require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"n1ID3u":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, exports, define, browserify_shim__define__module__export__) {
(function(i){var e="0.3.4",j="hasOwnProperty",b=/[\.\/]/,a="*",g=function(){},f=function(m,l){return m-l},d,h,k={n:{}},c=function(m,C){var v=k,s=h,w=Array.prototype.slice.call(arguments,2),y=c.listeners(m),x=0,u=false,p,o=[],t={},q=[],n=d,A=[];d=m;h=0;for(var r=0,B=y.length;r<B;r++){if("zIndex" in y[r]){o.push(y[r].zIndex);if(y[r].zIndex<0){t[y[r].zIndex]=y[r]}}}o.sort(f);while(o[x]<0){p=t[o[x++]];q.push(p.apply(C,w));if(h){h=s;return q}}for(r=0;r<B;r++){p=y[r];if("zIndex" in p){if(p.zIndex==o[x]){q.push(p.apply(C,w));if(h){break}do{x++;p=t[o[x]];p&&q.push(p.apply(C,w));if(h){break}}while(p)}else{t[p.zIndex]=p}}else{q.push(p.apply(C,w));if(h){break}}}h=s;d=n;return q.length?q:null};c.listeners=function(l){var t=l.split(b),r=k,x,s,m,p,w,o,q,u,v=[r],n=[];for(p=0,w=t.length;p<w;p++){u=[];for(o=0,q=v.length;o<q;o++){r=v[o].n;s=[r[t[p]],r[a]];m=2;while(m--){x=s[m];if(x){u.push(x);n=n.concat(x.f||[])}}}v=u}return n};c.on=function(l,o){var q=l.split(b),p=k;for(var m=0,n=q.length;m<n;m++){p=p.n;!p[q[m]]&&(p[q[m]]={n:{}});p=p[q[m]]}p.f=p.f||[];for(m=0,n=p.f.length;m<n;m++){if(p.f[m]==o){return g}}p.f.push(o);return function(r){if(+r==+r){o.zIndex=+r}}};c.stop=function(){h=1};c.nt=function(l){if(l){return new RegExp("(?:\\.|\\/|^)"+l+"(?:\\.|\\/|$)").test(d)}return d};c.off=c.unbind=function(m,r){var t=m.split(b),s,v,n,p,w,o,q,u=[k];for(p=0,w=t.length;p<w;p++){for(o=0;o<u.length;o+=n.length-2){n=[o,1];s=u[o].n;if(t[p]!=a){if(s[t[p]]){n.push(s[t[p]])}}else{for(v in s){if(s[j](v)){n.push(s[v])}}}u.splice.apply(u,n)}}for(p=0,w=u.length;p<w;p++){s=u[p];while(s.n){if(r){if(s.f){for(o=0,q=s.f.length;o<q;o++){if(s.f[o]==r){s.f.splice(o,1);break}}!s.f.length&&delete s.f}for(v in s.n){if(s.n[j](v)&&s.n[v].f){var l=s.n[v].f;for(o=0,q=l.length;o<q;o++){if(l[o]==r){l.splice(o,1);break}}!l.length&&delete s.n[v].f}}}else{delete s.f;for(v in s.n){if(s.n[j](v)&&s.n[v].f){delete s.n[v].f}}}s=s.n}}};c.once=function(l,m){var n=function(){var o=m.apply(this,arguments);c.unbind(l,n);return o};return c.on(l,n)};c.version=e;c.toString=function(){return"You are running Eve "+e};(typeof module!="undefined"&&module.exports)?(module.exports=c):(typeof define!="undefined"?(define("eve",[],function(){return c})):(i.eve=c))})(this);(function(){function aR(g){if(aR.is(g,"function")){return ao?g():eve.on("raphael.DOMload",g)}else{if(aR.is(g,bd)){return aR._engine.create[bG](aR,g.splice(0,3+aR.is(g[0],aL))).add(g)}else{var b=Array.prototype.slice.call(arguments,0);if(aR.is(b[b.length-1],"function")){var d=b.pop();return ao?d.call(aR._engine.create[bG](aR,b)):eve.on("raphael.DOMload",function(){d.call(aR._engine.create[bG](aR,b))})}else{return aR._engine.create[bG](aR,arguments)}}}}aR.version="2.1.0";aR.eve=eve;var ao,a=/[, ]+/,bw={circle:1,rect:1,path:1,ellipse:1,text:1,image:1},br=/\{(\d+)\}/g,bJ="prototype",ak="hasOwnProperty",aA={doc:document,win:window},s={was:Object.prototype[ak].call(aA.win,"Raphael"),is:aA.win.Raphael},bF=function(){this.ca=this.customAttributes={}},a4,bo="appendChild",bG="apply",bE="concat",Z="createTouch" in aA.doc,aX="",aQ=" ",bH=String,F="split",Q="click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[F](aQ),bx={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},bK=bH.prototype.toLowerCase,au=Math,m=au.max,bm=au.min,aw=au.abs,bp=au.pow,aV=au.PI,aL="number",aj="string",bd="array",a5="toString",a9="fill",a1=Object.prototype.toString,bz={},j="push",f=aR._ISURL=/^url\(['"]?([^\)]+?)['"]?\)$/i,A=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,av={"NaN":1,"Infinity":1,"-Infinity":1},c=/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,ah=au.round,z="setAttribute",an=parseFloat,U=parseInt,bt=bH.prototype.toUpperCase,r=aR._availableAttrs={"arrow-end":"none","arrow-start":"none",blur:0,"clip-rect":"0 0 1e9 1e9",cursor:"default",cx:0,cy:0,fill:"#fff","fill-opacity":1,font:'10px "Arial"',"font-family":'"Arial"',"font-size":"10","font-style":"normal","font-weight":400,gradient:0,height:0,href:"http://raphaeljs.com/","letter-spacing":0,opacity:1,path:"M0,0",r:0,rx:0,ry:0,src:"",stroke:"#000","stroke-dasharray":"","stroke-linecap":"butt","stroke-linejoin":"butt","stroke-miterlimit":0,"stroke-opacity":1,"stroke-width":1,target:"_blank","text-anchor":"middle",title:"Raphael",transform:"",width:0,x:0,y:0},ar=aR._availableAnimAttrs={blur:aL,"clip-rect":"csv",cx:aL,cy:aL,fill:"colour","fill-opacity":aL,"font-size":aL,height:aL,opacity:aL,path:"path",r:aL,rx:aL,ry:aL,stroke:"colour","stroke-opacity":aL,"stroke-width":aL,transform:"transform",width:aL,x:aL,y:aL},ac=/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,bi=/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,n={hs:1,rg:1},bg=/,?([achlmqrstvxz]),?/gi,a0=/([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,ai=/([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,aP=/(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,aW=aR._radial_gradient=/^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,aU={},bq=function(g,d){return g.key-d.key},u=function(g,d){return an(g)-an(d)},I=function(){},bB=function(b){return b
},az=aR._rectPath=function(b,E,d,g,i){if(i){return[["M",b+i,E],["l",d-i*2,0],["a",i,i,0,0,1,i,i],["l",0,g-i*2],["a",i,i,0,0,1,-i,i],["l",i*2-d,0],["a",i,i,0,0,1,-i,-i],["l",0,i*2-g],["a",i,i,0,0,1,i,-i],["z"]]}return[["M",b,E],["l",d,0],["l",0,g],["l",-d,0],["z"]]},K=function(b,i,g,d){if(d==null){d=g}return[["M",b,i],["m",0,-d],["a",g,d,0,1,1,0,2*d],["a",g,d,0,1,1,0,-2*d],["z"]]},N=aR._getPath={path:function(b){return b.attr("path")},circle:function(d){var b=d.attrs;return K(b.cx,b.cy,b.r)},ellipse:function(d){var b=d.attrs;return K(b.cx,b.cy,b.rx,b.ry)},rect:function(d){var b=d.attrs;return az(b.x,b.y,b.width,b.height,b.r)},image:function(d){var b=d.attrs;return az(b.x,b.y,b.width,b.height)},text:function(b){var d=b._getBBox();return az(d.x,d.y,d.width,d.height)}},L=aR.mapPath=function(bN,S){if(!S){return bN}var bL,R,g,b,bM,E,d;bN=W(bN);for(g=0,bM=bN.length;g<bM;g++){d=bN[g];for(b=1,E=d.length;b<E;b+=2){bL=S.x(d[b],d[b+1]);R=S.y(d[b],d[b+1]);d[b]=bL;d[b+1]=R}}return bN};aR._g=aA;aR.type=(aA.win.SVGAngle||aA.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML");if(aR.type=="VML"){var aE=aA.doc.createElement("div"),aH;aE.innerHTML='<v:shape adj="1"/>';aH=aE.firstChild;aH.style.behavior="url(#default#VML)";if(!(aH&&typeof aH.adj=="object")){return(aR.type=aX)}aE=null}aR.svg=!(aR.vml=aR.type=="VML");aR._Paper=bF;aR.fn=a4=bF.prototype=aR.prototype;aR._id=0;aR._oid=0;aR.is=function(d,b){b=bK.call(b);if(b=="finite"){return !av[ak](+d)}if(b=="array"){return d instanceof Array}return(b=="null"&&d===null)||(b==typeof d&&d!==null)||(b=="object"&&d===Object(d))||(b=="array"&&Array.isArray&&Array.isArray(d))||a1.call(d).slice(8,-1).toLowerCase()==b};function X(g){if(Object(g)!==g){return g}var d=new g.constructor;for(var b in g){if(g[ak](b)){d[b]=X(g[b])}}return d}aR.angle=function(E,S,g,R,d,i){if(d==null){var b=E-g,bL=S-R;if(!b&&!bL){return 0}return(180+au.atan2(-bL,-b)*180/aV+360)%360}else{return aR.angle(E,S,d,i)-aR.angle(g,R,d,i)}};aR.rad=function(b){return b%360*aV/180};aR.deg=function(b){return b*180/aV%360};aR.snapTo=function(d,E,b){b=aR.is(b,"finite")?b:10;if(aR.is(d,bd)){var g=d.length;while(g--){if(aw(d[g]-E)<=b){return d[g]}}}else{d=+d;var R=E%d;if(R<b){return E-R}if(R>d-b){return E-R+d}}return E};var h=aR.createUUID=(function(b,d){return function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(b,d).toUpperCase()}})(/[xy]/g,function(g){var d=au.random()*16|0,b=g=="x"?d:(d&3|8);return b.toString(16)});aR.setWindow=function(b){eve("raphael.setWindow",aR,aA.win,b);aA.win=b;aA.doc=aA.win.document;if(aR._engine.initWin){aR._engine.initWin(aA.win)}};var bf=function(g){if(aR.vml){var b=/^\s+|\s+$/g;var R;try{var S=new ActiveXObject("htmlfile");S.write("<body>");S.close();R=S.body}catch(bL){R=createPopup().document.body}var d=R.createTextRange();bf=aG(function(i){try{R.style.color=bH(i).replace(b,aX);var bM=d.queryCommandValue("ForeColor");bM=((bM&255)<<16)|(bM&65280)|((bM&16711680)>>>16);return"#"+("000000"+bM.toString(16)).slice(-6)}catch(bN){return"none"}})}else{var E=aA.doc.createElement("i");E.title="Rapha\xebl Colour Picker";E.style.display="none";aA.doc.body.appendChild(E);bf=aG(function(i){E.style.color=i;return aA.doc.defaultView.getComputedStyle(E,aX).getPropertyValue("color")})}return bf(g)},aI=function(){return"hsb("+[this.h,this.s,this.b]+")"},M=function(){return"hsl("+[this.h,this.s,this.l]+")"},x=function(){return this.hex},aY=function(R,E,d){if(E==null&&aR.is(R,"object")&&"r" in R&&"g" in R&&"b" in R){d=R.b;E=R.g;R=R.r}if(E==null&&aR.is(R,aj)){var i=aR.getRGB(R);R=i.r;E=i.g;d=i.b}if(R>1||E>1||d>1){R/=255;E/=255;d/=255}return[R,E,d]},a2=function(R,E,d,S){R*=255;E*=255;d*=255;var i={r:R,g:E,b:d,hex:aR.rgb(R,E,d),toString:x};aR.is(S,"finite")&&(i.opacity=S);return i};aR.color=function(b){var d;if(aR.is(b,"object")&&"h" in b&&"s" in b&&"b" in b){d=aR.hsb2rgb(b);b.r=d.r;b.g=d.g;b.b=d.b;b.hex=d.hex}else{if(aR.is(b,"object")&&"h" in b&&"s" in b&&"l" in b){d=aR.hsl2rgb(b);b.r=d.r;b.g=d.g;b.b=d.b;b.hex=d.hex}else{if(aR.is(b,"string")){b=aR.getRGB(b)}if(aR.is(b,"object")&&"r" in b&&"g" in b&&"b" in b){d=aR.rgb2hsl(b);b.h=d.h;b.s=d.s;b.l=d.l;d=aR.rgb2hsb(b);b.v=d.b}else{b={hex:"none"};b.r=b.g=b.b=b.h=b.s=b.v=b.l=-1}}}b.toString=x;return b};aR.hsb2rgb=function(S,bN,bL,i){if(this.is(S,"object")&&"h" in S&&"s" in S&&"b" in S){bL=S.b;bN=S.s;S=S.h;i=S.o}S*=360;var E,bM,d,g,b;S=(S%360)/60;b=bL*bN;g=b*(1-aw(S%2-1));E=bM=d=bL-b;S=~~S;E+=[b,g,0,0,g,b][S];bM+=[g,b,b,g,0,0][S];d+=[0,0,g,b,b,g][S];return a2(E,bM,d,i)};aR.hsl2rgb=function(bL,bN,E,i){if(this.is(bL,"object")&&"h" in bL&&"s" in bL&&"l" in bL){E=bL.l;bN=bL.s;bL=bL.h}if(bL>1||bN>1||E>1){bL/=360;bN/=100;E/=100}bL*=360;var S,bM,d,g,b;bL=(bL%360)/60;b=2*bN*(E<0.5?E:1-E);g=b*(1-aw(bL%2-1));S=bM=d=E-b/2;bL=~~bL;S+=[b,g,0,0,g,b][bL];bM+=[g,b,b,g,0,0][bL];d+=[0,0,g,b,b,g][bL];return a2(S,bM,d,i)};aR.rgb2hsb=function(bM,bL,d){d=aY(bM,bL,d);bM=d[0];bL=d[1];d=d[2];var R,E,i,bN;i=m(bM,bL,d);bN=i-bm(bM,bL,d);R=(bN==0?null:i==bM?(bL-d)/bN:i==bL?(d-bM)/bN+2:(bM-bL)/bN+4);R=((R+360)%6)*60/360;E=bN==0?0:bN/i;return{h:R,s:E,b:i,toString:aI}};aR.rgb2hsl=function(d,bL,bO){bO=aY(d,bL,bO);d=bO[0];bL=bO[1];bO=bO[2];var bP,R,bN,bM,E,i;bM=m(d,bL,bO);E=bm(d,bL,bO);i=bM-E;bP=(i==0?null:bM==d?(bL-bO)/i:bM==bL?(bO-d)/i+2:(d-bL)/i+4);bP=((bP+360)%6)*60/360;bN=(bM+E)/2;R=(i==0?0:bN<0.5?i/(2*bN):i/(2-2*bN));return{h:bP,s:R,l:bN,toString:M}};aR._path2string=function(){return this.join(",").replace(bg,"$1")};function bk(E,g){for(var b=0,d=E.length;b<d;b++){if(E[b]===g){return E.push(E.splice(b,1)[0])}}}function aG(i,d,b){function g(){var E=Array.prototype.slice.call(arguments,0),S=E.join("\u2400"),R=g.cache=g.cache||{},bL=g.count=g.count||[];if(R[ak](S)){bk(bL,S);return b?b(R[S]):R[S]}bL.length>=1000&&delete R[bL.shift()];bL.push(S);R[S]=i[bG](d,E);return b?b(R[S]):R[S]}return g}var bv=aR._preload=function(g,d){var b=aA.doc.createElement("img");b.style.cssText="position:absolute;left:-9999em;top:-9999em";b.onload=function(){d.call(this);this.onload=null;aA.doc.body.removeChild(this)};b.onerror=function(){aA.doc.body.removeChild(this)};aA.doc.body.appendChild(b);b.src=g};function aq(){return this.hex}aR.getRGB=aG(function(b){if(!b||!!((b=bH(b)).indexOf("-")+1)){return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:aq}}if(b=="none"){return{r:-1,g:-1,b:-1,hex:"none",toString:aq}}!(n[ak](b.toLowerCase().substring(0,2))||b.charAt()=="#")&&(b=bf(b));var E,d,g,S,i,bM,bL,R=b.match(A);if(R){if(R[2]){S=U(R[2].substring(5),16);g=U(R[2].substring(3,5),16);d=U(R[2].substring(1,3),16)}if(R[3]){S=U((bM=R[3].charAt(3))+bM,16);g=U((bM=R[3].charAt(2))+bM,16);d=U((bM=R[3].charAt(1))+bM,16)}if(R[4]){bL=R[4][F](bi);d=an(bL[0]);bL[0].slice(-1)=="%"&&(d*=2.55);g=an(bL[1]);bL[1].slice(-1)=="%"&&(g*=2.55);S=an(bL[2]);bL[2].slice(-1)=="%"&&(S*=2.55);R[1].toLowerCase().slice(0,4)=="rgba"&&(i=an(bL[3]));bL[3]&&bL[3].slice(-1)=="%"&&(i/=100)}if(R[5]){bL=R[5][F](bi);d=an(bL[0]);bL[0].slice(-1)=="%"&&(d*=2.55);g=an(bL[1]);bL[1].slice(-1)=="%"&&(g*=2.55);
S=an(bL[2]);bL[2].slice(-1)=="%"&&(S*=2.55);(bL[0].slice(-3)=="deg"||bL[0].slice(-1)=="\xb0")&&(d/=360);R[1].toLowerCase().slice(0,4)=="hsba"&&(i=an(bL[3]));bL[3]&&bL[3].slice(-1)=="%"&&(i/=100);return aR.hsb2rgb(d,g,S,i)}if(R[6]){bL=R[6][F](bi);d=an(bL[0]);bL[0].slice(-1)=="%"&&(d*=2.55);g=an(bL[1]);bL[1].slice(-1)=="%"&&(g*=2.55);S=an(bL[2]);bL[2].slice(-1)=="%"&&(S*=2.55);(bL[0].slice(-3)=="deg"||bL[0].slice(-1)=="\xb0")&&(d/=360);R[1].toLowerCase().slice(0,4)=="hsla"&&(i=an(bL[3]));bL[3]&&bL[3].slice(-1)=="%"&&(i/=100);return aR.hsl2rgb(d,g,S,i)}R={r:d,g:g,b:S,toString:aq};R.hex="#"+(16777216|S|(g<<8)|(d<<16)).toString(16).slice(1);aR.is(i,"finite")&&(R.opacity=i);return R}return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:aq}},aR);aR.hsb=aG(function(i,g,d){return aR.hsb2rgb(i,g,d).hex});aR.hsl=aG(function(g,d,b){return aR.hsl2rgb(g,d,b).hex});aR.rgb=aG(function(E,i,d){return"#"+(16777216|d|(i<<8)|(E<<16)).toString(16).slice(1)});aR.getColor=function(d){var g=this.getColor.start=this.getColor.start||{h:0,s:1,b:d||0.75},b=this.hsb2rgb(g.h,g.s,g.b);g.h+=0.075;if(g.h>1){g.h=0;g.s-=0.2;g.s<=0&&(this.getColor.start={h:0,s:1,b:g.b})}return b.hex};aR.getColor.reset=function(){delete this.start};function bb(E,bL){var S=[];for(var g=0,b=E.length;b-2*!bL>g;g+=2){var R=[{x:+E[g-2],y:+E[g-1]},{x:+E[g],y:+E[g+1]},{x:+E[g+2],y:+E[g+3]},{x:+E[g+4],y:+E[g+5]}];if(bL){if(!g){R[0]={x:+E[b-2],y:+E[b-1]}}else{if(b-4==g){R[3]={x:+E[0],y:+E[1]}}else{if(b-2==g){R[2]={x:+E[0],y:+E[1]};R[3]={x:+E[2],y:+E[3]}}}}}else{if(b-4==g){R[3]=R[2]}else{if(!g){R[0]={x:+E[g],y:+E[g+1]}}}}S.push(["C",(-R[0].x+6*R[1].x+R[2].x)/6,(-R[0].y+6*R[1].y+R[2].y)/6,(R[1].x+6*R[2].x-R[3].x)/6,(R[1].y+6*R[2].y-R[3].y)/6,R[2].x,R[2].y])}return S}aR.parsePathString=function(b){if(!b){return null}var g=Y(b);if(g.arr){return aZ(g.arr)}var i={a:7,c:6,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,z:0},d=[];if(aR.is(b,bd)&&aR.is(b[0],bd)){d=aZ(b)}if(!d.length){bH(b).replace(a0,function(R,E,bM){var bL=[],S=E.toLowerCase();bM.replace(aP,function(bO,bN){bN&&bL.push(+bN)});if(S=="m"&&bL.length>2){d.push([E][bE](bL.splice(0,2)));S="l";E=E=="m"?"l":"L"}if(S=="r"){d.push([E][bE](bL))}else{while(bL.length>=i[S]){d.push([E][bE](bL.splice(0,i[S])));if(!i[S]){break}}}})}d.toString=aR._path2string;g.arr=aZ(d);return d};aR.parseTransformString=aG(function(d){if(!d){return null}var g={r:3,s:4,t:2,m:6},b=[];if(aR.is(d,bd)&&aR.is(d[0],bd)){b=aZ(d)}if(!b.length){bH(d).replace(ai,function(E,i,bL){var S=[],R=bK.call(i);bL.replace(aP,function(bN,bM){bM&&S.push(+bM)});b.push([i][bE](S))})}b.toString=aR._path2string;return b});var Y=function(d){var b=Y.ps=Y.ps||{};if(b[d]){b[d].sleep=100}else{b[d]={sleep:100}}setTimeout(function(){for(var g in b){if(b[ak](g)&&g!=d){b[g].sleep--;!b[g].sleep&&delete b[g]}}});return b[d]};aR.findDotsAtSegment=function(d,b,b2,b0,S,E,bN,bL,bV){var bS=1-bV,bX=bp(bS,3),bY=bp(bS,2),bP=bV*bV,bM=bP*bV,bR=bX*d+bY*3*bV*b2+bS*3*bV*bV*S+bM*bN,bO=bX*b+bY*3*bV*b0+bS*3*bV*bV*E+bM*bL,bW=d+2*bV*(b2-d)+bP*(S-2*b2+d),bU=b+2*bV*(b0-b)+bP*(E-2*b0+b),b1=b2+2*bV*(S-b2)+bP*(bN-2*S+b2),bZ=b0+2*bV*(E-b0)+bP*(bL-2*E+b0),bT=bS*d+bV*b2,bQ=bS*b+bV*b0,i=bS*S+bV*bN,g=bS*E+bV*bL,R=(90-au.atan2(bW-b1,bU-bZ)*180/aV);(bW>b1||bU<bZ)&&(R+=180);return{x:bR,y:bO,m:{x:bW,y:bU},n:{x:b1,y:bZ},start:{x:bT,y:bQ},end:{x:i,y:g},alpha:R}};aR.bezierBBox=function(d,b,i,g,bM,S,R,E){if(!aR.is(d,"array")){d=[d,b,i,g,bM,S,R,E]}var bL=ba.apply(null,d);return{x:bL.min.x,y:bL.min.y,x2:bL.max.x,y2:bL.max.y,width:bL.max.x-bL.min.x,height:bL.max.y-bL.min.y}};aR.isPointInsideBBox=function(d,b,g){return b>=d.x&&b<=d.x2&&g>=d.y&&g<=d.y2};aR.isBBoxIntersect=function(g,d){var b=aR.isPointInsideBBox;return b(d,g.x,g.y)||b(d,g.x2,g.y)||b(d,g.x,g.y2)||b(d,g.x2,g.y2)||b(g,d.x,d.y)||b(g,d.x2,d.y)||b(g,d.x,d.y2)||b(g,d.x2,d.y2)||(g.x<d.x2&&g.x>d.x||d.x<g.x2&&d.x>g.x)&&(g.y<d.y2&&g.y>d.y||d.y<g.y2&&d.y>g.y)};function bj(b,S,R,E,i){var g=-3*S+9*R-9*E+3*i,d=b*g+6*S-12*R+6*E;return b*d-3*S+3*R}function q(bW,R,bV,g,bU,d,bR,b,bO){if(bO==null){bO=1}bO=bO>1?1:bO<0?0:bO;var bP=bO/2,bQ=12,bL=[-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],bT=[0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],E=0;for(var bS=0;bS<bQ;bS++){var bM=bP*bL[bS]+bP,bN=bj(bM,bW,bV,bU,bR),bX=bj(bM,R,g,d,b),S=bN*bN+bX*bX;E+=bT[bS]*au.sqrt(S)}return bP*E}function C(g,bP,d,bO,b,bM,bR,bL,bN){if(bN<0||q(g,bP,d,bO,b,bM,bR,bL)<bN){return}var bQ=1,i=bQ/2,R=bQ-i,E,S=0.01;E=q(g,bP,d,bO,b,bM,bR,bL,R);while(aw(E-bN)>S){i/=2;R+=(E<bN?1:-1)*i;E=q(g,bP,d,bO,b,bM,bR,bL,R)}return R}function O(i,bQ,g,bO,b,bN,bS,bM){if(m(i,g)<bm(b,bS)||bm(i,g)>m(b,bS)||m(bQ,bO)<bm(bN,bM)||bm(bQ,bO)>m(bN,bM)){return}var bL=(i*bO-bQ*g)*(b-bS)-(i-g)*(b*bM-bN*bS),S=(i*bO-bQ*g)*(bN-bM)-(bQ-bO)*(b*bM-bN*bS),E=(i-g)*(bN-bM)-(bQ-bO)*(b-bS);if(!E){return}var bR=bL/E,bP=S/E,R=+bR.toFixed(2),d=+bP.toFixed(2);if(R<+bm(i,g).toFixed(2)||R>+m(i,g).toFixed(2)||R<+bm(b,bS).toFixed(2)||R>+m(b,bS).toFixed(2)||d<+bm(bQ,bO).toFixed(2)||d>+m(bQ,bO).toFixed(2)||d<+bm(bN,bM).toFixed(2)||d>+m(bN,bM).toFixed(2)){return}return{x:bR,y:bP}}function ay(d,b){return af(d,b)}function t(d,b){return af(d,b,1)}function af(b2,b1,b0){var E=aR.bezierBBox(b2),d=aR.bezierBBox(b1);if(!aR.isBBoxIntersect(E,d)){return b0?0:[]}var bV=q.apply(0,b2),bU=q.apply(0,b1),bM=~~(bV/5),bL=~~(bU/5),bS=[],bR=[],g={},b3=b0?0:[];for(var bX=0;bX<bM+1;bX++){var bT=aR.findDotsAtSegment.apply(aR,b2.concat(bX/bM));bS.push({x:bT.x,y:bT.y,t:bX/bM})}for(bX=0;bX<bL+1;bX++){bT=aR.findDotsAtSegment.apply(aR,b1.concat(bX/bL));bR.push({x:bT.x,y:bT.y,t:bX/bL})}for(bX=0;bX<bM;bX++){for(var bW=0;bW<bL;bW++){var bZ=bS[bX],b=bS[bX+1],bY=bR[bW],S=bR[bW+1],bQ=aw(b.x-bZ.x)<0.001?"y":"x",bP=aw(S.x-bY.x)<0.001?"y":"x",R=O(bZ.x,bZ.y,b.x,b.y,bY.x,bY.y,S.x,S.y);if(R){if(g[R.x.toFixed(4)]==R.y.toFixed(4)){continue}g[R.x.toFixed(4)]=R.y.toFixed(4);var bO=bZ.t+aw((R[bQ]-bZ[bQ])/(b[bQ]-bZ[bQ]))*(b.t-bZ.t),bN=bY.t+aw((R[bP]-bY[bP])/(S[bP]-bY[bP]))*(S.t-bY.t);if(bO>=0&&bO<=1&&bN>=0&&bN<=1){if(b0){b3++}else{b3.push({x:R.x,y:R.y,t1:bO,t2:bN})}}}}}return b3}aR.pathIntersection=function(d,b){return D(d,b)};aR.pathIntersectionNumber=function(d,b){return D(d,b,1)};function D(g,b,bW){g=aR._path2curve(g);b=aR._path2curve(b);var bU,S,bT,E,bR,bL,d,bO,b0,bZ,b1=bW?0:[];for(var bS=0,bM=g.length;bS<bM;bS++){var bY=g[bS];if(bY[0]=="M"){bU=bR=bY[1];S=bL=bY[2]}else{if(bY[0]=="C"){b0=[bU,S].concat(bY.slice(1));bU=b0[6];S=b0[7]}else{b0=[bU,S,bU,S,bR,bL,bR,bL];bU=bR;S=bL}for(var bQ=0,bV=b.length;bQ<bV;bQ++){var bX=b[bQ];if(bX[0]=="M"){bT=d=bX[1];E=bO=bX[2]}else{if(bX[0]=="C"){bZ=[bT,E].concat(bX.slice(1));bT=bZ[6];E=bZ[7]}else{bZ=[bT,E,bT,E,d,bO,d,bO];bT=d;E=bO}var bN=af(b0,bZ,bW);if(bW){b1+=bN}else{for(var bP=0,R=bN.length;bP<R;bP++){bN[bP].segment1=bS;bN[bP].segment2=bQ;bN[bP].bez1=b0;bN[bP].bez2=bZ}b1=b1.concat(bN)}}}}}return b1}aR.isPointInsidePath=function(d,b,i){var g=aR.pathBBox(d);return aR.isPointInsideBBox(g,b,i)&&D(d,[["M",b,i],["H",g.x2+10]],1)%2==1};aR._removedFactory=function(b){return function(){eve("raphael.log",null,"Rapha\xebl: you are calling to method \u201c"+b+"\u201d of removed object",b)
}};var am=aR.pathBBox=function(bT){var bN=Y(bT);if(bN.bbox){return bN.bbox}if(!bT){return{x:0,y:0,width:0,height:0,x2:0,y2:0}}bT=W(bT);var bQ=0,bP=0,R=[],d=[],g;for(var bL=0,bS=bT.length;bL<bS;bL++){g=bT[bL];if(g[0]=="M"){bQ=g[1];bP=g[2];R.push(bQ);d.push(bP)}else{var bM=ba(bQ,bP,g[1],g[2],g[3],g[4],g[5],g[6]);R=R[bE](bM.min.x,bM.max.x);d=d[bE](bM.min.y,bM.max.y);bQ=g[5];bP=g[6]}}var b=bm[bG](0,R),bR=bm[bG](0,d),S=m[bG](0,R),E=m[bG](0,d),bO={x:b,y:bR,x2:S,y2:E,width:S-b,height:E-bR};bN.bbox=X(bO);return bO},aZ=function(d){var b=X(d);b.toString=aR._path2string;return b},aC=aR._pathToRelative=function(E){var bM=Y(E);if(bM.rel){return aZ(bM.rel)}if(!aR.is(E,bd)||!aR.is(E&&E[0],bd)){E=aR.parsePathString(E)}var bP=[],bR=0,bQ=0,bU=0,bT=0,g=0;if(E[0][0]=="M"){bR=E[0][1];bQ=E[0][2];bU=bR;bT=bQ;g++;bP.push(["M",bR,bQ])}for(var bL=g,bV=E.length;bL<bV;bL++){var b=bP[bL]=[],bS=E[bL];if(bS[0]!=bK.call(bS[0])){b[0]=bK.call(bS[0]);switch(b[0]){case"a":b[1]=bS[1];b[2]=bS[2];b[3]=bS[3];b[4]=bS[4];b[5]=bS[5];b[6]=+(bS[6]-bR).toFixed(3);b[7]=+(bS[7]-bQ).toFixed(3);break;case"v":b[1]=+(bS[1]-bQ).toFixed(3);break;case"m":bU=bS[1];bT=bS[2];default:for(var S=1,bN=bS.length;S<bN;S++){b[S]=+(bS[S]-((S%2)?bR:bQ)).toFixed(3)}}}else{b=bP[bL]=[];if(bS[0]=="m"){bU=bS[1]+bR;bT=bS[2]+bQ}for(var R=0,d=bS.length;R<d;R++){bP[bL][R]=bS[R]}}var bO=bP[bL].length;switch(bP[bL][0]){case"z":bR=bU;bQ=bT;break;case"h":bR+=+bP[bL][bO-1];break;case"v":bQ+=+bP[bL][bO-1];break;default:bR+=+bP[bL][bO-2];bQ+=+bP[bL][bO-1]}}bP.toString=aR._path2string;bM.rel=aZ(bP);return bP},w=aR._pathToAbsolute=function(bQ){var g=Y(bQ);if(g.abs){return aZ(g.abs)}if(!aR.is(bQ,bd)||!aR.is(bQ&&bQ[0],bd)){bQ=aR.parsePathString(bQ)}if(!bQ||!bQ.length){return[["M",0,0]]}var bW=[],bL=0,S=0,bO=0,bN=0,E=0;if(bQ[0][0]=="M"){bL=+bQ[0][1];S=+bQ[0][2];bO=bL;bN=S;E++;bW[0]=["M",bL,S]}var bV=bQ.length==3&&bQ[0][0]=="M"&&bQ[1][0].toUpperCase()=="R"&&bQ[2][0].toUpperCase()=="Z";for(var bP,b,bT=E,bM=bQ.length;bT<bM;bT++){bW.push(bP=[]);b=bQ[bT];if(b[0]!=bt.call(b[0])){bP[0]=bt.call(b[0]);switch(bP[0]){case"A":bP[1]=b[1];bP[2]=b[2];bP[3]=b[3];bP[4]=b[4];bP[5]=b[5];bP[6]=+(b[6]+bL);bP[7]=+(b[7]+S);break;case"V":bP[1]=+b[1]+S;break;case"H":bP[1]=+b[1]+bL;break;case"R":var R=[bL,S][bE](b.slice(1));for(var bS=2,bU=R.length;bS<bU;bS++){R[bS]=+R[bS]+bL;R[++bS]=+R[bS]+S}bW.pop();bW=bW[bE](bb(R,bV));break;case"M":bO=+b[1]+bL;bN=+b[2]+S;default:for(bS=1,bU=b.length;bS<bU;bS++){bP[bS]=+b[bS]+((bS%2)?bL:S)}}}else{if(b[0]=="R"){R=[bL,S][bE](b.slice(1));bW.pop();bW=bW[bE](bb(R,bV));bP=["R"][bE](b.slice(-2))}else{for(var bR=0,d=b.length;bR<d;bR++){bP[bR]=b[bR]}}}switch(bP[0]){case"Z":bL=bO;S=bN;break;case"H":bL=bP[1];break;case"V":S=bP[1];break;case"M":bO=bP[bP.length-2];bN=bP[bP.length-1];default:bL=bP[bP.length-2];S=bP[bP.length-1]}}bW.toString=aR._path2string;g.abs=aZ(bW);return bW},bI=function(d,i,b,g){return[d,i,b,g,b,g]},bn=function(d,i,S,E,b,g){var R=1/3,bL=2/3;return[R*d+bL*S,R*i+bL*E,R*b+bL*S,R*g+bL*E,b,g]},ae=function(bS,cn,b1,bZ,bT,bN,E,bR,cm,bU){var bY=aV*120/180,b=aV/180*(+bT||0),b5=[],b2,cj=aG(function(co,cr,i){var cq=co*au.cos(i)-cr*au.sin(i),cp=co*au.sin(i)+cr*au.cos(i);return{x:cq,y:cp}});if(!bU){b2=cj(bS,cn,-b);bS=b2.x;cn=b2.y;b2=cj(bR,cm,-b);bR=b2.x;cm=b2.y;var d=au.cos(aV/180*bT),bP=au.sin(aV/180*bT),b7=(bS-bR)/2,b6=(cn-cm)/2;var ch=(b7*b7)/(b1*b1)+(b6*b6)/(bZ*bZ);if(ch>1){ch=au.sqrt(ch);b1=ch*b1;bZ=ch*bZ}var g=b1*b1,ca=bZ*bZ,cc=(bN==E?-1:1)*au.sqrt(aw((g*ca-g*b6*b6-ca*b7*b7)/(g*b6*b6+ca*b7*b7))),bW=cc*b1*b6/bZ+(bS+bR)/2,bV=cc*-bZ*b7/b1+(cn+cm)/2,bM=au.asin(((cn-bV)/bZ).toFixed(9)),bL=au.asin(((cm-bV)/bZ).toFixed(9));bM=bS<bW?aV-bM:bM;bL=bR<bW?aV-bL:bL;bM<0&&(bM=aV*2+bM);bL<0&&(bL=aV*2+bL);if(E&&bM>bL){bM=bM-aV*2}if(!E&&bL>bM){bL=bL-aV*2}}else{bM=bU[0];bL=bU[1];bW=bU[2];bV=bU[3]}var bQ=bL-bM;if(aw(bQ)>bY){var bX=bL,b0=bR,bO=cm;bL=bM+bY*(E&&bL>bM?1:-1);bR=bW+b1*au.cos(bL);cm=bV+bZ*au.sin(bL);b5=ae(bR,cm,b1,bZ,bT,0,E,b0,bO,[bL,bX,bW,bV])}bQ=bL-bM;var S=au.cos(bM),cl=au.sin(bM),R=au.cos(bL),ck=au.sin(bL),b8=au.tan(bQ/4),cb=4/3*b1*b8,b9=4/3*bZ*b8,ci=[bS,cn],cg=[bS+cb*cl,cn-b9*S],cf=[bR+cb*ck,cm-b9*R],cd=[bR,cm];cg[0]=2*ci[0]-cg[0];cg[1]=2*ci[1]-cg[1];if(bU){return[cg,cf,cd][bE](b5)}else{b5=[cg,cf,cd][bE](b5).join()[F](",");var b3=[];for(var ce=0,b4=b5.length;ce<b4;ce++){b3[ce]=ce%2?cj(b5[ce-1],b5[ce],b).y:cj(b5[ce],b5[ce+1],b).x}return b3}},ag=function(d,b,i,g,bM,bL,S,R,bN){var E=1-bN;return{x:bp(E,3)*d+bp(E,2)*3*bN*i+E*3*bN*bN*bM+bp(bN,3)*S,y:bp(E,3)*b+bp(E,2)*3*bN*g+E*3*bN*bN*bL+bp(bN,3)*R}},ba=aG(function(i,d,R,E,bU,bT,bQ,bN){var bS=(bU-2*R+i)-(bQ-2*bU+R),bP=2*(R-i)-2*(bU-R),bM=i-R,bL=(-bP+au.sqrt(bP*bP-4*bS*bM))/2/bS,S=(-bP-au.sqrt(bP*bP-4*bS*bM))/2/bS,bO=[d,bN],bR=[i,bQ],g;aw(bL)>"1e12"&&(bL=0.5);aw(S)>"1e12"&&(S=0.5);if(bL>0&&bL<1){g=ag(i,d,R,E,bU,bT,bQ,bN,bL);bR.push(g.x);bO.push(g.y)}if(S>0&&S<1){g=ag(i,d,R,E,bU,bT,bQ,bN,S);bR.push(g.x);bO.push(g.y)}bS=(bT-2*E+d)-(bN-2*bT+E);bP=2*(E-d)-2*(bT-E);bM=d-E;bL=(-bP+au.sqrt(bP*bP-4*bS*bM))/2/bS;S=(-bP-au.sqrt(bP*bP-4*bS*bM))/2/bS;aw(bL)>"1e12"&&(bL=0.5);aw(S)>"1e12"&&(S=0.5);if(bL>0&&bL<1){g=ag(i,d,R,E,bU,bT,bQ,bN,bL);bR.push(g.x);bO.push(g.y)}if(S>0&&S<1){g=ag(i,d,R,E,bU,bT,bQ,bN,S);bR.push(g.x);bO.push(g.y)}return{min:{x:bm[bG](0,bR),y:bm[bG](0,bO)},max:{x:m[bG](0,bR),y:m[bG](0,bO)}}}),W=aR._path2curve=aG(function(bU,bP){var bN=!bP&&Y(bU);if(!bP&&bN.curve){return aZ(bN.curve)}var E=w(bU),bQ=bP&&w(bP),bR={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},d={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},S=function(bV,bW){var i,bX;if(!bV){return["C",bW.x,bW.y,bW.x,bW.y,bW.x,bW.y]}!(bV[0] in {T:1,Q:1})&&(bW.qx=bW.qy=null);switch(bV[0]){case"M":bW.X=bV[1];bW.Y=bV[2];break;case"A":bV=["C"][bE](ae[bG](0,[bW.x,bW.y][bE](bV.slice(1))));break;case"S":i=bW.x+(bW.x-(bW.bx||bW.x));bX=bW.y+(bW.y-(bW.by||bW.y));bV=["C",i,bX][bE](bV.slice(1));break;case"T":bW.qx=bW.x+(bW.x-(bW.qx||bW.x));bW.qy=bW.y+(bW.y-(bW.qy||bW.y));bV=["C"][bE](bn(bW.x,bW.y,bW.qx,bW.qy,bV[1],bV[2]));break;case"Q":bW.qx=bV[1];bW.qy=bV[2];bV=["C"][bE](bn(bW.x,bW.y,bV[1],bV[2],bV[3],bV[4]));break;case"L":bV=["C"][bE](bI(bW.x,bW.y,bV[1],bV[2]));break;case"H":bV=["C"][bE](bI(bW.x,bW.y,bV[1],bW.y));break;case"V":bV=["C"][bE](bI(bW.x,bW.y,bW.x,bV[1]));break;case"Z":bV=["C"][bE](bI(bW.x,bW.y,bW.X,bW.Y));break}return bV},b=function(bV,bW){if(bV[bW].length>7){bV[bW].shift();var bX=bV[bW];while(bX.length){bV.splice(bW++,0,["C"][bE](bX.splice(0,6)))}bV.splice(bW,1);bS=m(E.length,bQ&&bQ.length||0)}},g=function(bZ,bY,bW,bV,bX){if(bZ&&bY&&bZ[bX][0]=="M"&&bY[bX][0]!="M"){bY.splice(bX,0,["M",bV.x,bV.y]);bW.bx=0;bW.by=0;bW.x=bZ[bX][1];bW.y=bZ[bX][2];bS=m(E.length,bQ&&bQ.length||0)}};for(var bM=0,bS=m(E.length,bQ&&bQ.length||0);bM<bS;bM++){E[bM]=S(E[bM],bR);b(E,bM);bQ&&(bQ[bM]=S(bQ[bM],d));bQ&&b(bQ,bM);g(E,bQ,bR,d,bM);g(bQ,E,d,bR,bM);var bL=E[bM],bT=bQ&&bQ[bM],R=bL.length,bO=bQ&&bT.length;bR.x=bL[R-2];bR.y=bL[R-1];bR.bx=an(bL[R-4])||bR.x;bR.by=an(bL[R-3])||bR.y;d.bx=bQ&&(an(bT[bO-4])||d.x);d.by=bQ&&(an(bT[bO-3])||d.y);d.x=bQ&&bT[bO-2];d.y=bQ&&bT[bO-1]}if(!bQ){bN.curve=aZ(E)
}return bQ?[E,bQ]:E},null,aZ),v=aR._parseDots=aG(function(bO){var bN=[];for(var S=0,bP=bO.length;S<bP;S++){var b={},bM=bO[S].match(/^([^:]*):?([\d\.]*)/);b.color=aR.getRGB(bM[1]);if(b.color.error){return null}b.color=b.color.hex;bM[2]&&(b.offset=bM[2]+"%");bN.push(b)}for(S=1,bP=bN.length-1;S<bP;S++){if(!bN[S].offset){var g=an(bN[S-1].offset||0),E=0;for(var R=S+1;R<bP;R++){if(bN[R].offset){E=bN[R].offset;break}}if(!E){E=100;R=bP}E=an(E);var bL=(E-g)/(R-S+1);for(;S<R;S++){g+=bL;bN[S].offset=g+"%"}}}return bN}),aK=aR._tear=function(b,d){b==d.top&&(d.top=b.prev);b==d.bottom&&(d.bottom=b.next);b.next&&(b.next.prev=b.prev);b.prev&&(b.prev.next=b.next)},ap=aR._tofront=function(b,d){if(d.top===b){return}aK(b,d);b.next=null;b.prev=d.top;d.top.next=b;d.top=b},p=aR._toback=function(b,d){if(d.bottom===b){return}aK(b,d);b.next=d.bottom;b.prev=null;d.bottom.prev=b;d.bottom=b},G=aR._insertafter=function(d,b,g){aK(d,g);b==g.top&&(g.top=d);b.next&&(b.next.prev=d);d.next=b.next;d.prev=b;b.next=d},aT=aR._insertbefore=function(d,b,g){aK(d,g);b==g.bottom&&(g.bottom=d);b.prev&&(b.prev.next=d);d.prev=b.prev;b.prev=d;d.next=b},bl=aR.toMatrix=function(g,b){var i=am(g),d={_:{transform:aX},getBBox:function(){return i}};aO(d,b);return d.matrix},T=aR.transformPath=function(d,b){return L(d,bl(d,b))},aO=aR._extractTransform=function(d,bZ){if(bZ==null){return d._.transform}bZ=bH(bZ).replace(/\.{3}|\u2026/g,d._.transform||aX);var bR=aR.parseTransformString(bZ),bP=0,bN=0,bM=0,bT=1,bS=1,b0=d._,bU=new aF;b0.transform=bR||[];if(bR){for(var bV=0,bO=bR.length;bV<bO;bV++){var bQ=bR[bV],b=bQ.length,R=bH(bQ[0]).toLowerCase(),bY=bQ[0]!=R,bL=bY?bU.invert():0,bX,E,bW,g,S;if(R=="t"&&b==3){if(bY){bX=bL.x(0,0);E=bL.y(0,0);bW=bL.x(bQ[1],bQ[2]);g=bL.y(bQ[1],bQ[2]);bU.translate(bW-bX,g-E)}else{bU.translate(bQ[1],bQ[2])}}else{if(R=="r"){if(b==2){S=S||d.getBBox(1);bU.rotate(bQ[1],S.x+S.width/2,S.y+S.height/2);bP+=bQ[1]}else{if(b==4){if(bY){bW=bL.x(bQ[2],bQ[3]);g=bL.y(bQ[2],bQ[3]);bU.rotate(bQ[1],bW,g)}else{bU.rotate(bQ[1],bQ[2],bQ[3])}bP+=bQ[1]}}}else{if(R=="s"){if(b==2||b==3){S=S||d.getBBox(1);bU.scale(bQ[1],bQ[b-1],S.x+S.width/2,S.y+S.height/2);bT*=bQ[1];bS*=bQ[b-1]}else{if(b==5){if(bY){bW=bL.x(bQ[3],bQ[4]);g=bL.y(bQ[3],bQ[4]);bU.scale(bQ[1],bQ[2],bW,g)}else{bU.scale(bQ[1],bQ[2],bQ[3],bQ[4])}bT*=bQ[1];bS*=bQ[2]}}}else{if(R=="m"&&b==7){bU.add(bQ[1],bQ[2],bQ[3],bQ[4],bQ[5],bQ[6])}}}}b0.dirtyT=1;d.matrix=bU}}d.matrix=bU;b0.sx=bT;b0.sy=bS;b0.deg=bP;b0.dx=bN=bU.e;b0.dy=bM=bU.f;if(bT==1&&bS==1&&!bP&&b0.bbox){b0.bbox.x+=+bN;b0.bbox.y+=+bM}else{b0.dirtyT=1}},l=function(d){var b=d[0];switch(b.toLowerCase()){case"t":return[b,0,0];case"m":return[b,1,0,0,1,0,0];case"r":if(d.length==4){return[b,0,d[2],d[3]]}else{return[b,0]}case"s":if(d.length==5){return[b,1,1,d[3],d[4]]}else{if(d.length==3){return[b,1,1]}else{return[b,1]}}}},aB=aR._equaliseTransform=function(R,E){E=bH(E).replace(/\.{3}|\u2026/g,R);R=aR.parseTransformString(R)||[];E=aR.parseTransformString(E)||[];var b=m(R.length,E.length),bN=[],bO=[],g=0,d,S,bM,bL;for(;g<b;g++){bM=R[g]||l(E[g]);bL=E[g]||l(bM);if((bM[0]!=bL[0])||(bM[0].toLowerCase()=="r"&&(bM[2]!=bL[2]||bM[3]!=bL[3]))||(bM[0].toLowerCase()=="s"&&(bM[3]!=bL[3]||bM[4]!=bL[4]))){return}bN[g]=[];bO[g]=[];for(d=0,S=m(bM.length,bL.length);d<S;d++){d in bM&&(bN[g][d]=bM[d]);d in bL&&(bO[g][d]=bL[d])}}return{from:bN,to:bO}};aR._getContainer=function(b,E,g,i){var d;d=i==null&&!aR.is(b,"object")?aA.doc.getElementById(b):b;if(d==null){return}if(d.tagName){if(E==null){return{container:d,width:d.style.pixelWidth||d.offsetWidth,height:d.style.pixelHeight||d.offsetHeight}}else{return{container:d,width:E,height:g}}}return{container:1,x:b,y:E,width:g,height:i}};aR.pathToRelative=aC;aR._engine={};aR.path2curve=W;aR.matrix=function(i,g,bL,S,R,E){return new aF(i,g,bL,S,R,E)};function aF(i,g,bL,S,R,E){if(i!=null){this.a=+i;this.b=+g;this.c=+bL;this.d=+S;this.e=+R;this.f=+E}else{this.a=1;this.b=0;this.c=0;this.d=1;this.e=0;this.f=0}}(function(g){g.add=function(bT,bQ,bO,bM,S,R){var E=[[],[],[]],i=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],bS=[[bT,bO,S],[bQ,bM,R],[0,0,1]],bR,bP,bN,bL;if(bT&&bT instanceof aF){bS=[[bT.a,bT.c,bT.e],[bT.b,bT.d,bT.f],[0,0,1]]}for(bR=0;bR<3;bR++){for(bP=0;bP<3;bP++){bL=0;for(bN=0;bN<3;bN++){bL+=i[bR][bN]*bS[bN][bP]}E[bR][bP]=bL}}this.a=E[0][0];this.b=E[1][0];this.c=E[0][1];this.d=E[1][1];this.e=E[0][2];this.f=E[1][2]};g.invert=function(){var E=this,i=E.a*E.d-E.b*E.c;return new aF(E.d/i,-E.b/i,-E.c/i,E.a/i,(E.c*E.f-E.d*E.e)/i,(E.b*E.e-E.a*E.f)/i)};g.clone=function(){return new aF(this.a,this.b,this.c,this.d,this.e,this.f)};g.translate=function(i,E){this.add(1,0,0,1,i,E)};g.scale=function(E,S,i,R){S==null&&(S=E);(i||R)&&this.add(1,0,0,1,i,R);this.add(E,0,0,S,0,0);(i||R)&&this.add(1,0,0,1,-i,-R)};g.rotate=function(E,i,bL){E=aR.rad(E);i=i||0;bL=bL||0;var S=+au.cos(E).toFixed(9),R=+au.sin(E).toFixed(9);this.add(S,R,-R,S,i,bL);this.add(1,0,0,1,-i,-bL)};g.x=function(i,E){return i*this.a+E*this.c+this.e};g.y=function(i,E){return i*this.b+E*this.d+this.f};g.get=function(E){return +this[bH.fromCharCode(97+E)].toFixed(4)};g.toString=function(){return aR.svg?"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")":[this.get(0),this.get(2),this.get(1),this.get(3),0,0].join()};g.toFilter=function(){return"progid:DXImageTransform.Microsoft.Matrix(M11="+this.get(0)+", M12="+this.get(2)+", M21="+this.get(1)+", M22="+this.get(3)+", Dx="+this.get(4)+", Dy="+this.get(5)+", sizingmethod='auto expand')"};g.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]};function d(i){return i[0]*i[0]+i[1]*i[1]}function b(i){var E=au.sqrt(d(i));i[0]&&(i[0]/=E);i[1]&&(i[1]/=E)}g.split=function(){var E={};E.dx=this.e;E.dy=this.f;var S=[[this.a,this.c],[this.b,this.d]];E.scalex=au.sqrt(d(S[0]));b(S[0]);E.shear=S[0][0]*S[1][0]+S[0][1]*S[1][1];S[1]=[S[1][0]-S[0][0]*E.shear,S[1][1]-S[0][1]*E.shear];E.scaley=au.sqrt(d(S[1]));b(S[1]);E.shear/=E.scaley;var i=-S[0][1],R=S[1][1];if(R<0){E.rotate=aR.deg(au.acos(R));if(i<0){E.rotate=360-E.rotate}}else{E.rotate=aR.deg(au.asin(i))}E.isSimple=!+E.shear.toFixed(9)&&(E.scalex.toFixed(9)==E.scaley.toFixed(9)||!E.rotate);E.isSuperSimple=!+E.shear.toFixed(9)&&E.scalex.toFixed(9)==E.scaley.toFixed(9)&&!E.rotate;E.noRotation=!+E.shear.toFixed(9)&&!E.rotate;return E};g.toTransformString=function(i){var E=i||this[F]();if(E.isSimple){E.scalex=+E.scalex.toFixed(4);E.scaley=+E.scaley.toFixed(4);E.rotate=+E.rotate.toFixed(4);return(E.dx||E.dy?"t"+[E.dx,E.dy]:aX)+(E.scalex!=1||E.scaley!=1?"s"+[E.scalex,E.scaley,0,0]:aX)+(E.rotate?"r"+[E.rotate,0,0]:aX)}else{return"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]}}})(aF.prototype);var V=navigator.userAgent.match(/Version\/(.*?)\s/)||navigator.userAgent.match(/Chrome\/(\d+)/);if((navigator.vendor=="Apple Computer, Inc.")&&(V&&V[1]<4||navigator.platform.slice(0,2)=="iP")||(navigator.vendor=="Google Inc."&&V&&V[1]<8)){a4.safari=function(){var b=this.rect(-99,-99,this.width+99,this.height+99).attr({stroke:"none"});
setTimeout(function(){b.remove()})}}else{a4.safari=I}var P=function(){this.returnValue=false},bD=function(){return this.originalEvent.preventDefault()},a8=function(){this.cancelBubble=true},aJ=function(){return this.originalEvent.stopPropagation()},aD=(function(){if(aA.doc.addEventListener){return function(R,i,g,d){var b=Z&&bx[i]?bx[i]:i,E=function(bP){var bO=aA.doc.documentElement.scrollTop||aA.doc.body.scrollTop,bQ=aA.doc.documentElement.scrollLeft||aA.doc.body.scrollLeft,S=bP.clientX+bQ,bR=bP.clientY+bO;if(Z&&bx[ak](i)){for(var bM=0,bN=bP.targetTouches&&bP.targetTouches.length;bM<bN;bM++){if(bP.targetTouches[bM].target==R){var bL=bP;bP=bP.targetTouches[bM];bP.originalEvent=bL;bP.preventDefault=bD;bP.stopPropagation=aJ;break}}}return g.call(d,bP,S,bR)};R.addEventListener(b,E,false);return function(){R.removeEventListener(b,E,false);return true}}}else{if(aA.doc.attachEvent){return function(R,i,g,d){var E=function(bM){bM=bM||aA.win.event;var bL=aA.doc.documentElement.scrollTop||aA.doc.body.scrollTop,bN=aA.doc.documentElement.scrollLeft||aA.doc.body.scrollLeft,S=bM.clientX+bN,bO=bM.clientY+bL;bM.preventDefault=bM.preventDefault||P;bM.stopPropagation=bM.stopPropagation||a8;return g.call(d,bM,S,bO)};R.attachEvent("on"+i,E);var b=function(){R.detachEvent("on"+i,E);return true};return b}}}})(),be=[],by=function(bM){var bP=bM.clientX,bO=bM.clientY,bR=aA.doc.documentElement.scrollTop||aA.doc.body.scrollTop,bS=aA.doc.documentElement.scrollLeft||aA.doc.body.scrollLeft,g,E=be.length;while(E--){g=be[E];if(Z){var S=bM.touches.length,R;while(S--){R=bM.touches[S];if(R.identifier==g.el._drag.id){bP=R.clientX;bO=R.clientY;(bM.originalEvent?bM.originalEvent:bM).preventDefault();break}}}else{bM.preventDefault()}var d=g.el.node,b,bL=d.nextSibling,bQ=d.parentNode,bN=d.style.display;aA.win.opera&&bQ.removeChild(d);d.style.display="none";b=g.el.paper.getElementByPoint(bP,bO);d.style.display=bN;aA.win.opera&&(bL?bQ.insertBefore(d,bL):bQ.appendChild(d));b&&eve("raphael.drag.over."+g.el.id,g.el,b);bP+=bS;bO+=bR;eve("raphael.drag.move."+g.el.id,g.move_scope||g.el,bP-g.el._drag.x,bO-g.el._drag.y,bP,bO,bM)}},e=function(g){aR.unmousemove(by).unmouseup(e);var d=be.length,b;while(d--){b=be[d];b.el._drag={};eve("raphael.drag.end."+b.el.id,b.end_scope||b.start_scope||b.move_scope||b.el,g)}be=[]},bh=aR.el={};for(var ax=Q.length;ax--;){(function(b){aR[b]=bh[b]=function(g,d){if(aR.is(g,"function")){this.events=this.events||[];this.events.push({name:b,f:g,unbind:aD(this.shape||this.node||aA.doc,b,g,d||this)})}return this};aR["un"+b]=bh["un"+b]=function(i){var g=this.events||[],d=g.length;while(d--){if(g[d].name==b&&g[d].f==i){g[d].unbind();g.splice(d,1);!g.length&&delete this.events;return this}}return this}})(Q[ax])}bh.data=function(d,E){var g=aU[this.id]=aU[this.id]||{};if(arguments.length==1){if(aR.is(d,"object")){for(var b in d){if(d[ak](b)){this.data(b,d[b])}}return this}eve("raphael.data.get."+this.id,this,g[d],d);return g[d]}g[d]=E;eve("raphael.data.set."+this.id,this,E,d);return this};bh.removeData=function(b){if(b==null){aU[this.id]={}}else{aU[this.id]&&delete aU[this.id][b]}return this};bh.hover=function(i,b,g,d){return this.mouseover(i,g).mouseout(b,d||g)};bh.unhover=function(d,b){return this.unmouseover(d).unmouseout(b)};var bu=[];bh.drag=function(d,R,E,b,g,i){function S(bM){(bM.originalEvent||bM).preventDefault();var bL=aA.doc.documentElement.scrollTop||aA.doc.body.scrollTop,bN=aA.doc.documentElement.scrollLeft||aA.doc.body.scrollLeft;this._drag.x=bM.clientX+bN;this._drag.y=bM.clientY+bL;this._drag.id=bM.identifier;!be.length&&aR.mousemove(by).mouseup(e);be.push({el:this,move_scope:b,start_scope:g,end_scope:i});R&&eve.on("raphael.drag.start."+this.id,R);d&&eve.on("raphael.drag.move."+this.id,d);E&&eve.on("raphael.drag.end."+this.id,E);eve("raphael.drag.start."+this.id,g||b||this,bM.clientX+bN,bM.clientY+bL,bM)}this._drag={};bu.push({el:this,start:S});this.mousedown(S);return this};bh.onDragOver=function(b){b?eve.on("raphael.drag.over."+this.id,b):eve.unbind("raphael.drag.over."+this.id)};bh.undrag=function(){var b=bu.length;while(b--){if(bu[b].el==this){this.unmousedown(bu[b].start);bu.splice(b,1);eve.unbind("raphael.drag.*."+this.id)}}!bu.length&&aR.unmousemove(by).unmouseup(e)};a4.circle=function(b,i,g){var d=aR._engine.circle(this,b||0,i||0,g||0);this.__set__&&this.__set__.push(d);return d};a4.rect=function(b,R,d,i,E){var g=aR._engine.rect(this,b||0,R||0,d||0,i||0,E||0);this.__set__&&this.__set__.push(g);return g};a4.ellipse=function(b,E,i,g){var d=aR._engine.ellipse(this,b||0,E||0,i||0,g||0);this.__set__&&this.__set__.push(d);return d};a4.path=function(b){b&&!aR.is(b,aj)&&!aR.is(b[0],bd)&&(b+=aX);var d=aR._engine.path(aR.format[bG](aR,arguments),this);this.__set__&&this.__set__.push(d);return d};a4.image=function(E,b,R,d,i){var g=aR._engine.image(this,E||"about:blank",b||0,R||0,d||0,i||0);this.__set__&&this.__set__.push(g);return g};a4.text=function(b,i,g){var d=aR._engine.text(this,b||0,i||0,bH(g));this.__set__&&this.__set__.push(d);return d};a4.set=function(d){!aR.is(d,"array")&&(d=Array.prototype.splice.call(arguments,0,arguments.length));var b=new al(d);this.__set__&&this.__set__.push(b);return b};a4.setStart=function(b){this.__set__=b||this.set()};a4.setFinish=function(d){var b=this.__set__;delete this.__set__;return b};a4.setSize=function(d,b){return aR._engine.setSize.call(this,d,b)};a4.setViewBox=function(b,E,d,i,g){return aR._engine.setViewBox.call(this,b,E,d,i,g)};a4.top=a4.bottom=null;a4.raphael=aR;var bs=function(g){var E=g.getBoundingClientRect(),bM=g.ownerDocument,R=bM.body,b=bM.documentElement,i=b.clientTop||R.clientTop||0,S=b.clientLeft||R.clientLeft||0,bL=E.top+(aA.win.pageYOffset||b.scrollTop||R.scrollTop)-i,d=E.left+(aA.win.pageXOffset||b.scrollLeft||R.scrollLeft)-S;return{y:bL,x:d}};a4.getElementByPoint=function(d,bL){var S=this,g=S.canvas,R=aA.doc.elementFromPoint(d,bL);if(aA.win.opera&&R.tagName=="svg"){var E=bs(g),i=g.createSVGRect();i.x=d-E.x;i.y=bL-E.y;i.width=i.height=1;var b=g.getIntersectionList(i,null);if(b.length){R=b[b.length-1]}}if(!R){return null}while(R.parentNode&&R!=g.parentNode&&!R.raphael){R=R.parentNode}R==S.canvas.parentNode&&(R=g);R=R&&R.raphael?S.getById(R.raphaelid):null;return R};a4.getById=function(d){var b=this.bottom;while(b){if(b.id==d){return b}b=b.next}return null};a4.forEach=function(g,b){var d=this.bottom;while(d){if(g.call(b,d)===false){return this}d=d.next}return this};a4.getElementsByPoint=function(b,g){var d=this.set();this.forEach(function(i){if(i.isPointInside(b,g)){d.push(i)}});return d};function y(){return this.x+aQ+this.y}function at(){return this.x+aQ+this.y+aQ+this.width+" \xd7 "+this.height}bh.isPointInside=function(b,g){var d=this.realPath=this.realPath||N[this.type](this);return aR.isPointInsidePath(d,b,g)};bh.getBBox=function(d){if(this.removed){return{}}var b=this._;if(d){if(b.dirty||!b.bboxwt){this.realPath=N[this.type](this);b.bboxwt=am(this.realPath);b.bboxwt.toString=at;b.dirty=0}return b.bboxwt}if(b.dirty||b.dirtyT||!b.bbox){if(b.dirty||!this.realPath){b.bboxwt=0;
this.realPath=N[this.type](this)}b.bbox=am(L(this.realPath,this.matrix));b.bbox.toString=at;b.dirty=b.dirtyT=0}return b.bbox};bh.clone=function(){if(this.removed){return null}var b=this.paper[this.type]().attr(this.attr());this.__set__&&this.__set__.push(b);return b};bh.glow=function(bL){if(this.type=="text"){return null}bL=bL||{};var g={width:(bL.width||10)+(+this.attr("stroke-width")||1),fill:bL.fill||false,opacity:bL.opacity||0.5,offsetx:bL.offsetx||0,offsety:bL.offsety||0,color:bL.color||"#000"},S=g.width/2,E=this.paper,b=E.set(),R=this.realPath||N[this.type](this);R=this.matrix?L(R,this.matrix):R;for(var d=1;d<S+1;d++){b.push(E.path(R).attr({stroke:g.color,fill:g.fill?g.color:"none","stroke-linejoin":"round","stroke-linecap":"round","stroke-width":+(g.width/S*d).toFixed(3),opacity:+(g.opacity/S).toFixed(3)}))}return b.insertBefore(this).translate(g.offsetx,g.offsety)};var a7={},k=function(d,b,E,i,bM,bL,S,R,g){if(g==null){return q(d,b,E,i,bM,bL,S,R)}else{return aR.findDotsAtSegment(d,b,E,i,bM,bL,S,R,C(d,b,E,i,bM,bL,S,R,g))}},a6=function(b,d){return function(bT,R,S){bT=W(bT);var bP,bO,g,bL,E="",bS={},bQ,bN=0;for(var bM=0,bR=bT.length;bM<bR;bM++){g=bT[bM];if(g[0]=="M"){bP=+g[1];bO=+g[2]}else{bL=k(bP,bO,g[1],g[2],g[3],g[4],g[5],g[6]);if(bN+bL>R){if(d&&!bS.start){bQ=k(bP,bO,g[1],g[2],g[3],g[4],g[5],g[6],R-bN);E+=["C"+bQ.start.x,bQ.start.y,bQ.m.x,bQ.m.y,bQ.x,bQ.y];if(S){return E}bS.start=E;E=["M"+bQ.x,bQ.y+"C"+bQ.n.x,bQ.n.y,bQ.end.x,bQ.end.y,g[5],g[6]].join();bN+=bL;bP=+g[5];bO=+g[6];continue}if(!b&&!d){bQ=k(bP,bO,g[1],g[2],g[3],g[4],g[5],g[6],R-bN);return{x:bQ.x,y:bQ.y,alpha:bQ.alpha}}}bN+=bL;bP=+g[5];bO=+g[6]}E+=g.shift()+g}bS.end=E;bQ=b?bN:d?bS:aR.findDotsAtSegment(bP,bO,g[0],g[1],g[2],g[3],g[4],g[5],1);bQ.alpha&&(bQ={x:bQ.x,y:bQ.y,alpha:bQ.alpha});return bQ}};var aS=a6(1),J=a6(),ad=a6(0,1);aR.getTotalLength=aS;aR.getPointAtLength=J;aR.getSubpath=function(d,i,g){if(this.getTotalLength(d)-g<0.000001){return ad(d,i).end}var b=ad(d,g,1);return i?ad(b,i).end:b};bh.getTotalLength=function(){if(this.type!="path"){return}if(this.node.getTotalLength){return this.node.getTotalLength()}return aS(this.attrs.path)};bh.getPointAtLength=function(b){if(this.type!="path"){return}return J(this.attrs.path,b)};bh.getSubpath=function(d,b){if(this.type!="path"){return}return aR.getSubpath(this.attrs.path,d,b)};var o=aR.easing_formulas={linear:function(b){return b},"<":function(b){return bp(b,1.7)},">":function(b){return bp(b,0.48)},"<>":function(bL){var i=0.48-bL/1.04,g=au.sqrt(0.1734+i*i),b=g-i,S=bp(aw(b),1/3)*(b<0?-1:1),R=-g-i,E=bp(aw(R),1/3)*(R<0?-1:1),d=S+E+0.5;return(1-d)*3*d*d+d*d*d},backIn:function(d){var b=1.70158;return d*d*((b+1)*d-b)},backOut:function(d){d=d-1;var b=1.70158;return d*d*((b+1)*d+b)+1},elastic:function(b){if(b==!!b){return b}return bp(2,-10*b)*au.sin((b-0.075)*(2*aV)/0.3)+1},bounce:function(i){var d=7.5625,g=2.75,b;if(i<(1/g)){b=d*i*i}else{if(i<(2/g)){i-=(1.5/g);b=d*i*i+0.75}else{if(i<(2.5/g)){i-=(2.25/g);b=d*i*i+0.9375}else{i-=(2.625/g);b=d*i*i+0.984375}}}return b}};o.easeIn=o["ease-in"]=o["<"];o.easeOut=o["ease-out"]=o[">"];o.easeInOut=o["ease-in-out"]=o["<>"];o["back-in"]=o.backIn;o["back-out"]=o.backOut;var ab=[],aN=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(b){setTimeout(b,16)},bC=function(){var bL=+new Date,bT=0;for(;bT<ab.length;bT++){var bZ=ab[bT];if(bZ.el.removed||bZ.paused){continue}var E=bL-bZ.start,bR=bZ.ms,bQ=bZ.easing,bU=bZ.from,bO=bZ.diff,d=bZ.to,bN=bZ.t,S=bZ.el,bP={},b,bX={},b1;if(bZ.initstatus){E=(bZ.initstatus*bZ.anim.top-bZ.prev)/(bZ.percent-bZ.prev)*bR;bZ.status=bZ.initstatus;delete bZ.initstatus;bZ.stop&&ab.splice(bT--,1)}else{bZ.status=(bZ.prev+(bZ.percent-bZ.prev)*(E/bR))/bZ.anim.top}if(E<0){continue}if(E<bR){var g=bQ(E/bR);for(var bS in bU){if(bU[ak](bS)){switch(ar[bS]){case aL:b=+bU[bS]+g*bR*bO[bS];break;case"colour":b="rgb("+[H(ah(bU[bS].r+g*bR*bO[bS].r)),H(ah(bU[bS].g+g*bR*bO[bS].g)),H(ah(bU[bS].b+g*bR*bO[bS].b))].join(",")+")";break;case"path":b=[];for(var bW=0,bM=bU[bS].length;bW<bM;bW++){b[bW]=[bU[bS][bW][0]];for(var bV=1,bY=bU[bS][bW].length;bV<bY;bV++){b[bW][bV]=+bU[bS][bW][bV]+g*bR*bO[bS][bW][bV]}b[bW]=b[bW].join(aQ)}b=b.join(aQ);break;case"transform":if(bO[bS].real){b=[];for(bW=0,bM=bU[bS].length;bW<bM;bW++){b[bW]=[bU[bS][bW][0]];for(bV=1,bY=bU[bS][bW].length;bV<bY;bV++){b[bW][bV]=bU[bS][bW][bV]+g*bR*bO[bS][bW][bV]}}}else{var b0=function(b2){return +bU[bS][b2]+g*bR*bO[bS][b2]};b=[["m",b0(0),b0(1),b0(2),b0(3),b0(4),b0(5)]]}break;case"csv":if(bS=="clip-rect"){b=[];bW=4;while(bW--){b[bW]=+bU[bS][bW]+g*bR*bO[bS][bW]}}break;default:var R=[][bE](bU[bS]);b=[];bW=S.paper.customAttributes[bS].length;while(bW--){b[bW]=+R[bW]+g*bR*bO[bS][bW]}break}bP[bS]=b}}S.attr(bP);(function(b3,i,b2){setTimeout(function(){eve("raphael.anim.frame."+b3,i,b2)})})(S.id,S,bZ.anim)}else{(function(b3,b2,i){setTimeout(function(){eve("raphael.anim.frame."+b2.id,b2,i);eve("raphael.anim.finish."+b2.id,b2,i);aR.is(b3,"function")&&b3.call(b2)})})(bZ.callback,S,bZ.anim);S.attr(d);ab.splice(bT--,1);if(bZ.repeat>1&&!bZ.next){for(b1 in d){if(d[ak](b1)){bX[b1]=bZ.totalOrigin[b1]}}bZ.el.attr(bX);aM(bZ.anim,bZ.el,bZ.anim.percents[0],null,bZ.totalOrigin,bZ.repeat-1)}if(bZ.next&&!bZ.stop){aM(bZ.anim,bZ.el,bZ.next,null,bZ.totalOrigin,bZ.repeat)}}}aR.svg&&S&&S.paper&&S.paper.safari();ab.length&&aN(bC)},H=function(b){return b>255?255:b<0?0:b};bh.animateWith=function(d,E,g,b,bL,bQ){var S=this;if(S.removed){bQ&&bQ.call(S);return S}var bO=g instanceof bA?g:aR.animation(g,b,bL,bQ),bN,bM;aM(bO,S,bO.percents[0],null,S.attr());for(var R=0,bP=ab.length;R<bP;R++){if(ab[R].anim==E&&ab[R].el==d){ab[bP-1].start=ab[R].start;break}}return S};function a3(bR,i,d,bQ,bP,bL){var bM=3*i,bO=3*(bQ-i)-bM,b=1-bM-bO,S=3*d,bN=3*(bP-d)-S,bS=1-S-bN;function R(bT){return((b*bT+bO)*bT+bM)*bT}function g(bT,bV){var bU=E(bT,bV);return((bS*bU+bN)*bU+S)*bU}function E(bT,b0){var bZ,bY,bW,bU,bX,bV;for(bW=bT,bV=0;bV<8;bV++){bU=R(bW)-bT;if(aw(bU)<b0){return bW}bX=(3*b*bW+2*bO)*bW+bM;if(aw(bX)<0.000001){break}bW=bW-bU/bX}bZ=0;bY=1;bW=bT;if(bW<bZ){return bZ}if(bW>bY){return bY}while(bZ<bY){bU=R(bW);if(aw(bU-bT)<b0){return bW}if(bT>bU){bZ=bW}else{bY=bW}bW=(bY-bZ)/2+bZ}return bW}return g(bR,1/(200*bL))}bh.onAnimation=function(b){b?eve.on("raphael.anim.frame."+this.id,b):eve.unbind("raphael.anim.frame."+this.id);return this};function bA(E,g){var d=[],i={};this.ms=g;this.times=1;if(E){for(var b in E){if(E[ak](b)){i[an(b)]=E[b];d.push(an(b))}}d.sort(u)}this.anim=i;this.top=d[d.length-1];this.percents=d}bA.prototype.delay=function(d){var b=new bA(this.anim,this.ms);b.times=this.times;b.del=+d||0;return b};bA.prototype.repeat=function(d){var b=new bA(this.anim,this.ms);b.del=this.del;b.times=au.floor(m(d,0))||1;return b};function aM(b3,g,b,b1,bL,bP){b=an(b);var ca,S,bO,cb=[],bV,bU,R,bX=b3.ms,b2={},E={},bR={};if(b1){for(b6=0,bQ=ab.length;b6<bQ;b6++){var b8=ab[b6];if(b8.el.id==g.id&&b8.anim==b3){if(b8.percent!=b){ab.splice(b6,1);
bO=1}else{S=b8}g.attr(b8.totalOrigin);break}}}else{b1=+E}for(var b6=0,bQ=b3.percents.length;b6<bQ;b6++){if(b3.percents[b6]==b||b3.percents[b6]>b1*b3.top){b=b3.percents[b6];bU=b3.percents[b6-1]||0;bX=bX/b3.top*(b-bU);bV=b3.percents[b6+1];ca=b3.anim[b];break}else{if(b1){g.attr(b3.anim[b3.percents[b6]])}}}if(!ca){return}if(!S){for(var bZ in ca){if(ca[ak](bZ)){if(ar[ak](bZ)||g.paper.customAttributes[ak](bZ)){b2[bZ]=g.attr(bZ);(b2[bZ]==null)&&(b2[bZ]=r[bZ]);E[bZ]=ca[bZ];switch(ar[bZ]){case aL:bR[bZ]=(E[bZ]-b2[bZ])/bX;break;case"colour":b2[bZ]=aR.getRGB(b2[bZ]);var b0=aR.getRGB(E[bZ]);bR[bZ]={r:(b0.r-b2[bZ].r)/bX,g:(b0.g-b2[bZ].g)/bX,b:(b0.b-b2[bZ].b)/bX};break;case"path":var bM=W(b2[bZ],E[bZ]),bT=bM[1];b2[bZ]=bM[0];bR[bZ]=[];for(b6=0,bQ=b2[bZ].length;b6<bQ;b6++){bR[bZ][b6]=[0];for(var b5=1,b7=b2[bZ][b6].length;b5<b7;b5++){bR[bZ][b6][b5]=(bT[b6][b5]-b2[bZ][b6][b5])/bX}}break;case"transform":var cd=g._,cc=aB(cd[bZ],E[bZ]);if(cc){b2[bZ]=cc.from;E[bZ]=cc.to;bR[bZ]=[];bR[bZ].real=true;for(b6=0,bQ=b2[bZ].length;b6<bQ;b6++){bR[bZ][b6]=[b2[bZ][b6][0]];for(b5=1,b7=b2[bZ][b6].length;b5<b7;b5++){bR[bZ][b6][b5]=(E[bZ][b6][b5]-b2[bZ][b6][b5])/bX}}}else{var bY=(g.matrix||new aF),b9={_:{transform:cd.transform},getBBox:function(){return g.getBBox(1)}};b2[bZ]=[bY.a,bY.b,bY.c,bY.d,bY.e,bY.f];aO(b9,E[bZ]);E[bZ]=b9._.transform;bR[bZ]=[(b9.matrix.a-bY.a)/bX,(b9.matrix.b-bY.b)/bX,(b9.matrix.c-bY.c)/bX,(b9.matrix.d-bY.d)/bX,(b9.matrix.e-bY.e)/bX,(b9.matrix.f-bY.f)/bX]}break;case"csv":var d=bH(ca[bZ])[F](a),bN=bH(b2[bZ])[F](a);if(bZ=="clip-rect"){b2[bZ]=bN;bR[bZ]=[];b6=bN.length;while(b6--){bR[bZ][b6]=(d[b6]-b2[bZ][b6])/bX}}E[bZ]=d;break;default:d=[][bE](ca[bZ]);bN=[][bE](b2[bZ]);bR[bZ]=[];b6=g.paper.customAttributes[bZ].length;while(b6--){bR[bZ][b6]=((d[b6]||0)-(bN[b6]||0))/bX}break}}}}var bW=ca.easing,b4=aR.easing_formulas[bW];if(!b4){b4=bH(bW).match(c);if(b4&&b4.length==5){var bS=b4;b4=function(i){return a3(i,+bS[1],+bS[2],+bS[3],+bS[4],bX)}}else{b4=bB}}R=ca.start||b3.start||+new Date;b8={anim:b3,percent:b,timestamp:R,start:R+(b3.del||0),status:0,initstatus:b1||0,stop:false,ms:bX,easing:b4,from:b2,diff:bR,to:E,el:g,callback:ca.callback,prev:bU,next:bV,repeat:bP||b3.times,origin:g.attr(),totalOrigin:bL};ab.push(b8);if(b1&&!S&&!bO){b8.stop=true;b8.start=new Date-bX*b1;if(ab.length==1){return bC()}}if(bO){b8.start=new Date-b8.ms*b1}ab.length==1&&aN(bC)}else{S.initstatus=b1;S.start=new Date-S.ms*b1}eve("raphael.anim.start."+g.id,g,b3)}aR.animation=function(E,d,S,R){if(E instanceof bA){return E}if(aR.is(S,"function")||!S){R=R||S||null;S=null}E=Object(E);d=+d||0;var i={},g,b;for(b in E){if(E[ak](b)&&an(b)!=b&&an(b)+"%"!=b){g=true;i[b]=E[b]}}if(!g){return new bA(E,d)}else{S&&(i.easing=S);R&&(i.callback=R);return new bA({100:i},d)}};bh.animate=function(i,b,R,E){var d=this;if(d.removed){E&&E.call(d);return d}var g=i instanceof bA?i:aR.animation(i,b,R,E);aM(g,d,g.percents[0],null,d.attr());return d};bh.setTime=function(d,b){if(d&&b!=null){this.status(d,bm(b,d.ms)/d.ms)}return this};bh.status=function(R,E){var d=[],g=0,b,S;if(E!=null){aM(R,this,-1,bm(E,1));return this}else{b=ab.length;for(;g<b;g++){S=ab[g];if(S.el.id==this.id&&(!R||S.anim==R)){if(R){return S.status}d.push({anim:S.anim,status:S.status})}}if(R){return 0}return d}};bh.pause=function(d){for(var b=0;b<ab.length;b++){if(ab[b].el.id==this.id&&(!d||ab[b].anim==d)){if(eve("raphael.anim.pause."+this.id,this,ab[b].anim)!==false){ab[b].paused=true}}}return this};bh.resume=function(d){for(var b=0;b<ab.length;b++){if(ab[b].el.id==this.id&&(!d||ab[b].anim==d)){var g=ab[b];if(eve("raphael.anim.resume."+this.id,this,g.anim)!==false){delete g.paused;this.status(g.anim,g.status)}}}return this};bh.stop=function(d){for(var b=0;b<ab.length;b++){if(ab[b].el.id==this.id&&(!d||ab[b].anim==d)){if(eve("raphael.anim.stop."+this.id,this,ab[b].anim)!==false){ab.splice(b--,1)}}}return this};function aa(d){for(var b=0;b<ab.length;b++){if(ab[b].el.paper==d){ab.splice(b--,1)}}}eve.on("raphael.remove",aa);eve.on("raphael.clear",aa);bh.toString=function(){return"Rapha\xebl\u2019s object"};var al=function(b){this.items=[];this.length=0;this.type="set";if(b){for(var d=0,g=b.length;d<g;d++){if(b[d]&&(b[d].constructor==bh.constructor||b[d].constructor==al)){this[this.items.length]=this.items[this.items.length]=b[d];this.length++}}}},bc=al.prototype;bc.push=function(){var E,b;for(var d=0,g=arguments.length;d<g;d++){E=arguments[d];if(E&&(E.constructor==bh.constructor||E.constructor==al)){b=this.items.length;this[b]=this.items[b]=E;this.length++}}return this};bc.pop=function(){this.length&&delete this[this.length--];return this.items.pop()};bc.forEach=function(E,b){for(var d=0,g=this.items.length;d<g;d++){if(E.call(b,this.items[d],d)===false){return this}}return this};for(var B in bh){if(bh[ak](B)){bc[B]=(function(b){return function(){var d=arguments;return this.forEach(function(g){g[b][bG](g,d)})}})(B)}}bc.attr=function(d,S){if(d&&aR.is(d,bd)&&aR.is(d[0],"object")){for(var b=0,R=d.length;b<R;b++){this.items[b].attr(d[b])}}else{for(var g=0,E=this.items.length;g<E;g++){this.items[g].attr(d,S)}}return this};bc.clear=function(){while(this.length){this.pop()}};bc.splice=function(E,bL,bM){E=E<0?m(this.length+E,0):E;bL=m(0,bm(this.length-E,bL));var g=[],b=[],d=[],R;for(R=2;R<arguments.length;R++){d.push(arguments[R])}for(R=0;R<bL;R++){b.push(this[E+R])}for(;R<this.length-E;R++){g.push(this[E+R])}var S=d.length;for(R=0;R<S+g.length;R++){this.items[E+R]=this[E+R]=R<S?d[R]:g[R-S]}R=this.items.length=this.length-=bL-S;while(this[R]){delete this[R++]}return new al(b)};bc.exclude=function(g){for(var b=0,d=this.length;b<d;b++){if(this[b]==g){this.splice(b,1);return true}}};bc.animate=function(g,b,bL,bN){(aR.is(bL,"function")||!bL)&&(bN=bL||null);var S=this.items.length,E=S,bO,bM=this,R;if(!S){return this}bN&&(R=function(){!--S&&bN.call(bM)});bL=aR.is(bL,aj)?bL:R;var d=aR.animation(g,b,bL,R);bO=this.items[--E].animate(d);while(E--){this.items[E]&&!this.items[E].removed&&this.items[E].animateWith(bO,d,d)}return this};bc.insertAfter=function(d){var b=this.items.length;while(b--){this.items[b].insertAfter(d)}return this};bc.getBBox=function(){var b=[],S=[],d=[],E=[];for(var g=this.items.length;g--;){if(!this.items[g].removed){var R=this.items[g].getBBox();b.push(R.x);S.push(R.y);d.push(R.x+R.width);E.push(R.y+R.height)}}b=bm[bG](0,b);S=bm[bG](0,S);d=m[bG](0,d);E=m[bG](0,E);return{x:b,y:S,x2:d,y2:E,width:d-b,height:E-S}};bc.clone=function(g){g=new al;for(var b=0,d=this.items.length;b<d;b++){g.push(this.items[b].clone())}return g};bc.toString=function(){return"Rapha\xebl\u2018s set"};aR.registerFont=function(d){if(!d.face){return d}this.fonts=this.fonts||{};var i={w:d.w,face:{},glyphs:{}},g=d.face["font-family"];for(var S in d.face){if(d.face[ak](S)){i.face[S]=d.face[S]}}if(this.fonts[g]){this.fonts[g].push(i)}else{this.fonts[g]=[i]}if(!d.svg){i.face["units-per-em"]=U(d.face["units-per-em"],10);for(var E in d.glyphs){if(d.glyphs[ak](E)){var R=d.glyphs[E];i.glyphs[E]={w:R.w,k:{},d:R.d&&"M"+R.d.replace(/[mlcxtrv]/g,function(bL){return{l:"L",c:"C",x:"z",t:"m",r:"l",v:"c"}[bL]||"M"
})+"z"};if(R.k){for(var b in R.k){if(R[ak](b)){i.glyphs[E].k[b]=R.k[b]}}}}}}return d};a4.getFont=function(bM,bN,d,E){E=E||"normal";d=d||"normal";bN=+bN||{normal:400,bold:700,lighter:300,bolder:800}[bN]||400;if(!aR.fonts){return}var R=aR.fonts[bM];if(!R){var g=new RegExp("(^|\\s)"+bM.replace(/[^\w\d\s+!~.:_-]/g,aX)+"(\\s|$)","i");for(var b in aR.fonts){if(aR.fonts[ak](b)){if(g.test(b)){R=aR.fonts[b];break}}}}var S;if(R){for(var bL=0,bO=R.length;bL<bO;bL++){S=R[bL];if(S.face["font-weight"]==bN&&(S.face["font-style"]==d||!S.face["font-style"])&&S.face["font-stretch"]==E){break}}}return S};a4.print=function(bL,S,b,bO,bP,bY,d){bY=bY||"middle";d=m(bm(d||0,1),-1);var bX=bH(b)[F](aX),bU=0,bW=0,bS=aX,bZ;aR.is(bO,b)&&(bO=this.getFont(bO));if(bO){bZ=(bP||16)/bO.face["units-per-em"];var E=bO.face.bbox[F](a),bN=+E[0],g=E[3]-E[1],R=0,bQ=+E[1]+(bY=="baseline"?g+(+bO.face.descent):g/2);for(var bT=0,bM=bX.length;bT<bM;bT++){if(bX[bT]=="\n"){bU=0;bV=0;bW=0;R+=g}else{var bR=bW&&bO.glyphs[bX[bT-1]]||{},bV=bO.glyphs[bX[bT]];bU+=bW?(bR.w||bO.w)+(bR.k&&bR.k[bX[bT]]||0)+(bO.w*d):0;bW=1}if(bV&&bV.d){bS+=aR.transformPath(bV.d,["t",bU*bZ,R*bZ,"s",bZ,bZ,bN,bQ,"t",(bL-bN)/bZ,(S-bQ)/bZ])}}}return this.path(bS).attr({fill:"#000",stroke:"none"})};a4.add=function(E){if(aR.is(E,"array")){var g=this.set(),d=0,R=E.length,b;for(;d<R;d++){b=E[d]||{};bw[ak](b.type)&&g.push(this[b.type]().attr(b))}}return g};aR.format=function(d,g){var b=aR.is(g,bd)?[0][bE](g):arguments;d&&aR.is(d,aj)&&b.length-1&&(d=d.replace(br,function(R,E){return b[++E]==null?aX:b[E]}));return d||aX};aR.fullfill=(function(){var g=/\{([^\}]+)\}/g,b=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,d=function(R,E,S){var i=S;E.replace(b,function(bN,bM,bL,bP,bO){bM=bM||bP;if(i){if(bM in i){i=i[bM]}typeof i=="function"&&bO&&(i=i())}});i=(i==null||i==S?R:i)+"";return i};return function(E,i){return String(E).replace(g,function(S,R){return d(S,R,i)})}})();aR.ninja=function(){s.was?(aA.win.Raphael=s.is):delete Raphael;return aR};aR.st=bc;(function(i,d,g){if(i.readyState==null&&i.addEventListener){i.addEventListener(d,g=function(){i.removeEventListener(d,g,false);i.readyState="complete"},false);i.readyState="loading"}function b(){(/in/).test(i.readyState)?setTimeout(b,9):aR.eve("raphael.DOMload")}b()})(document,"DOMContentLoaded");s.was?(aA.win.Raphael=aR):(Raphael=aR);eve.on("raphael.DOMload",function(){ao=true})})();window.Raphael.svg&&function(l){var d="hasOwnProperty",B=String,n=parseFloat,q=parseInt,f=Math,C=f.max,s=f.abs,h=f.pow,g=/[, ]+/,z=l.eve,r="",j=" ";var o="http://www.w3.org/1999/xlink",y={block:"M5,0 0,2.5 5,5z",classic:"M5,0 0,2.5 5,5 3.5,3 3.5,2z",diamond:"M2.5,0 5,2.5 2.5,5 0,2.5z",open:"M6,1 1,3.5 6,6",oval:"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"},u={};l.toString=function(){return"Your browser supports SVG.\nYou are running Rapha\xebl "+this.version};var i=function(F,D){if(D){if(typeof F=="string"){F=i(F)}for(var E in D){if(D[d](E)){if(E.substring(0,6)=="xlink:"){F.setAttributeNS(o,E.substring(6),B(D[E]))}else{F.setAttribute(E,B(D[E]))}}}}else{F=l._g.doc.createElementNS("http://www.w3.org/2000/svg",F);F.style&&(F.style.webkitTapHighlightColor="rgba(0,0,0,0)")}return F},a=function(M,Q){var O="linear",E=M.id+Q,K=0.5,I=0.5,G=M.node,D=M.paper,S=G.style,F=l._g.doc.getElementById(E);if(!F){Q=B(Q).replace(l._radial_gradient,function(V,T,W){O="radial";if(T&&W){K=n(T);I=n(W);var U=((I>0.5)*2-1);h(K-0.5,2)+h(I-0.5,2)>0.25&&(I=f.sqrt(0.25-h(K-0.5,2))*U+0.5)&&I!=0.5&&(I=I.toFixed(5)-0.00001*U)}return r});Q=Q.split(/\s*\-\s*/);if(O=="linear"){var J=Q.shift();J=-n(J);if(isNaN(J)){return null}var H=[0,0,f.cos(l.rad(J)),f.sin(l.rad(J))],P=1/(C(s(H[2]),s(H[3]))||1);H[2]*=P;H[3]*=P;if(H[2]<0){H[0]=-H[2];H[2]=0}if(H[3]<0){H[1]=-H[3];H[3]=0}}var N=l._parseDots(Q);if(!N){return null}E=E.replace(/[\(\)\s,\xb0#]/g,"_");if(M.gradient&&E!=M.gradient.id){D.defs.removeChild(M.gradient);delete M.gradient}if(!M.gradient){F=i(O+"Gradient",{id:E});M.gradient=F;i(F,O=="radial"?{fx:K,fy:I}:{x1:H[0],y1:H[1],x2:H[2],y2:H[3],gradientTransform:M.matrix.invert()});D.defs.appendChild(F);for(var L=0,R=N.length;L<R;L++){F.appendChild(i("stop",{offset:N[L].offset?N[L].offset:L?"100%":"0%","stop-color":N[L].color||"#fff"}))}}}i(G,{fill:"url(#"+E+")",opacity:1,"fill-opacity":1});S.fill=r;S.opacity=1;S.fillOpacity=1;return 1},b=function(E){var D=E.getBBox(1);i(E.pattern,{patternTransform:E.matrix.invert()+" translate("+D.x+","+D.y+")"})},c=function(O,Q,J){if(O.type=="path"){var D=B(Q).toLowerCase().split("-"),N=O.paper,ab=J?"end":"start",S=O.node,P=O.attrs,I=P["stroke-width"],W=D.length,G="classic",V,F,L,T,R,K=3,X=3,M=5;while(W--){switch(D[W]){case"block":case"classic":case"oval":case"diamond":case"open":case"none":G=D[W];break;case"wide":X=5;break;case"narrow":X=2;break;case"long":K=5;break;case"short":K=2;break}}if(G=="open"){K+=2;X+=2;M+=2;L=1;T=J?4:1;R={fill:"none",stroke:P.stroke}}else{T=L=K/2;R={fill:P.stroke,stroke:"none"}}if(O._.arrows){if(J){O._.arrows.endPath&&u[O._.arrows.endPath]--;O._.arrows.endMarker&&u[O._.arrows.endMarker]--}else{O._.arrows.startPath&&u[O._.arrows.startPath]--;O._.arrows.startMarker&&u[O._.arrows.startMarker]--}}else{O._.arrows={}}if(G!="none"){var E="raphael-marker-"+G,aa="raphael-marker-"+ab+G+K+X;if(!l._g.doc.getElementById(E)){N.defs.appendChild(i(i("path"),{"stroke-linecap":"round",d:y[G],id:E}));u[E]=1}else{u[E]++}var H=l._g.doc.getElementById(aa),U;if(!H){H=i(i("marker"),{id:aa,markerHeight:X,markerWidth:K,orient:"auto",refX:T,refY:X/2});U=i(i("use"),{"xlink:href":"#"+E,transform:(J?"rotate(180 "+K/2+" "+X/2+") ":r)+"scale("+K/M+","+X/M+")","stroke-width":(1/((K/M+X/M)/2)).toFixed(4)});H.appendChild(U);N.defs.appendChild(H);u[aa]=1}else{u[aa]++;U=H.getElementsByTagName("use")[0]}i(U,R);var Z=L*(G!="diamond"&&G!="oval");if(J){V=O._.arrows.startdx*I||0;F=l.getTotalLength(P.path)-Z*I}else{V=Z*I;F=l.getTotalLength(P.path)-(O._.arrows.enddx*I||0)}R={};R["marker-"+ab]="url(#"+aa+")";if(F||V){R.d=Raphael.getSubpath(P.path,V,F)}i(S,R);O._.arrows[ab+"Path"]=E;O._.arrows[ab+"Marker"]=aa;O._.arrows[ab+"dx"]=Z;O._.arrows[ab+"Type"]=G;O._.arrows[ab+"String"]=Q}else{if(J){V=O._.arrows.startdx*I||0;F=l.getTotalLength(P.path)-V}else{V=0;F=l.getTotalLength(P.path)-(O._.arrows.enddx*I||0)}O._.arrows[ab+"Path"]&&i(S,{d:Raphael.getSubpath(P.path,V,F)});delete O._.arrows[ab+"Path"];delete O._.arrows[ab+"Marker"];delete O._.arrows[ab+"dx"];delete O._.arrows[ab+"Type"];delete O._.arrows[ab+"String"]}for(R in u){if(u[d](R)&&!u[R]){var Y=l._g.doc.getElementById(R);Y&&Y.parentNode.removeChild(Y)}}}},v={"":[0],none:[0],"-":[3,1],".":[1,1],"-.":[3,1,1,1],"-..":[3,1,1,1,1,1],". ":[1,3],"- ":[4,3],"--":[8,3],"- .":[4,3,1,3],"--.":[8,3,1,3],"--..":[8,3,1,3,1,3]},k=function(J,H,I){H=v[B(H).toLowerCase()];if(H){var F=J.attrs["stroke-width"]||"1",D={round:F,square:F,butt:0}[J.attrs["stroke-linecap"]||I["stroke-linecap"]]||0,G=[],E=H.length;while(E--){G[E]=H[E]*F+((E%2)?1:-1)*D}i(J.node,{"stroke-dasharray":G.join(",")})}},w=function(O,W){var S=O.node,P=O.attrs,M=S.style.visibility;
S.style.visibility="hidden";for(var R in W){if(W[d](R)){if(!l._availableAttrs[d](R)){continue}var Q=W[R];P[R]=Q;switch(R){case"blur":O.blur(Q);break;case"href":case"title":case"target":var U=S.parentNode;if(U.tagName.toLowerCase()!="a"){var H=i("a");U.insertBefore(H,S);H.appendChild(S);U=H}if(R=="target"){U.setAttributeNS(o,"show",Q=="blank"?"new":Q)}else{U.setAttributeNS(o,R,Q)}break;case"cursor":S.style.cursor=Q;break;case"transform":O.transform(Q);break;case"arrow-start":c(O,Q);break;case"arrow-end":c(O,Q,1);break;case"clip-rect":var E=B(Q).split(g);if(E.length==4){O.clip&&O.clip.parentNode.parentNode.removeChild(O.clip.parentNode);var F=i("clipPath"),T=i("rect");F.id=l.createUUID();i(T,{x:E[0],y:E[1],width:E[2],height:E[3]});F.appendChild(T);O.paper.defs.appendChild(F);i(S,{"clip-path":"url(#"+F.id+")"});O.clip=T}if(!Q){var N=S.getAttribute("clip-path");if(N){var V=l._g.doc.getElementById(N.replace(/(^url\(#|\)$)/g,r));V&&V.parentNode.removeChild(V);i(S,{"clip-path":r});delete O.clip}}break;case"path":if(O.type=="path"){i(S,{d:Q?P.path=l._pathToAbsolute(Q):"M0,0"});O._.dirty=1;if(O._.arrows){"startString" in O._.arrows&&c(O,O._.arrows.startString);"endString" in O._.arrows&&c(O,O._.arrows.endString,1)}}break;case"width":S.setAttribute(R,Q);O._.dirty=1;if(P.fx){R="x";Q=P.x}else{break}case"x":if(P.fx){Q=-P.x-(P.width||0)}case"rx":if(R=="rx"&&O.type=="rect"){break}case"cx":S.setAttribute(R,Q);O.pattern&&b(O);O._.dirty=1;break;case"height":S.setAttribute(R,Q);O._.dirty=1;if(P.fy){R="y";Q=P.y}else{break}case"y":if(P.fy){Q=-P.y-(P.height||0)}case"ry":if(R=="ry"&&O.type=="rect"){break}case"cy":S.setAttribute(R,Q);O.pattern&&b(O);O._.dirty=1;break;case"r":if(O.type=="rect"){i(S,{rx:Q,ry:Q})}else{S.setAttribute(R,Q)}O._.dirty=1;break;case"src":if(O.type=="image"){S.setAttributeNS(o,"href",Q)}break;case"stroke-width":if(O._.sx!=1||O._.sy!=1){Q/=C(s(O._.sx),s(O._.sy))||1}if(O.paper._vbSize){Q*=O.paper._vbSize}S.setAttribute(R,Q);if(P["stroke-dasharray"]){k(O,P["stroke-dasharray"],W)}if(O._.arrows){"startString" in O._.arrows&&c(O,O._.arrows.startString);"endString" in O._.arrows&&c(O,O._.arrows.endString,1)}break;case"stroke-dasharray":k(O,Q,W);break;case"fill":var I=B(Q).match(l._ISURL);if(I){F=i("pattern");var L=i("image");F.id=l.createUUID();i(F,{x:0,y:0,patternUnits:"userSpaceOnUse",height:1,width:1});i(L,{x:0,y:0,"xlink:href":I[1]});F.appendChild(L);(function(X){l._preload(I[1],function(){var Y=this.offsetWidth,Z=this.offsetHeight;i(X,{width:Y,height:Z});i(L,{width:Y,height:Z});O.paper.safari()})})(F);O.paper.defs.appendChild(F);i(S,{fill:"url(#"+F.id+")"});O.pattern=F;O.pattern&&b(O);break}var G=l.getRGB(Q);if(!G.error){delete W.gradient;delete P.gradient;!l.is(P.opacity,"undefined")&&l.is(W.opacity,"undefined")&&i(S,{opacity:P.opacity});!l.is(P["fill-opacity"],"undefined")&&l.is(W["fill-opacity"],"undefined")&&i(S,{"fill-opacity":P["fill-opacity"]})}else{if((O.type=="circle"||O.type=="ellipse"||B(Q).charAt()!="r")&&a(O,Q)){if("opacity" in P||"fill-opacity" in P){var D=l._g.doc.getElementById(S.getAttribute("fill").replace(/^url\(#|\)$/g,r));if(D){var J=D.getElementsByTagName("stop");i(J[J.length-1],{"stop-opacity":("opacity" in P?P.opacity:1)*("fill-opacity" in P?P["fill-opacity"]:1)})}}P.gradient=Q;P.fill="none";break}}G[d]("opacity")&&i(S,{"fill-opacity":G.opacity>1?G.opacity/100:G.opacity});case"stroke":G=l.getRGB(Q);S.setAttribute(R,G.hex);R=="stroke"&&G[d]("opacity")&&i(S,{"stroke-opacity":G.opacity>1?G.opacity/100:G.opacity});if(R=="stroke"&&O._.arrows){"startString" in O._.arrows&&c(O,O._.arrows.startString);"endString" in O._.arrows&&c(O,O._.arrows.endString,1)}break;case"gradient":(O.type=="circle"||O.type=="ellipse"||B(Q).charAt()!="r")&&a(O,Q);break;case"opacity":if(P.gradient&&!P[d]("stroke-opacity")){i(S,{"stroke-opacity":Q>1?Q/100:Q})}case"fill-opacity":if(P.gradient){D=l._g.doc.getElementById(S.getAttribute("fill").replace(/^url\(#|\)$/g,r));if(D){J=D.getElementsByTagName("stop");i(J[J.length-1],{"stop-opacity":Q})}break}default:R=="font-size"&&(Q=q(Q,10)+"px");var K=R.replace(/(\-.)/g,function(X){return X.substring(1).toUpperCase()});S.style[K]=Q;O._.dirty=1;S.setAttribute(R,Q);break}}}p(O,W);S.style.visibility=M},A=1.2,p=function(D,H){if(D.type!="text"||!(H[d]("text")||H[d]("font")||H[d]("font-size")||H[d]("x")||H[d]("y"))){return}var M=D.attrs,F=D.node,O=F.firstChild?q(l._g.doc.defaultView.getComputedStyle(F.firstChild,r).getPropertyValue("font-size"),10):10;if(H[d]("text")){M.text=H.text;while(F.firstChild){F.removeChild(F.firstChild)}var G=B(H.text).split("\n"),E=[],K;for(var I=0,N=G.length;I<N;I++){K=i("tspan");I&&i(K,{dy:O*A,x:M.x});K.appendChild(l._g.doc.createTextNode(G[I]));F.appendChild(K);E[I]=K}}else{E=F.getElementsByTagName("tspan");for(I=0,N=E.length;I<N;I++){if(I){i(E[I],{dy:O*A,x:M.x})}else{i(E[0],{dy:0})}}}i(F,{x:M.x,y:M.y});D._.dirty=1;var J=D._getBBox(),L=M.y-(J.y+J.height/2);L&&l.is(L,"finite")&&i(E[0],{dy:L})},t=function(E,D){var G=0,F=0;this[0]=this.node=E;E.raphael=true;this.id=l._oid++;E.raphaelid=this.id;this.matrix=l.matrix();this.realPath=null;this.paper=D;this.attrs=this.attrs||{};this._={transform:[],sx:1,sy:1,deg:0,dx:0,dy:0,dirty:1};!D.bottom&&(D.bottom=this);this.prev=D.top;D.top&&(D.top.next=this);D.top=this;this.next=null},m=l.el;t.prototype=m;m.constructor=t;l._engine.path=function(D,G){var E=i("path");G.canvas&&G.canvas.appendChild(E);var F=new t(E,G);F.type="path";w(F,{fill:"none",stroke:"#000",path:D});return F};m.rotate=function(E,D,G){if(this.removed){return this}E=B(E).split(g);if(E.length-1){D=n(E[1]);G=n(E[2])}E=n(E[0]);(G==null)&&(D=G);if(D==null||G==null){var F=this.getBBox(1);D=F.x+F.width/2;G=F.y+F.height/2}this.transform(this._.transform.concat([["r",E,D,G]]));return this};m.scale=function(H,F,D,G){if(this.removed){return this}H=B(H).split(g);if(H.length-1){F=n(H[1]);D=n(H[2]);G=n(H[3])}H=n(H[0]);(F==null)&&(F=H);(G==null)&&(D=G);if(D==null||G==null){var E=this.getBBox(1)}D=D==null?E.x+E.width/2:D;G=G==null?E.y+E.height/2:G;this.transform(this._.transform.concat([["s",H,F,D,G]]));return this};m.translate=function(E,D){if(this.removed){return this}E=B(E).split(g);if(E.length-1){D=n(E[1])}E=n(E[0])||0;D=+D||0;this.transform(this._.transform.concat([["t",E,D]]));return this};m.transform=function(E){var F=this._;if(E==null){return F.transform}l._extractTransform(this,E);this.clip&&i(this.clip,{transform:this.matrix.invert()});this.pattern&&b(this);this.node&&i(this.node,{transform:this.matrix});if(F.sx!=1||F.sy!=1){var D=this.attrs[d]("stroke-width")?this.attrs["stroke-width"]:1;this.attr({"stroke-width":D})}return this};m.hide=function(){!this.removed&&this.paper.safari(this.node.style.display="none");return this};m.show=function(){!this.removed&&this.paper.safari(this.node.style.display="");return this};m.remove=function(){if(this.removed||!this.node.parentNode){return}var E=this.paper;E.__set__&&E.__set__.exclude(this);z.unbind("raphael.*.*."+this.id);if(this.gradient){E.defs.removeChild(this.gradient)}l._tear(this,E);
if(this.node.parentNode.tagName.toLowerCase()=="a"){this.node.parentNode.parentNode.removeChild(this.node.parentNode)}else{this.node.parentNode.removeChild(this.node)}for(var D in this){this[D]=typeof this[D]=="function"?l._removedFactory(D):null}this.removed=true};m._getBBox=function(){if(this.node.style.display=="none"){this.show();var D=true}var F={};try{F=this.node.getBBox()}catch(E){}finally{F=F||{}}D&&this.hide();return F};m.attr=function(D,M){if(this.removed){return this}if(D==null){var J={};for(var L in this.attrs){if(this.attrs[d](L)){J[L]=this.attrs[L]}}J.gradient&&J.fill=="none"&&(J.fill=J.gradient)&&delete J.gradient;J.transform=this._.transform;return J}if(M==null&&l.is(D,"string")){if(D=="fill"&&this.attrs.fill=="none"&&this.attrs.gradient){return this.attrs.gradient}if(D=="transform"){return this._.transform}var K=D.split(g),G={};for(var H=0,O=K.length;H<O;H++){D=K[H];if(D in this.attrs){G[D]=this.attrs[D]}else{if(l.is(this.paper.customAttributes[D],"function")){G[D]=this.paper.customAttributes[D].def}else{G[D]=l._availableAttrs[D]}}}return O-1?G:G[K[0]]}if(M==null&&l.is(D,"array")){G={};for(H=0,O=D.length;H<O;H++){G[D[H]]=this.attr(D[H])}return G}if(M!=null){var E={};E[D]=M}else{if(D!=null&&l.is(D,"object")){E=D}}for(var N in E){z("raphael.attr."+N+"."+this.id,this,E[N])}for(N in this.paper.customAttributes){if(this.paper.customAttributes[d](N)&&E[d](N)&&l.is(this.paper.customAttributes[N],"function")){var I=this.paper.customAttributes[N].apply(this,[].concat(E[N]));this.attrs[N]=E[N];for(var F in I){if(I[d](F)){E[F]=I[F]}}}}w(this,E);return this};m.toFront=function(){if(this.removed){return this}if(this.node.parentNode.tagName.toLowerCase()=="a"){this.node.parentNode.parentNode.appendChild(this.node.parentNode)}else{this.node.parentNode.appendChild(this.node)}var D=this.paper;D.top!=this&&l._tofront(this,D);return this};m.toBack=function(){if(this.removed){return this}var E=this.node.parentNode;if(E.tagName.toLowerCase()=="a"){E.parentNode.insertBefore(this.node.parentNode,this.node.parentNode.parentNode.firstChild)}else{if(E.firstChild!=this.node){E.insertBefore(this.node,this.node.parentNode.firstChild)}}l._toback(this,this.paper);var D=this.paper;return this};m.insertAfter=function(D){if(this.removed){return this}var E=D.node||D[D.length-1].node;if(E.nextSibling){E.parentNode.insertBefore(this.node,E.nextSibling)}else{E.parentNode.appendChild(this.node)}l._insertafter(this,D,this.paper);return this};m.insertBefore=function(D){if(this.removed){return this}var E=D.node||D[0].node;E.parentNode.insertBefore(this.node,E);l._insertbefore(this,D,this.paper);return this};m.blur=function(E){var D=this;if(+E!==0){var F=i("filter"),G=i("feGaussianBlur");D.attrs.blur=E;F.id=l.createUUID();i(G,{stdDeviation:+E||1.5});F.appendChild(G);D.paper.defs.appendChild(F);D._blur=F;i(D.node,{filter:"url(#"+F.id+")"})}else{if(D._blur){D._blur.parentNode.removeChild(D._blur);delete D._blur;delete D.attrs.blur}D.node.removeAttribute("filter")}};l._engine.circle=function(E,D,I,H){var G=i("circle");E.canvas&&E.canvas.appendChild(G);var F=new t(G,E);F.attrs={cx:D,cy:I,r:H,fill:"none",stroke:"#000"};F.type="circle";i(G,F.attrs);return F};l._engine.rect=function(F,D,K,E,I,J){var H=i("rect");F.canvas&&F.canvas.appendChild(H);var G=new t(H,F);G.attrs={x:D,y:K,width:E,height:I,r:J||0,rx:J||0,ry:J||0,fill:"none",stroke:"#000"};G.type="rect";i(H,G.attrs);return G};l._engine.ellipse=function(E,D,J,I,H){var G=i("ellipse");E.canvas&&E.canvas.appendChild(G);var F=new t(G,E);F.attrs={cx:D,cy:J,rx:I,ry:H,fill:"none",stroke:"#000"};F.type="ellipse";i(G,F.attrs);return F};l._engine.image=function(F,J,D,K,E,I){var H=i("image");i(H,{x:D,y:K,width:E,height:I,preserveAspectRatio:"none"});H.setAttributeNS(o,"href",J);F.canvas&&F.canvas.appendChild(H);var G=new t(H,F);G.attrs={x:D,y:K,width:E,height:I,src:J};G.type="image";return G};l._engine.text=function(E,D,I,H){var G=i("text");E.canvas&&E.canvas.appendChild(G);var F=new t(G,E);F.attrs={x:D,y:I,"text-anchor":"middle",text:H,font:l._availableAttrs.font,stroke:"none",fill:"#000"};F.type="text";w(F,F.attrs);return F};l._engine.setSize=function(E,D){this.width=E||this.width;this.height=D||this.height;this.canvas.setAttribute("width",this.width);this.canvas.setAttribute("height",this.height);if(this._viewBox){this.setViewBox.apply(this,this._viewBox)}return this};l._engine.create=function(){var G=l._getContainer.apply(0,arguments),E=G&&G.container,K=G.x,J=G.y,F=G.width,L=G.height;if(!E){throw new Error("SVG container not found.")}var D=i("svg"),I="overflow:hidden;",H;K=K||0;J=J||0;F=F||512;L=L||342;i(D,{height:L,version:1.1,width:F,xmlns:"http://www.w3.org/2000/svg"});if(E==1){D.style.cssText=I+"position:absolute;left:"+K+"px;top:"+J+"px";l._g.doc.body.appendChild(D);H=1}else{D.style.cssText=I+"position:relative";if(E.firstChild){E.insertBefore(D,E.firstChild)}else{E.appendChild(D)}}E=new l._Paper;E.width=F;E.height=L;E.canvas=D;E.clear();E._left=E._top=0;H&&(E.renderfix=function(){});E.renderfix();return E};l._engine.setViewBox=function(I,G,K,D,E){z("raphael.setViewBox",this,this._viewBox,[I,G,K,D,E]);var M=C(K/this.width,D/this.height),H=this.top,L=E?"meet":"xMinYMin",F,J;if(I==null){if(this._vbSize){M=1}delete this._vbSize;F="0 0 "+this.width+j+this.height}else{this._vbSize=M;F=I+j+G+j+K+j+D}i(this.canvas,{viewBox:F,preserveAspectRatio:L});while(M&&H){J="stroke-width" in H.attrs?H.attrs["stroke-width"]:1;H.attr({"stroke-width":J});H._.dirty=1;H._.dirtyT=1;H=H.prev}this._viewBox=[I,G,K,D,!!E];return this};l.prototype.renderfix=function(){var I=this.canvas,D=I.style,H;try{H=I.getScreenCTM()||I.createSVGMatrix()}catch(G){H=I.createSVGMatrix()}var F=-H.e%1,E=-H.f%1;if(F||E){if(F){this._left=(this._left+F)%1;D.left=this._left+"px"}if(E){this._top=(this._top+E)%1;D.top=this._top+"px"}}};l.prototype.clear=function(){l.eve("raphael.clear",this);var D=this.canvas;while(D.firstChild){D.removeChild(D.firstChild)}this.bottom=this.top=null;(this.desc=i("desc")).appendChild(l._g.doc.createTextNode("Created with Rapha\xebl "+l.version));D.appendChild(this.desc);D.appendChild(this.defs=i("defs"))};l.prototype.remove=function(){z("raphael.remove",this);this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas);for(var D in this){this[D]=typeof this[D]=="function"?l._removedFactory(D):null}};var x=l.st;for(var e in m){if(m[d](e)&&!x[d](e)){x[e]=(function(D){return function(){var E=arguments;return this.forEach(function(F){F[D].apply(F,E)})}})(e)}}}(window.Raphael);window.Raphael.vml&&function(l){var e="hasOwnProperty",F=String,n=parseFloat,h=Math,B=h.round,I=h.max,C=h.min,s=h.abs,v="fill",i=/[, ]+/,A=l.eve,w=" progid:DXImageTransform.Microsoft",k=" ",q="",D={M:"m",L:"l",C:"c",Z:"x",m:"t",l:"r",c:"v",z:"x"},j=/([clmz]),?([^clmz]*)/gi,t=/ progid:\S+Blur\([^\)]+\)/g,H=/-?[^,\s-]+/g,d="position:absolute;left:0;top:0;width:1px;height:1px",b=21600,z={path:1,rect:1,image:1},r={circle:1,ellipse:1},f=function(S){var P=/[ahqstv]/ig,K=l._pathToAbsolute;F(S).match(P)&&(K=l._path2curve);
P=/[clmz]/g;if(K==l._pathToAbsolute&&!F(S).match(P)){var O=F(S).replace(j,function(W,Y,U){var X=[],T=Y.toLowerCase()=="m",V=D[Y];U.replace(H,function(Z){if(T&&X.length==2){V+=X+D[Y=="m"?"l":"L"];X=[]}X.push(B(Z*b))});return V+X});return O}var Q=K(S),J,E;O=[];for(var M=0,R=Q.length;M<R;M++){J=Q[M];E=Q[M][0].toLowerCase();E=="z"&&(E="x");for(var L=1,N=J.length;L<N;L++){E+=B(J[L]*b)+(L!=N-1?",":q)}O.push(E)}return O.join(k)},o=function(L,K,J){var E=l.matrix();E.rotate(-L,0.5,0.5);return{dx:E.x(K,J),dy:E.y(K,J)}},p=function(R,Q,P,M,L,N){var Z=R._,T=R.matrix,E=Z.fillpos,S=R.node,O=S.style,K=1,J="",V,X=b/Q,W=b/P;O.visibility="hidden";if(!Q||!P){return}S.coordsize=s(X)+k+s(W);O.rotation=N*(Q*P<0?-1:1);if(N){var Y=o(N,M,L);M=Y.dx;L=Y.dy}Q<0&&(J+="x");P<0&&(J+=" y")&&(K=-1);O.flip=J;S.coordorigin=(M*-X)+k+(L*-W);if(E||Z.fillsize){var U=S.getElementsByTagName(v);U=U&&U[0];S.removeChild(U);if(E){Y=o(N,T.x(E[0],E[1]),T.y(E[0],E[1]));U.position=Y.dx*K+k+Y.dy*K}if(Z.fillsize){U.size=Z.fillsize[0]*s(Q)+k+Z.fillsize[1]*s(P)}S.appendChild(U)}O.visibility="visible"};l.toString=function(){return"Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl "+this.version};var c=function(E,O,J){var Q=F(O).toLowerCase().split("-"),M=J?"end":"start",K=Q.length,N="classic",P="medium",L="medium";while(K--){switch(Q[K]){case"block":case"classic":case"oval":case"diamond":case"open":case"none":N=Q[K];break;case"wide":case"narrow":L=Q[K];break;case"long":case"short":P=Q[K];break}}var R=E.node.getElementsByTagName("stroke")[0];R[M+"arrow"]=N;R[M+"arrowlength"]=P;R[M+"arrowwidth"]=L},x=function(Z,aj){Z.attrs=Z.attrs||{};var ae=Z.node,an=Z.attrs,V=ae.style,R,ah=z[Z.type]&&(aj.x!=an.x||aj.y!=an.y||aj.width!=an.width||aj.height!=an.height||aj.cx!=an.cx||aj.cy!=an.cy||aj.rx!=an.rx||aj.ry!=an.ry||aj.r!=an.r),Y=r[Z.type]&&(an.cx!=aj.cx||an.cy!=aj.cy||an.r!=aj.r||an.rx!=aj.rx||an.ry!=aj.ry),aq=Z;for(var W in aj){if(aj[e](W)){an[W]=aj[W]}}if(ah){an.path=l._getPath[Z.type](Z);Z._.dirty=1}aj.href&&(ae.href=aj.href);aj.title&&(ae.title=aj.title);aj.target&&(ae.target=aj.target);aj.cursor&&(V.cursor=aj.cursor);"blur" in aj&&Z.blur(aj.blur);if(aj.path&&Z.type=="path"||ah){ae.path=f(~F(an.path).toLowerCase().indexOf("r")?l._pathToAbsolute(an.path):an.path);if(Z.type=="image"){Z._.fillpos=[an.x,an.y];Z._.fillsize=[an.width,an.height];p(Z,1,1,0,0,0)}}"transform" in aj&&Z.transform(aj.transform);if(Y){var M=+an.cx,K=+an.cy,Q=+an.rx||+an.r||0,P=+an.ry||+an.r||0;ae.path=l.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x",B((M-Q)*b),B((K-P)*b),B((M+Q)*b),B((K+P)*b),B(M*b))}if("clip-rect" in aj){var J=F(aj["clip-rect"]).split(i);if(J.length==4){J[2]=+J[2]+(+J[0]);J[3]=+J[3]+(+J[1]);var X=ae.clipRect||l._g.doc.createElement("div"),ap=X.style;ap.clip=l.format("rect({1}px {2}px {3}px {0}px)",J);if(!ae.clipRect){ap.position="absolute";ap.top=0;ap.left=0;ap.width=Z.paper.width+"px";ap.height=Z.paper.height+"px";ae.parentNode.insertBefore(X,ae);X.appendChild(ae);ae.clipRect=X}}if(!aj["clip-rect"]){ae.clipRect&&(ae.clipRect.style.clip="auto")}}if(Z.textpath){var al=Z.textpath.style;aj.font&&(al.font=aj.font);aj["font-family"]&&(al.fontFamily='"'+aj["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g,q)+'"');aj["font-size"]&&(al.fontSize=aj["font-size"]);aj["font-weight"]&&(al.fontWeight=aj["font-weight"]);aj["font-style"]&&(al.fontStyle=aj["font-style"])}if("arrow-start" in aj){c(aq,aj["arrow-start"])}if("arrow-end" in aj){c(aq,aj["arrow-end"],1)}if(aj.opacity!=null||aj["stroke-width"]!=null||aj.fill!=null||aj.src!=null||aj.stroke!=null||aj["stroke-width"]!=null||aj["stroke-opacity"]!=null||aj["fill-opacity"]!=null||aj["stroke-dasharray"]!=null||aj["stroke-miterlimit"]!=null||aj["stroke-linejoin"]!=null||aj["stroke-linecap"]!=null){var af=ae.getElementsByTagName(v),am=false;af=af&&af[0];!af&&(am=af=G(v));if(Z.type=="image"&&aj.src){af.src=aj.src}aj.fill&&(af.on=true);if(af.on==null||aj.fill=="none"||aj.fill===null){af.on=false}if(af.on&&aj.fill){var O=F(aj.fill).match(l._ISURL);if(O){af.parentNode==ae&&ae.removeChild(af);af.rotate=true;af.src=O[1];af.type="tile";var E=Z.getBBox(1);af.position=E.x+k+E.y;Z._.fillpos=[E.x,E.y];l._preload(O[1],function(){Z._.fillsize=[this.offsetWidth,this.offsetHeight]})}else{af.color=l.getRGB(aj.fill).hex;af.src=q;af.type="solid";if(l.getRGB(aj.fill).error&&(aq.type in {circle:1,ellipse:1}||F(aj.fill).charAt()!="r")&&a(aq,aj.fill,af)){an.fill="none";an.gradient=aj.fill;af.rotate=false}}}if("fill-opacity" in aj||"opacity" in aj){var N=((+an["fill-opacity"]+1||2)-1)*((+an.opacity+1||2)-1)*((+l.getRGB(aj.fill).o+1||2)-1);N=C(I(N,0),1);af.opacity=N;if(af.src){af.color="none"}}ae.appendChild(af);var S=(ae.getElementsByTagName("stroke")&&ae.getElementsByTagName("stroke")[0]),ao=false;!S&&(ao=S=G("stroke"));if((aj.stroke&&aj.stroke!="none")||aj["stroke-width"]||aj["stroke-opacity"]!=null||aj["stroke-dasharray"]||aj["stroke-miterlimit"]||aj["stroke-linejoin"]||aj["stroke-linecap"]){S.on=true}(aj.stroke=="none"||aj.stroke===null||S.on==null||aj.stroke==0||aj["stroke-width"]==0)&&(S.on=false);var ad=l.getRGB(aj.stroke);S.on&&aj.stroke&&(S.color=ad.hex);N=((+an["stroke-opacity"]+1||2)-1)*((+an.opacity+1||2)-1)*((+ad.o+1||2)-1);var aa=(n(aj["stroke-width"])||1)*0.75;N=C(I(N,0),1);aj["stroke-width"]==null&&(aa=an["stroke-width"]);aj["stroke-width"]&&(S.weight=aa);aa&&aa<1&&(N*=aa)&&(S.weight=1);S.opacity=N;aj["stroke-linejoin"]&&(S.joinstyle=aj["stroke-linejoin"]||"miter");S.miterlimit=aj["stroke-miterlimit"]||8;aj["stroke-linecap"]&&(S.endcap=aj["stroke-linecap"]=="butt"?"flat":aj["stroke-linecap"]=="square"?"square":"round");if(aj["stroke-dasharray"]){var ac={"-":"shortdash",".":"shortdot","-.":"shortdashdot","-..":"shortdashdotdot",". ":"dot","- ":"dash","--":"longdash","- .":"dashdot","--.":"longdashdot","--..":"longdashdotdot"};S.dashstyle=ac[e](aj["stroke-dasharray"])?ac[aj["stroke-dasharray"]]:q}ao&&ae.appendChild(S)}if(aq.type=="text"){aq.paper.canvas.style.display=q;var ag=aq.paper.span,ab=100,L=an.font&&an.font.match(/\d+(?:\.\d*)?(?=px)/);V=ag.style;an.font&&(V.font=an.font);an["font-family"]&&(V.fontFamily=an["font-family"]);an["font-weight"]&&(V.fontWeight=an["font-weight"]);an["font-style"]&&(V.fontStyle=an["font-style"]);L=n(an["font-size"]||L&&L[0])||10;V.fontSize=L*ab+"px";aq.textpath.string&&(ag.innerHTML=F(aq.textpath.string).replace(/</g,"&#60;").replace(/&/g,"&#38;").replace(/\n/g,"<br>"));var U=ag.getBoundingClientRect();aq.W=an.w=(U.right-U.left)/ab;aq.H=an.h=(U.bottom-U.top)/ab;aq.X=an.x;aq.Y=an.y+aq.H/2;("x" in aj||"y" in aj)&&(aq.path.v=l.format("m{0},{1}l{2},{1}",B(an.x*b),B(an.y*b),B(an.x*b)+1));var T=["x","y","text","font","font-family","font-weight","font-style","font-size"];for(var ai=0,ak=T.length;ai<ak;ai++){if(T[ai] in aj){aq._.dirty=1;break}}switch(an["text-anchor"]){case"start":aq.textpath.style["v-text-align"]="left";aq.bbx=aq.W/2;break;case"end":aq.textpath.style["v-text-align"]="right";aq.bbx=-aq.W/2;break;default:aq.textpath.style["v-text-align"]="center";
aq.bbx=0;break}aq.textpath.style["v-text-kern"]=true}},a=function(E,R,U){E.attrs=E.attrs||{};var S=E.attrs,L=Math.pow,M,N,P="linear",Q=".5 .5";E.attrs.gradient=R;R=F(R).replace(l._radial_gradient,function(X,Y,W){P="radial";if(Y&&W){Y=n(Y);W=n(W);L(Y-0.5,2)+L(W-0.5,2)>0.25&&(W=h.sqrt(0.25-L(Y-0.5,2))*((W>0.5)*2-1)+0.5);Q=Y+k+W}return q});R=R.split(/\s*\-\s*/);if(P=="linear"){var J=R.shift();J=-n(J);if(isNaN(J)){return null}}var O=l._parseDots(R);if(!O){return null}E=E.shape||E.node;if(O.length){E.removeChild(U);U.on=true;U.method="none";U.color=O[0].color;U.color2=O[O.length-1].color;var V=[];for(var K=0,T=O.length;K<T;K++){O[K].offset&&V.push(O[K].offset+k+O[K].color)}U.colors=V.length?V.join():"0% "+U.color;if(P=="radial"){U.type="gradientTitle";U.focus="100%";U.focussize="0 0";U.focusposition=Q;U.angle=0}else{U.type="gradient";U.angle=(270-J)%360}E.appendChild(U)}return 1},u=function(J,E){this[0]=this.node=J;J.raphael=true;this.id=l._oid++;J.raphaelid=this.id;this.X=0;this.Y=0;this.attrs={};this.paper=E;this.matrix=l.matrix();this._={transform:[],sx:1,sy:1,dx:0,dy:0,deg:0,dirty:1,dirtyT:1};!E.bottom&&(E.bottom=this);this.prev=E.top;E.top&&(E.top.next=this);E.top=this;this.next=null};var m=l.el;u.prototype=m;m.constructor=u;m.transform=function(M){if(M==null){return this._.transform}var O=this.paper._viewBoxShift,N=O?"s"+[O.scale,O.scale]+"-1-1t"+[O.dx,O.dy]:q,R;if(O){R=M=F(M).replace(/\.{3}|\u2026/g,this._.transform||q)}l._extractTransform(this,N+M);var S=this.matrix.clone(),U=this.skew,K=this.node,Q,L=~F(this.attrs.fill).indexOf("-"),E=!F(this.attrs.fill).indexOf("url(");S.translate(-0.5,-0.5);if(E||L||this.type=="image"){U.matrix="1 0 0 1";U.offset="0 0";Q=S.split();if((L&&Q.noRotation)||!Q.isSimple){K.style.filter=S.toFilter();var P=this.getBBox(),J=this.getBBox(1),V=P.x-J.x,T=P.y-J.y;K.coordorigin=(V*-b)+k+(T*-b);p(this,1,1,V,T,0)}else{K.style.filter=q;p(this,Q.scalex,Q.scaley,Q.dx,Q.dy,Q.rotate)}}else{K.style.filter=q;U.matrix=F(S);U.offset=S.offset()}R&&(this._.transform=R);return this};m.rotate=function(J,E,L){if(this.removed){return this}if(J==null){return}J=F(J).split(i);if(J.length-1){E=n(J[1]);L=n(J[2])}J=n(J[0]);(L==null)&&(E=L);if(E==null||L==null){var K=this.getBBox(1);E=K.x+K.width/2;L=K.y+K.height/2}this._.dirtyT=1;this.transform(this._.transform.concat([["r",J,E,L]]));return this};m.translate=function(J,E){if(this.removed){return this}J=F(J).split(i);if(J.length-1){E=n(J[1])}J=n(J[0])||0;E=+E||0;if(this._.bbox){this._.bbox.x+=J;this._.bbox.y+=E}this.transform(this._.transform.concat([["t",J,E]]));return this};m.scale=function(M,K,E,L){if(this.removed){return this}M=F(M).split(i);if(M.length-1){K=n(M[1]);E=n(M[2]);L=n(M[3]);isNaN(E)&&(E=null);isNaN(L)&&(L=null)}M=n(M[0]);(K==null)&&(K=M);(L==null)&&(E=L);if(E==null||L==null){var J=this.getBBox(1)}E=E==null?J.x+J.width/2:E;L=L==null?J.y+J.height/2:L;this.transform(this._.transform.concat([["s",M,K,E,L]]));this._.dirtyT=1;return this};m.hide=function(){!this.removed&&(this.node.style.display="none");return this};m.show=function(){!this.removed&&(this.node.style.display=q);return this};m._getBBox=function(){if(this.removed){return{}}return{x:this.X+(this.bbx||0)-this.W/2,y:this.Y-this.H,width:this.W,height:this.H}};m.remove=function(){if(this.removed||!this.node.parentNode){return}this.paper.__set__&&this.paper.__set__.exclude(this);l.eve.unbind("raphael.*.*."+this.id);l._tear(this,this.paper);this.node.parentNode.removeChild(this.node);this.shape&&this.shape.parentNode.removeChild(this.shape);for(var E in this){this[E]=typeof this[E]=="function"?l._removedFactory(E):null}this.removed=true};m.attr=function(E,R){if(this.removed){return this}if(E==null){var O={};for(var Q in this.attrs){if(this.attrs[e](Q)){O[Q]=this.attrs[Q]}}O.gradient&&O.fill=="none"&&(O.fill=O.gradient)&&delete O.gradient;O.transform=this._.transform;return O}if(R==null&&l.is(E,"string")){if(E==v&&this.attrs.fill=="none"&&this.attrs.gradient){return this.attrs.gradient}var P=E.split(i),L={};for(var M=0,T=P.length;M<T;M++){E=P[M];if(E in this.attrs){L[E]=this.attrs[E]}else{if(l.is(this.paper.customAttributes[E],"function")){L[E]=this.paper.customAttributes[E].def}else{L[E]=l._availableAttrs[E]}}}return T-1?L:L[P[0]]}if(this.attrs&&R==null&&l.is(E,"array")){L={};for(M=0,T=E.length;M<T;M++){L[E[M]]=this.attr(E[M])}return L}var J;if(R!=null){J={};J[E]=R}R==null&&l.is(E,"object")&&(J=E);for(var S in J){A("raphael.attr."+S+"."+this.id,this,J[S])}if(J){for(S in this.paper.customAttributes){if(this.paper.customAttributes[e](S)&&J[e](S)&&l.is(this.paper.customAttributes[S],"function")){var N=this.paper.customAttributes[S].apply(this,[].concat(J[S]));this.attrs[S]=J[S];for(var K in N){if(N[e](K)){J[K]=N[K]}}}}if(J.text&&this.type=="text"){this.textpath.string=J.text}x(this,J)}return this};m.toFront=function(){!this.removed&&this.node.parentNode.appendChild(this.node);this.paper&&this.paper.top!=this&&l._tofront(this,this.paper);return this};m.toBack=function(){if(this.removed){return this}if(this.node.parentNode.firstChild!=this.node){this.node.parentNode.insertBefore(this.node,this.node.parentNode.firstChild);l._toback(this,this.paper)}return this};m.insertAfter=function(E){if(this.removed){return this}if(E.constructor==l.st.constructor){E=E[E.length-1]}if(E.node.nextSibling){E.node.parentNode.insertBefore(this.node,E.node.nextSibling)}else{E.node.parentNode.appendChild(this.node)}l._insertafter(this,E,this.paper);return this};m.insertBefore=function(E){if(this.removed){return this}if(E.constructor==l.st.constructor){E=E[0]}E.node.parentNode.insertBefore(this.node,E.node);l._insertbefore(this,E,this.paper);return this};m.blur=function(E){var J=this.node.runtimeStyle,K=J.filter;K=K.replace(t,q);if(+E!==0){this.attrs.blur=E;J.filter=K+k+w+".Blur(pixelradius="+(+E||1.5)+")";J.margin=l.format("-{0}px 0 0 -{0}px",B(+E||1.5))}else{J.filter=K;J.margin=0;delete this.attrs.blur}};l._engine.path=function(L,J){var M=G("shape");M.style.cssText=d;M.coordsize=b+k+b;M.coordorigin=J.coordorigin;var N=new u(M,J),E={fill:"none",stroke:"#000"};L&&(E.path=L);N.type="path";N.path=[];N.Path=q;x(N,E);J.canvas.appendChild(M);var K=G("skew");K.on=true;M.appendChild(K);N.skew=K;N.transform(q);return N};l._engine.rect=function(J,O,M,P,K,E){var Q=l._rectPath(O,M,P,K,E),L=J.path(Q),N=L.attrs;L.X=N.x=O;L.Y=N.y=M;L.W=N.width=P;L.H=N.height=K;N.r=E;N.path=Q;L.type="rect";return L};l._engine.ellipse=function(J,E,O,N,M){var L=J.path(),K=L.attrs;L.X=E-N;L.Y=O-M;L.W=N*2;L.H=M*2;L.type="ellipse";x(L,{cx:E,cy:O,rx:N,ry:M});return L};l._engine.circle=function(J,E,N,M){var L=J.path(),K=L.attrs;L.X=E-M;L.Y=N-M;L.W=L.H=M*2;L.type="circle";x(L,{cx:E,cy:N,r:M});return L};l._engine.image=function(J,E,P,N,Q,L){var S=l._rectPath(P,N,Q,L),M=J.path(S).attr({stroke:"none"}),O=M.attrs,K=M.node,R=K.getElementsByTagName(v)[0];O.src=E;M.X=O.x=P;M.Y=O.y=N;M.W=O.width=Q;M.H=O.height=L;O.path=S;M.type="image";R.parentNode==K&&K.removeChild(R);R.rotate=true;R.src=E;R.type="tile";M._.fillpos=[P,N];M._.fillsize=[Q,L];
K.appendChild(R);p(M,1,1,0,0,0);return M};l._engine.text=function(E,O,N,P){var L=G("shape"),R=G("path"),K=G("textpath");O=O||0;N=N||0;P=P||"";R.v=l.format("m{0},{1}l{2},{1}",B(O*b),B(N*b),B(O*b)+1);R.textpathok=true;K.string=F(P);K.on=true;L.style.cssText=d;L.coordsize=b+k+b;L.coordorigin="0 0";var J=new u(L,E),M={fill:"#000",stroke:"none",font:l._availableAttrs.font,text:P};J.shape=L;J.path=R;J.textpath=K;J.type="text";J.attrs.text=F(P);J.attrs.x=O;J.attrs.y=N;J.attrs.w=1;J.attrs.h=1;x(J,M);L.appendChild(K);L.appendChild(R);E.canvas.appendChild(L);var Q=G("skew");Q.on=true;L.appendChild(Q);J.skew=Q;J.transform(q);return J};l._engine.setSize=function(K,E){var J=this.canvas.style;this.width=K;this.height=E;K==+K&&(K+="px");E==+E&&(E+="px");J.width=K;J.height=E;J.clip="rect(0 "+K+" "+E+" 0)";if(this._viewBox){l._engine.setViewBox.apply(this,this._viewBox)}return this};l._engine.setViewBox=function(N,M,O,K,L){l.eve("raphael.setViewBox",this,this._viewBox,[N,M,O,K,L]);var E=this.width,Q=this.height,R=1/I(O/E,K/Q),P,J;if(L){P=Q/K;J=E/O;if(O*P<E){N-=(E-O*P)/2/P}if(K*J<Q){M-=(Q-K*J)/2/J}}this._viewBox=[N,M,O,K,!!L];this._viewBoxShift={dx:-N,dy:-M,scale:R};this.forEach(function(S){S.transform("...")});return this};var G;l._engine.initWin=function(K){var J=K.document;J.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)");try{!J.namespaces.rvml&&J.namespaces.add("rvml","urn:schemas-microsoft-com:vml");G=function(L){return J.createElement("<rvml:"+L+' class="rvml">')}}catch(E){G=function(L){return J.createElement("<"+L+' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')}}};l._engine.initWin(l._g.win);l._engine.create=function(){var K=l._getContainer.apply(0,arguments),E=K.container,Q=K.height,R,J=K.width,P=K.x,O=K.y;if(!E){throw new Error("VML container not found.")}var M=new l._Paper,N=M.canvas=l._g.doc.createElement("div"),L=N.style;P=P||0;O=O||0;J=J||512;Q=Q||342;M.width=J;M.height=Q;J==+J&&(J+="px");Q==+Q&&(Q+="px");M.coordsize=b*1000+k+b*1000;M.coordorigin="0 0";M.span=l._g.doc.createElement("span");M.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";N.appendChild(M.span);L.cssText=l.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden",J,Q);if(E==1){l._g.doc.body.appendChild(N);L.left=P+"px";L.top=O+"px";L.position="absolute"}else{if(E.firstChild){E.insertBefore(N,E.firstChild)}else{E.appendChild(N)}}M.renderfix=function(){};return M};l.prototype.clear=function(){l.eve("raphael.clear",this);this.canvas.innerHTML=q;this.span=l._g.doc.createElement("span");this.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";this.canvas.appendChild(this.span);this.bottom=this.top=null};l.prototype.remove=function(){l.eve("raphael.remove",this);this.canvas.parentNode.removeChild(this.canvas);for(var E in this){this[E]=typeof this[E]=="function"?l._removedFactory(E):null}return true};var y=l.st;for(var g in m){if(m[e](g)&&!y[e](g)){y[g]=(function(E){return function(){var J=arguments;return this.forEach(function(K){K[E].apply(K,J)})}})(g)}}}(window.Raphael);if(!window.ABCJS){window.ABCJS={}}(function(){ABCJS.numberOfTunes=function(d){var b=d.split("\nX:");var c=b.length;if(c===0){c=1}return c};ABCJS.TuneBook=function(d){var h=this;var g="";d=window.ABCJS.parse.strip(d);var b=d.split("\nX:");for(var f=1;f<b.length;f++){b[f]="X:"+b[f]}var j=0;h.tunes=[];window.ABCJS.parse.each(b,function(i){h.tunes.push({abc:i,startPos:j});j+=i.length});if(h.tunes.length>1&&!window.ABCJS.parse.startsWith(h.tunes[0].abc,"X:")){var c=h.tunes.shift();var e=c.abc.split("\n");window.ABCJS.parse.each(e,function(i){if(window.ABCJS.parse.startsWith(i,"%%")){g+=i+"\n"}})}h.header=g;window.ABCJS.parse.each(h.tunes,function(k){var i=k.abc.indexOf("\n\n");if(i>0){k.abc=k.abc.substring(0,i)}k.pure=k.abc;k.abc=g+k.abc;var l=k.pure.split("T:");if(l.length>1){l=l[1].split("\n");k.title=l[0].replace(/^\s+|\s+$/g,"")}else{k.title=""}var m=k.pure.substring(2,k.pure.indexOf("\n"));k.id=m.replace(/^\s+|\s+$/g,"")})};ABCJS.TuneBook.prototype.getTuneById=function(c){for(var b=0;b<this.tunes.length;b++){if(this.tunes[b].id===c){return this.tunes[b]}}return null};ABCJS.TuneBook.prototype.getTuneByTitle=function(c){for(var b=0;b<this.tunes.length;b++){if(this.tunes[b].title===c){return this.tunes[b]}}return null};function a(n,e,m,l,d){var k=function(i){return i&&!(i.propertyIsEnumerable("length"))&&typeof i==="object"&&typeof i.length==="number"};if(e===undefined||m===undefined){return}if(!k(e)){e=[e]}if(l===undefined){l={}}if(d===undefined){d={}}var g=d.startingTune?d.startingTune:0;var f=new ABCJS.TuneBook(m);var c=new window.ABCJS.parse.Parse();for(var h=0;h<e.length;h++){var b=e[h];if(typeof(b)==="string"){b=document.getElementById(b)}if(b){b.innerHTML="";if(g<f.tunes.length){c.parse(f.tunes[g].abc,l);var j=c.getTune();n(b,j)}}g++}}ABCJS.renderAbc=function(c,e,b,d,f){function g(l,j){var h=f?f.width?f.width:800:800;var k=Raphael(l,h,400);if(d===undefined){d={}}var i=new ABCJS.write.Printer(k,d);i.printABC(j)}a(g,c,e,b,f)};ABCJS.renderMidi=function(c,d,b,f,e){function g(j,h){if(f===undefined){f={}}var i=new ABCJS.midi.MidiWriter(j,f);i.writeABC(h)}a(g,c,d,b,e)}})();if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.data){window.ABCJS.data={}}window.ABCJS.data.Tune=function(){this.reset=function(){this.version="1.0.1";this.media="screen";this.metaText={};this.formatting={};this.lines=[];this.staffNum=0;this.voiceNum=0;this.lineNum=0};this.cleanUp=function(f,p,y,q){this.closeLine();var b=false;var x,o,k;for(x=0;x<this.lines.length;x++){if(this.lines[x].staff!==undefined){var m=false;for(o=0;o<this.lines[x].staff.length;o++){if(this.lines[x].staff[o]===undefined){b=true;this.lines[x].staff[o]=null}else{for(k=0;k<this.lines[x].staff[o].voices.length;k++){if(this.lines[x].staff[o].voices[k]===undefined){this.lines[x].staff[o].voices[k]=[]}else{if(this.containsNotes(this.lines[x].staff[o].voices[k])){m=true}}}}}if(!m){this.lines[x]=null;b=true}}}if(b){this.lines=window.ABCJS.parse.compact(this.lines);window.ABCJS.parse.each(this.lines,function(i){if(i.staff){i.staff=window.ABCJS.parse.compact(i.staff)}})}if(y){for(x=0;x<this.lines.length;x++){if(this.lines[x].staff!==undefined){for(o=0;o<this.lines[x].staff.length;o++){for(k=0;k<this.lines[x].staff[o].voices.length;k++){var d=0;for(var t=0;t<this.lines[x].staff[o].voices[k].length;t++){if(this.lines[x].staff[o].voices[k][t].el_type==="bar"){d++;if(d>=y){if(t<this.lines[x].staff[o].voices[k].length-1){if(x===this.lines.length-1){var g=JSON.parse(JSON.stringify(this.lines[x]));this.lines.push(window.ABCJS.parse.clone(g));for(var u=0;u<this.lines[x+1].staff.length;u++){for(var r=0;r<this.lines[x+1].staff[u].voices.length;r++){this.lines[x+1].staff[u].voices[r]=[]}}}var a=t+1;var h=this.lines[x].staff[o].voices[k].slice(a);this.lines[x].staff[o].voices[k]=this.lines[x].staff[o].voices[k].slice(0,a);this.lines[x+1].staff[o].voices[k]=h.concat(this.lines[x+1].staff[o].voices[k])
}}}}}}}}}if(y){b=false;for(x=0;x<this.lines.length;x++){if(this.lines[x].staff!==undefined){for(o=0;o<this.lines[x].staff.length;o++){var c=false;for(k=0;k<this.lines[x].staff[o].voices.length;k++){if(this.containsNotesStrict(this.lines[x].staff[o].voices[k])){c=true}}if(!c){b=true;this.lines[x].staff[o]=null}}}}if(b){window.ABCJS.parse.each(this.lines,function(i){if(i.staff){i.staff=window.ABCJS.parse.compact(i.staff)}})}}for(x=0;x<this.lines.length;x++){if(this.lines[x].staff){for(o=0;o<this.lines[x].staff.length;o++){delete this.lines[x].staff[o].workingClef}}}function l(K){var J=[];var H;var I=function(N,j,P){if(J[P]===undefined){for(H=0;H<J.length;H++){if(J[H]!==undefined){P=H;break}}if(J[P]===undefined){var O=P*100;window.ABCJS.parse.each(N.endSlur,function(i){if(O===i){--O}});J[P]=[O]}}var M;for(var L=0;L<j;L++){M=J[P].pop();N.endSlur.push(M)}if(J[P].length===0){delete J[P]}return M};var C=function(N,j,O,M){N.startSlur=[];if(J[O]===undefined){J[O]=[]}var P=O*100+1;for(var L=0;L<j;L++){if(M){window.ABCJS.parse.each(M,function(i){if(P===i){++P}});window.ABCJS.parse.each(M,function(i){if(P===i){++P}});window.ABCJS.parse.each(M,function(i){if(P===i){++P}})}window.ABCJS.parse.each(J[O],function(i){if(P===i){++P}});window.ABCJS.parse.each(J[O],function(i){if(P===i){++P}});J[O].push(P);N.startSlur.push({label:P});P++}};for(var D=0;D<K.length;D++){var v=K[D];if(v.el_type==="note"){if(v.gracenotes){for(var E=0;E<v.gracenotes.length;E++){if(v.gracenotes[E].endSlur){var F=v.gracenotes[E].endSlur;v.gracenotes[E].endSlur=[];for(var n=0;n<F;n++){I(v.gracenotes[E],1,20)}}if(v.gracenotes[E].startSlur){H=v.gracenotes[E].startSlur;C(v.gracenotes[E],H,20)}}}if(v.endSlur){H=v.endSlur;v.endSlur=[];I(v,H,0)}if(v.startSlur){H=v.startSlur;C(v,H,0)}if(v.pitches){var G=[];for(var s=0;s<v.pitches.length;s++){if(v.pitches[s].endSlur){var A=v.pitches[s].endSlur;v.pitches[s].endSlur=[];for(var B=0;B<A;B++){var z=I(v.pitches[s],1,s+1);G.push(z)}}}for(s=0;s<v.pitches.length;s++){if(v.pitches[s].startSlur){H=v.pitches[s].startSlur;C(v.pitches[s],H,s+1,G)}}if(v.gracenotes&&v.pitches[0].endSlur&&v.pitches[0].endSlur[0]===100&&v.pitches[0].startSlur){if(v.gracenotes[0].endSlur){v.gracenotes[0].endSlur.push(v.pitches[0].startSlur[0].label)}else{v.gracenotes[0].endSlur=[v.pitches[0].startSlur[0].label]}if(v.pitches[0].endSlur.length===1){delete v.pitches[0].endSlur}else{if(v.pitches[0].endSlur[0]===100){v.pitches[0].endSlur.shift()}else{if(v.pitches[0].endSlur[v.pitches[0].endSlur.length-1]===100){v.pitches[0].endSlur.pop()}}}if(J[1].length===1){delete J[1]}else{J[1].pop()}}}}}}function e(i){window.ABCJS.parse.parseKeyVoice.fixClef(i)}for(this.lineNum=0;this.lineNum<this.lines.length;this.lineNum++){if(this.lines[this.lineNum].staff){for(this.staffNum=0;this.staffNum<this.lines[this.lineNum].staff.length;this.staffNum++){if(this.lines[this.lineNum].staff[this.staffNum].clef){e(this.lines[this.lineNum].staff[this.staffNum].clef)}for(this.voiceNum=0;this.voiceNum<this.lines[this.lineNum].staff[this.staffNum].voices.length;this.voiceNum++){l(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]);for(var w=0;w<this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length;w++){if(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][w].el_type==="clef"){e(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][w])}}}}}}if(!this.formatting.pagewidth){this.formatting.pagewidth=f}if(!this.formatting.pageheight){this.formatting.pageheight=p}delete this.staffNum;delete this.voiceNum;delete this.lineNum;delete this.potentialStartBeam;delete this.potentialEndBeam;delete this.vskipPending};this.reset();this.getLastNote=function(){if(this.lines[this.lineNum]&&this.lines[this.lineNum].staff&&this.lines[this.lineNum].staff[this.staffNum]&&this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]){for(var a=this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum].length-1;a>=0;a--){var b=this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum][a];if(b.el_type==="note"){return b}}}return null};this.addTieToLastNote=function(){var a=this.getLastNote();if(a&&a.pitches&&a.pitches.length>0){a.pitches[0].startTie={};return true}return false};this.getDuration=function(a){if(a.duration){return a.duration}return 0};this.closeLine=function(){if(this.potentialStartBeam&&this.potentialEndBeam){this.potentialStartBeam.startBeam=true;this.potentialEndBeam.endBeam=true}delete this.potentialStartBeam;delete this.potentialEndBeam};this.appendElement=function(h,i,e,a){var c=this;var g=function(l){if(l.pitches!==undefined){var j=c.lines[c.lineNum].staff[c.staffNum].workingClef.verticalPos;window.ABCJS.parse.each(l.pitches,function(m){m.verticalPos=m.pitch-j})}if(l.gracenotes!==undefined){var k=c.lines[c.lineNum].staff[c.staffNum].workingClef.verticalPos;window.ABCJS.parse.each(l.gracenotes,function(m){m.verticalPos=m.pitch-k})}c.lines[c.lineNum].staff[c.staffNum].voices[c.voiceNum].push(l)};a.el_type=h;if(i!==null){a.startChar=i}if(e!==null){a.endChar=e}var d=function(){c.potentialStartBeam.startBeam=true;a.endBeam=true;delete c.potentialStartBeam;delete c.potentialEndBeam};var f=function(){if(c.potentialStartBeam!==undefined&&c.potentialEndBeam!==undefined){c.potentialStartBeam.startBeam=true;c.potentialEndBeam.endBeam=true}delete c.potentialStartBeam;delete c.potentialEndBeam};if(h==="note"){var b=c.getDuration(a);if(b>=0.25){f()}else{if(a.force_end_beam_last&&c.potentialStartBeam!==undefined){f()}else{if(a.end_beam&&c.potentialStartBeam!==undefined){if(a.rest===undefined){d()}else{f()}}else{if(a.rest===undefined){if(c.potentialStartBeam===undefined){if(!a.end_beam){c.potentialStartBeam=a;delete c.potentialEndBeam}}else{c.potentialEndBeam=a}}}}}}else{f()}delete a.end_beam;delete a.force_end_beam_last;g(a)};this.appendStartingElement=function(f,a,h,c){this.closeLine();var e;if(f==="key"){e=c.impliedNaturals;delete c.impliedNaturals}var b=window.ABCJS.parse.clone(c);if(f==="clef"){this.lines[this.lineNum].staff[this.staffNum].workingClef=b}if(this.lines[this.lineNum].staff.length<=this.staffNum){this.lines[this.lineNum].staff[this.staffNum]={};this.lines[this.lineNum].staff[this.staffNum].clef=window.ABCJS.parse.clone(this.lines[this.lineNum].staff[0].clef);this.lines[this.lineNum].staff[this.staffNum].key=window.ABCJS.parse.clone(this.lines[this.lineNum].staff[0].key);this.lines[this.lineNum].staff[this.staffNum].meter=window.ABCJS.parse.clone(this.lines[this.lineNum].staff[0].meter);this.lines[this.lineNum].staff[this.staffNum].workingClef=window.ABCJS.parse.clone(this.lines[this.lineNum].staff[0].workingClef);this.lines[this.lineNum].staff[this.staffNum].voices=[[]]}var g=this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum];for(var d=0;d<g.length;d++){if(g[d].el_type==="note"||g[d].el_type==="bar"){b.el_type=f;b.startChar=a;b.endChar=h;if(e){b.accidentals=e.concat(b.accidentals)}g.push(b);return}if(g[d].el_type===f){b.el_type=f;b.startChar=a;
b.endChar=h;if(e){b.accidentals=e.concat(b.accidentals)}g[d]=b;return}}this.lines[this.lineNum].staff[this.staffNum][f]=c};this.getNumLines=function(){return this.lines.length};this.pushLine=function(a){if(this.vskipPending){a.vskip=this.vskipPending;delete this.vskipPending}this.lines.push(a)};this.addSubtitle=function(a){this.pushLine({subtitle:a})};this.addSpacing=function(a){this.vskipPending=a};this.addNewPage=function(a){this.pushLine({newpage:a})};this.addSeparator=function(c,b,a){this.pushLine({separator:{spaceAbove:c,spaceBelow:b,lineLength:a}})};this.addText=function(a){this.pushLine({text:a})};this.addCentered=function(a){this.pushLine({text:[{text:a,center:true}]})};this.containsNotes=function(b){for(var a=0;a<b.length;a++){if(b[a].el_type==="note"||b[a].el_type==="bar"){return true}}return false};this.containsNotesStrict=function(b){for(var a=0;a<b.length;a++){if(b[a].el_type==="note"&&b[a].rest===undefined){return true}}return false};this.startNewLine=function(e){var d=this;this.closeLine();var c=function(j){d.lines[d.lineNum].staff[d.staffNum].voices[d.voiceNum]=[];if(d.isFirstLine(d.lineNum)){if(j.name){if(!d.lines[d.lineNum].staff[d.staffNum].title){d.lines[d.lineNum].staff[d.staffNum].title=[]}d.lines[d.lineNum].staff[d.staffNum].title[d.voiceNum]=j.name}}else{if(j.subname){if(!d.lines[d.lineNum].staff[d.staffNum].title){d.lines[d.lineNum].staff[d.staffNum].title=[]}d.lines[d.lineNum].staff[d.staffNum].title[d.voiceNum]=j.subname}}if(j.style){d.appendElement("style",null,null,{head:j.style})}if(j.stem){d.appendElement("stem",null,null,{direction:j.stem})}else{if(d.voiceNum>0){if(d.lines[d.lineNum].staff[d.staffNum].voices[0]!==undefined){var g=false;for(var f=0;f<d.lines[d.lineNum].staff[d.staffNum].voices[0].length;f++){if(d.lines[d.lineNum].staff[d.staffNum].voices[0].el_type==="stem"){g=true}}if(!g){var h={el_type:"stem",direction:"up"};d.lines[d.lineNum].staff[d.staffNum].voices[0].splice(0,0,h)}}d.appendElement("stem",null,null,{direction:"down"})}}if(j.scale){d.appendElement("scale",null,null,{size:j.scale})}};var a=function(f){d.lines[d.lineNum].staff[d.staffNum]={voices:[],clef:f.clef,key:f.key,workingClef:f.clef};if(f.vocalfont){d.lines[d.lineNum].staff[d.staffNum].vocalfont=f.vocalfont}if(f.bracket){d.lines[d.lineNum].staff[d.staffNum].bracket=f.bracket}if(f.brace){d.lines[d.lineNum].staff[d.staffNum].brace=f.brace}if(f.connectBarLines){d.lines[d.lineNum].staff[d.staffNum].connectBarLines=f.connectBarLines}c(f);if(f.part){d.appendElement("part",f.startChar,f.endChar,{title:f.part})}if(f.meter!==undefined){d.lines[d.lineNum].staff[d.staffNum].meter=f.meter}};var b=function(f){d.lines[d.lineNum]={staff:[]};a(f)};if(this.lines[this.lineNum]===undefined){b(e)}else{if(this.lines[this.lineNum].staff===undefined){this.lineNum++;this.startNewLine(e)}else{if(this.lines[this.lineNum].staff[this.staffNum]===undefined){a(e)}else{if(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]===undefined){c(e)}else{if(!this.containsNotes(this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum])){return}else{this.lineNum++;this.startNewLine(e)}}}}}};this.hasBeginMusic=function(){return this.lines.length>0};this.isFirstLine=function(a){for(var b=a-1;b>=0;b--){if(this.lines[b].staff!==undefined){return false}}return true};this.getCurrentVoice=function(){if(this.lines[this.lineNum]!==undefined&&this.lines[this.lineNum].staff[this.staffNum]!==undefined&&this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]!==undefined){return this.lines[this.lineNum].staff[this.staffNum].voices[this.voiceNum]}else{return null}};this.setCurrentVoice=function(c,b){this.staffNum=c;this.voiceNum=b;for(var a=0;a<this.lines.length;a++){if(this.lines[a].staff){if(this.lines[a].staff[c]===undefined||this.lines[a].staff[c].voices[b]===undefined||!this.containsNotes(this.lines[a].staff[c].voices[b])){this.lineNum=a;return}}}this.lineNum=a};this.addMetaText=function(a,b){if(this.metaText[a]===undefined){this.metaText[a]=b}else{this.metaText[a]+="\n"+b}};this.addMetaTextArray=function(a,b){if(this.metaText[a]===undefined){this.metaText[a]=[b]}else{this.metaText[a].push(b)}};this.addMetaTextObj=function(a,b){this.metaText[a]=b}};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.midi){window.ABCJS.midi={}}(function(){function a(j,i){for(var h in i){if(i.hasOwnProperty(h)){j.setAttribute(h,i[h])}}return j}function g(h,i){this.javamidi=h;this.qtmidi=i}g.prototype.setTempo=function(h){this.javamidi.setTempo(h);this.qtmidi.setTempo(h)};g.prototype.startTrack=function(){this.javamidi.startTrack();this.qtmidi.startTrack()};g.prototype.endTrack=function(){this.javamidi.endTrack();this.qtmidi.endTrack()};g.prototype.setInstrument=function(h){this.javamidi.setInstrument(h);this.qtmidi.setInstrument(h)};g.prototype.startNote=function(j,h,i){this.javamidi.startNote(j,h,i);this.qtmidi.startNote(j,h,i)};g.prototype.endNote=function(i,h){this.javamidi.endNote(i,h);this.qtmidi.endNote(i,h)};g.prototype.addRest=function(h){this.javamidi.addRest(h);this.qtmidi.addRest(h)};g.prototype.embed=function(h){this.javamidi.embed(h);this.qtmidi.embed(h,true)};function b(h){this.playlist=[];this.trackcount=0;this.timecount=0;this.tempo=60;this.midiapi=MIDIPlugin;this.midiwriter=h;this.noteOnAndChannel="%90"}b.prototype.setTempo=function(h){this.tempo=h};b.prototype.startTrack=function(){this.silencelength=0;this.trackcount++;this.timecount=0;this.playlistpos=0;this.first=true;if(this.instrument){this.setInstrument(this.instrument)}if(this.channel){this.setChannel(this.channel)}};b.prototype.endTrack=function(){};b.prototype.setInstrument=function(h){this.instrument=h;this.midiapi.setInstrument(h)};b.prototype.setChannel=function(h){this.channel=h;this.midiapi.setChannel(h)};b.prototype.updatePos=function(){while(this.playlist[this.playlistpos]&&this.playlist[this.playlistpos].time<this.timecount){this.playlistpos++}};b.prototype.startNote=function(k,i,j){this.timecount+=this.silencelength;this.silencelength=0;if(this.first){}this.updatePos();var h=this;this.playlist.splice(this.playlistpos,0,{time:this.timecount,funct:function(){h.midiapi.playNote(k);h.midiwriter.notifySelect(j)}})};b.prototype.endNote=function(j,i){this.timecount+=i;this.updatePos();var h=this;this.playlist.splice(this.playlistpos,0,{time:this.timecount,funct:function(){h.midiapi.stopNote(j)}})};b.prototype.addRest=function(h){this.silencelength+=h};b.prototype.embed=function(i){this.playlink=a(document.createElement("a"),{style:"border:1px solid black; margin:3px;"});this.playlink.innerHTML="play";var h=this;this.playlink.onmousedown=function(){if(h.playing){this.innerHTML="play";h.pausePlay()}else{this.innerHTML="pause";h.startPlay()}};i.appendChild(this.playlink);var j=a(document.createElement("a"),{style:"border:1px solid black; margin:3px;"});j.innerHTML="stop";j.onmousedown=function(){h.stopPlay()};i.appendChild(j);this.i=0;this.currenttime=0;this.playing=false};b.prototype.stopPlay=function(){this.i=0;this.currenttime=0;
this.pausePlay();this.playlink.innerHTML="play"};b.prototype.startPlay=function(){this.playing=true;var h=this;this.ticksperinterval=480/4;this.doPlay();this.playinterval=window.setInterval(function(){h.doPlay()},(60000/(this.tempo*4)))};b.prototype.pausePlay=function(){this.playing=false;window.clearInterval(this.playinterval);this.midiapi.stopAllNotes()};b.prototype.doPlay=function(){while(this.playlist[this.i]&&this.playlist[this.i].time<=this.currenttime){this.playlist[this.i].funct();this.i++}if(this.playlist[this.i]){this.currenttime+=this.ticksperinterval}else{this.stopPlay()}};function d(){this.trackstrings="";this.trackcount=0;this.noteOnAndChannel="%90"}d.prototype.setTempo=function(h){if(this.trackcount===0){this.startTrack();this.track+="%00%FF%51%03"+c(Math.round(60000000/h),6);this.endTrack()}};d.prototype.startTrack=function(){this.track="";this.silencelength=0;this.trackcount++;this.first=true;if(this.instrument){this.setInstrument(this.instrument)}};d.prototype.endTrack=function(){var h=c(this.track.length/3+4,8);this.track="MTrk"+h+this.track+"%00%FF%2F%00";this.trackstrings+=this.track};d.prototype.setInstrument=function(h){if(this.track){this.track="%00%C0"+c(h,2)+this.track}else{this.track="%00%C0"+c(h,2)}this.instrument=h};d.prototype.setChannel=function(h){this.channel=h-1;this.noteOnAndChannel="%9"+this.channel.toString(16)};d.prototype.startNote=function(i,h){this.track+=e(this.silencelength);this.silencelength=0;if(this.first){this.first=false;this.track+=this.noteOnAndChannel}this.track+="%"+i.toString(16)+"%"+h};d.prototype.endNote=function(i,h){this.track+=e(h);this.track+="%"+i.toString(16)+"%00"};d.prototype.addRest=function(h){this.silencelength+=h};d.prototype.embed=function(i,h){var k="data:audio/midi,MThd%00%00%00%06%00%01"+c(this.trackcount,4)+"%01%e0"+this.trackstrings;var j=a(document.createElement("a"),{href:k});j.innerHTML="download midi";i.insertBefore(j,i.firstChild);if(h){return}var l=a(document.createElement("embed"),{src:k,type:"video/quicktime",controller:"true",autoplay:"false",loop:"false",enablejavascript:"true",style:"display:block; height: 20px;"});i.insertBefore(l,i.firstChild)};function f(k){var h="";for(var j=0;j<k.length;j+=2){h+="%";h+=k.substr(j,2)}return h}function c(j,i){var h=j.toString(16);while(h.length<i){h="0"+h}return f(h)}function e(o){var k=0;var h=[];while(o!==0){h.push(o&127);o=o>>7}for(var j=h.length-1;j>=0;j--){k=k<<8;var l=h[j];if(j!==0){l=l|128}k=k|l}var m=k.toString(16).length;m+=m%2;return c(k,m)}ABCJS.midi.MidiWriter=function(i,h){h=h||{};this.parent=i;this.scale=[0,2,4,5,7,9,11];this.restart={line:0,staff:0,voice:0,pos:0};this.visited={};this.multiplier=1;this.next=null;this.qpm=h.qpm||180;this.program=h.program||2;this.noteOnAndChannel="%90";this.javamidi=h.type==="java"||false;this.listeners=[];this.transpose=0;if(this.javamidi){MIDIPlugin=document.MIDIPlugin;setTimeout(function(){try{MIDIPlugin.openPlugin()}catch(k){var j=document.createElement("a");j.href="http://java.sun.com/products/java-media/sound/soundbanks.html";j.target="_blank";j.appendChild(document.createTextNode("Download Soundbank"));i.appendChild(j)}},0)}};ABCJS.midi.MidiWriter.prototype.addListener=function(h){this.listeners.push(h)};ABCJS.midi.MidiWriter.prototype.notifySelect=function(j){for(var h=0;h<this.listeners.length;h++){this.listeners[h].notifySelect(j.abselem)}};ABCJS.midi.MidiWriter.prototype.getMark=function(){return{line:this.line,staff:this.staff,voice:this.voice,pos:this.pos}};ABCJS.midi.MidiWriter.prototype.getMarkString=function(h){h=h||this;return"line"+h.line+"staff"+h.staff+"voice"+h.voice+"pos"+h.pos};ABCJS.midi.MidiWriter.prototype.goToMark=function(h){this.line=h.line;this.staff=h.staff;this.voice=h.voice;this.pos=h.pos};ABCJS.midi.MidiWriter.prototype.markVisited=function(){this.lastmark=this.getMarkString();this.visited[this.lastmark]=true};ABCJS.midi.MidiWriter.prototype.isVisited=function(){if(this.visited[this.getMarkString()]){return true}return false};ABCJS.midi.MidiWriter.prototype.setJumpMark=function(h){this.visited[this.lastmark]=h};ABCJS.midi.MidiWriter.prototype.getJumpMark=function(){return this.visited[this.getMarkString()]};ABCJS.midi.MidiWriter.prototype.getLine=function(){return this.abctune.lines[this.line]};ABCJS.midi.MidiWriter.prototype.getStaff=function(){try{return this.getLine().staff[this.staff]}catch(h){}};ABCJS.midi.MidiWriter.prototype.getVoice=function(){return this.getStaff().voices[this.voice]};ABCJS.midi.MidiWriter.prototype.getElem=function(){return this.getVoice()[this.pos]};ABCJS.midi.MidiWriter.prototype.writeABC=function(l){try{this.midi=(this.javamidi)?new g(new b(this),new d()):new d();this.baraccidentals=[];this.abctune=l;this.baseduration=480*4;if(l.formatting.midi&&l.formatting.midi.transpose){this.transpose=l.formatting.midi.transpose}if(l.formatting.midi&&l.formatting.midi.program&&l.formatting.midi.program.program){this.midi.setInstrument(l.formatting.midi.program.program)}else{this.midi.setInstrument(this.program)}if(l.formatting.midi&&l.formatting.midi.channel){this.midi.setChannel(l.formatting.midi.channel)}if(l.metaText.tempo){var k=1/4;if(l.metaText.tempo.duration){k=l.metaText.tempo.duration[0]}var j=60;if(l.metaText.tempo.bpm){j=l.metaText.tempo.bpm}this.qpm=j*k*4}this.midi.setTempo(this.qpm);this.staffcount=1;for(this.staff=0;this.staff<this.staffcount;this.staff++){this.voicecount=1;for(this.voice=0;this.voice<this.voicecount;this.voice++){this.midi.startTrack();this.restart={line:0,staff:this.staff,voice:this.voice,pos:0};this.next=null;for(this.line=0;this.line<l.lines.length;this.line++){var h=l.lines[this.line];if(this.getLine().staff){this.writeABCLine()}}this.midi.endTrack()}}this.midi.embed(this.parent)}catch(i){this.parent.innerHTML="Couldn't write midi: "+i}};ABCJS.midi.MidiWriter.prototype.writeABCLine=function(){this.staffcount=this.getLine().staff.length;this.voicecount=this.getStaff().voices.length;this.setKeySignature(this.getStaff().key);this.writeABCVoiceLine()};ABCJS.midi.MidiWriter.prototype.writeABCVoiceLine=function(){this.pos=0;while(this.pos<this.getVoice().length){this.writeABCElement(this.getElem());if(this.next){this.goToMark(this.next);this.next=null;if(!this.getLine().staff){return}}else{this.pos++}}};ABCJS.midi.MidiWriter.prototype.writeABCElement=function(h){var i;switch(h.el_type){case"note":this.writeNote(h);break;case"key":this.setKeySignature(h);break;case"bar":this.handleBar(h);break;case"meter":case"clef":break;default:}};ABCJS.midi.MidiWriter.prototype.writeNote=function(m){if(m.startTriplet){if(m.startTriplet===2){this.multiplier=3/2}else{this.multiplier=(m.startTriplet-1)/m.startTriplet}}var h=m.duration*this.baseduration*this.multiplier;if(m.pitches){var l=[];for(var j=0;j<m.pitches.length;j++){var k=m.pitches[j];var n=k.pitch;if(k.accidental){switch(k.accidental){case"sharp":this.baraccidentals[n]=1;break;case"flat":this.baraccidentals[n]=-1;break;case"natural":this.baraccidentals[n]=0;break;case"dblsharp":this.baraccidentals[n]=2;
break;case"dblflat":this.baraccidentals[n]=-2;break}}l[j]=60+12*this.extractOctave(n)+this.scale[this.extractNote(n)];if(this.baraccidentals[n]!==undefined){l[j]+=this.baraccidentals[n]}else{l[j]+=this.accidentals[this.extractNote(n)]}l[j]+=this.transpose;this.midi.startNote(l[j],64,m);if(k.startTie){this.tieduration=h}}for(j=0;j<m.pitches.length;j++){var k=m.pitches[j];var n=k.pitch+this.transpose;if(k.startTie){continue}if(k.endTie){this.midi.endNote(l[j],h+this.tieduration)}else{this.midi.endNote(l[j],h)}h=0;this.tieduration=0}}else{if(m.rest&&m.rest.type!=="spacer"){this.midi.addRest(h)}}if(m.endTriplet){this.multiplier=1}};ABCJS.midi.MidiWriter.prototype.handleBar=function(l){this.baraccidentals=[];var m=(l.type==="bar_right_repeat"||l.type==="bar_dbl_repeat");var k=(l.startEnding)?true:false;var h=(m||k);var j=(l.type==="bar_left_repeat"||l.type==="bar_dbl_repeat"||l.type==="bar_thick_thin"||l.type==="bar_thin_thick"||l.type==="bar_thin_thin"||l.type==="bar_right_repeat");var i=null;if(this.isVisited()){i=this.getJumpMark()}else{if(k||m){if(this.visited[this.lastmark]===true){this.setJumpMark(this.getMark())}}if(h){this.markVisited()}if(m){i=this.restart;this.setJumpMark(this.getMark())}}if(j){this.restart=this.getMark()}if(i&&this.getMarkString(i)!==this.getMarkString()){this.next=i}};ABCJS.midi.MidiWriter.prototype.setKeySignature=function(h){this.accidentals=[0,0,0,0,0,0,0];if(this.abctune.formatting.bagpipes){h.accidentals=[{acc:"natural",note:"g"},{acc:"sharp",note:"f"},{acc:"sharp",note:"c"}]}if(!h.accidentals){return}window.ABCJS.parse.each(h.accidentals,function(k){var l=(k.acc==="sharp")?1:(k.acc==="natural")?0:-1;var j=k.note.toLowerCase();var i=this.extractNote(j.charCodeAt(0)-"c".charCodeAt(0));this.accidentals[i]+=l},this)};ABCJS.midi.MidiWriter.prototype.extractNote=function(h){h=h%7;if(h<0){h+=7}return h};ABCJS.midi.MidiWriter.prototype.extractOctave=function(h){return Math.floor(h/7)}})();if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.parse){window.ABCJS.parse={}}window.ABCJS.parse.clone=function(c){var a={};for(var b in c){if(c.hasOwnProperty(b)){a[b]=c[b]}}return a};window.ABCJS.parse.gsub=function(c,b,a){return c.split(b).join(a)};window.ABCJS.parse.strip=function(a){return a.replace(/^\s+/,"").replace(/\s+$/,"")};window.ABCJS.parse.startsWith=function(b,a){return b.indexOf(a)===0};window.ABCJS.parse.endsWith=function(c,a){var b=c.length-a.length;return b>=0&&c.lastIndexOf(a)===b};window.ABCJS.parse.each=function(a,d,c){for(var b=0,e=a.length;b<e;b++){d.apply(c,[a[b],b])}};window.ABCJS.parse.last=function(a){if(a.length===0){return null}return a[a.length-1]};window.ABCJS.parse.compact=function(a){var b=[];for(var c=0;c<a.length;c++){if(a[c]){b.push(a[c])}}return b};window.ABCJS.parse.detect=function(a,c){for(var b=0;b<a.length;b++){if(c(a[b])){return true}}return false};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.parse){window.ABCJS.parse={}}window.ABCJS.parse.Parse=function(){var f=new window.ABCJS.data.Tune();var n=new window.ABCJS.parse.tokenizer();this.getTune=function(){return f};var y={reset:function(){for(var A in this){if(this.hasOwnProperty(A)&&typeof this[A]!=="function"){delete this[A]}}this.iChar=0;this.key={accidentals:[],root:"none",acc:"",mode:""};this.meter={type:"specified",value:[{num:"4",den:"4"}]};this.origMeter={type:"specified",value:[{num:"4",den:"4"}]};this.hasMainTitle=false;this.default_length=0.125;this.clef={type:"treble",verticalPos:0};this.next_note_duration=0;this.start_new_line=true;this.is_in_header=true;this.is_in_history=false;this.partForNextLine="";this.havent_set_length=true;this.voices={};this.staves=[];this.macros={};this.currBarNumber=1;this.inTextBlock=false;this.inPsBlock=false;this.ignoredDecorations=[];this.textBlock="";this.score_is_present=false;this.inEnding=false;this.inTie=false;this.inTieChord={}}};var z=function(A){if(!y.warnings){y.warnings=[]}y.warnings.push(A)};var c=function(B){var A=window.ABCJS.parse.gsub(B,"\x12"," ");A=window.ABCJS.parse.gsub(A,"&","&amp;");A=window.ABCJS.parse.gsub(A,"<","&lt;");return window.ABCJS.parse.gsub(A,">","&gt;")};var x=function(E,A,D){var C=A.charAt(D);if(C===" "){C="SPACE"}var B=c(A.substring(0,D))+'<span style="text-decoration:underline;font-size:1.3em;font-weight:bold;">'+C+"</span>"+c(A.substring(D+1));z("Music Line:"+f.getNumLines()+":"+(D+1)+": "+E+":  "+B)};var u=new window.ABCJS.parse.ParseHeader(n,x,y,f);this.getWarnings=function(){return y.warnings};var t=function(C,D){if(C.charAt(D)==='"'){var E=n.getBrackettedSubstring(C,D,5);if(!E[2]){x("Missing the closing quote while parsing the chord symbol",C,D)}if(E[0]>0&&E[1].length>0&&E[1].charAt(0)==="^"){E[1]=E[1].substring(1);E[2]="above"}else{if(E[0]>0&&E[1].length>0&&E[1].charAt(0)==="_"){E[1]=E[1].substring(1);E[2]="below"}else{if(E[0]>0&&E[1].length>0&&E[1].charAt(0)==="<"){E[1]=E[1].substring(1);E[2]="left"}else{if(E[0]>0&&E[1].length>0&&E[1].charAt(0)===">"){E[1]=E[1].substring(1);E[2]="right"}else{if(E[0]>0&&E[1].length>0&&E[1].charAt(0)==="@"){E[1]=E[1].substring(1);var A=n.getFloat(E[1]);if(A.digits===0){x("Missing first position in absolutely positioned annotation.",C,D)}E[1]=E[1].substring(A.digits);if(E[1][0]!==","){x("Missing comma absolutely positioned annotation.",C,D)}E[1]=E[1].substring(1);var F=n.getFloat(E[1]);if(F.digits===0){x("Missing second position in absolutely positioned annotation.",C,D)}E[1]=E[1].substring(F.digits);var B=n.skipWhiteSpace(E[1]);E[1]=E[1].substring(B);E[2]=null;E[3]={x:A.value,y:F.value}}else{E[1]=E[1].replace(/([ABCDEFG])b/g,"$1♭");E[1]=E[1].replace(/([ABCDEFG])#/g,"$1♯");E[2]="default"}}}}}return E}return[0,""]};var p=["trill","lowermordent","uppermordent","mordent","pralltriller","accent","fermata","invertedfermata","tenuto","0","1","2","3","4","5","+","wedge","open","thumb","snap","turn","roll","breath","shortphrase","mediumphrase","longphrase","segno","coda","D.S.","D.C.","fine","crescendo(","crescendo)","diminuendo(","diminuendo)","p","pp","f","ff","mf","mp","ppp","pppp","fff","ffff","sfz","repeatbar","repeatbar2","slide","upbow","downbow","/","//","///","////","trem1","trem2","trem3","trem4","turnx","invertedturn","invertedturnx","trill(","trill)","arpeggio","xstem","mark","umarcato","style=normal","style=harmonic","style=rhythm","style=x"];var s=[["<","accent"],[">","accent"],["tr","trill"],["<(","crescendo("],["<)","crescendo)"],[">(","diminuendo("],[">)","diminuendo)"],["plus","+"],["emphasis","accent"]];var h=function(A,C){var D=y.macros[A.charAt(C)];if(D!==undefined){if(D.charAt(0)==="!"||D.charAt(0)==="+"){D=D.substring(1)}if(D.charAt(D.length-1)==="!"||D.charAt(D.length-1)==="+"){D=D.substring(0,D.length-1)}if(window.ABCJS.parse.detect(p,function(E){return(D===E)})){return[1,D]}else{if(!window.ABCJS.parse.detect(y.ignoredDecorations,function(E){return(D===E)})){x("Unknown macro: "+D,A,C)}return[1,""]}}switch(A.charAt(C)){case".":return[1,"staccato"];case"u":return[1,"upbow"];case"v":return[1,"downbow"];case"~":return[1,"irishroll"];
case"!":case"+":var B=n.getBrackettedSubstring(A,C,5);if(B[1].length>0&&(B[1].charAt(0)==="^"||B[1].charAt(0)==="_")){B[1]=B[1].substring(1)}if(window.ABCJS.parse.detect(p,function(E){return(B[1]===E)})){return B}if(window.ABCJS.parse.detect(s,function(E){if(B[1]===E[0]){B[1]=E[1];return true}else{return false}})){return B}if(A.charAt(C)==="!"&&(B[0]===1||A.charAt(C+B[0]-1)!=="!")){return[1,null]}x("Unknown decoration: "+B[1],A,C);B[1]="";return B;case"H":return[1,"fermata"];case"J":return[1,"slide"];case"L":return[1,"accent"];case"M":return[1,"mordent"];case"O":return[1,"coda"];case"P":return[1,"pralltriller"];case"R":return[1,"roll"];case"S":return[1,"segno"];case"T":return[1,"trill"]}return[0,0]};var e=function(A,B){var C=B;while(n.isWhiteSpace(A.charAt(B))){B++}return[B-C]};var r=function(C,F){var D=n.getBarLine(C,F);if(D.len===0){return[0,""]}if(D.warn){x(D.warn,C,F);return[D.len,""]}for(var B=0;B<C.length;B++){if(C.charAt(F+D.len+B)!==" "){break}}var G=D.len;if(C.charAt(F+D.len+B)==="["){D.len+=B+1}if(C.charAt(F+D.len)==='"'&&C.charAt(F+D.len-1)==="["){var A=n.getBrackettedSubstring(C,F+D.len,5);return[D.len+A[0],D.token,A[1]]}var E=n.getTokenOf(C.substring(F+D.len),"1234567890-,");if(E.len===0||E.token[0]==="-"){return[G,D.token]}return[D.len+E.len,D.token,E.token]};var o=function(A,C){var B={};var D=C;while(A.charAt(C)==="("||n.isWhiteSpace(A.charAt(C))){if(A.charAt(C)==="("){if(C+1<A.length&&(A.charAt(C+1)>="2"&&A.charAt(C+1)<="9")){if(B.triplet!==undefined){x("Can't nest triplets",A,C)}else{B.triplet=A.charAt(C+1)-"0";if(C+2<A.length&&A.charAt(C+2)===":"){if(C+3<A.length&&A.charAt(C+3)===":"){if(C+4<A.length&&(A.charAt(C+4)>="1"&&A.charAt(C+4)<="9")){B.num_notes=A.charAt(C+4)-"0";C+=3}else{x("expected number after the two colons after the triplet to mark the duration",A,C)}}else{if(C+3<A.length&&(A.charAt(C+3)>="1"&&A.charAt(C+3)<="9")){if(C+4<A.length&&A.charAt(C+4)===":"){if(C+5<A.length&&(A.charAt(C+5)>="1"&&A.charAt(C+5)<="9")){B.num_notes=A.charAt(C+5)-"0";C+=4}}else{B.num_notes=B.triplet;C+=3}}else{x("expected number after the triplet to mark the duration",A,C)}}}}C++}else{if(B.startSlur===undefined){B.startSlur=1}else{B.startSlur++}}}C++}B.consumed=C-D;return B};var m=function(B,H){if(!B){x("Can't add words before the first line of mulsic",B,0);return}H=window.ABCJS.parse.strip(H);if(H.charAt(H.length-1)!=="-"){H=H+" "}var G=[];var F=0;var D=false;var A=function(I){var J=window.ABCJS.parse.strip(H.substring(F,I));F=I+1;if(J.length>0){if(D){J=window.ABCJS.parse.gsub(J,"~"," ")}var K=H.charAt(I);if(K!=="_"&&K!=="-"){K=" "}G.push({syllable:n.translateString(J),divider:K});D=false;return true}return false};for(var C=0;C<H.length;C++){switch(H.charAt(C)){case" ":case"\x12":A(C);break;case"-":if(!A(C)&&G.length>0){window.ABCJS.parse.last(G).divider="-";G.push({skip:true,to:"next"})}break;case"_":A(C);G.push({skip:true,to:"slur"});break;case"*":A(C);G.push({skip:true,to:"next"});break;case"|":A(C);G.push({skip:true,to:"bar"});break;case"~":D=true;break}}var E=false;window.ABCJS.parse.each(B,function(J){if(G.length!==0){if(G[0].skip){switch(G[0].to){case"next":if(J.el_type==="note"&&J.pitches!==null&&!E){G.shift()}break;case"slur":if(J.el_type==="note"&&J.pitches!==null){G.shift()}break;case"bar":if(J.el_type==="bar"){G.shift()}break}}else{if(J.el_type==="note"&&J.rest===undefined&&!E){var I=G.shift();if(J.lyric===undefined){J.lyric=[I]}else{J.lyric.push(I)}}}}})};var d=function(B,H){if(!B){x("Can't add symbols before the first line of mulsic",B,0);return}H=window.ABCJS.parse.strip(H);if(H.charAt(H.length-1)!=="-"){H=H+" "}var G=[];var F=0;var D=false;var A=function(I){var J=window.ABCJS.parse.strip(H.substring(F,I));F=I+1;if(J.length>0){if(D){J=window.ABCJS.parse.gsub(J,"~"," ")}var K=H.charAt(I);if(K!=="_"&&K!=="-"){K=" "}G.push({syllable:n.translateString(J),divider:K});D=false;return true}return false};for(var C=0;C<H.length;C++){switch(H.charAt(C)){case" ":case"\x12":A(C);break;case"-":if(!A(C)&&G.length>0){window.ABCJS.parse.last(G).divider="-";G.push({skip:true,to:"next"})}break;case"_":A(C);G.push({skip:true,to:"slur"});break;case"*":A(C);G.push({skip:true,to:"next"});break;case"|":A(C);G.push({skip:true,to:"bar"});break;case"~":D=true;break}}var E=false;window.ABCJS.parse.each(B,function(J){if(G.length!==0){if(G[0].skip){switch(G[0].to){case"next":if(J.el_type==="note"&&J.pitches!==null&&!E){G.shift()}break;case"slur":if(J.el_type==="note"&&J.pitches!==null){G.shift()}break;case"bar":if(J.el_type==="bar"){G.shift()}break}}else{if(J.el_type==="note"&&J.rest===undefined&&!E){var I=G.shift();if(J.lyric===undefined){J.lyric=[I]}else{J.lyric.push(I)}}}}})};var b=function(A,B){switch(A.charAt(B)){case">":if(B<A.length-1&&A.charAt(B+1)===">"){return[2,1.75,0.25]}else{return[1,1.5,0.5]}break;case"<":if(B<A.length-1&&A.charAt(B+1)==="<"){return[2,0.25,1.75]}else{return[1,0.5,1.5]}break}return null};var g=function(A){if(A.duration!==undefined&&A.duration<0.25){A.end_beam=true}return A};var j={A:5,B:6,C:0,D:1,E:2,F:3,G:4,a:12,b:13,c:7,d:8,e:9,f:10,g:11};var a={x:"invisible",y:"spacer",z:"rest",Z:"multimeasure"};var i=function(J,G,C,A){var H=function(K){return(K==="octave"||K==="duration"||K==="Zduration"||K==="broken_rhythm"||K==="end_slur")};var B="startSlur";var D=false;while(1){switch(J.charAt(G)){case"(":if(B==="startSlur"){if(C.startSlur===undefined){C.startSlur=1}else{C.startSlur++}}else{if(H(B)){C.endChar=G;return C}else{return null}}break;case")":if(H(B)){if(C.endSlur===undefined){C.endSlur=1}else{C.endSlur++}}else{return null}break;case"^":if(B==="startSlur"){C.accidental="sharp";B="sharp2"}else{if(B==="sharp2"){C.accidental="dblsharp";B="pitch"}else{if(H(B)){C.endChar=G;return C}else{return null}}}break;case"_":if(B==="startSlur"){C.accidental="flat";B="flat2"}else{if(B==="flat2"){C.accidental="dblflat";B="pitch"}else{if(H(B)){C.endChar=G;return C}else{return null}}}break;case"=":if(B==="startSlur"){C.accidental="natural";B="pitch"}else{if(H(B)){C.endChar=G;return C}else{return null}}break;case"A":case"B":case"C":case"D":case"E":case"F":case"G":case"a":case"b":case"c":case"d":case"e":case"f":case"g":if(B==="startSlur"||B==="sharp2"||B==="flat2"||B==="pitch"){C.pitch=j[J.charAt(G)];B="octave";if(A&&y.next_note_duration!==0){C.duration=y.next_note_duration;y.next_note_duration=0;D=true}else{C.duration=y.default_length}}else{if(H(B)){C.endChar=G;return C}else{return null}}break;case",":if(B==="octave"){C.pitch-=7}else{if(H(B)){C.endChar=G;return C}else{return null}}break;case"'":if(B==="octave"){C.pitch+=7}else{if(H(B)){C.endChar=G;return C}else{return null}}break;case"x":case"y":case"z":case"Z":if(B==="startSlur"){C.rest={type:a[J.charAt(G)]};delete C.accidental;delete C.startSlur;delete C.startTie;delete C.endSlur;delete C.endTie;delete C.end_beam;delete C.grace_notes;if(C.rest.type==="multimeasure"){C.duration=1;B="Zduration"}else{if(A&&y.next_note_duration!==0){C.duration=y.next_note_duration;y.next_note_duration=0;D=true}else{C.duration=y.default_length
}B="duration"}}else{if(H(B)){C.endChar=G;return C}else{return null}}break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"0":case"/":if(B==="octave"||B==="duration"){var I=n.getFraction(J,G);if(!D){C.duration=C.duration*I.value}C.endChar=I.index;while(I.index<J.length&&(n.isWhiteSpace(J.charAt(I.index))||J.charAt(I.index)==="-")){if(J.charAt(I.index)==="-"){C.startTie={}}else{C=g(C)}I.index++}G=I.index-1;B="broken_rhythm"}else{if(B==="sharp2"){C.accidental="quartersharp";B="pitch"}else{if(B==="flat2"){C.accidental="quarterflat";B="pitch"}else{if(B==="Zduration"){var F=n.getNumber(J,G);C.duration=F.num;C.endChar=F.index;return C}else{return null}}}}break;case"-":if(B==="startSlur"){f.addTieToLastNote();C.endTie=true}else{if(B==="octave"||B==="duration"||B==="end_slur"){C.startTie={};if(!D&&A){B="broken_rhythm"}else{if(n.isWhiteSpace(J.charAt(G+1))){g(C)}C.endChar=G+1;return C}}else{if(B==="broken_rhythm"){C.endChar=G;return C}else{return null}}}break;case" ":case"\t":if(H(B)){C.end_beam=true;do{if(J.charAt(G)==="-"){C.startTie={}}G++}while(G<J.length&&(n.isWhiteSpace(J.charAt(G))||J.charAt(G)==="-"));C.endChar=G;if(!D&&A&&(J.charAt(G)==="<"||J.charAt(G)===">")){G--;B="broken_rhythm"}else{return C}}else{return null}break;case">":case"<":if(H(B)){if(A){var E=b(J,G);G+=E[0]-1;y.next_note_duration=E[2]*C.duration;C.duration=E[1]*C.duration;B="end_slur"}else{C.endChar=G;return C}}else{return null}break;default:if(H(B)){C.endChar=G;return C}return null}G++;if(G===J.length){if(H(B)){C.endChar=G;return C}else{return null}}}return null};function v(){var B={startChar:-1,endChar:-1};if(y.partForNextLine.length){B.part=y.partForNextLine}B.clef=y.currentVoice&&y.staves[y.currentVoice.staffNum].clef!==undefined?window.ABCJS.parse.clone(y.staves[y.currentVoice.staffNum].clef):window.ABCJS.parse.clone(y.clef);B.key=window.ABCJS.parse.parseKeyVoice.deepCopyKey(y.key);window.ABCJS.parse.parseKeyVoice.addPosToKey(B.clef,B.key);if(y.meter!==null){if(y.currentVoice){window.ABCJS.parse.each(y.staves,function(C){C.meter=y.meter});B.meter=y.staves[y.currentVoice.staffNum].meter;y.staves[y.currentVoice.staffNum].meter=null}else{B.meter=y.meter}y.meter=null}else{if(y.currentVoice&&y.staves[y.currentVoice.staffNum].meter){B.meter=y.staves[y.currentVoice.staffNum].meter;y.staves[y.currentVoice.staffNum].meter=null}}if(y.currentVoice&&y.currentVoice.name){B.name=y.currentVoice.name}if(y.vocalfont){B.vocalfont=y.vocalfont}if(y.style){B.style=y.style}if(y.currentVoice){var A=y.staves[y.currentVoice.staffNum];if(A.brace){B.brace=A.brace}if(A.bracket){B.bracket=A.bracket}if(A.connectBarLines){B.connectBarLines=A.connectBarLines}if(A.name){B.name=A.name[y.currentVoice.index]}if(A.subname){B.subname=A.subname[y.currentVoice.index]}if(y.currentVoice.stem){B.stem=y.currentVoice.stem}if(y.currentVoice.scale){B.scale=y.currentVoice.scale}if(y.currentVoice.style){B.style=y.currentVoice.style}}f.startNewLine(B);y.partForNextLine="";if(y.currentVoice===undefined||(y.currentVoice.staffNum===y.staves.length-1&&y.staves[y.currentVoice.staffNum].numVoices-1===y.currentVoice.index)){if(y.barNumbers===0){y.barNumOnNextNote=y.currBarNumber}}}var w=function(B,D){if(B.charAt(D)==="{"){var C=n.getBrackettedSubstring(B,D,1,"}");if(!C[2]){x("Missing the closing '}' while parsing grace note",B,D)}if(B[D+C[0]]===")"){C[0]++;C[1]+=")"}var A=[];var F=0;var G=false;while(F<C[1].length){var H=false;if(C[1].charAt(F)==="/"){H=true;F++}var E=i(C[1],F,{},false);if(E!==null){if(H){E.acciaccatura=true}A.push(E);if(G){E.endTie=true;G=false}if(E.startTie){G=true}F=E.endChar;delete E.endChar}else{if(C[1].charAt(F)===" "){if(A.length>0){A[A.length-1].end_beam=true}}else{x("Unknown character '"+C[1].charAt(F)+"' while parsing grace note",B,D)}F++}}if(A.length){return[C[0],A]}}return[0]};var q="ABCDEFGabcdefgxyzZ[]|^_{";var l=function(K){u.resolveTempo();y.is_in_header=false;var R=0;var Q=y.iChar;while(n.isWhiteSpace(K.charAt(R))&&R<K.length){R++}if(R===K.length||K.charAt(R)==="%"){return}var U=y.start_new_line;if(y.continueall===undefined){y.start_new_line=true}else{y.start_new_line=false}var H=0;var N=u.letter_to_body_header(K,R);if(N[0]>0){R+=N[0]}var C={};while(R<K.length){var D=R;if(K.charAt(R)==="%"){break}var B=u.letter_to_inline_header(K,R);if(B[0]>0){R+=B[0]}else{if(U){v();U=false}var W;while(1){W=n.eatWhiteSpace(K,R);if(W>0){R+=W}if(R>0&&K.charAt(R-1)==="\x12"){W=u.letter_to_body_header(K,R);if(W[0]>0){R=W[0];y.start_new_line=false}}W=e(K,R);if(W[0]>0){R+=W[0]}W=t(K,R);if(W[0]>0){if(!C.chord){C.chord=[]}var G=n.translateString(W[1]);G=G.replace(/;/g,"\n");var F=false;for(var L=0;L<C.chord.length;L++){if(C.chord[L].position===W[2]){F=true;C.chord[L].name+="\n"+G}}if(F===false){if(W[2]===null&&W[3]){C.chord.push({name:G,rel_position:W[3]})}else{C.chord.push({name:G,position:W[2]})}}R+=W[0];var M=n.skipWhiteSpace(K.substring(R));if(M>0){C.force_end_beam_last=true}R+=M}else{if(q.indexOf(K.charAt(R))===-1){W=h(K,R)}else{W=[0]}if(W[0]>0){if(W[1]===null){if(R+1<K.length){v()}}else{if(W[1].length>0){if(C.decoration===undefined){C.decoration=[]}C.decoration.push(W[1])}}R+=W[0]}else{W=w(K,R);if(W[0]>0){C.gracenotes=W[1];R+=W[0]}else{break}}}}W=r(K,R);if(W[0]>0){if(C.gracenotes!==undefined){C.rest={type:"spacer"};C.duration=0.125;f.appendElement("note",Q+R,Q+R+W[0],C);y.measureNotEmpty=true;C={}}var T={type:W[1]};if(T.type.length===0){x("Unknown bar type",K,R)}else{if(y.inEnding&&T.type!=="bar_thin"){T.endEnding=true;y.inEnding=false}if(W[2]){T.startEnding=W[2];if(y.inEnding){T.endEnding=true}y.inEnding=true}if(C.decoration!==undefined){T.decoration=C.decoration}if(C.chord!==undefined){T.chord=C.chord}if(T.startEnding&&y.barFirstEndingNum===undefined){y.barFirstEndingNum=y.currBarNumber}else{if(T.startEnding&&T.endEnding&&y.barFirstEndingNum){y.currBarNumber=y.barFirstEndingNum}else{if(T.endEnding){y.barFirstEndingNum=undefined}}}if(T.type!=="bar_invisible"&&y.measureNotEmpty){y.currBarNumber++;if(y.barNumbers&&y.currBarNumber%y.barNumbers===0){y.barNumOnNextNote=y.currBarNumber}}f.appendElement("bar",Q+R,Q+R+W[0],T);y.measureNotEmpty=false;C={}}R+=W[0]}else{if(K[R]==="&"){x("Overlay not yet supported",K,R);R++}else{W=o(K,R);if(W.consumed>0){if(W.startSlur!==undefined){C.startSlur=W.startSlur}if(W.triplet!==undefined){if(H>0){x("Can't nest triplets",K,R)}else{C.startTriplet=W.triplet;H=W.num_notes===undefined?W.triplet:W.num_notes}}R+=W.consumed}if(K.charAt(R)==="["){R++;var A=null;var P=false;while(!P){var J=i(K,R,{},false);if(J!==null){if(J.end_beam){C.end_beam=true;delete J.end_beam}if(C.pitches===undefined){C.duration=J.duration;C.pitches=[J]}else{C.pitches.push(J)}delete J.duration;if(y.inTieChord[C.pitches.length]){J.endTie=true;y.inTieChord[C.pitches.length]=undefined}if(J.startTie){y.inTieChord[C.pitches.length]=true}R=J.endChar;delete J.endChar}else{if(K.charAt(R)===" "){x("Spaces are not allowed in chords",K,R);R++}else{if(R<K.length&&K.charAt(R)==="]"){R++;if(y.next_note_duration!==0){C.duration=C.duration*y.next_note_duration;
y.next_note_duration=0}if(y.inTie){window.ABCJS.parse.each(C.pitches,function(X){X.endTie=true});y.inTie=false}if(H>0){H--;if(H===0){C.endTriplet=true}}var I=false;while(R<K.length&&!I){switch(K.charAt(R)){case" ":case"\t":g(C);break;case")":if(C.endSlur===undefined){C.endSlur=1}else{C.endSlur++}break;case"-":window.ABCJS.parse.each(C.pitches,function(X){X.startTie={}});y.inTie=true;break;case">":case"<":var V=b(K,R);R+=V[0]-1;y.next_note_duration=V[2];A=V[1];break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"/":var E=n.getFraction(K,R);A=E.value;R=E.index;if(K.charAt(R)==="-"||K.charAt(R)===")"){R--}else{I=true}break;default:I=true;break}if(!I){R++}}}else{x("Expected ']' to end the chords",K,R)}if(C.pitches!==undefined){if(A!==null){C.duration=C.duration*A}if(y.barNumOnNextNote){C.barNumber=y.barNumOnNextNote;y.barNumOnNextNote=null}f.appendElement("note",Q+R,Q+R,C);y.measureNotEmpty=true;C={}}P=true}}}}else{var O={};var S=i(K,R,O,true);if(O.endTie!==undefined){y.inTie=true}if(S!==null){if(S.pitch!==undefined){C.pitches=[{}];if(S.accidental!==undefined){C.pitches[0].accidental=S.accidental}C.pitches[0].pitch=S.pitch;if(S.endSlur!==undefined){C.pitches[0].endSlur=S.endSlur}if(S.endTie!==undefined){C.pitches[0].endTie=S.endTie}if(S.startSlur!==undefined){C.pitches[0].startSlur=S.startSlur}if(C.startSlur!==undefined){C.pitches[0].startSlur=C.startSlur}if(S.startTie!==undefined){C.pitches[0].startTie=S.startTie}if(C.startTie!==undefined){C.pitches[0].startTie=C.startTie}}else{C.rest=S.rest;if(S.endSlur!==undefined){C.endSlur=S.endSlur}if(S.endTie!==undefined){C.rest.endTie=S.endTie}if(S.startSlur!==undefined){C.startSlur=S.startSlur}if(S.startTie!==undefined){C.rest.startTie=S.startTie}if(C.startTie!==undefined){C.rest.startTie=C.startTie}}if(S.chord!==undefined){C.chord=S.chord}if(S.duration!==undefined){C.duration=S.duration}if(S.decoration!==undefined){C.decoration=S.decoration}if(S.graceNotes!==undefined){C.graceNotes=S.graceNotes}delete C.startSlur;if(y.inTie){if(C.pitches!==undefined){C.pitches[0].endTie=true}else{C.rest.endTie=true}y.inTie=false}if(S.startTie||C.startTie){y.inTie=true}R=S.endChar;if(H>0){H--;if(H===0){C.endTriplet=true}}if(S.end_beam){g(C)}if(y.barNumOnNextNote){C.barNumber=y.barNumOnNextNote;y.barNumOnNextNote=null}f.appendElement("note",Q+D,Q+R,C);y.measureNotEmpty=true;C={}}}if(R===D){if(K.charAt(R)!==" "&&K.charAt(R)!=="`"){x("Unknown character ignored",K,R)}R++}}}}}};var k=function(A){var B=u.parseHeader(A);if(B.regular){l(B.str)}if(B.newline&&y.continueall===undefined){v()}if(B.words){m(f.getCurrentVoice(),A.substring(2))}if(B.symbols){d(f.getCurrentVoice(),A.substring(2))}if(B.recurse){k(B.str)}};this.parse=function(G,E){f.reset();if(E&&E.print){f.media="print"}y.reset();u.reset(n,x,y,f);G=window.ABCJS.parse.gsub(G,"\r\n","\n");G=window.ABCJS.parse.gsub(G,"\r","\n");G+="\n";G=G.replace(/\n\\.*\n/g,"\n");var C=function(J,L,M){var I="                                                                                                                                                                                                     ";var K=M?I.substring(0,M.length):"";return L+" \x12"+K};G=G.replace(/\\([ \t]*)(%.*)*\n/g,C);var B=G.split("\n");if(window.ABCJS.parse.last(B).length===0){B.pop()}try{window.ABCJS.parse.each(B,function(I){if(E){if(E.header_only&&y.is_in_header===false){throw"normal_abort"}if(E.stop_on_warning&&y.warnings){throw"normal_abort"}}if(y.is_in_history){if(I.charAt(1)===":"){y.is_in_history=false;k(I)}else{f.addMetaText("history",n.translateString(n.stripComment(I)))}}else{if(y.inTextBlock){if(window.ABCJS.parse.startsWith(I,"%%endtext")){f.addText(y.textBlock);y.inTextBlock=false}else{if(window.ABCJS.parse.startsWith(I,"%%")){y.textBlock+=" "+I.substring(2)}else{y.textBlock+=" "+I}}}else{if(y.inPsBlock){if(window.ABCJS.parse.startsWith(I,"%%endps")){y.inPsBlock=false}else{y.textBlock+=" "+I}}else{k(I)}}}y.iChar+=I.length+1});var H=11*72;var D=8.5*72;switch(y.papersize){case"legal":H=14*72;D=8.5*72;break;case"A4":H=11.7*72;D=8.3*72;break}if(y.landscape){var A=H;H=D;D=A}f.cleanUp(D,H,y.barsperstaff,y.staffnonote)}catch(F){if(F!=="normal_abort"){throw F}}}};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.parse){window.ABCJS.parse={}}window.ABCJS.parse.parseDirective={};(function(){var b;var d;var a;var c;window.ABCJS.parse.parseDirective.initialize=function(h,f,g,e){b=h;d=f;a=g;c=e};window.ABCJS.parse.parseDirective.parseFontChangeLine=function(g){var e=g.split("$");if(e.length>1&&a.setfont){var h=[{text:e[0]}];for(var f=1;f<e.length;f++){if(e[f].charAt(0)==="0"){h.push({text:e[f].substring(1)})}else{if(e[f].charAt(0)==="1"&&a.setfont[1]){h.push({font:a.setfont[1],text:e[f].substring(1)})}else{if(e[f].charAt(0)==="2"&&a.setfont[2]){h.push({font:a.setfont[2],text:e[f].substring(1)})}else{if(e[f].charAt(0)==="3"&&a.setfont[3]){h.push({font:a.setfont[3],text:e[f].substring(1)})}else{if(e[f].charAt(0)==="4"&&a.setfont[4]){h.push({font:a.setfont[4],text:e[f].substring(1)})}else{h[h.length-1].text+="$"+e[f]}}}}}}if(h.length>1){return h}}return g};window.ABCJS.parse.parseDirective.addDirective=function(M){var V=function(t,ag){var p=b.getMeasurement(ag);if(p.used===0||ag.length!==0){return{error:'Directive "'+t+'" requires a measurement as a parameter.'}}return p.value};var R=function(t,ag){var p=b.getMeasurement(ag);if(p.used===0||ag.length!==0){return'Directive "'+t+'" requires a measurement as a parameter.'}c.formatting[t]=p.value;return null};var B=function(ah){var p={};var t=window.ABCJS.parse.last(ah);if(t.type==="number"){p.size=parseInt(t.token);ah.pop()}if(ah.length>0){var ag="";window.ABCJS.parse.each(ah,function(ai){if(ai.token!=="-"){if(ag.length>0){ag+=" "}ag+=ai.token}});p.font=ag}return p};var k=function(p,t){if(t.length===0){return'Directive "'+p+'" requires a font as a parameter.'}a[p]=B(t);return null};var q=function(p,t){if(t.length===0){return'Directive "'+p+'" requires a font as a parameter.'}c.formatting[p]=B(t);return null};var g=function(ah,ai,aj,ag,p){if(aj.length!==1||aj[0].type!=="number"){return'Directive "'+ai+'" requires a number as a parameter.'}var t=aj[0].intt;if(ag!==undefined&&t<ag){return'Directive "'+ai+'" requires a number greater than or equal to '+ag+" as a parameter."}if(p!==undefined&&t>p){return'Directive "'+ai+'" requires a number less than or equal to '+p+" as a parameter."}a[ah]=t;return null};var E=function(p,t,ag){var ah=g(p,t,ag,0,1);if(ah!==null){return ah}a[p]=(a[p]===1);return null};var K=b.tokenize(M,0,M.length);if(K.length===0||K[0].type!=="alpha"){return null}var f=M.substring(M.indexOf(K[0].token)+K[0].token.length);f=b.stripComment(f);var Z=K.shift().token.toLowerCase();var ac;var j="";switch(Z){case"bagpipes":c.formatting.bagpipes=true;break;case"landscape":a.landscape=true;break;case"papersize":a.papersize=f;break;case"slurgraces":c.formatting.slurgraces=true;break;case"stretchlast":c.formatting.stretchlast=true;break;case"titlecaps":a.titlecaps=true;
break;case"titleleft":c.formatting.titleleft=true;break;case"measurebox":c.formatting.measurebox=true;break;case"botmargin":case"botspace":case"composerspace":case"indent":case"leftmargin":case"linesep":case"musicspace":case"partsspace":case"pageheight":case"pagewidth":case"rightmargin":case"staffsep":case"staffwidth":case"subtitlespace":case"sysstaffsep":case"systemsep":case"textspace":case"titlespace":case"topmargin":case"topspace":case"vocalspace":case"wordsspace":return R(Z,K);case"vskip":var i=V(Z,K);if(i.error){return i.error}c.addSpacing(i);return null;case"scale":j="";window.ABCJS.parse.each(K,function(p){j+=p.token});ac=parseFloat(j);if(isNaN(ac)||ac===0){return'Directive "'+Z+'" requires a number as a parameter.'}c.formatting.scale=ac;break;case"sep":if(K.length===0){c.addSeparator()}else{var Q=b.getMeasurement(K);if(Q.used===0){return'Directive "'+Z+'" requires 3 numbers: space above, space below, length of line'}var J=Q.value;Q=b.getMeasurement(K);if(Q.used===0){return'Directive "'+Z+'" requires 3 numbers: space above, space below, length of line'}var af=Q.value;Q=b.getMeasurement(K);if(Q.used===0||K.length!==0){return'Directive "'+Z+'" requires 3 numbers: space above, space below, length of line'}var A=Q.value;c.addSeparator(J,af,A)}break;case"barsperstaff":j=g("barsperstaff",Z,K);if(j!==null){return j}break;case"staffnonote":j=E("staffnonote",Z,K);if(j!==null){return j}break;case"printtempo":j=E("printTempo",Z,K);if(j!==null){return j}break;case"measurenb":case"barnumbers":j=g("barNumbers",Z,K);if(j!==null){return j}break;case"begintext":a.inTextBlock=true;break;case"continueall":a.continueall=true;break;case"beginps":a.inPsBlock=true;d("Postscript ignored",M,0);break;case"deco":if(f.length>0){a.ignoredDecorations.push(f.substring(0,f.indexOf(" ")))}d("Decoration redefinition ignored",M,0);break;case"text":var W=b.translateString(f);c.addText(window.ABCJS.parse.parseDirective.parseFontChangeLine(W));break;case"center":var e=b.translateString(f);c.addCentered(window.ABCJS.parse.parseDirective.parseFontChangeLine(e));break;case"font":break;case"setfont":var y=b.tokenize(f,0,f.length);var G=false;if(y.length>=4){if(y[0].token==="-"&&y[1].type==="number"){var h=parseInt(y[1].token);if(h>=1&&h<=4){if(!a.setfont){a.setfont=[]}var D=y.pop();if(D.type==="number"){D=parseInt(D.token);var u="";for(var w=2;w<y.length;w++){u+=y[w].token}a.setfont[h]={font:u,size:D};G=true}}}}if(!G){return"Bad parameters: "+Z}break;case"gchordfont":case"partsfont":case"vocalfont":case"textfont":return k(Z,K);case"barlabelfont":case"barnumberfont":case"composerfont":case"subtitlefont":case"tempofont":case"titlefont":case"voicefont":return q(Z,K);case"barnumfont":return q("barnumberfont",K);case"staves":case"score":a.score_is_present=true;var ae=function(aj,ag,ai,ah,t){if(ag||a.staves.length===0){a.staves.push({index:a.staves.length,numVoices:0})}var p=window.ABCJS.parse.last(a.staves);if(ai!==undefined){p.bracket=ai}if(ah!==undefined){p.brace=ah}if(t){p.connectBarLines="end"}if(a.voices[aj]===undefined){a.voices[aj]={staffNum:p.index,index:p.numVoices};p.numVoices++}};var O=false;var Y=false;var n=false;var P=false;var l=false;var o=false;var m=false;var s;var ad=function(){m=true;if(s){var p="start";if(s.staffNum>0){if(a.staves[s.staffNum-1].connectBarLines==="start"||a.staves[s.staffNum-1].connectBarLines==="continue"){p="continue"}}a.staves[s.staffNum].connectBarLines=p}};while(K.length){var T=K.shift();switch(T.token){case"(":if(O){d("Can't nest parenthesis in %%score",M,T.start)}else{O=true;P=true}break;case")":if(!O||P){d("Unexpected close parenthesis in %%score",M,T.start)}else{O=false}break;case"[":if(Y){d("Can't nest brackets in %%score",M,T.start)}else{Y=true;l=true}break;case"]":if(!Y||l){d("Unexpected close bracket in %%score",M,T.start)}else{Y=false;a.staves[s.staffNum].bracket="end"}break;case"{":if(n){d("Can't nest braces in %%score",M,T.start)}else{n=true;o=true}break;case"}":if(!n||o){d("Unexpected close brace in %%score",M,T.start)}else{n=false;a.staves[s.staffNum].brace="end"}break;case"|":ad();break;default:var C="";while(T.type==="alpha"||T.type==="number"){C+=T.token;if(T.continueId){T=K.shift()}else{break}}var I=!O||P;var L=l?"start":Y?"continue":undefined;var z=o?"start":n?"continue":undefined;ae(C,I,L,z,m);P=false;l=false;o=false;m=false;s=a.voices[C];if(Z==="staves"){ad()}break}}break;case"newpage":var v=b.getInt(f);c.addNewPage(v.digits===0?-1:v.value);break;case"abc-copyright":case"abc-creator":case"abc-version":case"abc-charset":case"abc-edited-by":c.addMetaText(Z,f);break;case"header":case"footer":var S=b.getMeat(f,0,f.length);S=f.substring(S.start,S.end);if(S.charAt(0)==='"'&&S.charAt(S.length-1)==='"'){S=S.substring(1,S.length-2)}var F=S.split("\t");var r={};if(F.length===1){r={left:"",center:F[0],right:""}}else{if(F.length===2){r={left:F[0],center:F[1],right:""}}else{r={left:F[0],center:F[1],right:F[2]}}}if(F.length>3){d("Too many tabs in "+Z+": "+F.length+" found.",f,0)}c.addMetaTextObj(Z,r);break;case"midi":var X=b.tokenize(f,0,f.length);if(X.length>0&&X[0].token==="="){X.shift()}if(X.length===0){d("Expected midi command",f,0)}else{var x=function(ag){if(ag.length>0){var ah=ag.shift();var ai=ah.token;if(ah.type==="number"){ai=ah.intt}return ai}else{return null}};if(c.formatting[Z]===undefined){c.formatting[Z]={}}var H=X.shift().token;var N=true;if(H==="program"){var ab=x(X);if(ab){var aa=x(X);if(aa){N={channel:ab,program:aa}}else{N={program:ab}}}}else{var U=x(X);if(U!==null){N=U}}c.formatting[Z][H]=N}break;case"playtempo":case"auquality":case"continuous":case"nobarcheck":c.formatting[Z]=f;break;default:return"Unknown directive: "+Z}return null}})();if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.parse){window.ABCJS.parse={}}window.ABCJS.parse.ParseHeader=function(c,e,a,d){this.reset=function(g,i,f,h){window.ABCJS.parse.parseKeyVoice.initialize(g,i,f,h);window.ABCJS.parse.parseDirective.initialize(g,i,f,h)};this.reset(c,e,a,d);this.setTitle=function(f){if(a.hasMainTitle){d.addSubtitle(c.translateString(c.stripComment(f)))}else{d.addMetaText("title",c.translateString(c.theReverser(c.stripComment(f))));a.hasMainTitle=true}};this.setMeter=function(n){n=c.stripComment(n);if(n==="C"){if(a.havent_set_length===true){a.default_length=0.125}return{type:"common_time"}}else{if(n==="C|"){if(a.havent_set_length===true){a.default_length=0.125}return{type:"cut_time"}}else{if(n==="o"){if(a.havent_set_length===true){a.default_length=0.125}return{type:"tempus_perfectum"}}else{if(n==="c"){if(a.havent_set_length===true){a.default_length=0.125}return{type:"tempus_imperfectum"}}else{if(n==="o."){if(a.havent_set_length===true){a.default_length=0.125}return{type:"tempus_perfectum_prolatio"}}else{if(n==="c."){if(a.havent_set_length===true){a.default_length=0.125}return{type:"tempus_imperfectum_prolatio"}}else{if(n.length===0||n.toLowerCase()==="none"){if(a.havent_set_length===true){a.default_length=0.125}return null}else{var k=c.tokenize(n,0,n.length);try{var j=function(){var p={value:0,num:""};
var o=k.shift();if(o.token==="("){o=k.shift()}while(1){if(o.type!=="number"){throw"Expected top number of meter"}p.value+=parseInt(o.token);p.num+=o.token;if(k.length===0||k[0].token==="/"){return p}o=k.shift();if(o.token===")"){if(k.length===0||k[0].token==="/"){return p}throw"Unexpected paren in meter"}if(o.token!=="."&&o.token!=="+"){throw"Expected top number of meter"}p.num+=o.token;if(k.length===0){throw"Expected top number of meter"}o=k.shift()}return p};var f=function(){var p=j();if(k.length===0){return p}var o=k.shift();if(o.token!=="/"){throw"Expected slash in meter"}o=k.shift();if(o.type!=="number"){throw"Expected bottom number of meter"}p.den=o.token;p.value=p.value/parseInt(p.den);return p};if(k.length===0){throw"Expected meter definition in M: line"}var g={type:"specified",value:[]};var l=0;while(1){var i=f();l+=i.value;var m={num:i.num};if(i.den!==undefined){m.den=i.den}g.value.push(m);if(k.length===0){break}}if(a.havent_set_length===true){a.default_length=l<0.75?0.0625:0.125}return g}catch(h){e(h,n,0)}}}}}}}}return null};this.calcTempo=function(f){var h=1/4;if(a.meter&&a.meter.type==="specified"){h=1/parseInt(a.meter.value[0].den)}else{if(a.origMeter&&a.origMeter.type==="specified"){h=1/parseInt(a.origMeter.value[0].den)}}for(var g=0;g<f.duration;g++){f.duration[g]=h*f.duration[g]}return f};this.resolveTempo=function(){if(a.tempo){this.calcTempo(a.tempo);d.metaText.tempo=a.tempo;delete a.tempo}};this.addUserDefinition=function(g,l,f){var h=g.indexOf("=",l);if(h===-1){e("Need an = in a macro definition",g,l);return}var j=window.ABCJS.parse.strip(g.substring(l,h));var k=window.ABCJS.parse.strip(g.substring(h+1));if(j.length!==1){e("Macro definitions can only be one character",g,l);return}var i="HIJKLMNOPQRSTUVWXYhijklmnopqrstuvw~";if(i.indexOf(j)===-1){e("Macro definitions must be H-Y, h-w, or tilde",g,l);return}if(k.length===0){e("Missing macro definition",g,l);return}if(a.macros===undefined){a.macros={}}a.macros[j]=k};this.setDefaultLength=function(h,l,g){var f=window.ABCJS.parse.gsub(h.substring(l,g)," ","");var k=f.split("/");if(k.length===2){var j=parseInt(k[0]);var i=parseInt(k[1]);if(i>0){a.default_length=j/i;a.havent_set_length=false}}};this.setTempo=function(o,f,i){try{var l=c.tokenize(o,f,i);if(l.length===0){throw"Missing parameter in Q: field"}var j={};var n=true;var h=l.shift();if(h.type==="quote"){j.preString=h.token;h=l.shift();if(l.length===0){return{type:"immediate",tempo:j}}}if(h.type==="alpha"&&h.token==="C"){if(l.length===0){throw"Missing tempo after C in Q: field"}h=l.shift();if(h.type==="punct"&&h.token==="="){if(l.length===0){throw"Missing tempo after = in Q: field"}h=l.shift();if(h.type!=="number"){throw"Expected number after = in Q: field"}j.duration=[1];j.bpm=parseInt(h.token)}else{if(h.type==="number"){j.duration=[parseInt(h.token)];if(l.length===0){throw"Missing = after duration in Q: field"}h=l.shift();if(h.type!=="punct"||h.token!=="="){throw"Expected = after duration in Q: field"}if(l.length===0){throw"Missing tempo after = in Q: field"}h=l.shift();if(h.type!=="number"){throw"Expected number after = in Q: field"}j.bpm=parseInt(h.token)}else{throw"Expected number or equal after C in Q: field"}}}else{if(h.type==="number"){var k=parseInt(h.token);if(l.length===0||l[0].type==="quote"){j.duration=[1];j.bpm=k}else{n=false;h=l.shift();if(h.type!=="punct"&&h.token!=="/"){throw"Expected fraction in Q: field"}h=l.shift();if(h.type!=="number"){throw"Expected fraction in Q: field"}var m=parseInt(h.token);j.duration=[k/m];while(l.length>0&&l[0].token!=="="&&l[0].type!=="quote"){h=l.shift();if(h.type!=="number"){throw"Expected fraction in Q: field"}k=parseInt(h.token);h=l.shift();if(h.type!=="punct"&&h.token!=="/"){throw"Expected fraction in Q: field"}h=l.shift();if(h.type!=="number"){throw"Expected fraction in Q: field"}m=parseInt(h.token);j.duration.push(k/m)}h=l.shift();if(h.type!=="punct"&&h.token!=="="){throw"Expected = in Q: field"}h=l.shift();if(h.type!=="number"){throw"Expected tempo in Q: field"}j.bpm=parseInt(h.token)}}else{throw"Unknown value in Q: field"}}if(l.length!==0){h=l.shift();if(h.type==="quote"){j.postString=h.token;h=l.shift()}if(l.length!==0){throw"Unexpected string at end of Q: field"}}if(a.printTempo===false){j.suppress=true}return{type:n?"delaySet":"immediate",tempo:j}}catch(g){e(g,o,f);return{type:"none"}}};this.letter_to_inline_header=function(h,k){var g=c.eatWhiteSpace(h,k);k+=g;if(h.length>=k+5&&h.charAt(k)==="["&&h.charAt(k+2)===":"){var n=h.indexOf("]",k);switch(h.substring(k,k+3)){case"[I:":var l=window.ABCJS.parse.parseDirective.addDirective(h.substring(k+3,n));if(l){e(l,h,k)}return[n-k+1+g];case"[M:":var m=this.setMeter(h.substring(k+3,n));if(d.hasBeginMusic()&&m){d.appendStartingElement("meter",-1,-1,m)}else{a.meter=m}return[n-k+1+g];case"[K:":var f=window.ABCJS.parse.parseKeyVoice.parseKey(h.substring(k+3,n));if(f.foundClef&&d.hasBeginMusic()){d.appendStartingElement("clef",-1,-1,a.clef)}if(f.foundKey&&d.hasBeginMusic()){d.appendStartingElement("key",-1,-1,window.ABCJS.parse.parseKeyVoice.fixKey(a.clef,a.key))}return[n-k+1+g];case"[P:":d.appendElement("part",-1,-1,{title:h.substring(k+3,n)});return[n-k+1+g];case"[L:":this.setDefaultLength(h,k+3,n);return[n-k+1+g];case"[Q:":if(n>0){var j=this.setTempo(h,k+3,n);if(j.type==="delaySet"){d.appendElement("tempo",-1,-1,this.calcTempo(j.tempo))}else{if(j.type==="immediate"){d.appendElement("tempo",-1,-1,j.tempo)}}return[n-k+1+g,h.charAt(k+1),h.substring(k+3,n)]}break;case"[V:":if(n>0){window.ABCJS.parse.parseKeyVoice.parseVoice(h,k+3,n);return[n-k+1+g,h.charAt(k+1),h.substring(k+3,n)]}break;default:}}return[0]};this.letter_to_body_header=function(g,j){if(g.length>=j+3){switch(g.substring(j,j+2)){case"I:":var k=window.ABCJS.parse.parseDirective.addDirective(g.substring(j+2));if(k){e(k,g,j)}return[g.length];case"M:":var l=this.setMeter(g.substring(j+2));if(d.hasBeginMusic()&&l){d.appendStartingElement("meter",-1,-1,l)}return[g.length];case"K:":var f=window.ABCJS.parse.parseKeyVoice.parseKey(g.substring(j+2));if(f.foundClef&&d.hasBeginMusic()){d.appendStartingElement("clef",-1,-1,a.clef)}if(f.foundKey&&d.hasBeginMusic()){d.appendStartingElement("key",-1,-1,window.ABCJS.parse.parseKeyVoice.fixKey(a.clef,a.key))}return[g.length];case"P:":if(d.hasBeginMusic()){d.appendElement("part",-1,-1,{title:g.substring(j+2)})}return[g.length];case"L:":this.setDefaultLength(g,j+2,g.length);return[g.length];case"Q:":var m=g.indexOf("\x12",j+2);if(m===-1){m=g.length}var h=this.setTempo(g,j+2,m);if(h.type==="delaySet"){d.appendElement("tempo",-1,-1,this.calcTempo(h.tempo))}else{if(h.type==="immediate"){d.appendElement("tempo",-1,-1,h.tempo)}}return[m,g.charAt(j),window.ABCJS.parse.strip(g.substring(j+2))];case"V:":window.ABCJS.parse.parseKeyVoice.parseVoice(g,2,g.length);return[g.length,g.charAt(j),window.ABCJS.parse(g.substring(j+2))];default:}}return[0]};var b={A:"author",B:"book",C:"composer",D:"discography",F:"url",G:"group",I:"instruction",N:"notes",O:"origin",R:"rhythm",S:"source",W:"unalignedWords",Z:"transcription"};
this.parseHeader=function(g){if(window.ABCJS.parse.startsWith(g,"%%")){var j=window.ABCJS.parse.parseDirective.addDirective(g.substring(2));if(j){e(j,g,2)}return{}}g=c.stripComment(g);if(g.length===0){return{}}if(g.length>=2){if(g.charAt(1)===":"){var i="";if(g.indexOf("\x12")>=0&&g.charAt(0)!=="w"){i=g.substring(g.indexOf("\x12")+1);g=g.substring(0,g.indexOf("\x12"))}var k=b[g.charAt(0)];if(k!==undefined){if(k==="unalignedWords"){d.addMetaTextArray(k,window.ABCJS.parse.parseDirective.parseFontChangeLine(c.translateString(c.stripComment(g.substring(2)))))}else{d.addMetaText(k,c.translateString(c.stripComment(g.substring(2))))}return{}}else{switch(g.charAt(0)){case"H":d.addMetaText("history",c.translateString(c.stripComment(g.substring(2))));a.is_in_history=true;break;case"K":this.resolveTempo();var f=window.ABCJS.parse.parseKeyVoice.parseKey(g.substring(2));if(!a.is_in_header&&d.hasBeginMusic()){if(f.foundClef){d.appendStartingElement("clef",-1,-1,a.clef)}if(f.foundKey){d.appendStartingElement("key",-1,-1,window.ABCJS.parse.parseKeyVoice.fixKey(a.clef,a.key))}}a.is_in_header=false;break;case"L":this.setDefaultLength(g,2,g.length);break;case"M":a.origMeter=a.meter=this.setMeter(g.substring(2));break;case"P":if(a.is_in_header){d.addMetaText("partOrder",c.translateString(c.stripComment(g.substring(2))))}else{a.partForNextLine=c.translateString(c.stripComment(g.substring(2)))}break;case"Q":var h=this.setTempo(g,2,g.length);if(h.type==="delaySet"){a.tempo=h.tempo}else{if(h.type==="immediate"){d.metaText.tempo=h.tempo}}break;case"T":this.setTitle(g.substring(2));break;case"U":this.addUserDefinition(g,2,g.length);break;case"V":window.ABCJS.parse.parseKeyVoice.parseVoice(g,2,g.length);if(!a.is_in_header){return{newline:true}}break;case"s":return{symbols:true};case"w":return{words:true};case"X":break;case"E":case"m":e("Ignored header",g,0);break;default:if(i.length){i="\x12"+i}return{regular:true,str:g+i}}}if(i.length>0){return{recurse:true,str:i}}return{}}}return{regular:true,str:g}}};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.parse){window.ABCJS.parse={}}window.ABCJS.parse.parseKeyVoice={};(function(){var i;var f;var b;var e;window.ABCJS.parse.parseKeyVoice.initialize=function(n,l,m,k){i=n;f=l;b=m;e=k};window.ABCJS.parse.parseKeyVoice.standardKey=function(x){var n={acc:"sharp",note:"f"};var s={acc:"sharp",note:"c"};var w={acc:"sharp",note:"g"};var l={acc:"sharp",note:"d"};var q={acc:"sharp",note:"A"};var v={acc:"sharp",note:"e"};var z={acc:"sharp",note:"B"};var u={acc:"flat",note:"B"};var t={acc:"flat",note:"e"};var r={acc:"flat",note:"A"};var p={acc:"flat",note:"d"};var o={acc:"flat",note:"G"};var m={acc:"flat",note:"c"};var k={acc:"flat",note:"F"};var y={"C#":[n,s,w,l,q,v,z],"A#m":[n,s,w,l,q,v,z],"G#Mix":[n,s,w,l,q,v,z],"D#Dor":[n,s,w,l,q,v,z],"E#Phr":[n,s,w,l,q,v,z],"F#Lyd":[n,s,w,l,q,v,z],"B#Loc":[n,s,w,l,q,v,z],"F#":[n,s,w,l,q,v],"D#m":[n,s,w,l,q,v],"C#Mix":[n,s,w,l,q,v],"G#Dor":[n,s,w,l,q,v],"A#Phr":[n,s,w,l,q,v],BLyd:[n,s,w,l,q,v],"E#Loc":[n,s,w,l,q,v],B:[n,s,w,l,q],"G#m":[n,s,w,l,q],"F#Mix":[n,s,w,l,q],"C#Dor":[n,s,w,l,q],"D#Phr":[n,s,w,l,q],ELyd:[n,s,w,l,q],"A#Loc":[n,s,w,l,q],E:[n,s,w,l],"C#m":[n,s,w,l],BMix:[n,s,w,l],"F#Dor":[n,s,w,l],"G#Phr":[n,s,w,l],ALyd:[n,s,w,l],"D#Loc":[n,s,w,l],A:[n,s,w],"F#m":[n,s,w],EMix:[n,s,w],BDor:[n,s,w],"C#Phr":[n,s,w],DLyd:[n,s,w],"G#Loc":[n,s,w],D:[n,s],Bm:[n,s],AMix:[n,s],EDor:[n,s],"F#Phr":[n,s],GLyd:[n,s],"C#Loc":[n,s],G:[n],Em:[n],DMix:[n],ADor:[n],BPhr:[n],CLyd:[n],"F#Loc":[n],C:[],Am:[],GMix:[],DDor:[],EPhr:[],FLyd:[],BLoc:[],F:[u],Dm:[u],CMix:[u],GDor:[u],APhr:[u],BbLyd:[u],ELoc:[u],Bb:[u,t],Gm:[u,t],FMix:[u,t],CDor:[u,t],DPhr:[u,t],EbLyd:[u,t],ALoc:[u,t],Eb:[u,t,r],Cm:[u,t,r],BbMix:[u,t,r],FDor:[u,t,r],GPhr:[u,t,r],AbLyd:[u,t,r],DLoc:[u,t,r],Ab:[u,t,r,p],Fm:[u,t,r,p],EbMix:[u,t,r,p],BbDor:[u,t,r,p],CPhr:[u,t,r,p],DbLyd:[u,t,r,p],GLoc:[u,t,r,p],Db:[u,t,r,p,o],Bbm:[u,t,r,p,o],AbMix:[u,t,r,p,o],EbDor:[u,t,r,p,o],FPhr:[u,t,r,p,o],GbLyd:[u,t,r,p,o],CLoc:[u,t,r,p,o],Gb:[u,t,r,p,o,m],Ebm:[u,t,r,p,o,m],DbMix:[u,t,r,p,o,m],AbDor:[u,t,r,p,o,m],BbPhr:[u,t,r,p,o,m],CbLyd:[u,t,r,p,o,m],FLoc:[u,t,r,p,o,m],Cb:[u,t,r,p,o,m,k],Abm:[u,t,r,p,o,m,k],GbMix:[u,t,r,p,o,m,k],DbDor:[u,t,r,p,o,m,k],EbPhr:[u,t,r,p,o,m,k],FbLyd:[u,t,r,p,o,m,k],BbLoc:[u,t,r,p,o,m,k],"A#":[u,t],"B#":[],"D#":[u,t,r],"E#":[u],"G#":[u,t,r,p],Gbm:[n,s,w,l,q,v,z]};return y[x]};var c={treble:{clef:"treble",pitch:4,mid:0},"treble+8":{clef:"treble+8",pitch:4,mid:0},"treble-8":{clef:"treble-8",pitch:4,mid:0},treble1:{clef:"treble",pitch:2,mid:2},treble2:{clef:"treble",pitch:4,mid:0},treble3:{clef:"treble",pitch:6,mid:-2},treble4:{clef:"treble",pitch:8,mid:-4},treble5:{clef:"treble",pitch:10,mid:-6},perc:{clef:"perc",pitch:6,mid:0},none:{clef:"none",mid:0},bass:{clef:"bass",pitch:8,mid:-12},"bass+8":{clef:"bass+8",pitch:8,mid:-12},"bass-8":{clef:"bass-8",pitch:8,mid:-12},"bass+16":{clef:"bass",pitch:8,mid:-12},"bass-16":{clef:"bass",pitch:8,mid:-12},bass1:{clef:"bass",pitch:2,mid:-6},bass2:{clef:"bass",pitch:4,mid:-8},bass3:{clef:"bass",pitch:6,mid:-10},bass4:{clef:"bass",pitch:8,mid:-12},bass5:{clef:"bass",pitch:10,mid:-14},tenor:{clef:"alto",pitch:8,mid:-8},tenor1:{clef:"alto",pitch:2,mid:-2},tenor2:{clef:"alto",pitch:4,mid:-4},tenor3:{clef:"alto",pitch:6,mid:-6},tenor4:{clef:"alto",pitch:8,mid:-8},tenor5:{clef:"alto",pitch:10,mid:-10},alto:{clef:"alto",pitch:6,mid:-6},alto1:{clef:"alto",pitch:2,mid:-2},alto2:{clef:"alto",pitch:4,mid:-4},alto3:{clef:"alto",pitch:6,mid:-6},alto4:{clef:"alto",pitch:8,mid:-8},alto5:{clef:"alto",pitch:10,mid:-10},"alto+8":{clef:"alto+8",pitch:6,mid:-6},"alto-8":{clef:"alto-8",pitch:6,mid:-6}};var j=function(n,k){var m=c[n];var l=m?m.mid:0;return l+k};window.ABCJS.parse.parseKeyVoice.fixClef=function(l){var k=c[l.type];if(k){l.clefPos=k.pitch;l.type=k.clef}};window.ABCJS.parse.parseKeyVoice.deepCopyKey=function(l){var k={accidentals:[],root:l.root,acc:l.acc,mode:l.mode};window.ABCJS.parse.each(l.accidentals,function(m){k.accidentals.push(window.ABCJS.parse.clone(m))});return k};var d={A:5,B:6,C:0,D:1,E:2,F:3,G:4,a:12,b:13,c:7,d:8,e:9,f:10,g:11};window.ABCJS.parse.parseKeyVoice.addPosToKey=function(m,l){var k=m.verticalPos;window.ABCJS.parse.each(l.accidentals,function(n){var o=d[n.note];o=o-k;n.verticalPos=o});if(l.impliedNaturals){window.ABCJS.parse.each(l.impliedNaturals,function(n){var o=d[n.note];o=o-k;n.verticalPos=o})}if(k<-10){window.ABCJS.parse.each(l.accidentals,function(n){n.verticalPos-=7;if(n.verticalPos>=11||(n.verticalPos===10&&n.acc==="flat")){n.verticalPos-=7}if(n.note==="A"&&n.acc==="sharp"){n.verticalPos-=7}if((n.note==="G"||n.note==="F")&&n.acc==="flat"){n.verticalPos-=7}});if(l.impliedNaturals){window.ABCJS.parse.each(l.impliedNaturals,function(n){n.verticalPos-=7;if(n.verticalPos>=11||(n.verticalPos===10&&n.acc==="flat")){n.verticalPos-=7}if(n.note==="A"&&n.acc==="sharp"){n.verticalPos-=7}if((n.note==="G"||n.note==="F")&&n.acc==="flat"){n.verticalPos-=7}})}}else{if(k<-4){window.ABCJS.parse.each(l.accidentals,function(n){n.verticalPos-=7;
if(k===-8&&(n.note==="f"||n.note==="g")&&n.acc==="sharp"){n.verticalPos-=7}});if(l.impliedNaturals){window.ABCJS.parse.each(l.impliedNaturals,function(n){n.verticalPos-=7;if(k===-8&&(n.note==="f"||n.note==="g")&&n.acc==="sharp"){n.verticalPos-=7}})}}else{if(k>=7){window.ABCJS.parse.each(l.accidentals,function(n){n.verticalPos+=7});if(l.impliedNaturals){window.ABCJS.parse.each(l.impliedNaturals,function(n){n.verticalPos+=7})}}}}};window.ABCJS.parse.parseKeyVoice.fixKey=function(m,k){var l=window.ABCJS.parse.clone(k);window.ABCJS.parse.parseKeyVoice.addPosToKey(m,l);return l};var a=function(m){var k=d[m.charAt(0)];for(var l=1;l<m.length;l++){if(m.charAt(l)===","){k-=7}else{if(m.charAt(l)===","){k+=7}else{break}}}return{mid:k-6,str:m.substring(l)}};var h=function(k){for(var l=0;l<k.length;l++){if(k[l].note==="b"){k[l].note="B"}else{if(k[l].note==="a"){k[l].note="A"}else{if(k[l].note==="F"){k[l].note="f"}else{if(k[l].note==="E"){k[l].note="e"}else{if(k[l].note==="D"){k[l].note="d"}else{if(k[l].note==="C"){k[l].note="c"}else{if(k[l].note==="G"&&k[l].acc==="sharp"){k[l].note="g"}else{if(k[l].note==="g"&&k[l].acc==="flat"){k[l].note="G"}}}}}}}}}};window.ABCJS.parse.parseKeyVoice.parseKey=function(x){if(x.length===0){x="none"}var w=i.tokenize(x,0,x.length);var D={};switch(w[0].token){case"HP":window.ABCJS.parse.parseDirective.addDirective("bagpipes");b.key={root:"HP",accidentals:[],acc:"",mode:""};D.foundKey=true;w.shift();break;case"Hp":window.ABCJS.parse.parseDirective.addDirective("bagpipes");b.key={root:"Hp",accidentals:[{acc:"natural",note:"g"},{acc:"sharp",note:"f"},{acc:"sharp",note:"c"}],acc:"",mode:""};D.foundKey=true;w.shift();break;case"none":b.key={root:"none",accidentals:[],acc:"",mode:""};D.foundKey=true;w.shift();break;default:var p=i.getKeyPitch(w[0].token);if(p.len>0){D.foundKey=true;var n="";var v="";if(w[0].token.length>1){w[0].token=w[0].token.substring(1)}else{w.shift()}var E=p.token;if(w.length>0){var l=i.getSharpFlat(w[0].token);if(l.len>0){if(w[0].token.length>1){w[0].token=w[0].token.substring(1)}else{w.shift()}E+=l.token;n=l.token}if(w.length>0){var C=i.getMode(w[0].token);if(C.len>0){w.shift();E+=C.token;v=C.token}}}var s=window.ABCJS.parse.parseKeyVoice.deepCopyKey(b.key);b.key=window.ABCJS.parse.parseKeyVoice.deepCopyKey({accidentals:window.ABCJS.parse.parseKeyVoice.standardKey(E)});b.key.root=p.token;b.key.acc=n;b.key.mode=v;if(s){var m;for(var z=0;z<b.key.accidentals.length;z++){for(m=0;m<s.accidentals.length;m++){if(s.accidentals[m].note&&b.key.accidentals[z].note.toLowerCase()===s.accidentals[m].note.toLowerCase()){s.accidentals[m].note=null}}}for(m=0;m<s.accidentals.length;m++){if(s.accidentals[m].note){if(!b.key.impliedNaturals){b.key.impliedNaturals=[]}b.key.impliedNaturals.push({acc:"natural",note:s.accidentals[m].note})}}}}break}if(w.length===0){return D}if(w[0].token==="exp"){w.shift()}if(w.length===0){return D}if(w[0].token==="oct"){w.shift()}if(w.length===0){return D}var t=i.getKeyAccidentals2(w);if(t.warn){f(t.warn,x,0)}if(t.accs){if(!D.foundKey){D.foundKey=true;b.key={root:"none",acc:"",mode:"",accidentals:[]}}h(t.accs);for(var B=0;B<t.accs.length;B++){var u=false;for(var A=0;A<b.key.accidentals.length&&!u;A++){if(b.key.accidentals[A].note===t.accs[B].note){u=true;b.key.accidentals[A].acc=t.accs[B].acc}}if(!u){b.key.accidentals.push(t.accs[B]);if(b.key.impliedNaturals){for(var q=0;q<b.key.impliedNaturals.length;q++){if(b.key.impliedNaturals[q].note===t.accs[B].note){b.key.impliedNaturals.splice(q,1)}}}}}}var o;while(w.length>0){switch(w[0].token){case"m":case"middle":w.shift();if(w.length===0){f("Expected = after middle",x,0);return D}o=w.shift();if(o.token!=="="){f("Expected = after middle",x,o.start);break}if(w.length===0){f("Expected parameter after middle=",x,0);return D}var r=i.getPitchFromTokens(w);if(r.warn){f(r.warn,x,0)}if(r.position){b.clef.verticalPos=r.position-6}break;case"transpose":w.shift();if(w.length===0){f("Expected = after transpose",x,0);return D}o=w.shift();if(o.token!=="="){f("Expected = after transpose",x,o.start);break}if(w.length===0){f("Expected parameter after transpose=",x,0);return D}if(w[0].type!=="number"){f("Expected number after transpose",x,w[0].start);break}b.clef.transpose=w[0].intt;w.shift();break;case"stafflines":w.shift();if(w.length===0){f("Expected = after stafflines",x,0);return D}o=w.shift();if(o.token!=="="){f("Expected = after stafflines",x,o.start);break}if(w.length===0){f("Expected parameter after stafflines=",x,0);return D}if(w[0].type!=="number"){f("Expected number after stafflines",x,w[0].start);break}b.clef.stafflines=w[0].intt;w.shift();break;case"staffscale":w.shift();if(w.length===0){f("Expected = after staffscale",x,0);return D}o=w.shift();if(o.token!=="="){f("Expected = after staffscale",x,o.start);break}if(w.length===0){f("Expected parameter after staffscale=",x,0);return D}if(w[0].type!=="number"){f("Expected number after staffscale",x,w[0].start);break}b.clef.staffscale=w[0].floatt;w.shift();break;case"style":w.shift();if(w.length===0){f("Expected = after style",x,0);return D}o=w.shift();if(o.token!=="="){f("Expected = after style",x,o.start);break}if(w.length===0){f("Expected parameter after style=",x,0);return D}switch(w[0].token){case"normal":case"harmonic":case"rhythm":case"x":b.style=w[0].token;w.shift();break;default:f("error parsing style element: "+w[0].token,x,w[0].start);break}break;case"clef":w.shift();if(w.length===0){f("Expected = after clef",x,0);return D}o=w.shift();if(o.token!=="="){f("Expected = after clef",x,o.start);break}if(w.length===0){f("Expected parameter after clef=",x,0);return D}case"treble":case"bass":case"alto":case"tenor":case"perc":var y=w.shift();switch(y.token){case"treble":case"tenor":case"alto":case"bass":case"perc":case"none":break;case"C":y.token="alto";break;case"F":y.token="bass";break;case"G":y.token="treble";break;case"c":y.token="alto";break;case"f":y.token="bass";break;case"g":y.token="treble";break;default:f("Expected clef name. Found "+y.token,x,y.start);break}if(w.length>0&&w[0].type==="number"){y.token+=w[0].token;w.shift()}if(w.length>1&&(w[0].token==="-"||w[0].token==="+")&&w[1].token==="8"){y.token+=w[0].token+w[1].token;w.shift();w.shift()}b.clef={type:y.token,verticalPos:j(y.token,0)};D.foundClef=true;break;default:f("Unknown parameter: "+w[0].token,x,w[0].start);w.shift()}}return D};var g=function(k){b.currentVoice=b.voices[k];e.setCurrentVoice(b.currentVoice.staffNum,b.currentVoice.index)};window.ABCJS.parse.parseKeyVoice.parseVoice=function(n,x,y){var C=i.getMeat(n,x,y);var l=C.start;var k=C.end;var r=i.getToken(n,l,k);if(r.length===0){f("Expected a voice id",n,l);return}var A=false;if(b.voices[r]===undefined){b.voices[r]={};A=true;if(b.score_is_present){f("Can't have an unknown V: id when the %score directive is present",n,l)}}l+=r.length;l+=i.eatWhiteSpace(n,l);var p={startStaff:A};var D=function(v){var s=i.getVoiceToken(n,l,k);if(s.warn!==undefined){f("Expected value for "+v+" in voice: "+s.warn,n,l)}else{if(s.token.length===0&&n.charAt(l)!=='"'){f("Expected value for "+v+" in voice",n,l)
}else{p[v]=s.token}}l+=s.len};var z=function(F,v,E){var s=i.getVoiceToken(n,l,k);if(s.warn!==undefined){f("Expected value for "+v+" in voice: "+s.warn,n,l)}else{if(s.token.length===0&&n.charAt(l)!=='"'){f("Expected value for "+v+" in voice",n,l)}else{if(E==="number"){s.token=parseFloat(s.token)}b.voices[F][v]=s.token}}l+=s.len};while(l<k){var m=i.getVoiceToken(n,l,k);l+=m.len;if(m.warn){f("Error parsing voice: "+m.warn,n,l)}else{var u=null;switch(m.token){case"clef":case"cl":D("clef");var t=0;if(p.clef!==undefined){p.clef=p.clef.replace(/[',]/g,"");if(p.clef.indexOf("+16")!==-1){t+=14;p.clef=p.clef.replace("+16","")}p.verticalPos=j(p.clef,t)}break;case"treble":case"bass":case"tenor":case"alto":case"none":case"treble'":case"bass'":case"tenor'":case"alto'":case"none'":case"treble''":case"bass''":case"tenor''":case"alto''":case"none''":case"treble,":case"bass,":case"tenor,":case"alto,":case"none,":case"treble,,":case"bass,,":case"tenor,,":case"alto,,":case"none,,":var w=0;p.clef=m.token.replace(/[',]/g,"");p.verticalPos=j(p.clef,w);break;case"staves":case"stave":case"stv":D("staves");break;case"brace":case"brc":D("brace");break;case"bracket":case"brk":D("bracket");break;case"name":case"nm":D("name");break;case"subname":case"sname":case"snm":D("subname");break;case"merge":p.startStaff=false;break;case"stems":u=i.getVoiceToken(n,l,k);if(u.warn!==undefined){f("Expected value for stems in voice: "+u.warn,n,l)}else{if(u.token==="up"||u.token==="down"){b.voices[r].stem=u.token}else{f("Expected up or down for voice stem",n,l)}}l+=u.len;break;case"up":case"down":b.voices[r].stem=m.token;break;case"middle":case"m":D("verticalPos");p.verticalPos=a(p.verticalPos).mid;break;case"gchords":case"gch":b.voices[r].suppressChords=true;break;case"space":case"spc":D("spacing");break;case"scale":z(r,"scale","number");break;case"transpose":z(r,"transpose","number");break}}l+=i.eatWhiteSpace(n,l)}if(p.startStaff||b.staves.length===0){b.staves.push({index:b.staves.length,meter:b.origMeter});if(!b.score_is_present){b.staves[b.staves.length-1].numVoices=0}}if(b.voices[r].staffNum===undefined){b.voices[r].staffNum=b.staves.length-1;var B=0;for(var o in b.voices){if(b.voices.hasOwnProperty(o)){if(b.voices[o].staffNum===b.voices[r].staffNum){B++}}}b.voices[r].index=B-1}var q=b.staves[b.voices[r].staffNum];if(!b.score_is_present){q.numVoices++}if(p.clef){q.clef={type:p.clef,verticalPos:p.verticalPos}}if(p.spacing){q.spacing_below_offset=p.spacing}if(p.verticalPos){q.verticalPos=p.verticalPos}if(p.name){if(q.name){q.name.push(p.name)}else{q.name=[p.name]}}if(p.subname){if(q.subname){q.subname.push(p.subname)}else{q.subname=[p.subname]}}g(r)}})();if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.parse){window.ABCJS.parse={}}window.ABCJS.parse.tokenizer=function(){this.skipWhiteSpace=function(j){for(var h=0;h<j.length;h++){if(!this.isWhiteSpace(j.charAt(h))){return h}}return j.length};var g=function(j,h){return h>=j.length};this.eatWhiteSpace=function(h,j){for(var k=j;k<h.length;k++){if(!this.isWhiteSpace(h.charAt(k))){return k-j}}return k-j};this.getKeyPitch=function(j){var h=this.skipWhiteSpace(j);if(g(j,h)){return{len:0}}switch(j.charAt(h)){case"A":return{len:h+1,token:"A"};case"B":return{len:h+1,token:"B"};case"C":return{len:h+1,token:"C"};case"D":return{len:h+1,token:"D"};case"E":return{len:h+1,token:"E"};case"F":return{len:h+1,token:"F"};case"G":return{len:h+1,token:"G"}}return{len:0}};this.getSharpFlat=function(h){if(h==="bass"){return{len:0}}switch(h.charAt(0)){case"#":return{len:1,token:"#"};case"b":return{len:1,token:"b"}}return{len:0}};this.getMode=function(l){var k=function(i,m){while(m<i.length&&((i.charAt(m)>="a"&&i.charAt(m)<="z")||(i.charAt(m)>="A"&&i.charAt(m)<="Z"))){m++}return m};var j=this.skipWhiteSpace(l);if(g(l,j)){return{len:0}}var h=l.substring(j,j+3).toLowerCase();if(h.length>1&&h.charAt(1)===" "||h.charAt(1)==="^"||h.charAt(1)==="_"||h.charAt(1)==="="){h=h.charAt(0)}switch(h){case"mix":return{len:k(l,j),token:"Mix"};case"dor":return{len:k(l,j),token:"Dor"};case"phr":return{len:k(l,j),token:"Phr"};case"lyd":return{len:k(l,j),token:"Lyd"};case"loc":return{len:k(l,j),token:"Loc"};case"aeo":return{len:k(l,j),token:"m"};case"maj":return{len:k(l,j),token:""};case"ion":return{len:k(l,j),token:""};case"min":return{len:k(l,j),token:"m"};case"m":return{len:k(l,j),token:"m"}}return{len:0}};this.getClef=function(o,n){var h=o;var m=this.skipWhiteSpace(o);if(g(o,m)){return{len:0}}var q=false;var p=o.substring(m);if(window.ABCJS.parse.startsWith(p,"clef=")){q=true;p=p.substring(5);m+=5}if(p.length===0&&q){return{len:m+5,warn:"No clef specified: "+h}}var l=this.skipWhiteSpace(p);if(g(p,l)){return{len:0}}if(l>0){m+=l;p=p.substring(l)}var k=null;if(window.ABCJS.parse.startsWith(p,"treble")){k="treble"}else{if(window.ABCJS.parse.startsWith(p,"bass3")){k="bass3"}else{if(window.ABCJS.parse.startsWith(p,"bass")){k="bass"}else{if(window.ABCJS.parse.startsWith(p,"tenor")){k="tenor"}else{if(window.ABCJS.parse.startsWith(p,"alto2")){k="alto2"}else{if(window.ABCJS.parse.startsWith(p,"alto1")){k="alto1"}else{if(window.ABCJS.parse.startsWith(p,"alto")){k="alto"}else{if(!n&&(q&&window.ABCJS.parse.startsWith(p,"none"))){k="none"}else{if(window.ABCJS.parse.startsWith(p,"perc")){k="perc"}else{if(!n&&(q&&window.ABCJS.parse.startsWith(p,"C"))){k="tenor"}else{if(!n&&(q&&window.ABCJS.parse.startsWith(p,"F"))){k="bass"}else{if(!n&&(q&&window.ABCJS.parse.startsWith(p,"G"))){k="treble"}else{return{len:m+5,warn:"Unknown clef specified: "+h}}}}}}}}}}}}}p=p.substring(k.length);l=this.isMatch(p,"+8");if(l>0){k+="+8"}else{l=this.isMatch(p,"-8");if(l>0){k+="-8"}}return{len:m+k.length,token:k,explicit:q}};this.getBarLine=function(h,k){switch(h.charAt(k)){case"]":++k;switch(h.charAt(k)){case"|":return{len:2,token:"bar_thick_thin"};case"[":++k;if((h.charAt(k)>="1"&&h.charAt(k)<="9")||h.charAt(k)==='"'){return{len:2,token:"bar_invisible"}}return{len:1,warn:"Unknown bar symbol"};default:return{len:1,token:"bar_invisible"}}break;case":":++k;switch(h.charAt(k)){case":":return{len:2,token:"bar_dbl_repeat"};case"|":++k;switch(h.charAt(k)){case"]":++k;switch(h.charAt(k)){case"|":++k;if(h.charAt(k)===":"){return{len:5,token:"bar_dbl_repeat"}}return{len:3,token:"bar_right_repeat"};default:return{len:3,token:"bar_right_repeat"}}break;case"|":++k;if(h.charAt(k)===":"){return{len:4,token:"bar_dbl_repeat"}}return{len:3,token:"bar_right_repeat"};default:return{len:2,token:"bar_right_repeat"}}break;default:return{len:1,warn:"Unknown bar symbol"}}break;case"[":++k;if(h.charAt(k)==="|"){++k;switch(h.charAt(k)){case":":return{len:3,token:"bar_left_repeat"};case"]":return{len:3,token:"bar_invisible"};default:return{len:2,token:"bar_thick_thin"}}}else{if((h.charAt(k)>="1"&&h.charAt(k)<="9")||h.charAt(k)==='"'){return{len:1,token:"bar_invisible"}}return{len:0}}break;case"|":++k;switch(h.charAt(k)){case"]":return{len:2,token:"bar_thin_thick"};case"|":++k;if(h.charAt(k)===":"){return{len:3,token:"bar_left_repeat"}}return{len:2,token:"bar_thin_thin"};
case":":var j=0;while(h.charAt(k+j)===":"){j++}return{len:1+j,token:"bar_left_repeat"};default:return{len:1,token:"bar_thin"}}break}return{len:0}};this.getTokenOf=function(k,j){for(var h=0;h<k.length;h++){if(j.indexOf(k.charAt(h))<0){return{len:h,token:k.substring(0,h)}}}return{len:h,token:k}};this.getToken=function(k,l,h){var j=l;while(j<h&&!this.isWhiteSpace(k.charAt(j))){j++}return k.substring(l,j)};this.isMatch=function(k,h){var j=this.skipWhiteSpace(k);if(g(k,j)){return 0}if(window.ABCJS.parse.startsWith(k.substring(j),h)){return j+h.length}return 0};this.getPitchFromTokens=function(j){var h={};var i={A:5,B:6,C:0,D:1,E:2,F:3,G:4,a:12,b:13,c:7,d:8,e:9,f:10,g:11};h.position=i[j[0].token];if(h.position===undefined){return{warn:"Pitch expected. Found: "+j[0].token}}j.shift();while(j.length){switch(j[0].token){case",":h.position-=7;j.shift();break;case"'":h.position+=7;j.shift();break;default:return h}}return h};this.getKeyAccidentals2=function(j){var h;while(j.length>0){var i;if(j[0].token==="^"){i="sharp";j.shift();if(j.length===0){return{accs:h,warn:"Expected note name after "+i}}switch(j[0].token){case"^":i="dblsharp";j.shift();break;case"/":i="quartersharp";j.shift();break}}else{if(j[0].token==="="){i="natural";j.shift()}else{if(j[0].token==="_"){i="flat";j.shift();if(j.length===0){return{accs:h,warn:"Expected note name after "+i}}switch(j[0].token){case"_":i="dblflat";j.shift();break;case"/":i="quarterflat";j.shift();break}}else{return{accs:h}}}}if(j.length===0){return{accs:h,warn:"Expected note name after "+i}}switch(j[0].token.charAt(0)){case"a":case"b":case"c":case"d":case"e":case"f":case"g":case"A":case"B":case"C":case"D":case"E":case"F":case"G":if(h===undefined){h=[]}h.push({acc:i,note:j[0].token.charAt(0)});if(j[0].token.length===1){j.shift()}else{j[0].token=j[0].token.substring(1)}break;default:return{accs:h,warn:"Expected note name after "+i+" Found: "+j[0].token}}}return{accs:h}};this.getKeyAccidental=function(l){var k={"^":"sharp","^^":"dblsharp","=":"natural",_:"flat",__:"dblflat","_/":"quarterflat","^/":"quartersharp"};var h=this.skipWhiteSpace(l);if(g(l,h)){return{len:0}}var j=null;switch(l.charAt(h)){case"^":case"_":case"=":j=l.charAt(h);break;default:return{len:0}}h++;if(g(l,h)){return{len:1,warn:"Expected note name after accidental"}}switch(l.charAt(h)){case"a":case"b":case"c":case"d":case"e":case"f":case"g":case"A":case"B":case"C":case"D":case"E":case"F":case"G":return{len:h+1,token:{acc:k[j],note:l.charAt(h)}};case"^":case"_":case"/":j+=l.charAt(h);h++;if(g(l,h)){return{len:2,warn:"Expected note name after accidental"}}switch(l.charAt(h)){case"a":case"b":case"c":case"d":case"e":case"f":case"g":case"A":case"B":case"C":case"D":case"E":case"F":case"G":return{len:h+1,token:{acc:k[j],note:l.charAt(h)}};default:return{len:2,warn:"Expected note name after accidental"}}break;default:return{len:1,warn:"Expected note name after accidental"}}};this.isWhiteSpace=function(h){return h===" "||h==="\t"||h==="\x12"};this.getMeat=function(i,k,h){var j=i.indexOf("%",k);if(j>=0&&j<h){h=j}while(k<h&&(i.charAt(k)===" "||i.charAt(k)==="\t"||i.charAt(k)==="\x12")){k++}while(k<h&&(i.charAt(h-1)===" "||i.charAt(h-1)==="\t"||i.charAt(h-1)==="\x12")){h--}return{start:k,end:h}};var d=function(h){return(h>="A"&&h<="Z")||(h>="a"&&h<="z")};var c=function(h){return(h>="0"&&h<="9")};this.tokenize=function(r,j,k){var n=this.getMeat(r,j,k);j=n.start;k=n.end;var p=[];var l;while(j<k){if(r.charAt(j)==='"'){l=j+1;while(l<k&&r.charAt(l)!=='"'){l++}p.push({type:"quote",token:r.substring(j+1,l),start:j+1,end:l});l++}else{if(d(r.charAt(j))){l=j+1;while(l<k&&d(r.charAt(l))){l++}p.push({type:"alpha",token:r.substring(j,l),continueId:c(r.charAt(l)),start:j,end:l});j=l+1}else{if(r.charAt(j)==="."&&c(r.charAt(l+1))){l=j+1;var q=null;var m=null;while(l<k&&c(r.charAt(l))){l++}m=parseFloat(r.substring(j,l));p.push({type:"number",token:r.substring(j,l),intt:q,floatt:m,continueId:d(r.charAt(l)),start:j,end:l});j=l+1}else{if(c(r.charAt(j))||(r.charAt(j)==="-"&&c(r.charAt(l+1)))){l=j+1;var h=null;var o=null;while(l<k&&c(r.charAt(l))){l++}if(r.charAt(l)==="."&&c(r.charAt(l+1))){l++;while(l<k&&c(r.charAt(l))){l++}}else{h=parseInt(r.substring(j,l))}o=parseFloat(r.substring(j,l));p.push({type:"number",token:r.substring(j,l),intt:h,floatt:o,continueId:d(r.charAt(l)),start:j,end:l});j=l+1}else{if(r.charAt(j)===" "||r.charAt(j)==="\t"){l=j+1}else{p.push({type:"punct",token:r.charAt(j),start:j,end:j+1});l=j+1}}}}}j=l}return p};this.getVoiceToken=function(j,n,h){var k=n;while(k<h&&this.isWhiteSpace(j.charAt(k))||j.charAt(k)==="="){k++}if(j.charAt(k)==='"'){var m=j.indexOf('"',k+1);if(m===-1||m>=h){return{len:1,err:"Missing close quote"}}return{len:m-n+1,token:this.translateString(j.substring(k+1,m))}}else{var l=k;while(l<h&&!this.isWhiteSpace(j.charAt(l))&&j.charAt(l)!=="="){l++}return{len:l-n+1,token:j.substring(k,l)}}};var f={"`a":"à","'a":"á","^a":"â","~a":"ã",'"a':"ä",oa:"å","=a":"ā",ua:"ă",";a":"ą","`e":"è","'e":"é","^e":"ê",'"e':"ë","=e":"ē",ue:"ĕ",";e":"ę",".e":"ė","`i":"ì","'i":"í","^i":"î",'"i':"ï","=i":"ī",ui:"ĭ",";i":"į","`o":"ò","'o":"ó","^o":"ô","~o":"õ",'"o':"ö","=o":"ō",uo:"ŏ","/o":"ø","`u":"ù","'u":"ú","^u":"û","~u":"ũ",'"u':"ü",ou:"ů","=u":"ū",uu:"ŭ",";u":"ų","`A":"À","'A":"Á","^A":"Â","~A":"Ã",'"A':"Ä",oA:"Å","=A":"Ā",uA:"Ă",";A":"Ą","`E":"È","'E":"É","^E":"Ê",'"E':"Ë","=E":"Ē",uE:"Ĕ",";E":"Ę",".E":"Ė","`I":"Ì","'I":"Í","^I":"Î","~I":"Ĩ",'"I':"Ï","=I":"Ī",uI:"Ĭ",";I":"Į",".I":"İ","`O":"Ò","'O":"Ó","^O":"Ô","~O":"Õ",'"O':"Ö","=O":"Ō",uO:"Ŏ","/O":"Ø","`U":"Ù","'U":"Ú","^U":"Û","~U":"Ũ",'"U':"Ü",oU:"Ů","=U":"Ū",uU:"Ŭ",";U":"Ų",ae:"æ",AE:"Æ",oe:"œ",OE:"Œ",ss:"ß","'c":"ć","^c":"ĉ",uc:"č",cc:"ç",".c":"ċ",cC:"Ç","'C":"Ć","^C":"Ĉ",uC:"Č",".C":"Ċ","~n":"ñ","=s":"š",vs:"š",vz:"ž"};var e={"#":"♯",b:"♭","=":"♮"};var b={"201":"♯","202":"♭","203":"♮","241":"¡","242":"¢","252":"a","262":"2","272":"o","302":"Â","312":"Ê","322":"Ò","332":"Ú","342":"â","352":"ê","362":"ò","372":"ú","243":"£","253":"«","263":"3","273":"»","303":"Ã","313":"Ë","323":"Ó","333":"Û","343":"ã","353":"ë","363":"ó","373":"û","244":"¤","254":"¬","264":"  ́","274":"1⁄4","304":"Ä","314":"Ì","324":"Ô","334":"Ü","344":"ä","354":"ì","364":"ô","374":"ü","245":"¥","255":"-","265":"μ","275":"1⁄2","305":"Å","315":"Í","325":"Õ","335":"Ý","345":"å","355":"í","365":"õ","375":"ý","246":"¦","256":"®","266":"¶","276":"3⁄4","306":"Æ","316":"Î","326":"Ö","336":"Þ","346":"æ","356":"î","366":"ö","376":"þ","247":"§","257":" ̄","267":"·","277":"¿","307":"Ç","317":"Ï","327":"×","337":"ß","347":"ç","357":"ï","367":"÷","377":"ÿ","250":" ̈","260":"°","270":" ̧","300":"À","310":"È","320":"Ð","330":"Ø","340":"à","350":"è","360":"ð","370":"ø","251":"©","261":"±","271":"1","301":"Á","311":"É","321":"Ñ","331":"Ù","341":"á","351":"é","361":"ñ","371":"ù"};this.translateString=function(j){var h=j.split("\\");
if(h.length===1){return j}var i=null;window.ABCJS.parse.each(h,function(k){if(i===null){i=k}else{var l=f[k.substring(0,2)];if(l!==undefined){i+=l+k.substring(2)}else{l=b[k.substring(0,3)];if(l!==undefined){i+=l+k.substring(3)}else{l=e[k.substring(0,1)];if(l!==undefined){i+=l+k.substring(1)}else{i+="\\"+k}}}}});return i};this.getNumber=function(h,j){var i=0;while(j<h.length){switch(h.charAt(j)){case"0":i=i*10;j++;break;case"1":i=i*10+1;j++;break;case"2":i=i*10+2;j++;break;case"3":i=i*10+3;j++;break;case"4":i=i*10+4;j++;break;case"5":i=i*10+5;j++;break;case"6":i=i*10+6;j++;break;case"7":i=i*10+7;j++;break;case"8":i=i*10+8;j++;break;case"9":i=i*10+9;j++;break;default:return{num:i,index:j}}}return{num:i,index:j}};this.getFraction=function(h,k){var j=1;var o=1;if(h.charAt(k)!=="/"){var i=this.getNumber(h,k);j=i.num;k=i.index}if(h.charAt(k)==="/"){k++;if(h.charAt(k)==="/"){var n=0.5;while(h.charAt(k++)==="/"){n=n/2}return{value:j*n,index:k-1}}else{var l=k;var m=this.getNumber(h,k);if(m.num===0&&l===k){m.num=2}if(m.num!==0){o=m.num}k=m.index}}return{value:j/o,index:k}};this.theReverser=function(h){if(window.ABCJS.parse.endsWith(h,", The")){return"The "+h.substring(0,h.length-5)}if(window.ABCJS.parse.endsWith(h,", A")){return"A "+h.substring(0,h.length-3)}return h};this.stripComment=function(j){var h=j.indexOf("%");if(h>=0){return window.ABCJS.parse.strip(j.substring(0,h))}return window.ABCJS.parse.strip(j)};this.getInt=function(l){var h=parseInt(l);if(isNaN(h)){return{digits:0}}var k=""+h;var j=l.indexOf(k);return{value:h,digits:j+k.length}};this.getFloat=function(l){var h=parseFloat(l);if(isNaN(h)){return{digits:0}}var k=""+h;var j=l.indexOf(k);return{value:h,digits:j+k.length}};this.getMeasurement=function(k){if(k.length===0){return{used:0}}var j=1;var i="";if(k[0].token==="-"){k.shift();i="-";j++}else{if(k[0].type!=="number"){return{used:0}}}i+=k.shift().token;if(k.length===0){return{used:1,value:parseInt(i)}}var h=k.shift();if(h.token==="."){j++;if(k.length===0){return{used:j,value:parseInt(i)}}if(k[0].type==="number"){h=k.shift();i=i+"."+h.token;j++;if(k.length===0){return{used:j,value:parseFloat(i)}}}h=k.shift()}switch(h.token){case"pt":return{used:j+1,value:parseFloat(i)};case"cm":return{used:j+1,value:parseFloat(i)/2.54*72};case"in":return{used:j+1,value:parseFloat(i)*72};default:k.unshift(h);return{used:j,value:parseFloat(i)}}return{used:0}};var a=function(h){while(h.indexOf("\\n")!==-1){h=h.replace("\\n","\n")}return h};this.getBrackettedSubstring=function(h,j,n,l){var k=l||h.charAt(j);var m=j+1;while((m<h.length)&&(h.charAt(m)!==k)){++m}if(h.charAt(m)===k){return[m-j+1,a(h.substring(j+1,m)),true]}else{m=j+n;if(m>h.length-1){m=h.length-1}return[m-j+1,a(h.substring(j+1,m)),false]}}};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.write){window.ABCJS.write={}}ABCJS.write.Glyphs=function(){var a={"rests.whole":{d:[["M",0.06,0.03],["l",0.09,-0.06],["l",5.46,0],["l",5.49,0],["l",0.09,0.06],["l",0.06,0.09],["l",0,2.19],["l",0,2.19],["l",-0.06,0.09],["l",-0.09,0.06],["l",-5.49,0],["l",-5.46,0],["l",-0.09,-0.06],["l",-0.06,-0.09],["l",0,-2.19],["l",0,-2.19],["z"]],w:11.25,h:4.68},"rests.half":{d:[["M",0.06,-4.62],["l",0.09,-0.06],["l",5.46,0],["l",5.49,0],["l",0.09,0.06],["l",0.06,0.09],["l",0,2.19],["l",0,2.19],["l",-0.06,0.09],["l",-0.09,0.06],["l",-5.49,0],["l",-5.46,0],["l",-0.09,-0.06],["l",-0.06,-0.09],["l",0,-2.19],["l",0,-2.19],["z"]],w:11.25,h:4.68},"rests.quarter":{d:[["M",1.89,-11.82],["c",0.12,-0.06,0.24,-0.06,0.36,-0.03],["c",0.09,0.06,4.74,5.58,4.86,5.82],["c",0.21,0.39,0.15,0.78,-0.15,1.26],["c",-0.24,0.33,-0.72,0.81,-1.62,1.56],["c",-0.45,0.36,-0.87,0.75,-0.96,0.84],["c",-0.93,0.99,-1.14,2.49,-0.6,3.63],["c",0.18,0.39,0.27,0.48,1.32,1.68],["c",1.92,2.25,1.83,2.16,1.83,2.34],["c",-0,0.18,-0.18,0.36,-0.36,0.39],["c",-0.15,-0,-0.27,-0.06,-0.48,-0.27],["c",-0.75,-0.75,-2.46,-1.29,-3.39,-1.08],["c",-0.45,0.09,-0.69,0.27,-0.9,0.69],["c",-0.12,0.3,-0.21,0.66,-0.24,1.14],["c",-0.03,0.66,0.09,1.35,0.3,2.01],["c",0.15,0.42,0.24,0.66,0.45,0.96],["c",0.18,0.24,0.18,0.33,0.03,0.42],["c",-0.12,0.06,-0.18,0.03,-0.45,-0.3],["c",-1.08,-1.38,-2.07,-3.36,-2.4,-4.83],["c",-0.27,-1.05,-0.15,-1.77,0.27,-2.07],["c",0.21,-0.12,0.42,-0.15,0.87,-0.15],["c",0.87,0.06,2.1,0.39,3.3,0.9],["l",0.39,0.18],["l",-1.65,-1.95],["c",-2.52,-2.97,-2.61,-3.09,-2.7,-3.27],["c",-0.09,-0.24,-0.12,-0.48,-0.03,-0.75],["c",0.15,-0.48,0.57,-0.96,1.83,-2.01],["c",0.45,-0.36,0.84,-0.72,0.93,-0.78],["c",0.69,-0.75,1.02,-1.8,0.9,-2.79],["c",-0.06,-0.33,-0.21,-0.84,-0.39,-1.11],["c",-0.09,-0.15,-0.45,-0.6,-0.81,-1.05],["c",-0.36,-0.42,-0.69,-0.81,-0.72,-0.87],["c",-0.09,-0.18,-0,-0.42,0.21,-0.51],["z"]],w:7.888,h:21.435},"rests.8th":{d:[["M",1.68,-6.12],["c",0.66,-0.09,1.23,0.09,1.68,0.51],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.12,0.27,0.33,0.45,0.6,0.48],["c",0.12,0,0.18,0,0.33,-0.09],["c",0.39,-0.18,1.32,-1.29,1.68,-1.98],["c",0.09,-0.21,0.24,-0.3,0.39,-0.3],["c",0.12,0,0.27,0.09,0.33,0.18],["c",0.03,0.06,-0.27,1.11,-1.86,6.42],["c",-1.02,3.48,-1.89,6.39,-1.92,6.42],["c",0,0.03,-0.12,0.12,-0.24,0.15],["c",-0.18,0.09,-0.21,0.09,-0.45,0.09],["c",-0.24,0,-0.3,0,-0.48,-0.06],["c",-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],["c",-0.06,-0.03,0.15,-0.57,1.68,-4.92],["c",0.96,-2.67,1.74,-4.89,1.71,-4.89],["l",-0.51,0.15],["c",-1.08,0.36,-1.74,0.48,-2.55,0.48],["c",-0.66,0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.33,-0.45,0.84,-0.81,1.38,-0.9],["z"]],w:7.534,h:13.883},"rests.16th":{d:[["M",3.33,-6.12],["c",0.66,-0.09,1.23,0.09,1.68,0.51],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.15,0.39,0.57,0.57,0.87,0.42],["c",0.39,-0.18,1.2,-1.23,1.62,-2.07],["c",0.06,-0.15,0.24,-0.24,0.36,-0.24],["c",0.12,0,0.27,0.09,0.33,0.18],["c",0.03,0.06,-0.45,1.86,-2.67,10.17],["c",-1.5,5.55,-2.73,10.14,-2.76,10.17],["c",-0.03,0.03,-0.12,0.12,-0.24,0.15],["c",-0.18,0.09,-0.21,0.09,-0.45,0.09],["c",-0.24,0,-0.3,0,-0.48,-0.06],["c",-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],["c",-0.06,-0.03,0.12,-0.57,1.44,-4.92],["c",0.81,-2.67,1.47,-4.86,1.47,-4.89],["c",-0.03,0,-0.27,0.06,-0.54,0.15],["c",-1.08,0.36,-1.77,0.48,-2.58,0.48],["c",-0.66,0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.72,-1.05,2.22,-1.23,3.06,-0.42],["c",0.3,0.33,0.42,0.6,0.6,1.38],["c",0.09,0.45,0.21,0.78,0.33,0.9],["c",0.09,0.09,0.27,0.18,0.45,0.21],["c",0.12,0,0.18,0,0.33,-0.09],["c",0.33,-0.15,1.02,-0.93,1.41,-1.59],["c",0.12,-0.21,0.18,-0.39,0.39,-1.08],["c",0.66,-2.1,1.17,-3.84,1.17,-3.87],["c",0,0,-0.21,0.06,-0.42,0.15],["c",-0.51,0.15,-1.2,0.33,-1.68,0.42],["c",-0.33,0.06,-0.51,0.06,-0.96,0.06],["c",-0.66,0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.33,-0.45,0.84,-0.81,1.38,-0.9],["z"]],w:9.724,h:21.383},"rests.32nd":{d:[["M",4.23,-13.62],["c",0.66,-0.09,1.23,0.09,1.68,0.51],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.12,0.27,0.33,0.45,0.6,0.48],["c",0.12,0,0.18,0,0.27,-0.06],["c",0.33,-0.21,0.99,-1.11,1.44,-1.98],["c",0.09,-0.24,0.21,-0.33,0.39,-0.33],["c",0.12,0,0.27,0.09,0.33,0.18],["c",0.03,0.06,-0.57,2.67,-3.21,13.89],["c",-1.8,7.62,-3.3,13.89,-3.3,13.92],["c",-0.03,0.06,-0.12,0.12,-0.24,0.18],["c",-0.21,0.09,-0.24,0.09,-0.48,0.09],["c",-0.24,-0,-0.3,-0,-0.48,-0.06],["c",-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],["c",-0.06,-0.03,0.09,-0.57,1.23,-4.92],["c",0.69,-2.67,1.26,-4.86,1.29,-4.89],["c",0,-0.03,-0.12,-0.03,-0.48,0.12],["c",-1.17,0.39,-2.22,0.57,-3,0.54],["c",-0.42,-0.03,-0.75,-0.12,-1.11,-0.3],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.72,-1.05,2.22,-1.23,3.06,-0.42],["c",0.3,0.33,0.42,0.6,0.6,1.38],["c",0.09,0.45,0.21,0.78,0.33,0.9],["c",0.12,0.09,0.3,0.18,0.48,0.21],["c",0.12,-0,0.18,-0,0.3,-0.09],["c",0.42,-0.21,1.29,-1.29,1.56,-1.89],["c",0.03,-0.12,1.23,-4.59,1.23,-4.65],["c",0,-0.03,-0.18,0.03,-0.39,0.12],["c",-0.63,0.18,-1.2,0.36,-1.74,0.45],["c",-0.39,0.06,-0.54,0.06,-1.02,0.06],["c",-0.66,-0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.72,-1.05,2.22,-1.23,3.06,-0.42],["c",0.3,0.33,0.42,0.6,0.6,1.38],["c",0.09,0.45,0.21,0.78,0.33,0.9],["c",0.18,0.18,0.51,0.27,0.72,0.15],["c",0.3,-0.12,0.69,-0.57,1.08,-1.17],["c",0.42,-0.6,0.39,-0.51,1.05,-3.03],["c",0.33,-1.26,0.6,-2.31,0.6,-2.34],["c",0,-0,-0.21,0.03,-0.45,0.12],["c",-0.57,0.18,-1.14,0.33,-1.62,0.42],["c",-0.33,0.06,-0.51,0.06,-0.96,0.06],["c",-0.66,-0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.33,-0.45,0.84,-0.81,1.38,-0.9],["z"]],w:11.373,h:28.883},"rests.64th":{d:[["M",5.13,-13.62],["c",0.66,-0.09,1.23,0.09,1.68,0.51],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.15,0.63,0.21,0.81,0.33,0.96],["c",0.18,0.21,0.54,0.3,0.75,0.18],["c",0.24,-0.12,0.63,-0.66,1.08,-1.56],["c",0.33,-0.66,0.39,-0.72,0.6,-0.72],["c",0.12,0,0.27,0.09,0.33,0.18],["c",0.03,0.06,-0.69,3.66,-3.54,17.64],["c",-1.95,9.66,-3.57,17.61,-3.57,17.64],["c",-0.03,0.06,-0.12,0.12,-0.24,0.18],["c",-0.21,0.09,-0.24,0.09,-0.48,0.09],["c",-0.24,0,-0.3,0,-0.48,-0.06],["c",-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],["c",-0.06,-0.03,0.06,-0.57,1.05,-4.95],["c",0.6,-2.7,1.08,-4.89,1.08,-4.92],["c",0,0,-0.24,0.06,-0.51,0.15],["c",-0.66,0.24,-1.2,0.36,-1.77,0.48],["c",-0.42,0.06,-0.57,0.06,-1.05,0.06],["c",-0.69,0,-0.87,-0.03,-1.35,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.72,-1.05,2.22,-1.23,3.06,-0.42],["c",0.3,0.33,0.42,0.6,0.6,1.38],["c",0.09,0.45,0.21,0.78,0.33,0.9],["c",0.09,0.09,0.27,0.18,0.45,0.21],["c",0.21,0.03,0.39,-0.09,0.72,-0.42],["c",0.45,-0.45,1.02,-1.26,1.17,-1.65],["c",0.03,-0.09,0.27,-1.14,0.54,-2.34],["c",0.27,-1.2,0.48,-2.19,0.51,-2.22],["c",0,-0.03,-0.09,-0.03,-0.48,0.12],["c",-1.17,0.39,-2.22,0.57,-3,0.54],["c",-0.42,-0.03,-0.75,-0.12,-1.11,-0.3],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.36,-0.54,0.96,-0.87,1.65,-0.93],["c",0.54,-0.03,1.02,0.15,1.41,0.54],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.15,0.39,0.57,0.57,0.9,0.42],["c",0.36,-0.18,1.2,-1.26,1.47,-1.89],["c",0.03,-0.09,0.3,-1.2,0.57,-2.43],["l",0.51,-2.28],["l",-0.54,0.18],["c",-1.11,0.36,-1.8,0.48,-2.61,0.48],["c",-0.66,0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.36,-0.54,0.96,-0.87,1.65,-0.93],["c",0.54,-0.03,1.02,0.15,1.41,0.54],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.15,0.63,0.21,0.81,0.33,0.96],["c",0.21,0.21,0.54,0.3,0.75,0.18],["c",0.36,-0.18,0.93,-0.93,1.29,-1.68],["c",0.12,-0.24,0.18,-0.48,0.63,-2.55],["l",0.51,-2.31],["c",0,-0.03,-0.18,0.03,-0.39,0.12],["c",-1.14,0.36,-2.1,0.54,-2.82,0.51],["c",-0.42,-0.03,-0.75,-0.12,-1.11,-0.3],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.33,-0.45,0.84,-0.81,1.38,-0.9],["z"]],w:12.453,h:36.383},"rests.128th":{d:[["M",6.03,-21.12],["c",0.66,-0.09,1.23,0.09,1.68,0.51],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.12,0.27,0.33,0.45,0.6,0.48],["c",0.21,0,0.33,-0.06,0.54,-0.36],["c",0.15,-0.21,0.54,-0.93,0.78,-1.47],["c",0.15,-0.33,0.18,-0.39,0.3,-0.48],["c",0.18,-0.09,0.45,0,0.51,0.15],["c",0.03,0.09,-7.11,42.75,-7.17,42.84],["c",-0.03,0.03,-0.15,0.09,-0.24,0.15],["c",-0.18,0.06,-0.24,0.06,-0.45,0.06],["c",-0.24,-0,-0.3,-0,-0.48,-0.06],["c",-0.09,-0.06,-0.21,-0.12,-0.21,-0.15],["c",-0.06,-0.03,0.03,-0.57,0.84,-4.98],["c",0.51,-2.7,0.93,-4.92,0.9,-4.92],["c",0,-0,-0.15,0.06,-0.36,0.12],["c",-0.78,0.27,-1.62,0.48,-2.31,0.57],["c",-0.15,0.03,-0.54,0.03,-0.81,0.03],["c",-0.66,-0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.36,-0.54,0.96,-0.87,1.65,-0.93],["c",0.54,-0.03,1.02,0.15,1.41,0.54],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.12,0.27,0.33,0.45,0.63,0.48],["c",0.12,-0,0.18,-0,0.3,-0.09],["c",0.42,-0.21,1.14,-1.11,1.5,-1.83],["c",0.12,-0.27,0.12,-0.27,0.54,-2.52],["c",0.24,-1.23,0.42,-2.25,0.39,-2.25],["c",0,-0,-0.24,0.06,-0.51,0.18],["c",-1.26,0.39,-2.25,0.57,-3.06,0.54],["c",-0.42,-0.03,-0.75,-0.12,-1.11,-0.3],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.36,-0.54,0.96,-0.87,1.65,-0.93],["c",0.54,-0.03,1.02,0.15,1.41,0.54],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.15,0.63,0.21,0.81,0.33,0.96],["c",0.18,0.21,0.51,0.3,0.75,0.18],["c",0.36,-0.15,1.05,-0.99,1.41,-1.77],["l",0.15,-0.3],["l",0.42,-2.25],["c",0.21,-1.26,0.42,-2.28,0.39,-2.28],["l",-0.51,0.15],["c",-1.11,0.39,-1.89,0.51,-2.7,0.51],["c",-0.66,-0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.36,-0.54,0.96,-0.87,1.65,-0.93],["c",0.54,-0.03,1.02,0.15,1.41,0.54],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.15,0.63,0.21,0.81,0.33,0.96],["c",0.18,0.18,0.48,0.27,0.72,0.21],["c",0.33,-0.12,1.14,-1.26,1.41,-1.95],["c",0,-0.09,0.21,-1.11,0.45,-2.34],["c",0.21,-1.2,0.39,-2.22,0.39,-2.28],["c",0.03,-0.03,0,-0.03,-0.45,0.12],["c",-0.57,0.18,-1.2,0.33,-1.71,0.42],["c",-0.3,0.06,-0.51,0.06,-0.93,0.06],["c",-0.66,-0,-0.84,-0.03,-1.32,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.36,-0.54,0.96,-0.87,1.65,-0.93],["c",0.54,-0.03,1.02,0.15,1.41,0.54],["c",0.27,0.3,0.39,0.54,0.57,1.26],["c",0.09,0.33,0.18,0.66,0.21,0.72],["c",0.12,0.27,0.33,0.45,0.6,0.48],["c",0.18,-0,0.36,-0.09,0.57,-0.33],["c",0.33,-0.36,0.78,-1.14,0.93,-1.56],["c",0.03,-0.12,0.24,-1.2,0.45,-2.4],["c",0.24,-1.2,0.42,-2.22,0.42,-2.28],["c",0.03,-0.03,0,-0.03,-0.39,0.09],["c",-1.05,0.36,-1.8,0.48,-2.58,0.48],["c",-0.63,-0,-0.84,-0.03,-1.29,-0.27],["c",-1.32,-0.63,-1.77,-2.16,-1.02,-3.3],["c",0.33,-0.45,0.84,-0.81,1.38,-0.9],["z"]],w:12.992,h:43.883},"accidentals.sharp":{d:[["M",5.73,-11.19],["c",0.21,-0.12,0.54,-0.03,0.66,0.24],["c",0.06,0.12,0.06,0.21,0.06,2.31],["c",0,1.23,0,2.22,0.03,2.22],["c",0,-0,0.27,-0.12,0.6,-0.24],["c",0.69,-0.27,0.78,-0.3,0.96,-0.15],["c",0.21,0.15,0.21,0.18,0.21,1.38],["c",0,1.02,0,1.11,-0.06,1.2],["c",-0.03,0.06,-0.09,0.12,-0.12,0.15],["c",-0.06,0.03,-0.42,0.21,-0.84,0.36],["l",-0.75,0.33],["l",-0.03,2.43],["c",0,1.32,0,2.43,0.03,2.43],["c",0,-0,0.27,-0.12,0.6,-0.24],["c",0.69,-0.27,0.78,-0.3,0.96,-0.15],["c",0.21,0.15,0.21,0.18,0.21,1.38],["c",0,1.02,0,1.11,-0.06,1.2],["c",-0.03,0.06,-0.09,0.12,-0.12,0.15],["c",-0.06,0.03,-0.42,0.21,-0.84,0.36],["l",-0.75,0.33],["l",-0.03,2.52],["c",0,2.28,-0.03,2.55,-0.06,2.64],["c",-0.21,0.36,-0.72,0.36,-0.93,-0],["c",-0.03,-0.09,-0.06,-0.33,-0.06,-2.43],["l",0,-2.31],["l",-1.29,0.51],["l",-1.26,0.51],["l",0,2.43],["c",0,2.58,0,2.52,-0.15,2.67],["c",-0.06,0.09,-0.27,0.18,-0.36,0.18],["c",-0.12,-0,-0.33,-0.09,-0.39,-0.18],["c",-0.15,-0.15,-0.15,-0.09,-0.15,-2.43],["c",0,-1.23,0,-2.22,-0.03,-2.22],["c",0,-0,-0.27,0.12,-0.6,0.24],["c",-0.69,0.27,-0.78,0.3,-0.96,0.15],["c",-0.21,-0.15,-0.21,-0.18,-0.21,-1.38],["c",0,-1.02,0,-1.11,0.06,-1.2],["c",0.03,-0.06,0.09,-0.12,0.12,-0.15],["c",0.06,-0.03,0.42,-0.21,0.84,-0.36],["l",0.78,-0.33],["l",0,-2.43],["c",0,-1.32,0,-2.43,-0.03,-2.43],["c",0,-0,-0.27,0.12,-0.6,0.24],["c",-0.69,0.27,-0.78,0.3,-0.96,0.15],["c",-0.21,-0.15,-0.21,-0.18,-0.21,-1.38],["c",0,-1.02,0,-1.11,0.06,-1.2],["c",0.03,-0.06,0.09,-0.12,0.12,-0.15],["c",0.06,-0.03,0.42,-0.21,0.84,-0.36],["l",0.78,-0.33],["l",0,-2.52],["c",0,-2.28,0.03,-2.55,0.06,-2.64],["c",0.21,-0.36,0.72,-0.36,0.93,0],["c",0.03,0.09,0.06,0.33,0.06,2.43],["l",0.03,2.31],["l",1.26,-0.51],["l",1.26,-0.51],["l",0,-2.43],["c",0,-2.28,0,-2.43,0.06,-2.55],["c",0.06,-0.12,0.12,-0.18,0.27,-0.24],["z"],["m",-0.33,10.65],["l",0,-2.43],["l",-1.29,0.51],["l",-1.26,0.51],["l",0,2.46],["l",0,2.43],["l",0.09,-0.03],["c",0.06,-0.03,0.63,-0.27,1.29,-0.51],["l",1.17,-0.48],["l",0,-2.46],["z"]],w:8.25,h:22.462},"accidentals.halfsharp":{d:[["M",2.43,-10.05],["c",0.21,-0.12,0.54,-0.03,0.66,0.24],["c",0.06,0.12,0.06,0.21,0.06,2.01],["c",0,1.05,0,1.89,0.03,1.89],["l",0.72,-0.48],["c",0.69,-0.48,0.69,-0.51,0.87,-0.51],["c",0.15,0,0.18,0.03,0.27,0.09],["c",0.21,0.15,0.21,0.18,0.21,1.41],["c",0,1.11,-0.03,1.14,-0.09,1.23],["c",-0.03,0.03,-0.48,0.39,-1.02,0.75],["l",-0.99,0.66],["l",0,2.37],["c",0,1.32,0,2.37,0.03,2.37],["l",0.72,-0.48],["c",0.69,-0.48,0.69,-0.51,0.87,-0.51],["c",0.15,0,0.18,0.03,0.27,0.09],["c",0.21,0.15,0.21,0.18,0.21,1.41],["c",0,1.11,-0.03,1.14,-0.09,1.23],["c",-0.03,0.03,-0.48,0.39,-1.02,0.75],["l",-0.99,0.66],["l",0,2.25],["c",0,1.95,0,2.28,-0.06,2.37],["c",-0.06,0.12,-0.12,0.21,-0.24,0.27],["c",-0.27,0.12,-0.54,0.03,-0.69,-0.24],["c",-0.06,-0.12,-0.06,-0.21,-0.06,-2.01],["c",0,-1.05,0,-1.89,-0.03,-1.89],["l",-0.72,0.48],["c",-0.69,0.48,-0.69,0.48,-0.87,0.48],["c",-0.15,0,-0.18,0,-0.27,-0.06],["c",-0.21,-0.15,-0.21,-0.18,-0.21,-1.41],["c",0,-1.11,0.03,-1.14,0.09,-1.23],["c",0.03,-0.03,0.48,-0.39,1.02,-0.75],["l",0.99,-0.66],["l",0,-2.37],["c",0,-1.32,0,-2.37,-0.03,-2.37],["l",-0.72,0.48],["c",-0.69,0.48,-0.69,0.48,-0.87,0.48],["c",-0.15,0,-0.18,0,-0.27,-0.06],["c",-0.21,-0.15,-0.21,-0.18,-0.21,-1.41],["c",0,-1.11,0.03,-1.14,0.09,-1.23],["c",0.03,-0.03,0.48,-0.39,1.02,-0.75],["l",0.99,-0.66],["l",0,-2.25],["c",0,-2.13,0,-2.28,0.06,-2.4],["c",0.06,-0.12,0.12,-0.18,0.27,-0.24],["z"]],w:5.25,h:20.174},"accidentals.nat":{d:[["M",0.204,-11.4],["c",0.24,-0.06,0.78,0,0.99,0.15],["c",0.03,0.03,0.03,0.48,0,2.61],["c",-0.03,1.44,-0.03,2.61,-0.03,2.61],["c",0,0.03,0.75,-0.09,1.68,-0.24],["c",0.96,-0.18,1.71,-0.27,1.74,-0.27],["c",0.15,0.03,0.27,0.15,0.36,0.3],["l",0.06,0.12],["l",0.09,8.67],["c",0.09,6.96,0.12,8.67,0.09,8.67],["c",-0.03,0.03,-0.12,0.06,-0.21,0.09],["c",-0.24,0.09,-0.72,0.09,-0.96,0],["c",-0.09,-0.03,-0.18,-0.06,-0.21,-0.09],["c",-0.03,-0.03,-0.03,-0.48,0,-2.61],["c",0.03,-1.44,0.03,-2.61,0.03,-2.61],["c",0,-0.03,-0.75,0.09,-1.68,0.24],["c",-0.96,0.18,-1.71,0.27,-1.74,0.27],["c",-0.15,-0.03,-0.27,-0.15,-0.36,-0.3],["l",-0.06,-0.15],["l",-0.09,-7.53],["c",-0.06,-4.14,-0.09,-8.04,-0.12,-8.67],["l",0,-1.11],["l",0.15,-0.06],["c",0.09,-0.03,0.21,-0.06,0.27,-0.09],["z"],["m",3.75,8.4],["c",0,-0.33,0,-0.42,-0.03,-0.42],["c",-0.12,0,-2.79,0.45,-2.79,0.48],["c",-0.03,0,-0.09,6.3,-0.09,6.33],["c",0.03,0,2.79,-0.45,2.82,-0.48],["c",0,0,0.09,-4.53,0.09,-5.91],["z"]],w:5.411,h:22.8},"accidentals.flat":{d:[["M",-0.36,-14.07],["c",0.33,-0.06,0.87,0,1.08,0.15],["c",0.06,0.03,0.06,0.36,-0.03,5.25],["c",-0.06,2.85,-0.09,5.19,-0.09,5.19],["c",0,0.03,0.12,-0.03,0.24,-0.12],["c",0.63,-0.42,1.41,-0.66,2.19,-0.72],["c",0.81,-0.03,1.47,0.21,2.04,0.78],["c",0.57,0.54,0.87,1.26,0.93,2.04],["c",0.03,0.57,-0.09,1.08,-0.36,1.62],["c",-0.42,0.81,-1.02,1.38,-2.82,2.61],["c",-1.14,0.78,-1.44,1.02,-1.8,1.44],["c",-0.18,0.18,-0.39,0.39,-0.45,0.42],["c",-0.27,0.18,-0.57,0.15,-0.81,-0.06],["c",-0.06,-0.09,-0.12,-0.18,-0.15,-0.27],["c",-0.03,-0.06,-0.09,-3.27,-0.18,-8.34],["c",-0.09,-4.53,-0.15,-8.58,-0.18,-9.03],["l",0,-0.78],["l",0.12,-0.06],["c",0.06,-0.03,0.18,-0.09,0.27,-0.12],["z"],["m",3.18,11.01],["c",-0.21,-0.12,-0.54,-0.15,-0.81,-0.06],["c",-0.54,0.15,-0.99,0.63,-1.17,1.26],["c",-0.06,0.3,-0.12,2.88,-0.06,3.87],["c",0.03,0.42,0.03,0.81,0.06,0.9],["l",0.03,0.12],["l",0.45,-0.39],["c",0.63,-0.54,1.26,-1.17,1.56,-1.59],["c",0.3,-0.42,0.6,-0.99,0.72,-1.41],["c",0.18,-0.69,0.09,-1.47,-0.18,-2.07],["c",-0.15,-0.3,-0.33,-0.51,-0.6,-0.63],["z"]],w:6.75,h:18.801},"accidentals.halfflat":{d:[["M",4.83,-14.07],["c",0.33,-0.06,0.87,0,1.08,0.15],["c",0.06,0.03,0.06,0.6,-0.12,9.06],["c",-0.09,5.55,-0.15,9.06,-0.18,9.12],["c",-0.03,0.09,-0.09,0.18,-0.15,0.27],["c",-0.24,0.21,-0.54,0.24,-0.81,0.06],["c",-0.06,-0.03,-0.27,-0.24,-0.45,-0.42],["c",-0.36,-0.42,-0.66,-0.66,-1.8,-1.44],["c",-1.23,-0.84,-1.83,-1.32,-2.25,-1.77],["c",-0.66,-0.78,-0.96,-1.56,-0.93,-2.46],["c",0.09,-1.41,1.11,-2.58,2.4,-2.79],["c",0.3,-0.06,0.84,-0.03,1.23,0.06],["c",0.54,0.12,1.08,0.33,1.53,0.63],["c",0.12,0.09,0.24,0.15,0.24,0.12],["c",0,0,-0.12,-8.37,-0.18,-9.75],["l",0,-0.66],["l",0.12,-0.06],["c",0.06,-0.03,0.18,-0.09,0.27,-0.12],["z"],["m",-1.65,10.95],["c",-0.6,-0.18,-1.08,0.09,-1.38,0.69],["c",-0.27,0.6,-0.36,1.38,-0.18,2.07],["c",0.12,0.42,0.42,0.99,0.72,1.41],["c",0.3,0.42,0.93,1.05,1.56,1.59],["l",0.48,0.39],["l",0,-0.12],["c",0.03,-0.09,0.03,-0.48,0.06,-0.9],["c",0.03,-0.57,0.03,-1.08,0,-2.22],["c",-0.03,-1.62,-0.03,-1.62,-0.24,-2.07],["c",-0.21,-0.42,-0.6,-0.75,-1.02,-0.84],["z"]],w:6.728,h:18.801},"accidentals.dblflat":{d:[["M",-0.36,-14.07],["c",0.33,-0.06,0.87,0,1.08,0.15],["c",0.06,0.03,0.06,0.33,-0.03,4.89],["c",-0.06,2.67,-0.09,5.01,-0.09,5.22],["l",0,0.36],["l",0.15,-0.15],["c",0.36,-0.3,0.75,-0.51,1.2,-0.63],["c",0.33,-0.09,0.96,-0.09,1.26,-0.03],["c",0.27,0.09,0.63,0.27,0.87,0.45],["l",0.21,0.15],["l",0,-0.27],["c",0,-0.15,-0.03,-2.43,-0.09,-5.1],["c",-0.09,-4.56,-0.09,-4.86,-0.03,-4.89],["c",0.15,-0.12,0.39,-0.15,0.72,-0.15],["c",0.3,0,0.54,0.03,0.69,0.15],["c",0.06,0.03,0.06,0.33,-0.03,4.95],["c",-0.06,2.7,-0.09,5.04,-0.09,5.22],["l",0.03,0.3],["l",0.21,-0.15],["c",0.69,-0.48,1.44,-0.69,2.28,-0.69],["c",0.51,0,0.78,0.03,1.2,0.21],["c",1.32,0.63,2.01,2.28,1.53,3.69],["c",-0.21,0.57,-0.51,1.02,-1.05,1.56],["c",-0.42,0.42,-0.81,0.72,-1.92,1.5],["c",-1.26,0.87,-1.5,1.08,-1.86,1.5],["c",-0.39,0.45,-0.54,0.54,-0.81,0.51],["c",-0.18,0,-0.21,0,-0.33,-0.06],["l",-0.21,-0.21],["l",-0.06,-0.12],["l",-0.03,-0.99],["c",-0.03,-0.54,-0.03,-1.29,-0.06,-1.68],["l",0,-0.69],["l",-0.21,0.24],["c",-0.36,0.42,-0.75,0.75,-1.8,1.62],["c",-1.02,0.84,-1.2,0.99,-1.44,1.38],["c",-0.36,0.51,-0.54,0.6,-0.9,0.51],["c",-0.15,-0.03,-0.39,-0.27,-0.42,-0.42],["c",-0.03,-0.06,-0.09,-3.27,-0.18,-8.34],["c",-0.09,-4.53,-0.15,-8.58,-0.18,-9.03],["l",0,-0.78],["l",0.12,-0.06],["c",0.06,-0.03,0.18,-0.09,0.27,-0.12],["z"],["m",2.52,10.98],["c",-0.18,-0.09,-0.48,-0.12,-0.66,-0.06],["c",-0.39,0.15,-0.69,0.54,-0.84,1.14],["c",-0.06,0.24,-0.06,0.39,-0.09,1.74],["c",-0.03,1.44,0,2.73,0.06,3.18],["l",0.03,0.15],["l",0.27,-0.27],["c",0.93,-0.96,1.5,-1.95,1.74,-3.06],["c",0.06,-0.27,0.06,-0.39,0.06,-0.96],["c",0,-0.54,0,-0.69,-0.06,-0.93],["c",-0.09,-0.51,-0.27,-0.81,-0.51,-0.93],["z"],["m",5.43,0],["c",-0.18,-0.09,-0.51,-0.12,-0.72,-0.06],["c",-0.54,0.12,-0.96,0.63,-1.17,1.26],["c",-0.06,0.3,-0.12,2.88,-0.06,3.9],["c",0.03,0.42,0.03,0.81,0.06,0.9],["l",0.03,0.12],["l",0.36,-0.3],["c",0.42,-0.36,1.02,-0.96,1.29,-1.29],["c",0.36,-0.45,0.66,-0.99,0.81,-1.41],["c",0.42,-1.23,0.15,-2.76,-0.6,-3.12],["z"]],w:11.613,h:18.804},"accidentals.dblsharp":{d:[["M",-0.186,-3.96],["c",0.06,-0.03,0.12,-0.06,0.15,-0.06],["c",0.09,0,2.76,0.27,2.79,0.3],["c",0.12,0.03,0.15,0.12,0.15,0.51],["c",0.06,0.96,0.24,1.59,0.57,2.1],["c",0.06,0.09,0.15,0.21,0.18,0.24],["l",0.09,0.06],["l",0.09,-0.06],["c",0.03,-0.03,0.12,-0.15,0.18,-0.24],["c",0.33,-0.51,0.51,-1.14,0.57,-2.1],["c",0,-0.39,0.03,-0.45,0.12,-0.51],["c",0.03,0,0.66,-0.09,1.44,-0.15],["c",1.47,-0.15,1.5,-0.15,1.56,-0.03],["c",0.03,0.06,0,0.42,-0.09,1.44],["c",-0.09,0.72,-0.15,1.35,-0.15,1.38],["c",0,0.03,-0.03,0.09,-0.06,0.12],["c",-0.06,0.06,-0.12,0.09,-0.51,0.09],["c",-1.08,0.06,-1.8,0.3,-2.28,0.75],["l",-0.12,0.09],["l",0.09,0.09],["c",0.12,0.15,0.39,0.33,0.63,0.45],["c",0.42,0.18,0.96,0.27,1.68,0.33],["c",0.39,-0,0.45,0.03,0.51,0.09],["c",0.03,0.03,0.06,0.09,0.06,0.12],["c",0,0.03,0.06,0.66,0.15,1.38],["c",0.09,1.02,0.12,1.38,0.09,1.44],["c",-0.06,0.12,-0.09,0.12,-1.56,-0.03],["c",-0.78,-0.06,-1.41,-0.15,-1.44,-0.15],["c",-0.09,-0.06,-0.12,-0.12,-0.12,-0.54],["c",-0.06,-0.93,-0.24,-1.56,-0.57,-2.07],["c",-0.06,-0.09,-0.15,-0.21,-0.18,-0.24],["l",-0.09,-0.06],["l",-0.09,0.06],["c",-0.03,0.03,-0.12,0.15,-0.18,0.24],["c",-0.33,0.51,-0.51,1.14,-0.57,2.07],["c",0,0.42,-0.03,0.48,-0.12,0.54],["c",-0.03,0,-0.66,0.09,-1.44,0.15],["c",-1.47,0.15,-1.5,0.15,-1.56,0.03],["c",-0.03,-0.06,0,-0.42,0.09,-1.44],["c",0.09,-0.72,0.15,-1.35,0.15,-1.38],["c",0,-0.03,0.03,-0.09,0.06,-0.12],["c",0.06,-0.06,0.12,-0.09,0.51,-0.09],["c",0.72,-0.06,1.26,-0.15,1.68,-0.33],["c",0.24,-0.12,0.51,-0.3,0.63,-0.45],["l",0.09,-0.09],["l",-0.12,-0.09],["c",-0.48,-0.45,-1.2,-0.69,-2.28,-0.75],["c",-0.39,0,-0.45,-0.03,-0.51,-0.09],["c",-0.03,-0.03,-0.06,-0.09,-0.06,-0.12],["c",0,-0.03,-0.06,-0.63,-0.12,-1.38],["c",-0.09,-0.72,-0.15,-1.35,-0.15,-1.38],["z"]],w:7.961,h:7.977},"dots.dot":{d:[["M",1.32,-1.68],["c",0.09,-0.03,0.27,-0.06,0.39,-0.06],["c",0.96,0,1.74,0.78,1.74,1.71],["c",0,0.96,-0.78,1.74,-1.71,1.74],["c",-0.96,0,-1.74,-0.78,-1.74,-1.71],["c",0,-0.78,0.54,-1.5,1.32,-1.68],["z"]],w:3.45,h:3.45},"noteheads.dbl":{d:[["M",-0.69,-4.02],["c",0.18,-0.09,0.36,-0.09,0.54,0],["c",0.18,0.09,0.24,0.15,0.33,0.3],["c",0.06,0.15,0.06,0.18,0.06,1.41],["l",-0,1.23],["l",0.12,-0.18],["c",0.72,-1.26,2.64,-2.31,4.86,-2.64],["c",0.81,-0.15,1.11,-0.15,2.13,-0.15],["c",0.99,0,1.29,0,2.1,0.15],["c",0.75,0.12,1.38,0.27,2.04,0.54],["c",1.35,0.51,2.34,1.26,2.82,2.1],["l",0.12,0.18],["l",0,-1.23],["c",0,-1.2,0,-1.26,0.06,-1.38],["c",0.09,-0.18,0.15,-0.24,0.33,-0.33],["c",0.18,-0.09,0.36,-0.09,0.54,0],["c",0.18,0.09,0.24,0.15,0.33,0.3],["l",0.06,0.15],["l",0,3.54],["l",0,3.54],["l",-0.06,0.15],["c",-0.09,0.18,-0.15,0.24,-0.33,0.33],["c",-0.18,0.09,-0.36,0.09,-0.54,0],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["c",-0.06,-0.12,-0.06,-0.18,-0.06,-1.38],["l",0,-1.23],["l",-0.12,0.18],["c",-0.48,0.84,-1.47,1.59,-2.82,2.1],["c",-0.84,0.33,-1.71,0.54,-2.85,0.66],["c",-0.45,0.06,-2.16,0.06,-2.61,0],["c",-1.14,-0.12,-2.01,-0.33,-2.85,-0.66],["c",-1.35,-0.51,-2.34,-1.26,-2.82,-2.1],["l",-0.12,-0.18],["l",0,1.23],["c",0,1.23,0,1.26,-0.06,1.38],["c",-0.09,0.18,-0.15,0.24,-0.33,0.33],["c",-0.18,0.09,-0.36,0.09,-0.54,0],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["l",-0.06,-0.15],["l",0,-3.54],["c",0,-3.48,0,-3.54,0.06,-3.66],["c",0.09,-0.18,0.15,-0.24,0.33,-0.33],["z"],["m",7.71,0.63],["c",-0.36,-0.06,-0.9,-0.06,-1.14,0],["c",-0.3,0.03,-0.66,0.24,-0.87,0.42],["c",-0.6,0.54,-0.9,1.62,-0.75,2.82],["c",0.12,0.93,0.51,1.68,1.11,2.31],["c",0.75,0.72,1.83,1.2,2.85,1.26],["c",1.05,0.06,1.83,-0.54,2.1,-1.65],["c",0.21,-0.9,0.12,-1.95,-0.24,-2.82],["c",-0.36,-0.81,-1.08,-1.53,-1.95,-1.95],["c",-0.3,-0.15,-0.78,-0.3,-1.11,-0.39],["z"]],w:16.83,h:8.145},"noteheads.whole":{d:[["M",6.51,-4.05],["c",0.51,-0.03,2.01,0,2.52,0.03],["c",1.41,0.18,2.64,0.51,3.72,1.08],["c",1.2,0.63,1.95,1.41,2.19,2.31],["c",0.09,0.33,0.09,0.9,-0,1.23],["c",-0.24,0.9,-0.99,1.68,-2.19,2.31],["c",-1.08,0.57,-2.28,0.9,-3.75,1.08],["c",-0.66,0.06,-2.31,0.06,-2.97,0],["c",-1.47,-0.18,-2.67,-0.51,-3.75,-1.08],["c",-1.2,-0.63,-1.95,-1.41,-2.19,-2.31],["c",-0.09,-0.33,-0.09,-0.9,-0,-1.23],["c",0.24,-0.9,0.99,-1.68,2.19,-2.31],["c",1.2,-0.63,2.61,-0.99,4.23,-1.11],["z"],["m",0.57,0.66],["c",-0.87,-0.15,-1.53,0,-2.04,0.51],["c",-0.15,0.15,-0.24,0.27,-0.33,0.48],["c",-0.24,0.51,-0.36,1.08,-0.33,1.77],["c",0.03,0.69,0.18,1.26,0.42,1.77],["c",0.6,1.17,1.74,1.98,3.18,2.22],["c",1.11,0.21,1.95,-0.15,2.34,-0.99],["c",0.24,-0.51,0.36,-1.08,0.33,-1.8],["c",-0.06,-1.11,-0.45,-2.04,-1.17,-2.76],["c",-0.63,-0.63,-1.47,-1.05,-2.4,-1.2],["z"]],w:14.985,h:8.097},"noteheads.half":{d:[["M",7.44,-4.05],["c",0.06,-0.03,0.27,-0.03,0.48,-0.03],["c",1.05,0,1.71,0.24,2.1,0.81],["c",0.42,0.6,0.45,1.35,0.18,2.4],["c",-0.42,1.59,-1.14,2.73,-2.16,3.39],["c",-1.41,0.93,-3.18,1.44,-5.4,1.53],["c",-1.17,0.03,-1.89,-0.21,-2.28,-0.81],["c",-0.42,-0.6,-0.45,-1.35,-0.18,-2.4],["c",0.42,-1.59,1.14,-2.73,2.16,-3.39],["c",0.63,-0.42,1.23,-0.72,1.98,-0.96],["c",0.9,-0.3,1.65,-0.42,3.12,-0.54],["z"],["m",1.29,0.87],["c",-0.27,-0.09,-0.63,-0.12,-0.9,-0.03],["c",-0.72,0.24,-1.53,0.69,-3.27,1.8],["c",-2.34,1.5,-3.3,2.25,-3.57,2.79],["c",-0.36,0.72,-0.06,1.5,0.66,1.77],["c",0.24,0.12,0.69,0.09,0.99,0],["c",0.84,-0.3,1.92,-0.93,4.14,-2.37],["c",1.62,-1.08,2.37,-1.71,2.61,-2.19],["c",0.36,-0.72,0.06,-1.5,-0.66,-1.77],["z"]],w:10.37,h:8.132},"noteheads.quarter":{d:[["M",6.09,-4.05],["c",0.36,-0.03,1.2,0,1.53,0.06],["c",1.17,0.24,1.89,0.84,2.16,1.83],["c",0.06,0.18,0.06,0.3,0.06,0.66],["c",0,0.45,0,0.63,-0.15,1.08],["c",-0.66,2.04,-3.06,3.93,-5.52,4.38],["c",-0.54,0.09,-1.44,0.09,-1.83,0.03],["c",-1.23,-0.27,-1.98,-0.87,-2.25,-1.86],["c",-0.06,-0.18,-0.06,-0.3,-0.06,-0.66],["c",0,-0.45,0,-0.63,0.15,-1.08],["c",0.24,-0.78,0.75,-1.53,1.44,-2.22],["c",1.2,-1.2,2.85,-2.01,4.47,-2.22],["z"]],w:9.81,h:8.094},"scripts.ufermata":{d:[["M",-0.75,-10.77],["c",0.12,0,0.45,-0.03,0.69,-0.03],["c",2.91,-0.03,5.55,1.53,7.41,4.35],["c",1.17,1.71,1.95,3.72,2.43,6.03],["c",0.12,0.51,0.12,0.57,0.03,0.69],["c",-0.12,0.21,-0.48,0.27,-0.69,0.12],["c",-0.12,-0.09,-0.18,-0.24,-0.27,-0.69],["c",-0.78,-3.63,-3.42,-6.54,-6.78,-7.38],["c",-0.78,-0.21,-1.2,-0.24,-2.07,-0.24],["c",-0.63,-0,-0.84,-0,-1.2,0.06],["c",-1.83,0.27,-3.42,1.08,-4.8,2.37],["c",-1.41,1.35,-2.4,3.21,-2.85,5.19],["c",-0.09,0.45,-0.15,0.6,-0.27,0.69],["c",-0.21,0.15,-0.57,0.09,-0.69,-0.12],["c",-0.09,-0.12,-0.09,-0.18,0.03,-0.69],["c",0.33,-1.62,0.78,-3,1.47,-4.38],["c",1.77,-3.54,4.44,-5.67,7.56,-5.97],["z"],["m",0.33,7.47],["c",1.38,-0.3,2.58,0.9,2.31,2.25],["c",-0.15,0.72,-0.78,1.35,-1.47,1.5],["c",-1.38,0.27,-2.58,-0.93,-2.31,-2.31],["c",0.15,-0.69,0.78,-1.29,1.47,-1.44],["z"]],w:19.748,h:11.289},"scripts.dfermata":{d:[["M",-9.63,-0.42],["c",0.15,-0.09,0.36,-0.06,0.51,0.03],["c",0.12,0.09,0.18,0.24,0.27,0.66],["c",0.78,3.66,3.42,6.57,6.78,7.41],["c",0.78,0.21,1.2,0.24,2.07,0.24],["c",0.63,-0,0.84,-0,1.2,-0.06],["c",1.83,-0.27,3.42,-1.08,4.8,-2.37],["c",1.41,-1.35,2.4,-3.21,2.85,-5.22],["c",0.09,-0.42,0.15,-0.57,0.27,-0.66],["c",0.21,-0.15,0.57,-0.09,0.69,0.12],["c",0.09,0.12,0.09,0.18,-0.03,0.69],["c",-0.33,1.62,-0.78,3,-1.47,4.38],["c",-1.92,3.84,-4.89,6,-8.31,6],["c",-3.42,0,-6.39,-2.16,-8.31,-6],["c",-0.48,-0.96,-0.84,-1.92,-1.14,-2.97],["c",-0.18,-0.69,-0.42,-1.74,-0.42,-1.92],["c",0,-0.12,0.09,-0.27,0.24,-0.33],["z"],["m",9.21,0],["c",1.2,-0.27,2.34,0.63,2.34,1.86],["c",-0,0.9,-0.66,1.68,-1.5,1.89],["c",-1.38,0.27,-2.58,-0.93,-2.31,-2.31],["c",0.15,-0.69,0.78,-1.29,1.47,-1.44],["z"]],w:19.744,h:11.274},"scripts.sforzato":{d:[["M",-6.45,-3.69],["c",0.06,-0.03,0.15,-0.06,0.18,-0.06],["c",0.06,0,2.85,0.72,6.24,1.59],["l",6.33,1.65],["c",0.33,0.06,0.45,0.21,0.45,0.51],["c",0,0.3,-0.12,0.45,-0.45,0.51],["l",-6.33,1.65],["c",-3.39,0.87,-6.18,1.59,-6.21,1.59],["c",-0.21,-0,-0.48,-0.24,-0.51,-0.45],["c",0,-0.15,0.06,-0.36,0.18,-0.45],["c",0.09,-0.06,0.87,-0.27,3.84,-1.05],["c",2.04,-0.54,3.84,-0.99,4.02,-1.02],["c",0.15,-0.06,1.14,-0.24,2.22,-0.42],["c",1.05,-0.18,1.92,-0.36,1.92,-0.36],["c",0,-0,-0.87,-0.18,-1.92,-0.36],["c",-1.08,-0.18,-2.07,-0.36,-2.22,-0.42],["c",-0.18,-0.03,-1.98,-0.48,-4.02,-1.02],["c",-2.97,-0.78,-3.75,-0.99,-3.84,-1.05],["c",-0.12,-0.09,-0.18,-0.3,-0.18,-0.45],["c",0.03,-0.15,0.15,-0.3,0.3,-0.39],["z"]],w:13.5,h:7.5},"scripts.staccato":{d:[["M",-0.36,-1.47],["c",0.93,-0.21,1.86,0.51,1.86,1.47],["c",-0,0.93,-0.87,1.65,-1.8,1.47],["c",-0.54,-0.12,-1.02,-0.57,-1.14,-1.08],["c",-0.21,-0.81,0.27,-1.65,1.08,-1.86],["z"]],w:2.989,h:3.004},"scripts.tenuto":{d:[["M",-4.2,-0.48],["l",0.12,-0.06],["l",4.08,0],["l",4.08,0],["l",0.12,0.06],["c",0.39,0.21,0.39,0.75,0,0.96],["l",-0.12,0.06],["l",-4.08,0],["l",-4.08,0],["l",-0.12,-0.06],["c",-0.39,-0.21,-0.39,-0.75,0,-0.96],["z"]],w:8.985,h:1.08},"scripts.umarcato":{d:[["M",-0.15,-8.19],["c",0.15,-0.12,0.36,-0.03,0.45,0.15],["c",0.21,0.42,3.45,7.65,3.45,7.71],["c",-0,0.12,-0.12,0.27,-0.21,0.3],["c",-0.03,0.03,-0.51,0.03,-1.14,0.03],["c",-1.05,0,-1.08,0,-1.17,-0.06],["c",-0.09,-0.06,-0.24,-0.36,-1.17,-2.4],["c",-0.57,-1.29,-1.05,-2.34,-1.08,-2.34],["c",-0,-0.03,-0.51,1.02,-1.08,2.34],["c",-0.93,2.07,-1.08,2.34,-1.14,2.4],["c",-0.06,0.03,-0.15,0.06,-0.18,0.06],["c",-0.15,0,-0.33,-0.18,-0.33,-0.33],["c",-0,-0.06,3.24,-7.32,3.45,-7.71],["c",0.03,-0.06,0.09,-0.15,0.15,-0.15],["z"]],w:7.5,h:8.245},"scripts.dmarcato":{d:[["M",-3.57,0.03],["c",0.03,0,0.57,-0.03,1.17,-0.03],["c",1.05,0,1.08,0,1.17,0.06],["c",0.09,0.06,0.24,0.36,1.17,2.4],["c",0.57,1.29,1.05,2.34,1.08,2.34],["c",0,0.03,0.51,-1.02,1.08,-2.34],["c",0.93,-2.07,1.08,-2.34,1.14,-2.4],["c",0.06,-0.03,0.15,-0.06,0.18,-0.06],["c",0.15,0,0.33,0.18,0.33,0.33],["c",0,0.09,-3.45,7.74,-3.54,7.83],["c",-0.12,0.12,-0.3,0.12,-0.42,0],["c",-0.09,-0.09,-3.54,-7.74,-3.54,-7.83],["c",0,-0.09,0.12,-0.27,0.18,-0.3],["z"]],w:7.5,h:8.25},"scripts.stopped":{d:[["M",-0.27,-4.08],["c",0.18,-0.09,0.36,-0.09,0.54,0],["c",0.18,0.09,0.24,0.15,0.33,0.3],["l",0.06,0.15],["l",-0,1.5],["l",-0,1.47],["l",1.47,0],["l",1.5,0],["l",0.15,0.06],["c",0.15,0.09,0.21,0.15,0.3,0.33],["c",0.09,0.18,0.09,0.36,-0,0.54],["c",-0.09,0.18,-0.15,0.24,-0.33,0.33],["c",-0.12,0.06,-0.18,0.06,-1.62,0.06],["l",-1.47,0],["l",-0,1.47],["l",-0,1.47],["l",-0.06,0.15],["c",-0.09,0.18,-0.15,0.24,-0.33,0.33],["c",-0.18,0.09,-0.36,0.09,-0.54,0],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["l",-0.06,-0.15],["l",-0,-1.47],["l",-0,-1.47],["l",-1.47,0],["c",-1.44,0,-1.5,0,-1.62,-0.06],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["c",-0.09,-0.18,-0.09,-0.36,-0,-0.54],["c",0.09,-0.18,0.15,-0.24,0.33,-0.33],["l",0.15,-0.06],["l",1.47,0],["l",1.47,0],["l",-0,-1.47],["c",-0,-1.44,-0,-1.5,0.06,-1.62],["c",0.09,-0.18,0.15,-0.24,0.33,-0.33],["z"]],w:8.295,h:8.295},"scripts.upbow":{d:[["M",-4.65,-15.54],["c",0.12,-0.09,0.36,-0.06,0.48,0.03],["c",0.03,0.03,0.09,0.09,0.12,0.15],["c",0.03,0.06,0.66,2.13,1.41,4.62],["c",1.35,4.41,1.38,4.56,2.01,6.96],["l",0.63,2.46],["l",0.63,-2.46],["c",0.63,-2.4,0.66,-2.55,2.01,-6.96],["c",0.75,-2.49,1.38,-4.56,1.41,-4.62],["c",0.06,-0.15,0.18,-0.21,0.36,-0.24],["c",0.15,0,0.3,0.06,0.39,0.18],["c",0.15,0.21,0.24,-0.18,-2.1,7.56],["c",-1.2,3.96,-2.22,7.32,-2.25,7.41],["c",0,0.12,-0.06,0.27,-0.09,0.3],["c",-0.12,0.21,-0.6,0.21,-0.72,0],["c",-0.03,-0.03,-0.09,-0.18,-0.09,-0.3],["c",-0.03,-0.09,-1.05,-3.45,-2.25,-7.41],["c",-2.34,-7.74,-2.25,-7.35,-2.1,-7.56],["c",0.03,-0.03,0.09,-0.09,0.15,-0.12],["z"]],w:9.73,h:15.608},"scripts.downbow":{d:[["M",-5.55,-9.93],["l",0.09,-0.06],["l",5.46,0],["l",5.46,0],["l",0.09,0.06],["l",0.06,0.09],["l",0,4.77],["c",0,5.28,0,4.89,-0.18,5.01],["c",-0.18,0.12,-0.42,0.06,-0.54,-0.12],["c",-0.06,-0.09,-0.06,-0.18,-0.06,-2.97],["l",0,-2.85],["l",-4.83,0],["l",-4.83,0],["l",0,2.85],["c",0,2.79,0,2.88,-0.06,2.97],["c",-0.15,0.24,-0.51,0.24,-0.66,0],["c",-0.06,-0.09,-0.06,-0.21,-0.06,-4.89],["l",0,-4.77],["z"]],w:11.22,h:9.992},"scripts.turn":{d:[["M",-4.77,-3.9],["c",0.36,-0.06,1.05,-0.06,1.44,0.03],["c",0.78,0.15,1.5,0.51,2.34,1.14],["c",0.6,0.45,1.05,0.87,2.22,2.01],["c",1.11,1.08,1.62,1.5,2.22,1.86],["c",0.6,0.36,1.32,0.57,1.92,0.57],["c",0.9,-0,1.71,-0.57,1.89,-1.35],["c",0.24,-0.93,-0.39,-1.89,-1.35,-2.1],["l",-0.15,-0.06],["l",-0.09,0.15],["c",-0.03,0.09,-0.15,0.24,-0.24,0.33],["c",-0.72,0.72,-2.04,0.54,-2.49,-0.36],["c",-0.48,-0.93,0.03,-1.86,1.17,-2.19],["c",0.3,-0.09,1.02,-0.09,1.35,-0],["c",0.99,0.27,1.74,0.87,2.25,1.83],["c",0.69,1.41,0.63,3,-0.21,4.26],["c",-0.21,0.3,-0.69,0.81,-0.99,1.02],["c",-0.3,0.21,-0.84,0.45,-1.17,0.54],["c",-1.23,0.36,-2.49,0.15,-3.72,-0.6],["c",-0.75,-0.48,-1.41,-1.02,-2.85,-2.46],["c",-1.11,-1.08,-1.62,-1.5,-2.22,-1.86],["c",-0.6,-0.36,-1.32,-0.57,-1.92,-0.57],["c",-0.9,0,-1.71,0.57,-1.89,1.35],["c",-0.24,0.93,0.39,1.89,1.35,2.1],["l",0.15,0.06],["l",0.09,-0.15],["c",0.03,-0.09,0.15,-0.24,0.24,-0.33],["c",0.72,-0.72,2.04,-0.54,2.49,0.36],["c",0.48,0.93,-0.03,1.86,-1.17,2.19],["c",-0.3,0.09,-1.02,0.09,-1.35,0],["c",-0.99,-0.27,-1.74,-0.87,-2.25,-1.83],["c",-0.69,-1.41,-0.63,-3,0.21,-4.26],["c",0.21,-0.3,0.69,-0.81,0.99,-1.02],["c",0.48,-0.33,1.11,-0.57,1.74,-0.66],["z"]],w:16.366,h:7.893},"scripts.trill":{d:[["M",-0.51,-16.02],["c",0.12,-0.09,0.21,-0.18,0.21,-0.18],["l",-0.81,4.02],["l",-0.81,4.02],["c",0.03,0,0.51,-0.27,1.08,-0.6],["c",0.6,-0.3,1.14,-0.63,1.26,-0.66],["c",1.14,-0.54,2.31,-0.6,3.09,-0.18],["c",0.27,0.15,0.54,0.36,0.6,0.51],["l",0.06,0.12],["l",0.21,-0.21],["c",0.9,-0.81,2.22,-0.99,3.12,-0.42],["c",0.6,0.42,0.9,1.14,0.78,2.07],["c",-0.15,1.29,-1.05,2.31,-1.95,2.25],["c",-0.48,-0.03,-0.78,-0.3,-0.96,-0.81],["c",-0.09,-0.27,-0.09,-0.9,-0.03,-1.2],["c",0.21,-0.75,0.81,-1.23,1.59,-1.32],["l",0.24,-0.03],["l",-0.09,-0.12],["c",-0.51,-0.66,-1.62,-0.63,-2.31,0.03],["c",-0.39,0.42,-0.3,0.09,-1.23,4.77],["l",-0.81,4.14],["c",-0.03,0,-0.12,-0.03,-0.21,-0.09],["c",-0.33,-0.15,-0.54,-0.18,-0.99,-0.18],["c",-0.42,0,-0.66,0.03,-1.05,0.18],["c",-0.12,0.06,-0.21,0.09,-0.21,0.09],["c",0,-0.03,0.36,-1.86,0.81,-4.11],["c",0.9,-4.47,0.87,-4.26,0.69,-4.53],["c",-0.21,-0.36,-0.66,-0.51,-1.17,-0.36],["c",-0.15,0.06,-2.22,1.14,-2.58,1.38],["c",-0.12,0.09,-0.12,0.09,-0.21,0.6],["l",-0.09,0.51],["l",0.21,0.24],["c",0.63,0.75,1.02,1.47,1.2,2.19],["c",0.06,0.27,0.06,0.36,0.06,0.81],["c",0,0.42,0,0.54,-0.06,0.78],["c",-0.15,0.54,-0.33,0.93,-0.63,1.35],["c",-0.18,0.24,-0.57,0.63,-0.81,0.78],["c",-0.24,0.15,-0.63,0.36,-0.84,0.42],["c",-0.27,0.06,-0.66,0.06,-0.87,0.03],["c",-0.81,-0.18,-1.32,-1.05,-1.38,-2.46],["c",-0.03,-0.6,0.03,-0.99,0.33,-2.46],["c",0.21,-1.08,0.24,-1.32,0.21,-1.29],["c",-1.2,0.48,-2.4,0.75,-3.21,0.72],["c",-0.69,-0.06,-1.17,-0.3,-1.41,-0.72],["c",-0.39,-0.75,-0.12,-1.8,0.66,-2.46],["c",0.24,-0.18,0.69,-0.42,1.02,-0.51],["c",0.69,-0.18,1.53,-0.15,2.31,0.09],["c",0.3,0.09,0.75,0.3,0.99,0.45],["c",0.12,0.09,0.15,0.09,0.15,0.03],["c",0.03,-0.03,0.33,-1.59,0.72,-3.45],["c",0.36,-1.86,0.66,-3.42,0.69,-3.45],["c",0,-0.03,0.03,-0.03,0.21,0.03],["c",0.21,0.06,0.27,0.06,0.48,0.06],["c",0.42,-0.03,0.78,-0.18,1.26,-0.48],["c",0.15,-0.12,0.36,-0.27,0.48,-0.39],["z"],["m",-5.73,7.68],["c",-0.27,-0.03,-0.96,-0.06,-1.2,-0.03],["c",-0.81,0.12,-1.35,0.57,-1.5,1.2],["c",-0.18,0.66,0.12,1.14,0.75,1.29],["c",0.66,0.12,1.92,-0.12,3.18,-0.66],["l",0.33,-0.15],["l",0.09,-0.39],["c",0.06,-0.21,0.09,-0.42,0.09,-0.45],["c",0,-0.03,-0.45,-0.3,-0.75,-0.45],["c",-0.27,-0.15,-0.66,-0.27,-0.99,-0.36],["z"],["m",4.29,3.63],["c",-0.24,-0.39,-0.51,-0.75,-0.51,-0.69],["c",-0.06,0.12,-0.39,1.92,-0.45,2.28],["c",-0.09,0.54,-0.12,1.14,-0.06,1.38],["c",0.06,0.42,0.21,0.6,0.51,0.57],["c",0.39,-0.06,0.75,-0.48,0.93,-1.14],["c",0.09,-0.33,0.09,-1.05,-0,-1.38],["c",-0.09,-0.39,-0.24,-0.69,-0.42,-1.02],["z"]],w:17.963,h:16.49},"scripts.segno":{d:[["M",-3.72,-11.22],["c",0.78,-0.09,1.59,0.03,2.31,0.42],["c",1.2,0.6,2.01,1.71,2.31,3.09],["c",0.09,0.42,0.09,1.2,0.03,1.5],["c",-0.15,0.45,-0.39,0.81,-0.66,0.93],["c",-0.33,0.18,-0.84,0.21,-1.23,0.15],["c",-0.81,-0.18,-1.32,-0.93,-1.26,-1.89],["c",0.03,-0.36,0.09,-0.57,0.24,-0.9],["c",0.15,-0.33,0.45,-0.6,0.72,-0.75],["c",0.12,-0.06,0.18,-0.09,0.18,-0.12],["c",0,-0.03,-0.03,-0.15,-0.09,-0.24],["c",-0.18,-0.45,-0.54,-0.87,-0.96,-1.08],["c",-1.11,-0.57,-2.34,-0.18,-2.88,0.9],["c",-0.24,0.51,-0.33,1.11,-0.24,1.83],["c",0.27,1.92,1.5,3.54,3.93,5.13],["c",0.48,0.33,1.26,0.78,1.29,0.78],["c",0.03,0,1.35,-2.19,2.94,-4.89],["l",2.88,-4.89],["l",0.84,0],["l",0.87,0],["l",-0.03,0.06],["c",-0.15,0.21,-6.15,10.41,-6.15,10.44],["c",0,0,0.21,0.15,0.48,0.27],["c",2.61,1.47,4.35,3.03,5.13,4.65],["c",1.14,2.34,0.51,5.07,-1.44,6.39],["c",-0.66,0.42,-1.32,0.63,-2.13,0.69],["c",-2.01,0.09,-3.81,-1.41,-4.26,-3.54],["c",-0.09,-0.42,-0.09,-1.2,-0.03,-1.5],["c",0.15,-0.45,0.39,-0.81,0.66,-0.93],["c",0.33,-0.18,0.84,-0.21,1.23,-0.15],["c",0.81,0.18,1.32,0.93,1.26,1.89],["c",-0.03,0.36,-0.09,0.57,-0.24,0.9],["c",-0.15,0.33,-0.45,0.6,-0.72,0.75],["c",-0.12,0.06,-0.18,0.09,-0.18,0.12],["c",0,0.03,0.03,0.15,0.09,0.24],["c",0.18,0.45,0.54,0.87,0.96,1.08],["c",1.11,0.57,2.34,0.18,2.88,-0.9],["c",0.24,-0.51,0.33,-1.11,0.24,-1.83],["c",-0.27,-1.92,-1.5,-3.54,-3.93,-5.13],["c",-0.48,-0.33,-1.26,-0.78,-1.29,-0.78],["c",-0.03,0,-1.35,2.19,-2.91,4.89],["l",-2.88,4.89],["l",-0.87,0],["l",-0.87,0],["l",0.03,-0.06],["c",0.15,-0.21,6.15,-10.41,6.15,-10.44],["c",0,0,-0.21,-0.15,-0.48,-0.3],["c",-2.61,-1.44,-4.35,-3,-5.13,-4.62],["c",-0.9,-1.89,-0.72,-4.02,0.48,-5.52],["c",0.69,-0.84,1.68,-1.41,2.73,-1.53],["z"],["m",8.76,9.09],["c",0.03,-0.03,0.15,-0.03,0.27,-0.03],["c",0.33,0.03,0.57,0.18,0.72,0.48],["c",0.09,0.18,0.09,0.57,0,0.75],["c",-0.09,0.18,-0.21,0.3,-0.36,0.39],["c",-0.15,0.06,-0.21,0.06,-0.39,0.06],["c",-0.21,0,-0.27,0,-0.39,-0.06],["c",-0.3,-0.15,-0.48,-0.45,-0.48,-0.75],["c",0,-0.39,0.24,-0.72,0.63,-0.84],["z"],["m",-10.53,2.61],["c",0.03,-0.03,0.15,-0.03,0.27,-0.03],["c",0.33,0.03,0.57,0.18,0.72,0.48],["c",0.09,0.18,0.09,0.57,0,0.75],["c",-0.09,0.18,-0.21,0.3,-0.36,0.39],["c",-0.15,0.06,-0.21,0.06,-0.39,0.06],["c",-0.21,0,-0.27,0,-0.39,-0.06],["c",-0.3,-0.15,-0.48,-0.45,-0.48,-0.75],["c",0,-0.39,0.24,-0.72,0.63,-0.84],["z"]],w:15,h:22.504},"scripts.coda":{d:[["M",-0.21,-10.47],["c",0.18,-0.12,0.42,-0.06,0.54,0.12],["c",0.06,0.09,0.06,0.18,0.06,1.5],["l",0,1.38],["l",0.18,0],["c",0.39,0.06,0.96,0.24,1.38,0.48],["c",1.68,0.93,2.82,3.24,3.03,6.12],["c",0.03,0.24,0.03,0.45,0.03,0.45],["c",0,0.03,0.6,0.03,1.35,0.03],["c",1.5,0,1.47,0,1.59,0.18],["c",0.09,0.12,0.09,0.3,-0,0.42],["c",-0.12,0.18,-0.09,0.18,-1.59,0.18],["c",-0.75,0,-1.35,0,-1.35,0.03],["c",-0,0,-0,0.21,-0.03,0.42],["c",-0.24,3.15,-1.53,5.58,-3.45,6.36],["c",-0.27,0.12,-0.72,0.24,-0.96,0.27],["l",-0.18,-0],["l",-0,1.38],["c",-0,1.32,-0,1.41,-0.06,1.5],["c",-0.15,0.24,-0.51,0.24,-0.66,-0],["c",-0.06,-0.09,-0.06,-0.18,-0.06,-1.5],["l",-0,-1.38],["l",-0.18,-0],["c",-0.39,-0.06,-0.96,-0.24,-1.38,-0.48],["c",-1.68,-0.93,-2.82,-3.24,-3.03,-6.15],["c",-0.03,-0.21,-0.03,-0.42,-0.03,-0.42],["c",0,-0.03,-0.6,-0.03,-1.35,-0.03],["c",-1.5,-0,-1.47,-0,-1.59,-0.18],["c",-0.09,-0.12,-0.09,-0.3,0,-0.42],["c",0.12,-0.18,0.09,-0.18,1.59,-0.18],["c",0.75,-0,1.35,-0,1.35,-0.03],["c",0,-0,0,-0.21,0.03,-0.45],["c",0.24,-3.12,1.53,-5.55,3.45,-6.33],["c",0.27,-0.12,0.72,-0.24,0.96,-0.27],["l",0.18,-0],["l",0,-1.38],["c",0,-1.53,0,-1.5,0.18,-1.62],["z"],["m",-0.18,6.93],["c",0,-2.97,0,-3.15,-0.06,-3.15],["c",-0.09,0,-0.51,0.15,-0.66,0.21],["c",-0.87,0.51,-1.38,1.62,-1.56,3.51],["c",-0.06,0.54,-0.12,1.59,-0.12,2.16],["l",0,0.42],["l",1.2,0],["l",1.2,0],["l",0,-3.15],["z"],["m",1.17,-3.06],["c",-0.09,-0.03,-0.21,-0.06,-0.27,-0.09],["l",-0.12,0],["l",0,3.15],["l",0,3.15],["l",1.2,0],["l",1.2,0],["l",0,-0.81],["c",-0.06,-2.4,-0.33,-3.69,-0.93,-4.59],["c",-0.27,-0.39,-0.66,-0.69,-1.08,-0.81],["z"],["m",-1.17,10.14],["l",0,-3.15],["l",-1.2,-0],["l",-1.2,-0],["l",0,0.81],["c",0.03,0.96,0.06,1.47,0.15,2.13],["c",0.24,2.04,0.96,3.12,2.13,3.36],["l",0.12,-0],["l",0,-3.15],["z"],["m",3.18,-2.34],["l",0,-0.81],["l",-1.2,0],["l",-1.2,0],["l",0,3.15],["l",0,3.15],["l",0.12,0],["c",1.17,-0.24,1.89,-1.32,2.13,-3.36],["c",0.09,-0.66,0.12,-1.17,0.15,-2.13],["z"]],w:16.035,h:21.062},"scripts.comma":{d:[["M",1.14,-4.62],["c",0.3,-0.12,0.69,-0.03,0.93,0.15],["c",0.12,0.12,0.36,0.45,0.51,0.78],["c",0.9,1.77,0.54,4.05,-1.08,6.75],["c",-0.36,0.63,-0.87,1.38,-0.96,1.44],["c",-0.18,0.12,-0.42,0.06,-0.54,-0.12],["c",-0.09,-0.18,-0.09,-0.3,0.12,-0.6],["c",0.96,-1.44,1.44,-2.97,1.38,-4.35],["c",-0.06,-0.93,-0.3,-1.68,-0.78,-2.46],["c",-0.27,-0.39,-0.33,-0.63,-0.24,-0.96],["c",0.09,-0.27,0.36,-0.54,0.66,-0.63],["z"]],w:3.042,h:9.237},"scripts.roll":{d:[["M",1.95,-6],["c",0.21,-0.09,0.36,-0.09,0.57,0],["c",0.39,0.15,0.63,0.39,1.47,1.35],["c",0.66,0.75,0.78,0.87,1.08,1.05],["c",0.75,0.45,1.65,0.42,2.4,-0.06],["c",0.12,-0.09,0.27,-0.27,0.54,-0.6],["c",0.42,-0.54,0.51,-0.63,0.69,-0.63],["c",0.09,0,0.3,0.12,0.36,0.21],["c",0.09,0.12,0.12,0.3,0.03,0.42],["c",-0.06,0.12,-3.15,3.9,-3.3,4.08],["c",-0.06,0.06,-0.18,0.12,-0.27,0.18],["c",-0.27,0.12,-0.6,0.06,-0.99,-0.27],["c",-0.27,-0.21,-0.42,-0.39,-1.08,-1.14],["c",-0.63,-0.72,-0.81,-0.9,-1.17,-1.08],["c",-0.36,-0.18,-0.57,-0.21,-0.99,-0.21],["c",-0.39,0,-0.63,0.03,-0.93,0.18],["c",-0.36,0.15,-0.51,0.27,-0.9,0.81],["c",-0.24,0.27,-0.45,0.51,-0.48,0.54],["c",-0.12,0.09,-0.27,0.06,-0.39,0],["c",-0.24,-0.15,-0.33,-0.39,-0.21,-0.6],["c",0.09,-0.12,3.18,-3.87,3.33,-4.02],["c",0.06,-0.06,0.18,-0.15,0.24,-0.21],["z"]],w:10.817,h:6.125},"scripts.prall":{d:[["M",-4.38,-3.69],["c",0.06,-0.03,0.18,-0.06,0.24,-0.06],["c",0.3,0,0.27,-0.03,1.89,1.95],["l",1.53,1.83],["c",0.03,-0,0.57,-0.84,1.23,-1.83],["c",1.14,-1.68,1.23,-1.83,1.35,-1.89],["c",0.06,-0.03,0.18,-0.06,0.24,-0.06],["c",0.3,0,0.27,-0.03,1.89,1.95],["l",1.53,1.83],["l",0.48,-0.69],["c",0.51,-0.78,0.54,-0.84,0.69,-0.9],["c",0.42,-0.18,0.87,0.15,0.81,0.6],["c",-0.03,0.12,-0.3,0.51,-1.5,2.37],["c",-1.38,2.07,-1.5,2.22,-1.62,2.28],["c",-0.06,0.03,-0.18,0.06,-0.24,0.06],["c",-0.3,0,-0.27,0.03,-1.89,-1.95],["l",-1.53,-1.83],["c",-0.03,0,-0.57,0.84,-1.23,1.83],["c",-1.14,1.68,-1.23,1.83,-1.35,1.89],["c",-0.06,0.03,-0.18,0.06,-0.24,0.06],["c",-0.3,0,-0.27,0.03,-1.89,-1.95],["l",-1.53,-1.83],["l",-0.48,0.69],["c",-0.51,0.78,-0.54,0.84,-0.69,0.9],["c",-0.42,0.18,-0.87,-0.15,-0.81,-0.6],["c",0.03,-0.12,0.3,-0.51,1.5,-2.37],["c",1.38,-2.07,1.5,-2.22,1.62,-2.28],["z"]],w:15.011,h:7.5},"scripts.mordent":{d:[["M",-0.21,-4.95],["c",0.27,-0.15,0.63,0,0.75,0.27],["c",0.06,0.12,0.06,0.24,0.06,1.44],["l",0,1.29],["l",0.57,-0.84],["c",0.51,-0.75,0.57,-0.84,0.69,-0.9],["c",0.06,-0.03,0.18,-0.06,0.24,-0.06],["c",0.3,0,0.27,-0.03,1.89,1.95],["l",1.53,1.83],["l",0.48,-0.69],["c",0.51,-0.78,0.54,-0.84,0.69,-0.9],["c",0.42,-0.18,0.87,0.15,0.81,0.6],["c",-0.03,0.12,-0.3,0.51,-1.5,2.37],["c",-1.38,2.07,-1.5,2.22,-1.62,2.28],["c",-0.06,0.03,-0.18,0.06,-0.24,0.06],["c",-0.3,0,-0.27,0.03,-1.83,-1.89],["c",-0.81,-0.99,-1.5,-1.8,-1.53,-1.86],["c",-0.06,-0.03,-0.06,-0.03,-0.12,0.03],["c",-0.06,0.06,-0.06,0.15,-0.06,2.28],["c",-0,1.95,-0,2.25,-0.06,2.34],["c",-0.18,0.45,-0.81,0.48,-1.05,0.03],["c",-0.03,-0.06,-0.06,-0.24,-0.06,-1.41],["l",-0,-1.35],["l",-0.57,0.84],["c",-0.54,0.78,-0.6,0.87,-0.72,0.93],["c",-0.06,0.03,-0.18,0.06,-0.24,0.06],["c",-0.3,0,-0.27,0.03,-1.89,-1.95],["l",-1.53,-1.83],["l",-0.48,0.69],["c",-0.51,0.78,-0.54,0.84,-0.69,0.9],["c",-0.42,0.18,-0.87,-0.15,-0.81,-0.6],["c",0.03,-0.12,0.3,-0.51,1.5,-2.37],["c",1.38,-2.07,1.5,-2.22,1.62,-2.28],["c",0.06,-0.03,0.18,-0.06,0.24,-0.06],["c",0.3,0,0.27,-0.03,1.89,1.95],["l",1.53,1.83],["c",0.03,-0,0.06,-0.06,0.09,-0.09],["c",0.06,-0.12,0.06,-0.15,0.06,-2.28],["c",-0,-1.92,-0,-2.22,0.06,-2.31],["c",0.06,-0.15,0.15,-0.24,0.3,-0.3],["z"]],w:15.011,h:10.012},"flags.u8th":{d:[["M",-0.42,3.75],["l",0,-3.75],["l",0.21,0],["l",0.21,0],["l",0,0.18],["c",0,0.3,0.06,0.84,0.12,1.23],["c",0.24,1.53,0.9,3.12,2.13,5.16],["l",0.99,1.59],["c",0.87,1.44,1.38,2.34,1.77,3.09],["c",0.81,1.68,1.2,3.06,1.26,4.53],["c",0.03,1.53,-0.21,3.27,-0.75,5.01],["c",-0.21,0.69,-0.51,1.5,-0.6,1.59],["c",-0.09,0.12,-0.27,0.21,-0.42,0.21],["c",-0.15,0,-0.42,-0.12,-0.51,-0.21],["c",-0.15,-0.18,-0.18,-0.42,-0.09,-0.66],["c",0.15,-0.33,0.45,-1.2,0.57,-1.62],["c",0.42,-1.38,0.6,-2.58,0.6,-3.9],["c",0,-0.66,0,-0.81,-0.06,-1.11],["c",-0.39,-2.07,-1.8,-4.26,-4.59,-7.14],["l",-0.42,-0.45],["l",-0.21,0],["l",-0.21,0],["l",0,-3.75],["z"]],w:6.692,h:22.59},"flags.u16th":{d:[["M",-0.42,7.5],["l",0,-7.5],["l",0.21,0],["l",0.21,0],["l",0,0.39],["c",0.06,1.08,0.39,2.19,0.99,3.39],["c",0.45,0.9,0.87,1.59,1.95,3.12],["c",1.29,1.86,1.77,2.64,2.22,3.57],["c",0.45,0.93,0.72,1.8,0.87,2.64],["c",0.06,0.51,0.06,1.5,0,1.92],["c",-0.12,0.6,-0.3,1.2,-0.54,1.71],["l",-0.09,0.24],["l",0.18,0.45],["c",0.51,1.2,0.72,2.22,0.69,3.42],["c",-0.06,1.53,-0.39,3.03,-0.99,4.53],["c",-0.3,0.75,-0.36,0.81,-0.57,0.9],["c",-0.15,0.09,-0.33,0.06,-0.48,-0],["c",-0.18,-0.09,-0.27,-0.18,-0.33,-0.33],["c",-0.09,-0.18,-0.06,-0.3,0.12,-0.75],["c",0.66,-1.41,1.02,-2.88,1.08,-4.32],["c",0,-0.6,-0.03,-1.05,-0.18,-1.59],["c",-0.3,-1.2,-0.99,-2.4,-2.25,-3.87],["c",-0.42,-0.48,-1.53,-1.62,-2.19,-2.22],["l",-0.45,-0.42],["l",-0.03,1.11],["l",0,1.11],["l",-0.21,-0],["l",-0.21,-0],["l",0,-7.5],["z"],["m",1.65,0.09],["c",-0.3,-0.3,-0.69,-0.72,-0.9,-0.87],["l",-0.33,-0.33],["l",0,0.15],["c",0,0.3,0.06,0.81,0.15,1.26],["c",0.27,1.29,0.87,2.61,2.04,4.29],["c",0.15,0.24,0.6,0.87,0.96,1.38],["l",1.08,1.53],["l",0.42,0.63],["c",0.03,0,0.12,-0.36,0.21,-0.72],["c",0.06,-0.33,0.06,-1.2,0,-1.62],["c",-0.33,-1.71,-1.44,-3.48,-3.63,-5.7],["z"]],w:6.693,h:26.337},"flags.u32nd":{d:[["M",-0.42,11.247],["l",0,-11.25],["l",0.21,0],["l",0.21,0],["l",0,0.36],["c",0.09,1.68,0.69,3.27,2.07,5.46],["l",0.87,1.35],["c",1.02,1.62,1.47,2.37,1.86,3.18],["c",0.48,1.02,0.78,1.92,0.93,2.88],["c",0.06,0.48,0.06,1.5,0,1.89],["c",-0.09,0.42,-0.21,0.87,-0.36,1.26],["l",-0.12,0.3],["l",0.15,0.39],["c",0.69,1.56,0.84,2.88,0.54,4.38],["c",-0.09,0.45,-0.27,1.08,-0.45,1.47],["l",-0.12,0.24],["l",0.18,0.36],["c",0.33,0.72,0.57,1.56,0.69,2.34],["c",0.12,1.02,-0.06,2.52,-0.42,3.84],["c",-0.27,0.93,-0.75,2.13,-0.93,2.31],["c",-0.18,0.15,-0.45,0.18,-0.66,0.09],["c",-0.18,-0.09,-0.27,-0.18,-0.33,-0.33],["c",-0.09,-0.18,-0.06,-0.3,0.06,-0.6],["c",0.21,-0.36,0.42,-0.9,0.57,-1.38],["c",0.51,-1.41,0.69,-3.06,0.48,-4.08],["c",-0.15,-0.81,-0.57,-1.68,-1.2,-2.55],["c",-0.72,-0.99,-1.83,-2.13,-3.3,-3.33],["l",-0.48,-0.42],["l",-0.03,1.53],["l",0,1.56],["l",-0.21,0],["l",-0.21,0],["l",0,-11.25],["z"],["m",1.26,-3.96],["c",-0.27,-0.3,-0.54,-0.6,-0.66,-0.72],["l",-0.18,-0.21],["l",0,0.42],["c",0.06,0.87,0.24,1.74,0.66,2.67],["c",0.36,0.87,0.96,1.86,1.92,3.18],["c",0.21,0.33,0.63,0.87,0.87,1.23],["c",0.27,0.39,0.6,0.84,0.75,1.08],["l",0.27,0.39],["l",0.03,-0.12],["c",0.12,-0.45,0.15,-1.05,0.09,-1.59],["c",-0.27,-1.86,-1.38,-3.78,-3.75,-6.33],["z"],["m",-0.27,6.09],["c",-0.27,-0.21,-0.48,-0.42,-0.51,-0.45],["c",-0.06,-0.03,-0.06,-0.03,-0.06,0.21],["c",0,0.9,0.3,2.04,0.81,3.09],["c",0.48,1.02,0.96,1.77,2.37,3.63],["c",0.6,0.78,1.05,1.44,1.29,1.77],["c",0.06,0.12,0.15,0.21,0.15,0.18],["c",0.03,-0.03,0.18,-0.57,0.24,-0.87],["c",0.06,-0.45,0.06,-1.32,-0.03,-1.74],["c",-0.09,-0.48,-0.24,-0.9,-0.51,-1.44],["c",-0.66,-1.35,-1.83,-2.7,-3.75,-4.38],["z"]],w:6.697,h:32.145},"flags.u64th":{d:[["M",-0.42,15],["l",0,-15],["l",0.21,0],["l",0.21,0],["l",0,0.36],["c",0.06,1.2,0.39,2.37,1.02,3.66],["c",0.39,0.81,0.84,1.56,1.8,3.09],["c",0.81,1.26,1.05,1.68,1.35,2.22],["c",0.87,1.5,1.35,2.79,1.56,4.08],["c",0.06,0.54,0.06,1.56,-0.03,2.04],["c",-0.09,0.48,-0.21,0.99,-0.36,1.35],["l",-0.12,0.27],["l",0.12,0.27],["c",0.09,0.15,0.21,0.45,0.27,0.66],["c",0.69,1.89,0.63,3.66,-0.18,5.46],["l",-0.18,0.39],["l",0.15,0.33],["c",0.3,0.66,0.51,1.44,0.63,2.1],["c",0.06,0.48,0.06,1.35,0,1.71],["c",-0.15,0.57,-0.42,1.2,-0.78,1.68],["l",-0.21,0.27],["l",0.18,0.33],["c",0.57,1.05,0.93,2.13,1.02,3.18],["c",0.06,0.72,0,1.83,-0.21,2.79],["c",-0.18,1.02,-0.63,2.34,-1.02,3.09],["c",-0.15,0.33,-0.48,0.45,-0.78,0.3],["c",-0.18,-0.09,-0.27,-0.18,-0.33,-0.33],["c",-0.09,-0.18,-0.06,-0.3,0.03,-0.54],["c",0.75,-1.5,1.23,-3.45,1.17,-4.89],["c",-0.06,-1.02,-0.42,-2.01,-1.17,-3.15],["c",-0.48,-0.72,-1.02,-1.35,-1.89,-2.22],["c",-0.57,-0.57,-1.56,-1.5,-1.92,-1.77],["l",-0.12,-0.09],["l",0,1.68],["l",0,1.68],["l",-0.21,0],["l",-0.21,0],["l",0,-15],["z"],["m",0.93,-8.07],["c",-0.27,-0.3,-0.48,-0.54,-0.51,-0.54],["c",-0,0,-0,0.69,0.03,1.02],["c",0.15,1.47,0.75,2.94,2.04,4.83],["l",1.08,1.53],["c",0.39,0.57,0.84,1.2,0.99,1.44],["c",0.15,0.24,0.3,0.45,0.3,0.45],["c",-0,0,0.03,-0.09,0.06,-0.21],["c",0.36,-1.59,-0.15,-3.33,-1.47,-5.4],["c",-0.63,-0.93,-1.35,-1.83,-2.52,-3.12],["z"],["m",0.06,6.72],["c",-0.24,-0.21,-0.48,-0.42,-0.51,-0.45],["l",-0.06,-0.06],["l",0,0.33],["c",0,1.2,0.3,2.34,0.93,3.6],["c",0.45,0.9,0.96,1.68,2.25,3.51],["c",0.39,0.54,0.84,1.17,1.02,1.44],["c",0.21,0.33,0.33,0.51,0.33,0.48],["c",0.06,-0.09,0.21,-0.63,0.3,-0.99],["c",0.06,-0.33,0.06,-0.45,0.06,-0.96],["c",-0,-0.6,-0.03,-0.84,-0.18,-1.35],["c",-0.3,-1.08,-1.02,-2.28,-2.13,-3.57],["c",-0.39,-0.45,-1.44,-1.47,-2.01,-1.98],["z"],["m",0,6.72],["c",-0.24,-0.21,-0.48,-0.39,-0.51,-0.42],["l",-0.06,-0.06],["l",0,0.33],["c",0,1.41,0.45,2.82,1.38,4.35],["c",0.42,0.72,0.72,1.14,1.86,2.73],["c",0.36,0.45,0.75,0.99,0.87,1.2],["c",0.15,0.21,0.3,0.36,0.3,0.36],["c",0.06,0,0.3,-0.48,0.39,-0.75],["c",0.09,-0.36,0.12,-0.63,0.12,-1.05],["c",-0.06,-1.05,-0.45,-2.04,-1.2,-3.18],["c",-0.57,-0.87,-1.11,-1.53,-2.07,-2.49],["c",-0.36,-0.33,-0.84,-0.78,-1.08,-1.02],["z"]],w:6.682,h:39.694},"flags.d8th":{d:[["M",5.67,-21.63],["c",0.24,-0.12,0.54,-0.06,0.69,0.15],["c",0.06,0.06,0.21,0.36,0.39,0.66],["c",0.84,1.77,1.26,3.36,1.32,5.1],["c",0.03,1.29,-0.21,2.37,-0.81,3.63],["c",-0.6,1.23,-1.26,2.13,-3.21,4.38],["c",-1.35,1.53,-1.86,2.19,-2.4,2.97],["c",-0.63,0.93,-1.11,1.92,-1.38,2.79],["c",-0.15,0.54,-0.27,1.35,-0.27,1.8],["l",0,0.15],["l",-0.21,-0],["l",-0.21,-0],["l",0,-3.75],["l",0,-3.75],["l",0.21,0],["l",0.21,0],["l",0.48,-0.3],["c",1.83,-1.11,3.12,-2.1,4.17,-3.12],["c",0.78,-0.81,1.32,-1.53,1.71,-2.31],["c",0.45,-0.93,0.6,-1.74,0.51,-2.88],["c",-0.12,-1.56,-0.63,-3.18,-1.47,-4.68],["c",-0.12,-0.21,-0.15,-0.33,-0.06,-0.51],["c",0.06,-0.15,0.15,-0.24,0.33,-0.33],["z"]],w:8.492,h:21.691},"flags.ugrace":{d:[["M",6.03,6.93],["c",0.15,-0.09,0.33,-0.06,0.51,0],["c",0.15,0.09,0.21,0.15,0.3,0.33],["c",0.09,0.18,0.06,0.39,-0.03,0.54],["c",-0.06,0.15,-10.89,8.88,-11.07,8.97],["c",-0.15,0.09,-0.33,0.06,-0.48,0],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["c",-0.09,-0.18,-0.06,-0.39,0.03,-0.54],["c",0.06,-0.15,10.89,-8.88,11.07,-8.97],["z"]],w:12.019,h:9.954},"flags.dgrace":{d:[["M",-6.06,-15.93],["c",0.18,-0.09,0.33,-0.12,0.48,-0.06],["c",0.18,0.09,14.01,8.04,14.1,8.1],["c",0.12,0.12,0.18,0.33,0.18,0.51],["c",-0.03,0.21,-0.15,0.39,-0.36,0.48],["c",-0.18,0.09,-0.33,0.12,-0.48,0.06],["c",-0.18,-0.09,-14.01,-8.04,-14.1,-8.1],["c",-0.12,-0.12,-0.18,-0.33,-0.18,-0.51],["c",0.03,-0.21,0.15,-0.39,0.36,-0.48],["z"]],w:15.12,h:9.212},"flags.d16th":{d:[["M",6.84,-22.53],["c",0.27,-0.12,0.57,-0.06,0.72,0.15],["c",0.15,0.15,0.33,0.87,0.45,1.56],["c",0.06,0.33,0.06,1.35,0,1.65],["c",-0.06,0.33,-0.15,0.78,-0.27,1.11],["c",-0.12,0.33,-0.45,0.96,-0.66,1.32],["l",-0.18,0.27],["l",0.09,0.18],["c",0.48,1.02,0.72,2.25,0.69,3.3],["c",-0.06,1.23,-0.42,2.28,-1.26,3.45],["c",-0.57,0.87,-0.99,1.32,-3,3.39],["c",-1.56,1.56,-2.22,2.4,-2.76,3.45],["c",-0.42,0.84,-0.66,1.8,-0.66,2.55],["l",0,0.15],["l",-0.21,-0],["l",-0.21,-0],["l",0,-7.5],["l",0,-7.5],["l",0.21,-0],["l",0.21,-0],["l",0,1.14],["l",0,1.11],["l",0.27,-0.15],["c",1.11,-0.57,1.77,-0.99,2.52,-1.47],["c",2.37,-1.56,3.69,-3.15,4.05,-4.83],["c",0.03,-0.18,0.03,-0.39,0.03,-0.78],["c",0,-0.6,-0.03,-0.93,-0.24,-1.5],["c",-0.06,-0.18,-0.12,-0.39,-0.15,-0.45],["c",-0.03,-0.24,0.12,-0.48,0.36,-0.6],["z"],["m",-0.63,7.5],["c",-0.06,-0.18,-0.15,-0.36,-0.15,-0.36],["c",-0.03,0,-0.03,0.03,-0.06,0.06],["c",-0.06,0.12,-0.96,1.02,-1.95,1.98],["c",-0.63,0.57,-1.26,1.17,-1.44,1.35],["c",-1.53,1.62,-2.28,2.85,-2.55,4.32],["c",-0.03,0.18,-0.03,0.54,-0.06,0.99],["l",0,0.69],["l",0.18,-0.09],["c",0.93,-0.54,2.1,-1.29,2.82,-1.83],["c",0.69,-0.51,1.02,-0.81,1.53,-1.29],["c",1.86,-1.89,2.37,-3.66,1.68,-5.82],["z"]],w:8.475,h:22.591},"flags.d32nd":{d:[["M",6.794,-29.13],["c",0.27,-0.12,0.57,-0.06,0.72,0.15],["c",0.12,0.12,0.27,0.63,0.36,1.11],["c",0.33,1.59,0.06,3.06,-0.81,4.47],["l",-0.18,0.27],["l",0.09,0.15],["c",0.12,0.24,0.33,0.69,0.45,1.05],["c",0.63,1.83,0.45,3.57,-0.57,5.22],["l",-0.18,0.3],["l",0.15,0.27],["c",0.42,0.87,0.6,1.71,0.57,2.61],["c",-0.06,1.29,-0.48,2.46,-1.35,3.78],["c",-0.54,0.81,-0.93,1.29,-2.46,3],["c",-0.51,0.54,-1.05,1.17,-1.26,1.41],["c",-1.56,1.86,-2.25,3.36,-2.37,5.01],["l",0,0.33],["l",-0.21,-0],["l",-0.21,-0],["l",0,-11.25],["l",0,-11.25],["l",0.21,0],["l",0.21,0],["l",0,1.35],["l",0.03,1.35],["l",0.78,-0.39],["c",1.38,-0.69,2.34,-1.26,3.24,-1.92],["c",1.38,-1.02,2.28,-2.13,2.64,-3.21],["c",0.15,-0.48,0.18,-0.72,0.18,-1.29],["c",0,-0.57,-0.06,-0.9,-0.24,-1.47],["c",-0.06,-0.18,-0.12,-0.39,-0.15,-0.45],["c",-0.03,-0.24,0.12,-0.48,0.36,-0.6],["z"],["m",-0.63,7.2],["c",-0.09,-0.18,-0.12,-0.21,-0.12,-0.15],["c",-0.03,0.09,-1.02,1.08,-2.04,2.04],["c",-1.17,1.08,-1.65,1.56,-2.07,2.04],["c",-0.84,0.96,-1.38,1.86,-1.68,2.76],["c",-0.21,0.57,-0.27,0.99,-0.3,1.65],["l",0,0.54],["l",0.66,-0.33],["c",3.57,-1.86,5.49,-3.69,5.94,-5.7],["c",0.06,-0.39,0.06,-1.2,-0.03,-1.65],["c",-0.06,-0.39,-0.24,-0.9,-0.36,-1.2],["z"],["m",-0.06,7.2],["c",-0.06,-0.15,-0.12,-0.33,-0.15,-0.45],["l",-0.06,-0.18],["l",-0.18,0.21],["l",-1.83,1.83],["c",-0.87,0.9,-1.77,1.8,-1.95,2.01],["c",-1.08,1.29,-1.62,2.31,-1.89,3.51],["c",-0.06,0.3,-0.06,0.51,-0.09,0.93],["l",0,0.57],["l",0.09,-0.06],["c",0.75,-0.45,1.89,-1.26,2.52,-1.74],["c",0.81,-0.66,1.74,-1.53,2.22,-2.16],["c",1.26,-1.53,1.68,-3.06,1.32,-4.47],["z"]],w:8.475,h:29.191},"flags.d64th":{d:[["M",7.08,-32.88],["c",0.3,-0.12,0.66,-0.03,0.78,0.24],["c",0.18,0.33,0.27,2.1,0.15,2.64],["c",-0.09,0.39,-0.21,0.78,-0.39,1.08],["l",-0.15,0.3],["l",0.09,0.27],["c",0.03,0.12,0.09,0.45,0.12,0.69],["c",0.27,1.44,0.18,2.55,-0.3,3.6],["l",-0.12,0.33],["l",0.06,0.42],["c",0.27,1.35,0.33,2.82,0.21,3.63],["c",-0.12,0.6,-0.3,1.23,-0.57,1.8],["l",-0.15,0.27],["l",0.03,0.42],["c",0.06,1.02,0.06,2.7,0.03,3.06],["c",-0.15,1.47,-0.66,2.76,-1.74,4.41],["c",-0.45,0.69,-0.75,1.11,-1.74,2.37],["c",-1.05,1.38,-1.5,1.98,-1.95,2.73],["c",-0.93,1.5,-1.38,2.82,-1.44,4.2],["l",0,0.42],["l",-0.21,-0],["l",-0.21,-0],["l",0,-15],["l",0,-15],["l",0.21,-0],["l",0.21,-0],["l",0,1.86],["l",0,1.89],["c",0,-0,0.21,-0.03,0.45,-0.09],["c",2.22,-0.39,4.08,-1.11,5.19,-2.01],["c",0.63,-0.54,1.02,-1.14,1.2,-1.8],["c",0.06,-0.3,0.06,-1.14,-0.03,-1.65],["c",-0.03,-0.18,-0.06,-0.39,-0.09,-0.48],["c",-0.03,-0.24,0.12,-0.48,0.36,-0.6],["z"],["m",-0.45,6.15],["c",-0.03,-0.18,-0.06,-0.42,-0.06,-0.54],["l",-0.03,-0.18],["l",-0.33,0.3],["c",-0.42,0.36,-0.87,0.72,-1.68,1.29],["c",-1.98,1.38,-2.25,1.59,-2.85,2.16],["c",-0.75,0.69,-1.23,1.44,-1.47,2.19],["c",-0.15,0.45,-0.18,0.63,-0.21,1.35],["l",0,0.66],["l",0.39,-0.18],["c",1.83,-0.9,3.45,-1.95,4.47,-2.91],["c",0.93,-0.9,1.53,-1.83,1.74,-2.82],["c",0.06,-0.33,0.06,-0.87,0.03,-1.32],["z"],["m",-0.27,4.86],["c",-0.03,-0.21,-0.06,-0.36,-0.06,-0.36],["c",0,-0.03,-0.12,0.09,-0.24,0.24],["c",-0.39,0.48,-0.99,1.08,-2.16,2.19],["c",-1.47,1.38,-1.92,1.83,-2.46,2.49],["c",-0.66,0.87,-1.08,1.74,-1.29,2.58],["c",-0.09,0.42,-0.15,0.87,-0.15,1.44],["l",0,0.54],["l",0.48,-0.33],["c",1.5,-1.02,2.58,-1.89,3.51,-2.82],["c",1.47,-1.47,2.25,-2.85,2.4,-4.26],["c",0.03,-0.39,0.03,-1.17,-0.03,-1.71],["z"],["m",-0.66,7.68],["c",0.03,-0.15,0.03,-0.6,0.03,-0.99],["l",0,-0.72],["l",-0.27,0.33],["l",-1.74,1.98],["c",-1.77,1.92,-2.43,2.76,-2.97,3.9],["c",-0.51,1.02,-0.72,1.77,-0.75,2.91],["c",0,0.63,0,0.63,0.06,0.6],["c",0.03,-0.03,0.3,-0.27,0.63,-0.54],["c",0.66,-0.6,1.86,-1.8,2.31,-2.31],["c",1.65,-1.89,2.52,-3.54,2.7,-5.16],["z"]],w:8.485,h:32.932},"clefs.C":{d:[["M",0.06,-14.94],["l",0.09,-0.06],["l",1.92,0],["l",1.92,0],["l",0.09,0.06],["l",0.06,0.09],["l",0,14.85],["l",0,14.82],["l",-0.06,0.09],["l",-0.09,0.06],["l",-1.92,0],["l",-1.92,0],["l",-0.09,-0.06],["l",-0.06,-0.09],["l",0,-14.82],["l",0,-14.85],["z"],["m",5.37,0],["c",0.09,-0.06,0.09,-0.06,0.57,-0.06],["c",0.45,0,0.45,0,0.54,0.06],["l",0.06,0.09],["l",0,7.14],["l",0,7.11],["l",0.09,-0.06],["c",0.18,-0.18,0.72,-0.84,0.96,-1.2],["c",0.3,-0.45,0.66,-1.17,0.84,-1.65],["c",0.36,-0.9,0.57,-1.83,0.6,-2.79],["c",0.03,-0.48,0.03,-0.54,0.09,-0.63],["c",0.12,-0.18,0.36,-0.21,0.54,-0.12],["c",0.18,0.09,0.21,0.15,0.24,0.66],["c",0.06,0.87,0.21,1.56,0.57,2.22],["c",0.51,1.02,1.26,1.68,2.22,1.92],["c",0.21,0.06,0.33,0.06,0.78,0.06],["c",0.45,-0,0.57,-0,0.84,-0.06],["c",0.45,-0.12,0.81,-0.33,1.08,-0.6],["c",0.57,-0.57,0.87,-1.41,0.99,-2.88],["c",0.06,-0.54,0.06,-3,0,-3.57],["c",-0.21,-2.58,-0.84,-3.87,-2.16,-4.5],["c",-0.48,-0.21,-1.17,-0.36,-1.77,-0.36],["c",-0.69,0,-1.29,0.27,-1.5,0.72],["c",-0.06,0.15,-0.06,0.21,-0.06,0.42],["c",0,0.24,0,0.3,0.06,0.45],["c",0.12,0.24,0.24,0.39,0.63,0.66],["c",0.42,0.3,0.57,0.48,0.69,0.72],["c",0.06,0.15,0.06,0.21,0.06,0.48],["c",0,0.39,-0.03,0.63,-0.21,0.96],["c",-0.3,0.6,-0.87,1.08,-1.5,1.26],["c",-0.27,0.06,-0.87,0.06,-1.14,0],["c",-0.78,-0.24,-1.44,-0.87,-1.65,-1.68],["c",-0.12,-0.42,-0.09,-1.17,0.09,-1.71],["c",0.51,-1.65,1.98,-2.82,3.81,-3.09],["c",0.84,-0.09,2.46,0.03,3.51,0.27],["c",2.22,0.57,3.69,1.8,4.44,3.75],["c",0.36,0.93,0.57,2.13,0.57,3.36],["c",-0,1.44,-0.48,2.73,-1.38,3.81],["c",-1.26,1.5,-3.27,2.43,-5.28,2.43],["c",-0.48,-0,-0.51,-0,-0.75,-0.09],["c",-0.15,-0.03,-0.48,-0.21,-0.78,-0.36],["c",-0.69,-0.36,-0.87,-0.42,-1.26,-0.42],["c",-0.27,-0,-0.3,-0,-0.51,0.09],["c",-0.57,0.3,-0.81,0.9,-0.81,2.1],["c",-0,1.23,0.24,1.83,0.81,2.13],["c",0.21,0.09,0.24,0.09,0.51,0.09],["c",0.39,-0,0.57,-0.06,1.26,-0.42],["c",0.3,-0.15,0.63,-0.33,0.78,-0.36],["c",0.24,-0.09,0.27,-0.09,0.75,-0.09],["c",2.01,-0,4.02,0.93,5.28,2.4],["c",0.9,1.11,1.38,2.4,1.38,3.84],["c",-0,1.5,-0.3,2.88,-0.84,3.96],["c",-0.78,1.59,-2.19,2.64,-4.17,3.15],["c",-1.05,0.24,-2.67,0.36,-3.51,0.27],["c",-1.83,-0.27,-3.3,-1.44,-3.81,-3.09],["c",-0.18,-0.54,-0.21,-1.29,-0.09,-1.74],["c",0.15,-0.6,0.63,-1.2,1.23,-1.47],["c",0.36,-0.18,0.57,-0.21,0.99,-0.21],["c",0.42,0,0.63,0.03,1.02,0.21],["c",0.42,0.21,0.84,0.63,1.05,1.05],["c",0.18,0.36,0.21,0.6,0.21,0.96],["c",-0,0.3,-0,0.36,-0.06,0.51],["c",-0.12,0.24,-0.27,0.42,-0.69,0.72],["c",-0.57,0.42,-0.69,0.63,-0.69,1.08],["c",-0,0.24,-0,0.3,0.06,0.45],["c",0.12,0.21,0.3,0.39,0.57,0.54],["c",0.42,0.18,0.87,0.21,1.53,0.15],["c",1.08,-0.15,1.8,-0.57,2.34,-1.32],["c",0.54,-0.75,0.84,-1.83,0.99,-3.51],["c",0.06,-0.57,0.06,-3.03,-0,-3.57],["c",-0.12,-1.47,-0.42,-2.31,-0.99,-2.88],["c",-0.27,-0.27,-0.63,-0.48,-1.08,-0.6],["c",-0.27,-0.06,-0.39,-0.06,-0.84,-0.06],["c",-0.45,0,-0.57,0,-0.78,0.06],["c",-1.14,0.27,-2.01,1.17,-2.46,2.49],["c",-0.21,0.57,-0.3,0.99,-0.33,1.65],["c",-0.03,0.51,-0.06,0.57,-0.24,0.66],["c",-0.12,0.06,-0.27,0.06,-0.39,0],["c",-0.21,-0.09,-0.21,-0.15,-0.24,-0.75],["c",-0.09,-1.92,-0.78,-3.72,-2.01,-5.19],["c",-0.18,-0.21,-0.36,-0.42,-0.39,-0.45],["l",-0.09,-0.06],["l",-0,7.11],["l",-0,7.14],["l",-0.06,0.09],["c",-0.09,0.06,-0.09,0.06,-0.54,0.06],["c",-0.48,0,-0.48,0,-0.57,-0.06],["l",-0.06,-0.09],["l",-0,-14.82],["l",-0,-14.85],["z"]],w:20.31,h:29.97},"clefs.F":{d:[["M",6.3,-7.8],["c",0.36,-0.03,1.65,0,2.13,0.03],["c",3.6,0.42,6.03,2.1,6.93,4.86],["c",0.27,0.84,0.36,1.5,0.36,2.58],["c",0,0.9,-0.03,1.35,-0.18,2.16],["c",-0.78,3.78,-3.54,7.08,-8.37,9.96],["c",-1.74,1.05,-3.87,2.13,-6.18,3.12],["c",-0.39,0.18,-0.75,0.33,-0.81,0.36],["c",-0.06,0.03,-0.15,0.06,-0.18,0.06],["c",-0.15,0,-0.33,-0.18,-0.33,-0.33],["c",0,-0.15,0.06,-0.21,0.51,-0.48],["c",3,-1.77,5.13,-3.21,6.84,-4.74],["c",0.51,-0.45,1.59,-1.5,1.95,-1.95],["c",1.89,-2.19,2.88,-4.32,3.15,-6.78],["c",0.06,-0.42,0.06,-1.77,0,-2.19],["c",-0.24,-2.01,-0.93,-3.63,-2.04,-4.71],["c",-0.63,-0.63,-1.29,-1.02,-2.07,-1.2],["c",-1.62,-0.39,-3.36,0.15,-4.56,1.44],["c",-0.54,0.6,-1.05,1.47,-1.32,2.22],["l",-0.09,0.21],["l",0.24,-0.12],["c",0.39,-0.21,0.63,-0.24,1.11,-0.24],["c",0.3,0,0.45,0,0.66,0.06],["c",1.92,0.48,2.85,2.55,1.95,4.38],["c",-0.45,0.99,-1.41,1.62,-2.46,1.71],["c",-1.47,0.09,-2.91,-0.87,-3.39,-2.25],["c",-0.18,-0.57,-0.21,-1.32,-0.03,-2.28],["c",0.39,-2.25,1.83,-4.2,3.81,-5.19],["c",0.69,-0.36,1.59,-0.6,2.37,-0.69],["z"],["m",11.58,2.52],["c",0.84,-0.21,1.71,0.3,1.89,1.14],["c",0.3,1.17,-0.72,2.19,-1.89,1.89],["c",-0.99,-0.21,-1.5,-1.32,-1.02,-2.25],["c",0.18,-0.39,0.6,-0.69,1.02,-0.78],["z"],["m",0,7.5],["c",0.84,-0.21,1.71,0.3,1.89,1.14],["c",0.21,0.87,-0.3,1.71,-1.14,1.89],["c",-0.87,0.21,-1.71,-0.3,-1.89,-1.14],["c",-0.21,-0.84,0.3,-1.71,1.14,-1.89],["z"]],w:20.153,h:23.142},"clefs.G":{d:[["M",9.69,-37.41],["c",0.09,-0.09,0.24,-0.06,0.36,0],["c",0.12,0.09,0.57,0.6,0.96,1.11],["c",1.77,2.34,3.21,5.85,3.57,8.73],["c",0.21,1.56,0.03,3.27,-0.45,4.86],["c",-0.69,2.31,-1.92,4.47,-4.23,7.44],["c",-0.3,0.39,-0.57,0.72,-0.6,0.75],["c",-0.03,0.06,0,0.15,0.18,0.78],["c",0.54,1.68,1.38,4.44,1.68,5.49],["l",0.09,0.42],["l",0.39,-0],["c",1.47,0.09,2.76,0.51,3.96,1.29],["c",1.83,1.23,3.06,3.21,3.39,5.52],["c",0.09,0.45,0.12,1.29,0.06,1.74],["c",-0.09,1.02,-0.33,1.83,-0.75,2.73],["c",-0.84,1.71,-2.28,3.06,-4.02,3.72],["l",-0.33,0.12],["l",0.03,1.26],["c",0,1.74,-0.06,3.63,-0.21,4.62],["c",-0.45,3.06,-2.19,5.49,-4.47,6.21],["c",-0.57,0.18,-0.9,0.21,-1.59,0.21],["c",-0.69,-0,-1.02,-0.03,-1.65,-0.21],["c",-1.14,-0.27,-2.13,-0.84,-2.94,-1.65],["c",-0.99,-0.99,-1.56,-2.16,-1.71,-3.54],["c",-0.09,-0.81,0.06,-1.53,0.45,-2.13],["c",0.63,-0.99,1.83,-1.56,3,-1.53],["c",1.5,0.09,2.64,1.32,2.73,2.94],["c",0.06,1.47,-0.93,2.7,-2.37,2.97],["c",-0.45,0.06,-0.84,0.03,-1.29,-0.09],["l",-0.21,-0.09],["l",0.09,0.12],["c",0.39,0.54,0.78,0.93,1.32,1.26],["c",1.35,0.87,3.06,1.02,4.35,0.36],["c",1.44,-0.72,2.52,-2.28,2.97,-4.35],["c",0.15,-0.66,0.24,-1.5,0.3,-3.03],["c",0.03,-0.84,0.03,-2.94,-0,-3],["c",-0.03,-0,-0.18,-0,-0.36,0.03],["c",-0.66,0.12,-0.99,0.12,-1.83,0.12],["c",-1.05,-0,-1.71,-0.06,-2.61,-0.3],["c",-4.02,-0.99,-7.11,-4.35,-7.8,-8.46],["c",-0.12,-0.66,-0.12,-0.99,-0.12,-1.83],["c",-0,-0.84,-0,-1.14,0.15,-1.92],["c",0.36,-2.28,1.41,-4.62,3.3,-7.29],["l",2.79,-3.6],["c",0.54,-0.66,0.96,-1.2,0.96,-1.23],["c",-0,-0.03,-0.09,-0.33,-0.18,-0.69],["c",-0.96,-3.21,-1.41,-5.28,-1.59,-7.68],["c",-0.12,-1.38,-0.15,-3.09,-0.06,-3.96],["c",0.33,-2.67,1.38,-5.07,3.12,-7.08],["c",0.36,-0.42,0.99,-1.05,1.17,-1.14],["z"],["m",2.01,4.71],["c",-0.15,-0.3,-0.3,-0.54,-0.3,-0.54],["c",-0.03,0,-0.18,0.09,-0.3,0.21],["c",-2.4,1.74,-3.87,4.2,-4.26,7.11],["c",-0.06,0.54,-0.06,1.41,-0.03,1.89],["c",0.09,1.29,0.48,3.12,1.08,5.22],["c",0.15,0.42,0.24,0.78,0.24,0.81],["c",0,0.03,0.84,-1.11,1.23,-1.68],["c",1.89,-2.73,2.88,-5.07,3.15,-7.53],["c",0.09,-0.57,0.12,-1.74,0.06,-2.37],["c",-0.09,-1.23,-0.27,-1.92,-0.87,-3.12],["z"],["m",-2.94,20.7],["c",-0.21,-0.72,-0.39,-1.32,-0.42,-1.32],["c",0,0,-1.2,1.47,-1.86,2.37],["c",-2.79,3.63,-4.02,6.3,-4.35,9.3],["c",-0.03,0.21,-0.03,0.69,-0.03,1.08],["c",0,0.69,0,0.75,0.06,1.11],["c",0.12,0.54,0.27,0.99,0.51,1.47],["c",0.69,1.38,1.83,2.55,3.42,3.42],["c",0.96,0.54,2.07,0.9,3.21,1.08],["c",0.78,0.12,2.04,0.12,2.94,-0.03],["c",0.51,-0.06,0.45,-0.03,0.42,-0.3],["c",-0.24,-3.33,-0.72,-6.33,-1.62,-10.08],["c",-0.09,-0.39,-0.18,-0.75,-0.18,-0.78],["c",-0.03,-0.03,-0.42,-0,-0.81,0.09],["c",-0.9,0.18,-1.65,0.57,-2.22,1.14],["c",-0.72,0.72,-1.08,1.65,-1.05,2.64],["c",0.06,0.96,0.48,1.83,1.23,2.58],["c",0.36,0.36,0.72,0.63,1.17,0.9],["c",0.33,0.18,0.36,0.21,0.42,0.33],["c",0.18,0.42,-0.18,0.9,-0.6,0.87],["c",-0.18,-0.03,-0.84,-0.36,-1.26,-0.63],["c",-0.78,-0.51,-1.38,-1.11,-1.86,-1.83],["c",-1.77,-2.7,-0.99,-6.42,1.71,-8.19],["c",0.3,-0.21,0.81,-0.48,1.17,-0.63],["c",0.3,-0.09,1.02,-0.3,1.14,-0.3],["c",0.06,-0,0.09,-0,0.09,-0.03],["c",0.03,-0.03,-0.51,-1.92,-1.23,-4.26],["z"],["m",3.78,7.41],["c",-0.18,-0.03,-0.36,-0.06,-0.39,-0.06],["c",-0.03,0,0,0.21,0.18,1.02],["c",0.75,3.18,1.26,6.3,1.5,9.09],["c",0.06,0.72,0,0.69,0.51,0.42],["c",0.78,-0.36,1.44,-0.96,1.98,-1.77],["c",1.08,-1.62,1.2,-3.69,0.3,-5.55],["c",-0.81,-1.62,-2.31,-2.79,-4.08,-3.15],["z"]],w:19.051,h:57.057},"clefs.perc":{d:[["M",5.07,-7.44],["l",0.09,-0.06],["l",1.53,0],["l",1.53,0],["l",0.09,0.06],["l",0.06,0.09],["l",0,7.35],["l",0,7.32],["l",-0.06,0.09],["l",-0.09,0.06],["l",-1.53,-0],["l",-1.53,-0],["l",-0.09,-0.06],["l",-0.06,-0.09],["l",0,-7.32],["l",0,-7.35],["z"],["m",6.63,0],["l",0.09,-0.06],["l",1.53,0],["l",1.53,0],["l",0.09,0.06],["l",0.06,0.09],["l",0,7.35],["l",0,7.32],["l",-0.06,0.09],["l",-0.09,0.06],["l",-1.53,-0],["l",-1.53,-0],["l",-0.09,-0.06],["l",-0.06,-0.09],["l",0,-7.32],["l",0,-7.35],["z"]],w:9.99,h:14.97},"timesig.common":{d:[["M",6.66,-7.826],["c",0.72,-0.06,1.41,-0.03,1.98,0.09],["c",1.2,0.27,2.34,0.96,3.09,1.92],["c",0.63,0.81,1.08,1.86,1.14,2.73],["c",0.06,1.02,-0.51,1.92,-1.44,2.22],["c",-0.24,0.09,-0.3,0.09,-0.63,0.09],["c",-0.33,-0,-0.42,-0,-0.63,-0.06],["c",-0.66,-0.24,-1.14,-0.63,-1.41,-1.2],["c",-0.15,-0.3,-0.21,-0.51,-0.24,-0.9],["c",-0.06,-1.08,0.57,-2.04,1.56,-2.37],["c",0.18,-0.06,0.27,-0.06,0.63,-0.06],["l",0.45,0],["c",0.06,0.03,0.09,0.03,0.09,0],["c",0,0,-0.09,-0.12,-0.24,-0.27],["c",-1.02,-1.11,-2.55,-1.68,-4.08,-1.5],["c",-1.29,0.15,-2.04,0.69,-2.4,1.74],["c",-0.36,0.93,-0.42,1.89,-0.42,5.37],["c",0,2.97,0.06,3.96,0.24,4.77],["c",0.24,1.08,0.63,1.68,1.41,2.07],["c",0.81,0.39,2.16,0.45,3.18,0.09],["c",1.29,-0.45,2.37,-1.53,3.03,-2.97],["c",0.15,-0.33,0.33,-0.87,0.39,-1.17],["c",0.09,-0.24,0.15,-0.36,0.3,-0.39],["c",0.21,-0.03,0.42,0.15,0.39,0.36],["c",-0.06,0.39,-0.42,1.38,-0.69,1.89],["c",-0.96,1.8,-2.49,2.94,-4.23,3.18],["c",-0.99,0.12,-2.58,-0.06,-3.63,-0.45],["c",-0.96,-0.36,-1.71,-0.84,-2.4,-1.5],["c",-1.11,-1.11,-1.8,-2.61,-2.04,-4.56],["c",-0.06,-0.6,-0.06,-2.01,0,-2.61],["c",0.24,-1.95,0.9,-3.45,2.01,-4.56],["c",0.69,-0.66,1.44,-1.11,2.37,-1.47],["c",0.63,-0.24,1.47,-0.42,2.22,-0.48],["z"]],w:13.038,h:15.697},"timesig.cut":{d:[["M",6.24,-10.44],["c",0.09,-0.06,0.09,-0.06,0.48,-0.06],["c",0.36,0,0.36,0,0.45,0.06],["l",0.06,0.09],["l",0,1.23],["l",0,1.26],["l",0.27,0],["c",1.26,0,2.49,0.45,3.48,1.29],["c",1.05,0.87,1.8,2.28,1.89,3.48],["c",0.06,1.02,-0.51,1.92,-1.44,2.22],["c",-0.24,0.09,-0.3,0.09,-0.63,0.09],["c",-0.33,-0,-0.42,-0,-0.63,-0.06],["c",-0.66,-0.24,-1.14,-0.63,-1.41,-1.2],["c",-0.15,-0.3,-0.21,-0.51,-0.24,-0.9],["c",-0.06,-1.08,0.57,-2.04,1.56,-2.37],["c",0.18,-0.06,0.27,-0.06,0.63,-0.06],["l",0.45,-0],["c",0.06,0.03,0.09,0.03,0.09,-0],["c",0,-0.03,-0.45,-0.51,-0.66,-0.69],["c",-0.87,-0.69,-1.83,-1.05,-2.94,-1.11],["l",-0.42,0],["l",0,7.17],["l",0,7.14],["l",0.42,0],["c",0.69,-0.03,1.23,-0.18,1.86,-0.51],["c",1.05,-0.51,1.89,-1.47,2.46,-2.7],["c",0.15,-0.33,0.33,-0.87,0.39,-1.17],["c",0.09,-0.24,0.15,-0.36,0.3,-0.39],["c",0.21,-0.03,0.42,0.15,0.39,0.36],["c",-0.03,0.24,-0.21,0.78,-0.39,1.2],["c",-0.96,2.37,-2.94,3.9,-5.13,3.9],["l",-0.3,0],["l",0,1.26],["l",0,1.23],["l",-0.06,0.09],["c",-0.09,0.06,-0.09,0.06,-0.45,0.06],["c",-0.39,0,-0.39,0,-0.48,-0.06],["l",-0.06,-0.09],["l",0,-1.29],["l",0,-1.29],["l",-0.21,-0.03],["c",-1.23,-0.21,-2.31,-0.63,-3.21,-1.29],["c",-0.15,-0.09,-0.45,-0.36,-0.66,-0.57],["c",-1.11,-1.11,-1.8,-2.61,-2.04,-4.56],["c",-0.06,-0.6,-0.06,-2.01,0,-2.61],["c",0.24,-1.95,0.93,-3.45,2.04,-4.59],["c",0.42,-0.39,0.78,-0.66,1.26,-0.93],["c",0.75,-0.45,1.65,-0.75,2.61,-0.9],["l",0.21,-0.03],["l",0,-1.29],["l",0,-1.29],["z"],["m",-0.06,10.44],["c",0,-5.58,0,-6.99,-0.03,-6.99],["c",-0.15,0,-0.63,0.27,-0.87,0.45],["c",-0.45,0.36,-0.75,0.93,-0.93,1.77],["c",-0.18,0.81,-0.24,1.8,-0.24,4.74],["c",0,2.97,0.06,3.96,0.24,4.77],["c",0.24,1.08,0.66,1.68,1.41,2.07],["c",0.12,0.06,0.3,0.12,0.33,0.15],["l",0.09,0],["l",0,-6.96],["z"]],w:13.038,h:20.97},"0":{d:[["M",4.83,-14.97],["c",0.33,-0.03,1.11,0,1.47,0.06],["c",1.68,0.36,2.97,1.59,3.78,3.6],["c",1.2,2.97,0.81,6.96,-0.9,9.27],["c",-0.78,1.08,-1.71,1.71,-2.91,1.95],["c",-0.45,0.09,-1.32,0.09,-1.77,0],["c",-0.81,-0.18,-1.47,-0.51,-2.07,-1.02],["c",-2.34,-2.07,-3.15,-6.72,-1.74,-10.2],["c",0.87,-2.16,2.28,-3.42,4.14,-3.66],["z"],["m",1.11,0.87],["c",-0.21,-0.06,-0.69,-0.09,-0.87,-0.06],["c",-0.54,0.12,-0.87,0.42,-1.17,0.99],["c",-0.36,0.66,-0.51,1.56,-0.6,3],["c",-0.03,0.75,-0.03,4.59,-0,5.31],["c",0.09,1.5,0.27,2.4,0.6,3.06],["c",0.24,0.48,0.57,0.78,0.96,0.9],["c",0.27,0.09,0.78,0.09,1.05,-0],["c",0.39,-0.12,0.72,-0.42,0.96,-0.9],["c",0.33,-0.66,0.51,-1.56,0.6,-3.06],["c",0.03,-0.72,0.03,-4.56,-0,-5.31],["c",-0.09,-1.47,-0.27,-2.37,-0.6,-3.03],["c",-0.24,-0.48,-0.54,-0.78,-0.93,-0.9],["z"]],w:10.78,h:14.959},"1":{d:[["M",3.3,-15.06],["c",0.06,-0.06,0.21,-0.03,0.66,0.15],["c",0.81,0.39,1.08,0.39,1.83,0.03],["c",0.21,-0.09,0.39,-0.15,0.42,-0.15],["c",0.12,0,0.21,0.09,0.27,0.21],["c",0.06,0.12,0.06,0.33,0.06,5.94],["c",0,3.93,0,5.85,0.03,6.03],["c",0.06,0.36,0.15,0.69,0.27,0.96],["c",0.36,0.75,0.93,1.17,1.68,1.26],["c",0.3,0.03,0.39,0.09,0.39,0.3],["c",0,0.15,-0.03,0.18,-0.09,0.24],["c",-0.06,0.06,-0.09,0.06,-0.48,0.06],["c",-0.42,-0,-0.69,-0.03,-2.1,-0.24],["c",-0.9,-0.15,-1.77,-0.15,-2.67,-0],["c",-1.41,0.21,-1.68,0.24,-2.1,0.24],["c",-0.39,-0,-0.42,-0,-0.48,-0.06],["c",-0.06,-0.06,-0.06,-0.09,-0.06,-0.24],["c",0,-0.21,0.06,-0.27,0.36,-0.3],["c",0.75,-0.09,1.32,-0.51,1.68,-1.26],["c",0.12,-0.27,0.21,-0.6,0.27,-0.96],["c",0.03,-0.18,0.03,-1.59,0.03,-4.29],["c",0,-3.87,0,-4.05,-0.06,-4.14],["c",-0.09,-0.15,-0.18,-0.24,-0.39,-0.24],["c",-0.12,-0,-0.15,0.03,-0.21,0.06],["c",-0.03,0.06,-0.45,0.99,-0.96,2.13],["c",-0.48,1.14,-0.9,2.1,-0.93,2.16],["c",-0.06,0.15,-0.21,0.24,-0.33,0.24],["c",-0.24,0,-0.42,-0.18,-0.42,-0.39],["c",0,-0.06,3.27,-7.62,3.33,-7.74],["z"]],w:8.94,h:15.058},"2":{d:[["M",4.23,-14.97],["c",0.57,-0.06,1.68,0,2.34,0.18],["c",0.69,0.18,1.5,0.54,2.01,0.9],["c",1.35,0.96,1.95,2.25,1.77,3.81],["c",-0.15,1.35,-0.66,2.34,-1.68,3.15],["c",-0.6,0.48,-1.44,0.93,-3.12,1.65],["c",-1.32,0.57,-1.8,0.81,-2.37,1.14],["c",-0.57,0.33,-0.57,0.33,-0.24,0.27],["c",0.39,-0.09,1.26,-0.09,1.68,0],["c",0.72,0.15,1.41,0.45,2.1,0.9],["c",0.99,0.63,1.86,0.87,2.55,0.75],["c",0.24,-0.06,0.42,-0.15,0.57,-0.3],["c",0.12,-0.09,0.3,-0.42,0.3,-0.51],["c",0,-0.09,0.12,-0.21,0.24,-0.24],["c",0.18,-0.03,0.39,0.12,0.39,0.3],["c",0,0.12,-0.15,0.57,-0.3,0.87],["c",-0.54,1.02,-1.56,1.74,-2.79,2.01],["c",-0.42,0.09,-1.23,0.09,-1.62,0.03],["c",-0.81,-0.18,-1.32,-0.45,-2.01,-1.11],["c",-0.45,-0.45,-0.63,-0.57,-0.96,-0.69],["c",-0.84,-0.27,-1.89,0.12,-2.25,0.9],["c",-0.12,0.21,-0.21,0.54,-0.21,0.72],["c",0,0.12,-0.12,0.21,-0.27,0.24],["c",-0.15,0,-0.27,-0.03,-0.33,-0.15],["c",-0.09,-0.21,0.09,-1.08,0.33,-1.71],["c",0.24,-0.66,0.66,-1.26,1.29,-1.89],["c",0.45,-0.45,0.9,-0.81,1.92,-1.56],["c",1.29,-0.93,1.89,-1.44,2.34,-1.98],["c",0.87,-1.05,1.26,-2.19,1.2,-3.63],["c",-0.06,-1.29,-0.39,-2.31,-0.96,-2.91],["c",-0.36,-0.33,-0.72,-0.51,-1.17,-0.54],["c",-0.84,-0.03,-1.53,0.42,-1.59,1.05],["c",-0.03,0.33,0.12,0.6,0.57,1.14],["c",0.45,0.54,0.54,0.87,0.42,1.41],["c",-0.15,0.63,-0.54,1.11,-1.08,1.38],["c",-0.63,0.33,-1.2,0.33,-1.83,0],["c",-0.24,-0.12,-0.33,-0.18,-0.54,-0.39],["c",-0.18,-0.18,-0.27,-0.3,-0.36,-0.51],["c",-0.24,-0.45,-0.27,-0.84,-0.21,-1.38],["c",0.12,-0.75,0.45,-1.41,1.02,-1.98],["c",0.72,-0.72,1.74,-1.17,2.85,-1.32],["z"]],w:10.764,h:14.993},"3":{d:[["M",3.78,-14.97],["c",0.3,-0.03,1.41,0,1.83,0.06],["c",2.22,0.3,3.51,1.32,3.72,2.91],["c",0.03,0.33,0.03,1.26,-0.03,1.65],["c",-0.12,0.84,-0.48,1.47,-1.05,1.77],["c",-0.27,0.15,-0.36,0.24,-0.45,0.39],["c",-0.09,0.21,-0.09,0.36,0,0.57],["c",0.09,0.15,0.18,0.24,0.51,0.39],["c",0.75,0.42,1.23,1.14,1.41,2.13],["c",0.06,0.42,0.06,1.35,0,1.71],["c",-0.18,0.81,-0.48,1.38,-1.02,1.95],["c",-0.75,0.72,-1.8,1.2,-3.18,1.38],["c",-0.42,0.06,-1.56,0.06,-1.95,0],["c",-1.89,-0.33,-3.18,-1.29,-3.51,-2.64],["c",-0.03,-0.12,-0.03,-0.33,-0.03,-0.6],["c",0,-0.36,0,-0.42,0.06,-0.63],["c",0.12,-0.3,0.27,-0.51,0.51,-0.75],["c",0.24,-0.24,0.45,-0.39,0.75,-0.51],["c",0.21,-0.06,0.27,-0.06,0.6,-0.06],["c",0.33,0,0.39,0,0.6,0.06],["c",0.3,0.12,0.51,0.27,0.75,0.51],["c",0.36,0.33,0.57,0.75,0.6,1.2],["c",0,0.21,0,0.27,-0.06,0.42],["c",-0.09,0.18,-0.12,0.24,-0.54,0.54],["c",-0.51,0.36,-0.63,0.54,-0.6,0.87],["c",0.06,0.54,0.54,0.9,1.38,0.99],["c",0.36,0.06,0.72,0.03,0.96,-0.06],["c",0.81,-0.27,1.29,-1.23,1.44,-2.79],["c",0.03,-0.45,0.03,-1.95,-0.03,-2.37],["c",-0.09,-0.75,-0.33,-1.23,-0.75,-1.44],["c",-0.33,-0.18,-0.45,-0.18,-1.98,-0.18],["c",-1.35,0,-1.41,0,-1.5,-0.06],["c",-0.18,-0.12,-0.24,-0.39,-0.12,-0.6],["c",0.12,-0.15,0.15,-0.15,1.68,-0.15],["c",1.5,0,1.62,0,1.89,-0.15],["c",0.18,-0.09,0.42,-0.36,0.54,-0.57],["c",0.18,-0.42,0.27,-0.9,0.3,-1.95],["c",0.03,-1.2,-0.06,-1.8,-0.36,-2.37],["c",-0.24,-0.48,-0.63,-0.81,-1.14,-0.96],["c",-0.3,-0.06,-1.08,-0.06,-1.38,0.03],["c",-0.6,0.15,-0.9,0.42,-0.96,0.84],["c",-0.03,0.3,0.06,0.45,0.63,0.84],["c",0.33,0.24,0.42,0.39,0.45,0.63],["c",0.03,0.72,-0.57,1.5,-1.32,1.65],["c",-1.05,0.27,-2.1,-0.57,-2.1,-1.65],["c",0,-0.45,0.15,-0.96,0.39,-1.38],["c",0.12,-0.21,0.54,-0.63,0.81,-0.81],["c",0.57,-0.42,1.38,-0.69,2.25,-0.81],["z"]],w:9.735,h:14.967},"4":{d:[["M",8.64,-14.94],["c",0.27,-0.09,0.42,-0.12,0.54,-0.03],["c",0.09,0.06,0.15,0.21,0.15,0.3],["c",-0.03,0.06,-1.92,2.31,-4.23,5.04],["c",-2.31,2.73,-4.23,4.98,-4.26,5.01],["c",-0.03,0.06,0.12,0.06,2.55,0.06],["l",2.61,0],["l",0,-2.37],["c",0,-2.19,0.03,-2.37,0.06,-2.46],["c",0.03,-0.06,0.21,-0.18,0.57,-0.42],["c",1.08,-0.72,1.38,-1.08,1.86,-2.16],["c",0.12,-0.3,0.24,-0.54,0.27,-0.57],["c",0.12,-0.12,0.39,-0.06,0.45,0.12],["c",0.06,0.09,0.06,0.57,0.06,3.96],["l",0,3.9],["l",1.08,0],["c",1.05,0,1.11,0,1.2,0.06],["c",0.24,0.15,0.24,0.54,0,0.69],["c",-0.09,0.06,-0.15,0.06,-1.2,0.06],["l",-1.08,0],["l",0,0.33],["c",0,0.57,0.09,1.11,0.3,1.53],["c",0.36,0.75,0.93,1.17,1.68,1.26],["c",0.3,0.03,0.39,0.09,0.39,0.3],["c",0,0.15,-0.03,0.18,-0.09,0.24],["c",-0.06,0.06,-0.09,0.06,-0.48,0.06],["c",-0.42,0,-0.69,-0.03,-2.1,-0.24],["c",-0.9,-0.15,-1.77,-0.15,-2.67,0],["c",-1.41,0.21,-1.68,0.24,-2.1,0.24],["c",-0.39,0,-0.42,0,-0.48,-0.06],["c",-0.06,-0.06,-0.06,-0.09,-0.06,-0.24],["c",0,-0.21,0.06,-0.27,0.36,-0.3],["c",0.75,-0.09,1.32,-0.51,1.68,-1.26],["c",0.21,-0.42,0.3,-0.96,0.3,-1.53],["l",0,-0.33],["l",-2.7,0],["c",-2.91,0,-2.85,0,-3.09,-0.15],["c",-0.18,-0.12,-0.3,-0.39,-0.27,-0.54],["c",0.03,-0.06,0.18,-0.24,0.33,-0.45],["c",0.75,-0.9,1.59,-2.07,2.13,-3.03],["c",0.33,-0.54,0.84,-1.62,1.05,-2.16],["c",0.57,-1.41,0.84,-2.64,0.9,-4.05],["c",0.03,-0.63,0.06,-0.72,0.24,-0.81],["l",0.12,-0.06],["l",0.45,0.12],["c",0.66,0.18,1.02,0.24,1.47,0.27],["c",0.6,0.03,1.23,-0.09,2.01,-0.33],["z"]],w:11.795,h:14.994},"5":{d:[["M",1.02,-14.94],["c",0.12,-0.09,0.03,-0.09,1.08,0.06],["c",2.49,0.36,4.35,0.36,6.96,-0.06],["c",0.57,-0.09,0.66,-0.06,0.81,0.06],["c",0.15,0.18,0.12,0.24,-0.15,0.51],["c",-1.29,1.26,-3.24,2.04,-5.58,2.31],["c",-0.6,0.09,-1.2,0.12,-1.71,0.12],["c",-0.39,0,-0.45,0,-0.57,0.06],["c",-0.09,0.06,-0.15,0.12,-0.21,0.21],["l",-0.06,0.12],["l",0,1.65],["l",0,1.65],["l",0.21,-0.21],["c",0.66,-0.57,1.41,-0.96,2.19,-1.14],["c",0.33,-0.06,1.41,-0.06,1.95,0],["c",2.61,0.36,4.02,1.74,4.26,4.14],["c",0.03,0.45,0.03,1.08,-0.03,1.44],["c",-0.18,1.02,-0.78,2.01,-1.59,2.7],["c",-0.72,0.57,-1.62,1.02,-2.49,1.2],["c",-1.38,0.27,-3.03,0.06,-4.2,-0.54],["c",-1.08,-0.54,-1.71,-1.32,-1.86,-2.28],["c",-0.09,-0.69,0.09,-1.29,0.57,-1.74],["c",0.24,-0.24,0.45,-0.39,0.75,-0.51],["c",0.21,-0.06,0.27,-0.06,0.6,-0.06],["c",0.33,0,0.39,0,0.6,0.06],["c",0.3,0.12,0.51,0.27,0.75,0.51],["c",0.36,0.33,0.57,0.75,0.6,1.2],["c",0,0.21,0,0.27,-0.06,0.42],["c",-0.09,0.18,-0.12,0.24,-0.54,0.54],["c",-0.18,0.12,-0.36,0.3,-0.42,0.33],["c",-0.36,0.42,-0.18,0.99,0.36,1.26],["c",0.51,0.27,1.47,0.36,2.01,0.27],["c",0.93,-0.21,1.47,-1.17,1.65,-2.91],["c",0.06,-0.45,0.06,-1.89,0,-2.31],["c",-0.15,-1.2,-0.51,-2.1,-1.05,-2.55],["c",-0.21,-0.18,-0.54,-0.36,-0.81,-0.39],["c",-0.3,-0.06,-0.84,-0.03,-1.26,0.06],["c",-0.93,0.18,-1.65,0.6,-2.16,1.2],["c",-0.15,0.21,-0.27,0.3,-0.39,0.3],["c",-0.15,0,-0.3,-0.09,-0.36,-0.18],["c",-0.06,-0.09,-0.06,-0.15,-0.06,-3.66],["c",0,-3.39,0,-3.57,0.06,-3.66],["c",0.03,-0.06,0.09,-0.15,0.15,-0.18],["z"]],w:10.212,h:14.997},"6":{d:[["M",4.98,-14.97],["c",0.36,-0.03,1.2,0,1.59,0.06],["c",0.9,0.15,1.68,0.51,2.25,1.05],["c",0.57,0.51,0.87,1.23,0.84,1.98],["c",-0.03,0.51,-0.21,0.9,-0.6,1.26],["c",-0.24,0.24,-0.45,0.39,-0.75,0.51],["c",-0.21,0.06,-0.27,0.06,-0.6,0.06],["c",-0.33,0,-0.39,0,-0.6,-0.06],["c",-0.3,-0.12,-0.51,-0.27,-0.75,-0.51],["c",-0.39,-0.36,-0.57,-0.78,-0.57,-1.26],["c",0,-0.27,0,-0.3,0.09,-0.42],["c",0.03,-0.09,0.18,-0.21,0.3,-0.3],["c",0.12,-0.09,0.3,-0.21,0.39,-0.27],["c",0.09,-0.06,0.21,-0.18,0.27,-0.24],["c",0.06,-0.12,0.09,-0.15,0.09,-0.33],["c",0,-0.18,-0.03,-0.24,-0.09,-0.36],["c",-0.24,-0.39,-0.75,-0.6,-1.38,-0.57],["c",-0.54,0.03,-0.9,0.18,-1.23,0.48],["c",-0.81,0.72,-1.08,2.16,-0.96,5.37],["l",0,0.63],["l",0.3,-0.12],["c",0.78,-0.27,1.29,-0.33,2.1,-0.27],["c",1.47,0.12,2.49,0.54,3.27,1.29],["c",0.48,0.51,0.81,1.11,0.96,1.89],["c",0.06,0.27,0.06,0.42,0.06,0.93],["c",0,0.54,0,0.69,-0.06,0.96],["c",-0.15,0.78,-0.48,1.38,-0.96,1.89],["c",-0.54,0.51,-1.17,0.87,-1.98,1.08],["c",-1.14,0.3,-2.4,0.33,-3.24,0.03],["c",-1.5,-0.48,-2.64,-1.89,-3.27,-4.02],["c",-0.36,-1.23,-0.51,-2.82,-0.42,-4.08],["c",0.3,-3.66,2.28,-6.3,4.95,-6.66],["z"],["m",0.66,7.41],["c",-0.27,-0.09,-0.81,-0.12,-1.08,-0.06],["c",-0.72,0.18,-1.08,0.69,-1.23,1.71],["c",-0.06,0.54,-0.06,3,0,3.54],["c",0.18,1.26,0.72,1.77,1.8,1.74],["c",0.39,-0.03,0.63,-0.09,0.9,-0.27],["c",0.66,-0.42,0.9,-1.32,0.9,-3.24],["c",0,-2.22,-0.36,-3.12,-1.29,-3.42],["z"]],w:9.956,h:14.982},"7":{d:[["M",0.21,-14.97],["c",0.21,-0.06,0.45,0,0.54,0.15],["c",0.06,0.09,0.06,0.15,0.06,0.39],["c",0,0.24,0,0.33,0.06,0.42],["c",0.06,0.12,0.21,0.24,0.27,0.24],["c",0.03,0,0.12,-0.12,0.24,-0.21],["c",0.96,-1.2,2.58,-1.35,3.99,-0.42],["c",0.15,0.12,0.42,0.3,0.54,0.45],["c",0.48,0.39,0.81,0.57,1.29,0.6],["c",0.69,0.03,1.5,-0.3,2.13,-0.87],["c",0.09,-0.09,0.27,-0.3,0.39,-0.45],["c",0.12,-0.15,0.24,-0.27,0.3,-0.3],["c",0.18,-0.06,0.39,0.03,0.51,0.21],["c",0.06,0.18,0.06,0.24,-0.27,0.72],["c",-0.18,0.24,-0.54,0.78,-0.78,1.17],["c",-2.37,3.54,-3.54,6.27,-3.87,9],["c",-0.03,0.33,-0.03,0.66,-0.03,1.26],["c",0,0.9,0,1.08,0.15,1.89],["c",0.06,0.45,0.06,0.48,0.03,0.6],["c",-0.06,0.09,-0.21,0.21,-0.3,0.21],["c",-0.03,0,-0.27,-0.06,-0.54,-0.15],["c",-0.84,-0.27,-1.11,-0.3,-1.65,-0.3],["c",-0.57,0,-0.84,0.03,-1.56,0.27],["c",-0.6,0.18,-0.69,0.21,-0.81,0.15],["c",-0.12,-0.06,-0.21,-0.18,-0.21,-0.3],["c",0,-0.15,0.6,-1.44,1.2,-2.61],["c",1.14,-2.22,2.73,-4.68,5.1,-8.01],["c",0.21,-0.27,0.36,-0.48,0.33,-0.48],["c",0,0,-0.12,0.06,-0.27,0.12],["c",-0.54,0.3,-0.99,0.39,-1.56,0.39],["c",-0.75,0.03,-1.2,-0.18,-1.83,-0.75],["c",-0.99,-0.9,-1.83,-1.17,-2.31,-0.72],["c",-0.18,0.15,-0.36,0.51,-0.45,0.84],["c",-0.06,0.24,-0.06,0.33,-0.09,1.98],["c",0,1.62,-0.03,1.74,-0.06,1.8],["c",-0.15,0.24,-0.54,0.24,-0.69,0],["c",-0.06,-0.09,-0.06,-0.15,-0.06,-3.57],["c",0,-3.42,0,-3.48,0.06,-3.57],["c",0.03,-0.06,0.09,-0.12,0.15,-0.15],["z"]],w:10.561,h:15.093},"8":{d:[["M",4.98,-14.97],["c",0.33,-0.03,1.02,-0.03,1.32,0],["c",1.32,0.12,2.49,0.6,3.21,1.32],["c",0.39,0.39,0.66,0.81,0.78,1.29],["c",0.09,0.36,0.09,1.08,0,1.44],["c",-0.21,0.84,-0.66,1.59,-1.59,2.55],["l",-0.3,0.3],["l",0.27,0.18],["c",1.47,0.93,2.31,2.31,2.25,3.75],["c",-0.03,0.75,-0.24,1.35,-0.63,1.95],["c",-0.45,0.66,-1.02,1.14,-1.83,1.53],["c",-1.8,0.87,-4.2,0.87,-6,0.03],["c",-1.62,-0.78,-2.52,-2.16,-2.46,-3.66],["c",0.06,-0.99,0.54,-1.77,1.8,-2.97],["c",0.54,-0.51,0.54,-0.54,0.48,-0.57],["c",-0.39,-0.27,-0.96,-0.78,-1.2,-1.14],["c",-0.75,-1.11,-0.87,-2.4,-0.3,-3.6],["c",0.69,-1.35,2.25,-2.25,4.2,-2.4],["z"],["m",1.53,0.69],["c",-0.42,-0.09,-1.11,-0.12,-1.38,-0.06],["c",-0.3,0.06,-0.6,0.18,-0.81,0.3],["c",-0.21,0.12,-0.6,0.51,-0.72,0.72],["c",-0.51,0.87,-0.42,1.89,0.21,2.52],["c",0.21,0.21,0.36,0.3,1.95,1.23],["c",0.96,0.54,1.74,0.99,1.77,1.02],["c",0.09,0,0.63,-0.6,0.99,-1.11],["c",0.21,-0.36,0.48,-0.87,0.57,-1.23],["c",0.06,-0.24,0.06,-0.36,0.06,-0.72],["c",0,-0.45,-0.03,-0.66,-0.15,-0.99],["c",-0.39,-0.81,-1.29,-1.44,-2.49,-1.68],["z"],["m",-1.44,8.07],["l",-1.89,-1.08],["c",-0.03,0,-0.18,0.15,-0.39,0.33],["c",-1.2,1.08,-1.65,1.95,-1.59,3],["c",0.09,1.59,1.35,2.85,3.21,3.24],["c",0.33,0.06,0.45,0.06,0.93,0.06],["c",0.63,-0,0.81,-0.03,1.29,-0.27],["c",0.9,-0.42,1.47,-1.41,1.41,-2.4],["c",-0.06,-0.66,-0.39,-1.29,-0.9,-1.65],["c",-0.12,-0.09,-1.05,-0.63,-2.07,-1.23],["z"]],w:10.926,h:14.989},"9":{d:[["M",4.23,-14.97],["c",0.42,-0.03,1.29,0,1.62,0.06],["c",0.51,0.12,0.93,0.3,1.38,0.57],["c",1.53,1.02,2.52,3.24,2.73,5.94],["c",0.18,2.55,-0.48,4.98,-1.83,6.57],["c",-1.05,1.26,-2.4,1.89,-3.93,1.83],["c",-1.23,-0.06,-2.31,-0.45,-3.03,-1.14],["c",-0.57,-0.51,-0.87,-1.23,-0.84,-1.98],["c",0.03,-0.51,0.21,-0.9,0.6,-1.26],["c",0.24,-0.24,0.45,-0.39,0.75,-0.51],["c",0.21,-0.06,0.27,-0.06,0.6,-0.06],["c",0.33,-0,0.39,-0,0.6,0.06],["c",0.3,0.12,0.51,0.27,0.75,0.51],["c",0.39,0.36,0.57,0.78,0.57,1.26],["c",0,0.27,0,0.3,-0.09,0.42],["c",-0.03,0.09,-0.18,0.21,-0.3,0.3],["c",-0.12,0.09,-0.3,0.21,-0.39,0.27],["c",-0.09,0.06,-0.21,0.18,-0.27,0.24],["c",-0.06,0.12,-0.06,0.15,-0.06,0.33],["c",0,0.18,0,0.24,0.06,0.36],["c",0.24,0.39,0.75,0.6,1.38,0.57],["c",0.54,-0.03,0.9,-0.18,1.23,-0.48],["c",0.81,-0.72,1.08,-2.16,0.96,-5.37],["l",0,-0.63],["l",-0.3,0.12],["c",-0.78,0.27,-1.29,0.33,-2.1,0.27],["c",-1.47,-0.12,-2.49,-0.54,-3.27,-1.29],["c",-0.48,-0.51,-0.81,-1.11,-0.96,-1.89],["c",-0.06,-0.27,-0.06,-0.42,-0.06,-0.96],["c",0,-0.51,0,-0.66,0.06,-0.93],["c",0.15,-0.78,0.48,-1.38,0.96,-1.89],["c",0.15,-0.12,0.33,-0.27,0.42,-0.36],["c",0.69,-0.51,1.62,-0.81,2.76,-0.93],["z"],["m",1.17,0.66],["c",-0.21,-0.06,-0.57,-0.06,-0.81,-0.03],["c",-0.78,0.12,-1.26,0.69,-1.41,1.74],["c",-0.12,0.63,-0.15,1.95,-0.09,2.79],["c",0.12,1.71,0.63,2.4,1.77,2.46],["c",1.08,0.03,1.62,-0.48,1.8,-1.74],["c",0.06,-0.54,0.06,-3,0,-3.54],["c",-0.15,-1.05,-0.51,-1.53,-1.26,-1.68],["z"]],w:9.959,h:14.986},f:{d:[["M",9.93,-14.28],["c",1.53,-0.18,2.88,0.45,3.12,1.5],["c",0.12,0.51,0,1.32,-0.27,1.86],["c",-0.15,0.3,-0.42,0.57,-0.63,0.69],["c",-0.69,0.36,-1.56,0.03,-1.83,-0.69],["c",-0.09,-0.24,-0.09,-0.69,0,-0.87],["c",0.06,-0.12,0.21,-0.24,0.45,-0.42],["c",0.42,-0.24,0.57,-0.45,0.6,-0.72],["c",0.03,-0.33,-0.09,-0.39,-0.63,-0.42],["c",-0.3,0,-0.45,0,-0.6,0.03],["c",-0.81,0.21,-1.35,0.93,-1.74,2.46],["c",-0.06,0.27,-0.48,2.25,-0.48,2.31],["c",0,0.03,0.39,0.03,0.9,0.03],["c",0.72,0,0.9,0,0.99,0.06],["c",0.42,0.15,0.45,0.72,0.03,0.9],["c",-0.12,0.06,-0.24,0.06,-1.17,0.06],["l",-1.05,0],["l",-0.78,2.55],["c",-0.45,1.41,-0.87,2.79,-0.96,3.06],["c",-0.87,2.37,-2.37,4.74,-3.78,5.91],["c",-1.05,0.9,-2.04,1.23,-3.09,1.08],["c",-1.11,-0.18,-1.89,-0.78,-2.04,-1.59],["c",-0.12,-0.66,0.15,-1.71,0.54,-2.19],["c",0.69,-0.75,1.86,-0.54,2.22,0.39],["c",0.06,0.15,0.09,0.27,0.09,0.48],["c",-0,0.24,-0.03,0.27,-0.12,0.42],["c",-0.03,0.09,-0.15,0.18,-0.27,0.27],["c",-0.09,0.06,-0.27,0.21,-0.36,0.27],["c",-0.24,0.18,-0.36,0.36,-0.39,0.6],["c",-0.03,0.33,0.09,0.39,0.63,0.42],["c",0.42,0,0.63,-0.03,0.9,-0.15],["c",0.6,-0.3,0.96,-0.96,1.38,-2.64],["c",0.09,-0.42,0.63,-2.55,1.17,-4.77],["l",1.02,-4.08],["c",-0,-0.03,-0.36,-0.03,-0.81,-0.03],["c",-0.72,0,-0.81,0,-0.93,-0.06],["c",-0.42,-0.18,-0.39,-0.75,0.03,-0.9],["c",0.09,-0.06,0.27,-0.06,1.05,-0.06],["l",0.96,0],["l",0,-0.09],["c",0.06,-0.18,0.3,-0.72,0.51,-1.17],["c",1.2,-2.46,3.3,-4.23,5.34,-4.5],["z"]],w:16.155,h:19.445},m:{d:[["M",2.79,-8.91],["c",0.09,0,0.3,-0.03,0.45,-0.03],["c",0.24,0.03,0.3,0.03,0.45,0.12],["c",0.36,0.15,0.63,0.54,0.75,1.02],["l",0.03,0.21],["l",0.33,-0.3],["c",0.69,-0.69,1.38,-1.02,2.07,-1.02],["c",0.27,0,0.33,0,0.48,0.06],["c",0.21,0.09,0.48,0.36,0.63,0.6],["c",0.03,0.09,0.12,0.27,0.18,0.42],["c",0.03,0.15,0.09,0.27,0.12,0.27],["c",0,0,0.09,-0.09,0.18,-0.21],["c",0.33,-0.39,0.87,-0.81,1.29,-0.99],["c",0.78,-0.33,1.47,-0.21,2.01,0.33],["c",0.3,0.33,0.48,0.69,0.6,1.14],["c",0.09,0.42,0.06,0.54,-0.54,3.06],["c",-0.33,1.29,-0.57,2.4,-0.57,2.43],["c",0,0.12,0.09,0.21,0.21,0.21],["c",0.24,-0,0.75,-0.3,1.2,-0.72],["c",0.45,-0.39,0.6,-0.45,0.78,-0.27],["c",0.18,0.18,0.09,0.36,-0.45,0.87],["c",-1.05,0.96,-1.83,1.47,-2.58,1.71],["c",-0.93,0.33,-1.53,0.21,-1.8,-0.33],["c",-0.06,-0.15,-0.06,-0.21,-0.06,-0.45],["c",0,-0.24,0.03,-0.48,0.6,-2.82],["c",0.42,-1.71,0.6,-2.64,0.63,-2.79],["c",0.03,-0.57,-0.3,-0.75,-0.84,-0.48],["c",-0.24,0.12,-0.54,0.39,-0.66,0.63],["c",-0.03,0.09,-0.42,1.38,-0.9,3],["c",-0.9,3.15,-0.84,3,-1.14,3.15],["l",-0.15,0.09],["l",-0.78,0],["c",-0.6,0,-0.78,0,-0.84,-0.06],["c",-0.09,-0.03,-0.18,-0.18,-0.18,-0.27],["c",0,-0.03,0.36,-1.38,0.84,-2.97],["c",0.57,-2.04,0.81,-2.97,0.84,-3.12],["c",0.03,-0.54,-0.3,-0.72,-0.84,-0.45],["c",-0.24,0.12,-0.57,0.42,-0.66,0.63],["c",-0.06,0.09,-0.51,1.44,-1.05,2.97],["c",-0.51,1.56,-0.99,2.85,-0.99,2.91],["c",-0.06,0.12,-0.21,0.24,-0.36,0.3],["c",-0.12,0.06,-0.21,0.06,-0.9,0.06],["c",-0.6,0,-0.78,0,-0.84,-0.06],["c",-0.09,-0.03,-0.18,-0.18,-0.18,-0.27],["c",0,-0.03,0.45,-1.38,0.99,-2.97],["c",1.05,-3.18,1.05,-3.18,0.93,-3.45],["c",-0.12,-0.27,-0.39,-0.3,-0.72,-0.15],["c",-0.54,0.27,-1.14,1.17,-1.56,2.4],["c",-0.06,0.15,-0.15,0.3,-0.18,0.36],["c",-0.21,0.21,-0.57,0.27,-0.72,0.09],["c",-0.09,-0.09,-0.06,-0.21,0.06,-0.63],["c",0.48,-1.26,1.26,-2.46,2.01,-3.21],["c",0.57,-0.54,1.2,-0.87,1.83,-1.02],["z"]],w:14.687,h:9.126},p:{d:[["M",1.92,-8.7],["c",0.27,-0.09,0.81,-0.06,1.11,0.03],["c",0.54,0.18,0.93,0.51,1.17,0.99],["c",0.09,0.15,0.15,0.33,0.18,0.36],["l",-0,0.12],["l",0.3,-0.27],["c",0.66,-0.6,1.35,-1.02,2.13,-1.2],["c",0.21,-0.06,0.33,-0.06,0.78,-0.06],["c",0.45,0,0.51,0,0.84,0.09],["c",1.29,0.33,2.07,1.32,2.25,2.79],["c",0.09,0.81,-0.09,2.01,-0.45,2.79],["c",-0.54,1.26,-1.86,2.55,-3.18,3.03],["c",-0.45,0.18,-0.81,0.24,-1.29,0.24],["c",-0.69,-0.03,-1.35,-0.18,-1.86,-0.45],["c",-0.3,-0.15,-0.51,-0.18,-0.69,-0.09],["c",-0.09,0.03,-0.18,0.09,-0.18,0.12],["c",-0.09,0.12,-1.05,2.94,-1.05,3.06],["c",0,0.24,0.18,0.48,0.51,0.63],["c",0.18,0.06,0.54,0.15,0.75,0.15],["c",0.21,0,0.36,0.06,0.42,0.18],["c",0.12,0.18,0.06,0.42,-0.12,0.54],["c",-0.09,0.03,-0.15,0.03,-0.78,0],["c",-1.98,-0.15,-3.81,-0.15,-5.79,0],["c",-0.63,0.03,-0.69,0.03,-0.78,0],["c",-0.24,-0.15,-0.24,-0.57,0.03,-0.66],["c",0.06,-0.03,0.48,-0.09,0.99,-0.12],["c",0.87,-0.06,1.11,-0.09,1.35,-0.21],["c",0.18,-0.06,0.33,-0.18,0.39,-0.3],["c",0.06,-0.12,3.24,-9.42,3.27,-9.6],["c",0.06,-0.33,0.03,-0.57,-0.15,-0.69],["c",-0.09,-0.06,-0.12,-0.06,-0.3,-0.06],["c",-0.69,0.06,-1.53,1.02,-2.28,2.61],["c",-0.09,0.21,-0.21,0.45,-0.27,0.51],["c",-0.09,0.12,-0.33,0.24,-0.48,0.24],["c",-0.18,0,-0.36,-0.15,-0.36,-0.3],["c",0,-0.24,0.78,-1.83,1.26,-2.55],["c",0.72,-1.11,1.47,-1.74,2.28,-1.92],["z"],["m",5.37,1.47],["c",-0.27,-0.12,-0.75,-0.03,-1.14,0.21],["c",-0.75,0.48,-1.47,1.68,-1.89,3.15],["c",-0.45,1.47,-0.42,2.34,0,2.7],["c",0.45,0.39,1.26,0.21,1.83,-0.36],["c",0.51,-0.51,0.99,-1.68,1.38,-3.27],["c",0.3,-1.17,0.33,-1.74,0.15,-2.13],["c",-0.09,-0.15,-0.15,-0.21,-0.33,-0.3],["z"]],w:14.689,h:13.127},r:{d:[["M",6.33,-9.12],["c",0.27,-0.03,0.93,0,1.2,0.06],["c",0.84,0.21,1.23,0.81,1.02,1.53],["c",-0.24,0.75,-0.9,1.17,-1.56,0.96],["c",-0.33,-0.09,-0.51,-0.3,-0.66,-0.75],["c",-0.03,-0.12,-0.09,-0.24,-0.12,-0.3],["c",-0.09,-0.15,-0.3,-0.24,-0.48,-0.24],["c",-0.57,0,-1.38,0.54,-1.65,1.08],["c",-0.06,0.15,-0.33,1.17,-0.9,3.27],["c",-0.57,2.31,-0.81,3.12,-0.87,3.21],["c",-0.03,0.06,-0.12,0.15,-0.18,0.21],["l",-0.12,0.06],["l",-0.81,0.03],["c",-0.69,0,-0.81,0,-0.9,-0.03],["c",-0.09,-0.06,-0.18,-0.21,-0.18,-0.3],["c",0,-0.06,0.39,-1.62,0.9,-3.51],["c",0.84,-3.24,0.87,-3.45,0.87,-3.72],["c",0,-0.21,0,-0.27,-0.03,-0.36],["c",-0.12,-0.15,-0.21,-0.24,-0.42,-0.24],["c",-0.24,0,-0.45,0.15,-0.78,0.42],["c",-0.33,0.36,-0.45,0.54,-0.72,1.14],["c",-0.03,0.12,-0.21,0.24,-0.36,0.27],["c",-0.12,0,-0.15,0,-0.24,-0.06],["c",-0.18,-0.12,-0.18,-0.21,-0.06,-0.54],["c",0.21,-0.57,0.42,-0.93,0.78,-1.32],["c",0.54,-0.51,1.2,-0.81,1.95,-0.87],["c",0.81,-0.03,1.53,0.3,1.92,0.87],["l",0.12,0.18],["l",0.09,-0.09],["c",0.57,-0.45,1.41,-0.84,2.19,-0.96],["z"]],w:9.41,h:9.132},s:{d:[["M",4.47,-8.73],["c",0.09,0,0.36,-0.03,0.57,-0.03],["c",0.75,0.03,1.29,0.24,1.71,0.63],["c",0.51,0.54,0.66,1.26,0.36,1.83],["c",-0.24,0.42,-0.63,0.57,-1.11,0.42],["c",-0.33,-0.09,-0.6,-0.36,-0.6,-0.57],["c",0,-0.03,0.06,-0.21,0.15,-0.39],["c",0.12,-0.21,0.15,-0.33,0.18,-0.48],["c",0,-0.24,-0.06,-0.48,-0.15,-0.6],["c",-0.15,-0.21,-0.42,-0.24,-0.75,-0.15],["c",-0.27,0.06,-0.48,0.18,-0.69,0.36],["c",-0.39,0.39,-0.51,0.96,-0.33,1.38],["c",0.09,0.21,0.42,0.51,0.78,0.72],["c",1.11,0.69,1.59,1.11,1.89,1.68],["c",0.21,0.39,0.24,0.78,0.15,1.29],["c",-0.18,1.2,-1.17,2.16,-2.52,2.52],["c",-1.02,0.24,-1.95,0.12,-2.7,-0.42],["c",-0.72,-0.51,-0.99,-1.47,-0.6,-2.19],["c",0.24,-0.48,0.72,-0.63,1.17,-0.42],["c",0.33,0.18,0.54,0.45,0.57,0.81],["c",0,0.21,-0.03,0.3,-0.33,0.51],["c",-0.33,0.24,-0.39,0.42,-0.27,0.69],["c",0.06,0.15,0.21,0.27,0.45,0.33],["c",0.3,0.09,0.87,0.09,1.2,-0],["c",0.75,-0.21,1.23,-0.72,1.29,-1.35],["c",0.03,-0.42,-0.15,-0.81,-0.54,-1.2],["c",-0.24,-0.24,-0.48,-0.42,-1.41,-1.02],["c",-0.69,-0.42,-1.05,-0.93,-1.05,-1.47],["c",0,-0.39,0.12,-0.87,0.3,-1.23],["c",0.27,-0.57,0.78,-1.05,1.38,-1.35],["c",0.24,-0.12,0.63,-0.27,0.9,-0.3],["z"]],w:6.632,h:8.758},z:{d:[["M",2.64,-7.95],["c",0.36,-0.09,0.81,-0.03,1.71,0.27],["c",0.78,0.21,0.96,0.27,1.74,0.3],["c",0.87,0.06,1.02,0.03,1.38,-0.21],["c",0.21,-0.15,0.33,-0.15,0.48,-0.06],["c",0.15,0.09,0.21,0.3,0.15,0.45],["c",-0.03,0.06,-1.26,1.26,-2.76,2.67],["l",-2.73,2.55],["l",0.54,0.03],["c",0.54,0.03,0.72,0.03,2.01,0.15],["c",0.36,0.03,0.9,0.06,1.2,0.09],["c",0.66,0,0.81,-0.03,1.02,-0.24],["c",0.3,-0.3,0.39,-0.72,0.27,-1.23],["c",-0.06,-0.27,-0.06,-0.27,-0.03,-0.39],["c",0.15,-0.3,0.54,-0.27,0.69,0.03],["c",0.15,0.33,0.27,1.02,0.27,1.5],["c",0,1.47,-1.11,2.7,-2.52,2.79],["c",-0.57,0.03,-1.02,-0.09,-2.01,-0.51],["c",-1.02,-0.42,-1.23,-0.48,-2.13,-0.54],["c",-0.81,-0.06,-0.96,-0.03,-1.26,0.18],["c",-0.12,0.06,-0.24,0.12,-0.27,0.12],["c",-0.27,0,-0.45,-0.3,-0.36,-0.51],["c",0.03,-0.06,1.32,-1.32,2.91,-2.79],["l",2.88,-2.73],["c",-0.03,0,-0.21,0.03,-0.42,0.06],["c",-0.21,0.03,-0.78,0.09,-1.23,0.12],["c",-1.11,0.12,-1.23,0.15,-1.95,0.27],["c",-0.72,0.15,-1.17,0.18,-1.29,0.09],["c",-0.27,-0.18,-0.21,-0.75,0.12,-1.26],["c",0.39,-0.6,0.93,-1.02,1.59,-1.2],["z"]],w:8.573,h:8.743},"+":{d:[["M",3.48,-11.19],["c",0.18,-0.09,0.36,-0.09,0.54,0],["c",0.18,0.09,0.24,0.15,0.33,0.3],["l",0.06,0.15],["l",0,1.29],["l",0,1.29],["l",1.29,0],["c",1.23,0,1.29,0,1.41,0.06],["c",0.06,0.03,0.15,0.09,0.18,0.12],["c",0.12,0.09,0.21,0.33,0.21,0.48],["c",0,0.15,-0.09,0.39,-0.21,0.48],["c",-0.03,0.03,-0.12,0.09,-0.18,0.12],["c",-0.12,0.06,-0.18,0.06,-1.41,0.06],["l",-1.29,0],["l",0,1.29],["c",0,1.23,0,1.29,-0.06,1.41],["c",-0.09,0.18,-0.15,0.24,-0.3,0.33],["c",-0.21,0.09,-0.39,0.09,-0.57,0],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["c",-0.06,-0.12,-0.06,-0.18,-0.06,-1.41],["l",0,-1.29],["l",-1.29,0],["c",-1.23,0,-1.29,0,-1.41,-0.06],["c",-0.18,-0.09,-0.24,-0.15,-0.33,-0.33],["c",-0.09,-0.18,-0.09,-0.36,0,-0.54],["c",0.09,-0.18,0.15,-0.24,0.33,-0.33],["l",0.15,-0.06],["l",1.26,0],["l",1.29,0],["l",0,-1.29],["c",0,-1.23,0,-1.29,0.06,-1.41],["c",0.09,-0.18,0.15,-0.24,0.33,-0.33],["z"]],w:7.507,h:7.515},",":{d:[["M",1.32,-3.36],["c",0.57,-0.15,1.17,0.03,1.59,0.45],["c",0.45,0.45,0.6,0.96,0.51,1.89],["c",-0.09,1.23,-0.42,2.46,-0.99,3.93],["c",-0.3,0.72,-0.72,1.62,-0.78,1.68],["c",-0.18,0.21,-0.51,0.18,-0.66,-0.06],["c",-0.03,-0.06,-0.06,-0.15,-0.06,-0.18],["c",0,-0.06,0.12,-0.33,0.24,-0.63],["c",0.84,-1.8,1.02,-2.61,0.69,-3.24],["c",-0.12,-0.24,-0.27,-0.36,-0.75,-0.6],["c",-0.36,-0.15,-0.42,-0.21,-0.6,-0.39],["c",-0.69,-0.69,-0.69,-1.71,0,-2.4],["c",0.21,-0.21,0.51,-0.39,0.81,-0.45],["z"]],w:3.452,h:8.143},"-":{d:[["M",0.18,-5.34],["c",0.09,-0.06,0.15,-0.06,2.31,-0.06],["c",2.46,0,2.37,0,2.46,0.21],["c",0.12,0.21,0.03,0.42,-0.15,0.54],["c",-0.09,0.06,-0.15,0.06,-2.28,0.06],["c",-2.16,0,-2.22,0,-2.31,-0.06],["c",-0.27,-0.15,-0.27,-0.54,-0.03,-0.69],["z"]],w:5.001,h:0.81},".":{d:[["M",1.32,-3.36],["c",1.05,-0.27,2.1,0.57,2.1,1.65],["c",0,1.08,-1.05,1.92,-2.1,1.65],["c",-0.9,-0.21,-1.5,-1.14,-1.26,-2.04],["c",0.12,-0.63,0.63,-1.11,1.26,-1.26],["z"]],w:3.413,h:3.402}};
this.printSymbol=function(b,g,c,f){if(!a[c]){return null}var d=this.pathClone(a[c].d);d[0][1]+=b;d[0][2]+=g;var e=f.path().attr({path:d,stroke:"none",fill:"#000000"});return e};this.getPathForSymbol=function(b,g,e,d,c){d=d||1;c=c||1;if(!a[e]){return null}var f=this.pathClone(a[e].d);if(d!==1||c!==1){this.pathScale(f,d,c)}f[0][1]+=b;f[0][2]+=g;return f};this.getSymbolWidth=function(b){if(a[b]){return a[b].w}return 0};this.getSymbolHeight=function(b){if(a[b]){return a[b].h}return 0};this.getSymbolAlign=function(b){if(b.substring(0,7)==="scripts"&&b!=="scripts.roll"){return"center"}return"left"};this.pathClone=function(g){var d=[];for(var c=0,e=g.length;c<e;c++){d[c]=[];for(var b=0,f=g[c].length;b<f;b++){d[c][b]=g[c][b]}}return d};this.pathScale=function(h,f,d){for(var c=0,e=h.length;c<e;c++){var k=h[c];var b,g;for(b=1,g=k.length;b<g;b++){k[b]*=(b%2)?f:d}}};this.getYCorr=function(b){switch(b){case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"+":return -3;case"timesig.common":case"timesig.cut":return -1;case"flags.d32nd":return -1;case"flags.d64th":return -2;case"flags.u32nd":return 1;case"flags.u64th":return 3;case"rests.whole":return 1;case"rests.half":return -1;case"rests.8th":return -1;case"rests.quarter":return -2;case"rests.16th":return -1;case"rests.32nd":return -1;case"rests.64th":return -1;default:return 0}}};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.write){window.ABCJS.write={}}ABCJS.write.StaffGroupElement=function(){this.voices=[];this.staffs=[];this.stafflines=[]};ABCJS.write.StaffGroupElement.prototype.addVoice=function(c,b,a){this.voices[this.voices.length]=c;if(!this.staffs[b]){this.staffs[this.staffs.length]={top:0,highest:7,lowest:7};this.stafflines[this.stafflines.length]=a}c.staff=this.staffs[b]};ABCJS.write.StaffGroupElement.prototype.finished=function(){for(var a=0;a<this.voices.length;a++){if(!this.voices[a].layoutEnded()){return false}}return true};ABCJS.write.StaffGroupElement.prototype.layout=function(g,o,a){this.spacingunits=0;this.minspace=1000;var l=o.paddingleft*o.scale;var b=0;for(var e=0;e<this.voices.length;e++){if(this.voices[e].header){var p=o.paper.text(100*o.scale,-10*o.scale,this.voices[e].header).attr({"font-size":12*o.scale,"font-family":"serif","font-weight":"bold"});b=Math.max(b,p.getBBox().width);p.remove()}}l=l+b*(1/o.scale)*1.1;this.startx=l;var d=0;if(a){console.log("init layout")}for(e=0;e<this.voices.length;e++){this.voices[e].beginLayout(l)}while(!this.finished()){d=null;for(e=0;e<this.voices.length;e++){if(!this.voices[e].layoutEnded()&&(!d||this.voices[e].getDurationIndex()<d)){d=this.voices[e].getDurationIndex()}}if(a){console.log("currentduration: ",d)}var n=[];var m=[];for(e=0;e<this.voices.length;e++){if(this.voices[e].getDurationIndex()!==d){m.push(this.voices[e])}else{n.push(this.voices[e]);if(a){console.log("in: voice ",e)}}}var k=0;for(e=0;e<n.length;e++){if(n[e].nextx>l){l=n[e].nextx;k=n[e].spacingunits}}this.spacingunits+=k;this.minspace=Math.min(this.minspace,k);for(e=0;e<m.length;e++){if(m[e].spacingunits-=k){}}for(e=0;e<n.length;e++){var f=n[e].layoutOneItem(l,g);var q=f-l;if(q>0){l=f;for(var c=0;c<e;c++){n[c].shiftRight(q)}}}for(e=0;e<n.length;e++){var h=n[e];h.updateIndices()}}for(e=0;e<this.voices.length;e++){if(this.voices[e].nextx>l){l=this.voices[e].nextx;k=this.voices[e].spacingunits}}this.spacingunits+=k;this.w=l;for(e=0;e<this.voices.length;e++){this.voices[e].w=this.w}};ABCJS.write.StaffGroupElement.prototype.draw=function(e,h){this.y=h;for(var d=0;d<this.staffs.length;d++){var c=this.staffs[d].highest-((d===0)?20:15);var b=this.staffs[d].lowest-((d===this.staffs.length-1)?0:0);this.staffs[d].top=h;if(c>0){h+=c*ABCJS.write.spacing.STEP}this.staffs[d].y=h;h+=ABCJS.write.spacing.STAVEHEIGHT*0.9;if(b<0){h-=b*ABCJS.write.spacing.STEP}this.staffs[d].bottom=h}this.height=h-this.y;var g=0;for(d=0;d<this.voices.length;d++){this.voices[d].draw(e,g);g=this.voices[d].barbottom}if(this.staffs.length>1){e.y=this.staffs[0].y;var f=e.calcY(10);e.y=this.staffs[this.staffs.length-1].y;var a=e.calcY(2);e.printStem(this.startx,0.6,f,a)}for(d=0;d<this.staffs.length;d++){if(this.stafflines[d]===0){continue}e.y=this.staffs[d].y;if(this.stafflines[d]===undefined){this.stafflines[d]=5}e.printStave(this.startx,this.w,this.stafflines[d])}};ABCJS.write.VoiceElement=function(b,a){this.children=[];this.beams=[];this.otherchildren=[];this.w=0;this.duplicate=false;this.voicenumber=b;this.voicetotal=a};ABCJS.write.VoiceElement.prototype.addChild=function(a){this.children[this.children.length]=a};ABCJS.write.VoiceElement.prototype.addOther=function(a){if(a instanceof ABCJS.write.BeamElem){this.beams.push(a)}else{this.otherchildren.push(a)}};ABCJS.write.VoiceElement.prototype.updateIndices=function(){if(!this.layoutEnded()){this.durationindex+=this.children[this.i].duration;if(this.children[this.i].duration===0){this.durationindex=Math.round(this.durationindex*64)/64}this.i++;this.minx=this.nextminx}};ABCJS.write.VoiceElement.prototype.layoutEnded=function(){return(this.i>=this.children.length)};ABCJS.write.VoiceElement.prototype.getDurationIndex=function(){return this.durationindex-(this.children[this.i]&&(this.children[this.i].duration>0)?0:5e-7)};ABCJS.write.VoiceElement.prototype.beginLayout=function(a){this.i=0;this.durationindex=0;this.ii=this.children.length;this.startx=a;this.minx=a;this.nextminx=a;this.nextx=a;this.spacingunits=0};ABCJS.write.VoiceElement.prototype.layoutOneItem=function(a,d){var c=this.children[this.i];if(!c){return 0}var b=a-this.minx;if(b<c.getExtraWidth()){a+=c.getExtraWidth()-b}c.x=a;a+=(d*Math.sqrt(c.duration*8));this.nextminx=c.x+c.getMinWidth();if(this.i!==this.ii-1){this.nextminx+=c.minspacing}if(this.nextminx>a){a=this.nextminx;this.spacingunits=0}else{this.spacingunits=Math.sqrt(c.duration*8)}this.nextx=a;this.staff.highest=Math.max(c.top,this.staff.highest);this.staff.lowest=Math.min(c.bottom,this.staff.lowest);return c.x};ABCJS.write.VoiceElement.prototype.shiftRight=function(a){var b=this.children[this.i];if(!b){return}b.x+=a;this.nextminx+=a;this.nextx+=a};ABCJS.write.VoiceElement.prototype.draw=function(f,g){var d=this.w-1;f.y=this.staff.y;f.staffbottom=this.staff.bottom;this.barbottom=f.calcY(2);if(this.header){var e=12-(this.voicenumber+1)*(12/(this.voicetotal+1));var a=(this.startx-f.paddingleft)/2+f.paddingleft;a=a*f.scale;f.paper.text(a,f.calcY(e)*f.scale,this.header).attr({"font-size":12*f.scale,"font-family":"serif","font-weight":"bold"})}for(var b=0,c=this.children.length;b<c;b++){this.children[b].draw(f,(this.barto||b===c-1)?g:0)}window.ABCJS.parse.each(this.beams,function(h){h.draw(f)});window.ABCJS.parse.each(this.otherchildren,function(h){h.draw(f,this.startx+10,d)})};ABCJS.write.AbsoluteElement=function(c,b,a){this.abcelem=c;this.duration=b;this.minspacing=a||0;this.x=0;this.children=[];this.heads=[];this.extra=[];this.extraw=0;this.decs=[];this.w=0;this.right=[];this.invisible=false;this.bottom=7;this.top=7};ABCJS.write.AbsoluteElement.prototype.getMinWidth=function(){return this.w
};ABCJS.write.AbsoluteElement.prototype.getExtraWidth=function(){return -this.extraw};ABCJS.write.AbsoluteElement.prototype.addExtra=function(a){if(a.dx<this.extraw){this.extraw=a.dx}this.extra[this.extra.length]=a;this.addChild(a)};ABCJS.write.AbsoluteElement.prototype.addHead=function(a){if(a.dx<this.extraw){this.extraw=a.dx}this.heads[this.heads.length]=a;this.addRight(a)};ABCJS.write.AbsoluteElement.prototype.addRight=function(a){if(a.dx+a.w>this.w){this.w=a.dx+a.w}this.right[this.right.length]=a;this.addChild(a)};ABCJS.write.AbsoluteElement.prototype.addChild=function(a){a.parent=this;this.children[this.children.length]=a;this.pushTop(a.top);this.pushBottom(a.bottom)};ABCJS.write.AbsoluteElement.prototype.pushTop=function(a){this.top=Math.max(a,this.top)};ABCJS.write.AbsoluteElement.prototype.pushBottom=function(a){this.bottom=Math.min(a,this.bottom)};ABCJS.write.AbsoluteElement.prototype.draw=function(e,f){this.elemset=e.paper.set();if(this.invisible){return}e.beginGroup();for(var d=0;d<this.children.length;d++){this.elemset.push(this.children[d].draw(e,this.x,f))}this.elemset.push(e.endGroup());if(this.klass){this.setClass("mark","","#00ff00")}var c=this;this.elemset.mouseup(function(i){e.notifySelect(c)});this.abcelem.abselem=this;var h=ABCJS.write.spacing.STEP*e.scale;var g=function(){this.dy=0},b=function(j,i){i=Math.round(i/h)*h;this.translate(0,-this.dy);this.dy=i;this.translate(0,this.dy)},a=function(){var i=-Math.round(this.dy/h);c.abcelem.pitches[0].pitch+=i;c.abcelem.pitches[0].verticalPos+=i;e.notifyChange()};if(this.abcelem.el_type==="note"&&e.editable){this.elemset.drag(b,g,a)}};ABCJS.write.AbsoluteElement.prototype.isIE=
/*@cc_on!@*/
false;ABCJS.write.AbsoluteElement.prototype.setClass=function(d,e,b){this.elemset.attr({fill:b});if(!this.isIE){for(var c=0;c<this.elemset.length;c++){if(this.elemset[c][0].setAttribute){var a=this.elemset[c][0].getAttribute("class");if(!a){a=""}a=a.replace(e,"");a=a.replace(d,"");if(d.length>0){if(a.length>0&&a.charAt(a.length-1)!==" "){a+=" "}a+=d}this.elemset[c][0].setAttribute("class",a)}}}};ABCJS.write.AbsoluteElement.prototype.highlight=function(){this.setClass("note_selected","","#ff0000")};ABCJS.write.AbsoluteElement.prototype.unhighlight=function(){this.setClass("","note_selected","#000000")};ABCJS.write.RelativeElement=function(f,b,a,e,d){d=d||{};this.x=0;this.c=f;this.dx=b;this.w=a;this.pitch=e;this.scalex=d.scalex||1;this.scaley=d.scaley||1;this.type=d.type||"symbol";this.pitch2=d.pitch2;this.linewidth=d.linewidth;this.attributes=d.attributes;this.top=e+((d.extreme==="above")?7:0);this.bottom=e-((d.extreme==="below")?7:0)};ABCJS.write.RelativeElement.prototype.draw=function(b,a,c){this.x=a+this.dx;switch(this.type){case"symbol":if(this.c===null){return null}this.graphelem=b.printSymbol(this.x,this.pitch,this.c,this.scalex,this.scaley);break;case"debug":this.graphelem=b.debugMsg(this.x,this.c);break;case"debugLow":this.graphelem=b.printLyrics(this.x,this.c);break;case"text":this.graphelem=b.printText(this.x,this.pitch,this.c);break;case"bar":this.graphelem=b.printStem(this.x,this.linewidth,b.calcY(this.pitch),(c)?c:b.calcY(this.pitch2));break;case"stem":this.graphelem=b.printStem(this.x,this.linewidth,b.calcY(this.pitch),b.calcY(this.pitch2));break;case"ledger":this.graphelem=b.printStaveLine(this.x,this.x+this.w,this.pitch);break}if(this.scalex!==1&&this.graphelem){this.graphelem.scale(this.scalex,this.scaley,this.x,b.calcY(this.pitch))}if(this.attributes){this.graphelem.attr(this.attributes)}return this.graphelem};ABCJS.write.EndingElem=function(c,b,a){this.text=c;this.anchor1=b;this.anchor2=a};ABCJS.write.EndingElem.prototype.draw=function(c,d,b){var a;if(this.anchor1){d=this.anchor1.x+this.anchor1.w;a=ABCJS.write.sprintf("M %f %f L %f %f",d,c.y,d,c.y+10);c.printPath({path:a,stroke:"#000000",fill:"#000000"});c.printText(d+5*c.scale,18.5,this.text).attr({"font-size":""+10*c.scale+"px"})}if(this.anchor2){b=this.anchor2.x;a=ABCJS.write.sprintf("M %f %f L %f %f",b,c.y,b,c.y+10);c.printPath({path:a,stroke:"#000000",fill:"#000000"})}a=ABCJS.write.sprintf("M %f %f L %f %f",d,c.y,b,c.y);c.printPath({path:a,stroke:"#000000",fill:"#000000"})};ABCJS.write.TieElem=function(d,b,a,c){this.anchor1=d;this.anchor2=b;this.above=a;this.force=c};ABCJS.write.TieElem.prototype.draw=function(c,e,a){var d;var b;if(this.startlimitelem){e=this.startlimitelem.x+this.startlimitelem.w}if(this.endlimitelem){a=this.endlimitelem.x}if(!this.force&&this.anchor2&&this.anchor2.pitch===this.anchor2.top){this.above=true}if(this.anchor1){e=this.anchor1.x;d=this.above?this.anchor1.highestVert:this.anchor1.pitch;if(!this.anchor2){b=this.above?this.anchor1.highestVert:this.anchor1.pitch}}if(this.anchor2){a=this.anchor2.x;b=this.above?this.anchor2.highestVert:this.anchor2.pitch;if(!this.anchor1){d=this.above?this.anchor2.highestVert:this.anchor2.pitch}}c.drawArc(e,a,d,b,this.above)};ABCJS.write.DynamicDecoration=function(a,b){this.anchor=a;this.dec=b};ABCJS.write.DynamicDecoration.prototype.draw=function(d,f,a){var e=d.layouter.minY-7;var c=1;var b=1;d.printSymbol(this.anchor.x,e,this.dec,c,b)};ABCJS.write.CrescendoElem=function(c,b,a){this.anchor1=c;this.anchor2=b;this.dir=a};ABCJS.write.CrescendoElem.prototype.draw=function(b,c,a){if(this.dir==="<"){this.drawLine(b,0,-4);this.drawLine(b,0,4)}else{this.drawLine(b,-4,0);this.drawLine(b,4,0)}};ABCJS.write.CrescendoElem.prototype.drawLine=function(d,c,b){var e=d.layouter.minY-7;var a=ABCJS.write.sprintf("M %f %f L %f %f",this.anchor1.x,d.calcY(e)+c-4,this.anchor2.x,d.calcY(e)+b-4);d.printPath({path:a,stroke:"#000000"})};ABCJS.write.TripletElem=function(d,c,b,a){this.anchor1=c;this.anchor2=b;this.above=a;this.number=d};ABCJS.write.TripletElem.prototype.draw=function(d,g,c){if(this.anchor1&&this.anchor2){var f=this.above?16:-1;if(this.anchor1.parent.beam&&this.anchor1.parent.beam===this.anchor2.parent.beam){var b=this.anchor1.parent.beam;this.above=b.asc;f=b.pos}else{this.drawLine(d,d.calcY(f))}var e=this.anchor1.x+this.anchor2.x;var a=0;if(b){if(this.above){e+=(this.anchor2.w+this.anchor1.w);a=4}else{a=-4}}else{e+=this.anchor2.w}d.printText(e/2,f+a,this.number,"middle").attr({"font-size":"10px","font-style":"italic"})}};ABCJS.write.TripletElem.prototype.drawLine=function(c,e){var b;var d=this.anchor1.x;b=ABCJS.write.sprintf("M %f %f L %f %f",d,e,d,e+5);c.printPath({path:b,stroke:"#000000"});var a=this.anchor2.x+this.anchor2.w;b=ABCJS.write.sprintf("M %f %f L %f %f",a,e,a,e+5);c.printPath({path:b,stroke:"#000000"});b=ABCJS.write.sprintf("M %f %f L %f %f",d,e,(d+a)/2-5,e);c.printPath({path:b,stroke:"#000000"});b=ABCJS.write.sprintf("M %f %f L %f %f",(d+a)/2+5,e,a,e);c.printPath({path:b,stroke:"#000000"})};ABCJS.write.BeamElem=function(a,b){this.isflat=(b);this.isgrace=(a&&a==="grace");this.forceup=(a&&a==="up");this.forcedown=(a&&a==="down");this.elems=[];this.total=0;this.dy=(this.asc)?ABCJS.write.spacing.STEP*1.2:-ABCJS.write.spacing.STEP*1.2;if(this.isgrace){this.dy=this.dy*0.4}this.allrests=true};ABCJS.write.BeamElem.prototype.add=function(a){var b=a.abcelem.averagepitch;
if(b===undefined){return}this.allrests=this.allrests&&a.abcelem.rest;a.beam=this;this.elems.push(a);this.total+=b;if(!this.min||a.abcelem.minpitch<this.min){this.min=a.abcelem.minpitch}if(!this.max||a.abcelem.maxpitch>this.max){this.max=a.abcelem.maxpitch}};ABCJS.write.BeamElem.prototype.average=function(){try{return this.total/this.elems.length}catch(a){return 0}};ABCJS.write.BeamElem.prototype.draw=function(a){if(this.elems.length===0||this.allrests){return}this.drawBeam(a);this.drawStems(a)};ABCJS.write.BeamElem.prototype.calcDir=function(){var a=this.average();this.asc=(this.forceup||this.isgrace||a<6)&&(!this.forcedown);return this.asc};ABCJS.write.BeamElem.prototype.drawBeam=function(i){var b=this.average();var h=(this.isgrace)?5:7;this.calcDir();var a=this.asc?5:8;this.pos=Math.round(this.asc?Math.max(b+h,this.max+a):Math.min(b-h,this.min-a));var f=this.elems[0].abcelem.averagepitch-this.elems[this.elems.length-1].abcelem.averagepitch;if(this.isflat){f=0}var e=this.elems.length/2;if(f>e){f=e}if(f<-e){f=-e}this.starty=i.calcY(this.pos+Math.floor(f/2));this.endy=i.calcY(this.pos+Math.floor(-f/2));var d=this.elems[0].heads[(this.asc)?0:this.elems[0].heads.length-1];var g=this.elems[this.elems.length-1].heads[(this.asc)?0:this.elems[this.elems.length-1].heads.length-1];this.startx=d.x;if(this.asc){this.startx+=d.w-0.6}this.endx=g.x;if(this.asc){this.endx+=g.w}if(this.asc&&this.pos<6){this.starty=i.calcY(6);this.endy=i.calcY(6)}else{if(!this.asc&&this.pos>6){this.starty=i.calcY(6);this.endy=i.calcY(6)}}var c="M"+this.startx+" "+this.starty+" L"+this.endx+" "+this.endy+"L"+this.endx+" "+(this.endy+this.dy)+" L"+this.startx+" "+(this.starty+this.dy)+"z";i.printPath({path:c,stroke:"none",fill:"#000000"})};ABCJS.write.BeamElem.prototype.drawStems=function(r){var a=[];r.beginGroup();for(var g=0,q=this.elems.length;g<q;g++){if(this.elems[g].abcelem.rest){continue}var m=this.elems[g].heads[(this.asc)?0:this.elems[g].heads.length-1];var e=(this.isgrace)?1/3:1/5;var b=m.pitch+((this.asc)?e:-e);var o=r.calcY(b);var p=m.x+((this.asc)?m.w:0);var l=this.getBarYAt(p);var s=(this.asc)?-0.6:0.6;r.printStem(p,s,o,l);var n=(this.asc)?1.5*ABCJS.write.spacing.STEP:-1.5*ABCJS.write.spacing.STEP;if(this.isgrace){n=n*2/3}for(var c=ABCJS.write.getDurlog(this.elems[g].abcelem.duration);c<-3;c++){if(a[-4-c]){a[-4-c].single=false}else{a[-4-c]={x:p+((this.asc)?-0.6:0),y:l+n*(-4-c+1),durlog:c,single:true}}}for(var f=a.length-1;f>=0;f--){if(g===q-1||ABCJS.write.getDurlog(this.elems[g+1].abcelem.duration)>(-f-4)){var k=p;var h=l+n*(f+1);if(a[f].single){k=(g===0)?p+5:p-5;h=this.getBarYAt(k)+n*(f+1)}var d="M"+a[f].x+" "+a[f].y+" L"+k+" "+h+"L"+k+" "+(h+this.dy)+" L"+a[f].x+" "+(a[f].y+this.dy)+"z";r.printPath({path:d,stroke:"none",fill:"#000000"});a=a.slice(0,f)}}}r.endGroup()};ABCJS.write.BeamElem.prototype.getBarYAt=function(a){return this.starty+(this.endy-this.starty)/(this.endx-this.startx)*(a-this.startx)};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.write){window.ABCJS.write={}}ABCJS.write.getDuration=function(a){var b=0;if(a.duration){b=a.duration}return b};ABCJS.write.getDurlog=function(a){if(a===undefined){return 0}return Math.floor(Math.log(a)/Math.log(2))};ABCJS.write.Layout=function(b,a){this.glyphs=b;this.isBagpipes=a;this.chartable={rest:{0:"rests.whole",1:"rests.half",2:"rests.quarter",3:"rests.8th",4:"rests.16th",5:"rests.32nd",6:"rests.64th",7:"rests.128th"},note:{"-1":"noteheads.dbl",0:"noteheads.whole",1:"noteheads.half",2:"noteheads.quarter",3:"noteheads.quarter",4:"noteheads.quarter",5:"noteheads.quarter",6:"noteheads.quarter"},uflags:{3:"flags.u8th",4:"flags.u16th",5:"flags.u32nd",6:"flags.u64th"},dflags:{3:"flags.d8th",4:"flags.d16th",5:"flags.d32nd",6:"flags.d64th"}};this.slurs={};this.ties=[];this.slursbyvoice={};this.tiesbyvoice={};this.endingsbyvoice={};this.s=0;this.v=0;this.stafflines=5;this.tripletmultiplier=1};ABCJS.write.Layout.prototype.getCurrentVoiceId=function(){return"s"+this.s+"v"+this.v};ABCJS.write.Layout.prototype.pushCrossLineElems=function(){this.slursbyvoice[this.getCurrentVoiceId()]=this.slurs;this.tiesbyvoice[this.getCurrentVoiceId()]=this.ties;this.endingsbyvoice[this.getCurrentVoiceId()]=this.partstartelem};ABCJS.write.Layout.prototype.popCrossLineElems=function(){this.slurs=this.slursbyvoice[this.getCurrentVoiceId()]||{};this.ties=this.tiesbyvoice[this.getCurrentVoiceId()]||[];this.partstartelem=this.endingsbyvoice[this.getCurrentVoiceId()]};ABCJS.write.Layout.prototype.getElem=function(){if(this.abcline.length<=this.pos){return null}return this.abcline[this.pos]};ABCJS.write.Layout.prototype.getNextElem=function(){if(this.abcline.length<=this.pos+1){return null}return this.abcline[this.pos+1]};ABCJS.write.Layout.prototype.printABCLine=function(a){this.minY=2;this.staffgroup=new ABCJS.write.StaffGroupElement();for(this.s=0;this.s<a.length;this.s++){this.printABCStaff(a[this.s])}return this.staffgroup};ABCJS.write.Layout.prototype.printABCStaff=function(a){var b="";if(a.bracket){b+="bracket "+a.bracket+" "}if(a.brace){b+="brace "+a.brace+" "}for(this.v=0;this.v<a.voices.length;this.v++){this.voice=new ABCJS.write.VoiceElement(this.v,a.voices.length);if(this.v===0){this.voice.barfrom=(a.connectBarLines==="start"||a.connectBarLines==="continue");this.voice.barto=(a.connectBarLines==="continue"||a.connectBarLines==="end")}else{this.voice.duplicate=true}if(a.title&&a.title[this.v]){this.voice.header=a.title[this.v]}this.voice.addChild(this.printClef(a.clef));this.voice.addChild(this.printKeySignature(a.key));if(a.meter){this.voice.addChild(this.printTimeSignature(a.meter))}this.printABCVoice(a.voices[this.v]);this.staffgroup.addVoice(this.voice,this.s,this.stafflines)}};ABCJS.write.Layout.prototype.printABCVoice=function(b){this.popCrossLineElems();this.stemdir=(this.isBagpipes)?"down":null;this.abcline=b;if(this.partstartelem){this.partstartelem=new ABCJS.write.EndingElem("",null,null);this.voice.addOther(this.partstartelem)}for(var a in this.slurs){if(this.slurs.hasOwnProperty(a)){this.slurs[a]=new ABCJS.write.TieElem(null,null,this.slurs[a].above,this.slurs[a].force);this.voice.addOther(this.slurs[a])}}for(var c=0;c<this.ties.length;c++){this.ties[c]=new ABCJS.write.TieElem(null,null,this.ties[c].above,this.ties[c].force);this.voice.addOther(this.ties[c])}for(this.pos=0;this.pos<this.abcline.length;this.pos++){var d=this.printABCElement();for(c=0;c<d.length;c++){this.voice.addChild(d[c])}}this.pushCrossLineElems()};ABCJS.write.Layout.prototype.printABCElement=function(){var d=[];var b=this.getElem();switch(b.el_type){case"note":d=this.printBeam();break;case"bar":d[0]=this.printBarLine(b);if(this.voice.duplicate){d[0].invisible=true}break;case"meter":d[0]=this.printTimeSignature(b);if(this.voice.duplicate){d[0].invisible=true}break;case"clef":d[0]=this.printClef(b);if(this.voice.duplicate){d[0].invisible=true}break;case"key":d[0]=this.printKeySignature(b);if(this.voice.duplicate){d[0].invisible=true}break;case"stem":this.stemdir=b.direction;break;
case"part":var a=new ABCJS.write.AbsoluteElement(b,0,0);a.addChild(new ABCJS.write.RelativeElement(b.title,0,0,18,{type:"text",attributes:{"font-weight":"bold","font-size":""+16*this.printer.scale+"px","font-family":"serif"}}));d[0]=a;break;default:var c=new ABCJS.write.AbsoluteElement(b,0,0);c.addChild(new ABCJS.write.RelativeElement("element type "+b.el_type,0,0,0,{type:"debug"}));d[0]=c}return d};ABCJS.write.Layout.prototype.printBeam=function(){var e=[];if(this.getElem().startBeam&&!this.getElem().endBeam){var f=new ABCJS.write.BeamElem(this.stemdir);var b=this.pos;var c;while(this.getElem()){c=this.printNote(this.getElem(),true,true);f.add(c);if(this.getElem().endBeam){break}this.pos++}var a=f.calcDir();this.pos=b;f=new ABCJS.write.BeamElem(a?"up":"down");var d=this.stemdir;this.stemdir=a?"up":"down";while(this.getElem()){c=this.printNote(this.getElem(),true);e.push(c);f.add(c);if(this.getElem().endBeam){break}this.pos++}this.stemdir=d;this.voice.addOther(f)}else{e[0]=this.printNote(this.getElem())}return e};ABCJS.write.sortPitch=function(c){var a;do{a=true;for(var d=0;d<c.pitches.length-1;d++){if(c.pitches[d].pitch>c.pitches[d+1].pitch){a=false;var b=c.pitches[d];c.pitches[d]=c.pitches[d+1];c.pitches[d+1]=b}}}while(!a)};ABCJS.write.Layout.prototype.printNote=function(L,d,S){var o=null;var a=null;this.roomtaken=0;this.roomtakenright=0;var D=0;var U="";var B=null;var q=[];var I,O,l;var b,R,Q,e;var r=ABCJS.write.getDuration(L);if(r===0){r=0.25;d=true}var v=Math.floor(Math.log(r)/Math.log(2));var W=0;for(var f=Math.pow(2,v),P=f/2;f<r;W++,f+=P,P/=2){}if(L.startTriplet){if(L.startTriplet===2){this.tripletmultiplier=3/2}else{this.tripletmultiplier=(L.startTriplet-1)/L.startTriplet}}var g=new ABCJS.write.AbsoluteElement(L,r*this.tripletmultiplier,1);if(L.rest){var k=7;if(this.stemdir==="down"){k=3}if(this.stemdir==="up"){k=11}switch(L.rest.type){case"rest":U=this.chartable.rest[-v];L.averagepitch=k;L.minpitch=k;L.maxpitch=k;break;case"invisible":case"spacer":U=""}if(!S){o=this.printNoteHead(g,U,{verticalPos:k},null,0,-this.roomtaken,null,W,0,1)}if(o){g.addHead(o)}this.roomtaken+=this.accidentalshiftx;this.roomtakenright=Math.max(this.roomtakenright,this.dotshiftx)}else{ABCJS.write.sortPitch(L);var n=0;for(I=0,l=L.pitches.length;I<l;I++){n+=L.pitches[I].verticalPos}L.averagepitch=n/L.pitches.length;L.minpitch=L.pitches[0].verticalPos;this.minY=Math.min(L.minpitch,this.minY);L.maxpitch=L.pitches[L.pitches.length-1].verticalPos;var V=(L.averagepitch>=6)?"down":"up";if(this.stemdir){V=this.stemdir}for(I=(V==="down")?L.pitches.length-2:1;(V==="down")?I>=0:I<L.pitches.length;I=(V==="down")?I-1:I+1){var w=L.pitches[(V==="down")?I+1:I-1];var E=L.pitches[I];var F=(V==="down")?w.pitch-E.pitch:E.pitch-w.pitch;if(F<=1&&!w.printer_shift){E.printer_shift=(F)?"different":"same";if(E.verticalPos>11||E.verticalPos<1){q.push(E.verticalPos-(E.verticalPos%2))}if(V==="down"){this.roomtaken=this.glyphs.getSymbolWidth(this.chartable.note[-v])+2}else{D=this.glyphs.getSymbolWidth(this.chartable.note[-v])+2}}}this.accidentalSlot=[];for(I=0;I<L.pitches.length;I++){if(!d){if((V==="down"&&I!==0)||(V==="up"&&I!==l-1)){B=null}else{B=this.chartable[(V==="down")?"dflags":"uflags"][-v]}U=this.chartable.note[-v]}else{U="noteheads.quarter"}L.pitches[I].highestVert=L.pitches[I].verticalPos;var j=(this.stemdir==="up"||V==="up")&&I===0;var J=(this.stemdir==="down"||V==="down")&&I===l-1;if(!S&&(j||J)){if(L.startSlur||l===1){L.pitches[I].highestVert=L.pitches[l-1].verticalPos;if(this.stemdir==="up"||V==="up"){L.pitches[I].highestVert+=6}}if(L.startSlur){if(!L.pitches[I].startSlur){L.pitches[I].startSlur=[]}for(O=0;O<L.startSlur.length;O++){L.pitches[I].startSlur.push(L.startSlur[O])}}if(!S&&L.endSlur){L.pitches[I].highestVert=L.pitches[l-1].verticalPos;if(this.stemdir==="up"||V==="up"){L.pitches[I].highestVert+=6}if(!L.pitches[I].endSlur){L.pitches[I].endSlur=[]}for(O=0;O<L.endSlur.length;O++){L.pitches[I].endSlur.push(L.endSlur[O])}}}if(!S){o=this.printNoteHead(g,U,L.pitches[I],V,0,-this.roomtaken,B,W,D,1)}if(o){g.addHead(o)}this.roomtaken+=this.accidentalshiftx;this.roomtakenright=Math.max(this.roomtakenright,this.dotshiftx)}if(!d&&v<=-1){R=(V==="down")?L.minpitch-7:L.minpitch+1/3;if(R>6&&!this.stemdir){R=6}Q=(V==="down")?L.maxpitch-1/3:L.maxpitch+7;if(Q<6&&!this.stemdir){Q=6}e=(V==="down"||g.heads.length===0)?0:g.heads[0].w;b=(V==="down")?1:-1;g.addExtra(new ABCJS.write.RelativeElement(null,e,0,R,{type:"stem",pitch2:Q,linewidth:b}));this.minY=Math.min(R,this.minY);this.minY=Math.min(Q,this.minY)}}if(L.lyric!==undefined){var K="";window.ABCJS.parse.each(L.lyric,function(c){K+=c.syllable+c.divider+"\n"});g.addRight(new ABCJS.write.RelativeElement(K,0,K.length*5,0,{type:"debugLow"}))}if(!S&&L.gracenotes!==undefined){var u=3/5;var h=null;if(L.gracenotes.length>1){h=new ABCJS.write.BeamElem("grace",this.isBagpipes)}var T=[];for(O=L.gracenotes.length-1;O>=0;O--){this.roomtaken+=10;T[O]=this.roomtaken;if(L.gracenotes[O].accidental){this.roomtaken+=7}}for(O=0;O<L.gracenotes.length;O++){var t=L.gracenotes[O].verticalPos;B=(h)?null:this.chartable.uflags[(this.isBagpipes)?5:3];a=this.printNoteHead(g,"noteheads.quarter",L.gracenotes[O],"up",-T[O],-T[O],B,0,0,u);g.addExtra(a);if(L.gracenotes[O].acciaccatura){var z=L.gracenotes[O].verticalPos+7*u;var N=h?5:6;g.addRight(new ABCJS.write.RelativeElement("flags.ugrace",-T[O]+N,0,z,{scalex:u,scaley:u}))}if(h){var m={heads:[a],abcelem:{averagepitch:t,minpitch:t,maxpitch:t},duration:(this.isBagpipes)?1/32:1/16};h.add(m)}else{R=t+1/3*u;Q=t+7*u;e=a.dx+a.w;b=-0.6;g.addExtra(new ABCJS.write.RelativeElement(null,e,0,R,{type:"stem",pitch2:Q,linewidth:b}))}if(O===0&&!this.isBagpipes&&!(L.rest&&(L.rest.type==="spacer"||L.rest.type==="invisible"))){this.voice.addOther(new ABCJS.write.TieElem(a,o,false,true))}}if(h){this.voice.addOther(h)}}if(!S&&L.decoration){var s=this.printDecoration(L.decoration,L.maxpitch,(o)?o.w:0,g,this.roomtaken,V,L.minpitch);if(s){g.klass="mark"}}if(L.barNumber){g.addChild(new ABCJS.write.RelativeElement(L.barNumber,-10,0,0,{type:"debug"}))}for(O=L.maxpitch;O>11;O--){if(O%2===0&&!L.rest){g.addChild(new ABCJS.write.RelativeElement(null,-2,this.glyphs.getSymbolWidth(U)+4,O,{type:"ledger"}))}}for(O=L.minpitch;O<1;O++){if(O%2===0&&!L.rest){g.addChild(new ABCJS.write.RelativeElement(null,-2,this.glyphs.getSymbolWidth(U)+4,O,{type:"ledger"}))}}for(O=0;O<q.length;O++){var C=this.glyphs.getSymbolWidth(U);if(V==="down"){C=-C}g.addChild(new ABCJS.write.RelativeElement(null,C-2,this.glyphs.getSymbolWidth(U)+4,q[O],{type:"ledger"}))}if(L.chord!==undefined){for(O=0;O<L.chord.length;O++){var H=0;var G=16;switch(L.chord[O].position){case"left":this.roomtaken+=7;H=-this.roomtaken;G=L.averagepitch;g.addExtra(new ABCJS.write.RelativeElement(L.chord[O].name,H,this.glyphs.getSymbolWidth(L.chord[O].name[0])+4,G,{type:"text"}));break;case"right":this.roomtakenright+=4;H=this.roomtakenright;G=L.averagepitch;g.addRight(new ABCJS.write.RelativeElement(L.chord[O].name,H,this.glyphs.getSymbolWidth(L.chord[O].name[0])+4,G,{type:"text"}));
break;case"below":G=L.minpitch-4;if(G>-3){G=-3}var M=L.chord[O].name.split("\n");for(var A=0;A<M.length;A++){g.addChild(new ABCJS.write.RelativeElement(M[A],H,0,G,{type:"text"}));G-=3}break;default:if(L.chord[O].rel_position){g.addChild(new ABCJS.write.RelativeElement(L.chord[O].name,H+L.chord[O].rel_position.x,0,L.minpitch+L.chord[O].rel_position.y/ABCJS.write.spacing.STEP,{type:"text"}))}else{g.addChild(new ABCJS.write.RelativeElement(L.chord[O].name,H,0,G,{type:"text"}))}}}}if(L.startTriplet){this.triplet=new ABCJS.write.TripletElem(L.startTriplet,o,null,true);if(!S){this.voice.addOther(this.triplet)}}if(L.endTriplet&&this.triplet){this.triplet.anchor2=o;this.triplet=null;this.tripletmultiplier=1}return g};ABCJS.write.Layout.prototype.printNoteHead=function(m,z,A,o,h,e,u,p,x,B){var k=A.verticalPos;var d;var v;this.accidentalshiftx=0;this.dotshiftx=0;if(z===undefined){m.addChild(new ABCJS.write.RelativeElement("pitch is undefined",0,0,0,{type:"debug"}))}else{if(z===""){d=new ABCJS.write.RelativeElement(null,0,0,k)}else{var n=h;if(A.printer_shift){var r=(A.printer_shift==="same")?1:0;n=(o==="down")?-this.glyphs.getSymbolWidth(z)*B+r:this.glyphs.getSymbolWidth(z)*B-r}d=new ABCJS.write.RelativeElement(z,n,this.glyphs.getSymbolWidth(z)*B,k,{scalex:B,scaley:B,extreme:((o==="down")?"below":"above")});if(u){var g=k+((o==="down")?-7:7)*B;if(B===1&&(o==="down")?(g>6):(g<6)){g=6}var q=(o==="down")?h:h+d.w-0.6;m.addRight(new ABCJS.write.RelativeElement(u,q,this.glyphs.getSymbolWidth(u)*B,g,{scalex:B,scaley:B}))}this.dotshiftx=d.w+x-2+5*p;for(;p>0;p--){var a=(1-Math.abs(k)%2);m.addRight(new ABCJS.write.RelativeElement("dots.dot",d.w+x-2+5*p,this.glyphs.getSymbolWidth("dots.dot"),k+a))}}}if(d){d.highestVert=A.highestVert}if(A.accidental){var b;switch(A.accidental){case"quartersharp":b="accidentals.halfsharp";break;case"dblsharp":b="accidentals.dblsharp";break;case"sharp":b="accidentals.sharp";break;case"quarterflat":b="accidentals.halfflat";break;case"flat":b="accidentals.flat";break;case"dblflat":b="accidentals.dblflat";break;case"natural":b="accidentals.nat"}var l=false;var w=e;for(var s=0;s<this.accidentalSlot.length;s++){if(k-this.accidentalSlot[s][0]>=6){this.accidentalSlot[s][0]=k;w=this.accidentalSlot[s][1];l=true;break}}if(l===false){w-=(this.glyphs.getSymbolWidth(b)*B+2);this.accidentalSlot.push([k,w]);this.accidentalshiftx=(this.glyphs.getSymbolWidth(b)*B+2)}m.addExtra(new ABCJS.write.RelativeElement(b,w,this.glyphs.getSymbolWidth(b),k,{scalex:B,scaley:B}))}if(A.endTie){if(this.ties[0]){this.ties[0].anchor2=d;this.ties=this.ties.slice(1,this.ties.length)}}if(A.startTie){var t=new ABCJS.write.TieElem(d,null,(this.stemdir==="down"||o==="down")&&this.stemdir!=="up",(this.stemdir==="down"||this.stemdir==="up"));this.ties[this.ties.length]=t;this.voice.addOther(t)}if(A.endSlur){for(v=0;v<A.endSlur.length;v++){var y=A.endSlur[v];var f;if(this.slurs[y]){f=this.slurs[y].anchor2=d;delete this.slurs[y]}else{f=new ABCJS.write.TieElem(null,d,o==="down",(this.stemdir==="up"||o==="down")&&this.stemdir!=="down",this.stemdir);this.voice.addOther(f)}if(this.startlimitelem){f.startlimitelem=this.startlimitelem}}}if(A.startSlur){for(v=0;v<A.startSlur.length;v++){var y=A.startSlur[v].label;var f=new ABCJS.write.TieElem(d,null,(this.stemdir==="down"||o==="down")&&this.stemdir!=="up",false);this.slurs[y]=f;this.voice.addOther(f)}}return d};ABCJS.write.Layout.prototype.printDecoration=function(l,k,t,n,a,r,f){var q;var v;var j;var y;var s=[];var z=(k>9)?k+3:12;var h;var o=false;var m=this.minY-4;var x;a=a||0;if(k===5){z=14}var g=false;for(x=0;x<l.length;x++){if(l[x]==="staccato"||l[x]==="tenuto"){var u="scripts."+l[x];h=(r==="down")?k+2:f-2;switch(h){case 2:case 4:case 6:case 8:case 10:if(r==="up"){h--}else{h++}break}if(k>9){z++}var c=t/2;if(this.glyphs.getSymbolAlign(u)!=="center"){c-=(this.glyphs.getSymbolWidth(q)/2)}n.addChild(new ABCJS.write.RelativeElement(u,c,this.glyphs.getSymbolWidth(u),h))}if(l[x]==="slide"&&n.heads[0]){h=n.heads[0].pitch;var d=new ABCJS.write.RelativeElement("",-a-15,0,h-1);var b=new ABCJS.write.RelativeElement("",-a-5,0,h+1);n.addChild(d);n.addChild(b);this.voice.addOther(new ABCJS.write.TieElem(d,b,false))}}for(x=0;x<l.length;x++){o=false;switch(l[x]){case"trill":q="scripts.trill";break;case"roll":q="scripts.roll";break;case"irishroll":q="scripts.roll";break;case"marcato":q="scripts.umarcato";break;case"marcato2":q="scriopts.dmarcato";break;case"turn":q="scripts.turn";break;case"uppermordent":q="scripts.prall";break;case"mordent":case"lowermordent":q="scripts.mordent";break;case"staccato":case"tenuto":case"slide":continue;case"downbow":q="scripts.downbow";break;case"upbow":q="scripts.upbow";break;case"fermata":q="scripts.ufermata";break;case"invertedfermata":o=true;q="scripts.dfermata";break;case"breath":q=",";break;case"accent":q="scripts.sforzato";break;case"umarcato":q="scripts.umarcato";break;case"coda":q="scripts.coda";break;case"segno":q="scripts.segno";break;case"/":v=["flags.ugrace",1];continue;case"//":v=["flags.ugrace",2];continue;case"///":v=["flags.ugrace",3];continue;case"////":v=["flags.ugrace",4];continue;case"p":case"mp":case"pp":case"ppp":case"pppp":case"f":case"ff":case"fff":case"ffff":case"sfz":case"mf":var w=new ABCJS.write.DynamicDecoration(n,l[x]);this.voice.addOther(w);continue;case"mark":g=true;continue;case"diminuendo(":ABCJS.write.Layout.prototype.startDiminuendoX=n;j=undefined;continue;case"diminuendo)":j={start:ABCJS.write.Layout.prototype.startDiminuendoX,stop:n};ABCJS.write.Layout.prototype.startDiminuendoX=undefined;continue;case"crescendo(":ABCJS.write.Layout.prototype.startCrescendoX=n;y=undefined;continue;case"crescendo)":y={start:ABCJS.write.Layout.prototype.startCrescendoX,stop:n};ABCJS.write.Layout.prototype.startCrescendoX=undefined;continue;default:s[s.length]=l[x];continue}if(o){h=m;m-=4}else{h=z;z+=3}var c=t/2;if(this.glyphs.getSymbolAlign(q)!=="center"){c-=(this.glyphs.getSymbolWidth(q)/2)}n.addChild(new ABCJS.write.RelativeElement(q,c,this.glyphs.getSymbolWidth(q),h))}if(v){h=(r==="down")?k+1:k+9;c=t/2;c+=(r==="down")?-5:3;for(var e=0;e<v[1];e++){h-=1;n.addChild(new ABCJS.write.RelativeElement(v[0],c,this.glyphs.getSymbolWidth(v[0]),h))}}if(j){var p=new ABCJS.write.CrescendoElem(j.start,j.stop,">");this.voice.addOther(p)}if(y){var A=new ABCJS.write.CrescendoElem(y.start,y.stop,"<");this.voice.addOther(A)}if(s.length>0){n.addChild(new ABCJS.write.RelativeElement(s.join(","),0,0,0,{type:"debug"}))}return g};ABCJS.write.Layout.prototype.printBarLine=function(c){var i=new ABCJS.write.AbsoluteElement(c,0,10);var d=null;var j=0;var a=(c.type==="bar_right_repeat"||c.type==="bar_dbl_repeat");var e=(c.type!=="bar_left_repeat"&&c.type!=="bar_thick_thin"&&c.type!=="bar_invisible");var f=(c.type==="bar_right_repeat"||c.type==="bar_dbl_repeat"||c.type==="bar_left_repeat"||c.type==="bar_thin_thick"||c.type==="bar_thick_thin");var g=(c.type==="bar_left_repeat"||c.type==="bar_thick_thin"||c.type==="bar_thin_thin"||c.type==="bar_dbl_repeat");
var b=(c.type==="bar_left_repeat"||c.type==="bar_dbl_repeat");if(a||b){for(var h in this.slurs){if(this.slurs.hasOwnProperty(h)){this.slurs[h].endlimitelem=i}}this.startlimitelem=i}if(a){i.addRight(new ABCJS.write.RelativeElement("dots.dot",j,1,7));i.addRight(new ABCJS.write.RelativeElement("dots.dot",j,1,5));j+=6}if(e){d=new ABCJS.write.RelativeElement(null,j,1,2,{type:"bar",pitch2:10,linewidth:0.6});i.addRight(d)}if(c.type==="bar_invisible"){d=new ABCJS.write.RelativeElement(null,j,1,2,{type:"none",pitch2:10,linewidth:0.6});i.addRight(d)}if(c.decoration){this.printDecoration(c.decoration,12,(f)?3:1,i,0,"down",2)}if(f){j+=4;d=new ABCJS.write.RelativeElement(null,j,4,2,{type:"bar",pitch2:10,linewidth:4});i.addRight(d);j+=5}if(this.partstartelem&&c.endEnding){this.partstartelem.anchor2=d;this.partstartelem=null}if(g){j+=3;d=new ABCJS.write.RelativeElement(null,j,1,2,{type:"bar",pitch2:10,linewidth:0.6});i.addRight(d)}if(b){j+=3;i.addRight(new ABCJS.write.RelativeElement("dots.dot",j,1,7));i.addRight(new ABCJS.write.RelativeElement("dots.dot",j,1,5))}if(c.startEnding){this.partstartelem=new ABCJS.write.EndingElem(c.startEnding,d,null);this.voice.addOther(this.partstartelem)}return i};ABCJS.write.Layout.prototype.printClef=function(e){var f="clefs.G";var c=0;var d=new ABCJS.write.AbsoluteElement(e,0,10);switch(e.type){case"treble":break;case"tenor":f="clefs.C";break;case"alto":f="clefs.C";break;case"bass":f="clefs.F";break;case"treble+8":c=1;break;case"tenor+8":f="clefs.C";c=1;break;case"bass+8":f="clefs.F";c=1;break;case"alto+8":f="clefs.C";c=1;break;case"treble-8":c=-1;break;case"tenor-8":f="clefs.C";c=-1;break;case"bass-8":f="clefs.F";c=-1;break;case"alto-8":f="clefs.C";c=-1;break;case"none":f="";break;case"perc":f="clefs.perc";break;default:d.addChild(new ABCJS.write.RelativeElement("clef="+e.type,0,0,0,{type:"debug"}))}var b=10;if(f!==""){d.addRight(new ABCJS.write.RelativeElement(f,b,this.glyphs.getSymbolWidth(f),e.clefPos))}if(c!==0){var g=2/3;var a=(this.glyphs.getSymbolWidth(f)-this.glyphs.getSymbolWidth("8")*g)/2;d.addRight(new ABCJS.write.RelativeElement("8",b+a,this.glyphs.getSymbolWidth("8")*g,(c>0)?16:-2,{scalex:g,scaley:g}))}if(e.stafflines===0){this.stafflines=0}else{this.stafflines=e.stafflines}return d};ABCJS.write.Layout.prototype.printKeySignature=function(c){var b=new ABCJS.write.AbsoluteElement(c,0,10);var a=0;if(c.accidentals){window.ABCJS.parse.each(c.accidentals,function(e){var d=(e.acc==="sharp")?"accidentals.sharp":(e.acc==="natural")?"accidentals.nat":"accidentals.flat";b.addRight(new ABCJS.write.RelativeElement(d,a,this.glyphs.getSymbolWidth(d),e.verticalPos));a+=this.glyphs.getSymbolWidth(d)+2},this)}this.startlimitelem=b;return b};ABCJS.write.Layout.prototype.printTimeSignature=function(c){var b=new ABCJS.write.AbsoluteElement(c,0,20);if(c.type==="specified"){for(var a=0;a<c.value.length;a++){if(a!==0){b.addRight(new ABCJS.write.RelativeElement("+",a*20-9,this.glyphs.getSymbolWidth("+"),7))}if(c.value[a].den){b.addRight(new ABCJS.write.RelativeElement(c.value[a].num,a*20,this.glyphs.getSymbolWidth(c.value[a].num.charAt(0))*c.value[a].num.length,9));b.addRight(new ABCJS.write.RelativeElement(c.value[a].den,a*20,this.glyphs.getSymbolWidth(c.value[a].den.charAt(0))*c.value[a].den.length,5))}else{b.addRight(new ABCJS.write.RelativeElement(c.value[a].num,a*20,this.glyphs.getSymbolWidth(c.value[a].num.charAt(0))*c.value[a].num.length,7))}}}else{if(c.type==="common_time"){b.addRight(new ABCJS.write.RelativeElement("timesig.common",0,this.glyphs.getSymbolWidth("timesig.common"),7))}else{if(c.type==="cut_time"){b.addRight(new ABCJS.write.RelativeElement("timesig.cut",0,this.glyphs.getSymbolWidth("timesig.cut"),7))}}}this.startlimitelem=b;return b};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.write){window.ABCJS.write={}}ABCJS.write.spacing=function(){};ABCJS.write.spacing.FONTEM=360;ABCJS.write.spacing.FONTSIZE=30;ABCJS.write.spacing.STEP=ABCJS.write.spacing.FONTSIZE*93/720;ABCJS.write.spacing.SPACE=10;ABCJS.write.spacing.TOPNOTE=20;ABCJS.write.spacing.STAVEHEIGHT=100;ABCJS.write.Printer=function(b,a){a=a||{};this.y=0;this.paper=b;this.space=3*ABCJS.write.spacing.SPACE;this.glyphs=new ABCJS.write.Glyphs();this.listeners=[];this.selected=[];this.ingroup=false;this.scale=a.scale||1;this.staffwidth=a.staffwidth||740;this.paddingtop=a.paddingtop||15;this.paddingbottom=a.paddingbottom||30;this.paddingright=a.paddingright||50;this.paddingleft=a.paddingleft||15;this.editable=a.editable||false};ABCJS.write.Printer.prototype.notifySelect=function(b){this.clearSelection();this.selected=[b];b.highlight();for(var a=0;a<this.listeners.length;a++){this.listeners[a].highlight(b.abcelem)}};ABCJS.write.Printer.prototype.notifyChange=function(b){for(var a=0;a<this.listeners.length;a++){this.listeners[a].modelChanged()}};ABCJS.write.Printer.prototype.clearSelection=function(){for(var a=0;a<this.selected.length;a++){this.selected[a].unhighlight()}this.selected=[]};ABCJS.write.Printer.prototype.addSelectListener=function(a){this.listeners[this.listeners.length]=a};ABCJS.write.Printer.prototype.rangeHighlight=function(b,d){this.clearSelection();for(var i=0;i<this.staffgroups.length;i++){var f=this.staffgroups[i].voices;for(var g=0;g<f.length;g++){var a=f[g].children;for(var c=0;c<a.length;c++){var h=a[c].abcelem.startChar;var e=a[c].abcelem.endChar;if((d>h&&b<e)||((d===b)&&d===e)){this.selected[this.selected.length]=a[c];a[c].highlight()}}}}};ABCJS.write.Printer.prototype.beginGroup=function(){this.path=[];this.lastM=[0,0];this.ingroup=true};ABCJS.write.Printer.prototype.addPath=function(c){c=c||[];if(c.length===0){return}c[0][0]="m";c[0][1]-=this.lastM[0];c[0][2]-=this.lastM[1];this.lastM[0]+=c[0][1];this.lastM[1]+=c[0][2];this.path.push(c[0]);for(var a=1,b=c.length;a<b;a++){if(c[a][0]==="m"){this.lastM[0]+=c[a][1];this.lastM[1]+=c[a][2]}this.path.push(c[a])}};ABCJS.write.Printer.prototype.endGroup=function(){this.ingroup=false;if(this.path.length===0){return null}var a=this.paper.path().attr({path:this.path,stroke:"none",fill:"#000000"});if(this.scale!==1){a.scale(this.scale,this.scale,0,0)}return a};ABCJS.write.Printer.prototype.printStaveLine=function(x1,x2,pitch){var isIE=
/*@cc_on!@*/
false;var dy=0.35;var fill="#000000";if(isIE){dy=1;fill="#666666"}var y=this.calcY(pitch);var pathString=ABCJS.write.sprintf("M %f %f L %f %f L %f %f L %f %f z",x1,y-dy,x2,y-dy,x2,y+dy,x1,y+dy);var ret=this.paper.path().attr({path:pathString,stroke:"none",fill:fill}).toBack();if(this.scale!==1){ret.scale(this.scale,this.scale,0,0)}return ret};ABCJS.write.Printer.prototype.printStem=function(x,dx,y1,y2){if(dx<0){var tmp=y2;y2=y1;y1=tmp}var isIE=
/*@cc_on!@*/
false;var fill="#000000";if(isIE&&dx<1){dx=1;fill="#666666"}if(~~x===x){x+=0.05}var pathArray=[["M",x,y1],["L",x,y2],["L",x+dx,y2],["L",x+dx,y1],["z"]];if(!isIE&&this.ingroup){this.addPath(pathArray)}else{var ret=this.paper.path().attr({path:pathArray,stroke:"none",fill:fill}).toBack();if(this.scale!==1){ret.scale(this.scale,this.scale,0,0)
}return ret}};ABCJS.write.Printer.prototype.printText=function(a,e,d,c){c=c||"start";var b=this.paper.text(a*this.scale,this.calcY(e)*this.scale,d).attr({"text-anchor":c,"font-size":12*this.scale});return b};ABCJS.write.Printer.prototype.printSymbol=function(j,d,c,g,f){var b;if(!c){return null}if(c.length>0&&c.indexOf(".")<0){var h=this.paper.set();var k=0;for(var e=0;e<c.length;e++){var a=this.glyphs.getYCorr(c.charAt(e));b=this.glyphs.printSymbol(j+k,this.calcY(d+a),c.charAt(e),this.paper);if(b){h.push(b);k+=this.glyphs.getSymbolWidth(c.charAt(e))}else{this.debugMsg(j,"no symbol:"+c)}}if(this.scale!==1){h.scale(this.scale,this.scale,0,0)}return h}else{var a=this.glyphs.getYCorr(c);if(this.ingroup){this.addPath(this.glyphs.getPathForSymbol(j,this.calcY(d+a),c,g,f))}else{b=this.glyphs.printSymbol(j,this.calcY(d+a),c,this.paper);if(b){if(this.scale!==1){b.scale(this.scale,this.scale,0,0)}return b}else{this.debugMsg(j,"no symbol:"+c)}}return null}};ABCJS.write.Printer.prototype.printPath=function(b){var a=this.paper.path().attr(b);if(this.scale!==1){a.scale(this.scale,this.scale,0,0)}return a};ABCJS.write.Printer.prototype.drawArc=function(n,m,q,p,o){n=n+6;m=m+4;q=q+((o)?1.5:-1.5);p=p+((o)?1.5:-1.5);var c=this.calcY(q);var b=this.calcY(p);var h=m-n;var g=b-c;var f=Math.sqrt(h*h+g*g);var e=h/f;var d=g/f;var u=f/3.5;var i=((o)?-1:1)*Math.min(25,Math.max(4,u));var l=n+u*e-i*d;var t=c+u*d+i*e;var j=m-u*e-i*d;var r=b-u*d+i*e;var a=2;var k=ABCJS.write.sprintf("M %f %f C %f %f %f %f %f %f C %f %f %f %f %f %f z",n,c,l,t,j,r,m,b,j-a*d,r+a*e,l-a*d,t+a*e,n,c);var s=this.paper.path().attr({path:k,stroke:"none",fill:"#000000"});if(this.scale!==1){s.scale(this.scale,this.scale,0,0)}return s};ABCJS.write.Printer.prototype.debugMsg=function(a,b){return this.paper.text(a,this.y,b).scale(this.scale,this.scale,0,0)};ABCJS.write.Printer.prototype.debugMsgLow=function(a,b){return this.paper.text(a,this.calcY(this.layouter.minY-7),b).attr({"font-family":"serif","font-size":12,"text-anchor":"begin"}).scale(this.scale,this.scale,0,0)};ABCJS.write.Printer.prototype.printLyrics=function(a,c){var b=this.paper.text(a,this.calcY(this.layouter.minY-7),c).attr({"font-family":"Times New Roman","font-weight":"bold","font-size":14,"text-anchor":"begin"}).scale(this.scale,this.scale,0,0);b[0].setAttribute("class","abc-lyric");return b};ABCJS.write.Printer.prototype.calcY=function(a){return this.y+((ABCJS.write.spacing.TOPNOTE-a)*ABCJS.write.spacing.STEP)};ABCJS.write.Printer.prototype.printStave=function(a,d,b){if(b===1){this.printStaveLine(a,d,6);return}for(var c=0;c<b;c++){this.printStaveLine(a,d,(c+1)*2)}};ABCJS.write.Printer.prototype.printABC=function(a){if(a[0]===undefined){a=[a]}this.y=0;for(var b=0;b<a.length;b++){this.printTune(a[b])}};ABCJS.write.Printer.prototype.printTempo=function(t,k,q,h,e,j){var f={"text-anchor":"start","font-size":12*e.scale,"font-weight":"bold"};if(t.preString){var o=k.text(j*e.scale,h*e.scale+20*e.scale,t.preString).attr(f);j+=(o.getBBox().width+20*e.scale)}if(t.duration){var g=0.75*e.scale;var w=14.5;var a=t.duration[0];var n=new ABCJS.write.AbsoluteElement(t,a,1);var u=Math.floor(Math.log(a)/Math.log(2));var r=0;for(var m=Math.pow(2,u),i=m/2;m<a;r++,m+=i,i/=2){}var z=q.chartable.note[-u];var v=q.chartable.uflags[-u];var p=q.printNoteHead(n,z,{verticalPos:w},"up",0,0,v,r,0,g);n.addHead(p);if(a<1){var d=w+1/3*g;var b=w+7*g;var l=p.dx+p.w;var s=-0.6*e.scale;n.addExtra(new ABCJS.write.RelativeElement(null,l,0,d,{type:"stem",pitch2:b,linewidth:s}))}n.x=j*(1/e.scale);n.draw(e,null);j+=(n.w+5*e.scale);o=k.text(j,h*e.scale+20*e.scale,"= "+t.bpm).attr(f);j+=o.getBBox().width+10*e.scale}if(t.postString){k.text(j,h*e.scale+20*e.scale,t.postString).attr(f)}h+=15*e.scale;return h};ABCJS.write.Printer.prototype.printTune=function(abctune){this.layouter=new ABCJS.write.Layout(this.glyphs,abctune.formatting.bagpipes);this.layouter.printer=this;if(abctune.media==="print"){var m=abctune.formatting.topmargin===undefined?54:abctune.formatting.topmargin;this.y+=m}else{this.y+=this.paddingtop}if(abctune.formatting.staffwidth){this.width=abctune.formatting.staffwidth}else{this.width=this.staffwidth}this.width+=this.paddingleft;if(abctune.formatting.scale){this.scale=abctune.formatting.scale}if(abctune.metaText.title){this.paper.text(this.width*this.scale/2,this.y,abctune.metaText.title).attr({"font-size":20*this.scale,"font-family":"serif"})}this.y+=20*this.scale;if(abctune.lines[0]&&abctune.lines[0].subtitle){this.printSubtitleLine(abctune.lines[0]);this.y+=20*this.scale}if(abctune.metaText.rhythm){this.paper.text(this.paddingleft,this.y,abctune.metaText.rhythm).attr({"text-anchor":"start","font-style":"italic","font-family":"serif","font-size":12*this.scale});!(abctune.metaText.author||abctune.metaText.origin||abctune.metaText.composer)&&(this.y+=15*this.scale)}var composerLine="";if(abctune.metaText.composer){composerLine+=abctune.metaText.composer}if(abctune.metaText.origin){composerLine+=" ("+abctune.metaText.origin+")"}if(composerLine.length>0){this.paper.text(this.width*this.scale,this.y,composerLine).attr({"text-anchor":"end","font-style":"italic","font-family":"serif","font-size":12*this.scale});this.y+=15}if(abctune.metaText.author){this.paper.text(this.width*this.scale,this.y,abctune.metaText.author).attr({"text-anchor":"end","font-style":"italic","font-family":"serif","font-size":12*this.scale});this.y+=15}if(abctune.metaText.tempo&&!abctune.metaText.tempo.suppress){this.y=this.printTempo(abctune.metaText.tempo,this.paper,this.layouter,this.y,this,50);this.y+=20*this.scale}this.staffgroups=[];var maxwidth=this.width;for(var line=0;line<abctune.lines.length;line++){var abcline=abctune.lines[line];if(abcline.staff){staffgroup=this.printStaffLine(abctune,abcline,line);if(staffgroup.w>maxwidth){maxwidth=staffgroup.w}}else{if(abcline.subtitle&&line!==0){this.printSubtitleLine(abcline);this.y+=20*this.scale}else{if(abcline.text){if(typeof abcline.text==="string"){this.paper.text(100,this.y,"TEXT: "+abcline.text)}else{var str="";for(var i=0;i<abcline.text.length;i++){str+=" FONT "+abcline.text[i].text}this.paper.text(100,this.y,"TEXT: "+str)}this.y+=20*this.scale}}}}var extraText="";var text2;var height;if(abctune.metaText.partOrder){extraText+="Part Order: "+abctune.metaText.partOrder+"\n"}if(abctune.metaText.unalignedWords){for(var j=0;j<abctune.metaText.unalignedWords.length;j++){if(typeof abctune.metaText.unalignedWords[j]==="string"){extraText+=abctune.metaText.unalignedWords[j]+"\n"}else{for(var k=0;k<abctune.metaText.unalignedWords[j].length;k++){extraText+=" FONT "+abctune.metaText.unalignedWords[j][k].text}extraText+="\n"}}text2=this.paper.text(this.paddingleft*this.scale+50*this.scale,this.y*this.scale+25*this.scale,extraText).attr({"text-anchor":"start","font-family":"serif","font-size":17*this.scale});height=text2.getBBox().height+17*this.scale;text2.translate(0,height/2);this.y+=height;extraText=""}if(abctune.metaText.book){extraText+="Book: "+abctune.metaText.book+"\n"}if(abctune.metaText.source){extraText+="Source: "+abctune.metaText.source+"\n"
}if(abctune.metaText.discography){extraText+="Discography: "+abctune.metaText.discography+"\n"}if(abctune.metaText.notes){extraText+="Notes: "+abctune.metaText.notes+"\n"}if(abctune.metaText.transcription){extraText+="Transcription: "+abctune.metaText.transcription+"\n"}if(abctune.metaText.history){extraText+="History: "+abctune.metaText.history+"\n"}text2=this.paper.text(this.paddingleft,this.y*this.scale+25*this.scale,extraText).attr({"text-anchor":"start","font-family":"serif","font-size":17*this.scale});height=text2.getBBox().height;if(!height){height=25*this.scale}text2.translate(0,height/2);this.y+=25*this.scale+height*this.scale;var sizetoset={w:(maxwidth+this.paddingright)*this.scale,h:(this.y+this.paddingbottom)*this.scale};this.paper.setSize(sizetoset.w,sizetoset.h);var isIE=
/*@cc_on!@*/
false;if(isIE){this.paper.canvas.parentNode.style.width=sizetoset.w+"px";this.paper.canvas.parentNode.style.height=""+sizetoset.h+"px"}else{this.paper.canvas.parentNode.setAttribute("style","width:"+sizetoset.w+"px")}};ABCJS.write.Printer.prototype.printSubtitleLine=function(a){this.paper.text(this.width/2,this.y,a.subtitle).attr({"font-size":16}).scale(this.scale,this.scale,0,0)};ABCJS.write.Printer.prototype.printStaffLine=function(g,d,b){var h=this.layouter.printABCLine(d.staff);var c=this.space;for(var f=0;f<3;f++){h.layout(c,this,false);if(b&&b===g.lines.length-1&&h.w/this.width<0.66&&!g.formatting.stretchlast){break}var a=h.spacingunits*c;var e=h.w-a;if(h.spacingunits>0){c=(this.width-e)/h.spacingunits;if(c*h.minspace>50){c=50/h.minspace}}}h.draw(this,this.y);this.staffgroups[this.staffgroups.length]=h;this.y=h.y+h.height;this.y+=ABCJS.write.spacing.STAVEHEIGHT*0.2;return h};if(!window.ABCJS){window.ABCJS={}}if(!window.ABCJS.write){window.ABCJS.write={}}ABCJS.write.sprintf=function(){var g=0,e,h=arguments[g++],k=[],d,j,l,b;while(h){if(d=/^[^\x25]+/.exec(h)){k.push(d[0])}else{if(d=/^\x25{2}/.exec(h)){k.push("%")}else{if(d=/^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(h)){if(((e=arguments[d[1]||g++])==null)||(e==undefined)){throw ("Too few arguments.")}if(/[^s]/.test(d[7])&&(typeof(e)!="number")){throw ("Expecting number but found "+typeof(e))}switch(d[7]){case"b":e=e.toString(2);break;case"c":e=String.fromCharCode(e);break;case"d":e=parseInt(e);break;case"e":e=d[6]?e.toExponential(d[6]):e.toExponential();break;case"f":e=d[6]?parseFloat(e).toFixed(d[6]):parseFloat(e);break;case"o":e=e.toString(8);break;case"s":e=((e=String(e))&&d[6]?e.substring(0,d[6]):e);break;case"u":e=Math.abs(e);break;case"x":e=e.toString(16);break;case"X":e=e.toString(16).toUpperCase();break}e=(/[def]/.test(d[7])&&d[2]&&e>0?"+"+e:e);l=d[3]?d[3]=="0"?"0":d[3].charAt(1):" ";b=d[5]-String(e).length;j=d[5]?str_repeat(l,b):"";k.push(d[4]?e+j:j+e)}else{throw ("Huh ?!")}}}h=h.substring(d[0].length)}return k.join("")};
; browserify_shim__define__module__export__(typeof ABCJS != "undefined" ? ABCJS : window.ABCJS);

}).call(global, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

},{}],"abcjs":[function(require,module,exports){
module.exports=require('n1ID3u');
},{}],"angular-animate":[function(require,module,exports){
module.exports=require('7HlBcc');
},{}],"7HlBcc":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, define) {

; require("/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js");
/**
 * @license AngularJS v1.2.6
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* jshint maxlen: false */

/**
 * @ngdoc overview
 * @name ngAnimate
 * @description
 *
 * # ngAnimate
 *
 * The `ngAnimate` module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.
 *
 * {@installModule animate}
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 *
 * To see animations in action, all that is required is to define the appropriate CSS classes
 * or to register a JavaScript animation via the myModule.animation() function. The directives that support animation automatically are:
 * `ngRepeat`, `ngInclude`, `ngIf`, `ngSwitch`, `ngShow`, `ngHide`, `ngView` and `ngClass`. Custom directives can take advantage of animation
 * by using the `$animate` service.
 *
 * Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:
 *
 * | Directive                                                 | Supported Animations                               |
 * |---------------------------------------------------------- |----------------------------------------------------|
 * | {@link ng.directive:ngRepeat#usage_animations ngRepeat}         | enter, leave and move                              |
 * | {@link ngRoute.directive:ngView#usage_animations ngView}        | enter and leave                                    |
 * | {@link ng.directive:ngInclude#usage_animations ngInclude}       | enter and leave                                    |
 * | {@link ng.directive:ngSwitch#usage_animations ngSwitch}         | enter and leave                                    |
 * | {@link ng.directive:ngIf#usage_animations ngIf}                 | enter and leave                                    |
 * | {@link ng.directive:ngClass#usage_animations ngClass}           | add and remove                                     |
 * | {@link ng.directive:ngShow#usage_animations ngShow & ngHide}    | add and remove (the ng-hide class value)           |
 *
 * You can find out more information about animations upon visiting each directive page.
 *
 * Below is an example of how to apply animations to a directive that supports animation hooks:
 *
 * <pre>
 * <style type="text/css">
 * .slide.ng-enter, .slide.ng-leave {
 *   -webkit-transition:0.5s linear all;
 *   transition:0.5s linear all;
 * }
 *
 * .slide.ng-enter { }        /&#42; starting animations for enter &#42;/
 * .slide.ng-enter-active { } /&#42; terminal animations for enter &#42;/
 * .slide.ng-leave { }        /&#42; starting animations for leave &#42;/
 * .slide.ng-leave-active { } /&#42; terminal animations for leave &#42;/
 * </style>
 *
 * <!--
 * the animate service will automatically add .ng-enter and .ng-leave to the element
 * to trigger the CSS transition/animations
 * -->
 * <ANY class="slide" ng-include="..."></ANY>
 * </pre>
 *
 * Keep in mind that if an animation is running, any child elements cannot be animated until the parent element's
 * animation has completed.
 *
 * <h2>CSS-defined Animations</h2>
 * The animate service will automatically apply two CSS classes to the animated element and these two CSS classes
 * are designed to contain the start and end CSS styling. Both CSS transitions and keyframe animations are supported
 * and can be used to play along with this naming structure.
 *
 * The following code below demonstrates how to perform animations using **CSS transitions** with Angular:
 *
 * <pre>
 * <style type="text/css">
 * /&#42;
 *  The animate class is apart of the element and the ng-enter class
 *  is attached to the element once the enter animation event is triggered
 * &#42;/
 * .reveal-animation.ng-enter {
 *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/
 *  transition: 1s linear all; /&#42; All other modern browsers and IE10+ &#42;/
 *
 *  /&#42; The animation preparation code &#42;/
 *  opacity: 0;
 * }
 *
 * /&#42;
 *  Keep in mind that you want to combine both CSS
 *  classes together to avoid any CSS-specificity
 *  conflicts
 * &#42;/
 * .reveal-animation.ng-enter.ng-enter-active {
 *  /&#42; The animation code itself &#42;/
 *  opacity: 1;
 * }
 * </style>
 *
 * <div class="view-container">
 *   <div ng-view class="reveal-animation"></div>
 * </div>
 * </pre>
 *
 * The following code below demonstrates how to perform animations using **CSS animations** with Angular:
 *
 * <pre>
 * <style type="text/css">
 * .reveal-animation.ng-enter {
 *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/
 *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/
 * }
 * &#64-webkit-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * &#64keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * </style>
 *
 * <div class="view-container">
 *   <div ng-view class="reveal-animation"></div>
 * </div>
 * </pre>
 *
 * Both CSS3 animations and transitions can be used together and the animate service will figure out the correct duration and delay timing.
 *
 * Upon DOM mutation, the event class is added first (something like `ng-enter`), then the browser prepares itself to add
 * the active class (in this case `ng-enter-active`) which then triggers the animation. The animation module will automatically
 * detect the CSS code to determine when the animation ends. Once the animation is over then both CSS classes will be
 * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end
 * immediately resulting in a DOM element that is at its final state. This final state is when the DOM element
 * has no CSS transition/animation classes applied to it.
 *
 * <h3>CSS Staggering Animations</h3>
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module, as of 1.2.0, supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * <pre>
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   -webkit-transition: 1s linear all;
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   -webkit-transition-delay: 0.1s;
 *   transition-delay: 0.1s;
 *
 *   /&#42; in case the stagger doesn't work then these two values
 *    must be set to 0 to avoid an accidental CSS inheritance &#42;/
 *   -webkit-transition-duration: 0s;
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * </pre>
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if more than 10ms has passed after the last animation has been fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * <pre>
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * $timeout(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 * }, 100, false);
 * </pre>
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * <h2>JavaScript-defined Animations</h2>
 * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations on browsers that do not
 * yet support CSS transitions/animations, then you can make use of JavaScript animations defined inside of your AngularJS module.
 *
 * <pre>
 * //!annotate="YourApp" Your AngularJS Module|Replace this or ngModule with the module that you used to define your application.
 * var ngModule = angular.module('YourApp', ['ngAnimate']);
 * ngModule.animation('.my-crazy-animation', function() {
 *   return {
 *     enter: function(element, done) {
 *       //run the animation here and call done when the animation is complete
 *       return function(cancelled) {
 *         //this (optional) function will be called when the animation
 *         //completes or when the animation is cancelled (the cancelled
 *         //flag will be set to true if cancelled).
 *       };
 *     },
 *     leave: function(element, done) { },
 *     move: function(element, done) { },
 *
 *     //animation that can be triggered before the class is added
 *     beforeAddClass: function(element, className, done) { },
 *
 *     //animation that can be triggered after the class is added
 *     addClass: function(element, className, done) { },
 *
 *     //animation that can be triggered before the class is removed
 *     beforeRemoveClass: function(element, className, done) { },
 *
 *     //animation that can be triggered after the class is removed
 *     removeClass: function(element, className, done) { }
 *   };
 * });
 * </pre>
 *
 * JavaScript-defined animations are created with a CSS-like class selector and a collection of events which are set to run
 * a javascript callback function. When an animation is triggered, $animate will look for a matching animation which fits
 * the element's CSS class attribute value and then run the matching animation event function (if found).
 * In other words, if the CSS classes present on the animated element match any of the JavaScript animations then the callback function will
 * be executed. It should be also noted that only simple, single class selectors are allowed (compound class selectors are not supported).
 *
 * Within a JavaScript animation, an object containing various event callback animation functions is expected to be returned.
 * As explained above, these callbacks are triggered based on the animation event. Therefore if an enter animation is run,
 * and the JavaScript animation is found, then the enter callback will handle that animation (in addition to the CSS keyframe animation
 * or transition code that is defined via a stylesheet).
 *
 */

angular.module('ngAnimate', ['ng'])

  /**
   * @ngdoc object
   * @name ngAnimate.$animateProvider
   * @description
   *
   * The `$animateProvider` allows developers to register JavaScript animation event handlers directly inside of a module.
   * When an animation is triggered, the $animate service will query the $animate service to find any animations that match
   * the provided name value.
   *
   * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
   *
   * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
   *
   */
  .config(['$provide', '$animateProvider', function($provide, $animateProvider) {
    var noop = angular.noop;
    var forEach = angular.forEach;
    var selectors = $animateProvider.$$selectors;

    var ELEMENT_NODE = 1;
    var NG_ANIMATE_STATE = '$$ngAnimateState';
    var NG_ANIMATE_CLASS_NAME = 'ng-animate';
    var rootAnimateState = {running: true};

    function extractElementNode(element) {
      for(var i = 0; i < element.length; i++) {
        var elm = element[i];
        if(elm.nodeType == ELEMENT_NODE) {
          return elm;
        }
      }
    }

    function isMatchingElement(elm1, elm2) {
      return extractElementNode(elm1) == extractElementNode(elm2);
    }

    $provide.decorator('$animate', ['$delegate', '$injector', '$sniffer', '$rootElement', '$timeout', '$rootScope', '$document',
                            function($delegate,   $injector,   $sniffer,   $rootElement,   $timeout,   $rootScope,   $document) {

      $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);

      // disable animations during bootstrap, but once we bootstrapped, wait again
      // for another digest until enabling animations. The reason why we digest twice
      // is because all structural animations (enter, leave and move) all perform a
      // post digest operation before animating. If we only wait for a single digest
      // to pass then the structural animation would render its animation on page load.
      // (which is what we're trying to avoid when the application first boots up.)
      $rootScope.$$postDigest(function() {
        $rootScope.$$postDigest(function() {
          rootAnimateState.running = false;
        });
      });

      var classNameFilter = $animateProvider.classNameFilter();
      var isAnimatableClassName = !classNameFilter
              ? function() { return true; }
              : function(className) {
                return classNameFilter.test(className);
              };

      function lookup(name) {
        if (name) {
          var matches = [],
              flagMap = {},
              classes = name.substr(1).split('.');

          //the empty string value is the default animation
          //operation which performs CSS transition and keyframe
          //animations sniffing. This is always included for each
          //element animation procedure if the browser supports
          //transitions and/or keyframe animations
          if ($sniffer.transitions || $sniffer.animations) {
            classes.push('');
          }

          for(var i=0; i < classes.length; i++) {
            var klass = classes[i],
                selectorFactoryName = selectors[klass];
            if(selectorFactoryName && !flagMap[klass]) {
              matches.push($injector.get(selectorFactoryName));
              flagMap[klass] = true;
            }
          }
          return matches;
        }
      }

      /**
       * @ngdoc object
       * @name ngAnimate.$animate
       * @function
       *
       * @description
       * The `$animate` service provides animation detection support while performing DOM operations (enter, leave and move) as well as during addClass and removeClass operations.
       * When any of these operations are run, the $animate service
       * will examine any JavaScript-defined animations (which are defined by using the $animateProvider provider object)
       * as well as any CSS-defined animations against the CSS classes present on the element once the DOM operation is run.
       *
       * The `$animate` service is used behind the scenes with pre-existing directives and animation with these directives
       * will work out of the box without any extra configuration.
       *
       * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
       *
       * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
       *
       */
      return {
        /**
         * @ngdoc function
         * @name ngAnimate.$animate#enter
         * @methodOf ngAnimate.$animate
         * @function
         *
         * @description
         * Appends the element to the parentElement element that resides in the document and then runs the enter animation. Once
         * the animation is started, the following CSS classes will be present on the element for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during enter animation:
         *
         * | Animation Step                                                                               | What the element class attribute looks like |
         * |----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.enter(...) is called                                                             | class="my-animation"                        |
         * | 2. element is inserted into the parentElement element or beside the afterElement element     | class="my-animation"                        |
         * | 3. $animate runs any JavaScript-defined animations on the element                            | class="my-animation ng-animate"             |
         * | 4. the .ng-enter class is added to the element                                               | class="my-animation ng-animate ng-enter"    |
         * | 5. $animate scans the element styles to get the CSS transition/animation duration and delay  | class="my-animation ng-animate ng-enter"    |
         * | 6. $animate waits for 10ms (this performs a reflow)                                          | class="my-animation ng-animate ng-enter"    |
         * | 7. the .ng-enter-active and .ng-animate-active classes are added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active ng-enter ng-enter-active" |
         * | 8. $animate waits for X milliseconds for the animation to complete                           | class="my-animation ng-animate ng-animate-active ng-enter ng-enter-active" |
         * | 9. The animation ends and all generated CSS classes are removed from the element             | class="my-animation"                        |
         * | 10. The doneCallback() callback is fired (if provided)                                       | class="my-animation"                        |
         *
         * @param {jQuery/jqLite element} element the element that will be the focus of the enter animation
         * @param {jQuery/jqLite element} parentElement the parent element of the element that will be the focus of the enter animation
         * @param {jQuery/jqLite element} afterElement the sibling element (which is the previous element) of the element that will be the focus of the enter animation
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        enter : function(element, parentElement, afterElement, doneCallback) {
          this.enabled(false, element);
          $delegate.enter(element, parentElement, afterElement);
          $rootScope.$$postDigest(function() {
            performAnimation('enter', 'ng-enter', element, parentElement, afterElement, noop, doneCallback);
          });
        },

        /**
         * @ngdoc function
         * @name ngAnimate.$animate#leave
         * @methodOf ngAnimate.$animate
         * @function
         *
         * @description
         * Runs the leave animation operation and, upon completion, removes the element from the DOM. Once
         * the animation is started, the following CSS classes will be added for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during leave animation:
         *
         * | Animation Step                                                                               | What the element class attribute looks like |
         * |----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.leave(...) is called                                                             | class="my-animation"                        |
         * | 2. $animate runs any JavaScript-defined animations on the element                            | class="my-animation ng-animate"             |
         * | 3. the .ng-leave class is added to the element                                               | class="my-animation ng-animate ng-leave"    |
         * | 4. $animate scans the element styles to get the CSS transition/animation duration and delay  | class="my-animation ng-animate ng-leave"    |
         * | 5. $animate waits for 10ms (this performs a reflow)                                          | class="my-animation ng-animate ng-leave"    |
         * | 6. the .ng-leave-active and .ng-animate-active classes is added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active ng-leave ng-leave-active" |
         * | 7. $animate waits for X milliseconds for the animation to complete                           | class="my-animation ng-animate ng-animate-active ng-leave ng-leave-active" |
         * | 8. The animation ends and all generated CSS classes are removed from the element             | class="my-animation"                        |
         * | 9. The element is removed from the DOM                                                       | ...                                         |
         * | 10. The doneCallback() callback is fired (if provided)                                       | ...                                         |
         *
         * @param {jQuery/jqLite element} element the element that will be the focus of the leave animation
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        leave : function(element, doneCallback) {
          cancelChildAnimations(element);
          this.enabled(false, element);
          $rootScope.$$postDigest(function() {
            performAnimation('leave', 'ng-leave', element, null, null, function() {
              $delegate.leave(element);
            }, doneCallback);
          });
        },

        /**
         * @ngdoc function
         * @name ngAnimate.$animate#move
         * @methodOf ngAnimate.$animate
         * @function
         *
         * @description
         * Fires the move DOM operation. Just before the animation starts, the animate service will either append it into the parentElement container or
         * add the element directly after the afterElement element if present. Then the move animation will be run. Once
         * the animation is started, the following CSS classes will be added for the duration of the animation:
         *
         * Below is a breakdown of each step that occurs during move animation:
         *
         * | Animation Step                                                                               | What the element class attribute looks like |
         * |----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.move(...) is called                                                              | class="my-animation"                        |
         * | 2. element is moved into the parentElement element or beside the afterElement element        | class="my-animation"                        |
         * | 3. $animate runs any JavaScript-defined animations on the element                            | class="my-animation ng-animate"             |
         * | 4. the .ng-move class is added to the element                                                | class="my-animation ng-animate ng-move"     |
         * | 5. $animate scans the element styles to get the CSS transition/animation duration and delay  | class="my-animation ng-animate ng-move"     |
         * | 6. $animate waits for 10ms (this performs a reflow)                                          | class="my-animation ng-animate ng-move"     |
         * | 7. the .ng-move-active and .ng-animate-active classes is added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active ng-move ng-move-active" |
         * | 8. $animate waits for X milliseconds for the animation to complete                           | class="my-animation ng-animate ng-animate-active ng-move ng-move-active" |
         * | 9. The animation ends and all generated CSS classes are removed from the element             | class="my-animation"                        |
         * | 10. The doneCallback() callback is fired (if provided)                                       | class="my-animation"                        |
         *
         * @param {jQuery/jqLite element} element the element that will be the focus of the move animation
         * @param {jQuery/jqLite element} parentElement the parentElement element of the element that will be the focus of the move animation
         * @param {jQuery/jqLite element} afterElement the sibling element (which is the previous element) of the element that will be the focus of the move animation
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        move : function(element, parentElement, afterElement, doneCallback) {
          cancelChildAnimations(element);
          this.enabled(false, element);
          $delegate.move(element, parentElement, afterElement);
          $rootScope.$$postDigest(function() {
            performAnimation('move', 'ng-move', element, parentElement, afterElement, noop, doneCallback);
          });
        },

        /**
         * @ngdoc function
         * @name ngAnimate.$animate#addClass
         * @methodOf ngAnimate.$animate
         *
         * @description
         * Triggers a custom animation event based off the className variable and then attaches the className value to the element as a CSS class.
         * Unlike the other animation methods, the animate service will suffix the className value with {@type -add} in order to provide
         * the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if no CSS transitions
         * or keyframes are defined on the -add or base CSS class).
         *
         * Below is a breakdown of each step that occurs during addClass animation:
         *
         * | Animation Step                                                                                 | What the element class attribute looks like |
         * |------------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.addClass(element, 'super') is called                                               | class="my-animation"                        |
         * | 2. $animate runs any JavaScript-defined animations on the element                              | class="my-animation ng-animate"             |
         * | 3. the .super-add class are added to the element                                               | class="my-animation ng-animate super-add"   |
         * | 4. $animate scans the element styles to get the CSS transition/animation duration and delay    | class="my-animation ng-animate super-add"   |
         * | 5. $animate waits for 10ms (this performs a reflow)                                            | class="my-animation ng-animate super-add"   |
         * | 6. the .super, .super-add-active and .ng-animate-active classes are added (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active super super-add super-add-active"          |
         * | 7. $animate waits for X milliseconds for the animation to complete                             | class="my-animation super-add super-add-active"  |
         * | 8. The animation ends and all generated CSS classes are removed from the element               | class="my-animation super"                  |
         * | 9. The super class is kept on the element                                                      | class="my-animation super"                  |
         * | 10. The doneCallback() callback is fired (if provided)                                         | class="my-animation super"                  |
         *
         * @param {jQuery/jqLite element} element the element that will be animated
         * @param {string} className the CSS class that will be added to the element and then animated
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        addClass : function(element, className, doneCallback) {
          performAnimation('addClass', className, element, null, null, function() {
            $delegate.addClass(element, className);
          }, doneCallback);
        },

        /**
         * @ngdoc function
         * @name ngAnimate.$animate#removeClass
         * @methodOf ngAnimate.$animate
         *
         * @description
         * Triggers a custom animation event based off the className variable and then removes the CSS class provided by the className value
         * from the element. Unlike the other animation methods, the animate service will suffix the className value with {@type -remove} in
         * order to provide the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if
         * no CSS transitions or keyframes are defined on the -remove or base CSS classes).
         *
         * Below is a breakdown of each step that occurs during removeClass animation:
         *
         * | Animation Step                                                                                | What the element class attribute looks like     |
         * |-----------------------------------------------------------------------------------------------|---------------------------------------------|
         * | 1. $animate.removeClass(element, 'super') is called                                           | class="my-animation super"                  |
         * | 2. $animate runs any JavaScript-defined animations on the element                             | class="my-animation super ng-animate"       |
         * | 3. the .super-remove class are added to the element                                           | class="my-animation super ng-animate super-remove"|
         * | 4. $animate scans the element styles to get the CSS transition/animation duration and delay   | class="my-animation super ng-animate super-remove"   |
         * | 5. $animate waits for 10ms (this performs a reflow)                                           | class="my-animation super ng-animate super-remove"   |
         * | 6. the .super-remove-active and .ng-animate-active classes are added and .super is removed (this triggers the CSS transition/animation) | class="my-animation ng-animate ng-animate-active super-remove super-remove-active"          |
         * | 7. $animate waits for X milliseconds for the animation to complete                            | class="my-animation ng-animate ng-animate-active super-remove super-remove-active"   |
         * | 8. The animation ends and all generated CSS classes are removed from the element              | class="my-animation"                        |
         * | 9. The doneCallback() callback is fired (if provided)                                         | class="my-animation"                        |
         *
         *
         * @param {jQuery/jqLite element} element the element that will be animated
         * @param {string} className the CSS class that will be animated and then removed from the element
         * @param {function()=} doneCallback the callback function that will be called once the animation is complete
        */
        removeClass : function(element, className, doneCallback) {
          performAnimation('removeClass', className, element, null, null, function() {
            $delegate.removeClass(element, className);
          }, doneCallback);
        },

        /**
         * @ngdoc function
         * @name ngAnimate.$animate#enabled
         * @methodOf ngAnimate.$animate
         * @function
         *
         * @param {boolean=} value If provided then set the animation on or off.
         * @param {jQuery/jqLite element=} element If provided then the element will be used to represent the enable/disable operation
         * @return {boolean} Current animation state.
         *
         * @description
         * Globally enables/disables animations.
         *
        */
        enabled : function(value, element) {
          switch(arguments.length) {
            case 2:
              if(value) {
                cleanup(element);
              } else {
                var data = element.data(NG_ANIMATE_STATE) || {};
                data.disabled = true;
                element.data(NG_ANIMATE_STATE, data);
              }
            break;

            case 1:
              rootAnimateState.disabled = !value;
            break;

            default:
              value = !rootAnimateState.disabled;
            break;
          }
          return !!value;
         }
      };

      /*
        all animations call this shared animation triggering function internally.
        The animationEvent variable refers to the JavaScript animation event that will be triggered
        and the className value is the name of the animation that will be applied within the
        CSS code. Element, parentElement and afterElement are provided DOM elements for the animation
        and the onComplete callback will be fired once the animation is fully complete.
      */
      function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
        var currentClassName, classes, node = extractElementNode(element);
        if(node) {
          currentClassName = node.className;
          classes = currentClassName + ' ' + className;
        }

        //transcluded directives may sometimes fire an animation using only comment nodes
        //best to catch this early on to prevent any animation operations from occurring
        if(!node || !isAnimatableClassName(classes)) {
          fireDOMOperation();
          closeAnimation();
          return;
        }

        var animationLookup = (' ' + classes).replace(/\s+/g,'.');
        if (!parentElement) {
          parentElement = afterElement ? afterElement.parent() : element.parent();
        }

        var matches = lookup(animationLookup);
        var isClassBased = animationEvent == 'addClass' || animationEvent == 'removeClass';
        var ngAnimateState = element.data(NG_ANIMATE_STATE) || {};

        //skip the animation if animations are disabled, a parent is already being animated,
        //the element is not currently attached to the document body or then completely close
        //the animation if any matching animations are not found at all.
        //NOTE: IE8 + IE9 should close properly (run closeAnimation()) in case a NO animation is not found.
        if (animationsDisabled(element, parentElement) || matches.length === 0) {
          fireDOMOperation();
          closeAnimation();
          return;
        }

        var animations = [];
        //only add animations if the currently running animation is not structural
        //or if there is no animation running at all
        if(!ngAnimateState.running || !(isClassBased && ngAnimateState.structural)) {
          forEach(matches, function(animation) {
            //add the animation to the queue to if it is allowed to be cancelled
            if(!animation.allowCancel || animation.allowCancel(element, animationEvent, className)) {
              var beforeFn, afterFn = animation[animationEvent];

              //Special case for a leave animation since there is no point in performing an
              //animation on a element node that has already been removed from the DOM
              if(animationEvent == 'leave') {
                beforeFn = afterFn;
                afterFn = null; //this must be falsy so that the animation is skipped for leave
              } else {
                beforeFn = animation['before' + animationEvent.charAt(0).toUpperCase() + animationEvent.substr(1)];
              }
              animations.push({
                before : beforeFn,
                after : afterFn
              });
            }
          });
        }

        //this would mean that an animation was not allowed so let the existing
        //animation do it's thing and close this one early
        if(animations.length === 0) {
          fireDOMOperation();
          fireDoneCallbackAsync();
          return;
        }

        //this value will be searched for class-based CSS className lookup. Therefore,
        //we prefix and suffix the current className value with spaces to avoid substring
        //lookups of className tokens
        var futureClassName = ' ' + currentClassName + ' ';
        if(ngAnimateState.running) {
          //if an animation is currently running on the element then lets take the steps
          //to cancel that animation and fire any required callbacks
          $timeout.cancel(ngAnimateState.closeAnimationTimeout);
          cleanup(element);
          cancelAnimations(ngAnimateState.animations);

          //if the class is removed during the reflow then it will revert the styles temporarily
          //back to the base class CSS styling causing a jump-like effect to occur. This check
          //here ensures that the domOperation is only performed after the reflow has commenced
          if(ngAnimateState.beforeComplete) {
            (ngAnimateState.done || noop)(true);
          } else if(isClassBased && !ngAnimateState.structural) {
            //class-based animations will compare element className values after cancelling the
            //previous animation to see if the element properties already contain the final CSS
            //class and if so then the animation will be skipped. Since the domOperation will
            //be performed only after the reflow is complete then our element's className value
            //will be invalid. Therefore the same string manipulation that would occur within the
            //DOM operation will be performed below so that the class comparison is valid...
            futureClassName = ngAnimateState.event == 'removeClass' ?
              futureClassName.replace(ngAnimateState.className, '') :
              futureClassName + ngAnimateState.className + ' ';
          }
        }

        //There is no point in perform a class-based animation if the element already contains
        //(on addClass) or doesn't contain (on removeClass) the className being animated.
        //The reason why this is being called after the previous animations are cancelled
        //is so that the CSS classes present on the element can be properly examined.
        var classNameToken = ' ' + className + ' ';
        if((animationEvent == 'addClass'    && futureClassName.indexOf(classNameToken) >= 0) ||
           (animationEvent == 'removeClass' && futureClassName.indexOf(classNameToken) == -1)) {
          fireDOMOperation();
          fireDoneCallbackAsync();
          return;
        }

        //the ng-animate class does nothing, but it's here to allow for
        //parent animations to find and cancel child animations when needed
        element.addClass(NG_ANIMATE_CLASS_NAME);

        element.data(NG_ANIMATE_STATE, {
          running:true,
          event:animationEvent,
          className:className,
          structural:!isClassBased,
          animations:animations,
          done:onBeforeAnimationsComplete
        });

        //first we run the before animations and when all of those are complete
        //then we perform the DOM operation and run the next set of animations
        invokeRegisteredAnimationFns(animations, 'before', onBeforeAnimationsComplete);

        function onBeforeAnimationsComplete(cancelled) {
          fireDOMOperation();
          if(cancelled === true) {
            closeAnimation();
            return;
          }

          //set the done function to the final done function
          //so that the DOM event won't be executed twice by accident
          //if the after animation is cancelled as well
          var data = element.data(NG_ANIMATE_STATE);
          if(data) {
            data.done = closeAnimation;
            element.data(NG_ANIMATE_STATE, data);
          }
          invokeRegisteredAnimationFns(animations, 'after', closeAnimation);
        }

        function invokeRegisteredAnimationFns(animations, phase, allAnimationFnsComplete) {
          var endFnName = phase + 'End';
          forEach(animations, function(animation, index) {
            var animationPhaseCompleted = function() {
              progress(index, phase);
            };

            //there are no before functions for enter + move since the DOM
            //operations happen before the performAnimation method fires
            if(phase == 'before' && (animationEvent == 'enter' || animationEvent == 'move')) {
              animationPhaseCompleted();
              return;
            }

            if(animation[phase]) {
              animation[endFnName] = isClassBased ?
                animation[phase](element, className, animationPhaseCompleted) :
                animation[phase](element, animationPhaseCompleted);
            } else {
              animationPhaseCompleted();
            }
          });

          function progress(index, phase) {
            var phaseCompletionFlag = phase + 'Complete';
            var currentAnimation = animations[index];
            currentAnimation[phaseCompletionFlag] = true;
            (currentAnimation[endFnName] || noop)();

            for(var i=0;i<animations.length;i++) {
              if(!animations[i][phaseCompletionFlag]) return;
            }

            allAnimationFnsComplete();
          }
        }

        function fireDoneCallbackAsync() {
          doneCallback && $timeout(doneCallback, 0, false);
        }

        //it is less complicated to use a flag than managing and cancelling
        //timeouts containing multiple callbacks.
        function fireDOMOperation() {
          if(!fireDOMOperation.hasBeenRun) {
            fireDOMOperation.hasBeenRun = true;
            domOperation();
          }
        }

        function closeAnimation() {
          if(!closeAnimation.hasBeenRun) {
            closeAnimation.hasBeenRun = true;
            var data = element.data(NG_ANIMATE_STATE);
            if(data) {
              /* only structural animations wait for reflow before removing an
                 animation, but class-based animations don't. An example of this
                 failing would be when a parent HTML tag has a ng-class attribute
                 causing ALL directives below to skip animations during the digest */
              if(isClassBased) {
                cleanup(element);
              } else {
                data.closeAnimationTimeout = $timeout(function() {
                  cleanup(element);
                }, 0, false);
                element.data(NG_ANIMATE_STATE, data);
              }
            }
            fireDoneCallbackAsync();
          }
        }
      }

      function cancelChildAnimations(element) {
        var node = extractElementNode(element);
        forEach(node.querySelectorAll('.' + NG_ANIMATE_CLASS_NAME), function(element) {
          element = angular.element(element);
          var data = element.data(NG_ANIMATE_STATE);
          if(data) {
            cancelAnimations(data.animations);
            cleanup(element);
          }
        });
      }

      function cancelAnimations(animations) {
        var isCancelledFlag = true;
        forEach(animations, function(animation) {
          if(!animations.beforeComplete) {
            (animation.beforeEnd || noop)(isCancelledFlag);
          }
          if(!animations.afterComplete) {
            (animation.afterEnd || noop)(isCancelledFlag);
          }
        });
      }

      function cleanup(element) {
        if(isMatchingElement(element, $rootElement)) {
          if(!rootAnimateState.disabled) {
            rootAnimateState.running = false;
            rootAnimateState.structural = false;
          }
        } else {
          element.removeClass(NG_ANIMATE_CLASS_NAME);
          element.removeData(NG_ANIMATE_STATE);
        }
      }

      function animationsDisabled(element, parentElement) {
        if (rootAnimateState.disabled) return true;

        if(isMatchingElement(element, $rootElement)) {
          return rootAnimateState.disabled || rootAnimateState.running;
        }

        do {
          //the element did not reach the root element which means that it
          //is not apart of the DOM. Therefore there is no reason to do
          //any animations on it
          if(parentElement.length === 0) break;

          var isRoot = isMatchingElement(parentElement, $rootElement);
          var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE);
          var result = state && (!!state.disabled || !!state.running);
          if(isRoot || result) {
            return result;
          }

          if(isRoot) return true;
        }
        while(parentElement = parentElement.parent());

        return true;
      }
    }]);

    $animateProvider.register('', ['$window', '$sniffer', '$timeout', function($window, $sniffer, $timeout) {
      // Detect proper transitionend/animationend event names.
      var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

      // If unprefixed events are not supported but webkit-prefixed are, use the latter.
      // Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
      // Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
      // but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
      // Register both events in case `window.onanimationend` is not supported because of that,
      // do the same for `transitionend` as Safari is likely to exhibit similar behavior.
      // Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
      // therefore there is no reason to test anymore for other vendor prefixes: http://caniuse.com/#search=transition
      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }

      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }

      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var NG_ANIMATE_PARENT_KEY = '$$ngAnimateKey';
      var NG_ANIMATE_CSS_DATA_KEY = '$$ngAnimateCSS3Data';
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var ONE_SECOND = 1000;

      var animationCounter = 0;
      var lookupCache = {};
      var parentCounter = 0;
      var animationReflowQueue = [];
      var animationElementQueue = [];
      var animationTimer;
      var closingAnimationTime = 0;
      var timeOut = false;
      function afterReflow(element, callback) {
        $timeout.cancel(animationTimer);

        animationReflowQueue.push(callback);

        var node = extractElementNode(element);
        element = angular.element(node);
        animationElementQueue.push(element);

        var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
        closingAnimationTime = Math.max(closingAnimationTime,
          (elementData.maxDelay + elementData.maxDuration) * CLOSING_TIME_BUFFER * ONE_SECOND);

        //by placing a counter we can avoid an accidental
        //race condition which may close an animation when
        //a follow-up animation is midway in its animation
        elementData.animationCount = animationCounter;

        animationTimer = $timeout(function() {
          forEach(animationReflowQueue, function(fn) {
            fn();
          });

          //copy the list of elements so that successive
          //animations won't conflict if they're added before
          //the closing animation timeout has run
          var elementQueueSnapshot = [];
          var animationCounterSnapshot = animationCounter;
          forEach(animationElementQueue, function(elm) {
            elementQueueSnapshot.push(elm);
          });

          $timeout(function() {
            closeAllAnimations(elementQueueSnapshot, animationCounterSnapshot);
            elementQueueSnapshot = null;
          }, closingAnimationTime, false);

          animationReflowQueue = [];
          animationElementQueue = [];
          animationTimer = null;
          lookupCache = {};
          closingAnimationTime = 0;
          animationCounter++;
        }, 10, false);
      }

      function closeAllAnimations(elements, count) {
        forEach(elements, function(element) {
          var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
          if(elementData && elementData.animationCount == count) {
            (elementData.closeAnimationFn || noop)();
          }
        });
      }

      function getElementAnimationDetails(element, cacheKey) {
        var data = cacheKey ? lookupCache[cacheKey] : null;
        if(!data) {
          var transitionDuration = 0;
          var transitionDelay = 0;
          var animationDuration = 0;
          var animationDelay = 0;
          var transitionDelayStyle;
          var animationDelayStyle;
          var transitionDurationStyle;
          var transitionPropertyStyle;

          //we want all the styles defined before and after
          forEach(element, function(element) {
            if (element.nodeType == ELEMENT_NODE) {
              var elementStyles = $window.getComputedStyle(element) || {};

              transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];

              transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);

              transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY];

              transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];

              transitionDelay  = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);

              animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];

              animationDelay   = Math.max(parseMaxTime(animationDelayStyle), animationDelay);

              var aDuration  = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);

              if(aDuration > 0) {
                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
              }

              animationDuration = Math.max(aDuration, animationDuration);
            }
          });
          data = {
            total : 0,
            transitionPropertyStyle: transitionPropertyStyle,
            transitionDurationStyle: transitionDurationStyle,
            transitionDelayStyle: transitionDelayStyle,
            transitionDelay: transitionDelay,
            transitionDuration: transitionDuration,
            animationDelayStyle: animationDelayStyle,
            animationDelay: animationDelay,
            animationDuration: animationDuration
          };
          if(cacheKey) {
            lookupCache[cacheKey] = data;
          }
        }
        return data;
      }

      function parseMaxTime(str) {
        var maxValue = 0;
        var values = angular.isString(str) ?
          str.split(/\s*,\s*/) :
          [];
        forEach(values, function(value) {
          maxValue = Math.max(parseFloat(value) || 0, maxValue);
        });
        return maxValue;
      }

      function getCacheKey(element) {
        var parentElement = element.parent();
        var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
        if(!parentID) {
          parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
          parentID = parentCounter;
        }
        return parentID + '-' + extractElementNode(element).className;
      }

      function animateSetup(element, className) {
        var cacheKey = getCacheKey(element);
        var eventCacheKey = cacheKey + ' ' + className;
        var stagger = {};
        var ii = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;

        if(ii > 0) {
          var staggerClassName = className + '-stagger';
          var staggerCacheKey = cacheKey + ' ' + staggerClassName;
          var applyClasses = !lookupCache[staggerCacheKey];

          applyClasses && element.addClass(staggerClassName);

          stagger = getElementAnimationDetails(element, staggerCacheKey);

          applyClasses && element.removeClass(staggerClassName);
        }

        element.addClass(className);

        var timings = getElementAnimationDetails(element, eventCacheKey);

        /* there is no point in performing a reflow if the animation
           timeout is empty (this would cause a flicker bug normally
           in the page. There is also no point in performing an animation
           that only has a delay and no duration */
        var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
        var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
        if(maxDuration === 0) {
          element.removeClass(className);
          return false;
        }

        //temporarily disable the transition so that the enter styles
        //don't animate twice (this is here to avoid a bug in Chrome/FF).
        var activeClassName = '';
        timings.transitionDuration > 0 ?
          blockTransitions(element) :
          blockKeyframeAnimations(element);

        forEach(className.split(' '), function(klass, i) {
          activeClassName += (i > 0 ? ' ' : '') + klass + '-active';
        });

        element.data(NG_ANIMATE_CSS_DATA_KEY, {
          className : className,
          activeClassName : activeClassName,
          maxDuration : maxDuration,
          maxDelay : maxDelay,
          classes : className + ' ' + activeClassName,
          timings : timings,
          stagger : stagger,
          ii : ii
        });

        return true;
      }

      function blockTransitions(element) {
        extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = 'none';
      }

      function blockKeyframeAnimations(element) {
        extractElementNode(element).style[ANIMATION_PROP] = 'none 0s';
      }

      function unblockTransitions(element) {
        var prop = TRANSITION_PROP + PROPERTY_KEY;
        var node = extractElementNode(element);
        if(node.style[prop] && node.style[prop].length > 0) {
          node.style[prop] = '';
        }
      }

      function unblockKeyframeAnimations(element) {
        var prop = ANIMATION_PROP;
        var node = extractElementNode(element);
        if(node.style[prop] && node.style[prop].length > 0) {
          node.style[prop] = '';
        }
      }

      function animateRun(element, className, activeAnimationComplete) {
        var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
        var node = extractElementNode(element);
        if(node.className.indexOf(className) == -1 || !elementData) {
          activeAnimationComplete();
          return;
        }

        var timings = elementData.timings;
        var stagger = elementData.stagger;
        var maxDuration = elementData.maxDuration;
        var activeClassName = elementData.activeClassName;
        var maxDelayTime = Math.max(timings.transitionDelay, timings.animationDelay) * ONE_SECOND;
        var startTime = Date.now();
        var css3AnimationEvents = ANIMATIONEND_EVENT + ' ' + TRANSITIONEND_EVENT;
        var ii = elementData.ii;

        var style = '', appliedStyles = [];
        if(timings.transitionDuration > 0) {
          var propertyStyle = timings.transitionPropertyStyle;
          if(propertyStyle.indexOf('all') == -1) {
            style += CSS_PREFIX + 'transition-property: ' + propertyStyle + ';';
            style += CSS_PREFIX + 'transition-duration: ' + timings.transitionDurationStyle + 's;';
            appliedStyles.push(CSS_PREFIX + 'transition-property');
            appliedStyles.push(CSS_PREFIX + 'transition-duration');
          }
        }

        if(ii > 0) {
          if(stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
            var delayStyle = timings.transitionDelayStyle;
            style += CSS_PREFIX + 'transition-delay: ' +
                     prepareStaggerDelay(delayStyle, stagger.transitionDelay, ii) + '; ';
            appliedStyles.push(CSS_PREFIX + 'transition-delay');
          }

          if(stagger.animationDelay > 0 && stagger.animationDuration === 0) {
            style += CSS_PREFIX + 'animation-delay: ' +
                     prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, ii) + '; ';
            appliedStyles.push(CSS_PREFIX + 'animation-delay');
          }
        }

        if(appliedStyles.length > 0) {
          //the element being animated may sometimes contain comment nodes in
          //the jqLite object, so we're safe to use a single variable to house
          //the styles since there is always only one element being animated
          var oldStyle = node.getAttribute('style') || '';
          node.setAttribute('style', oldStyle + ' ' + style);
        }

        element.on(css3AnimationEvents, onAnimationProgress);
        element.addClass(activeClassName);
        elementData.closeAnimationFn = function() {
          onEnd();
          activeAnimationComplete();
        };
        return onEnd;

        // This will automatically be called by $animate so
        // there is no need to attach this internally to the
        // timeout done method.
        function onEnd(cancelled) {
          element.off(css3AnimationEvents, onAnimationProgress);
          element.removeClass(activeClassName);
          animateClose(element, className);
          var node = extractElementNode(element);
          for (var i in appliedStyles) {
            node.style.removeProperty(appliedStyles[i]);
          }
        }

        function onAnimationProgress(event) {
          event.stopPropagation();
          var ev = event.originalEvent || event;
          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
          
          /* Firefox (or possibly just Gecko) likes to not round values up
           * when a ms measurement is used for the animation */
          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

          /* $manualTimeStamp is a mocked timeStamp value which is set
           * within browserTrigger(). This is only here so that tests can
           * mock animations properly. Real events fallback to event.timeStamp,
           * or, if they don't, then a timeStamp is automatically created for them.
           * We're checking to see if the timeStamp surpasses the expected delay,
           * but we're using elapsedTime instead of the timeStamp on the 2nd
           * pre-condition since animations sometimes close off early */
          if(Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
            activeAnimationComplete();
          }
        }
      }

      function prepareStaggerDelay(delayStyle, staggerDelay, index) {
        var style = '';
        forEach(delayStyle.split(','), function(val, i) {
          style += (i > 0 ? ',' : '') +
                   (index * staggerDelay + parseInt(val, 10)) + 's';
        });
        return style;
      }

      function animateBefore(element, className) {
        if(animateSetup(element, className)) {
          return function(cancelled) {
            cancelled && animateClose(element, className);
          };
        }
      }

      function animateAfter(element, className, afterAnimationComplete) {
        if(element.data(NG_ANIMATE_CSS_DATA_KEY)) {
          return animateRun(element, className, afterAnimationComplete);
        } else {
          animateClose(element, className);
          afterAnimationComplete();
        }
      }

      function animate(element, className, animationComplete) {
        //If the animateSetup function doesn't bother returning a
        //cancellation function then it means that there is no animation
        //to perform at all
        var preReflowCancellation = animateBefore(element, className);
        if(!preReflowCancellation) {
          animationComplete();
          return;
        }

        //There are two cancellation functions: one is before the first
        //reflow animation and the second is during the active state
        //animation. The first function will take care of removing the
        //data from the element which will not make the 2nd animation
        //happen in the first place
        var cancel = preReflowCancellation;
        afterReflow(element, function() {
          unblockTransitions(element);
          unblockKeyframeAnimations(element);
          //once the reflow is complete then we point cancel to
          //the new cancellation function which will remove all of the
          //animation properties from the active animation
          cancel = animateAfter(element, className, animationComplete);
        });

        return function(cancelled) {
          (cancel || noop)(cancelled);
        };
      }

      function animateClose(element, className) {
        element.removeClass(className);
        element.removeData(NG_ANIMATE_CSS_DATA_KEY);
      }

      return {
        allowCancel : function(element, animationEvent, className) {
          //always cancel the current animation if it is a
          //structural animation
          var oldClasses = (element.data(NG_ANIMATE_CSS_DATA_KEY) || {}).classes;
          if(!oldClasses || ['enter','leave','move'].indexOf(animationEvent) >= 0) {
            return true;
          }

          var parentElement = element.parent();
          var clone = angular.element(extractElementNode(element).cloneNode());

          //make the element super hidden and override any CSS style values
          clone.attr('style','position:absolute; top:-9999px; left:-9999px');
          clone.removeAttr('id');
          clone.empty();

          forEach(oldClasses.split(' '), function(klass) {
            clone.removeClass(klass);
          });

          var suffix = animationEvent == 'addClass' ? '-add' : '-remove';
          clone.addClass(suffixClasses(className, suffix));
          parentElement.append(clone);

          var timings = getElementAnimationDetails(clone);
          clone.remove();

          return Math.max(timings.transitionDuration, timings.animationDuration) > 0;
        },

        enter : function(element, animationCompleted) {
          return animate(element, 'ng-enter', animationCompleted);
        },

        leave : function(element, animationCompleted) {
          return animate(element, 'ng-leave', animationCompleted);
        },

        move : function(element, animationCompleted) {
          return animate(element, 'ng-move', animationCompleted);
        },

        beforeAddClass : function(element, className, animationCompleted) {
          var cancellationMethod = animateBefore(element, suffixClasses(className, '-add'));
          if(cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },

        addClass : function(element, className, animationCompleted) {
          return animateAfter(element, suffixClasses(className, '-add'), animationCompleted);
        },

        beforeRemoveClass : function(element, className, animationCompleted) {
          var cancellationMethod = animateBefore(element, suffixClasses(className, '-remove'));
          if(cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },

        removeClass : function(element, className, animationCompleted) {
          return animateAfter(element, suffixClasses(className, '-remove'), animationCompleted);
        }
      };

      function suffixClasses(classes, suffix) {
        var className = '';
        classes = angular.isArray(classes) ? classes : classes.split(/\s+/);
        forEach(classes, function(klass, i) {
          if(klass && klass.length > 0) {
            className += (i > 0 ? ' ' : '') + klass + suffix;
          }
        });
        return className;
      }
    }]);
  }]);


})(window, window.angular);

}).call(global, module, undefined);

},{"/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js":"t5daAN"}],"angular-bootstrap":[function(require,module,exports){
module.exports=require('ZGQjzz');
},{}],"ZGQjzz":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, define) {

; require("/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js");
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdownToggle","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/popup.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset-titles.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.transition', [])

/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject('Transition cancelled');
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement('trans');
  var transitionEndEventNames = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'transition': 'transitionend'
  };
  var animationEndEventNames = {
    'WebkitTransition': 'webkitAnimationEnd',
    'MozTransition': 'animationend',
    'OTransition': 'oAnimationEnd',
    'transition': 'animationend'
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module('ui.bootstrap.collapse',['ui.bootstrap.transition'])

// The collapsible directive indicates a block of html that will expand and collapse
.directive('collapse', ['$transition', function($transition) {
  // CSS transitions don't work with height: auto, so we have to manually change the height to a
  // specific value and then once the animation completes, we can reset the height to auto.
  // Unfortunately if you do this while the CSS transitions are specified (i.e. in the CSS class
  // "collapse") then you trigger a change to height 0 in between.
  // The fix is to remove the "collapse" CSS class while changing the height back to auto - phew!
  var fixUpHeight = function(scope, element, height) {
    // We remove the collapse CSS class to prevent a transition when we change to height: auto
    element.removeClass('collapse');
    element.css({ height: height });
    // It appears that  reading offsetWidth makes the browser realise that we have changed the
    // height already :-/
    var x = element[0].offsetWidth;
    element.addClass('collapse');
  };

  return {
    link: function(scope, element, attrs) {

      var isCollapsed;
      var initialAnimSkip = true;

      scope.$watch(attrs.collapse, function(value) {
        if (value) {
          collapse();
        } else {
          expand();
        }
      });
      

      var currentTransition;
      var doTransition = function(change) {
        if ( currentTransition ) {
          currentTransition.cancel();
        }
        currentTransition = $transition(element,change);
        currentTransition.then(
          function() { currentTransition = undefined; },
          function() { currentTransition = undefined; }
        );
        return currentTransition;
      };

      var expand = function() {
        if (initialAnimSkip) {
          initialAnimSkip = false;
          if ( !isCollapsed ) {
            fixUpHeight(scope, element, 'auto');
            element.addClass('in');
          }
        } else {
          doTransition({ height : element[0].scrollHeight + 'px' })
          .then(function() {
            // This check ensures that we don't accidentally update the height if the user has closed
            // the group while the animation was still running
            if ( !isCollapsed ) {
              fixUpHeight(scope, element, 'auto');
              element.addClass('in');
            }
          });
        }
        isCollapsed = false;
      };
      
      var collapse = function() {
        isCollapsed = true;
        element.removeClass('in');
        if (initialAnimSkip) {
          initialAnimSkip = false;
          fixUpHeight(scope, element, 0);
        } else {
          fixUpHeight(scope, element, element[0].scrollHeight + 'px');
          doTransition({'height':'0'});
        }
      };
    }
  };
}]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('accordionConfig', {
  closeOthers: true
})

.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {

  // This array keeps track of the accordion groups
  this.groups = [];

  // Keep reference to user's scope to properly assign `is-open`
  this.scope = $scope;

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if ( closeOthers ) {
      angular.forEach(this.groups, function (group) {
        if ( group !== openGroup ) {
          group.isOpen = false;
        }
      });
    }
  };
  
  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if ( index !== -1 ) {
      this.groups.splice(this.groups.indexOf(group), 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
  return {
    restrict:'EA',
    controller:'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', ['$parse', '$transition', '$timeout', function($parse, $transition, $timeout) {
  return {
    require:'^accordion',         // We need this directive to be inside an accordion
    restrict:'EA',
    transclude:true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl:'template/accordion/accordion-group.html',
    scope:{ heading:'@' },        // Create an isolated scope and interpolate the heading attribute onto this scope
    controller: ['$scope', function($scope) {
      this.setHeading = function(element) {
        this.heading = element;
      };
    }],
    link: function(scope, element, attrs, accordionCtrl) {
      var getIsOpen, setIsOpen;

      accordionCtrl.addGroup(scope);

      scope.isOpen = false;
      
      if ( attrs.isOpen ) {
        getIsOpen = $parse(attrs.isOpen);
        setIsOpen = getIsOpen.assign;

        accordionCtrl.scope.$watch(getIsOpen, function(value) {
          scope.isOpen = !!value;
        });
      }

      scope.$watch('isOpen', function(value) {
        if ( value ) {
          accordionCtrl.closeOthers(scope);
        }
        if ( setIsOpen ) {
          setIsOpen(accordionCtrl.scope, value);
        }
      });
    }
  };
}])

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function() {
  return {
    restrict: 'EA',
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^accordionGroup',
    compile: function(element, attr, transclude) {
      return function link(scope, element, attr, accordionGroupCtrl) {
        // Pass the heading to the accordion-group controller
        // so that it can be transcluded into the right place in the template
        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
        accordionGroupCtrl.setHeading(transclude(scope, function() {}));
      };
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function() {
  return {
    require: '^accordionGroup',
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if ( heading ) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
});

angular.module("ui.bootstrap.alert", []).directive('alert', function () {
  return {
    restrict:'EA',
    templateUrl:'template/alert/alert.html',
    transclude:true,
    replace:true,
    scope: {
      type: '=',
      close: '&'
    },
    link: function(scope, iElement, iAttrs) {
      scope.closeable = "close" in iAttrs;
    }
  };
});

angular.module('ui.bootstrap.bindHtml', [])

  .directive('bindHtmlUnsafe', function () {
    return function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || '');
      });
    };
  });
angular.module('ui.bootstrap.buttons', [])

.constant('buttonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.directive('btnRadio', ['buttonConfig', function (buttonConfig) {
  var activeClass = buttonConfig.activeClass || 'active';
  var toggleEvent = buttonConfig.toggleEvent || 'click';

  return {
    require: 'ngModel',
    link: function (scope, element, attrs, ngModelCtrl) {

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui->model
      element.bind(toggleEvent, function () {
        if (!element.hasClass(activeClass)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
}])

.directive('btnCheckbox', ['buttonConfig', function (buttonConfig) {
  var activeClass = buttonConfig.activeClass || 'active';
  var toggleEvent = buttonConfig.toggleEvent || 'click';

  return {
    require: 'ngModel',
    link: function (scope, element, attrs, ngModelCtrl) {

      function getTrueValue() {
        var trueValue = scope.$eval(attrs.btnCheckboxTrue);
        return angular.isDefined(trueValue) ? trueValue : true;
      }

      function getFalseValue() {
        var falseValue = scope.$eval(attrs.btnCheckboxFalse);
        return angular.isDefined(falseValue) ? falseValue : false;
      }

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.bind(toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
}]);

/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module('ui.bootstrap.carousel', ['ui.bootstrap.transition'])
.controller('CarouselController', ['$scope', '$timeout', '$transition', '$q', function ($scope, $timeout, $transition, $q) {
  var self = this,
    slides = self.slides = [],
    currentIndex = -1,
    currentTimeout, isPlaying;
  self.currentSlide = null;

  /* direction: "prev" or "next" */
  self.select = function(nextSlide, direction) {
    var nextIndex = slides.indexOf(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > currentIndex ? "next" : "prev";
    }
    if (nextSlide && nextSlide !== self.currentSlide) {
      if ($scope.$currentTransition) {
        $scope.$currentTransition.cancel();
        //Timeout so ng-class in template has time to fix classes for finished slide
        $timeout(goNext);
      } else {
        goNext();
      }
    }
    function goNext() {
      //If we have a slide to transition from and we have a transition type and we're allowed, go
      if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
        //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
        nextSlide.$element.addClass(direction);
        var reflow = nextSlide.$element[0].offsetWidth; //force reflow

        //Set all other slides to stop doing their stuff for the new transition
        angular.forEach(slides, function(slide) {
          angular.extend(slide, {direction: '', entering: false, leaving: false, active: false});
        });
        angular.extend(nextSlide, {direction: direction, active: true, entering: true});
        angular.extend(self.currentSlide||{}, {direction: direction, leaving: true});

        $scope.$currentTransition = $transition(nextSlide.$element, {});
        //We have to create new pointers inside a closure since next & current will change
        (function(next,current) {
          $scope.$currentTransition.then(
            function(){ transitionDone(next, current); },
            function(){ transitionDone(next, current); }
          );
        }(nextSlide, self.currentSlide));
      } else {
        transitionDone(nextSlide, self.currentSlide);
      }
      self.currentSlide = nextSlide;
      currentIndex = nextIndex;
      //every time you change slides, reset the timer
      restartTimer();
    }
    function transitionDone(next, current) {
      angular.extend(next, {direction: '', active: true, leaving: false, entering: false});
      angular.extend(current||{}, {direction: '', active: false, leaving: false, entering: false});
      $scope.$currentTransition = null;
    }
  };

  /* Allow outside people to call indexOf on slides array */
  self.indexOfSlide = function(slide) {
    return slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (currentIndex + 1) % slides.length;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'next');
    }
  };

  $scope.prev = function() {
    var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(slides[newIndex], 'prev');
    }
  };

  $scope.select = function(slide) {
    self.select(slide);
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.slides = function() {
    return slides;
  };

  $scope.$watch('interval', restartTimer);
  function restartTimer() {
    if (currentTimeout) {
      $timeout.cancel(currentTimeout);
    }
    function go() {
      if (isPlaying) {
        $scope.next();
        restartTimer();
      } else {
        $scope.pause();
      }
    }
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval>=0) {
      currentTimeout = $timeout(go, interval);
    }
  }
  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      if (currentTimeout) {
        $timeout.cancel(currentTimeout);
      }
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <carousel>
      <slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </slide>
      <slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </slide>
    </carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('carousel', [function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    require: 'carousel',
    templateUrl: 'template/carousel/carousel.html',
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '='
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <carousel>
    <slide ng-repeat="slide in slides" active="slide.active">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </slide>
  </carousel>
  <div class="row-fluid">
    <div class="span6">
      <ul>
        <li ng-repeat="slide in slides">
          <button class="btn btn-mini" ng-class="{'btn-info': !slide.active, 'btn-success': slide.active}" ng-disabled="slide.active" ng-click="slide.active = true">select</button>
          {{$index}}: {{slide.text}}
        </li>
      </ul>
      <a class="btn" ng-click="addSlide()">Add Slide</a>
    </div>
    <div class="span6">
      Interval, in milliseconds: <input type="number" ng-model="myInterval">
      <br />Enter a negative number to stop the interval.
    </div>
  </div>
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
  var slides = $scope.slides = [];
  $scope.addSlide = function() {
    var newWidth = 200 + ((slides.length + (25 * slides.length)) % 150);
    slides.push({
      image: 'http://placekitten.com/' + newWidth + '/200',
      text: ['More','Extra','Lots of','Surplus'][slides.length % 4] + ' '
        ['Cats', 'Kittys', 'Felines', 'Cutes'][slides.length % 4]
    });
  };
  for (var i=0; i<4; i++) $scope.addSlide();
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('slide', ['$parse', function($parse) {
  return {
    require: '^carousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: 'template/carousel/slide.html',
    scope: {
    },
    link: function (scope, element, attrs, carouselCtrl) {
      //Set up optional 'active' = binding
      if (attrs.active) {
        var getActive = $parse(attrs.active);
        var setActive = getActive.assign;
        var lastValue = scope.active = getActive(scope.$parent);
        scope.$watch(function parentActiveWatch() {
          var parentActive = getActive(scope.$parent);

          if (parentActive !== scope.active) {
            // we are out of sync and need to copy
            if (parentActive !== lastValue) {
              // parent changed and it has precedence
              lastValue = scope.active = parentActive;
            } else {
              // if the parent can be assigned then do so
              setActive(scope.$parent, parentActive = lastValue = scope.active);
            }
          }
          return parentActive;
        });
      }

      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, "position") || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft  || $document[0].documentElement.scrollLeft)
        };
      }
    };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.position'])

.constant('datepickerConfig', {
  dayFormat: 'dd',
  monthFormat: 'MMMM',
  yearFormat: 'yyyy',
  dayHeaderFormat: 'EEE',
  dayTitleFormat: 'MMMM yyyy',
  monthTitleFormat: 'yyyy',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null
})

.controller('DatepickerController', ['$scope', '$attrs', 'dateFilter', 'datepickerConfig', function($scope, $attrs, dateFilter, dtConfig) {
  var format = {
    day:        getValue($attrs.dayFormat,        dtConfig.dayFormat),
    month:      getValue($attrs.monthFormat,      dtConfig.monthFormat),
    year:       getValue($attrs.yearFormat,       dtConfig.yearFormat),
    dayHeader:  getValue($attrs.dayHeaderFormat,  dtConfig.dayHeaderFormat),
    dayTitle:   getValue($attrs.dayTitleFormat,   dtConfig.dayTitleFormat),
    monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
  },
  startingDay = getValue($attrs.startingDay,      dtConfig.startingDay),
  yearRange =   getValue($attrs.yearRange,        dtConfig.yearRange);

  this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
  this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;

  function getValue(value, defaultValue) {
    return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
  }

  function getDaysInMonth( year, month ) {
    return new Date(year, month, 0).getDate();
  }

  function getDates(startDate, n) {
    var dates = new Array(n);
    var current = startDate, i = 0;
    while (i < n) {
      dates[i++] = new Date(current);
      current.setDate( current.getDate() + 1 );
    }
    return dates;
  }

  function makeDate(date, format, isSelected, isSecondary) {
    return { date: date, label: dateFilter(date, format), selected: !!isSelected, secondary: !!isSecondary };
  }

  this.modes = [
    {
      name: 'day',
      getVisibleDates: function(date, selected) {
        var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
        var difference = startingDay - firstDayOfMonth.getDay(),
        numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
        firstDate = new Date(firstDayOfMonth), numDates = 0;

        if ( numDisplayedFromPreviousMonth > 0 ) {
          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
          numDates += numDisplayedFromPreviousMonth; // Previous
        }
        numDates += getDaysInMonth(year, month + 1); // Current
        numDates += (7 - numDates % 7) % 7; // Next

        var days = getDates(firstDate, numDates), labels = new Array(7);
        for (var i = 0; i < numDates; i ++) {
          var dt = new Date(days[i]);
          days[i] = makeDate(dt, format.day, (selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear()), dt.getMonth() !== month);
        }
        for (var j = 0; j < 7; j++) {
          labels[j] = dateFilter(days[j].date, format.dayHeader);
        }
        return { objects: days, title: dateFilter(date, format.dayTitle), labels: labels };
      },
      compare: function(date1, date2) {
        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
      },
      split: 7,
      step: { months: 1 }
    },
    {
      name: 'month',
      getVisibleDates: function(date, selected) {
        var months = new Array(12), year = date.getFullYear();
        for ( var i = 0; i < 12; i++ ) {
          var dt = new Date(year, i, 1);
          months[i] = makeDate(dt, format.month, (selected && selected.getMonth() === i && selected.getFullYear() === year));
        }
        return { objects: months, title: dateFilter(date, format.monthTitle) };
      },
      compare: function(date1, date2) {
        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
      },
      split: 3,
      step: { years: 1 }
    },
    {
      name: 'year',
      getVisibleDates: function(date, selected) {
        var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
        for ( var i = 0; i < yearRange; i++ ) {
          var dt = new Date(startYear + i, 0, 1);
          years[i] = makeDate(dt, format.year, (selected && selected.getFullYear() === dt.getFullYear()));
        }
        return { objects: years, title: [years[0].label, years[yearRange - 1].label].join(' - ') };
      },
      compare: function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      },
      split: 5,
      step: { years: yearRange }
    }
  ];

  this.isDisabled = function(date, mode) {
    var currentMode = this.modes[mode || 0];
    return ((this.minDate && currentMode.compare(date, this.minDate) < 0) || (this.maxDate && currentMode.compare(date, this.maxDate) > 0) || ($scope.dateDisabled && $scope.dateDisabled({date: date, mode: currentMode.name})));
  };
}])

.directive( 'datepicker', ['dateFilter', '$parse', 'datepickerConfig', '$log', function (dateFilter, $parse, datepickerConfig, $log) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/datepicker.html',
    scope: {
      dateDisabled: '&'
    },
    require: ['datepicker', '?^ngModel'],
    controller: 'DatepickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModel = ctrls[1];

      if (!ngModel) {
        return; // do nothing if no ng-model
      }

      // Configuration parameters
      var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;

      if (attrs.showWeeks) {
        scope.$parent.$watch($parse(attrs.showWeeks), function(value) {
          showWeeks = !! value;
          updateShowWeekNumbers();
        });
      } else {
        updateShowWeekNumbers();
      }

      if (attrs.min) {
        scope.$parent.$watch($parse(attrs.min), function(value) {
          datepickerCtrl.minDate = value ? new Date(value) : null;
          refill();
        });
      }
      if (attrs.max) {
        scope.$parent.$watch($parse(attrs.max), function(value) {
          datepickerCtrl.maxDate = value ? new Date(value) : null;
          refill();
        });
      }

      function updateShowWeekNumbers() {
        scope.showWeekNumbers = mode === 0 && showWeeks;
      }

      // Split array into smaller arrays
      function split(arr, size) {
        var arrays = [];
        while (arr.length > 0) {
          arrays.push(arr.splice(0, size));
        }
        return arrays;
      }

      function refill( updateSelected ) {
        var date = null, valid = true;

        if ( ngModel.$modelValue ) {
          date = new Date( ngModel.$modelValue );

          if ( isNaN(date) ) {
            valid = false;
            $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
          } else if ( updateSelected ) {
            selected = date;
          }
        }
        ngModel.$setValidity('date', valid);

        var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
        angular.forEach(data.objects, function(obj) {
          obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
        });

        ngModel.$setValidity('date-disabled', (!date || !datepickerCtrl.isDisabled(date)));

        scope.rows = split(data.objects, currentMode.split);
        scope.labels = data.labels || [];
        scope.title = data.title;
      }

      function setMode(value) {
        mode = value;
        updateShowWeekNumbers();
        refill();
      }

      ngModel.$render = function() {
        refill( true );
      };

      scope.select = function( date ) {
        if ( mode === 0 ) {
          var dt = new Date( ngModel.$modelValue );
          dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
          ngModel.$setViewValue( dt );
          refill( true );
        } else {
          selected = date;
          setMode( mode - 1 );
        }
      };
      scope.move = function(direction) {
        var step = datepickerCtrl.modes[mode].step;
        selected.setMonth( selected.getMonth() + direction * (step.months || 0) );
        selected.setFullYear( selected.getFullYear() + direction * (step.years || 0) );
        refill();
      };
      scope.toggleMode = function() {
        setMode( (mode + 1) % datepickerCtrl.modes.length );
      };
      scope.getWeekNumber = function(row) {
        return ( mode === 0 && scope.showWeekNumbers && row.length === 7 ) ? getISO8601WeekNumber(row[0].date) : null;
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }
    }
  };
}])

.constant('datepickerPopupConfig', {
  dateFormat: 'yyyy-MM-dd',
  currentText: 'Today',
  toggleWeeksText: 'Weeks',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'datepickerPopupConfig', 'datepickerConfig',
function ($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig, datepickerConfig) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    link: function(originalScope, element, attrs, ngModel) {
      var dateFormat;
      attrs.$observe('datepickerPopup', function(value) {
          dateFormat = value || datepickerPopupConfig.dateFormat;
          ngModel.$render();
      });

      var closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? originalScope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
      var appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? originalScope.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;

      // create a child scope for the datepicker directive so we are not polluting original scope
      var scope = originalScope.$new();

      originalScope.$on('$destroy', function() {
        scope.$destroy();
      });

      attrs.$observe('currentText', function(text) {
        scope.currentText = angular.isDefined(text) ? text : datepickerPopupConfig.currentText;
      });
      attrs.$observe('toggleWeeksText', function(text) {
        scope.toggleWeeksText = angular.isDefined(text) ? text : datepickerPopupConfig.toggleWeeksText;
      });
      attrs.$observe('clearText', function(text) {
        scope.clearText = angular.isDefined(text) ? text : datepickerPopupConfig.clearText;
      });
      attrs.$observe('closeText', function(text) {
        scope.closeText = angular.isDefined(text) ? text : datepickerPopupConfig.closeText;
      });

      var getIsOpen, setIsOpen;
      if ( attrs.isOpen ) {
        getIsOpen = $parse(attrs.isOpen);
        setIsOpen = getIsOpen.assign;

        originalScope.$watch(getIsOpen, function updateOpen(value) {
          scope.isOpen = !! value;
        });
      }
      scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false; // Initial state

      function setOpen( value ) {
        if (setIsOpen) {
          setIsOpen(originalScope, !!value);
        } else {
          scope.isOpen = !!value;
        }
      }

      var documentClickBind = function(event) {
        if (scope.isOpen && event.target !== element[0]) {
          scope.$apply(function() {
            setOpen(false);
          });
        }
      };

      var elementFocusBind = function() {
        scope.$apply(function() {
          setOpen( true );
        });
      };

      // popup element used to display calendar
      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection()'
      });
      var datepickerEl = angular.element(popupEl.children()[0]);
      if (attrs.datepickerOptions) {
        datepickerEl.attr(angular.extend({}, originalScope.$eval(attrs.datepickerOptions)));
      }

      // TODO: reverse from dateFilter string to Date object
      function parseDate(viewValue) {
        if (!viewValue) {
          ngModel.$setValidity('date', true);
          return null;
        } else if (angular.isDate(viewValue)) {
          ngModel.$setValidity('date', true);
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = new Date(viewValue);
          if (isNaN(date)) {
            ngModel.$setValidity('date', false);
            return undefined;
          } else {
            ngModel.$setValidity('date', true);
            return date;
          }
        } else {
          ngModel.$setValidity('date', false);
          return undefined;
        }
      }
      ngModel.$parsers.unshift(parseDate);

      // Inner change
      scope.dateSelection = function() {
        ngModel.$setViewValue(scope.date);
        ngModel.$render();

        if (closeOnDateSelection) {
          setOpen( false );
        }
      };

      element.bind('input change keyup', function() {
        scope.$apply(function() {
          updateCalendar();
        });
      });

      // Outter change
      ngModel.$render = function() {
        var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : '';
        element.val(date);

        updateCalendar();
      };

      function updateCalendar() {
        scope.date = ngModel.$modelValue;
        updatePosition();
      }

      function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
        if (attribute) {
          originalScope.$watch($parse(attribute), function(value){
            scope[scopeProperty] = value;
          });
          datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
        }
      }
      addWatchableAttribute(attrs.min, 'min');
      addWatchableAttribute(attrs.max, 'max');
      if (attrs.showWeeks) {
        addWatchableAttribute(attrs.showWeeks, 'showWeeks', 'show-weeks');
      } else {
        scope.showWeeks = datepickerConfig.showWeeks;
        datepickerEl.attr('show-weeks', 'showWeeks');
      }
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', attrs.dateDisabled);
      }

      function updatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element);
        scope.position.top = scope.position.top + element.prop('offsetHeight');
      }

      var documentBindingInitialized = false, elementFocusInitialized = false;
      scope.$watch('isOpen', function(value) {
        if (value) {
          updatePosition();
          $document.bind('click', documentClickBind);
          if(elementFocusInitialized) {
            element.unbind('focus', elementFocusBind);
          }
          element[0].focus();
          documentBindingInitialized = true;
        } else {
          if(documentBindingInitialized) {
            $document.unbind('click', documentClickBind);
          }
          element.bind('focus', elementFocusBind);
          elementFocusInitialized = true;
        }

        if ( setIsOpen ) {
          setIsOpen(originalScope, value);
        }
      });

      var $setModelValue = $parse(attrs.ngModel).assign;

      scope.today = function() {
        $setModelValue(originalScope, new Date());
      };
      scope.clear = function() {
        $setModelValue(originalScope, null);
      };

      var $popup = $compile(popupEl)(scope);
      if ( appendToBody ) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }
    }
  };
}])

.directive('datepickerPopupWrap', function() {
  return {
    restrict:'EA',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link:function (scope, element, attrs) {
      element.bind('click', function(event) {
        event.preventDefault();
        event.stopPropagation();
      });
    }
  };
});

/*
 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
 * @restrict class or attribute
 * @example:
   <li class="dropdown">
     <a class="dropdown-toggle">My Dropdown Menu</a>
     <ul class="dropdown-menu">
       <li ng-repeat="choice in dropChoices">
         <a ng-href="{{choice.href}}">{{choice.text}}</a>
       </li>
     </ul>
   </li>
 */

angular.module('ui.bootstrap.dropdownToggle', []).directive('dropdownToggle', ['$document', '$location', function ($document, $location) {
  var openElement = null,
      closeMenu   = angular.noop;
  return {
    restrict: 'CA',
    link: function(scope, element, attrs) {
      scope.$watch('$location.path', function() { closeMenu(); });
      element.parent().bind('click', function() { closeMenu(); });
      element.bind('click', function (event) {

        var elementWasOpen = (element === openElement);

        event.preventDefault();
        event.stopPropagation();

        if (!!openElement) {
          closeMenu();
        }

        if (!elementWasOpen && !element.hasClass('disabled') && !element.prop('disabled')) {
          element.parent().addClass('open');
          openElement = element;
          closeMenu = function (event) {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            $document.unbind('click', closeMenu);
            element.parent().removeClass('open');
            closeMenu = angular.noop;
            openElement = null;
          };
          $document.bind('click', closeMenu);
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.modal', [])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function () {
    return {
      createNew: function () {
        var stack = [];

        return {
          add: function (key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function (key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function () {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('modalBackdrop', ['$modalStack', '$timeout', function ($modalStack, $timeout) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      link: function (scope, element, attrs) {

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });

        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop != 'static') {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };
      }
    };
  }])

  .directive('modalWindow', ['$timeout', function ($timeout) {
    return {
      restrict: 'EA',
      scope: {
        index: '@'
      },
      replace: true,
      transclude: true,
      templateUrl: 'template/modal/window.html',
      link: function (scope, element, attrs) {
        scope.windowClass = attrs.windowClass || '';

        //trigger CSS transitions
        $timeout(function () {
          scope.animate = true;
        });
      }
    };
  }])

  .factory('$modalStack', ['$document', '$compile', '$rootScope', '$$stackedMap',
    function ($document, $compile, $rootScope, $$stackedMap) {

      var backdropjqLiteEl, backdropDomEl;
      var backdropScope = $rootScope.$new(true);
      var body = $document.find('body').eq(0);
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
        backdropScope.index = newBackdropIndex;
      });

      function removeModalWindow(modalInstance) {

        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        //remove window DOM element
        modalWindow.modalDomEl.remove();

        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() == -1) {
          backdropDomEl.remove();
          backdropDomEl = undefined;
        }

        //destroy scope
        modalWindow.modalScope.$destroy();
      }

      $document.bind('keydown', function (evt) {
        var modal;

        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            $rootScope.$apply(function () {
              $modalStack.dismiss(modal.key);
            });
          }
        }
      });

      $modalStack.open = function (modalInstance, modal) {

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });

        var angularDomEl = angular.element('<div modal-window></div>');
        angularDomEl.attr('window-class', modal.windowClass);
        angularDomEl.attr('index', openedWindows.length() - 1);
        angularDomEl.html(modal.content);

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        body.append(modalDomEl);

        if (backdropIndex() >= 0 && !backdropDomEl) {
            backdropjqLiteEl = angular.element('<div modal-backdrop></div>');
            backdropDomEl = $compile(backdropjqLiteEl)(backdropScope);
            body.append(backdropDomEl);
        }
      };

      $modalStack.close = function (modalInstance, result) {
        var modal = openedWindows.get(modalInstance);
        if (modal) {
          modal.value.deferred.resolve(result);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
          modalWindow.deferred.reject(reason);
          removeModalWindow(modalInstance);
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      return $modalStack;
    }])

  .provider('$modal', function () {

    var $modalProvider = {
      options: {
        backdrop: true, //can be also false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack',
        function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {

          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $http.get(options.templateUrl, {cache: $templateCache}).then(function (result) {
                return result.data;
              });
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value, key) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              close: function (result) {
                $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;

              //controllers
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });

                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
              }

              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                content: tplAndVars[0],
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                windowClass: modalOptions.windowClass
              });

            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });

            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function () {
              modalOpenedDeferred.reject(false);
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function ($scope, $attrs, $parse, $interpolate) {
  var self = this,
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(defaultItemsPerPage) {
    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = defaultItemsPerPage;
    }
  };

  this.noPrevious = function() {
    return this.page === 1;
  };
  this.noNext = function() {
    return this.page === $scope.totalPages;
  };

  this.isActive = function(page) {
    return this.page === page;
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.getAttributeValue = function(attribute, defaultValue, interpolate) {
    return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
  };

  this.render = function() {
    this.page = parseInt($scope.page, 10) || 1;
    if (this.page > 0 && this.page <= $scope.totalPages) {
      $scope.pages = this.getPages(this.page, $scope.totalPages);
    }
  };

  $scope.selectPage = function(page) {
    if ( ! self.isActive(page) && page > 0 && page <= $scope.totalPages) {
      $scope.page = page;
      $scope.onSelectPage({ page: page });
    }
  };

  $scope.$watch('page', function() {
    self.render();
  });

  $scope.$watch('totalItems', function() {
    $scope.totalPages = self.calculateTotalPages();
  });

  $scope.$watch('totalPages', function(value) {
    setNumPages($scope.$parent, value); // Readonly variable

    if ( self.page > value ) {
      $scope.selectPage(value);
    } else {
      self.render();
    }
  });
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &'
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var maxSize,
      boundaryLinks  = paginationCtrl.getAttributeValue(attrs.boundaryLinks,  config.boundaryLinks      ),
      directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks     ),
      firstText      = paginationCtrl.getAttributeValue(attrs.firstText,      config.firstText,     true),
      previousText   = paginationCtrl.getAttributeValue(attrs.previousText,   config.previousText,  true),
      nextText       = paginationCtrl.getAttributeValue(attrs.nextText,       config.nextText,      true),
      lastText       = paginationCtrl.getAttributeValue(attrs.lastText,       config.lastText,      true),
      rotate         = paginationCtrl.getAttributeValue(attrs.rotate,         config.rotate);

      paginationCtrl.init(config.itemsPerPage);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive, isDisabled) {
        return {
          number: number,
          text: text,
          active: isActive,
          disabled: isDisabled
        };
      }

      paginationCtrl.getPages = function(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, paginationCtrl.isActive(number), false);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false, false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false, false);
            pages.push(nextPageSet);
          }
        }

        // Add previous & next links
        if (directionLinks) {
          var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
          pages.unshift(previousPage);

          var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
          pages.push(nextPage);
        }

        // Add first & last links
        if (boundaryLinks) {
          var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
          pages.unshift(firstPage);

          var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
          pages.push(lastPage);
        }

        return pages;
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: '« Previous',
  nextText: 'Next »',
  align: true
})

.directive('pager', ['pagerConfig', function(config) {
  return {
    restrict: 'EA',
    scope: {
      page: '=',
      totalItems: '=',
      onSelectPage:' &'
    },
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, paginationCtrl) {

      // Setup configuration parameters
      var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
      nextText         = paginationCtrl.getAttributeValue(attrs.nextText,     config.nextText,     true),
      align            = paginationCtrl.getAttributeValue(attrs.align,        config.align);

      paginationCtrl.init(config.itemsPerPage);

      // Create page object used in template
      function makePage(number, text, isDisabled, isPrevious, isNext) {
        return {
          number: number,
          text: text,
          disabled: isDisabled,
          previous: ( align && isPrevious ),
          next: ( align && isNext )
        };
      }

      paginationCtrl.getPages = function(currentPage) {
        return [
          makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false),
          makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)
        ];
      };
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider( '$tooltip', function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur'
  };

  // The options specified to the provider globally.
  var globalOptions = {};
  
  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function( value ) {
		angular.extend( globalOptions, value );
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers ( triggers ) {
    angular.extend( triggerMap, triggers );
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name){
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = [ '$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function ( $window, $compile, $timeout, $parse, $document, $position, $interpolate ) {
    return function $tooltip ( type, prefix, defaultTriggerShow ) {
      var options = angular.extend( {}, defaultOptions, globalOptions );

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers ( trigger ) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case( type );

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template = 
        '<'+ directiveName +'-popup '+
          'title="'+startSym+'tt_title'+endSym+'" '+
          'content="'+startSym+'tt_content'+endSym+'" '+
          'placement="'+startSym+'tt_placement'+endSym+'" '+
          'animation="tt_animation" '+
          'is-open="tt_isOpen"'+
          '>'+
        '</'+ directiveName +'-popup>';

      return {
        restrict: 'EA',
        scope: true,
        link: function link ( scope, element, attrs ) {
          var tooltip = $compile( template )( scope );
          var transitionTimeout;
          var popupTimeout;
          var $body = $document.find( 'body' );
          var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
          var triggers = getTriggers( undefined );
          var hasRegisteredTriggers = false;
          var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);

          // By default, the tooltip is not open.
          // TODO add ability to start tooltip opened
          scope.tt_isOpen = false;

          function toggleTooltipBind () {
            if ( ! scope.tt_isOpen ) {
              showTooltipBind();
            } else {
              hideTooltipBind();
            }
          }
          
          // Show the tooltip with delay if specified, otherwise show it immediately
          function showTooltipBind() {
            if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {
              return;
            }
            if ( scope.tt_popupDelay ) {
              popupTimeout = $timeout( show, scope.tt_popupDelay );
            } else {
              scope.$apply( show );
            }
          }

          function hideTooltipBind () {
            scope.$apply(function () {
              hide();
            });
          }
          
          // Show the tooltip popup element.
          function show() {
            var position,
                ttWidth,
                ttHeight,
                ttPosition;

            // Don't show empty tooltips.
            if ( ! scope.tt_content ) {
              return;
            }

            // If there is a pending remove transition, we must cancel it, lest the
            // tooltip be mysteriously removed.
            if ( transitionTimeout ) {
              $timeout.cancel( transitionTimeout );
            }
            
            // Set the initial positioning.
            tooltip.css({ top: 0, left: 0, display: 'block' });
            
            // Now we add it to the DOM because need some info about it. But it's not 
            // visible yet anyway.
            if ( appendToBody ) {
                $body.append( tooltip );
            } else {
              element.after( tooltip );
            }

            // Get the position of the directive element.
            position = appendToBody ? $position.offset( element ) : $position.position( element );

            // Get the height and width of the tooltip so we can center it.
            ttWidth = tooltip.prop( 'offsetWidth' );
            ttHeight = tooltip.prop( 'offsetHeight' );
            
            // Calculate the tooltip's top and left coordinates to center it with
            // this directive.
            switch ( scope.tt_placement ) {
              case 'right':
                ttPosition = {
                  top: position.top + position.height / 2 - ttHeight / 2,
                  left: position.left + position.width
                };
                break;
              case 'bottom':
                ttPosition = {
                  top: position.top + position.height,
                  left: position.left + position.width / 2 - ttWidth / 2
                };
                break;
              case 'left':
                ttPosition = {
                  top: position.top + position.height / 2 - ttHeight / 2,
                  left: position.left - ttWidth
                };
                break;
              default:
                ttPosition = {
                  top: position.top - ttHeight,
                  left: position.left + position.width / 2 - ttWidth / 2
                };
                break;
            }

            ttPosition.top += 'px';
            ttPosition.left += 'px';

            // Now set the calculated positioning.
            tooltip.css( ttPosition );
              
            // And show the tooltip.
            scope.tt_isOpen = true;
          }
          
          // Hide the tooltip popup element.
          function hide() {
            // First things first: we don't show it anymore.
            scope.tt_isOpen = false;

            //if tooltip is going to be shown after delay, we must cancel this
            $timeout.cancel( popupTimeout );
            
            // And now we remove it from the DOM. However, if we have animation, we 
            // need to wait for it to expire beforehand.
            // FIXME: this is a placeholder for a port of the transitions library.
            if ( scope.tt_animation ) {
              transitionTimeout = $timeout(function () {
                tooltip.remove();
              }, 500);
            } else {
              tooltip.remove();
            }
          }

          /**
           * Observe the relevant attributes.
           */
          attrs.$observe( type, function ( val ) {
            if (val) {
              scope.tt_content = val;
            } else {
              if ( scope.tt_isOpen ) {
                hide();
              }
            }
          });

          attrs.$observe( prefix+'Title', function ( val ) {
            scope.tt_title = val;
          });

          attrs.$observe( prefix+'Placement', function ( val ) {
            scope.tt_placement = angular.isDefined( val ) ? val : options.placement;
          });

          attrs.$observe(prefix + 'Animation', function (val) {
            scope.tt_animation = angular.isDefined(val) ? !!val : options.animation;
          });

          attrs.$observe( prefix+'PopupDelay', function ( val ) {
            var delay = parseInt( val, 10 );
            scope.tt_popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
          });

          attrs.$observe( prefix+'Trigger', function ( val ) {

            if (hasRegisteredTriggers) {
              element.unbind( triggers.show, showTooltipBind );
              element.unbind( triggers.hide, hideTooltipBind );
            }

            triggers = getTriggers( val );

            if ( triggers.show === triggers.hide ) {
              element.bind( triggers.show, toggleTooltipBind );
            } else {
              element.bind( triggers.show, showTooltipBind );
              element.bind( triggers.hide, hideTooltipBind );
            }

            hasRegisteredTriggers = true;
          });

          attrs.$observe( prefix+'AppendToBody', function ( val ) {
            appendToBody = angular.isDefined( val ) ? $parse( val )( scope ) : appendToBody;
          });

          // if a tooltip is attached to <body> we need to remove it on
          // location change as its parent scope will probably not be destroyed
          // by the change.
          if ( appendToBody ) {
            scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {
            if ( scope.tt_isOpen ) {
              hide();
            }
          });
          }

          // Make sure tooltip is destroyed and removed.
          scope.$on('$destroy', function onDestroyTooltip() {
            $timeout.cancel( popupTimeout );
            tooltip.remove();
            tooltip.unbind();
            tooltip = null;
            $body = null;
          });
        }
      };
    };
  }];
})

.directive( 'tooltipPopup', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
})

.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );
}])

.directive( 'tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'E',
    replace: true,
    scope: { content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
})

.directive( 'tooltipHtmlUnsafe', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )
.directive( 'popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', content: '@', placement: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html'
  };
})
.directive( 'popover', [ '$compile', '$timeout', '$parse', '$window', '$tooltip', function ( $compile, $timeout, $parse, $window, $tooltip ) {
  return $tooltip( 'popover', 'popover', 'click' );
}]);


angular.module('ui.bootstrap.progressbar', ['ui.bootstrap.transition'])

.constant('progressConfig', {
  animate: true,
  autoType: false,
  stackedTypes: ['success', 'info', 'warning', 'danger']
})

.controller('ProgressBarController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {

    // Whether bar transitions should be animated
    var animate = angular.isDefined($attrs.animate) ? $scope.$eval($attrs.animate) : progressConfig.animate;
    var autoType = angular.isDefined($attrs.autoType) ? $scope.$eval($attrs.autoType) : progressConfig.autoType;
    var stackedTypes = angular.isDefined($attrs.stackedTypes) ? $scope.$eval('[' + $attrs.stackedTypes + ']') : progressConfig.stackedTypes;

    // Create bar object
    this.makeBar = function(newBar, oldBar, index) {
        var newValue = (angular.isObject(newBar)) ? newBar.value : (newBar || 0);
        var oldValue =  (angular.isObject(oldBar)) ? oldBar.value : (oldBar || 0);
        var type = (angular.isObject(newBar) && angular.isDefined(newBar.type)) ? newBar.type : (autoType) ? getStackedType(index || 0) : null;

        return {
            from: oldValue,
            to: newValue,
            type: type,
            animate: animate
        };
    };

    function getStackedType(index) {
        return stackedTypes[index];
    }

    this.addBar = function(bar) {
        $scope.bars.push(bar);
        $scope.totalPercent += bar.to;
    };

    this.clearBars = function() {
        $scope.bars = [];
        $scope.totalPercent = 0;
    };
    this.clearBars();
}])

.directive('progress', function() {
    return {
        restrict: 'EA',
        replace: true,
        controller: 'ProgressBarController',
        scope: {
            value: '=percent',
            onFull: '&',
            onEmpty: '&'
        },
        templateUrl: 'template/progressbar/progress.html',
        link: function(scope, element, attrs, controller) {
            scope.$watch('value', function(newValue, oldValue) {
                controller.clearBars();

                if (angular.isArray(newValue)) {
                    // Stacked progress bar
                    for (var i=0, n=newValue.length; i < n; i++) {
                        controller.addBar(controller.makeBar(newValue[i], oldValue[i], i));
                    }
                } else {
                    // Simple bar
                    controller.addBar(controller.makeBar(newValue, oldValue));
                }
            }, true);

            // Total percent listeners
            scope.$watch('totalPercent', function(value) {
              if (value >= 100) {
                scope.onFull();
              } else if (value <= 0) {
                scope.onEmpty();
              }
            }, true);
        }
    };
})

.directive('progressbar', ['$transition', function($transition) {
    return {
        restrict: 'EA',
        replace: true,
        scope: {
            width: '=',
            old: '=',
            type: '=',
            animate: '='
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element) {
            scope.$watch('width', function(value) {
                if (scope.animate) {
                    element.css('width', scope.old + '%');
                    $transition(element, {width: value + '%'});
                } else {
                    element.css('width', value + '%');
                }
            });
        }
    };
}]);
angular.module('ui.bootstrap.rating', [])

.constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
})

.controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {

  this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
  this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
  this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

  this.createRateObjects = function(states) {
    var defaultOptions = {
      stateOn: this.stateOn,
      stateOff: this.stateOff
    };

    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, defaultOptions, states[i]);
    }
    return states;
  };

  // Get objects used in template
  $scope.range = angular.isDefined($attrs.ratingStates) ?  this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))): this.createRateObjects(new Array(this.maxRange));

  $scope.rate = function(value) {
    if ( $scope.readonly || $scope.value === value) {
      return;
    }

    $scope.value = value;
  };

  $scope.enter = function(value) {
    if ( ! $scope.readonly ) {
      $scope.val = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.val = angular.copy($scope.value);
    $scope.onLeave();
  };

  $scope.$watch('value', function(value) {
    $scope.val = value;
  });

  $scope.readonly = false;
  if ($attrs.readonly) {
    $scope.$parent.$watch($parse($attrs.readonly), function(value) {
      $scope.readonly = !!value;
    });
  }
}])

.directive('rating', function() {
  return {
    restrict: 'EA',
    scope: {
      value: '=',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true
  };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.directive('tabs', function() {
  return function() {
    throw new Error("The `tabs` directive is deprecated, please migrate to `tabset`. Instructions can be found at http://github.com/angular-ui/bootstrap/tree/master/CHANGELOG.md");
  };
})

.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(tab) {
    angular.forEach(tabs, function(tab) {
      tab.active = false;
    });
    tab.active = true;
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    if (tabs.length === 1 || tab.active) {
      ctrl.select(tab);
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected
    if (tab.active && tabs.length > 1) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {string=} direction  What direction the tabs should be rendered. Available:
 * 'right', 'left', 'below'.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Vertical Tab 1"><b>First</b> Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    require: '^tabset',
    scope: {},
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    compile: function(elm, attrs, transclude) {
      return function(scope, element, attrs, tabsetCtrl) {
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
        scope.direction = angular.isDefined(attrs.direction) ? scope.$parent.$eval(attrs.direction) : 'top';
        scope.tabsAbove = (scope.direction != 'below');
        tabsetCtrl.$scope = scope;
        tabsetCtrl.$transcludeFn = transclude;
      };
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', function($parse) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    compile: function(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {
        var getActive, setActive;
        if (attrs.active) {
          getActive = $parse(attrs.active);
          setActive = getActive.assign;
          scope.$parent.$watch(getActive, function updateActive(value, oldVal) {
            // Avoid re-initializing scope.active as it is already initialized
            // below. (watcher is called async during init with value ===
            // oldVal)
            if (value !== oldVal) {
              scope.active = !!value;
            }
          });
          scope.active = getActive(scope.$parent);
        } else {
          setActive = getActive = angular.noop;
        }

        scope.$watch('active', function(active) {
          // Note this watcher also initializes and assigns scope.active to the
          // attrs.active expression.
          setActive(scope.$parent, active);
          if (active) {
            tabsetCtrl.select(scope);
            scope.onSelect();
          } else {
            scope.onDeselect();
          }
        });

        scope.disabled = false;
        if ( attrs.disabled ) {
          scope.$parent.$watch($parse(attrs.disabled), function(value) {
            scope.disabled = !! value;
          });
        }

        scope.select = function() {
          if ( ! scope.disabled ) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });


        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}])

.directive('tabHeadingTransclude', [function() {
  return {
    restrict: 'A',
    require: '^tab',
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
}])

.directive('tabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName &&  (
      node.hasAttribute('tab-heading') ||
      node.hasAttribute('data-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' ||
      node.tagName.toLowerCase() === 'data-tab-heading'
    );
  }
})

.directive('tabsetTitles', function() {
  return {
    restrict: 'A',
    require: '^tabset',
    templateUrl: 'template/tabs/tabset-titles.html',
    replace: true,
    link: function(scope, elm, attrs, tabsetCtrl) {
      if (!scope.$eval(attrs.tabsetTitles)) {
        elm.remove();
      } else {
        //now that tabs location has been decided, transclude the tab titles in
        tabsetCtrl.$transcludeFn(tabsetCtrl.$scope.$parent, function(node) {
          elm.append(node);
        });
      }
    }
  };
});

angular.module('ui.bootstrap.timepicker', [])

.constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: ['AM', 'PM'],
  readonlyInput: false,
  mousewheel: true
})

.directive('timepicker', ['$parse', '$log', 'timepickerConfig', function ($parse, $log, timepickerConfig) {
  return {
    restrict: 'EA',
    require:'?^ngModel',
    replace: true,
    scope: {},
    templateUrl: 'template/timepicker/timepicker.html',
    link: function(scope, element, attrs, ngModel) {
      if ( !ngModel ) {
        return; // do nothing if no ng-model
      }

      var selected = new Date(), meridians = timepickerConfig.meridians;

      var hourStep = timepickerConfig.hourStep;
      if (attrs.hourStep) {
        scope.$parent.$watch($parse(attrs.hourStep), function(value) {
          hourStep = parseInt(value, 10);
        });
      }

      var minuteStep = timepickerConfig.minuteStep;
      if (attrs.minuteStep) {
        scope.$parent.$watch($parse(attrs.minuteStep), function(value) {
          minuteStep = parseInt(value, 10);
        });
      }

      // 12H / 24H mode
      scope.showMeridian = timepickerConfig.showMeridian;
      if (attrs.showMeridian) {
        scope.$parent.$watch($parse(attrs.showMeridian), function(value) {
          scope.showMeridian = !!value;

          if ( ngModel.$error.time ) {
            // Evaluate from template
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            if (angular.isDefined( hours ) && angular.isDefined( minutes )) {
              selected.setHours( hours );
              refresh();
            }
          } else {
            updateTemplate();
          }
        });
      }

      // Get scope.hours in 24H mode if valid
      function getHoursFromTemplate ( ) {
        var hours = parseInt( scope.hours, 10 );
        var valid = ( scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
        if ( !valid ) {
          return undefined;
        }

        if ( scope.showMeridian ) {
          if ( hours === 12 ) {
            hours = 0;
          }
          if ( scope.meridian === meridians[1] ) {
            hours = hours + 12;
          }
        }
        return hours;
      }

      function getMinutesFromTemplate() {
        var minutes = parseInt(scope.minutes, 10);
        return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;
      }

      function pad( value ) {
        return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value;
      }

      // Input elements
      var inputs = element.find('input'), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);

      // Respond on mousewheel spin
      var mousewheel = (angular.isDefined(attrs.mousewheel)) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
      if ( mousewheel ) {

        var isScrollingUp = function(e) {
          if (e.originalEvent) {
            e = e.originalEvent;
          }
          //pick correct delta variable depending on event
          var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
          return (e.detail || delta > 0);
        };

        hoursInputEl.bind('mousewheel wheel', function(e) {
          scope.$apply( (isScrollingUp(e)) ? scope.incrementHours() : scope.decrementHours() );
          e.preventDefault();
        });

        minutesInputEl.bind('mousewheel wheel', function(e) {
          scope.$apply( (isScrollingUp(e)) ? scope.incrementMinutes() : scope.decrementMinutes() );
          e.preventDefault();
        });
      }

      scope.readonlyInput = (angular.isDefined(attrs.readonlyInput)) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
      if ( ! scope.readonlyInput ) {

        var invalidate = function(invalidHours, invalidMinutes) {
          ngModel.$setViewValue( null );
          ngModel.$setValidity('time', false);
          if (angular.isDefined(invalidHours)) {
            scope.invalidHours = invalidHours;
          }
          if (angular.isDefined(invalidMinutes)) {
            scope.invalidMinutes = invalidMinutes;
          }
        };

        scope.updateHours = function() {
          var hours = getHoursFromTemplate();

          if ( angular.isDefined(hours) ) {
            selected.setHours( hours );
            refresh( 'h' );
          } else {
            invalidate(true);
          }
        };

        hoursInputEl.bind('blur', function(e) {
          if ( !scope.validHours && scope.hours < 10) {
            scope.$apply( function() {
              scope.hours = pad( scope.hours );
            });
          }
        });

        scope.updateMinutes = function() {
          var minutes = getMinutesFromTemplate();

          if ( angular.isDefined(minutes) ) {
            selected.setMinutes( minutes );
            refresh( 'm' );
          } else {
            invalidate(undefined, true);
          }
        };

        minutesInputEl.bind('blur', function(e) {
          if ( !scope.invalidMinutes && scope.minutes < 10 ) {
            scope.$apply( function() {
              scope.minutes = pad( scope.minutes );
            });
          }
        });
      } else {
        scope.updateHours = angular.noop;
        scope.updateMinutes = angular.noop;
      }

      ngModel.$render = function() {
        var date = ngModel.$modelValue ? new Date( ngModel.$modelValue ) : null;

        if ( isNaN(date) ) {
          ngModel.$setValidity('time', false);
          $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        } else {
          if ( date ) {
            selected = date;
          }
          makeValid();
          updateTemplate();
        }
      };

      // Call internally when we know that model is valid.
      function refresh( keyboardChange ) {
        makeValid();
        ngModel.$setViewValue( new Date(selected) );
        updateTemplate( keyboardChange );
      }

      function makeValid() {
        ngModel.$setValidity('time', true);
        scope.invalidHours = false;
        scope.invalidMinutes = false;
      }

      function updateTemplate( keyboardChange ) {
        var hours = selected.getHours(), minutes = selected.getMinutes();

        if ( scope.showMeridian ) {
          hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
        }
        scope.hours =  keyboardChange === 'h' ? hours : pad(hours);
        scope.minutes = keyboardChange === 'm' ? minutes : pad(minutes);
        scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
      }

      function addMinutes( minutes ) {
        var dt = new Date( selected.getTime() + minutes * 60000 );
        selected.setHours( dt.getHours(), dt.getMinutes() );
        refresh();
      }

      scope.incrementHours = function() {
        addMinutes( hourStep * 60 );
      };
      scope.decrementHours = function() {
        addMinutes( - hourStep * 60 );
      };
      scope.incrementMinutes = function() {
        addMinutes( minuteStep );
      };
      scope.decrementMinutes = function() {
        addMinutes( - minuteStep );
      };
      scope.toggleMeridian = function() {
        addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );
      };
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('typeaheadParser', ['$parse', function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

  return {
    parse:function (input) {

      var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
      if (!match) {
        throw new Error(
          "Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" +
            " but got '" + input + "'.");
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',
    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require:'ngModel',
    link:function (originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typehead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);

      var hasFocus;

      //pop-up element used to display matches
      var popUpEl = angular.element('<div typeahead-popup></div>');
      popUpEl.attr({
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        query: 'query',
        position: 'position'
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function(){
        scope.$destroy();
      });

      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
      };

      var getMatchesAsync = function(inputValue) {

        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          if (inputValue === modelCtrl.$viewValue && hasFocus) {
            if (matches.length > 0) {

              scope.activeIdx = 0;
              scope.matches.length = 0;

              //transform labels
              for(var i=0; i<matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');

            } else {
              resetMatches();
            }
            isLoadingSetter(originalScope, false);
          }
        }, function(){
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;

      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
      var timeoutPromise;

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        hasFocus = true;

        if (inputValue && inputValue.length >= minSearch) {
          if (waitTime > 0) {
            if (timeoutPromise) {
              $timeout.cancel(timeoutPromise);//cancel previous timeout
            }
            timeoutPromise = $timeout(function () {
              getMatchesAsync(inputValue);
            }, waitTime);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return inputValue;
          } else {
            modelCtrl.$setValidity('editable', false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        if (inputFormatter) {

          locals['$model'] = modelValue;
          return inputFormatter(originalScope, locals);

        } else {

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a mach was selected via a mouse click event
        element[0].focus();
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind('keydown', function (evt) {

        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          if (evt.which === 13) {
            evt.preventDefault();
          }
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();

        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();

        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });

        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      element.bind('blur', function (evt) {
        hasFocus = false;
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function (evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind('click', dismissClickHandler);

      originalScope.$on('$destroy', function(){
        $document.unbind('click', dismissClickHandler);
      });

      element.after($compile(popUpEl)(scope));
    }
  };

}])

  .directive('typeaheadPopup', function () {
    return {
      restrict:'EA',
      scope:{
        matches:'=',
        query:'=',
        active:'=',
        position:'=',
        select:'&'
      },
      replace:true,
      templateUrl:'template/typeahead/typeahead-popup.html',
      link:function (scope, element, attrs) {

        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function () {
          return scope.matches.length > 0;
        };

        scope.isActive = function (matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function (matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function (activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function ($http, $templateCache, $compile, $parse) {
    return {
      restrict:'EA',
      scope:{
        index:'=',
        match:'=',
        query:'='
      },
      link:function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent){
           element.replaceWith($compile(tplContent.trim())(scope));
        });
      }
    };
  }])

  .filter('typeaheadHighlight', function() {

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }

    return function(matchItem, query) {
      return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
    };
  });
angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion-group.html",
    "<div class=\"accordion-group\">\n" +
    "  <div class=\"accordion-heading\" ><a class=\"accordion-toggle\" ng-click=\"isOpen = !isOpen\" accordion-transclude=\"heading\">{{heading}}</a></div>\n" +
    "  <div class=\"accordion-body\" collapse=\"!isOpen\">\n" +
    "    <div class=\"accordion-inner\" ng-transclude></div>  </div>\n" +
    "</div>");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion.html",
    "<div class=\"accordion\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/alert/alert.html",
    "<div class='alert' ng-class='type && \"alert-\" + type'>\n" +
    "    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\">\n" +
    "    <ol class=\"carousel-indicators\" ng-show=\"slides().length > 1\">\n" +
    "        <li ng-repeat=\"slide in slides()\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
    "    </ol>\n" +
    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "    <a ng-click=\"prev()\" class=\"carousel-control left\" ng-show=\"slides().length > 1\">&lsaquo;</a>\n" +
    "    <a ng-click=\"next()\" class=\"carousel-control right\" ng-show=\"slides().length > 1\">&rsaquo;</a>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': leaving || (active && !entering),\n" +
    "    'prev': (next || active) && direction=='prev',\n" +
    "    'next': (next || active) && direction=='next',\n" +
    "    'right': direction=='prev',\n" +
    "    'left': direction=='next'\n" +
    "  }\" class=\"item\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<table>\n" +
    "  <thead>\n" +
    "    <tr class=\"text-center\">\n" +
    "      <th><button type=\"button\" class=\"btn pull-left\" ng-click=\"move(-1)\"><i class=\"icon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{rows[0].length - 2 + showWeekNumbers}}\"><button type=\"button\" class=\"btn btn-block\" ng-click=\"toggleMode()\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn pull-right\" ng-click=\"move(1)\"><i class=\"icon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"labels.length > 0\">\n" +
    "      <th ng-show=\"showWeekNumbers\">#</th>\n" +
    "      <th ng-repeat=\"label in labels\">{{label}}</th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows\">\n" +
    "      <td ng-show=\"showWeekNumbers\" class=\"text-center\"><em>{{ getWeekNumber(row) }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row\" class=\"text-center\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn\" ng-class=\"{'btn-info': dt.selected}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\"><span ng-class=\"{muted: dt.secondary}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
    "	<li ng-transclude></li>\n" +
    "	<li class=\"divider\"></li>\n" +
    "	<li style=\"padding: 9px;\">\n" +
    "		<span class=\"btn-group\">\n" +
    "			<button type=\"button\" class=\"btn btn-small btn-inverse\" ng-click=\"today()\">{{currentText}}</button>\n" +
    "			<button type=\"button\" class=\"btn btn-small btn-info\" ng-click=\"showWeeks = ! showWeeks\" ng-class=\"{active: showWeeks}\">{{toggleWeeksText}}</button>\n" +
    "			<button type=\"button\" class=\"btn btn-small btn-danger\" ng-click=\"clear()\">{{clearText}}</button>\n" +
    "		</span>\n" +
    "		<button type=\"button\" class=\"btn btn-small btn-success pull-right\" ng-click=\"isOpen = false\">{{closeText}}</button>\n" +
    "	</li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/backdrop.html",
    "<div class=\"modal-backdrop fade\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1040 + index*10}\" ng-click=\"close($event)\"></div>");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/window.html",
    "<div class=\"modal fade {{ windowClass }}\" ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10}\" ng-transclude></div>");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<div class=\"pager\">\n" +
    "  <ul>\n" +
    "    <li ng-repeat=\"page in pages\" ng-class=\"{disabled: page.disabled, previous: page.previous, next: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<div class=\"pagination\"><ul>\n" +
    "  <li ng-repeat=\"page in pages\" ng-class=\"{active: page.active, disabled: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" +
    "  </ul>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover.html",
    "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/bar.html",
    "<div class=\"bar\" ng-class='type && \"bar-\" + type'></div>");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progress.html",
    "<div class=\"progress\"><progressbar ng-repeat=\"bar in bars\" width=\"bar.to\" old=\"bar.from\" animate=\"bar.animate\" type=\"bar.type\"></progressbar></div>");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\">\n" +
    "	<i ng-repeat=\"r in range\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" ng-class=\"$index < val && (r.stateOn || 'icon-star') || (r.stateOff || 'icon-star-empty')\"></i>\n" +
    "</span>");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
    "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabset-titles.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset-titles.html",
    "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "\n" +
    "<div class=\"tabbable\" ng-class=\"{'tabs-right': direction == 'right', 'tabs-left': direction == 'left', 'tabs-below': direction == 'below'}\">\n" +
    "  <div tabset-titles=\"tabsAbove\"></div>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div tabset-titles=\"!tabsAbove\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/timepicker/timepicker.html",
    "<table class=\"form-inline\">\n" +
    "	<tr class=\"text-center\">\n" +
    "		<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
    "		<td>&nbsp;</td>\n" +
    "		<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-up\"></i></a></td>\n" +
    "		<td ng-show=\"showMeridian\"></td>\n" +
    "	</tr>\n" +
    "	<tr>\n" +
    "		<td class=\"control-group\" ng-class=\"{'error': invalidHours}\"><input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"span1 text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" maxlength=\"2\"></td>\n" +
    "		<td>:</td>\n" +
    "		<td class=\"control-group\" ng-class=\"{'error': invalidMinutes}\"><input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"span1 text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\"></td>\n" +
    "		<td ng-show=\"showMeridian\"><button type=\"button\" ng-click=\"toggleMeridian()\" class=\"btn text-center\">{{meridian}}</button></td>\n" +
    "	</tr>\n" +
    "	<tr class=\"text-center\">\n" +
    "		<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
    "		<td>&nbsp;</td>\n" +
    "		<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><i class=\"icon-chevron-down\"></i></a></td>\n" +
    "		<td ng-show=\"showMeridian\"></td>\n" +
    "	</tr>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-match.html",
    "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-popup.html",
    "<ul class=\"typeahead dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" +
    "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\">\n" +
    "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>");
}]);

}).call(global, module, undefined);

},{"/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js":"t5daAN"}],"vNkBbw":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, define) {

; require("/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js");
/**
 * @license AngularJS v1.2.6
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/**
 * @ngdoc overview
 * @name ngCookies
 * @description
 *
 * # ngCookies
 *
 * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies. 
 *
 * {@installModule cookies}
 *
 * <div doc-module-components="ngCookies"></div>
 *
 * See {@link ngCookies.$cookies `$cookies`} and
 * {@link ngCookies.$cookieStore `$cookieStore`} for usage.
 */


angular.module('ngCookies', ['ng']).
  /**
   * @ngdoc object
   * @name ngCookies.$cookies
   * @requires $browser
   *
   * @description
   * Provides read/write access to browser's cookies.
   *
   * Only a simple Object is exposed and by adding or removing properties to/from
   * this object, new cookies are created/deleted at the end of current $eval.
   *
   * Requires the {@link ngCookies `ngCookies`} module to be installed.
   *
   * @example
   <doc:example>
     <doc:source>
       <script>
         function ExampleController($cookies) {
           // Retrieving a cookie
           var favoriteCookie = $cookies.myFavorite;
           // Setting a cookie
           $cookies.myFavorite = 'oatmeal';
         }
       </script>
     </doc:source>
   </doc:example>
   */
   factory('$cookies', ['$rootScope', '$browser', function ($rootScope, $browser) {
      var cookies = {},
          lastCookies = {},
          lastBrowserCookies,
          runEval = false,
          copy = angular.copy,
          isUndefined = angular.isUndefined;

      //creates a poller fn that copies all cookies from the $browser to service & inits the service
      $browser.addPollFn(function() {
        var currentCookies = $browser.cookies();
        if (lastBrowserCookies != currentCookies) { //relies on browser.cookies() impl
          lastBrowserCookies = currentCookies;
          copy(currentCookies, lastCookies);
          copy(currentCookies, cookies);
          if (runEval) $rootScope.$apply();
        }
      })();

      runEval = true;

      //at the end of each eval, push cookies
      //TODO: this should happen before the "delayed" watches fire, because if some cookies are not
      //      strings or browser refuses to store some cookies, we update the model in the push fn.
      $rootScope.$watch(push);

      return cookies;


      /**
       * Pushes all the cookies from the service to the browser and verifies if all cookies were
       * stored.
       */
      function push() {
        var name,
            value,
            browserCookies,
            updated;

        //delete any cookies deleted in $cookies
        for (name in lastCookies) {
          if (isUndefined(cookies[name])) {
            $browser.cookies(name, undefined);
          }
        }

        //update all cookies updated in $cookies
        for(name in cookies) {
          value = cookies[name];
          if (!angular.isString(value)) {
            if (angular.isDefined(lastCookies[name])) {
              cookies[name] = lastCookies[name];
            } else {
              delete cookies[name];
            }
          } else if (value !== lastCookies[name]) {
            $browser.cookies(name, value);
            updated = true;
          }
        }

        //verify what was actually stored
        if (updated){
          updated = false;
          browserCookies = $browser.cookies();

          for (name in cookies) {
            if (cookies[name] !== browserCookies[name]) {
              //delete or reset all cookies that the browser dropped from $cookies
              if (isUndefined(browserCookies[name])) {
                delete cookies[name];
              } else {
                cookies[name] = browserCookies[name];
              }
              updated = true;
            }
          }
        }
      }
    }]).


  /**
   * @ngdoc object
   * @name ngCookies.$cookieStore
   * @requires $cookies
   *
   * @description
   * Provides a key-value (string-object) storage, that is backed by session cookies.
   * Objects put or retrieved from this storage are automatically serialized or
   * deserialized by angular's toJson/fromJson.
   *
   * Requires the {@link ngCookies `ngCookies`} module to be installed.
   *
   * @example
   */
   factory('$cookieStore', ['$cookies', function($cookies) {

      return {
        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#get
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Returns the value of given cookie key
         *
         * @param {string} key Id to use for lookup.
         * @returns {Object} Deserialized cookie value.
         */
        get: function(key) {
          var value = $cookies[key];
          return value ? angular.fromJson(value) : value;
        },

        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#put
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Sets a value for given cookie key
         *
         * @param {string} key Id for the `value`.
         * @param {Object} value Value to be stored.
         */
        put: function(key, value) {
          $cookies[key] = angular.toJson(value);
        },

        /**
         * @ngdoc method
         * @name ngCookies.$cookieStore#remove
         * @methodOf ngCookies.$cookieStore
         *
         * @description
         * Remove given cookie
         *
         * @param {string} key Id of the key-value pair to delete.
         */
        remove: function(key) {
          delete $cookies[key];
        }
      };

    }]);


})(window, window.angular);

}).call(global, module, undefined);

},{"/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js":"t5daAN"}],"angular-cookies":[function(require,module,exports){
module.exports=require('vNkBbw');
},{}],"angular-resource":[function(require,module,exports){
module.exports=require('dIO6bv');
},{}],"dIO6bv":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, define) {

; require("/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js");
/**
 * @license AngularJS v1.2.6
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

var $resourceMinErr = angular.$$minErr('$resource');

// Helper functions and regex to lookup a dotted path on an object
// stopping at undefined/null.  The path must be composed of ASCII
// identifiers (just like $parse)
var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$][0-9a-zA-Z_$]*)+$/;

function isValidDottedPath(path) {
  return (path != null && path !== '' && path !== 'hasOwnProperty' &&
      MEMBER_NAME_REGEX.test('.' + path));
}

function lookupDottedPath(obj, path) {
  if (!isValidDottedPath(path)) {
    throw $resourceMinErr('badmember', 'Dotted member path "@{0}" is invalid.', path);
  }
  var keys = path.split('.');
  for (var i = 0, ii = keys.length; i < ii && obj !== undefined; i++) {
    var key = keys[i];
    obj = (obj !== null) ? obj[key] : undefined;
  }
  return obj;
}

/**
 * Create a shallow copy of an object and clear other fields from the destination
 */
function shallowClearAndCopy(src, dst) {
  dst = dst || {};

  angular.forEach(dst, function(value, key){
    delete dst[key];
  });

  for (var key in src) {
    if (src.hasOwnProperty(key) && key.charAt(0) !== '$' && key.charAt(1) !== '$') {
      dst[key] = src[key];
    }
  }

  return dst;
}

/**
 * @ngdoc overview
 * @name ngResource
 * @description
 *
 * # ngResource
 *
 * The `ngResource` module provides interaction support with RESTful services
 * via the $resource service.
 *
 * {@installModule resource}
 *
 * <div doc-module-components="ngResource"></div>
 *
 * See {@link ngResource.$resource `$resource`} for usage.
 */

/**
 * @ngdoc object
 * @name ngResource.$resource
 * @requires $http
 *
 * @description
 * A factory which creates a resource object that lets you interact with
 * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.
 *
 * The returned resource object has action methods which provide high-level behaviors without
 * the need to interact with the low level {@link ng.$http $http} service.
 *
 * Requires the {@link ngResource `ngResource`} module to be installed.
 *
 * @param {string} url A parametrized URL template with parameters prefixed by `:` as in
 *   `/user/:username`. If you are using a URL with a port number (e.g.
 *   `http://example.com:8080/api`), it will be respected.
 *
 *   If you are using a url with a suffix, just add the suffix, like this:
 *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`
 *   or even `$resource('http://example.com/resource/:resource_id.:format')`
 *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be
 *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you
 *   can escape it with `/\.`.
 *
 * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in
 *   `actions` methods. If any of the parameter value is a function, it will be executed every time
 *   when a param value needs to be obtained for a request (unless the param was overridden).
 *
 *   Each key value in the parameter object is first bound to url template if present and then any
 *   excess keys are appended to the url seapph query after the `?`.
 *
 *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in
 *   URL `/path/greet?salutation=Hello`.
 *
 *   If the parameter value is prefixed with `@` then the value of that parameter is extracted from
 *   the data object (useful for non-GET operations).
 *
 * @param {Object.<Object>=} actions Hash with declaration of custom action that should extend the
 *   default set of resource actions. The declaration should be created in the format of {@link
 *   ng.$http#usage_parameters $http.config}:
 *
 *       {action1: {method:?, params:?, isArray:?, headers:?, ...},
 *        action2: {method:?, params:?, isArray:?, headers:?, ...},
 *        ...}
 *
 *   Where:
 *
 *   - **`action`** – {string} – The name of action. This name becomes the name of the method on
 *     your resource object.
 *   - **`method`** – {string} – HTTP request method. Valid methods are: `GET`, `POST`, `PUT`,
 *     `DELETE`, and `JSONP`.
 *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of
 *     the parameter value is a function, it will be executed every time when a param value needs to
 *     be obtained for a request (unless the param was overridden).
 *   - **`url`** – {string} – action specific `url` override. The url templating is supported just
 *     like for the resource-level urls.
 *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array,
 *     see `returns` section.
 *   - **`transformRequest`** –
 *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
 *     transform function or an array of such functions. The transform function takes the http
 *     request body and headers and returns its transformed (typically serialized) version.
 *   - **`transformResponse`** –
 *     `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
 *     transform function or an array of such functions. The transform function takes the http
 *     response body and headers and returns its transformed (typically deserialized) version.
 *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the
 *     GET request, otherwise if a cache instance built with
 *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
 *     caching.
 *   - **`timeout`** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise} that
 *     should abort the request when resolved.
 *   - **`withCredentials`** - `{boolean}` - whether to set the `withCredentials` flag on the
 *     XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
 *     requests with credentials} for more information.
 *   - **`responseType`** - `{string}` - see {@link
 *     https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
 *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -
 *     `response` and `responseError`. Both `response` and `responseError` interceptors get called
 *     with `http response` object. See {@link ng.$http $http interceptors}.
 *
 * @returns {Object} A resource "class" object with methods for the default set of resource actions
 *   optionally extended with custom `actions`. The default set contains these actions:
 *
 *       { 'get':    {method:'GET'},
 *         'save':   {method:'POST'},
 *         'query':  {method:'GET', isArray:true},
 *         'remove': {method:'DELETE'},
 *         'delete': {method:'DELETE'} };
 *
 *   Calling these methods invoke an {@link ng.$http} with the specified http method,
 *   destination and parameters. When the data is returned from the server then the object is an
 *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it
 *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,
 *   read, update, delete) on server-side data like this:
 *   <pre>
        var User = $resource('/user/:userId', {userId:'@id'});
        var user = User.get({userId:123}, function() {
          user.abc = true;
          user.$save();
        });
     </pre>
 *
 *   It is important to realize that invoking a $resource object method immediately returns an
 *   empty reference (object or array depending on `isArray`). Once the data is returned from the
 *   server the existing reference is populated with the actual data. This is a useful trick since
 *   usually the resource is assigned to a model which is then rendered by the view. Having an empty
 *   object results in no rendering, once the data arrives from the server then the object is
 *   populated with the data and the view automatically re-renders itself showing the new data. This
 *   means that in most cases one never has to write a callback function for the action methods.
 *
 *   The action methods on the class object or instance object can be invoked with the following
 *   parameters:
 *
 *   - HTTP GET "class" actions: `Resource.action([parameters], [success], [error])`
 *   - non-GET "class" actions: `Resource.action([parameters], postData, [success], [error])`
 *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`
 *
 *   Success callback is called with (value, responseHeaders) arguments. Error callback is called
 *   with (httpResponse) argument.
 *
 *   Class actions return empty instance (with additional properties below).
 *   Instance actions return promise of the action.
 *
 *   The Resource instances and collection have these additional properties:
 *
 *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this
 *     instance or collection.
 *
 *     On success, the promise is resolved with the same resource instance or collection object,
 *     updated with data from server. This makes it easy to use in
 *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view
 *     rendering until the resource(s) are loaded.
 *
 *     On failure, the promise is resolved with the {@link ng.$http http response} object, without
 *     the `resource` property.
 *
 *   - `$resolved`: `true` after first server interaction is completed (either with success or
 *      rejection), `false` before that. Knowing if the Resource has been resolved is useful in
 *      data-binding.
 *
 * @example
 *
 * # Credit card resource
 *
 * <pre>
     // Define CreditCard class
     var CreditCard = $resource('/user/:userId/card/:cardId',
      {userId:123, cardId:'@id'}, {
       charge: {method:'POST', params:{charge:true}}
      });

     // We can retrieve a collection from the server
     var cards = CreditCard.query(function() {
       // GET: /user/123/card
       // server returns: [ {id:456, number:'1234', name:'Smith'} ];

       var card = cards[0];
       // each item is an instance of CreditCard
       expect(card instanceof CreditCard).toEqual(true);
       card.name = "J. Smith";
       // non GET methods are mapped onto the instances
       card.$save();
       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}
       // server returns: {id:456, number:'1234', name: 'J. Smith'};

       // our custom method is mapped as well.
       card.$charge({amount:9.99});
       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}
     });

     // we can create an instance as well
     var newCard = new CreditCard({number:'0123'});
     newCard.name = "Mike Smith";
     newCard.$save();
     // POST: /user/123/card {number:'0123', name:'Mike Smith'}
     // server returns: {id:789, number:'0123', name: 'Mike Smith'};
     expect(newCard.id).toEqual(789);
 * </pre>
 *
 * The object returned from this function execution is a resource "class" which has "static" method
 * for each action in the definition.
 *
 * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and
 * `headers`.
 * When the data is returned from the server then the object is an instance of the resource type and
 * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD
 * operations (create, read, update, delete) on server-side data.

   <pre>
     var User = $resource('/user/:userId', {userId:'@id'});
     var user = User.get({userId:123}, function() {
       user.abc = true;
       user.$save();
     });
   </pre>
 *
 * It's worth noting that the success callback for `get`, `query` and other methods gets passed
 * in the response that came from the server as well as $http header getter function, so one
 * could rewrite the above example and get access to http headers as:
 *
   <pre>
     var User = $resource('/user/:userId', {userId:'@id'});
     User.get({userId:123}, function(u, getResponseHeaders){
       u.abc = true;
       u.$save(function(u, putResponseHeaders) {
         //u => saved user object
         //putResponseHeaders => $http header getter
       });
     });
   </pre>

 * # Creating a custom 'PUT' request
 * In this example we create a custom method on our resource to make a PUT request
 * <pre>
 *		var app = angular.module('app', ['ngResource', 'ngRoute']);
 *
 *		// Some APIs expect a PUT request in the format URL/object/ID
 *		// Here we are creating an 'update' method 
 *		app.factory('Notes', ['$resource', function($resource) {
 *    return $resource('/notes/:id', null,
 *        {
 *            'update': { method:'PUT' }
 *        });
 *		}]);
 *
 *		// In our controller we get the ID from the URL using ngRoute and $routeParams
 *		// We pass in $routeParams and our Notes factory along with $scope
 *		app.controller('NotesCtrl', ['$scope', '$routeParams', 'Notes',
                                      function($scope, $routeParams, Notes) {
 *    // First get a note object from the factory
 *    var note = Notes.get({ id:$routeParams.id });
 *    $id = note.id;
 *
 *    // Now call update passing in the ID first then the object you are updating
 *    Notes.update({ id:$id }, note);
 *
 *    // This will PUT /notes/ID with the note object in the request payload
 *		}]);
 * </pre>
 */
angular.module('ngResource', ['ng']).
  factory('$resource', ['$http', '$q', function($http, $q) {

    var DEFAULT_ACTIONS = {
      'get':    {method:'GET'},
      'save':   {method:'POST'},
      'query':  {method:'GET', isArray:true},
      'remove': {method:'DELETE'},
      'delete': {method:'DELETE'}
    };
    var noop = angular.noop,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy,
        isFunction = angular.isFunction;

    /**
     * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
     * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
     * segments:
     *    segment       = *pchar
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriSegment(val) {
      return encodeUriQuery(val, true).
        replace(/%26/gi, '&').
        replace(/%3D/gi, '=').
        replace(/%2B/gi, '+');
    }


    /**
     * This method is intended for encoding *key* or *value* parts of query component. We need a
     * custom method because encodeURIComponent is too aggressive and encodes stuff that doesn't
     * have to be encoded per http://tools.ietf.org/html/rfc3986:
     *    query       = *( pchar / "/" / "?" )
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriQuery(val, pctEncodeSpaces) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
    }

    function Route(template, defaults) {
      this.template = template;
      this.defaults = defaults || {};
      this.urlParams = {};
    }

    Route.prototype = {
      setUrlParams: function(config, params, actionUrl) {
        var self = this,
            url = actionUrl || self.template,
            val,
            encodedVal;

        var urlParams = self.urlParams = {};
        forEach(url.split(/\W/), function(param){
          if (param === 'hasOwnProperty') {
            throw $resourceMinErr('badname', "hasOwnProperty is not a valid parameter name.");
          }
          if (!(new RegExp("^\\d+$").test(param)) && param &&
               (new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url))) {
            urlParams[param] = true;
          }
        });
        url = url.replace(/\\:/g, ':');

        params = params || {};
        forEach(self.urlParams, function(_, urlParam){
          val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
          if (angular.isDefined(val) && val !== null) {
            encodedVal = encodeUriSegment(val);
            url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), encodedVal + "$1");
          } else {
            url = url.replace(new RegExp("(\/?):" + urlParam + "(\\W|$)", "g"), function(match,
                leadingSlashes, tail) {
              if (tail.charAt(0) == '/') {
                return tail;
              } else {
                return leadingSlashes + tail;
              }
            });
          }
        });

        // strip trailing slashes and set the url
        url = url.replace(/\/+$/, '');
        // then replace collapse `/.` if found in the last URL path segment before the query
        // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`
        url = url.replace(/\/\.(?=\w+($|\?))/, '.');
        // replace escaped `/\.` with `/.`
        config.url = url.replace(/\/\\\./, '/.');


        // set params - delegate param encoding to $http
        forEach(params, function(value, key){
          if (!self.urlParams[key]) {
            config.params = config.params || {};
            config.params[key] = value;
          }
        });
      }
    };


    function resourceFactory(url, paramDefaults, actions) {
      var route = new Route(url);

      actions = extend({}, DEFAULT_ACTIONS, actions);

      function extractParams(data, actionParams){
        var ids = {};
        actionParams = extend({}, paramDefaults, actionParams);
        forEach(actionParams, function(value, key){
          if (isFunction(value)) { value = value(); }
          ids[key] = value && value.charAt && value.charAt(0) == '@' ?
            lookupDottedPath(data, value.substr(1)) : value;
        });
        return ids;
      }

      function defaultResponseInterceptor(response) {
        return response.resource;
      }

      function Resource(value){
        shallowClearAndCopy(value || {}, this);
      }

      forEach(actions, function(action, name) {
        var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);

        Resource[name] = function(a1, a2, a3, a4) {
          var params = {}, data, success, error;

          /* jshint -W086 */ /* (purposefully fall through case statements) */
          switch(arguments.length) {
          case 4:
            error = a4;
            success = a3;
            //fallthrough
          case 3:
          case 2:
            if (isFunction(a2)) {
              if (isFunction(a1)) {
                success = a1;
                error = a2;
                break;
              }

              success = a2;
              error = a3;
              //fallthrough
            } else {
              params = a1;
              data = a2;
              success = a3;
              break;
            }
          case 1:
            if (isFunction(a1)) success = a1;
            else if (hasBody) data = a1;
            else params = a1;
            break;
          case 0: break;
          default:
            throw $resourceMinErr('badargs',
              "Expected up to 4 arguments [params, data, success, error], got {0} arguments",
              arguments.length);
          }
          /* jshint +W086 */ /* (purposefully fall through case statements) */

          var isInstanceCall = this instanceof Resource;
          var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));
          var httpConfig = {};
          var responseInterceptor = action.interceptor && action.interceptor.response ||
                                    defaultResponseInterceptor;
          var responseErrorInterceptor = action.interceptor && action.interceptor.responseError ||
                                    undefined;

          forEach(action, function(value, key) {
            if (key != 'params' && key != 'isArray' && key != 'interceptor') {
              httpConfig[key] = copy(value);
            }
          });

          if (hasBody) httpConfig.data = data;
          route.setUrlParams(httpConfig,
                             extend({}, extractParams(data, action.params || {}), params),
                             action.url);

          var promise = $http(httpConfig).then(function(response) {
            var data = response.data,
                promise = value.$promise;

            if (data) {
              // Need to convert action.isArray to boolean in case it is undefined
              // jshint -W018
              if (angular.isArray(data) !== (!!action.isArray)) {
                throw $resourceMinErr('badcfg', 'Error in resource configuration. Expected ' +
                  'response to contain an {0} but got an {1}',
                  action.isArray?'array':'object', angular.isArray(data)?'array':'object');
              }
              // jshint +W018
              if (action.isArray) {
                value.length = 0;
                forEach(data, function(item) {
                  value.push(new Resource(item));
                });
              } else {
                shallowClearAndCopy(data, value);
                value.$promise = promise;
              }
            }

            value.$resolved = true;

            response.resource = value;

            return response;
          }, function(response) {
            value.$resolved = true;

            (error||noop)(response);

            return $q.reject(response);
          });

          promise = promise.then(
              function(response) {
                var value = responseInterceptor(response);
                (success||noop)(value, response.headers);
                return value;
              },
              responseErrorInterceptor);

          if (!isInstanceCall) {
            // we are creating instance / collection
            // - set the initial promise
            // - return the instance / collection
            value.$promise = promise;
            value.$resolved = false;

            return value;
          }

          // instance call
          return promise;
        };


        Resource.prototype['$' + name] = function(params, success, error) {
          if (isFunction(params)) {
            error = success; success = params; params = {};
          }
          var result = Resource[name].call(this, params, this, success, error);
          return result.$promise || result;
        };
      });

      Resource.bind = function(additionalParamDefaults){
        return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);
      };

      return Resource;
    }

    return resourceFactory;
  }]);


})(window, window.angular);

}).call(global, module, undefined);

},{"/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js":"t5daAN"}],"auZsF/":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, define) {

; require("/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js");
/**
 * @license AngularJS v1.2.6
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/**
 * @ngdoc overview
 * @name ngRoute
 * @description
 *
 * # ngRoute
 *
 * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.
 *
 * ## Example
 * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.
 * 
 * {@installModule route}
 *
 * <div doc-module-components="ngRoute"></div>
 */
 /* global -ngRouteModule */
var ngRouteModule = angular.module('ngRoute', ['ng']).
                        provider('$route', $RouteProvider);

/**
 * @ngdoc object
 * @name ngRoute.$routeProvider
 * @function
 *
 * @description
 *
 * Used for configuring routes.
 * 
 * ## Example
 * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.
 *
 * ## Dependencies
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 */
function $RouteProvider(){
  function inherit(parent, extra) {
    return angular.extend(new (angular.extend(function() {}, {prototype:parent}))(), extra);
  }

  var routes = {};

  /**
   * @ngdoc method
   * @name ngRoute.$routeProvider#when
   * @methodOf ngRoute.$routeProvider
   *
   * @param {string} path Route path (matched against `$location.path`). If `$location.path`
   *    contains redundant trailing slash or is missing one, the route will still match and the
   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the
   *    route definition.
   *
   *      * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up
   *        to the next slash are matched and stored in `$routeParams` under the given `name`
   *        when the route matches.
   *      * `path` can contain named groups starting with a colon and ending with a star:
   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`
   *        when the route matches.
   *      * `path` can contain optional named groups with a question mark: e.g.`:name?`.
   *
   *    For example, routes like `/color/:color/largecode/:largecode*\/edit` will match
   *    `/color/brown/largecode/code/with/slashs/edit` and extract:
   *
   *      * `color: brown`
   *      * `largecode: code/with/slashs`.
   *
   *
   * @param {Object} route Mapping information to be assigned to `$route.current` on route
   *    match.
   *
   *    Object properties:
   *
   *    - `controller` – `{(string|function()=}` – Controller fn that should be associated with
   *      newly created scope or the name of a {@link angular.Module#controller registered
   *      controller} if passed as a string.
   *    - `controllerAs` – `{string=}` – A controller alias name. If present the controller will be
   *      published to scope under the `controllerAs` name.
   *    - `template` – `{string=|function()=}` – html template as a string or a function that
   *      returns an html template as a string which should be used by {@link
   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.
   *      This property takes precedence over `templateUrl`.
   *
   *      If `template` is a function, it will be called with the following parameters:
   *
   *      - `{Array.<Object>}` - route parameters extracted from the current
   *        `$location.path()` by applying the current route
   *
   *    - `templateUrl` – `{string=|function()=}` – path or function that returns a path to an html
   *      template that should be used by {@link ngRoute.directive:ngView ngView}.
   *
   *      If `templateUrl` is a function, it will be called with the following parameters:
   *
   *      - `{Array.<Object>}` - route parameters extracted from the current
   *        `$location.path()` by applying the current route
   *
   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
   *      be injected into the controller. If any of these dependencies are promises, the router
   *      will wait for them all to be resolved or one to be rejected before the controller is
   *      instantiated.
   *      If all the promises are resolved successfully, the values of the resolved promises are
   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is
   *      fired. If any of the promises are rejected the
   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired. The map object
   *      is:
   *
   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.
   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.
   *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}
   *        and the return value is treated as the dependency. If the result is a promise, it is
   *        resolved before its value is injected into the controller. Be aware that
   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve
   *        functions.  Use `$route.current.params` to access the new route parameters, instead.
   *
   *    - `redirectTo` – {(string|function())=} – value to update
   *      {@link ng.$location $location} path with and trigger route redirection.
   *
   *      If `redirectTo` is a function, it will be called with the following parameters:
   *
   *      - `{Object.<string>}` - route parameters extracted from the current
   *        `$location.path()` by applying the current route templateUrl.
   *      - `{string}` - current `$location.path()`
   *      - `{Object}` - current `$location.search()`
   *
   *      The custom `redirectTo` function is expected to return a string which will be used
   *      to update `$location.path()` and `$location.search()`.
   *
   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only `$location.search()`
   *      or `$location.hash()` changes.
   *
   *      If the option is set to `false` and url in the browser changes, then
   *      `$routeUpdate` event is broadcasted on the root scope.
   *
   *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive
   *
   *      If the option is set to `true`, then the particular route can be matched without being
   *      case sensitive
   *
   * @returns {Object} self
   *
   * @description
   * Adds a new route definition to the `$route` service.
   */
  this.when = function(path, route) {
    routes[path] = angular.extend(
      {reloadOnSearch: true},
      route,
      path && pathRegExp(path, route)
    );

    // create redirection for trailing slashes
    if (path) {
      var redirectPath = (path[path.length-1] == '/')
            ? path.substr(0, path.length-1)
            : path +'/';

      routes[redirectPath] = angular.extend(
        {redirectTo: path},
        pathRegExp(redirectPath, route)
      );
    }

    return this;
  };

   /**
    * @param path {string} path
    * @param opts {Object} options
    * @return {?Object}
    *
    * @description
    * Normalizes the given path, returning a regular expression
    * and the original path.
    *
    * Inspired by pathRexp in visionmedia/express/lib/utils.js.
    */
  function pathRegExp(path, opts) {
    var insensitive = opts.caseInsensitiveMatch,
        ret = {
          originalPath: path,
          regexp: path
        },
        keys = ret.keys = [];

    path = path
      .replace(/([().])/g, '\\$1')
      .replace(/(\/)?:(\w+)([\?|\*])?/g, function(_, slash, key, option){
        var optional = option === '?' ? option : null;
        var star = option === '*' ? option : null;
        keys.push({ name: key, optional: !!optional });
        slash = slash || '';
        return ''
          + (optional ? '' : slash)
          + '(?:'
          + (optional ? slash : '')
          + (star && '(.+?)' || '([^/]+)')
          + (optional || '')
          + ')'
          + (optional || '');
      })
      .replace(/([\/$\*])/g, '\\$1');

    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');
    return ret;
  }

  /**
   * @ngdoc method
   * @name ngRoute.$routeProvider#otherwise
   * @methodOf ngRoute.$routeProvider
   *
   * @description
   * Sets route definition that will be used on route change when no other route definition
   * is matched.
   *
   * @param {Object} params Mapping information to be assigned to `$route.current`.
   * @returns {Object} self
   */
  this.otherwise = function(params) {
    this.when(null, params);
    return this;
  };


  this.$get = ['$rootScope',
               '$location',
               '$routeParams',
               '$q',
               '$injector',
               '$http',
               '$templateCache',
               '$sce',
      function($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache, $sce) {

    /**
     * @ngdoc object
     * @name ngRoute.$route
     * @requires $location
     * @requires $routeParams
     *
     * @property {Object} current Reference to the current route definition.
     * The route definition contains:
     *
     *   - `controller`: The controller constructor as define in route definition.
     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for
     *     controller instantiation. The `locals` contain
     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:
     *
     *     - `$scope` - The current route scope.
     *     - `$template` - The current route template HTML.
     *
     * @property {Array.<Object>} routes Array of all configured routes.
     *
     * @description
     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).
     * It watches `$location.url()` and tries to map the path to an existing route definition.
     *
     * Requires the {@link ngRoute `ngRoute`} module to be installed.
     *
     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.
     *
     * The `$route` service is typically used in conjunction with the
     * {@link ngRoute.directive:ngView `ngView`} directive and the
     * {@link ngRoute.$routeParams `$routeParams`} service.
     *
     * @example
       This example shows how changing the URL hash causes the `$route` to match a route against the
       URL, and the `ngView` pulls in the partial.

       Note that this example is using {@link ng.directive:script inlined templates}
       to get it working on jsfiddle as well.

     <example module="ngViewExample" deps="angular-route.js">
       <file name="index.html">
         <div ng-controller="MainCntl">
           Choose:
           <a href="Book/Moby">Moby</a> |
           <a href="Book/Moby/ch/1">Moby: Ch1</a> |
           <a href="Book/Gatsby">Gatsby</a> |
           <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
           <a href="Book/Scarlet">Scarlet Letter</a><br/>

           <div ng-view></div>
           <hr />

           <pre>$location.path() = {{$location.path()}}</pre>
           <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>
           <pre>$route.current.params = {{$route.current.params}}</pre>
           <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>
           <pre>$routeParams = {{$routeParams}}</pre>
         </div>
       </file>

       <file name="book.html">
         controller: {{name}}<br />
         Book Id: {{params.bookId}}<br />
       </file>

       <file name="chapter.html">
         controller: {{name}}<br />
         Book Id: {{params.bookId}}<br />
         Chapter Id: {{params.chapterId}}
       </file>

       <file name="script.js">
         angular.module('ngViewExample', ['ngRoute'])

         .config(function($routeProvider, $locationProvider) {
           $routeProvider.when('/Book/:bookId', {
             templateUrl: 'book.html',
             controller: BookCntl,
             resolve: {
               // I will cause a 1 second delay
               delay: function($q, $timeout) {
                 var delay = $q.defer();
                 $timeout(delay.resolve, 1000);
                 return delay.promise;
               }
             }
           });
           $routeProvider.when('/Book/:bookId/ch/:chapterId', {
             templateUrl: 'chapter.html',
             controller: ChapterCntl
           });

           // configure html5 to get links working on jsfiddle
           $locationProvider.html5Mode(true);
         });

         function MainCntl($scope, $route, $routeParams, $location) {
           $scope.$route = $route;
           $scope.$location = $location;
           $scope.$routeParams = $routeParams;
         }

         function BookCntl($scope, $routeParams) {
           $scope.name = "BookCntl";
           $scope.params = $routeParams;
         }

         function ChapterCntl($scope, $routeParams) {
           $scope.name = "ChapterCntl";
           $scope.params = $routeParams;
         }
       </file>

       <file name="scenario.js">
         it('should load and compile correct template', function() {
           element('a:contains("Moby: Ch1")').click();
           var content = element('.doc-example-live [ng-view]').text();
           expect(content).toMatch(/controller\: ChapterCntl/);
           expect(content).toMatch(/Book Id\: Moby/);
           expect(content).toMatch(/Chapter Id\: 1/);

           element('a:contains("Scarlet")').click();
           sleep(2); // promises are not part of scenario waiting
           content = element('.doc-example-live [ng-view]').text();
           expect(content).toMatch(/controller\: BookCntl/);
           expect(content).toMatch(/Book Id\: Scarlet/);
         });
       </file>
     </example>
     */

    /**
     * @ngdoc event
     * @name ngRoute.$route#$routeChangeStart
     * @eventOf ngRoute.$route
     * @eventType broadcast on root scope
     * @description
     * Broadcasted before a route change. At this  point the route services starts
     * resolving all of the dependencies needed for the route change to occurs.
     * Typically this involves fetching the view template as well as any dependencies
     * defined in `resolve` route property. Once  all of the dependencies are resolved
     * `$routeChangeSuccess` is fired.
     *
     * @param {Object} angularEvent Synthetic event object.
     * @param {Route} next Future route information.
     * @param {Route} current Current route information.
     */

    /**
     * @ngdoc event
     * @name ngRoute.$route#$routeChangeSuccess
     * @eventOf ngRoute.$route
     * @eventType broadcast on root scope
     * @description
     * Broadcasted after a route dependencies are resolved.
     * {@link ngRoute.directive:ngView ngView} listens for the directive
     * to instantiate the controller and render the view.
     *
     * @param {Object} angularEvent Synthetic event object.
     * @param {Route} current Current route information.
     * @param {Route|Undefined} previous Previous route information, or undefined if current is
     * first route entered.
     */

    /**
     * @ngdoc event
     * @name ngRoute.$route#$routeChangeError
     * @eventOf ngRoute.$route
     * @eventType broadcast on root scope
     * @description
     * Broadcasted if any of the resolve promises are rejected.
     *
     * @param {Object} angularEvent Synthetic event object
     * @param {Route} current Current route information.
     * @param {Route} previous Previous route information.
     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.
     */

    /**
     * @ngdoc event
     * @name ngRoute.$route#$routeUpdate
     * @eventOf ngRoute.$route
     * @eventType broadcast on root scope
     * @description
     *
     * The `reloadOnSearch` property has been set to false, and we are reusing the same
     * instance of the Controller.
     */

    var forceReload = false,
        $route = {
          routes: routes,

          /**
           * @ngdoc method
           * @name ngRoute.$route#reload
           * @methodOf ngRoute.$route
           *
           * @description
           * Causes `$route` service to reload the current route even if
           * {@link ng.$location $location} hasn't changed.
           *
           * As a result of that, {@link ngRoute.directive:ngView ngView}
           * creates new scope, reinstantiates the controller.
           */
          reload: function() {
            forceReload = true;
            $rootScope.$evalAsync(updateRoute);
          }
        };

    $rootScope.$on('$locationChangeSuccess', updateRoute);

    return $route;

    /////////////////////////////////////////////////////

    /**
     * @param on {string} current url
     * @param route {Object} route regexp to match the url against
     * @return {?Object}
     *
     * @description
     * Check if the route matches the current url.
     *
     * Inspired by match in
     * visionmedia/express/lib/router/router.js.
     */
    function switchRouteMatcher(on, route) {
      var keys = route.keys,
          params = {};

      if (!route.regexp) return null;

      var m = route.regexp.exec(on);
      if (!m) return null;

      for (var i = 1, len = m.length; i < len; ++i) {
        var key = keys[i - 1];

        var val = 'string' == typeof m[i]
              ? decodeURIComponent(m[i])
              : m[i];

        if (key && val) {
          params[key.name] = val;
        }
      }
      return params;
    }

    function updateRoute() {
      var next = parseRoute(),
          last = $route.current;

      if (next && last && next.$$route === last.$$route
          && angular.equals(next.pathParams, last.pathParams)
          && !next.reloadOnSearch && !forceReload) {
        last.params = next.params;
        angular.copy(last.params, $routeParams);
        $rootScope.$broadcast('$routeUpdate', last);
      } else if (next || last) {
        forceReload = false;
        $rootScope.$broadcast('$routeChangeStart', next, last);
        $route.current = next;
        if (next) {
          if (next.redirectTo) {
            if (angular.isString(next.redirectTo)) {
              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)
                       .replace();
            } else {
              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))
                       .replace();
            }
          }
        }

        $q.when(next).
          then(function() {
            if (next) {
              var locals = angular.extend({}, next.resolve),
                  template, templateUrl;

              angular.forEach(locals, function(value, key) {
                locals[key] = angular.isString(value) ?
                    $injector.get(value) : $injector.invoke(value);
              });

              if (angular.isDefined(template = next.template)) {
                if (angular.isFunction(template)) {
                  template = template(next.params);
                }
              } else if (angular.isDefined(templateUrl = next.templateUrl)) {
                if (angular.isFunction(templateUrl)) {
                  templateUrl = templateUrl(next.params);
                }
                templateUrl = $sce.getTrustedResourceUrl(templateUrl);
                if (angular.isDefined(templateUrl)) {
                  next.loadedTemplateUrl = templateUrl;
                  template = $http.get(templateUrl, {cache: $templateCache}).
                      then(function(response) { return response.data; });
                }
              }
              if (angular.isDefined(template)) {
                locals['$template'] = template;
              }
              return $q.all(locals);
            }
          }).
          // after route change
          then(function(locals) {
            if (next == $route.current) {
              if (next) {
                next.locals = locals;
                angular.copy(next.params, $routeParams);
              }
              $rootScope.$broadcast('$routeChangeSuccess', next, last);
            }
          }, function(error) {
            if (next == $route.current) {
              $rootScope.$broadcast('$routeChangeError', next, last, error);
            }
          });
      }
    }


    /**
     * @returns the current active route, by matching it against the URL
     */
    function parseRoute() {
      // Match a route
      var params, match;
      angular.forEach(routes, function(route, path) {
        if (!match && (params = switchRouteMatcher($location.path(), route))) {
          match = inherit(route, {
            params: angular.extend({}, $location.search(), params),
            pathParams: params});
          match.$$route = route;
        }
      });
      // No route matched; fallback to "otherwise" route
      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});
    }

    /**
     * @returns interpolation of the redirect path with the parameters
     */
    function interpolate(string, params) {
      var result = [];
      angular.forEach((string||'').split(':'), function(segment, i) {
        if (i === 0) {
          result.push(segment);
        } else {
          var segmentMatch = segment.match(/(\w+)(.*)/);
          var key = segmentMatch[1];
          result.push(params[key]);
          result.push(segmentMatch[2] || '');
          delete params[key];
        }
      });
      return result.join('');
    }
  }];
}

ngRouteModule.provider('$routeParams', $RouteParamsProvider);


/**
 * @ngdoc object
 * @name ngRoute.$routeParams
 * @requires $route
 *
 * @description
 * The `$routeParams` service allows you to retrieve the current set of route parameters.
 *
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 *
 * The route parameters are a combination of {@link ng.$location `$location`}'s
 * {@link ng.$location#methods_search `search()`} and {@link ng.$location#methods_path `path()`}.
 * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.
 *
 * In case of parameter name collision, `path` params take precedence over `search` params.
 *
 * The service guarantees that the identity of the `$routeParams` object will remain unchanged
 * (but its properties will likely change) even when a route change occurs.
 *
 * Note that the `$routeParams` are only updated *after* a route change completes successfully.
 * This means that you cannot rely on `$routeParams` being correct in route resolve functions.
 * Instead you can use `$route.current.params` to access the new route's parameters.
 *
 * @example
 * <pre>
 *  // Given:
 *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
 *  // Route: /Chapter/:chapterId/Section/:sectionId
 *  //
 *  // Then
 *  $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}
 * </pre>
 */
function $RouteParamsProvider() {
  this.$get = function() { return {}; };
}

ngRouteModule.directive('ngView', ngViewFactory);
ngRouteModule.directive('ngView', ngViewFillContentFactory);


/**
 * @ngdoc directive
 * @name ngRoute.directive:ngView
 * @restrict ECA
 *
 * @description
 * # Overview
 * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by
 * including the rendered template of the current route into the main layout (`index.html`) file.
 * Every time the current route changes, the included view changes with it according to the
 * configuration of the `$route` service.
 *
 * Requires the {@link ngRoute `ngRoute`} module to be installed.
 *
 * @animations
 * enter - animation is used to bring new content into the browser.
 * leave - animation is used to animate existing content away.
 *
 * The enter and leave animation occur concurrently.
 *
 * @scope
 * @priority 400
 * @example
    <example module="ngViewExample" deps="angular-route.js" animations="true">
      <file name="index.html">
        <div ng-controller="MainCntl as main">
          Choose:
          <a href="Book/Moby">Moby</a> |
          <a href="Book/Moby/ch/1">Moby: Ch1</a> |
          <a href="Book/Gatsby">Gatsby</a> |
          <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
          <a href="Book/Scarlet">Scarlet Letter</a><br/>

          <div class="view-animate-container">
            <div ng-view class="view-animate"></div>
          </div>
          <hr />

          <pre>$location.path() = {{main.$location.path()}}</pre>
          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>
          <pre>$route.current.params = {{main.$route.current.params}}</pre>
          <pre>$route.current.scope.name = {{main.$route.current.scope.name}}</pre>
          <pre>$routeParams = {{main.$routeParams}}</pre>
        </div>
      </file>

      <file name="book.html">
        <div>
          controller: {{book.name}}<br />
          Book Id: {{book.params.bookId}}<br />
        </div>
      </file>

      <file name="chapter.html">
        <div>
          controller: {{chapter.name}}<br />
          Book Id: {{chapter.params.bookId}}<br />
          Chapter Id: {{chapter.params.chapterId}}
        </div>
      </file>

      <file name="animations.css">
        .view-animate-container {
          position:relative;
          height:100px!important;
          position:relative;
          background:white;
          border:1px solid black;
          height:40px;
          overflow:hidden;
        }

        .view-animate {
          padding:10px;
        }

        .view-animate.ng-enter, .view-animate.ng-leave {
          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;

          display:block;
          width:100%;
          border-left:1px solid black;

          position:absolute;
          top:0;
          left:0;
          right:0;
          bottom:0;
          padding:10px;
        }

        .view-animate.ng-enter {
          left:100%;
        }
        .view-animate.ng-enter.ng-enter-active {
          left:0;
        }
        .view-animate.ng-leave.ng-leave-active {
          left:-100%;
        }
      </file>

      <file name="script.js">
        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'],
          function($routeProvider, $locationProvider) {
            $routeProvider.when('/Book/:bookId', {
              templateUrl: 'book.html',
              controller: BookCntl,
              controllerAs: 'book'
            });
            $routeProvider.when('/Book/:bookId/ch/:chapterId', {
              templateUrl: 'chapter.html',
              controller: ChapterCntl,
              controllerAs: 'chapter'
            });

            // configure html5 to get links working on jsfiddle
            $locationProvider.html5Mode(true);
        });

        function MainCntl($route, $routeParams, $location) {
          this.$route = $route;
          this.$location = $location;
          this.$routeParams = $routeParams;
        }

        function BookCntl($routeParams) {
          this.name = "BookCntl";
          this.params = $routeParams;
        }

        function ChapterCntl($routeParams) {
          this.name = "ChapterCntl";
          this.params = $routeParams;
        }
      </file>

      <file name="scenario.js">
        it('should load and compile correct template', function() {
          element('a:contains("Moby: Ch1")').click();
          var content = element('.doc-example-live [ng-view]').text();
          expect(content).toMatch(/controller\: ChapterCntl/);
          expect(content).toMatch(/Book Id\: Moby/);
          expect(content).toMatch(/Chapter Id\: 1/);

          element('a:contains("Scarlet")').click();
          content = element('.doc-example-live [ng-view]').text();
          expect(content).toMatch(/controller\: BookCntl/);
          expect(content).toMatch(/Book Id\: Scarlet/);
        });
      </file>
    </example>
 */


/**
 * @ngdoc event
 * @name ngRoute.directive:ngView#$viewContentLoaded
 * @eventOf ngRoute.directive:ngView
 * @eventType emit on the current ngView scope
 * @description
 * Emitted every time the ngView content is reloaded.
 */
ngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];
function ngViewFactory(   $route,   $anchorScroll,   $animate) {
  return {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    link: function(scope, $element, attr, ctrl, $transclude) {
        var currentScope,
            currentElement,
            autoScrollExp = attr.autoscroll,
            onloadExp = attr.onload || '';

        scope.$on('$routeChangeSuccess', update);
        update();

        function cleanupLastView() {
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if(currentElement) {
            $animate.leave(currentElement);
            currentElement = null;
          }
        }

        function update() {
          var locals = $route.current && $route.current.locals,
              template = locals && locals.$template;

          if (template) {
            var newScope = scope.$new();
            var current = $route.current;

            // Note: This will also link all children of ng-view that were contained in the original
            // html. If that content contains controllers, ... they could pollute/change the scope.
            // However, using ng-view on an element with additional content does not make sense...
            // Note: We can't remove them in the cloneAttchFn of $transclude as that
            // function is called before linking the content, which would apply child
            // directives to non existing elements.
            var clone = $transclude(newScope, function(clone) {
              $animate.enter(clone, null, currentElement || $element, function onNgViewEnter () {
                if (angular.isDefined(autoScrollExp)
                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              });
              cleanupLastView();
            });

            currentElement = clone;
            currentScope = current.scope = newScope;
            currentScope.$emit('$viewContentLoaded');
            currentScope.$eval(onloadExp);
          } else {
            cleanupLastView();
          }
        }
    }
  };
}

// This directive is called during the $transclude call of the first `ngView` directive.
// It will replace and compile the content of the element with the loaded template.
// We need this directive so that the element content is already filled when
// the link function of another directive on the same element as ngView
// is called.
ngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];
function ngViewFillContentFactory($compile, $controller, $route) {
  return {
    restrict: 'ECA',
    priority: -400,
    link: function(scope, $element) {
      var current = $route.current,
          locals = current.locals;

      $element.html(locals.$template);

      var link = $compile($element.contents());

      if (current.controller) {
        locals.$scope = scope;
        var controller = $controller(current.controller, locals);
        if (current.controllerAs) {
          scope[current.controllerAs] = controller;
        }
        $element.data('$ngControllerController', controller);
        $element.children().data('$ngControllerController', controller);
      }

      link(scope);
    }
  };
}


})(window, window.angular);

}).call(global, module, undefined);

},{"/Users/wheresrhys/Sites/jigsnreels/bower_components/angular/angular.js":"t5daAN"}],"angular-route":[function(require,module,exports){
module.exports=require('auZsF/');
},{}],"angular":[function(require,module,exports){
module.exports=require('t5daAN');
},{}],"t5daAN":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, exports, define, browserify_shim__define__module__export__) {
/**
 * @license AngularJS v1.2.6
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, document, undefined) {'use strict';

/**
 * @description
 *
 * This object provides a utility for producing rich Error messages within
 * Angular. It can be called as follows:
 *
 * var exampleMinErr = minErr('example');
 * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
 *
 * The above creates an instance of minErr in the example namespace. The
 * resulting error will have a namespaced error code of example.one.  The
 * resulting error will replace {0} with the value of foo, and {1} with the
 * value of bar. The object is not restricted in the number of arguments it can
 * take.
 *
 * If fewer arguments are specified than necessary for interpolation, the extra
 * interpolation markers will be preserved in the final string.
 *
 * Since data will be parsed statically during a build step, some restrictions
 * are applied with respect to how minErr instances are created and called.
 * Instances should have names of the form namespaceMinErr for a minErr created
 * using minErr('namespace') . Error codes, namespaces and template strings
 * should all be static strings, not variables or general expressions.
 *
 * @param {string} module The namespace to use for the new minErr instance.
 * @returns {function(string, string, ...): Error} instance
 */

function minErr(module) {
  return function () {
    var code = arguments[0],
      prefix = '[' + (module ? module + ':' : '') + code + '] ',
      template = arguments[1],
      templateArgs = arguments,
      stringify = function (obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (typeof obj === 'undefined') {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return JSON.stringify(obj);
        }
        return obj;
      },
      message, i;

    message = prefix + template.replace(/\{\d+\}/g, function (match) {
      var index = +match.slice(1, -1), arg;

      if (index + 2 < templateArgs.length) {
        arg = templateArgs[index + 2];
        if (typeof arg === 'function') {
          return arg.toString().replace(/ ?\{[\s\S]*$/, '');
        } else if (typeof arg === 'undefined') {
          return 'undefined';
        } else if (typeof arg !== 'string') {
          return toJson(arg);
        }
        return arg;
      }
      return match;
    });

    message = message + '\nhttp://errors.angularjs.org/1.2.6/' +
      (module ? module + '/' : '') + code;
    for (i = 2; i < arguments.length; i++) {
      message = message + (i == 2 ? '?' : '&') + 'p' + (i-2) + '=' +
        encodeURIComponent(stringify(arguments[i]));
    }

    return new Error(message);
  };
}

/* We need to tell jshint what variables are being exported */
/* global
    -angular,
    -msie,
    -jqLite,
    -jQuery,
    -slice,
    -push,
    -toString,
    -ngMinErr,
    -_angular,
    -angularModule,
    -nodeName_,
    -uid,

    -lowercase,
    -uppercase,
    -manualLowercase,
    -manualUppercase,
    -nodeName_,
    -isArrayLike,
    -forEach,
    -sortedKeys,
    -forEachSorted,
    -reverseParams,
    -nextUid,
    -setHashKey,
    -extend,
    -int,
    -inherit,
    -noop,
    -identity,
    -valueFn,
    -isUndefined,
    -isDefined,
    -isObject,
    -isString,
    -isNumber,
    -isDate,
    -isArray,
    -isFunction,
    -isRegExp,
    -isWindow,
    -isScope,
    -isFile,
    -isBoolean,
    -trim,
    -isElement,
    -makeMap,
    -map,
    -size,
    -includes,
    -indexOf,
    -arrayRemove,
    -isLeafNode,
    -copy,
    -shallowCopy,
    -equals,
    -csp,
    -concat,
    -sliceArgs,
    -bind,
    -toJsonReplacer,
    -toJson,
    -fromJson,
    -toBoolean,
    -startingTag,
    -tryDecodeURIComponent,
    -parseKeyValue,
    -toKeyValue,
    -encodeUriSegment,
    -encodeUriQuery,
    -angularInit,
    -bootstrap,
    -snake_case,
    -bindJQuery,
    -assertArg,
    -assertArgFn,
    -assertNotHasOwnProperty,
    -getter,
    -getBlockElements,

*/

////////////////////////////////////

/**
 * @ngdoc function
 * @name angular.lowercase
 * @function
 *
 * @description Converts the specified string to lowercase.
 * @param {string} string String to be converted to lowercase.
 * @returns {string} Lowercased string.
 */
var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};


/**
 * @ngdoc function
 * @name angular.uppercase
 * @function
 *
 * @description Converts the specified string to uppercase.
 * @param {string} string String to be converted to uppercase.
 * @returns {string} Uppercased string.
 */
var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


var manualLowercase = function(s) {
  /* jshint bitwise: false */
  return isString(s)
      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
      : s;
};
var manualUppercase = function(s) {
  /* jshint bitwise: false */
  return isString(s)
      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
      : s;
};


// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
if ('i' !== 'I'.toLowerCase()) {
  lowercase = manualLowercase;
  uppercase = manualUppercase;
}


var /** holds major version number for IE or NaN for real browsers */
    msie,
    jqLite,           // delay binding since jQuery could be loaded after us.
    jQuery,           // delay binding
    slice             = [].slice,
    push              = [].push,
    toString          = Object.prototype.toString,
    ngMinErr          = minErr('ng'),


    _angular          = window.angular,
    /** @name angular */
    angular           = window.angular || (window.angular = {}),
    angularModule,
    nodeName_,
    uid               = ['0', '0', '0'];

/**
 * IE 11 changed the format of the UserAgent string.
 * See http://msdn.microsoft.com/en-us/library/ms537503.aspx
 */
msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
if (isNaN(msie)) {
  msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
}


/**
 * @private
 * @param {*} obj
 * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
 *                   String ...)
 */
function isArrayLike(obj) {
  if (obj == null || isWindow(obj)) {
    return false;
  }

  var length = obj.length;

  if (obj.nodeType === 1 && length) {
    return true;
  }

  return isString(obj) || isArray(obj) || length === 0 ||
         typeof length === 'number' && length > 0 && (length - 1) in obj;
}

/**
 * @ngdoc function
 * @name angular.forEach
 * @function
 *
 * @description
 * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
 * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`
 * is the value of an object property or an array element and `key` is the object property key or
 * array element index. Specifying a `context` for the function is optional.
 *
 * Note: this function was previously known as `angular.foreach`.
 *
   <pre>
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key){
       this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender:male']);
   </pre>
 *
 * @param {Object|Array} obj Object to iterate over.
 * @param {Function} iterator Iterator function.
 * @param {Object=} context Object to become context (`this`) for the iterator function.
 * @returns {Object|Array} Reference to `obj`.
 */
function forEach(obj, iterator, context) {
  var key;
  if (obj) {
    if (isFunction(obj)){
      for (key in obj) {
        // Need to check if hasOwnProperty exists,
        // as on IE8 the result of querySelectorAll is an object without a hasOwnProperty function
        if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
          iterator.call(context, obj[key], key);
        }
      }
    } else if (obj.forEach && obj.forEach !== forEach) {
      obj.forEach(iterator, context);
    } else if (isArrayLike(obj)) {
      for (key = 0; key < obj.length; key++)
        iterator.call(context, obj[key], key);
    } else {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    }
  }
  return obj;
}

function sortedKeys(obj) {
  var keys = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keys.push(key);
    }
  }
  return keys.sort();
}

function forEachSorted(obj, iterator, context) {
  var keys = sortedKeys(obj);
  for ( var i = 0; i < keys.length; i++) {
    iterator.call(context, obj[keys[i]], keys[i]);
  }
  return keys;
}


/**
 * when using forEach the params are value, key, but it is often useful to have key, value.
 * @param {function(string, *)} iteratorFn
 * @returns {function(*, string)}
 */
function reverseParams(iteratorFn) {
  return function(value, key) { iteratorFn(key, value); };
}

/**
 * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
 * characters such as '012ABC'. The reason why we are not using simply a number counter is that
 * the number string gets longer over time, and it can also overflow, where as the nextId
 * will grow much slower, it is a string, and it will never overflow.
 *
 * @returns an unique alpha-numeric string
 */
function nextUid() {
  var index = uid.length;
  var digit;

  while(index) {
    index--;
    digit = uid[index].charCodeAt(0);
    if (digit == 57 /*'9'*/) {
      uid[index] = 'A';
      return uid.join('');
    }
    if (digit == 90  /*'Z'*/) {
      uid[index] = '0';
    } else {
      uid[index] = String.fromCharCode(digit + 1);
      return uid.join('');
    }
  }
  uid.unshift('0');
  return uid.join('');
}


/**
 * Set or clear the hashkey for an object.
 * @param obj object
 * @param h the hashkey (!truthy to delete the hashkey)
 */
function setHashKey(obj, h) {
  if (h) {
    obj.$$hashKey = h;
  }
  else {
    delete obj.$$hashKey;
  }
}

/**
 * @ngdoc function
 * @name angular.extend
 * @function
 *
 * @description
 * Extends the destination object `dst` by copying all of the properties from the `src` object(s)
 * to `dst`. You can specify multiple `src` objects.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
function extend(dst) {
  var h = dst.$$hashKey;
  forEach(arguments, function(obj){
    if (obj !== dst) {
      forEach(obj, function(value, key){
        dst[key] = value;
      });
    }
  });

  setHashKey(dst,h);
  return dst;
}

function int(str) {
  return parseInt(str, 10);
}


function inherit(parent, extra) {
  return extend(new (extend(function() {}, {prototype:parent}))(), extra);
}

/**
 * @ngdoc function
 * @name angular.noop
 * @function
 *
 * @description
 * A function that performs no operations. This function can be useful when writing code in the
 * functional style.
   <pre>
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
   </pre>
 */
function noop() {}
noop.$inject = [];


/**
 * @ngdoc function
 * @name angular.identity
 * @function
 *
 * @description
 * A function that returns its first argument. This function is useful when writing code in the
 * functional style.
 *
   <pre>
     function transformer(transformationFn, value) {
       return (transformationFn || angular.identity)(value);
     };
   </pre>
 */
function identity($) {return $;}
identity.$inject = [];


function valueFn(value) {return function() {return value;};}

/**
 * @ngdoc function
 * @name angular.isUndefined
 * @function
 *
 * @description
 * Determines if a reference is undefined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is undefined.
 */
function isUndefined(value){return typeof value === 'undefined';}


/**
 * @ngdoc function
 * @name angular.isDefined
 * @function
 *
 * @description
 * Determines if a reference is defined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is defined.
 */
function isDefined(value){return typeof value !== 'undefined';}


/**
 * @ngdoc function
 * @name angular.isObject
 * @function
 *
 * @description
 * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
 * considered to be objects.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Object` but not `null`.
 */
function isObject(value){return value != null && typeof value === 'object';}


/**
 * @ngdoc function
 * @name angular.isString
 * @function
 *
 * @description
 * Determines if a reference is a `String`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `String`.
 */
function isString(value){return typeof value === 'string';}


/**
 * @ngdoc function
 * @name angular.isNumber
 * @function
 *
 * @description
 * Determines if a reference is a `Number`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Number`.
 */
function isNumber(value){return typeof value === 'number';}


/**
 * @ngdoc function
 * @name angular.isDate
 * @function
 *
 * @description
 * Determines if a value is a date.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Date`.
 */
function isDate(value){
  return toString.call(value) === '[object Date]';
}


/**
 * @ngdoc function
 * @name angular.isArray
 * @function
 *
 * @description
 * Determines if a reference is an `Array`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is an `Array`.
 */
function isArray(value) {
  return toString.call(value) === '[object Array]';
}


/**
 * @ngdoc function
 * @name angular.isFunction
 * @function
 *
 * @description
 * Determines if a reference is a `Function`.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `Function`.
 */
function isFunction(value){return typeof value === 'function';}


/**
 * Determines if a value is a regular expression object.
 *
 * @private
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a `RegExp`.
 */
function isRegExp(value) {
  return toString.call(value) === '[object RegExp]';
}


/**
 * Checks if `obj` is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if `obj` is a window obj.
 */
function isWindow(obj) {
  return obj && obj.document && obj.location && obj.alert && obj.setInterval;
}


function isScope(obj) {
  return obj && obj.$evalAsync && obj.$watch;
}


function isFile(obj) {
  return toString.call(obj) === '[object File]';
}


function isBoolean(value) {
  return typeof value === 'boolean';
}


var trim = (function() {
  // native trim is way faster: http://jsperf.com/angular-trim-test
  // but IE doesn't have it... :-(
  // TODO: we should move this into IE/ES5 polyfill
  if (!String.prototype.trim) {
    return function(value) {
      return isString(value) ? value.replace(/^\s\s*/, '').replace(/\s\s*$/, '') : value;
    };
  }
  return function(value) {
    return isString(value) ? value.trim() : value;
  };
})();


/**
 * @ngdoc function
 * @name angular.isElement
 * @function
 *
 * @description
 * Determines if a reference is a DOM element (or wrapped jQuery element).
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
 */
function isElement(node) {
  return !!(node &&
    (node.nodeName  // we are a direct element
    || (node.on && node.find)));  // we have an on and find method part of jQuery API
}

/**
 * @param str 'key1,key2,...'
 * @returns {object} in the form of {key1:true, key2:true, ...}
 */
function makeMap(str){
  var obj = {}, items = str.split(","), i;
  for ( i = 0; i < items.length; i++ )
    obj[ items[i] ] = true;
  return obj;
}


if (msie < 9) {
  nodeName_ = function(element) {
    element = element.nodeName ? element : element[0];
    return (element.scopeName && element.scopeName != 'HTML')
      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
  };
} else {
  nodeName_ = function(element) {
    return element.nodeName ? element.nodeName : element[0].nodeName;
  };
}


function map(obj, iterator, context) {
  var results = [];
  forEach(obj, function(value, index, list) {
    results.push(iterator.call(context, value, index, list));
  });
  return results;
}


/**
 * @description
 * Determines the number of elements in an array, the number of properties an object has, or
 * the length of a string.
 *
 * Note: This function is used to augment the Object type in Angular expressions. See
 * {@link angular.Object} for more information about Angular arrays.
 *
 * @param {Object|Array|string} obj Object, array, or string to inspect.
 * @param {boolean} [ownPropsOnly=false] Count only "own" properties in an object
 * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.
 */
function size(obj, ownPropsOnly) {
  var count = 0, key;

  if (isArray(obj) || isString(obj)) {
    return obj.length;
  } else if (isObject(obj)){
    for (key in obj)
      if (!ownPropsOnly || obj.hasOwnProperty(key))
        count++;
  }

  return count;
}


function includes(array, obj) {
  return indexOf(array, obj) != -1;
}

function indexOf(array, obj) {
  if (array.indexOf) return array.indexOf(obj);

  for (var i = 0; i < array.length; i++) {
    if (obj === array[i]) return i;
  }
  return -1;
}

function arrayRemove(array, value) {
  var index = indexOf(array, value);
  if (index >=0)
    array.splice(index, 1);
  return value;
}

function isLeafNode (node) {
  if (node) {
    switch (node.nodeName) {
    case "OPTION":
    case "PRE":
    case "TITLE":
      return true;
    }
  }
  return false;
}

/**
 * @ngdoc function
 * @name angular.copy
 * @function
 *
 * @description
 * Creates a deep copy of `source`, which should be an object or an array.
 *
 * * If no destination is supplied, a copy of the object or array is created.
 * * If a destination is provided, all of its elements (for array) or properties (for objects)
 *   are deleted and then all elements/properties from the source are copied to it.
 * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.
 * * If `source` is identical to 'destination' an exception will be thrown.
 *
 * @param {*} source The source that will be used to make a copy.
 *                   Can be any type, including primitives, `null`, and `undefined`.
 * @param {(Object|Array)=} destination Destination into which the source is copied. If
 *     provided, must be of the same type as `source`.
 * @returns {*} The copy or updated `destination`, if `destination` was specified.
 *
 * @example
 <doc:example>
 <doc:source>
 <div ng-controller="Controller">
 <form novalidate class="simple-form">
 Name: <input type="text" ng-model="user.name" /><br />
 E-mail: <input type="email" ng-model="user.email" /><br />
 Gender: <input type="radio" ng-model="user.gender" value="male" />male
 <input type="radio" ng-model="user.gender" value="female" />female<br />
 <button ng-click="reset()">RESET</button>
 <button ng-click="update(user)">SAVE</button>
 </form>
 <pre>form = {{user | json}}</pre>
 <pre>master = {{master | json}}</pre>
 </div>

 <script>
 function Controller($scope) {
    $scope.master= {};

    $scope.update = function(user) {
      // Example with 1 argument
      $scope.master= angular.copy(user);
    };

    $scope.reset = function() {
      // Example with 2 arguments
      angular.copy($scope.master, $scope.user);
    };

    $scope.reset();
  }
 </script>
 </doc:source>
 </doc:example>
 */
function copy(source, destination){
  if (isWindow(source) || isScope(source)) {
    throw ngMinErr('cpws',
      "Can't copy! Making copies of Window or Scope instances is not supported.");
  }

  if (!destination) {
    destination = source;
    if (source) {
      if (isArray(source)) {
        destination = copy(source, []);
      } else if (isDate(source)) {
        destination = new Date(source.getTime());
      } else if (isRegExp(source)) {
        destination = new RegExp(source.source);
      } else if (isObject(source)) {
        destination = copy(source, {});
      }
    }
  } else {
    if (source === destination) throw ngMinErr('cpi',
      "Can't copy! Source and destination are identical.");
    if (isArray(source)) {
      destination.length = 0;
      for ( var i = 0; i < source.length; i++) {
        destination.push(copy(source[i]));
      }
    } else {
      var h = destination.$$hashKey;
      forEach(destination, function(value, key){
        delete destination[key];
      });
      for ( var key in source) {
        destination[key] = copy(source[key]);
      }
      setHashKey(destination,h);
    }
  }
  return destination;
}

/**
 * Create a shallow copy of an object
 */
function shallowCopy(src, dst) {
  dst = dst || {};

  for(var key in src) {
    // shallowCopy is only ever called by $compile nodeLinkFn, which has control over src
    // so we don't need to worry about using our custom hasOwnProperty here
    if (src.hasOwnProperty(key) && key.charAt(0) !== '$' && key.charAt(1) !== '$') {
      dst[key] = src[key];
    }
  }

  return dst;
}


/**
 * @ngdoc function
 * @name angular.equals
 * @function
 *
 * @description
 * Determines if two objects or two values are equivalent. Supports value types, regular
 * expressions, arrays and objects.
 *
 * Two objects or values are considered equivalent if at least one of the following is true:
 *
 * * Both objects or values pass `===` comparison.
 * * Both objects or values are of the same type and all of their properties are equal by
 *   comparing them with `angular.equals`.
 * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
 * * Both values represent the same regular expression (In JavasScript,
 *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
 *   representation matches).
 *
 * During a property comparison, properties of `function` type and properties with names
 * that begin with `$` are ignored.
 *
 * Scope and DOMWindow objects are being compared only by identify (`===`).
 *
 * @param {*} o1 Object or value to compare.
 * @param {*} o2 Object or value to compare.
 * @returns {boolean} True if arguments are equal.
 */
function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
  if (t1 == t2) {
    if (t1 == 'object') {
      if (isArray(o1)) {
        if (!isArray(o2)) return false;
        if ((length = o1.length) == o2.length) {
          for(key=0; key<length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        return isDate(o2) && o1.getTime() == o2.getTime();
      } else if (isRegExp(o1) && isRegExp(o2)) {
        return o1.toString() == o2.toString();
      } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
        keySet = {};
        for(key in o1) {
          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for(key in o2) {
          if (!keySet.hasOwnProperty(key) &&
              key.charAt(0) !== '$' &&
              o2[key] !== undefined &&
              !isFunction(o2[key])) return false;
        }
        return true;
      }
    }
  }
  return false;
}


function csp() {
  return (document.securityPolicy && document.securityPolicy.isActive) ||
      (document.querySelector &&
      !!(document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]')));
}


function concat(array1, array2, index) {
  return array1.concat(slice.call(array2, index));
}

function sliceArgs(args, startIndex) {
  return slice.call(args, startIndex || 0);
}


/* jshint -W101 */
/**
 * @ngdoc function
 * @name angular.bind
 * @function
 *
 * @description
 * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
 * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
 * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
 * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
 *
 * @param {Object} self Context which `fn` should be evaluated in.
 * @param {function()} fn Function to be bound.
 * @param {...*} args Optional arguments to be prebound to the `fn` function call.
 * @returns {function()} Function that wraps the `fn` with all the specified bindings.
 */
/* jshint +W101 */
function bind(self, fn) {
  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
  if (isFunction(fn) && !(fn instanceof RegExp)) {
    return curryArgs.length
      ? function() {
          return arguments.length
            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))
            : fn.apply(self, curryArgs);
        }
      : function() {
          return arguments.length
            ? fn.apply(self, arguments)
            : fn.call(self);
        };
  } else {
    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
    return fn;
  }
}


function toJsonReplacer(key, value) {
  var val = value;

  if (typeof key === 'string' && key.charAt(0) === '$') {
    val = undefined;
  } else if (isWindow(value)) {
    val = '$WINDOW';
  } else if (value &&  document === value) {
    val = '$DOCUMENT';
  } else if (isScope(value)) {
    val = '$SCOPE';
  }

  return val;
}


/**
 * @ngdoc function
 * @name angular.toJson
 * @function
 *
 * @description
 * Serializes input into a JSON-formatted string. Properties with leading $ characters will be
 * stripped since angular uses this notation internally.
 *
 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
 * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
 * @returns {string|undefined} JSON-ified string representing `obj`.
 */
function toJson(obj, pretty) {
  if (typeof obj === 'undefined') return undefined;
  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
}


/**
 * @ngdoc function
 * @name angular.fromJson
 * @function
 *
 * @description
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|Date|string|number} Deserialized thingy.
 */
function fromJson(json) {
  return isString(json)
      ? JSON.parse(json)
      : json;
}


function toBoolean(value) {
  if (value && value.length !== 0) {
    var v = lowercase("" + value);
    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
  } else {
    value = false;
  }
  return value;
}

/**
 * @returns {string} Returns the string representation of the element.
 */
function startingTag(element) {
  element = jqLite(element).clone();
  try {
    // turns out IE does not let you set .html() on elements which
    // are not allowed to have children. So we just ignore it.
    element.empty();
  } catch(e) {}
  // As Per DOM Standards
  var TEXT_NODE = 3;
  var elemHtml = jqLite('<div>').append(element).html();
  try {
    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :
        elemHtml.
          match(/^(<[^>]+>)/)[1].
          replace(/^<([\w\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });
  } catch(e) {
    return lowercase(elemHtml);
  }

}


/////////////////////////////////////////////////

/**
 * Tries to decode the URI component without throwing an exception.
 *
 * @private
 * @param str value potential URI component to check.
 * @returns {boolean} True if `value` can be decoded
 * with the decodeURIComponent function.
 */
function tryDecodeURIComponent(value) {
  try {
    return decodeURIComponent(value);
  } catch(e) {
    // Ignore any invalid uri component
  }
}


/**
 * Parses an escaped url query string into key-value pairs.
 * @returns Object.<(string|boolean)>
 */
function parseKeyValue(/**string*/keyValue) {
  var obj = {}, key_value, key;
  forEach((keyValue || "").split('&'), function(keyValue){
    if ( keyValue ) {
      key_value = keyValue.split('=');
      key = tryDecodeURIComponent(key_value[0]);
      if ( isDefined(key) ) {
        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
        if (!obj[key]) {
          obj[key] = val;
        } else if(isArray(obj[key])) {
          obj[key].push(val);
        } else {
          obj[key] = [obj[key],val];
        }
      }
    }
  });
  return obj;
}

function toKeyValue(obj) {
  var parts = [];
  forEach(obj, function(value, key) {
    if (isArray(value)) {
      forEach(value, function(arrayValue) {
        parts.push(encodeUriQuery(key, true) +
                   (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
      });
    } else {
    parts.push(encodeUriQuery(key, true) +
               (value === true ? '' : '=' + encodeUriQuery(value, true)));
    }
  });
  return parts.length ? parts.join('&') : '';
}


/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
 * segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriSegment(val) {
  return encodeUriQuery(val, true).
             replace(/%26/gi, '&').
             replace(/%3D/gi, '=').
             replace(/%2B/gi, '+');
}


/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query       = *( pchar / "/" / "?" )
 *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
 *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
 *    pct-encoded   = "%" HEXDIG HEXDIG
 *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
 *                     / "*" / "+" / "," / ";" / "="
 */
function encodeUriQuery(val, pctEncodeSpaces) {
  return encodeURIComponent(val).
             replace(/%40/gi, '@').
             replace(/%3A/gi, ':').
             replace(/%24/g, '$').
             replace(/%2C/gi, ',').
             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
}


/**
 * @ngdoc directive
 * @name ng.directive:ngApp
 *
 * @element ANY
 * @param {angular.Module} ngApp an optional application
 *   {@link angular.module module} name to load.
 *
 * @description
 *
 * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive
 * designates the **root element** of the application and is typically placed near the root element
 * of the page - e.g. on the `<body>` or `<html>` tags.
 *
 * Only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`
 * found in the document will be used to define the root element to auto-bootstrap as an
 * application. To run multiple applications in an HTML document you must manually bootstrap them using
 * {@link angular.bootstrap} instead. AngularJS applications cannot be nested within each other.
 *
 * You can specify an **AngularJS module** to be used as the root module for the application.  This
 * module will be loaded into the {@link AUTO.$injector} when the application is bootstrapped and
 * should contain the application code needed or have dependencies on other modules that will
 * contain the code. See {@link angular.module} for more information.
 *
 * In the example below if the `ngApp` directive were not placed on the `html` element then the
 * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`
 * would not be resolved to `3`.
 *
 * `ngApp` is the easiest, and most common, way to bootstrap an application.
 *
 <example module="ngAppDemo">
   <file name="index.html">
   <div ng-controller="ngAppDemoController">
     I can add: {{a}} + {{b}} =  {{ a+b }}
   </file>
   <file name="script.js">
   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {
     $scope.a = 1;
     $scope.b = 2;
   });
   </file>
 </example>
 *
 */
function angularInit(element, bootstrap) {
  var elements = [element],
      appElement,
      module,
      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
      NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

  function append(element) {
    element && elements.push(element);
  }

  forEach(names, function(name) {
    names[name] = true;
    append(document.getElementById(name));
    name = name.replace(':', '\\:');
    if (element.querySelectorAll) {
      forEach(element.querySelectorAll('.' + name), append);
      forEach(element.querySelectorAll('.' + name + '\\:'), append);
      forEach(element.querySelectorAll('[' + name + ']'), append);
    }
  });

  forEach(elements, function(element) {
    if (!appElement) {
      var className = ' ' + element.className + ' ';
      var match = NG_APP_CLASS_REGEXP.exec(className);
      if (match) {
        appElement = element;
        module = (match[2] || '').replace(/\s+/g, ',');
      } else {
        forEach(element.attributes, function(attr) {
          if (!appElement && names[attr.name]) {
            appElement = element;
            module = attr.value;
          }
        });
      }
    }
  });
  if (appElement) {
    bootstrap(appElement, module ? [module] : []);
  }
}

/**
 * @ngdoc function
 * @name angular.bootstrap
 * @description
 * Use this function to manually start up angular application.
 *
 * See: {@link guide/bootstrap Bootstrap}
 *
 * Note that ngScenario-based end-to-end tests cannot use this function to bootstrap manually.
 * They must use {@link api/ng.directive:ngApp ngApp}.
 *
 * @param {Element} element DOM element which is the root of angular application.
 * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.
 *     Each item in the array should be the name of a predefined module or a (DI annotated)
 *     function that will be invoked by the injector as a run block.
 *     See: {@link angular.module modules}
 * @returns {AUTO.$injector} Returns the newly created injector for this app.
 */
function bootstrap(element, modules) {
  var doBootstrap = function() {
    element = jqLite(element);

    if (element.injector()) {
      var tag = (element[0] === document) ? 'document' : startingTag(element);
      throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag);
    }

    modules = modules || [];
    modules.unshift(['$provide', function($provide) {
      $provide.value('$rootElement', element);
    }]);
    modules.unshift('ng');
    var injector = createInjector(modules);
    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate',
       function(scope, element, compile, injector, animate) {
        scope.$apply(function() {
          element.data('$injector', injector);
          compile(element)(scope);
        });
      }]
    );
    return injector;
  };

  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return doBootstrap();
  }

  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
  angular.resumeBootstrap = function(extraModules) {
    forEach(extraModules, function(module) {
      modules.push(module);
    });
    doBootstrap();
  };
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator){
  separator = separator || '_';
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
    return (pos ? separator : '') + letter.toLowerCase();
  });
}

function bindJQuery() {
  // bind to jQuery if present;
  jQuery = window.jQuery;
  // reset to jQuery or default to us.
  if (jQuery) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      isolateScope: JQLitePrototype.isolateScope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });
    // Method signature:
    //     jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)
    jqLitePatchJQueryRemove('remove', true, true, false);
    jqLitePatchJQueryRemove('empty', false, false, false);
    jqLitePatchJQueryRemove('html', false, false, true);
  } else {
    jqLite = JQLite;
  }
  angular.element = jqLite;
}

/**
 * throw error if the argument is falsy.
 */
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
  }

  assertArg(isFunction(arg), name, 'not a function, got ' +
      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
  return arg;
}

/**
 * throw error if the name given is hasOwnProperty
 * @param  {String} name    the name to test
 * @param  {String} context the context in which the name is used, such as module or directive
 */
function assertNotHasOwnProperty(name, context) {
  if (name === 'hasOwnProperty') {
    throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
  }
}

/**
 * Return the value accessible from the object by path. Any undefined traversals are ignored
 * @param {Object} obj starting object
 * @param {string} path path to traverse
 * @param {boolean=true} bindFnToScope
 * @returns value as accessible by path
 */
//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
  if (!path) return obj;
  var keys = path.split('.');
  var key;
  var lastInstance = obj;
  var len = keys.length;

  for (var i = 0; i < len; i++) {
    key = keys[i];
    if (obj) {
      obj = (lastInstance = obj)[key];
    }
  }
  if (!bindFnToScope && isFunction(obj)) {
    return bind(lastInstance, obj);
  }
  return obj;
}

/**
 * Return the DOM siblings between the first and last node in the given array.
 * @param {Array} array like object
 * @returns jQlite object containing the elements
 */
function getBlockElements(nodes) {
  var startNode = nodes[0],
      endNode = nodes[nodes.length - 1];
  if (startNode === endNode) {
    return jqLite(startNode);
  }

  var element = startNode;
  var elements = [element];

  do {
    element = element.nextSibling;
    if (!element) break;
    elements.push(element);
  } while (element !== endNode);

  return jqLite(elements);
}

/**
 * @ngdoc interface
 * @name angular.Module
 * @description
 *
 * Interface for configuring angular {@link angular.module modules}.
 */

function setupModuleLoader(window) {

  var $injectorMinErr = minErr('$injector');
  var ngMinErr = minErr('ng');

  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  var angular = ensure(window, 'angular', Object);

  // We need to expose `angular.$$minErr` to modules such as `ngResource` that reference it during bootstrap
  angular.$$minErr = angular.$$minErr || minErr;

  return ensure(angular, 'module', function() {
    /** @type {Object.<string, angular.Module>} */
    var modules = {};

    /**
     * @ngdoc function
     * @name angular.module
     * @description
     *
     * The `angular.module` is a global place for creating, registering and retrieving Angular
     * modules.
     * All modules (angular core or 3rd party) that should be available to an application must be
     * registered using this mechanism.
     *
     * When passed two or more arguments, a new module is created.  If passed only one argument, an
     * existing module (the name passed as the first argument to `module`) is retrieved.
     *
     *
     * # Module
     *
     * A module is a collection of services, directives, filters, and configuration information.
     * `angular.module` is used to configure the {@link AUTO.$injector $injector}.
     *
     * <pre>
     * // Create a new module
     * var myModule = angular.module('myModule', []);
     *
     * // register a new service
     * myModule.value('appName', 'MyCoolApp');
     *
     * // configure existing services inside initialization blocks.
     * myModule.config(function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix('!');
     * });
     * </pre>
     *
     * Then you can create an injector and load your modules like this:
     *
     * <pre>
     * var injector = angular.injector(['ng', 'MyModule'])
     * </pre>
     *
     * However it's more likely that you'll just use
     * {@link ng.directive:ngApp ngApp} or
     * {@link angular.bootstrap} to simplify this process for you.
     *
     * @param {!string} name The name of the module to create or retrieve.
     * @param {Array.<string>=} requires If specified then new module is being created. If
     *        unspecified then the the module is being retrieved for further configuration.
     * @param {Function} configFn Optional configuration function for the module. Same as
     *        {@link angular.Module#methods_config Module#config()}.
     * @returns {module} new module with the {@link angular.Module} api.
     */
    return function module(name, requires, configFn) {
      var assertNotHasOwnProperty = function(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
        }
      };

      assertNotHasOwnProperty(name, 'module');
      if (requires && modules.hasOwnProperty(name)) {
        modules[name] = null;
      }
      return ensure(modules, name, function() {
        if (!requires) {
          throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " +
             "the module name or forgot to load it. If registering a module ensure that you " +
             "specify the dependencies as the second argument.", name);
        }

        /** @type {!Array.<Array.<*>>} */
        var invokeQueue = [];

        /** @type {!Array.<Function>} */
        var runBlocks = [];

        var config = invokeLater('$injector', 'invoke');

        /** @type {angular.Module} */
        var moduleInstance = {
          // Private state
          _invokeQueue: invokeQueue,
          _runBlocks: runBlocks,

          /**
           * @ngdoc property
           * @name angular.Module#requires
           * @propertyOf angular.Module
           * @returns {Array.<string>} List of module names which must be loaded before this module.
           * @description
           * Holds the list of modules which the injector will load before the current module is
           * loaded.
           */
          requires: requires,

          /**
           * @ngdoc property
           * @name angular.Module#name
           * @propertyOf angular.Module
           * @returns {string} Name of the module.
           * @description
           */
          name: name,


          /**
           * @ngdoc method
           * @name angular.Module#provider
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerType Construction function for creating new instance of the
           *                                service.
           * @description
           * See {@link AUTO.$provide#provider $provide.provider()}.
           */
          provider: invokeLater('$provide', 'provider'),

          /**
           * @ngdoc method
           * @name angular.Module#factory
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerFunction Function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#factory $provide.factory()}.
           */
          factory: invokeLater('$provide', 'factory'),

          /**
           * @ngdoc method
           * @name angular.Module#service
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} constructor A constructor function that will be instantiated.
           * @description
           * See {@link AUTO.$provide#service $provide.service()}.
           */
          service: invokeLater('$provide', 'service'),

          /**
           * @ngdoc method
           * @name angular.Module#value
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {*} object Service instance object.
           * @description
           * See {@link AUTO.$provide#value $provide.value()}.
           */
          value: invokeLater('$provide', 'value'),

          /**
           * @ngdoc method
           * @name angular.Module#constant
           * @methodOf angular.Module
           * @param {string} name constant name
           * @param {*} object Constant value.
           * @description
           * Because the constant are fixed, they get applied before other provide methods.
           * See {@link AUTO.$provide#constant $provide.constant()}.
           */
          constant: invokeLater('$provide', 'constant', 'unshift'),

          /**
           * @ngdoc method
           * @name angular.Module#animation
           * @methodOf angular.Module
           * @param {string} name animation name
           * @param {Function} animationFactory Factory function for creating new instance of an
           *                                    animation.
           * @description
           *
           * **NOTE**: animations take effect only if the **ngAnimate** module is loaded.
           *
           *
           * Defines an animation hook that can be later used with
           * {@link ngAnimate.$animate $animate} service and directives that use this service.
           *
           * <pre>
           * module.animation('.animation-name', function($inject1, $inject2) {
           *   return {
           *     eventName : function(element, done) {
           *       //code to run the animation
           *       //once complete, then run done()
           *       return function cancellationFunction(element) {
           *         //code to cancel the animation
           *       }
           *     }
           *   }
           * })
           * </pre>
           *
           * See {@link ngAnimate.$animateProvider#register $animateProvider.register()} and
           * {@link ngAnimate ngAnimate module} for more information.
           */
          animation: invokeLater('$animateProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#filter
           * @methodOf angular.Module
           * @param {string} name Filter name.
           * @param {Function} filterFactory Factory function for creating new instance of filter.
           * @description
           * See {@link ng.$filterProvider#register $filterProvider.register()}.
           */
          filter: invokeLater('$filterProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#controller
           * @methodOf angular.Module
           * @param {string|Object} name Controller name, or an object map of controllers where the
           *    keys are the names and the values are the constructors.
           * @param {Function} constructor Controller constructor function.
           * @description
           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
           */
          controller: invokeLater('$controllerProvider', 'register'),

          /**
           * @ngdoc method
           * @name angular.Module#directive
           * @methodOf angular.Module
           * @param {string|Object} name Directive name, or an object map of directives where the
           *    keys are the names and the values are the factories.
           * @param {Function} directiveFactory Factory function for creating new instance of
           * directives.
           * @description
           * See {@link ng.$compileProvider#methods_directive $compileProvider.directive()}.
           */
          directive: invokeLater('$compileProvider', 'directive'),

          /**
           * @ngdoc method
           * @name angular.Module#config
           * @methodOf angular.Module
           * @param {Function} configFn Execute this function on module load. Useful for service
           *    configuration.
           * @description
           * Use this method to register work which needs to be performed on module loading.
           */
          config: config,

          /**
           * @ngdoc method
           * @name angular.Module#run
           * @methodOf angular.Module
           * @param {Function} initializationFn Execute this function after injector creation.
           *    Useful for application initialization.
           * @description
           * Use this method to register work which should be performed when the injector is done
           * loading all modules.
           */
          run: function(block) {
            runBlocks.push(block);
            return this;
          }
        };

        if (configFn) {
          config(configFn);
        }

        return  moduleInstance;

        /**
         * @param {string} provider
         * @param {string} method
         * @param {String=} insertMethod
         * @returns {angular.Module}
         */
        function invokeLater(provider, method, insertMethod) {
          return function() {
            invokeQueue[insertMethod || 'push']([provider, method, arguments]);
            return moduleInstance;
          };
        }
      });
    };
  });

}

/* global
    angularModule: true,
    version: true,
    
    $LocaleProvider,
    $CompileProvider,
    
    htmlAnchorDirective,
    inputDirective,
    inputDirective,
    formDirective,
    scriptDirective,
    selectDirective,
    styleDirective,
    optionDirective,
    ngBindDirective,
    ngBindHtmlDirective,
    ngBindTemplateDirective,
    ngClassDirective,
    ngClassEvenDirective,
    ngClassOddDirective,
    ngCspDirective,
    ngCloakDirective,
    ngControllerDirective,
    ngFormDirective,
    ngHideDirective,
    ngIfDirective,
    ngIncludeDirective,
    ngIncludeFillContentDirective,
    ngInitDirective,
    ngNonBindableDirective,
    ngPluralizeDirective,
    ngRepeatDirective,
    ngShowDirective,
    ngStyleDirective,
    ngSwitchDirective,
    ngSwitchWhenDirective,
    ngSwitchDefaultDirective,
    ngOptionsDirective,
    ngTranscludeDirective,
    ngModelDirective,
    ngListDirective,
    ngChangeDirective,
    requiredDirective,
    requiredDirective,
    ngValueDirective,
    ngAttributeAliasDirectives,
    ngEventDirectives,

    $AnchorScrollProvider,
    $AnimateProvider,
    $BrowserProvider,
    $CacheFactoryProvider,
    $ControllerProvider,
    $DocumentProvider,
    $ExceptionHandlerProvider,
    $FilterProvider,
    $InterpolateProvider,
    $IntervalProvider,
    $HttpProvider,
    $HttpBackendProvider,
    $LocationProvider,
    $LogProvider,
    $ParseProvider,
    $RootScopeProvider,
    $QProvider,
    $$SanitizeUriProvider,
    $SceProvider,
    $SceDelegateProvider,
    $SnifferProvider,
    $TemplateCacheProvider,
    $TimeoutProvider,
    $WindowProvider
*/


/**
 * @ngdoc property
 * @name angular.version
 * @description
 * An object that contains information about the current AngularJS version. This object has the
 * following properties:
 *
 * - `full` – `{string}` – Full version string, such as "0.9.18".
 * - `major` – `{number}` – Major version number, such as "0".
 * - `minor` – `{number}` – Minor version number, such as "9".
 * - `dot` – `{number}` – Dot version number, such as "18".
 * - `codeName` – `{string}` – Code name of the release, such as "jiggling-armfat".
 */
var version = {
  full: '1.2.6',    // all of these placeholder strings will be replaced by grunt's
  major: 1,    // package task
  minor: 2,
  dot: 6,
  codeName: 'taco-salsafication'
};


function publishExternalAPI(angular){
  extend(angular, {
    'bootstrap': bootstrap,
    'copy': copy,
    'extend': extend,
    'equals': equals,
    'element': jqLite,
    'forEach': forEach,
    'injector': createInjector,
    'noop':noop,
    'bind':bind,
    'toJson': toJson,
    'fromJson': fromJson,
    'identity':identity,
    'isUndefined': isUndefined,
    'isDefined': isDefined,
    'isString': isString,
    'isFunction': isFunction,
    'isObject': isObject,
    'isNumber': isNumber,
    'isElement': isElement,
    'isArray': isArray,
    'version': version,
    'isDate': isDate,
    'lowercase': lowercase,
    'uppercase': uppercase,
    'callbacks': {counter: 0},
    '$$minErr': minErr,
    '$$csp': csp
  });

  angularModule = setupModuleLoader(window);
  try {
    angularModule('ngLocale');
  } catch (e) {
    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
  }

  angularModule('ng', ['ngLocale'], ['$provide',
    function ngModule($provide) {
      // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
      $provide.provider({
        $$sanitizeUri: $$SanitizeUriProvider
      });
      $provide.provider('$compile', $CompileProvider).
        directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            ngValue: ngValueDirective
        }).
        directive({
          ngInclude: ngIncludeFillContentDirective
        }).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider({
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $interpolate: $InterpolateProvider,
        $interval: $IntervalProvider,
        $http: $HttpProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider
      });
    }
  ]);
}

/* global

  -JQLitePrototype,
  -addEventListenerFn,
  -removeEventListenerFn,
  -BOOLEAN_ATTR
*/

//////////////////////////////////
//JQLite
//////////////////////////////////

/**
 * @ngdoc function
 * @name angular.element
 * @function
 *
 * @description
 * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
 *
 * If jQuery is available, `angular.element` is an alias for the
 * [jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not available, `angular.element`
 * delegates to Angular's built-in subset of jQuery, called "jQuery lite" or "jqLite."
 *
 * <div class="alert alert-success">jqLite is a tiny, API-compatible subset of jQuery that allows
 * Angular to manipulate the DOM in a cross-browser compatible way. **jqLite** implements only the most
 * commonly needed functionality with the goal of having a very small footprint.</div>
 *
 * To use jQuery, simply load it before `DOMContentLoaded` event fired.
 *
 * <div class="alert">**Note:** all element references in Angular are always wrapped with jQuery or
 * jqLite; they are never raw DOM references.</div>
 *
 * ## Angular's jqLite
 * jqLite provides only the following jQuery methods:
 *
 * - [`addClass()`](http://api.jquery.com/addClass/)
 * - [`after()`](http://api.jquery.com/after/)
 * - [`append()`](http://api.jquery.com/append/)
 * - [`attr()`](http://api.jquery.com/attr/)
 * - [`bind()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
 * - [`children()`](http://api.jquery.com/children/) - Does not support selectors
 * - [`clone()`](http://api.jquery.com/clone/)
 * - [`contents()`](http://api.jquery.com/contents/)
 * - [`css()`](http://api.jquery.com/css/)
 * - [`data()`](http://api.jquery.com/data/)
 * - [`empty()`](http://api.jquery.com/empty/)
 * - [`eq()`](http://api.jquery.com/eq/)
 * - [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name
 * - [`hasClass()`](http://api.jquery.com/hasClass/)
 * - [`html()`](http://api.jquery.com/html/)
 * - [`next()`](http://api.jquery.com/next/) - Does not support selectors
 * - [`on()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData
 * - [`off()`](http://api.jquery.com/off/) - Does not support namespaces or selectors
 * - [`one()`](http://api.jquery.com/one/) - Does not support namespaces or selectors
 * - [`parent()`](http://api.jquery.com/parent/) - Does not support selectors
 * - [`prepend()`](http://api.jquery.com/prepend/)
 * - [`prop()`](http://api.jquery.com/prop/)
 * - [`ready()`](http://api.jquery.com/ready/)
 * - [`remove()`](http://api.jquery.com/remove/)
 * - [`removeAttr()`](http://api.jquery.com/removeAttr/)
 * - [`removeClass()`](http://api.jquery.com/removeClass/)
 * - [`removeData()`](http://api.jquery.com/removeData/)
 * - [`replaceWith()`](http://api.jquery.com/replaceWith/)
 * - [`text()`](http://api.jquery.com/text/)
 * - [`toggleClass()`](http://api.jquery.com/toggleClass/)
 * - [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
 * - [`unbind()`](http://api.jquery.com/off/) - Does not support namespaces
 * - [`val()`](http://api.jquery.com/val/)
 * - [`wrap()`](http://api.jquery.com/wrap/)
 *
 * ## jQuery/jqLite Extras
 * Angular also provides the following additional methods and events to both jQuery and jqLite:
 *
 * ### Events
 * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event
 *    on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM
 *    element before it is removed.
 *
 * ### Methods
 * - `controller(name)` - retrieves the controller of the current element or its parent. By default
 *   retrieves controller associated with the `ngController` directive. If `name` is provided as
 *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
 *   `'ngModel'`).
 * - `injector()` - retrieves the injector of the current element or its parent.
 * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current
 *   element or its parent.
 * - `isolateScope()` - retrieves an isolate {@link api/ng.$rootScope.Scope scope} if one is attached directly to the
 *   current element. This getter should be used only on elements that contain a directive which starts a new isolate
 *   scope. Calling `scope()` on this element always returns the original non-isolate scope.
 * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
 *   parent element is reached.
 *
 * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
 * @returns {Object} jQuery object.
 */

var jqCache = JQLite.cache = {},
    jqName = JQLite.expando = 'ng-' + new Date().getTime(),
    jqId = 1,
    addEventListenerFn = (window.document.addEventListener
      ? function(element, type, fn) {element.addEventListener(type, fn, false);}
      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),
    removeEventListenerFn = (window.document.removeEventListener
      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }
      : function(element, type, fn) {element.detachEvent('on' + type, fn); });

function jqNextId() { return ++jqId; }


var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;
var jqLiteMinErr = minErr('jqLite');

/**
 * Converts snake_case to camelCase.
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function camelCase(name) {
  return name.
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).
    replace(MOZ_HACK_REGEXP, 'Moz$1');
}

/////////////////////////////////////////////
// jQuery mutation patch
//
// In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a
// $destroy event on all DOM nodes being removed.
//
/////////////////////////////////////////////

function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
  var originalJqFn = jQuery.fn[name];
  originalJqFn = originalJqFn.$original || originalJqFn;
  removePatch.$original = originalJqFn;
  jQuery.fn[name] = removePatch;

  function removePatch(param) {
    // jshint -W040
    var list = filterElems && param ? [this.filter(param)] : [this],
        fireEvent = dispatchThis,
        set, setIndex, setLength,
        element, childIndex, childLength, children;

    if (!getterIfNoArguments || param != null) {
      while(list.length) {
        set = list.shift();
        for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for(childIndex = 0, childLength = (children = element.children()).length;
              childIndex < childLength;
              childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
    }
    return originalJqFn.apply(this, arguments);
  }
}

/////////////////////////////////////////////
function JQLite(element) {
  if (element instanceof JQLite) {
    return element;
  }
  if (!(this instanceof JQLite)) {
    if (isString(element) && element.charAt(0) != '<') {
      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
    }
    return new JQLite(element);
  }

  if (isString(element)) {
    var div = document.createElement('div');
    // Read about the NoScope elements here:
    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx
    div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!
    div.removeChild(div.firstChild); // remove the superfluous div
    jqLiteAddNodes(this, div.childNodes);
    var fragment = jqLite(document.createDocumentFragment());
    fragment.append(this); // detach the elements from the temporary DOM div.
  } else {
    jqLiteAddNodes(this, element);
  }
}

function jqLiteClone(element) {
  return element.cloneNode(true);
}

function jqLiteDealoc(element){
  jqLiteRemoveData(element);
  for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {
    jqLiteDealoc(children[i]);
  }
}

function jqLiteOff(element, type, fn, unsupported) {
  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');

  var events = jqLiteExpandoStore(element, 'events'),
      handle = jqLiteExpandoStore(element, 'handle');

  if (!handle) return; //no listeners registered

  if (isUndefined(type)) {
    forEach(events, function(eventHandler, type) {
      removeEventListenerFn(element, type, eventHandler);
      delete events[type];
    });
  } else {
    forEach(type.split(' '), function(type) {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type] || [], fn);
      }
    });
  }
}

function jqLiteRemoveData(element, name) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId];

  if (expandoStore) {
    if (name) {
      delete jqCache[expandoId].data[name];
      return;
    }

    if (expandoStore.handle) {
      expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
      jqLiteOff(element);
    }
    delete jqCache[expandoId];
    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.
  }
}

function jqLiteExpandoStore(element, key, value) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId || -1];

  if (isDefined(value)) {
    if (!expandoStore) {
      element[jqName] = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {};
    }
    expandoStore[key] = value;
  } else {
    return expandoStore && expandoStore[key];
  }
}

function jqLiteData(element, key, value) {
  var data = jqLiteExpandoStore(element, 'data'),
      isSetter = isDefined(value),
      keyDefined = !isSetter && isDefined(key),
      isSimpleGetter = keyDefined && !isObject(key);

  if (!data && !isSimpleGetter) {
    jqLiteExpandoStore(element, 'data', data = {});
  }

  if (isSetter) {
    data[key] = value;
  } else {
    if (keyDefined) {
      if (isSimpleGetter) {
        // don't create data in this case.
        return data && data[key];
      } else {
        extend(data, key);
      }
    } else {
      return data;
    }
  }
}

function jqLiteHasClass(element, selector) {
  if (!element.getAttribute) return false;
  return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").
      indexOf( " " + selector + " " ) > -1);
}

function jqLiteRemoveClass(element, cssClasses) {
  if (cssClasses && element.setAttribute) {
    forEach(cssClasses.split(' '), function(cssClass) {
      element.setAttribute('class', trim(
          (" " + (element.getAttribute('class') || '') + " ")
          .replace(/[\n\t]/g, " ")
          .replace(" " + trim(cssClass) + " ", " "))
      );
    });
  }
}

function jqLiteAddClass(element, cssClasses) {
  if (cssClasses && element.setAttribute) {
    var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ')
                            .replace(/[\n\t]/g, " ");

    forEach(cssClasses.split(' '), function(cssClass) {
      cssClass = trim(cssClass);
      if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
        existingClasses += cssClass + ' ';
      }
    });

    element.setAttribute('class', trim(existingClasses));
  }
}

function jqLiteAddNodes(root, elements) {
  if (elements) {
    elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))
      ? elements
      : [ elements ];
    for(var i=0; i < elements.length; i++) {
      root.push(elements[i]);
    }
  }
}

function jqLiteController(element, name) {
  return jqLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');
}

function jqLiteInheritedData(element, name, value) {
  element = jqLite(element);

  // if element is the document object work with the html element instead
  // this makes $(document).scope() possible
  if(element[0].nodeType == 9) {
    element = element.find('html');
  }
  var names = isArray(name) ? name : [name];

  while (element.length) {

    for (var i = 0, ii = names.length; i < ii; i++) {
      if ((value = element.data(names[i])) !== undefined) return value;
    }
    element = element.parent();
  }
}

function jqLiteEmpty(element) {
  for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
    jqLiteDealoc(childNodes[i]);
  }
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}

//////////////////////////////////////////
// Functions which are declared directly.
//////////////////////////////////////////
var JQLitePrototype = JQLite.prototype = {
  ready: function(fn) {
    var fired = false;

    function trigger() {
      if (fired) return;
      fired = true;
      fn();
    }

    // check if document already is loaded
    if (document.readyState === 'complete'){
      setTimeout(trigger);
    } else {
      this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9
      // we can not use jqLite since we are not done loading and jQuery could be loaded later.
      // jshint -W064
      JQLite(window).on('load', trigger); // fallback to window.onload for others
      // jshint +W064
    }
  },
  toString: function() {
    var value = [];
    forEach(this, function(e){ value.push('' + e);});
    return '[' + value.join(', ') + ']';
  },

  eq: function(index) {
      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
  },

  length: 0,
  push: push,
  sort: [].sort,
  splice: [].splice
};

//////////////////////////////////////////
// Functions iterating getter/setters.
// these functions return self on setter and
// value on get.
//////////////////////////////////////////
var BOOLEAN_ATTR = {};
forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
  BOOLEAN_ATTR[lowercase(value)] = value;
});
var BOOLEAN_ELEMENTS = {};
forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
  BOOLEAN_ELEMENTS[uppercase(value)] = true;
});

function getBooleanAttrName(element, name) {
  // check dom last since we will most likely fail on name
  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];

  // booleanAttr is here twice to minimize DOM access
  return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
}

forEach({
  data: jqLiteData,
  inheritedData: jqLiteInheritedData,

  scope: function(element) {
    // Can't use jqLiteData here directly so we stay compatible with jQuery!
    return jqLite(element).data('$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
  },

  isolateScope: function(element) {
    // Can't use jqLiteData here directly so we stay compatible with jQuery!
    return jqLite(element).data('$isolateScope') || jqLite(element).data('$isolateScopeNoTemplate');
  },

  controller: jqLiteController ,

  injector: function(element) {
    return jqLiteInheritedData(element, '$injector');
  },

  removeAttr: function(element,name) {
    element.removeAttribute(name);
  },

  hasClass: jqLiteHasClass,

  css: function(element, name, value) {
    name = camelCase(name);

    if (isDefined(value)) {
      element.style[name] = value;
    } else {
      var val;

      if (msie <= 8) {
        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
        val = element.currentStyle && element.currentStyle[name];
        if (val === '') val = 'auto';
      }

      val = val || element.style[name];

      if (msie <= 8) {
        // jquery weirdness :-/
        val = (val === '') ? undefined : val;
      }

      return  val;
    }
  },

  attr: function(element, name, value){
    var lowercasedName = lowercase(name);
    if (BOOLEAN_ATTR[lowercasedName]) {
      if (isDefined(value)) {
        if (!!value) {
          element[name] = true;
          element.setAttribute(name, lowercasedName);
        } else {
          element[name] = false;
          element.removeAttribute(lowercasedName);
        }
      } else {
        return (element[name] ||
                 (element.attributes.getNamedItem(name)|| noop).specified)
               ? lowercasedName
               : undefined;
      }
    } else if (isDefined(value)) {
      element.setAttribute(name, value);
    } else if (element.getAttribute) {
      // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
      // some elements (e.g. Document) don't have get attribute, so return undefined
      var ret = element.getAttribute(name, 2);
      // normalize non-existing attributes to undefined (as jQuery)
      return ret === null ? undefined : ret;
    }
  },

  prop: function(element, name, value) {
    if (isDefined(value)) {
      element[name] = value;
    } else {
      return element[name];
    }
  },

  text: (function() {
    var NODE_TYPE_TEXT_PROPERTY = [];
    if (msie < 9) {
      NODE_TYPE_TEXT_PROPERTY[1] = 'innerText';    /** Element **/
      NODE_TYPE_TEXT_PROPERTY[3] = 'nodeValue';    /** Text **/
    } else {
      NODE_TYPE_TEXT_PROPERTY[1] =                 /** Element **/
      NODE_TYPE_TEXT_PROPERTY[3] = 'textContent';  /** Text **/
    }
    getText.$dv = '';
    return getText;

    function getText(element, value) {
      var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
      if (isUndefined(value)) {
        return textProp ? element[textProp] : '';
      }
      element[textProp] = value;
    }
  })(),

  val: function(element, value) {
    if (isUndefined(value)) {
      if (nodeName_(element) === 'SELECT' && element.multiple) {
        var result = [];
        forEach(element.options, function (option) {
          if (option.selected) {
            result.push(option.value || option.text);
          }
        });
        return result.length === 0 ? null : result;
      }
      return element.value;
    }
    element.value = value;
  },

  html: function(element, value) {
    if (isUndefined(value)) {
      return element.innerHTML;
    }
    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
      jqLiteDealoc(childNodes[i]);
    }
    element.innerHTML = value;
  },

  empty: jqLiteEmpty
}, function(fn, name){
  /**
   * Properties: writes return selection, reads return first value
   */
  JQLite.prototype[name] = function(arg1, arg2) {
    var i, key;

    // jqLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
    // in a way that survives minification.
    // jqLiteEmpty takes no arguments but is a setter.
    if (fn !== jqLiteEmpty &&
        (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
      if (isObject(arg1)) {

        // we are a write, but the object properties are the key/values
        for (i = 0; i < this.length; i++) {
          if (fn === jqLiteData) {
            // data() takes the whole object in jQuery
            fn(this[i], arg1);
          } else {
            for (key in arg1) {
              fn(this[i], key, arg1[key]);
            }
          }
        }
        // return self for chaining
        return this;
      } else {
        // we are a read, so read the first child.
        var value = fn.$dv;
        // Only if we have $dv do we iterate over all, otherwise it is just the first element.
        var jj = (value === undefined) ? Math.min(this.length, 1) : this.length;
        for (var j = 0; j < jj; j++) {
          var nodeValue = fn(this[j], arg1, arg2);
          value = value ? value + nodeValue : nodeValue;
        }
        return value;
      }
    } else {
      // we are a write, so apply to all children
      for (i = 0; i < this.length; i++) {
        fn(this[i], arg1, arg2);
      }
      // return self for chaining
      return this;
    }
  };
});

function createEventHandler(element, events) {
  var eventHandler = function (event, type) {
    if (!event.preventDefault) {
      event.preventDefault = function() {
        event.returnValue = false; //ie
      };
    }

    if (!event.stopPropagation) {
      event.stopPropagation = function() {
        event.cancelBubble = true; //ie
      };
    }

    if (!event.target) {
      event.target = event.srcElement || document;
    }

    if (isUndefined(event.defaultPrevented)) {
      var prevent = event.preventDefault;
      event.preventDefault = function() {
        event.defaultPrevented = true;
        prevent.call(event);
      };
      event.defaultPrevented = false;
    }

    event.isDefaultPrevented = function() {
      return event.defaultPrevented || event.returnValue === false;
    };

    // Copy event handlers in case event handlers array is modified during execution.
    var eventHandlersCopy = shallowCopy(events[type || event.type] || []);

    forEach(eventHandlersCopy, function(fn) {
      fn.call(element, event);
    });

    // Remove monkey-patched methods (IE),
    // as they would cause memory leaks in IE8.
    if (msie <= 8) {
      // IE7/8 does not allow to delete property on native object
      event.preventDefault = null;
      event.stopPropagation = null;
      event.isDefaultPrevented = null;
    } else {
      // It shouldn't affect normal browsers (native methods are defined on prototype).
      delete event.preventDefault;
      delete event.stopPropagation;
      delete event.isDefaultPrevented;
    }
  };
  eventHandler.elem = element;
  return eventHandler;
}

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
forEach({
  removeData: jqLiteRemoveData,

  dealoc: jqLiteDealoc,

  on: function onFn(element, type, fn, unsupported){
    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');

    var events = jqLiteExpandoStore(element, 'events'),
        handle = jqLiteExpandoStore(element, 'handle');

    if (!events) jqLiteExpandoStore(element, 'events', events = {});
    if (!handle) jqLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));

    forEach(type.split(' '), function(type){
      var eventFns = events[type];

      if (!eventFns) {
        if (type == 'mouseenter' || type == 'mouseleave') {
          var contains = document.body.contains || document.body.compareDocumentPosition ?
          function( a, b ) {
            // jshint bitwise: false
            var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
              adown.contains ?
              adown.contains( bup ) :
              a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
              ));
            } :
            function( a, b ) {
              if ( b ) {
                while ( (b = b.parentNode) ) {
                  if ( b === a ) {
                    return true;
                  }
                }
              }
              return false;
            };

          events[type] = [];

          // Refer to jQuery's implementation of mouseenter & mouseleave
          // Read about mouseenter and mouseleave:
          // http://www.quirksmode.org/js/events_mouse.html#link8
          var eventmap = { mouseleave : "mouseout", mouseenter : "mouseover"};

          onFn(element, eventmap[type], function(event) {
            var target = this, related = event.relatedTarget;
            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !contains(target, related)) ){
              handle(event, type);
            }
          });

        } else {
          addEventListenerFn(element, type, handle);
          events[type] = [];
        }
        eventFns = events[type];
      }
      eventFns.push(fn);
    });
  },

  off: jqLiteOff,

  one: function(element, type, fn) {
    element = jqLite(element);

    //add the listener twice so that when it is called
    //you can remove the original function and still be
    //able to call element.off(ev, fn) normally
    element.on(type, function onFn() {
      element.off(type, fn);
      element.off(type, onFn);
    });
    element.on(type, fn);
  },

  replaceWith: function(element, replaceNode) {
    var index, parent = element.parentNode;
    jqLiteDealoc(element);
    forEach(new JQLite(replaceNode), function(node){
      if (index) {
        parent.insertBefore(node, index.nextSibling);
      } else {
        parent.replaceChild(node, element);
      }
      index = node;
    });
  },

  children: function(element) {
    var children = [];
    forEach(element.childNodes, function(element){
      if (element.nodeType === 1)
        children.push(element);
    });
    return children;
  },

  contents: function(element) {
    return element.childNodes || [];
  },

  append: function(element, node) {
    forEach(new JQLite(node), function(child){
      if (element.nodeType === 1 || element.nodeType === 11) {
        element.appendChild(child);
      }
    });
  },

  prepend: function(element, node) {
    if (element.nodeType === 1) {
      var index = element.firstChild;
      forEach(new JQLite(node), function(child){
        element.insertBefore(child, index);
      });
    }
  },

  wrap: function(element, wrapNode) {
    wrapNode = jqLite(wrapNode)[0];
    var parent = element.parentNode;
    if (parent) {
      parent.replaceChild(wrapNode, element);
    }
    wrapNode.appendChild(element);
  },

  remove: function(element) {
    jqLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  },

  after: function(element, newElement) {
    var index = element, parent = element.parentNode;
    forEach(new JQLite(newElement), function(node){
      parent.insertBefore(node, index.nextSibling);
      index = node;
    });
  },

  addClass: jqLiteAddClass,
  removeClass: jqLiteRemoveClass,

  toggleClass: function(element, selector, condition) {
    if (isUndefined(condition)) {
      condition = !jqLiteHasClass(element, selector);
    }
    (condition ? jqLiteAddClass : jqLiteRemoveClass)(element, selector);
  },

  parent: function(element) {
    var parent = element.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },

  next: function(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }

    // IE8 doesn't have nextElementSibling
    var elm = element.nextSibling;
    while (elm != null && elm.nodeType !== 1) {
      elm = elm.nextSibling;
    }
    return elm;
  },

  find: function(element, selector) {
    if (element.getElementsByTagName) {
      return element.getElementsByTagName(selector);
    } else {
      return [];
    }
  },

  clone: jqLiteClone,

  triggerHandler: function(element, eventName, eventData) {
    var eventFns = (jqLiteExpandoStore(element, 'events') || {})[eventName];

    eventData = eventData || [];

    var event = [{
      preventDefault: noop,
      stopPropagation: noop
    }];

    forEach(eventFns, function(fn) {
      fn.apply(element, event.concat(eventData));
    });
  }
}, function(fn, name){
  /**
   * chaining functions
   */
  JQLite.prototype[name] = function(arg1, arg2, arg3) {
    var value;
    for(var i=0; i < this.length; i++) {
      if (isUndefined(value)) {
        value = fn(this[i], arg1, arg2, arg3);
        if (isDefined(value)) {
          // any function which returns a value needs to be wrapped
          value = jqLite(value);
        }
      } else {
        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
      }
    }
    return isDefined(value) ? value : this;
  };

  // bind legacy bind/unbind to on/off
  JQLite.prototype.bind = JQLite.prototype.on;
  JQLite.prototype.unbind = JQLite.prototype.off;
});

/**
 * Computes a hash of an 'obj'.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in 'type:hashKey' format.
 */
function hashKey(obj) {
  var objType = typeof obj,
      key;

  if (objType == 'object' && obj !== null) {
    if (typeof (key = obj.$$hashKey) == 'function') {
      // must invoke on object to keep the right this
      key = obj.$$hashKey();
    } else if (key === undefined) {
      key = obj.$$hashKey = nextUid();
    }
  } else {
    key = obj;
  }

  return objType + ':' + key;
}

/**
 * HashMap which can use objects as keys
 */
function HashMap(array){
  forEach(array, this.put, this);
}
HashMap.prototype = {
  /**
   * Store key value pair
   * @param key key to store can be any type
   * @param value value to store can be any type
   */
  put: function(key, value) {
    this[hashKey(key)] = value;
  },

  /**
   * @param key
   * @returns the value for the key
   */
  get: function(key) {
    return this[hashKey(key)];
  },

  /**
   * Remove the key/value pair
   * @param key
   */
  remove: function(key) {
    var value = this[key = hashKey(key)];
    delete this[key];
    return value;
  }
};

/**
 * @ngdoc function
 * @name angular.injector
 * @function
 *
 * @description
 * Creates an injector function that can be used for retrieving services as well as for
 * dependency injection (see {@link guide/di dependency injection}).
 *

 * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
 *        {@link angular.module}. The `ng` module must be explicitly added.
 * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.
 *
 * @example
 * Typical usage
 * <pre>
 *   // create an injector
 *   var $injector = angular.injector(['ng']);
 *
 *   // use the injector to kick off your application
 *   // use the type inference to auto inject arguments, or use implicit injection
 *   $injector.invoke(function($rootScope, $compile, $document){
 *     $compile($document)($rootScope);
 *     $rootScope.$digest();
 *   });
 * </pre>
 *
 * Sometimes you want to get access to the injector of a currently running Angular app
 * from outside Angular. Perhaps, you want to inject and compile some markup after the
 * application has been bootstrapped. You can do this using extra `injector()` added
 * to JQuery/jqLite elements. See {@link angular.element}.
 *
 * *This is fairly rare but could be the case if a third party library is injecting the
 * markup.*
 *
 * In the following example a new block of HTML containing a `ng-controller`
 * directive is added to the end of the document body by JQuery. We then compile and link
 * it into the current AngularJS scope.
 *
 * <pre>
 * var $div = $('<div ng-controller="MyCtrl">{{content.label}}</div>');
 * $(document.body).append($div);
 *
 * angular.element(document).injector().invoke(function($compile) {
 *   var scope = angular.element($div).scope();
 *   $compile($div)(scope);
 * });
 * </pre>
 */


/**
 * @ngdoc overview
 * @name AUTO
 * @description
 *
 * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.
 */

var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var $injectorMinErr = minErr('$injector');
function annotate(fn) {
  var $inject,
      fnText,
      argDecl,
      last;

  if (typeof fn == 'function') {
    if (!($inject = fn.$inject)) {
      $inject = [];
      if (fn.length) {
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
          arg.replace(FN_ARG, function(all, underscore, name){
            $inject.push(name);
          });
        });
      }
      fn.$inject = $inject;
    }
  } else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], 'fn');
    $inject = fn.slice(0, last);
  } else {
    assertArgFn(fn, 'fn', true);
  }
  return $inject;
}

///////////////////////////////////////

/**
 * @ngdoc object
 * @name AUTO.$injector
 * @function
 *
 * @description
 *
 * `$injector` is used to retrieve object instances as defined by
 * {@link AUTO.$provide provider}, instantiate types, invoke methods,
 * and load modules.
 *
 * The following always holds true:
 *
 * <pre>
 *   var $injector = angular.injector();
 *   expect($injector.get('$injector')).toBe($injector);
 *   expect($injector.invoke(function($injector){
 *     return $injector;
 *   }).toBe($injector);
 * </pre>
 *
 * # Injection Function Annotation
 *
 * JavaScript does not have annotations, and annotations are needed for dependency injection. The
 * following are all valid ways of annotating function with injection arguments and are equivalent.
 *
 * <pre>
 *   // inferred (only works if code not minified/obfuscated)
 *   $injector.invoke(function(serviceA){});
 *
 *   // annotated
 *   function explicit(serviceA) {};
 *   explicit.$inject = ['serviceA'];
 *   $injector.invoke(explicit);
 *
 *   // inline
 *   $injector.invoke(['serviceA', function(serviceA){}]);
 * </pre>
 *
 * ## Inference
 *
 * In JavaScript calling `toString()` on a function returns the function definition. The definition
 * can then be parsed and the function arguments can be extracted. *NOTE:* This does not work with
 * minification, and obfuscation tools since these tools change the argument names.
 *
 * ## `$inject` Annotation
 * By adding a `$inject` property onto a function the injection parameters can be specified.
 *
 * ## Inline
 * As an array of injection names, where the last item in the array is the function to call.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#get
 * @methodOf AUTO.$injector
 *
 * @description
 * Return an instance of the service.
 *
 * @param {string} name The name of the instance to retrieve.
 * @return {*} The instance.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#invoke
 * @methodOf AUTO.$injector
 *
 * @description
 * Invoke the method and supply the method arguments from the `$injector`.
 *
 * @param {!function} fn The function to invoke. Function parameters are injected according to the
 *   {@link guide/di $inject Annotation} rules.
 * @param {Object=} self The `this` for the invoked method.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this
 *                         object first, before the `$injector` is consulted.
 * @returns {*} the value returned by the invoked `fn` function.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#has
 * @methodOf AUTO.$injector
 *
 * @description
 * Allows the user to query if the particular service exist.
 *
 * @param {string} Name of the service to query.
 * @returns {boolean} returns true if injector has given service.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#instantiate
 * @methodOf AUTO.$injector
 * @description
 * Create a new instance of JS type. The method takes a constructor function invokes the new
 * operator and supplies all of the arguments to the constructor function as specified by the
 * constructor annotation.
 *
 * @param {function} Type Annotated constructor function.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this
 * object first, before the `$injector` is consulted.
 * @returns {Object} new instance of `Type`.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#annotate
 * @methodOf AUTO.$injector
 *
 * @description
 * Returns an array of service names which the function is requesting for injection. This API is
 * used by the injector to determine which services need to be injected into the function when the
 * function is invoked. There are three ways in which the function can be annotated with the needed
 * dependencies.
 *
 * # Argument names
 *
 * The simplest form is to extract the dependencies from the arguments of the function. This is done
 * by converting the function into a string using `toString()` method and extracting the argument
 * names.
 * <pre>
 *   // Given
 *   function MyController($scope, $route) {
 *     // ...
 *   }
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
 * </pre>
 *
 * This method does not work with code minification / obfuscation. For this reason the following
 * annotation strategies are supported.
 *
 * # The `$inject` property
 *
 * If a function has an `$inject` property and its value is an array of strings, then the strings
 * represent names of services to be injected into the function.
 * <pre>
 *   // Given
 *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
 *     // ...
 *   }
 *   // Define function dependencies
 *   MyController['$inject'] = ['$scope', '$route'];
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);
 * </pre>
 *
 * # The array notation
 *
 * It is often desirable to inline Injected functions and that's when setting the `$inject` property
 * is very inconvenient. In these situations using the array notation to specify the dependencies in
 * a way that survives minification is a better choice:
 *
 * <pre>
 *   // We wish to write this (not minification / obfuscation safe)
 *   injector.invoke(function($compile, $rootScope) {
 *     // ...
 *   });
 *
 *   // We are forced to write break inlining
 *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
 *     // ...
 *   };
 *   tmpFn.$inject = ['$compile', '$rootScope'];
 *   injector.invoke(tmpFn);
 *
 *   // To better support inline function the inline annotation is supported
 *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {
 *     // ...
 *   }]);
 *
 *   // Therefore
 *   expect(injector.annotate(
 *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])
 *    ).toEqual(['$compile', '$rootScope']);
 * </pre>
 *
 * @param {function|Array.<string|Function>} fn Function for which dependent service names need to
 * be retrieved as described above.
 *
 * @returns {Array.<string>} The names of the services which the function requires.
 */




/**
 * @ngdoc object
 * @name AUTO.$provide
 *
 * @description
 *
 * The {@link AUTO.$provide $provide} service has a number of methods for registering components
 * with the {@link AUTO.$injector $injector}. Many of these functions are also exposed on
 * {@link angular.Module}.
 *
 * An Angular **service** is a singleton object created by a **service factory**.  These **service
 * factories** are functions which, in turn, are created by a **service provider**.
 * The **service providers** are constructor functions. When instantiated they must contain a
 * property called `$get`, which holds the **service factory** function.
 *
 * When you request a service, the {@link AUTO.$injector $injector} is responsible for finding the
 * correct **service provider**, instantiating it and then calling its `$get` **service factory**
 * function to get the instance of the **service**.
 *
 * Often services have no configuration options and there is no need to add methods to the service
 * provider.  The provider will be no more than a constructor function with a `$get` property. For
 * these cases the {@link AUTO.$provide $provide} service has additional helper methods to register
 * services without specifying a provider.
 *
 * * {@link AUTO.$provide#methods_provider provider(provider)} - registers a **service provider** with the
 *     {@link AUTO.$injector $injector}
 * * {@link AUTO.$provide#methods_constant constant(obj)} - registers a value/object that can be accessed by
 *     providers and services.
 * * {@link AUTO.$provide#methods_value value(obj)} - registers a value/object that can only be accessed by
 *     services, not providers.
 * * {@link AUTO.$provide#methods_factory factory(fn)} - registers a service **factory function**, `fn`,
 *     that will be wrapped in a **service provider** object, whose `$get` property will contain the
 *     given factory function.
 * * {@link AUTO.$provide#methods_service service(class)} - registers a **constructor function**, `class` that
 *     that will be wrapped in a **service provider** object, whose `$get` property will instantiate
 *      a new object using the given constructor function.
 *
 * See the individual methods for more information and examples.
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#provider
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a **provider function** with the {@link AUTO.$injector $injector}. Provider functions
 * are constructor functions, whose instances are responsible for "providing" a factory for a
 * service.
 *
 * Service provider names start with the name of the service they provide followed by `Provider`.
 * For example, the {@link ng.$log $log} service has a provider called
 * {@link ng.$logProvider $logProvider}.
 *
 * Service provider objects can have additional methods which allow configuration of the provider
 * and its service. Importantly, you can configure what kind of service is created by the `$get`
 * method, or how that service will act. For example, the {@link ng.$logProvider $logProvider} has a
 * method {@link ng.$logProvider#debugEnabled debugEnabled}
 * which lets you specify whether the {@link ng.$log $log} service will log debug messages to the
 * console or not.
 *
 * @param {string} name The name of the instance. NOTE: the provider will be available under `name +
                        'Provider'` key.
 * @param {(Object|function())} provider If the provider is:
 *
 *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
 *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be
 *               created.
 *   - `Constructor`: a new instance of the provider will be created using
 *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as
 *               `object`.
 *
 * @returns {Object} registered provider instance

 * @example
 *
 * The following example shows how to create a simple event tracking service and register it using
 * {@link AUTO.$provide#methods_provider $provide.provider()}.
 *
 * <pre>
 *  // Define the eventTracker provider
 *  function EventTrackerProvider() {
 *    var trackingUrl = '/track';
 *
 *    // A provider method for configuring where the tracked events should been saved
 *    this.setTrackingUrl = function(url) {
 *      trackingUrl = url;
 *    };
 *
 *    // The service factory function
 *    this.$get = ['$http', function($http) {
 *      var trackedEvents = {};
 *      return {
 *        // Call this to track an event
 *        event: function(event) {
 *          var count = trackedEvents[event] || 0;
 *          count += 1;
 *          trackedEvents[event] = count;
 *          return count;
 *        },
 *        // Call this to save the tracked events to the trackingUrl
 *        save: function() {
 *          $http.post(trackingUrl, trackedEvents);
 *        }
 *      };
 *    }];
 *  }
 *
 *  describe('eventTracker', function() {
 *    var postSpy;
 *
 *    beforeEach(module(function($provide) {
 *      // Register the eventTracker provider
 *      $provide.provider('eventTracker', EventTrackerProvider);
 *    }));
 *
 *    beforeEach(module(function(eventTrackerProvider) {
 *      // Configure eventTracker provider
 *      eventTrackerProvider.setTrackingUrl('/custom-track');
 *    }));
 *
 *    it('tracks events', inject(function(eventTracker) {
 *      expect(eventTracker.event('login')).toEqual(1);
 *      expect(eventTracker.event('login')).toEqual(2);
 *    }));
 *
 *    it('saves to the tracking url', inject(function(eventTracker, $http) {
 *      postSpy = spyOn($http, 'post');
 *      eventTracker.event('login');
 *      eventTracker.save();
 *      expect(postSpy).toHaveBeenCalled();
 *      expect(postSpy.mostRecentCall.args[0]).not.toEqual('/track');
 *      expect(postSpy.mostRecentCall.args[0]).toEqual('/custom-track');
 *      expect(postSpy.mostRecentCall.args[1]).toEqual({ 'login': 1 });
 *    }));
 *  });
 * </pre>
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#factory
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a **service factory**, which will be called to return the service instance.
 * This is short for registering a service where its provider consists of only a `$get` property,
 * which is the given service factory function.
 * You should use {@link AUTO.$provide#factory $provide.factory(getFn)} if you do not need to
 * configure your service in a provider.
 *
 * @param {string} name The name of the instance.
 * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand
 *                            for `$provide.provider(name, {$get: $getFn})`.
 * @returns {Object} registered provider instance
 *
 * @example
 * Here is an example of registering a service
 * <pre>
 *   $provide.factory('ping', ['$http', function($http) {
 *     return function ping() {
 *       return $http.send('/ping');
 *     };
 *   }]);
 * </pre>
 * You would then inject and use this service like this:
 * <pre>
 *   someModule.controller('Ctrl', ['ping', function(ping) {
 *     ping();
 *   }]);
 * </pre>
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#service
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a **service constructor**, which will be invoked with `new` to create the service
 * instance.
 * This is short for registering a service where its provider's `$get` property is the service
 * constructor function that will be used to instantiate the service instance.
 *
 * You should use {@link AUTO.$provide#methods_service $provide.service(class)} if you define your service
 * as a type/class. This is common when using {@link http://coffeescript.org CoffeeScript}.
 *
 * @param {string} name The name of the instance.
 * @param {Function} constructor A class (constructor function) that will be instantiated.
 * @returns {Object} registered provider instance
 *
 * @example
 * Here is an example of registering a service using
 * {@link AUTO.$provide#methods_service $provide.service(class)} that is defined as a CoffeeScript class.
 * <pre>
 *   class Ping
 *     constructor: (@$http) ->
 *     send: () =>
 *       @$http.get('/ping')
 *
 *   $provide.service('ping', ['$http', Ping])
 * </pre>
 * You would then inject and use this service like this:
 * <pre>
 *   someModule.controller 'Ctrl', ['ping', (ping) ->
 *     ping.send()
 *   ]
 * </pre>
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#value
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a **value service** with the {@link AUTO.$injector $injector}, such as a string, a
 * number, an array, an object or a function.  This is short for registering a service where its
 * provider's `$get` property is a factory function that takes no arguments and returns the **value
 * service**.
 *
 * Value services are similar to constant services, except that they cannot be injected into a
 * module configuration function (see {@link angular.Module#config}) but they can be overridden by
 * an Angular
 * {@link AUTO.$provide#decorator decorator}.
 *
 * @param {string} name The name of the instance.
 * @param {*} value The value.
 * @returns {Object} registered provider instance
 *
 * @example
 * Here are some examples of creating value services.
 * <pre>
 *   $provide.value('ADMIN_USER', 'admin');
 *
 *   $provide.value('RoleLookup', { admin: 0, writer: 1, reader: 2 });
 *
 *   $provide.value('halfOf', function(value) {
 *     return value / 2;
 *   });
 * </pre>
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#constant
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a **constant service**, such as a string, a number, an array, an object or a function,
 * with the {@link AUTO.$injector $injector}. Unlike {@link AUTO.$provide#value value} it can be
 * injected into a module configuration function (see {@link angular.Module#config}) and it cannot
 * be overridden by an Angular {@link AUTO.$provide#decorator decorator}.
 *
 * @param {string} name The name of the constant.
 * @param {*} value The constant value.
 * @returns {Object} registered instance
 *
 * @example
 * Here a some examples of creating constants:
 * <pre>
 *   $provide.constant('SHARD_HEIGHT', 306);
 *
 *   $provide.constant('MY_COLOURS', ['red', 'blue', 'grey']);
 *
 *   $provide.constant('double', function(value) {
 *     return value * 2;
 *   });
 * </pre>
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#decorator
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a **service decorator** with the {@link AUTO.$injector $injector}. A service decorator
 * intercepts the creation of a service, allowing it to override or modify the behaviour of the
 * service. The object returned by the decorator may be the original service, or a new service
 * object which replaces or wraps and delegates to the original service.
 *
 * @param {string} name The name of the service to decorate.
 * @param {function()} decorator This function will be invoked when the service needs to be
 *    instantiated and should return the decorated service instance. The function is called using
 *    the {@link AUTO.$injector#invoke injector.invoke} method and is therefore fully injectable.
 *    Local injection arguments:
 *
 *    * `$delegate` - The original service instance, which can be monkey patched, configured,
 *      decorated or delegated to.
 *
 * @example
 * Here we decorate the {@link ng.$log $log} service to convert warnings to errors by intercepting
 * calls to {@link ng.$log#error $log.warn()}.
 * <pre>
 *   $provider.decorator('$log', ['$delegate', function($delegate) {
 *     $delegate.warn = $delegate.error;
 *     return $delegate;
 *   }]);
 * </pre>
 */


function createInjector(modulesToLoad) {
  var INSTANTIATING = {},
      providerSuffix = 'Provider',
      path = [],
      loadedModules = new HashMap(),
      providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          }
      },
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, function() {
            throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
          })),
      instanceCache = {},
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
          }));


  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });

  return instanceInjector;

  ////////////////////////////////////
  // $provider
  ////////////////////////////////////

  function supportObject(delegate) {
    return function(key, value) {
      if (isObject(key)) {
        forEach(key, reverseParams(delegate));
      } else {
        return delegate(key, value);
      }
    };
  }

  function provider(name, provider_) {
    assertNotHasOwnProperty(name, 'service');
    if (isFunction(provider_) || isArray(provider_)) {
      provider_ = providerInjector.instantiate(provider_);
    }
    if (!provider_.$get) {
      throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
    }
    return providerCache[name + providerSuffix] = provider_;
  }

  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }

  function service(name, constructor) {
    return factory(name, ['$injector', function($injector) {
      return $injector.instantiate(constructor);
    }]);
  }

  function value(name, val) { return factory(name, valueFn(val)); }

  function constant(name, value) {
    assertNotHasOwnProperty(name, 'constant');
    providerCache[name] = value;
    instanceCache[name] = value;
  }

  function decorator(serviceName, decorFn) {
    var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = function() {
      var origInstance = instanceInjector.invoke(orig$get, origProvider);
      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
    };
  }

  ////////////////////////////////////
  // Module Loading
  ////////////////////////////////////
  function loadModules(modulesToLoad){
    var runBlocks = [], moduleFn, invokeQueue, i, ii;
    forEach(modulesToLoad, function(module) {
      if (loadedModules.get(module)) return;
      loadedModules.put(module, true);

      try {
        if (isString(module)) {
          moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

          for(invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
            var invokeArgs = invokeQueue[i],
                provider = providerInjector.get(invokeArgs[0]);

            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
        } else {
          assertArgFn(module, 'module');
        }
      } catch (e) {
        if (isArray(module)) {
          module = module[module.length - 1];
        }
        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
          // Safari & FF's stack traces don't contain error.message content
          // unlike those of Chrome and IE
          // So if stack doesn't contain message, we create a new string that contains both.
          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.
          /* jshint -W022 */
          e = e.message + '\n' + e.stack;
        }
        throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}",
                  module, e.stack || e.message || e);
      }
    });
    return runBlocks;
  }

  ////////////////////////////////////
  // internal Injector
  ////////////////////////////////////

  function createInternalInjector(cache, factory) {

    function getService(serviceName) {
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr('cdep', 'Circular dependency found: {0}', path.join(' <- '));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          return cache[serviceName] = factory(serviceName);
        } finally {
          path.shift();
        }
      }
    }

    function invoke(fn, self, locals){
      var args = [],
          $inject = annotate(fn),
          length, i,
          key;

      for(i = 0, length = $inject.length; i < length; i++) {
        key = $inject[i];
        if (typeof key !== 'string') {
          throw $injectorMinErr('itkn',
                  'Incorrect injection token! Expected service name as string, got {0}', key);
        }
        args.push(
          locals && locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key)
        );
      }
      if (!fn.$inject) {
        // this means that we must be an array.
        fn = fn[length];
      }

      // http://jsperf.com/angularjs-invoke-apply-vs-switch
      // #5388
      return fn.apply(self, args);
    }

    function instantiate(Type, locals) {
      var Constructor = function() {},
          instance, returnedValue;

      // Check if Type is annotated and use just the given function at n-1 as parameter
      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
      instance = new Constructor();
      returnedValue = invoke(Type, instance, locals);

      return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
    }

    return {
      invoke: invoke,
      instantiate: instantiate,
      get: getService,
      annotate: annotate,
      has: function(name) {
        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      }
    };
  }
}

/**
 * @ngdoc function
 * @name ng.$anchorScroll
 * @requires $window
 * @requires $location
 * @requires $rootScope
 *
 * @description
 * When called, it checks current value of `$location.hash()` and scroll to related element,
 * according to rules specified in
 * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.
 *
 * It also watches the `$location.hash()` and scrolls whenever it changes to match any anchor.
 * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.
 * 
 * @example
   <example>
     <file name="index.html">
       <div id="scrollArea" ng-controller="ScrollCtrl">
         <a ng-click="gotoBottom()">Go to bottom</a>
         <a id="bottom"></a> You're at the bottom!
       </div>
     </file>
     <file name="script.js">
       function ScrollCtrl($scope, $location, $anchorScroll) {
         $scope.gotoBottom = function (){
           // set the location.hash to the id of
           // the element you wish to scroll to.
           $location.hash('bottom');
           
           // call $anchorScroll()
           $anchorScroll();
         }
       }
     </file>
     <file name="style.css">
       #scrollArea {
         height: 350px;
         overflow: auto;
       }

       #bottom {
         display: block;
         margin-top: 2000px;
       }
     </file>
   </example>
 */
function $AnchorScrollProvider() {

  var autoScrollingEnabled = true;

  this.disableAutoScrolling = function() {
    autoScrollingEnabled = false;
  };

  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
    var document = $window.document;

    // helper function to get first anchor from a NodeList
    // can't use filter.filter, as it accepts only instances of Array
    // and IE can't convert NodeList to an array using [].slice
    // TODO(vojta): use filter if we change it to accept lists as well
    function getFirstAnchor(list) {
      var result = null;
      forEach(list, function(element) {
        if (!result && lowercase(element.nodeName) === 'a') result = element;
      });
      return result;
    }

    function scroll() {
      var hash = $location.hash(), elm;

      // empty hash, scroll to the top of the page
      if (!hash) $window.scrollTo(0, 0);

      // element with given id
      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();

      // first anchor with given name :-D
      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();

      // no element and hash == 'top', scroll to the top of the page
      else if (hash === 'top') $window.scrollTo(0, 0);
    }

    // does not scroll when user clicks on anchor link that is currently on
    // (no url change, no $location.hash() change), browser native does scroll
    if (autoScrollingEnabled) {
      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
        function autoScrollWatchAction() {
          $rootScope.$evalAsync(scroll);
        });
    }

    return scroll;
  }];
}

var $animateMinErr = minErr('$animate');

/**
 * @ngdoc object
 * @name ng.$animateProvider
 *
 * @description
 * Default implementation of $animate that doesn't perform any animations, instead just
 * synchronously performs DOM
 * updates and calls done() callbacks.
 *
 * In order to enable animations the ngAnimate module has to be loaded.
 *
 * To see the functional implementation check out src/ngAnimate/animate.js
 */
var $AnimateProvider = ['$provide', function($provide) {

  
  this.$$selectors = {};


  /**
   * @ngdoc function
   * @name ng.$animateProvider#register
   * @methodOf ng.$animateProvider
   *
   * @description
   * Registers a new injectable animation factory function. The factory function produces the
   * animation object which contains callback functions for each event that is expected to be
   * animated.
   *
   *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction`
   *   must be called once the element animation is complete. If a function is returned then the
   *   animation service will use this function to cancel the animation whenever a cancel event is
   *   triggered.
   *
   *
   *<pre>
   *   return {
     *     eventFn : function(element, done) {
     *       //code to run the animation
     *       //once complete, then run done()
     *       return function cancellationFunction() {
     *         //code to cancel the animation
     *       }
     *     }
     *   }
   *</pre>
   *
   * @param {string} name The name of the animation.
   * @param {function} factory The factory function that will be executed to return the animation
   *                           object.
   */
  this.register = function(name, factory) {
    var key = name + '-animation';
    if (name && name.charAt(0) != '.') throw $animateMinErr('notcsel',
        "Expecting class selector starting with '.' got '{0}'.", name);
    this.$$selectors[name.substr(1)] = key;
    $provide.factory(key, factory);
  };

  /**
   * @ngdoc function
   * @name ng.$animateProvider#classNameFilter
   * @methodOf ng.$animateProvider
   *
   * @description
   * Sets and/or returns the CSS class regular expression that is checked when performing
   * an animation. Upon bootstrap the classNameFilter value is not set at all and will
   * therefore enable $animate to attempt to perform an animation on any element.
   * When setting the classNameFilter value, animations will only be performed on elements
   * that successfully match the filter expression. This in turn can boost performance
   * for low-powered devices as well as applications containing a lot of structural operations.
   * @param {RegExp=} expression The className expression which will be checked against all animations
   * @return {RegExp} The current CSS className expression value. If null then there is no expression value
   */
  this.classNameFilter = function(expression) {
    if(arguments.length === 1) {
      this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
    }
    return this.$$classNameFilter;
  };

  this.$get = ['$timeout', function($timeout) {

    /**
     *
     * @ngdoc object
     * @name ng.$animate
     * @description The $animate service provides rudimentary DOM manipulation functions to
     * insert, remove and move elements within the DOM, as well as adding and removing classes.
     * This service is the core service used by the ngAnimate $animator service which provides
     * high-level animation hooks for CSS and JavaScript.
     *
     * $animate is available in the AngularJS core, however, the ngAnimate module must be included
     * to enable full out animation support. Otherwise, $animate will only perform simple DOM
     * manipulation operations.
     *
     * To learn more about enabling animation support, click here to visit the {@link ngAnimate
     * ngAnimate module page} as well as the {@link ngAnimate.$animate ngAnimate $animate service
     * page}.
     */
    return {

      /**
       *
       * @ngdoc function
       * @name ng.$animate#enter
       * @methodOf ng.$animate
       * @function
       * @description Inserts the element into the DOM either after the `after` element or within
       *   the `parent` element. Once complete, the done() callback will be fired (if provided).
       * @param {jQuery/jqLite element} element the element which will be inserted into the DOM
       * @param {jQuery/jqLite element} parent the parent element which will append the element as
       *   a child (if the after element is not present)
       * @param {jQuery/jqLite element} after the sibling element which will append the element
       *   after itself
       * @param {function=} done callback function that will be called after the element has been
       *   inserted into the DOM
       */
      enter : function(element, parent, after, done) {
        if (after) {
          after.after(element);
        } else {
          if (!parent || !parent[0]) {
            parent = after.parent();
          }
          parent.append(element);
        }
        done && $timeout(done, 0, false);
      },

      /**
       *
       * @ngdoc function
       * @name ng.$animate#leave
       * @methodOf ng.$animate
       * @function
       * @description Removes the element from the DOM. Once complete, the done() callback will be
       *   fired (if provided).
       * @param {jQuery/jqLite element} element the element which will be removed from the DOM
       * @param {function=} done callback function that will be called after the element has been
       *   removed from the DOM
       */
      leave : function(element, done) {
        element.remove();
        done && $timeout(done, 0, false);
      },

      /**
       *
       * @ngdoc function
       * @name ng.$animate#move
       * @methodOf ng.$animate
       * @function
       * @description Moves the position of the provided element within the DOM to be placed
       * either after the `after` element or inside of the `parent` element. Once complete, the
       * done() callback will be fired (if provided).
       * 
       * @param {jQuery/jqLite element} element the element which will be moved around within the
       *   DOM
       * @param {jQuery/jqLite element} parent the parent element where the element will be
       *   inserted into (if the after element is not present)
       * @param {jQuery/jqLite element} after the sibling element where the element will be
       *   positioned next to
       * @param {function=} done the callback function (if provided) that will be fired after the
       *   element has been moved to its new position
       */
      move : function(element, parent, after, done) {
        // Do not remove element before insert. Removing will cause data associated with the
        // element to be dropped. Insert will implicitly do the remove.
        this.enter(element, parent, after, done);
      },

      /**
       *
       * @ngdoc function
       * @name ng.$animate#addClass
       * @methodOf ng.$animate
       * @function
       * @description Adds the provided className CSS class value to the provided element. Once
       * complete, the done() callback will be fired (if provided).
       * @param {jQuery/jqLite element} element the element which will have the className value
       *   added to it
       * @param {string} className the CSS class which will be added to the element
       * @param {function=} done the callback function (if provided) that will be fired after the
       *   className value has been added to the element
       */
      addClass : function(element, className, done) {
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(' ') : '';
        forEach(element, function (element) {
          jqLiteAddClass(element, className);
        });
        done && $timeout(done, 0, false);
      },

      /**
       *
       * @ngdoc function
       * @name ng.$animate#removeClass
       * @methodOf ng.$animate
       * @function
       * @description Removes the provided className CSS class value from the provided element.
       * Once complete, the done() callback will be fired (if provided).
       * @param {jQuery/jqLite element} element the element which will have the className value
       *   removed from it
       * @param {string} className the CSS class which will be removed from the element
       * @param {function=} done the callback function (if provided) that will be fired after the
       *   className value has been removed from the element
       */
      removeClass : function(element, className, done) {
        className = isString(className) ?
                      className :
                      isArray(className) ? className.join(' ') : '';
        forEach(element, function (element) {
          jqLiteRemoveClass(element, className);
        });
        done && $timeout(done, 0, false);
      },

      enabled : noop
    };
  }];
}];

/**
 * ! This is a private undocumented service !
 *
 * @name ng.$browser
 * @requires $log
 * @description
 * This object has two goals:
 *
 * - hide all the global state in the browser caused by the window object
 * - abstract away all the browser specific features and inconsistencies
 *
 * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`
 * service, which can be used for convenient testing of the application without the interaction with
 * the real browser apis.
 */
/**
 * @param {object} window The global window object.
 * @param {object} document jQuery wrapped document.
 * @param {function()} XHR XMLHttpRequest constructor.
 * @param {object} $log console.log or an object with the same interface.
 * @param {object} $sniffer $sniffer service
 */
function Browser(window, document, $log, $sniffer) {
  var self = this,
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};

  self.isMock = false;

  var outstandingRequestCount = 0;
  var outstandingRequestCallbacks = [];

  // TODO(vojta): remove this temporary api
  self.$$completeOutstandingRequest = completeOutstandingRequest;
  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };

  /**
   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
   */
  function completeOutstandingRequest(fn) {
    try {
      fn.apply(null, sliceArgs(arguments, 1));
    } finally {
      outstandingRequestCount--;
      if (outstandingRequestCount === 0) {
        while(outstandingRequestCallbacks.length) {
          try {
            outstandingRequestCallbacks.pop()();
          } catch (e) {
            $log.error(e);
          }
        }
      }
    }
  }

  /**
   * @private
   * Note: this method is used only by scenario runner
   * TODO(vojta): prefix this method with $$ ?
   * @param {function()} callback Function that will be called when no outstanding request
   */
  self.notifyWhenNoOutstandingRequests = function(callback) {
    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
    // at some deterministic time in respect to the test runner's actions. Leaving things up to the
    // regular poller would result in flaky tests.
    forEach(pollFns, function(pollFn){ pollFn(); });

    if (outstandingRequestCount === 0) {
      callback();
    } else {
      outstandingRequestCallbacks.push(callback);
    }
  };

  //////////////////////////////////////////////////////////////
  // Poll Watcher API
  //////////////////////////////////////////////////////////////
  var pollFns = [],
      pollTimeout;

  /**
   * @name ng.$browser#addPollFn
   * @methodOf ng.$browser
   *
   * @param {function()} fn Poll function to add
   *
   * @description
   * Adds a function to the list of functions that poller periodically executes,
   * and starts polling if not started yet.
   *
   * @returns {function()} the added function
   */
  self.addPollFn = function(fn) {
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
    pollFns.push(fn);
    return fn;
  };

  /**
   * @param {number} interval How often should browser call poll functions (ms)
   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
   *
   * @description
   * Configures the poller to run in the specified intervals, using the specified
   * setTimeout fn and kicks it off.
   */
  function startPoller(interval, setTimeout) {
    (function check() {
      forEach(pollFns, function(pollFn){ pollFn(); });
      pollTimeout = setTimeout(check, interval);
    })();
  }

  //////////////////////////////////////////////////////////////
  // URL API
  //////////////////////////////////////////////////////////////

  var lastBrowserUrl = location.href,
      baseElement = document.find('base'),
      newLocation = null;

  /**
   * @name ng.$browser#url
   * @methodOf ng.$browser
   *
   * @description
   * GETTER:
   * Without any argument, this method just returns current value of location.href.
   *
   * SETTER:
   * With at least one argument, this method sets url to new value.
   * If html5 history api supported, pushState/replaceState is used, otherwise
   * location.href/location.replace is used.
   * Returns its own instance to allow chaining
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to change url.
   *
   * @param {string} url New url (when used as setter)
   * @param {boolean=} replace Should new url replace current history record ?
   */
  self.url = function(url, replace) {
    // Android Browser BFCache causes location reference to become stale.
    if (location !== window.location) location = window.location;

    // setter
    if (url) {
      if (lastBrowserUrl == url) return;
      lastBrowserUrl = url;
      if ($sniffer.history) {
        if (replace) history.replaceState(null, '', url);
        else {
          history.pushState(null, '', url);
          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462
          baseElement.attr('href', baseElement.attr('href'));
        }
      } else {
        newLocation = url;
        if (replace) {
          location.replace(url);
        } else {
          location.href = url;
        }
      }
      return self;
    // getter
    } else {
      // - newLocation is a workaround for an IE7-9 issue with location.replace and location.href
      //   methods not updating location.href synchronously.
      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
      return newLocation || location.href.replace(/%27/g,"'");
    }
  };

  var urlChangeListeners = [],
      urlChangeInit = false;

  function fireUrlChange() {
    newLocation = null;
    if (lastBrowserUrl == self.url()) return;

    lastBrowserUrl = self.url();
    forEach(urlChangeListeners, function(listener) {
      listener(self.url());
    });
  }

  /**
   * @name ng.$browser#onUrlChange
   * @methodOf ng.$browser
   * @TODO(vojta): refactor to use node's syntax for events
   *
   * @description
   * Register callback function that will be called, when url changes.
   *
   * It's only called when the url is changed by outside of angular:
   * - user types different url into address bar
   * - user clicks on history (forward/back) button
   * - user clicks on a link
   *
   * It's not called when url is changed by $browser.url() method
   *
   * The listener gets called with new url as parameter.
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to monitor url changes in angular apps.
   *
   * @param {function(string)} listener Listener function to be called when url changes.
   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
   */
  self.onUrlChange = function(callback) {
    if (!urlChangeInit) {
      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
      // don't fire popstate when user change the address bar and don't fire hashchange when url
      // changed by push/replaceState

      // html5 history api - popstate event
      if ($sniffer.history) jqLite(window).on('popstate', fireUrlChange);
      // hashchange event
      if ($sniffer.hashchange) jqLite(window).on('hashchange', fireUrlChange);
      // polling
      else self.addPollFn(fireUrlChange);

      urlChangeInit = true;
    }

    urlChangeListeners.push(callback);
    return callback;
  };

  //////////////////////////////////////////////////////////////
  // Misc API
  //////////////////////////////////////////////////////////////

  /**
   * @name ng.$browser#baseHref
   * @methodOf ng.$browser
   * 
   * @description
   * Returns current <base href>
   * (always relative - without domain)
   *
   * @returns {string=} current <base href>
   */
  self.baseHref = function() {
    var href = baseElement.attr('href');
    return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
  };

  //////////////////////////////////////////////////////////////
  // Cookies API
  //////////////////////////////////////////////////////////////
  var lastCookies = {};
  var lastCookieString = '';
  var cookiePath = self.baseHref();

  /**
   * @name ng.$browser#cookies
   * @methodOf ng.$browser
   *
   * @param {string=} name Cookie name
   * @param {string=} value Cookie value
   *
   * @description
   * The cookies method provides a 'private' low level access to browser cookies.
   * It is not meant to be used directly, use the $cookie service instead.
   *
   * The return values vary depending on the arguments that the method was called with as follows:
   * 
   * - cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify
   *   it
   * - cookies(name, value) -> set name to value, if value is undefined delete the cookie
   * - cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that
   *   way)
   * 
   * @returns {Object} Hash of all cookies (if called without any parameter)
   */
  self.cookies = function(name, value) {
    /* global escape: false, unescape: false */
    var cookieLength, cookieArray, cookie, i, index;

    if (name) {
      if (value === undefined) {
        rawDocument.cookie = escape(name) + "=;path=" + cookiePath +
                                ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
      } else {
        if (isString(value)) {
          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) +
                                ';path=' + cookiePath).length + 1;

          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
          // - 300 cookies
          // - 20 cookies per unique domain
          // - 4096 bytes per cookie
          if (cookieLength > 4096) {
            $log.warn("Cookie '"+ name +
              "' possibly not set or overflowed because it was too large ("+
              cookieLength + " > 4096 bytes)!");
          }
        }
      }
    } else {
      if (rawDocument.cookie !== lastCookieString) {
        lastCookieString = rawDocument.cookie;
        cookieArray = lastCookieString.split("; ");
        lastCookies = {};

        for (i = 0; i < cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf('=');
          if (index > 0) { //ignore nameless cookies
            name = unescape(cookie.substring(0, index));
            // the first value that is seen for a cookie is the most
            // specific one.  values for the same cookie name that
            // follow are for less specific paths.
            if (lastCookies[name] === undefined) {
              lastCookies[name] = unescape(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    }
  };


  /**
   * @name ng.$browser#defer
   * @methodOf ng.$browser
   * @param {function()} fn A function, who's execution should be deferred.
   * @param {number=} [delay=0] of milliseconds to defer the function execution.
   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
   *
   * @description
   * Executes a fn asynchronously via `setTimeout(fn, delay)`.
   *
   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
   * via `$browser.defer.flush()`.
   *
   */
  self.defer = function(fn, delay) {
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(function() {
      delete pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    }, delay || 0);
    pendingDeferIds[timeoutId] = true;
    return timeoutId;
  };


  /**
   * @name ng.$browser#defer.cancel
   * @methodOf ng.$browser.defer
   *
   * @description
   * Cancels a deferred task identified with `deferId`.
   *
   * @param {*} deferId Token returned by the `$browser.defer` function.
   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
   *                    canceled.
   */
  self.defer.cancel = function(deferId) {
    if (pendingDeferIds[deferId]) {
      delete pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      return true;
    }
    return false;
  };

}

function $BrowserProvider(){
  this.$get = ['$window', '$log', '$sniffer', '$document',
      function( $window,   $log,   $sniffer,   $document){
        return new Browser($window, $document, $log, $sniffer);
      }];
}

/**
 * @ngdoc object
 * @name ng.$cacheFactory
 *
 * @description
 * Factory that constructs cache objects and gives access to them.
 * 
 * <pre>
 * 
 *  var cache = $cacheFactory('cacheId');
 *  expect($cacheFactory.get('cacheId')).toBe(cache);
 *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();
 *
 *  cache.put("key", "value");
 *  cache.put("another key", "another value");
 *
 *  // We've specified no options on creation
 *  expect(cache.info()).toEqual({id: 'cacheId', size: 2}); 
 * 
 * </pre>
 *
 *
 * @param {string} cacheId Name or id of the newly created cache.
 * @param {object=} options Options object that specifies the cache behavior. Properties:
 *
 *   - `{number=}` `capacity` — turns the cache into LRU cache.
 *
 * @returns {object} Newly created cache object with the following set of methods:
 *
 * - `{object}` `info()` — Returns id, size, and options of cache.
 * - `{{*}}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache and returns
 *   it.
 * - `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.
 * - `{void}` `remove({string} key)` — Removes a key-value pair from the cache.
 * - `{void}` `removeAll()` — Removes all cached values.
 * - `{void}` `destroy()` — Removes references to this cache from $cacheFactory.
 *
 */
function $CacheFactoryProvider() {

  this.$get = function() {
    var caches = {};

    function cacheFactory(cacheId, options) {
      if (cacheId in caches) {
        throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
      }

      var size = 0,
          stats = extend({}, options, {id: cacheId}),
          data = {},
          capacity = (options && options.capacity) || Number.MAX_VALUE,
          lruHash = {},
          freshEnd = null,
          staleEnd = null;

      return caches[cacheId] = {

        put: function(key, value) {
          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

          refresh(lruEntry);

          if (isUndefined(value)) return;
          if (!(key in data)) size++;
          data[key] = value;

          if (size > capacity) {
            this.remove(staleEnd.key);
          }

          return value;
        },


        get: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          refresh(lruEntry);

          return data[key];
        },


        remove: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          if (lruEntry == freshEnd) freshEnd = lruEntry.p;
          if (lruEntry == staleEnd) staleEnd = lruEntry.n;
          link(lruEntry.n,lruEntry.p);

          delete lruHash[key];
          delete data[key];
          size--;
        },


        removeAll: function() {
          data = {};
          size = 0;
          lruHash = {};
          freshEnd = staleEnd = null;
        },


        destroy: function() {
          data = null;
          stats = null;
          lruHash = null;
          delete caches[cacheId];
        },


        info: function() {
          return extend({}, stats, {size: size});
        }
      };


      /**
       * makes the `entry` the freshEnd of the LRU linked list
       */
      function refresh(entry) {
        if (entry != freshEnd) {
          if (!staleEnd) {
            staleEnd = entry;
          } else if (staleEnd == entry) {
            staleEnd = entry.n;
          }

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        }
      }


      /**
       * bidirectionally links two entries of the LRU linked list
       */
      function link(nextEntry, prevEntry) {
        if (nextEntry != prevEntry) {
          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
        }
      }
    }


  /**
   * @ngdoc method
   * @name ng.$cacheFactory#info
   * @methodOf ng.$cacheFactory
   *
   * @description
   * Get information about all the of the caches that have been created
   *
   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`
   */
    cacheFactory.info = function() {
      var info = {};
      forEach(caches, function(cache, cacheId) {
        info[cacheId] = cache.info();
      });
      return info;
    };


  /**
   * @ngdoc method
   * @name ng.$cacheFactory#get
   * @methodOf ng.$cacheFactory
   *
   * @description
   * Get access to a cache object by the `cacheId` used when it was created.
   *
   * @param {string} cacheId Name or id of a cache to access.
   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.
   */
    cacheFactory.get = function(cacheId) {
      return caches[cacheId];
    };


    return cacheFactory;
  };
}

/**
 * @ngdoc object
 * @name ng.$templateCache
 *
 * @description
 * The first time a template is used, it is loaded in the template cache for quick retrieval. You
 * can load templates directly into the cache in a `script` tag, or by consuming the
 * `$templateCache` service directly.
 * 
 * Adding via the `script` tag:
 * <pre>
 * <html ng-app>
 * <head>
 * <script type="text/ng-template" id="templateId.html">
 *   This is the content of the template
 * </script>
 * </head>
 *   ...
 * </html>
 * </pre>
 * 
 * **Note:** the `script` tag containing the template does not need to be included in the `head` of
 * the document, but it must be below the `ng-app` definition.
 * 
 * Adding via the $templateCache service:
 * 
 * <pre>
 * var myApp = angular.module('myApp', []);
 * myApp.run(function($templateCache) {
 *   $templateCache.put('templateId.html', 'This is the content of the template');
 * });
 * </pre>
 * 
 * To retrieve the template later, simply use it in your HTML:
 * <pre>
 * <div ng-include=" 'templateId.html' "></div>
 * </pre>
 * 
 * or get it via Javascript:
 * <pre>
 * $templateCache.get('templateId.html')
 * </pre>
 * 
 * See {@link ng.$cacheFactory $cacheFactory}.
 *
 */
function $TemplateCacheProvider() {
  this.$get = ['$cacheFactory', function($cacheFactory) {
    return $cacheFactory('templates');
  }];
}

/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
 *
 * DOM-related variables:
 *
 * - "node" - DOM Node
 * - "element" - DOM Element or Node
 * - "$node" or "$element" - jqLite-wrapped node or element
 *
 *
 * Compiler related stuff:
 *
 * - "linkFn" - linking fn of a single directive
 * - "nodeLinkFn" - function that aggregates all linking fns for a particular node
 * - "childLinkFn" -  function that aggregates all linking fns for child nodes of a particular node
 * - "compositeLinkFn" - function that aggregates all linking fns for a compilation root (nodeList)
 */


/**
 * @ngdoc function
 * @name ng.$compile
 * @function
 *
 * @description
 * Compiles a piece of HTML string or DOM into a template and produces a template function, which
 * can then be used to link {@link ng.$rootScope.Scope `scope`} and the template together.
 *
 * The compilation is a process of walking the DOM tree and matching DOM elements to
 * {@link ng.$compileProvider#methods_directive directives}.
 *
 * <div class="alert alert-warning">
 * **Note:** This document is an in-depth reference of all directive options.
 * For a gentle introduction to directives with examples of common use cases,
 * see the {@link guide/directive directive guide}.
 * </div>
 *
 * ## Comprehensive Directive API
 *
 * There are many different options for a directive.
 *
 * The difference resides in the return value of the factory function.
 * You can either return a "Directive Definition Object" (see below) that defines the directive properties,
 * or just the `postLink` function (all other properties will have the default values).
 *
 * <div class="alert alert-success">
 * **Best Practice:** It's recommended to use the "directive definition object" form.
 * </div>
 *
 * Here's an example directive declared with a Directive Definition Object:
 *
 * <pre>
 *   var myModule = angular.module(...);
 *
 *   myModule.directive('directiveName', function factory(injectables) {
 *     var directiveDefinitionObject = {
 *       priority: 0,
 *       template: '<div></div>', // or // function(tElement, tAttrs) { ... },
 *       // or
 *       // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
 *       replace: false,
 *       transclude: false,
 *       restrict: 'A',
 *       scope: false,
 *       controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
 *       require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
 *       compile: function compile(tElement, tAttrs, transclude) {
 *         return {
 *           pre: function preLink(scope, iElement, iAttrs, controller) { ... },
 *           post: function postLink(scope, iElement, iAttrs, controller) { ... }
 *         }
 *         // or
 *         // return function postLink( ... ) { ... }
 *       },
 *       // or
 *       // link: {
 *       //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
 *       //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
 *       // }
 *       // or
 *       // link: function postLink( ... ) { ... }
 *     };
 *     return directiveDefinitionObject;
 *   });
 * </pre>
 *
 * <div class="alert alert-warning">
 * **Note:** Any unspecified options will use the default value. You can see the default values below.
 * </div>
 *
 * Therefore the above can be simplified as:
 *
 * <pre>
 *   var myModule = angular.module(...);
 *
 *   myModule.directive('directiveName', function factory(injectables) {
 *     var directiveDefinitionObject = {
 *       link: function postLink(scope, iElement, iAttrs) { ... }
 *     };
 *     return directiveDefinitionObject;
 *     // or
 *     // return function postLink(scope, iElement, iAttrs) { ... }
 *   });
 * </pre>
 *
 *
 *
 * ### Directive Definition Object
 *
 * The directive definition object provides instructions to the {@link api/ng.$compile
 * compiler}. The attributes are:
 *
 * #### `priority`
 * When there are multiple directives defined on a single DOM element, sometimes it
 * is necessary to specify the order in which the directives are applied. The `priority` is used
 * to sort the directives before their `compile` functions get called. Priority is defined as a
 * number. Directives with greater numerical `priority` are compiled first. Pre-link functions
 * are also run in priority order, but post-link functions are run in reverse order. The order
 * of directives with the same priority is undefined. The default priority is `0`.
 *
 * #### `terminal`
 * If set to true then the current `priority` will be the last set of directives
 * which will execute (any directives at the current priority will still execute
 * as the order of execution on same `priority` is undefined).
 *
 * #### `scope`
 * **If set to `true`,** then a new scope will be created for this directive. If multiple directives on the
 * same element request a new scope, only one new scope is created. The new scope rule does not
 * apply for the root of the template since the root of the template always gets a new scope.
 *
 * **If set to `{}` (object hash),** then a new "isolate" scope is created. The 'isolate' scope differs from
 * normal scope in that it does not prototypically inherit from the parent scope. This is useful
 * when creating reusable components, which should not accidentally read or modify data in the
 * parent scope.
 *
 * The 'isolate' scope takes an object hash which defines a set of local scope properties
 * derived from the parent scope. These local properties are useful for aliasing values for
 * templates. Locals definition is a hash of local scope property to its source:
 *
 * * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is
 *   always a string since DOM attributes are strings. If no `attr` name is specified  then the
 *   attribute name is assumed to be the same as the local name.
 *   Given `<widget my-attr="hello {{name}}">` and widget definition
 *   of `scope: { localName:'@myAttr' }`, then widget scope property `localName` will reflect
 *   the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the
 *   `localName` property on the widget scope. The `name` is read from the parent scope (not
 *   component scope).
 *
 * * `=` or `=attr` - set up bi-directional binding between a local scope property and the
 *   parent scope property of name defined via the value of the `attr` attribute. If no `attr`
 *   name is specified then the attribute name is assumed to be the same as the local name.
 *   Given `<widget my-attr="parentModel">` and widget definition of
 *   `scope: { localModel:'=myAttr' }`, then widget scope property `localModel` will reflect the
 *   value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected
 *   in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent
 *   scope property doesn't exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You
 *   can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional.
 *
 * * `&` or `&attr` - provides a way to execute an expression in the context of the parent scope.
 *   If no `attr` name is specified then the attribute name is assumed to be the same as the
 *   local name. Given `<widget my-attr="count = count + value">` and widget definition of
 *   `scope: { localFn:'&myAttr' }`, then isolate scope property `localFn` will point to
 *   a function wrapper for the `count = count + value` expression. Often it's desirable to
 *   pass data from the isolated scope via an expression and to the parent scope, this can be
 *   done by passing a map of local variable names and values into the expression wrapper fn.
 *   For example, if the expression is `increment(amount)` then we can specify the amount value
 *   by calling the `localFn` as `localFn({amount: 22})`.
 *
 *
 *
 * #### `controller`
 * Controller constructor function. The controller is instantiated before the
 * pre-linking phase and it is shared with other directives (see
 * `require` attribute). This allows the directives to communicate with each other and augment
 * each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:
 *
 * * `$scope` - Current scope associated with the element
 * * `$element` - Current element
 * * `$attrs` - Current attributes object for the element
 * * `$transclude` - A transclude linking function pre-bound to the correct transclusion scope.
 *    The scope can be overridden by an optional first argument.
 *   `function([scope], cloneLinkingFn)`.
 *
 *
 * #### `require`
 * Require another directive and inject its controller as the fourth argument to the linking function. The
 * `require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the
 * injected argument will be an array in corresponding order. If no such directive can be
 * found, or if the directive does not have a controller, then an error is raised. The name can be prefixed with:
 *
 * * (no prefix) - Locate the required controller on the current element. Throw an error if not found.
 * * `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.
 * * `^` - Locate the required controller by searching the element's parents. Throw an error if not found.
 * * `?^` - Attempt to locate the required controller by searching the element's parents or pass `null` to the
 *   `link` fn if not found.
 *
 *
 * #### `controllerAs`
 * Controller alias at the directive scope. An alias for the controller so it
 * can be referenced at the directive template. The directive needs to define a scope for this
 * configuration to be used. Useful in the case when directive is used as component.
 *
 *
 * #### `restrict`
 * String of subset of `EACM` which restricts the directive to a specific directive
 * declaration style. If omitted, the default (attributes only) is used.
 *
 * * `E` - Element name: `<my-directive></my-directive>`
 * * `A` - Attribute (default): `<div my-directive="exp"></div>`
 * * `C` - Class: `<div class="my-directive: exp;"></div>`
 * * `M` - Comment: `<!-- directive: my-directive exp -->`
 *
 *
 * #### `template`
 * replace the current element with the contents of the HTML. The replacement process
 * migrates all of the attributes / classes from the old element to the new one. See the
 * {@link guide/directive#creating-custom-directives_creating-directives_template-expanding-directive
 * Directives Guide} for an example.
 *
 * You can specify `template` as a string representing the template or as a function which takes
 * two arguments `tElement` and `tAttrs` (described in the `compile` function api below) and
 * returns a string value representing the template.
 *
 *
 * #### `templateUrl`
 * Same as `template` but the template is loaded from the specified URL. Because
 * the template loading is asynchronous the compilation/linking is suspended until the template
 * is loaded.
 *
 * You can specify `templateUrl` as a string representing the URL or as a function which takes two
 * arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns
 * a string value representing the url.  In either case, the template URL is passed through {@link
 * api/ng.$sce#methods_getTrustedResourceUrl $sce.getTrustedResourceUrl}.
 *
 *
 * #### `replace`
 * specify where the template should be inserted. Defaults to `false`.
 *
 * * `true` - the template will replace the current element.
 * * `false` - the template will replace the contents of the current element.
 *
 *
 * #### `transclude`
 * compile the content of the element and make it available to the directive.
 * Typically used with {@link api/ng.directive:ngTransclude
 * ngTransclude}. The advantage of transclusion is that the linking function receives a
 * transclusion function which is pre-bound to the correct scope. In a typical setup the widget
 * creates an `isolate` scope, but the transclusion is not a child, but a sibling of the `isolate`
 * scope. This makes it possible for the widget to have private state, and the transclusion to
 * be bound to the parent (pre-`isolate`) scope.
 *
 * * `true` - transclude the content of the directive.
 * * `'element'` - transclude the whole element including any directives defined at lower priority.
 *
 *
 * #### `compile`
 *
 * <pre>
 *   function compile(tElement, tAttrs, transclude) { ... }
 * </pre>
 *
 * The compile function deals with transforming the template DOM. Since most directives do not do
 * template transformation, it is not used often. Examples that require compile functions are
 * directives that transform template DOM, such as {@link
 * api/ng.directive:ngRepeat ngRepeat}, or load the contents
 * asynchronously, such as {@link api/ngRoute.directive:ngView ngView}. The
 * compile function takes the following arguments.
 *
 *   * `tElement` - template element - The element where the directive has been declared. It is
 *     safe to do template transformation on the element and child elements only.
 *
 *   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared
 *     between all directive compile functions.
 *
 *   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`
 *
 * <div class="alert alert-warning">
 * **Note:** The template instance and the link instance may be different objects if the template has
 * been cloned. For this reason it is **not** safe to do anything other than DOM transformations that
 * apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration
 * should be done in a linking function rather than in a compile function.
 * </div>
 *
 * <div class="alert alert-error">
 * **Note:** The `transclude` function that is passed to the compile function is deprecated, as it
 *   e.g. does not know about the right outer scope. Please use the transclude function that is passed
 *   to the link function instead.
 * </div>

 * A compile function can have a return value which can be either a function or an object.
 *
 * * returning a (post-link) function - is equivalent to registering the linking function via the
 *   `link` property of the config object when the compile function is empty.
 *
 * * returning an object with function(s) registered via `pre` and `post` properties - allows you to
 *   control when a linking function should be called during the linking phase. See info about
 *   pre-linking and post-linking functions below.
 *
 *
 * #### `link`
 * This property is used only if the `compile` property is not defined.
 *
 * <pre>
 *   function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }
 * </pre>
 *
 * The link function is responsible for registering DOM listeners as well as updating the DOM. It is
 * executed after the template has been cloned. This is where most of the directive logic will be
 * put.
 *
 *   * `scope` - {@link api/ng.$rootScope.Scope Scope} - The scope to be used by the
 *     directive for registering {@link api/ng.$rootScope.Scope#methods_$watch watches}.
 *
 *   * `iElement` - instance element - The element where the directive is to be used. It is safe to
 *     manipulate the children of the element only in `postLink` function since the children have
 *     already been linked.
 *
 *   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared
 *     between all directive linking functions.
 *
 *   * `controller` - a controller instance - A controller instance if at least one directive on the
 *     element defines a controller. The controller is shared among all the directives, which allows
 *     the directives to use the controllers as a communication channel.
 *
 *   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.
 *     The scope can be overridden by an optional first argument. This is the same as the `$transclude`
 *     parameter of directive controllers.
 *     `function([scope], cloneLinkingFn)`.
 *
 *
 * #### Pre-linking function
 *
 * Executed before the child elements are linked. Not safe to do DOM transformation since the
 * compiler linking function will fail to locate the correct elements for linking.
 *
 * #### Post-linking function
 *
 * Executed after the child elements are linked. It is safe to do DOM transformation in the post-linking function.
 *
 * <a name="Attributes"></a>
 * ### Attributes
 *
 * The {@link api/ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the
 * `link()` or `compile()` functions. It has a variety of uses.
 *
 * accessing *Normalized attribute names:*
 * Directives like 'ngBind' can be expressed in many ways: 'ng:bind', `data-ng-bind`, or 'x-ng-bind'.
 * the attributes object allows for normalized access to
 *   the attributes.
 *
 * * *Directive inter-communication:* All directives share the same instance of the attributes
 *   object which allows the directives to use the attributes object as inter directive
 *   communication.
 *
 * * *Supports interpolation:* Interpolation attributes are assigned to the attribute object
 *   allowing other directives to read the interpolated value.
 *
 * * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes
 *   that contain interpolation (e.g. `src="{{bar}}"`). Not only is this very efficient but it's also
 *   the only way to easily get the actual value because during the linking phase the interpolation
 *   hasn't been evaluated yet and so the value is at this time set to `undefined`.
 *
 * <pre>
 * function linkingFn(scope, elm, attrs, ctrl) {
 *   // get the attribute value
 *   console.log(attrs.ngModel);
 *
 *   // change the attribute
 *   attrs.$set('ngModel', 'new value');
 *
 *   // observe changes to interpolated attribute
 *   attrs.$observe('ngModel', function(value) {
 *     console.log('ngModel has changed value to ' + value);
 *   });
 * }
 * </pre>
 *
 * Below is an example using `$compileProvider`.
 *
 * <div class="alert alert-warning">
 * **Note**: Typically directives are registered with `module.directive`. The example below is
 * to illustrate how `$compile` works.
 * </div>
 *
 <doc:example module="compile">
   <doc:source>
    <script>
      angular.module('compile', [], function($compileProvider) {
        // configure new 'compile' directive by passing a directive
        // factory function. The factory function injects the '$compile'
        $compileProvider.directive('compile', function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the 'compile' expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the 'compile' expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don't get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        })
      });

      function Ctrl($scope) {
        $scope.name = 'Angular';
        $scope.html = 'Hello {{name}}';
      }
    </script>
    <div ng-controller="Ctrl">
      <input ng-model="name"> <br>
      <textarea ng-model="html"></textarea> <br>
      <div compile="html"></div>
    </div>
   </doc:source>
   <doc:scenario>
     it('should auto compile', function() {
       expect(element('div[compile]').text()).toBe('Hello Angular');
       input('html').enter('{{name}}!');
       expect(element('div[compile]').text()).toBe('Angular!');
     });
   </doc:scenario>
 </doc:example>

 *
 *
 * @param {string|DOMElement} element Element or HTML string to compile into a template function.
 * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.
 * @param {number} maxPriority only apply directives lower then given priority (Only effects the
 *                 root element(s), not their children)
 * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template
 * (a DOM element/tree) to a scope. Where:
 *
 *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.
 *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
 *  `template` and call the `cloneAttachFn` function allowing the caller to attach the
 *  cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
 *  called as: <br> `cloneAttachFn(clonedElement, scope)` where:
 *
 *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
 *      * `scope` - is the current scope with which the linking function is working with.
 *
 * Calling the linking function returns the element of the template. It is either the original
 * element passed in, or the clone of the element if the `cloneAttachFn` is provided.
 *
 * After linking the view is not updated until after a call to $digest which typically is done by
 * Angular automatically.
 *
 * If you need access to the bound view, there are two ways to do it:
 *
 * - If you are not asking the linking function to clone the template, create the DOM element(s)
 *   before you send them to the compiler and keep this reference around.
 *   <pre>
 *     var element = $compile('<p>{{total}}</p>')(scope);
 *   </pre>
 *
 * - if on the other hand, you need the element to be cloned, the view reference from the original
 *   example would not point to the clone, but rather to the original template that was cloned. In
 *   this case, you can access the clone via the cloneAttachFn:
 *   <pre>
 *     var templateElement = angular.element('<p>{{total}}</p>'),
 *         scope = ....;
 *
 *     var clonedElement = $compile(templateElement)(scope, function(clonedElement, scope) {
 *       //attach the clone to DOM document at the right place
 *     });
 *
 *     //now we have reference to the cloned DOM via `clonedElement`
 *   </pre>
 *
 *
 * For information on how the compiler works, see the
 * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
 */

var $compileMinErr = minErr('$compile');

/**
 * @ngdoc service
 * @name ng.$compileProvider
 * @function
 *
 * @description
 */
$CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
function $CompileProvider($provide, $$sanitizeUriProvider) {
  var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;

  /**
   * @ngdoc function
   * @name ng.$compileProvider#directive
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Register a new directive with the compiler.
   *
   * @param {string|Object} name Name of the directive in camel-case (i.e. <code>ngBind</code> which
   *    will match as <code>ng-bind</code>), or an object map of directives where the keys are the
   *    names and the values are the factories.
   * @param {function|Array} directiveFactory An injectable directive factory function. See
   *    {@link guide/directive} for more info.
   * @returns {ng.$compileProvider} Self for chaining.
   */
   this.directive = function registerDirective(name, directiveFactory) {
    assertNotHasOwnProperty(name, 'directive');
    if (isString(name)) {
      assertArg(directiveFactory, 'directiveFactory');
      if (!hasDirectives.hasOwnProperty(name)) {
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
          function($injector, $exceptionHandler) {
            var directives = [];
            forEach(hasDirectives[name], function(directiveFactory, index) {
              try {
                var directive = $injector.invoke(directiveFactory);
                if (isFunction(directive)) {
                  directive = { compile: valueFn(directive) };
                } else if (!directive.compile && directive.link) {
                  directive.compile = valueFn(directive.link);
                }
                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller && directive.name);
                directive.restrict = directive.restrict || 'A';
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          }]);
      }
      hasDirectives[name].push(directiveFactory);
    } else {
      forEach(name, reverseParams(registerDirective));
    }
    return this;
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#aHrefSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.aHrefSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
      return this;
    } else {
      return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
    }
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#imgSrcSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during img[src] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.imgSrcSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
      return this;
    } else {
      return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
    }
  };

  this.$get = [
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',
            '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri',
    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
             $controller,   $rootScope,   $document,   $sce,   $animate,   $$sanitizeUri) {

    var Attributes = function(element, attr) {
      this.$$element = element;
      this.$attr = attr || {};
    };

    Attributes.prototype = {
      $normalize: directiveNormalize,


      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$addClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Adds the CSS class value specified by the classVal parameter to the element. If animations
       * are enabled then an animation will be triggered for the class addition.
       *
       * @param {string} classVal The className value that will be added to the element
       */
      $addClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.addClass(this.$$element, classVal);
        }
      },

      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$removeClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Removes the CSS class value specified by the classVal parameter from the element. If
       * animations are enabled then an animation will be triggered for the class removal.
       *
       * @param {string} classVal The className value that will be removed from the element
       */
      $removeClass : function(classVal) {
        if(classVal && classVal.length > 0) {
          $animate.removeClass(this.$$element, classVal);
        }
      },

      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$updateClass
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Adds and removes the appropriate CSS class values to the element based on the difference
       * between the new and old CSS class values (specified as newClasses and oldClasses).
       *
       * @param {string} newClasses The current CSS className value
       * @param {string} oldClasses The former CSS className value
       */
      $updateClass : function(newClasses, oldClasses) {
        this.$removeClass(tokenDifference(oldClasses, newClasses));
        this.$addClass(tokenDifference(newClasses, oldClasses));
      },

      /**
       * Set a normalized attribute on the element in a way such that all directives
       * can share the attribute. This function properly handles boolean attributes.
       * @param {string} key Normalized key. (ie ngAttribute)
       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
       *     Defaults to true.
       * @param {string=} attrName Optional none normalized name. Defaults to key.
       */
      $set: function(key, value, writeAttr, attrName) {
        // TODO: decide whether or not to throw an error if "class"
        //is set through this function since it may cause $updateClass to
        //become unstable.

        var booleanKey = getBooleanAttrName(this.$$element[0], key),
            normalizedVal,
            nodeName;

        if (booleanKey) {
          this.$$element.prop(key, value);
          attrName = booleanKey;
        }

        this[key] = value;

        // translate normalized key to actual key
        if (attrName) {
          this.$attr[key] = attrName;
        } else {
          attrName = this.$attr[key];
          if (!attrName) {
            this.$attr[key] = attrName = snake_case(key, '-');
          }
        }

        nodeName = nodeName_(this.$$element);

        // sanitize a[href] and img[src] values
        if ((nodeName === 'A' && key === 'href') ||
            (nodeName === 'IMG' && key === 'src')) {
          this[key] = value = $$sanitizeUri(value, key === 'src');
        }

        if (writeAttr !== false) {
          if (value === null || value === undefined) {
            this.$$element.removeAttr(attrName);
          } else {
            this.$$element.attr(attrName, value);
          }
        }

        // fire observers
        var $$observers = this.$$observers;
        $$observers && forEach($$observers[key], function(fn) {
          try {
            fn(value);
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      },


      /**
       * @ngdoc function
       * @name ng.$compile.directive.Attributes#$observe
       * @methodOf ng.$compile.directive.Attributes
       * @function
       *
       * @description
       * Observes an interpolated attribute.
       *
       * The observer function will be invoked once during the next `$digest` following
       * compilation. The observer is then invoked whenever the interpolated value
       * changes.
       *
       * @param {string} key Normalized key. (ie ngAttribute) .
       * @param {function(interpolatedValue)} fn Function that will be called whenever
                the interpolated value of the attribute changes.
       *        See the {@link guide/directive#Attributes Directives} guide for more info.
       * @returns {function()} the `fn` parameter.
       */
      $observe: function(key, fn) {
        var attrs = this,
            $$observers = (attrs.$$observers || (attrs.$$observers = {})),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(function() {
          if (!listeners.$$inter) {
            // no one registered attribute interpolation function, so lets call it manually
            fn(attrs[key]);
          }
        });
        return fn;
      }
    };

    var startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')
            ? identity
            : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
        },
        NG_ATTR_BINDING = /^ngAttr[A-Z]/;


    return compile;

    //================================

    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective,
                        previousCompileContext) {
      if (!($compileNodes instanceof jqLite)) {
        // jquery always rewraps, whereas we need to preserve the original selector so that we can
        // modify it.
        $compileNodes = jqLite($compileNodes);
      }
      // We can not compile top level text elements since text nodes can be merged and we will
      // not be able to attach scope data to them, so we will wrap them in <span>
      forEach($compileNodes, function(node, index){
        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\S+/) /* non-empty */ ) {
          $compileNodes[index] = node = jqLite(node).wrap('<span></span>').parent()[0];
        }
      });
      var compositeLinkFn =
              compileNodes($compileNodes, transcludeFn, $compileNodes,
                           maxPriority, ignoreDirective, previousCompileContext);
      safeAddClass($compileNodes, 'ng-scope');
      return function publicLinkFn(scope, cloneConnectFn, transcludeControllers){
        assertArg(scope, 'scope');
        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
        // and sometimes changes the structure of the DOM.
        var $linkNode = cloneConnectFn
          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!
          : $compileNodes;

        forEach(transcludeControllers, function(instance, name) {
          $linkNode.data('$' + name + 'Controller', instance);
        });

        // Attach scope only to non-text nodes.
        for(var i = 0, ii = $linkNode.length; i<ii; i++) {
          var node = $linkNode[i],
              nodeType = node.nodeType;
          if (nodeType === 1 /* element */ || nodeType === 9 /* document */) {
            $linkNode.eq(i).data('$scope', scope);
          }
        }

        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
        return $linkNode;
      };
    }

    function safeAddClass($element, className) {
      try {
        $element.addClass(className);
      } catch(e) {
        // ignore, since it means that we are trying to set class on
        // SVG element, where class name is read-only.
      }
    }

    /**
     * Compile function matches each node in nodeList against the directives. Once all directives
     * for a particular node are collected their compile functions are executed. The compile
     * functions return values - the linking functions - are combined into a composite linking
     * function, which is the a linking function for the node.
     *
     * @param {NodeList} nodeList an array of nodes or NodeList to compile
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then
     *        the rootElement must be set the jqLite collection of the compile root. This is
     *        needed so that the jqLite collection items can be replaced with widgets.
     * @param {number=} maxPriority Max directive priority.
     * @returns {?function} A composite linking function of all of the matched directives or null.
     */
    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective,
                            previousCompileContext) {
      var linkFns = [],
          attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound;

      for (var i = 0; i < nodeList.length; i++) {
        attrs = new Attributes();

        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
        directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined,
                                        ignoreDirective);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement,
                                      null, [], [], previousCompileContext)
            : null;

        if (nodeLinkFn && nodeLinkFn.scope) {
          safeAddClass(jqLite(nodeList[i]), 'ng-scope');
        }

        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal ||
                      !(childNodes = nodeList[i].childNodes) ||
                      !childNodes.length)
            ? null
            : compileNodes(childNodes,
                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

        linkFns.push(nodeLinkFn, childLinkFn);
        linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
        //use the previous context only for the first element in the virtual group
        previousCompileContext = null;
      }

      // return a linking function if we have found anything, null otherwise
      return linkFnFound ? compositeLinkFn : null;

      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
        var nodeLinkFn, childLinkFn, node, $node, childScope, childTranscludeFn, i, ii, n;

        // copy nodeList so that linking doesn't break due to live list updates.
        var nodeListLength = nodeList.length,
            stableNodeList = new Array(nodeListLength);
        for (i = 0; i < nodeListLength; i++) {
          stableNodeList[i] = nodeList[i];
        }

        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
          node = stableNodeList[n];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];
          $node = jqLite(node);

          if (nodeLinkFn) {
            if (nodeLinkFn.scope) {
              childScope = scope.$new();
              $node.data('$scope', childScope);
            } else {
              childScope = scope;
            }
            childTranscludeFn = nodeLinkFn.transclude;
            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                createBoundTranscludeFn(scope, childTranscludeFn || transcludeFn)
              );
            } else {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement, boundTranscludeFn);
            }
          } else if (childLinkFn) {
            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
          }
        }
      }
    }

    function createBoundTranscludeFn(scope, transcludeFn) {
      return function boundTranscludeFn(transcludedScope, cloneFn, controllers) {
        var scopeCreated = false;

        if (!transcludedScope) {
          transcludedScope = scope.$new();
          transcludedScope.$$transcluded = true;
          scopeCreated = true;
        }

        var clone = transcludeFn(transcludedScope, cloneFn, controllers);
        if (scopeCreated) {
          clone.on('$destroy', bind(transcludedScope, transcludedScope.$destroy));
        }
        return clone;
      };
    }

    /**
     * Looks for directives on the given node and adds them to the directive collection which is
     * sorted.
     *
     * @param node Node to search.
     * @param directives An array to which the directives are added to. This array is sorted before
     *        the function returns.
     * @param attrs The shared attrs object which is used to populate the normalized attributes.
     * @param {number=} maxPriority Max directive priority.
     */
    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      switch(nodeType) {
        case 1: /* Element */
          // use the node name: <directive>
          addDirective(directives,
              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority, ignoreDirective);

          // iterate over the attributes
          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
            var attrStartName = false;
            var attrEndName = false;

            attr = nAttrs[j];
            if (!msie || msie >= 8 || attr.specified) {
              name = attr.name;
              // support ngAttr attribute binding
              ngAttrName = directiveNormalize(name);
              if (NG_ATTR_BINDING.test(ngAttrName)) {
                name = snake_case(ngAttrName.substr(6), '-');
              }

              var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
              if (ngAttrName === directiveNName + 'Start') {
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + 'end';
                name = name.substr(0, name.length - 6);
              }

              nName = directiveNormalize(name.toLowerCase());
              attrsMap[nName] = name;
              attrs[nName] = value = trim(attr.value);
              if (getBooleanAttrName(node, nName)) {
                attrs[nName] = true; // presence means true
              }
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName,
                            attrEndName);
            }
          }

          // use class as directive
          className = node.className;
          if (isString(className) && className !== '') {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;
        case 3: /* Text Node */
          addTextInterpolateDirective(directives, node.nodeValue);
          break;
        case 8: /* Comment */
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {
            // turns out that under some circumstances IE9 throws errors when one attempts to read
            // comment's node value.
            // Just ignore it and continue. (Can't seem to reproduce in test case.)
          }
          break;
      }

      directives.sort(byPriority);
      return directives;
    }

    /**
     * Given a node with an directive-start it collects all of the siblings until it finds
     * directive-end.
     * @param node
     * @param attrStart
     * @param attrEnd
     * @returns {*}
     */
    function groupScan(node, attrStart, attrEnd) {
      var nodes = [];
      var depth = 0;
      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
        var startNode = node;
        do {
          if (!node) {
            throw $compileMinErr('uterdir',
                      "Unterminated attribute, found '{0}' but no matching '{1}' found.",
                      attrStart, attrEnd);
          }
          if (node.nodeType == 1 /** Element **/) {
            if (node.hasAttribute(attrStart)) depth++;
            if (node.hasAttribute(attrEnd)) depth--;
          }
          nodes.push(node);
          node = node.nextSibling;
        } while (depth > 0);
      } else {
        nodes.push(node);
      }

      return jqLite(nodes);
    }

    /**
     * Wrapper for linking function which converts normal linking function into a grouped
     * linking function.
     * @param linkFn
     * @param attrStart
     * @param attrEnd
     * @returns {Function}
     */
    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
      return function(scope, element, attrs, controllers, transcludeFn) {
        element = groupScan(element[0], attrStart, attrEnd);
        return linkFn(scope, element, attrs, controllers, transcludeFn);
      };
    }

    /**
     * Once the directives have been collected, their compile functions are executed. This method
     * is responsible for inlining directive templates as well as terminating the application
     * of the directives if the terminal directive has been reached.
     *
     * @param {Array} directives Array of collected directives to execute their compile function.
     *        this needs to be pre-sorted by priority order.
     * @param {Node} compileNode The raw DOM node to apply the compile functions to
     * @param {Object} templateAttrs The shared attribute function
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *                                                  scope argument is auto-generated to the new
     *                                                  child of the transcluded parent scope.
     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
     *                              argument has the root jqLite array so that we can replace nodes
     *                              on it.
     * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
     *                                           compiling the transclusion.
     * @param {Array.<Function>} preLinkFns
     * @param {Array.<Function>} postLinkFns
     * @param {Object} previousCompileContext Context used for previous compilation of the current
     *                                        node
     * @returns linkFn
     */
    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn,
                                   jqCollection, originalReplaceDirective, preLinkFns, postLinkFns,
                                   previousCompileContext) {
      previousCompileContext = previousCompileContext || {};

      var terminalPriority = -Number.MAX_VALUE,
          newScopeDirective,
          controllerDirectives = previousCompileContext.controllerDirectives,
          newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
          templateDirective = previousCompileContext.templateDirective,
          nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
          hasTranscludeDirective = false,
          hasElementTranscludeDirective = false,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          replaceDirective = originalReplaceDirective,
          childTranscludeFn = transcludeFn,
          linkFn,
          directiveValue;

      // executes all directives on the current element
      for(var i = 0, ii = directives.length; i < ii; i++) {
        directive = directives[i];
        var attrStart = directive.$$start;
        var attrEnd = directive.$$end;

        // collect multiblock sections
        if (attrStart) {
          $compileNode = groupScan(compileNode, attrStart, attrEnd);
        }
        $template = undefined;

        if (terminalPriority > directive.priority) {
          break; // prevent further processing of directives
        }

        if (directiveValue = directive.scope) {
          newScopeDirective = newScopeDirective || directive;

          // skip the check for directives with async templates, we'll check the derived sync
          // directive when the template arrives
          if (!directive.templateUrl) {
            assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive,
                              $compileNode);
            if (isObject(directiveValue)) {
              newIsolateScopeDirective = directive;
            }
          }
        }

        directiveName = directive.name;

        if (!directive.templateUrl && directive.controller) {
          directiveValue = directive.controller;
          controllerDirectives = controllerDirectives || {};
          assertNoDuplicate("'" + directiveName + "' controller",
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        }

        if (directiveValue = directive.transclude) {
          hasTranscludeDirective = true;

          // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
          // This option should only be used by directives that know how to how to safely handle element transclusion,
          // where the transcluded nodes are added or replaced after linking.
          if (!directive.$$tlb) {
            assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
            nonTlbTranscludeDirective = directive;
          }

          if (directiveValue == 'element') {
            hasElementTranscludeDirective = true;
            terminalPriority = directive.priority;
            $template = groupScan(compileNode, attrStart, attrEnd);
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(' ' + directiveName + ': ' +
                                              templateAttrs[directiveName] + ' '));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode);

            childTranscludeFn = compile($template, transcludeFn, terminalPriority,
                                        replaceDirective && replaceDirective.name, {
                                          // Don't pass in:
                                          // - controllerDirectives - otherwise we'll create duplicates controllers
                                          // - newIsolateScopeDirective or templateDirective - combining templates with
                                          //   element transclusion doesn't make sense.
                                          //
                                          // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
                                          // on the same element more than once.
                                          nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                        });
          } else {
            $template = jqLite(jqLiteClone(compileNode)).contents();
            $compileNode.empty(); // clear contents
            childTranscludeFn = compile($template, transcludeFn);
          }
        }

        if (directive.template) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          if (directive.replace) {
            replaceDirective = directive;
            $template = jqLite('<div>' +
                                 trim(directiveValue) +
                               '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt',
                  "Template for directive '{0}' must have exactly one root element. {1}",
                  directiveName, '');
            }

            replaceWith(jqCollection, $compileNode, compileNode);

            var newTemplateAttrs = {$attr: {}};

            // combine directives from the original node and from the template:
            // - take the array of directives for this element
            // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
            // - collect directives from the template and sort them by priority
            // - combine directives as: processed + template + unprocessed
            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));

            if (newIsolateScopeDirective) {
              markDirectivesAsIsolate(templateDirectives);
            }
            directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          } else {
            $compileNode.html(directiveValue);
          }
        }

        if (directive.templateUrl) {
          assertNoDuplicate('template', templateDirective, directive, $compileNode);
          templateDirective = directive;

          if (directive.replace) {
            replaceDirective = directive;
          }

          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode,
              templateAttrs, jqCollection, childTranscludeFn, preLinkFns, postLinkFns, {
                controllerDirectives: controllerDirectives,
                newIsolateScopeDirective: newIsolateScopeDirective,
                templateDirective: templateDirective,
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              });
          ii = directives.length;
        } else if (directive.compile) {
          try {
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            if (isFunction(linkFn)) {
              addLinkFns(null, linkFn, attrStart, attrEnd);
            } else if (linkFn) {
              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
            }
          } catch (e) {
            $exceptionHandler(e, startingTag($compileNode));
          }
        }

        if (directive.terminal) {
          nodeLinkFn.terminal = true;
          terminalPriority = Math.max(terminalPriority, directive.priority);
        }

      }

      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
      nodeLinkFn.transclude = hasTranscludeDirective && childTranscludeFn;

      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
      return nodeLinkFn;

      ////////////////////

      function addLinkFns(pre, post, attrStart, attrEnd) {
        if (pre) {
          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
          pre.require = directive.require;
          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
            pre = cloneAndAnnotateFn(pre, {isolateScope: true});
          }
          preLinkFns.push(pre);
        }
        if (post) {
          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
          post.require = directive.require;
          if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
            post = cloneAndAnnotateFn(post, {isolateScope: true});
          }
          postLinkFns.push(post);
        }
      }


      function getControllers(require, $element, elementControllers) {
        var value, retrievalMethod = 'data', optional = false;
        if (isString(require)) {
          while((value = require.charAt(0)) == '^' || value == '?') {
            require = require.substr(1);
            if (value == '^') {
              retrievalMethod = 'inheritedData';
            }
            optional = optional || value == '?';
          }
          value = null;

          if (elementControllers && retrievalMethod === 'data') {
            value = elementControllers[require];
          }
          value = value || $element[retrievalMethod]('$' + require + 'Controller');

          if (!value && !optional) {
            throw $compileMinErr('ctreq',
                "Controller '{0}', required by directive '{1}', can't be found!",
                require, directiveName);
          }
          return value;
        } else if (isArray(require)) {
          value = [];
          forEach(require, function(require) {
            value.push(getControllers(require, $element, elementControllers));
          });
        }
        return value;
      }


      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
        var attrs, $element, i, ii, linkFn, controller, isolateScope, elementControllers = {}, transcludeFn;

        if (compileNode === linkNode) {
          attrs = templateAttrs;
        } else {
          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
        }
        $element = attrs.$$element;

        if (newIsolateScopeDirective) {
          var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
          var $linkNode = jqLite(linkNode);

          isolateScope = scope.$new(true);

          if (templateDirective && (templateDirective === newIsolateScopeDirective.$$originalDirective)) {
            $linkNode.data('$isolateScope', isolateScope) ;
          } else {
            $linkNode.data('$isolateScopeNoTemplate', isolateScope);
          }



          safeAddClass($linkNode, 'ng-isolate-scope');

          forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
            var match = definition.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                optional = (match[2] == '?'),
                mode = match[1], // @, =, or &
                lastValue,
                parentGet, parentSet, compare;

            isolateScope.$$isolateBindings[scopeName] = mode + attrName;

            switch (mode) {

              case '@':
                attrs.$observe(attrName, function(value) {
                  isolateScope[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = scope;
                if( attrs[attrName] ) {
                  // If the attribute has been provided then we trigger an interpolation to ensure
                  // the value is there for use in the link fn
                  isolateScope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;

              case '=':
                if (optional && !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function(a,b) { return a === b; };
                }
                parentSet = parentGet.assign || function() {
                  // reset the change, or we will throw this exception on every $digest
                  lastValue = isolateScope[scopeName] = parentGet(scope);
                  throw $compileMinErr('nonassign',
                      "Expression '{0}' used with directive '{1}' is non-assignable!",
                      attrs[attrName], newIsolateScopeDirective.name);
                };
                lastValue = isolateScope[scopeName] = parentGet(scope);
                isolateScope.$watch(function parentValueWatch() {
                  var parentValue = parentGet(scope);
                  if (!compare(parentValue, isolateScope[scopeName])) {
                    // we are out of sync and need to copy
                    if (!compare(parentValue, lastValue)) {
                      // parent changed and it has precedence
                      isolateScope[scopeName] = parentValue;
                    } else {
                      // if the parent can be assigned then do so
                      parentSet(scope, parentValue = isolateScope[scopeName]);
                    }
                  }
                  return lastValue = parentValue;
                }, null, parentGet.literal);
                break;

              case '&':
                parentGet = $parse(attrs[attrName]);
                isolateScope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;

              default:
                throw $compileMinErr('iscp',
                    "Invalid isolate scope definition for directive '{0}'." +
                    " Definition: {... {1}: '{2}' ...}",
                    newIsolateScopeDirective.name, scopeName, definition);
            }
          });
        }
        transcludeFn = boundTranscludeFn && controllersBoundTransclude;
        if (controllerDirectives) {
          forEach(controllerDirectives, function(directive) {
            var locals = {
              $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
              $element: $element,
              $attrs: attrs,
              $transclude: transcludeFn
            }, controllerInstance;

            controller = directive.controller;
            if (controller == '@') {
              controller = attrs[directive.name];
            }

            controllerInstance = $controller(controller, locals);
            // For directives with element transclusion the element is a comment,
            // but jQuery .data doesn't support attaching data to comment nodes as it's hard to
            // clean up (http://bugs.jquery.com/ticket/8335).
            // Instead, we save the controllers for the element in a local hash and attach to .data
            // later, once we have the actual element.
            elementControllers[directive.name] = controllerInstance;
            if (!hasElementTranscludeDirective) {
              $element.data('$' + directive.name + 'Controller', controllerInstance);
            }

            if (directive.controllerAs) {
              locals.$scope[directive.controllerAs] = controllerInstance;
            }
          });
        }

        // PRELINKING
        for(i = 0, ii = preLinkFns.length; i < ii; i++) {
          try {
            linkFn = preLinkFns[i];
            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // RECURSION
        // We only pass the isolate scope, if the isolate directive has a template,
        // otherwise the child elements do not belong to the isolate directive.
        var scopeToChild = scope;
        if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
          scopeToChild = isolateScope;
        }
        childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);

        // POSTLINKING
        for(i = postLinkFns.length - 1; i >= 0; i--) {
          try {
            linkFn = postLinkFns[i];
            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs,
                linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // This is the function that is injected as `$transclude`.
        function controllersBoundTransclude(scope, cloneAttachFn) {
          var transcludeControllers;

          // no scope passed
          if (arguments.length < 2) {
            cloneAttachFn = scope;
            scope = undefined;
          }

          if (hasElementTranscludeDirective) {
            transcludeControllers = elementControllers;
          }

          return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
        }
      }
    }

    function markDirectivesAsIsolate(directives) {
      // mark all directives as needing isolate scope.
      for (var j = 0, jj = directives.length; j < jj; j++) {
        directives[j] = inherit(directives[j], {$$isolateScope: true});
      }
    }

    /**
     * looks up the directive and decorates it with exception handling and proper parameters. We
     * call this the boundDirective.
     *
     * @param {string} name name of the directive to look up.
     * @param {string} location The directive must be found in specific format.
     *   String containing any of theses characters:
     *
     *   * `E`: element name
     *   * `A': attribute
     *   * `C`: class
     *   * `M`: comment
     * @returns true if directive was added.
     */
    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName,
                          endAttrName) {
      if (name === ignoreDirective) return null;
      var match = null;
      if (hasDirectives.hasOwnProperty(name)) {
        for(var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i<ii; i++) {
          try {
            directive = directives[i];
            if ( (maxPriority === undefined || maxPriority > directive.priority) &&
                 directive.restrict.indexOf(location) != -1) {
              if (startAttrName) {
                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});
              }
              tDirectives.push(directive);
              match = directive;
            }
          } catch(e) { $exceptionHandler(e); }
        }
      }
      return match;
    }


    /**
     * When the element is replaced with HTML template then the new attributes
     * on the template need to be merged with the existing attributes in the DOM.
     * The desired effect is to have both of the attributes present.
     *
     * @param {object} dst destination attributes (original DOM)
     * @param {object} src source attributes (from the directive template)
     */
    function mergeTemplateAttributes(dst, src) {
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      // reapply the old attributes to the new element
      forEach(dst, function(value, key) {
        if (key.charAt(0) != '$') {
          if (src[key]) {
            value += (key === 'style' ? ';' : ' ') + src[key];
          }
          dst.$set(key, value, true, srcAttr[key]);
        }
      });

      // copy the new attributes on the old attrs object
      forEach(src, function(value, key) {
        if (key == 'class') {
          safeAddClass($element, value);
          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
        } else if (key == 'style') {
          $element.attr('style', $element.attr('style') + ';' + value);
          dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
          // `dst` will never contain hasOwnProperty as DOM parser won't let it.
          // You will get an "InvalidCharacterError: DOM Exception 5" error if you
          // have an attribute like "has-own-property" or "data-has-own-property", etc.
        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        }
      });
    }


    function compileTemplateUrl(directives, $compileNode, tAttrs,
        $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          // The fact that we have to copy and patch the directive seems wrong!
          derivedSyncDirective = extend({}, origAsyncDirective, {
            templateUrl: null, transclude: null, replace: null, $$originalDirective: origAsyncDirective
          }),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl;

      $compileNode.empty();

      $http.get($sce.getTrustedResourceUrl(templateUrl), {cache: $templateCache}).
        success(function(content) {
          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;

          content = denormalizeTemplate(content);

          if (origAsyncDirective.replace) {
            $template = jqLite('<div>' + trim(content) + '</div>').contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr('tplrt',
                  "Template for directive '{0}' must have exactly one root element. {1}",
                  origAsyncDirective.name, templateUrl);
            }

            tempTemplateAttrs = {$attr: {}};
            replaceWith($rootElement, $compileNode, compileNode);
            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);

            if (isObject(origAsyncDirective.scope)) {
              markDirectivesAsIsolate(templateDirectives);
            }
            directives = templateDirectives.concat(directives);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          } else {
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          }

          directives.unshift(derivedSyncDirective);

          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs,
              childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns,
              previousCompileContext);
          forEach($rootElement, function(node, i) {
            if (node == compileNode) {
              $rootElement[i] = $compileNode[0];
            }
          });
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);


          while(linkQueue.length) {
            var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                boundTranscludeFn = linkQueue.shift(),
                linkNode = $compileNode[0];

            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
              // it was cloned therefore we have to clone as well.
              linkNode = jqLiteClone(compileNode);
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
            }
            if (afterTemplateNodeLinkFn.transclude) {
              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude);
            } else {
              childBoundTranscludeFn = boundTranscludeFn;
            }
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement,
              childBoundTranscludeFn);
          }
          linkQueue = null;
        }).
        error(function(response, code, headers, config) {
          throw $compileMinErr('tpload', 'Failed to load template: {0}', config.url);
        });

      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
        if (linkQueue) {
          linkQueue.push(scope);
          linkQueue.push(node);
          linkQueue.push(rootElement);
          linkQueue.push(boundTranscludeFn);
        } else {
          afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, boundTranscludeFn);
        }
      };
    }


    /**
     * Sorting function for bound directives.
     */
    function byPriority(a, b) {
      var diff = b.priority - a.priority;
      if (diff !== 0) return diff;
      if (a.name !== b.name) return (a.name < b.name) ? -1 : 1;
      return a.index - b.index;
    }


    function assertNoDuplicate(what, previousDirective, directive, element) {
      if (previousDirective) {
        throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] asking for {2} on: {3}',
            previousDirective.name, directive.name, what, startingTag(element));
      }
    }


    function addTextInterpolateDirective(directives, text) {
      var interpolateFn = $interpolate(text, true);
      if (interpolateFn) {
        directives.push({
          priority: 0,
          compile: valueFn(function textInterpolateLinkFn(scope, node) {
            var parent = node.parent(),
                bindings = parent.data('$binding') || [];
            bindings.push(interpolateFn);
            safeAddClass(parent.data('$binding', bindings), 'ng-binding');
            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
              node[0].nodeValue = value;
            });
          })
        });
      }
    }


    function getTrustedContext(node, attrNormalizedName) {
      if (attrNormalizedName == "srcdoc") {
        return $sce.HTML;
      }
      var tag = nodeName_(node);
      // maction[xlink:href] can source SVG.  It's not limited to <maction>.
      if (attrNormalizedName == "xlinkHref" ||
          (tag == "FORM" && attrNormalizedName == "action") ||
          (tag != "IMG" && (attrNormalizedName == "src" ||
                            attrNormalizedName == "ngSrc"))) {
        return $sce.RESOURCE_URL;
      }
    }


    function addAttrInterpolateDirective(node, directives, value, name) {
      var interpolateFn = $interpolate(value, true);

      // no interpolation found -> ignore
      if (!interpolateFn) return;


      if (name === "multiple" && nodeName_(node) === "SELECT") {
        throw $compileMinErr("selmulti",
            "Binding to the 'multiple' attribute is not supported. Element: {0}",
            startingTag(node));
      }

      directives.push({
        priority: 100,
        compile: function() {
            return {
              pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                var $$observers = (attr.$$observers || (attr.$$observers = {}));

                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                  throw $compileMinErr('nodomevents',
                      "Interpolations for HTML DOM event attributes are disallowed.  Please use the " +
                          "ng- versions (such as ng-click instead of onclick) instead.");
                }

                // we need to interpolate again, in case the attribute value has been updated
                // (e.g. by another directive's compile function)
                interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name));

                // if attribute was updated so that there is no interpolation going on we don't want to
                // register any observers
                if (!interpolateFn) return;

                // TODO(i): this should likely be attr.$set(name, iterpolateFn(scope) so that we reset the
                // actual attr value
                attr[name] = interpolateFn(scope);
                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                (attr.$$observers && attr.$$observers[name].$$scope || scope).
                  $watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                    //special case for class attribute addition + removal
                    //so that class changes can tap into the animation
                    //hooks provided by the $animate service. Be sure to
                    //skip animations when the first digest occurs (when
                    //both the new and the old values are the same) since
                    //the CSS classes are the non-interpolated values
                    if(name === 'class' && newValue != oldValue) {
                      attr.$updateClass(newValue, oldValue);
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
              }
            };
          }
      });
    }


    /**
     * This is a special jqLite.replaceWith, which can replace items which
     * have no parents, provided that the containing jqLite collection is provided.
     *
     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
     *                               in the root of the tree.
     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep
     *                                  the shell, but replace its DOM node reference.
     * @param {Node} newNode The new DOM node.
     */
    function replaceWith($rootElement, elementsToRemove, newNode) {
      var firstElementToRemove = elementsToRemove[0],
          removeCount = elementsToRemove.length,
          parent = firstElementToRemove.parentNode,
          i, ii;

      if ($rootElement) {
        for(i = 0, ii = $rootElement.length; i < ii; i++) {
          if ($rootElement[i] == firstElementToRemove) {
            $rootElement[i++] = newNode;
            for (var j = i, j2 = j + removeCount - 1,
                     jj = $rootElement.length;
                 j < jj; j++, j2++) {
              if (j2 < jj) {
                $rootElement[j] = $rootElement[j2];
              } else {
                delete $rootElement[j];
              }
            }
            $rootElement.length -= removeCount - 1;
            break;
          }
        }
      }

      if (parent) {
        parent.replaceChild(newNode, firstElementToRemove);
      }
      var fragment = document.createDocumentFragment();
      fragment.appendChild(firstElementToRemove);
      newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
        var element = elementsToRemove[k];
        jqLite(element).remove(); // must do this way to clean up expando
        fragment.appendChild(element);
        delete elementsToRemove[k];
      }

      elementsToRemove[0] = newNode;
      elementsToRemove.length = 1;
    }


    function cloneAndAnnotateFn(fn, annotation) {
      return extend(function() { return fn.apply(null, arguments); }, fn, annotation);
    }
  }];
}

var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
/**
 * Converts all accepted directives format into proper directive name.
 * All of these will become 'myDirective':
 *   my:Directive
 *   my-directive
 *   x-my-directive
 *   data-my:directive
 *
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function directiveNormalize(name) {
  return camelCase(name.replace(PREFIX_REGEXP, ''));
}

/**
 * @ngdoc object
 * @name ng.$compile.directive.Attributes
 *
 * @description
 * A shared object between directive compile / linking functions which contains normalized DOM
 * element attributes. The values reflect current binding state `{{ }}`. The normalization is
 * needed since all of these are treated as equivalent in Angular:
 *
 *    <span ng:bind="a" ng-bind="a" data-ng-bind="a" x-ng-bind="a">
 */

/**
 * @ngdoc property
 * @name ng.$compile.directive.Attributes#$attr
 * @propertyOf ng.$compile.directive.Attributes
 * @returns {object} A map of DOM element attribute names to the normalized name. This is
 *                   needed to do reverse lookup from normalized name back to actual name.
 */


/**
 * @ngdoc function
 * @name ng.$compile.directive.Attributes#$set
 * @methodOf ng.$compile.directive.Attributes
 * @function
 *
 * @description
 * Set DOM element attribute value.
 *
 *
 * @param {string} name Normalized element attribute name of the property to modify. The name is
 *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
 *          property to the original name.
 * @param {string} value Value to set the attribute to. The value can be an interpolated string.
 */



/**
 * Closure compiler type information
 */

function nodesetLinkingFn(
  /* angular.Scope */ scope,
  /* NodeList */ nodeList,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

function directiveLinkingFn(
  /* nodesetLinkingFn */ nodesetLinkingFn,
  /* angular.Scope */ scope,
  /* Node */ node,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

function tokenDifference(str1, str2) {
  var values = '',
      tokens1 = str1.split(/\s+/),
      tokens2 = str2.split(/\s+/);

  outer:
  for(var i = 0; i < tokens1.length; i++) {
    var token = tokens1[i];
    for(var j = 0; j < tokens2.length; j++) {
      if(token == tokens2[j]) continue outer;
    }
    values += (values.length > 0 ? ' ' : '') + token;
  }
  return values;
}

/**
 * @ngdoc object
 * @name ng.$controllerProvider
 * @description
 * The {@link ng.$controller $controller service} is used by Angular to create new
 * controllers.
 *
 * This provider allows controller registration via the
 * {@link ng.$controllerProvider#methods_register register} method.
 */
function $ControllerProvider() {
  var controllers = {},
      CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;


  /**
   * @ngdoc function
   * @name ng.$controllerProvider#register
   * @methodOf ng.$controllerProvider
   * @param {string|Object} name Controller name, or an object map of controllers where the keys are
   *    the names and the values are the constructors.
   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
   *    annotations in the array notation).
   */
  this.register = function(name, constructor) {
    assertNotHasOwnProperty(name, 'controller');
    if (isObject(name)) {
      extend(controllers, name);
    } else {
      controllers[name] = constructor;
    }
  };


  this.$get = ['$injector', '$window', function($injector, $window) {

    /**
     * @ngdoc function
     * @name ng.$controller
     * @requires $injector
     *
     * @param {Function|string} constructor If called with a function then it's considered to be the
     *    controller constructor function. Otherwise it's considered to be a string which is used
     *    to retrieve the controller constructor using the following steps:
     *
     *    * check if a controller with given name is registered via `$controllerProvider`
     *    * check if evaluating the string on the current scope returns a constructor
     *    * check `window[constructor]` on the global `window` object
     *
     * @param {Object} locals Injection locals for Controller.
     * @return {Object} Instance of given controller.
     *
     * @description
     * `$controller` service is responsible for instantiating controllers.
     *
     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into
     * a service, so that one can override this service with {@link https://gist.github.com/1649788
     * BC version}.
     */
    return function(expression, locals) {
      var instance, match, constructor, identifier;

      if(isString(expression)) {
        match = expression.match(CNTRL_REG),
        constructor = match[1],
        identifier = match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);

        assertArgFn(expression, constructor, true);
      }

      instance = $injector.instantiate(expression, locals);

      if (identifier) {
        if (!(locals && typeof locals.$scope == 'object')) {
          throw minErr('$controller')('noscp',
              "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
              constructor || expression.name, identifier);
        }

        locals.$scope[identifier] = instance;
      }

      return instance;
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$document
 * @requires $window
 *
 * @description
 * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`
 * element.
 */
function $DocumentProvider(){
  this.$get = ['$window', function(window){
    return jqLite(window.document);
  }];
}

/**
 * @ngdoc function
 * @name ng.$exceptionHandler
 * @requires $log
 *
 * @description
 * Any uncaught exception in angular expressions is delegated to this service.
 * The default implementation simply delegates to `$log.error` which logs it into
 * the browser console.
 * 
 * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
 *
 * ## Example:
 * 
 * <pre>
 *   angular.module('exceptionOverride', []).factory('$exceptionHandler', function () {
 *     return function (exception, cause) {
 *       exception.message += ' (caused by "' + cause + '")';
 *       throw exception;
 *     };
 *   });
 * </pre>
 * 
 * This example will override the normal action of `$exceptionHandler`, to make angular
 * exceptions fail hard when they happen, instead of just logging to the console.
 *
 * @param {Error} exception Exception associated with the error.
 * @param {string=} cause optional information about the context in which
 *       the error was thrown.
 *
 */
function $ExceptionHandlerProvider() {
  this.$get = ['$log', function($log) {
    return function(exception, cause) {
      $log.error.apply($log, arguments);
    };
  }];
}

/**
 * Parse headers into key value object
 *
 * @param {string} headers Raw headers as a string
 * @returns {Object} Parsed headers as key value object
 */
function parseHeaders(headers) {
  var parsed = {}, key, val, i;

  if (!headers) return parsed;

  forEach(headers.split('\n'), function(line) {
    i = line.indexOf(':');
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    if (key) {
      if (parsed[key]) {
        parsed[key] += ', ' + val;
      } else {
        parsed[key] = val;
      }
    }
  });

  return parsed;
}


/**
 * Returns a function that provides access to parsed headers.
 *
 * Headers are lazy parsed when first requested.
 * @see parseHeaders
 *
 * @param {(string|Object)} headers Headers to provide access to.
 * @returns {function(string=)} Returns a getter function which if called with:
 *
 *   - if called with single an argument returns a single header value or null
 *   - if called with no arguments returns an object containing all headers.
 */
function headersGetter(headers) {
  var headersObj = isObject(headers) ? headers : undefined;

  return function(name) {
    if (!headersObj) headersObj =  parseHeaders(headers);

    if (name) {
      return headersObj[lowercase(name)] || null;
    }

    return headersObj;
  };
}


/**
 * Chain all given functions
 *
 * This function is used for both request and response transforming
 *
 * @param {*} data Data to transform.
 * @param {function(string=)} headers Http headers getter fn.
 * @param {(function|Array.<function>)} fns Function or an array of functions.
 * @returns {*} Transformed data.
 */
function transformData(data, headers, fns) {
  if (isFunction(fns))
    return fns(data, headers);

  forEach(fns, function(fn) {
    data = fn(data, headers);
  });

  return data;
}


function isSuccess(status) {
  return 200 <= status && status < 300;
}


function $HttpProvider() {
  var JSON_START = /^\s*(\[|\{[^\{])/,
      JSON_END = /[\}\]]\s*$/,
      PROTECTION_PREFIX = /^\)\]\}',?\n/,
      CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': 'application/json;charset=utf-8'};

  var defaults = this.defaults = {
    // transform incoming response data
    transformResponse: [function(data) {
      if (isString(data)) {
        // strip json vulnerability protection prefix
        data = data.replace(PROTECTION_PREFIX, '');
        if (JSON_START.test(data) && JSON_END.test(data))
          data = fromJson(data);
      }
      return data;
    }],

    // transform outgoing request data
    transformRequest: [function(d) {
      return isObject(d) && !isFile(d) ? toJson(d) : d;
    }],

    // default headers
    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*'
      },
      post:   CONTENT_TYPE_APPLICATION_JSON,
      put:    CONTENT_TYPE_APPLICATION_JSON,
      patch:  CONTENT_TYPE_APPLICATION_JSON
    },

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN'
  };

  /**
   * Are ordered by request, i.e. they are applied in the same order as the
   * array, on request, but reverse order, on response.
   */
  var interceptorFactories = this.interceptors = [];

  /**
   * For historical reasons, response interceptors are ordered by the order in which
   * they are applied to the response. (This is the opposite of interceptorFactories)
   */
  var responseInterceptorFactories = this.responseInterceptors = [];

  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

    var defaultCache = $cacheFactory('$http');

    /**
     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
     * The reversal is needed so that we can build up the interception chain around the
     * server request.
     */
    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory)
          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory)
          ? $injector.get(interceptorFactory)
          : $injector.invoke(interceptorFactory);

      /**
       * Response interceptors go before "around" interceptors (no real reason, just
       * had to pick one.) But they are already reversed, so we can't use unshift, hence
       * the splice.
       */
      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });


    /**
     * @ngdoc function
     * @name ng.$http
     * @requires $httpBackend
     * @requires $browser
     * @requires $cacheFactory
     * @requires $rootScope
     * @requires $q
     * @requires $injector
     *
     * @description
     * The `$http` service is a core Angular service that facilitates communication with the remote
     * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest
     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.
     *
     * For unit testing applications that use `$http` service, see
     * {@link ngMock.$httpBackend $httpBackend mock}.
     *
     * For a higher level of abstraction, please check out the {@link ngResource.$resource
     * $resource} service.
     *
     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage
     * it is important to familiarize yourself with these APIs and the guarantees they provide.
     *
     *
     * # General usage
     * The `$http` service is a function which takes a single argument — a configuration object —
     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
     * with two $http specific methods: `success` and `error`.
     *
     * <pre>
     *   $http({method: 'GET', url: '/someUrl'}).
     *     success(function(data, status, headers, config) {
     *       // this callback will be called asynchronously
     *       // when the response is available
     *     }).
     *     error(function(data, status, headers, config) {
     *       // called asynchronously if an error occurs
     *       // or server returns response with an error status.
     *     });
     * </pre>
     *
     * Since the returned value of calling the $http function is a `promise`, you can also use
     * the `then` method to register callbacks, and these callbacks will receive a single argument –
     * an object representing the response. See the API signature and type info below for more
     * details.
     *
     * A response status code between 200 and 299 is considered a success status and
     * will result in the success callback being called. Note that if the response is a redirect,
     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
     * called for such responses.
     * 
     * # Calling $http from outside AngularJS
     * The `$http` service will not actually send the request until the next `$digest()` is
     * executed. Normally this is not an issue, since almost all the time your call to `$http` will
     * be from within a `$apply()` block.
     * If you are calling `$http` from outside Angular, then you should wrap it in a call to
     * `$apply` to cause a $digest to occur and also to handle errors in the block correctly.
     *
     * ```
     * $scope.$apply(function() {
     *   $http(...);
     * });
     * ```
     *
     * # Writing Unit Tests that use $http
     * When unit testing you are mostly responsible for scheduling the `$digest` cycle. If you do
     * not trigger a `$digest` before calling `$httpBackend.flush()` then the request will not have
     * been made and `$httpBackend.expect(...)` expectations will fail.  The solution is to run the
     * code that calls the `$http()` method inside a $apply block as explained in the previous
     * section.
     *
     * ```
     * $httpBackend.expectGET(...);
     * $scope.$apply(function() {
     *   $http.get(...);
     * });
     * $httpBackend.flush();
     * ```
     *
     * # Shortcut methods
     *
     * Since all invocations of the $http service require passing in an HTTP method and URL, and
     * POST/PUT requests require request data to be provided as well, shortcut methods
     * were created:
     *
     * <pre>
     *   $http.get('/someUrl').success(successCallback);
     *   $http.post('/someUrl', data).success(successCallback);
     * </pre>
     *
     * Complete list of shortcut methods:
     *
     * - {@link ng.$http#methods_get $http.get}
     * - {@link ng.$http#methods_head $http.head}
     * - {@link ng.$http#methods_post $http.post}
     * - {@link ng.$http#methods_put $http.put}
     * - {@link ng.$http#methods_delete $http.delete}
     * - {@link ng.$http#methods_jsonp $http.jsonp}
     *
     *
     * # Setting HTTP Headers
     *
     * The $http service will automatically add certain HTTP headers to all requests. These defaults
     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
     * object, which currently contains this default configuration:
     *
     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
     *   - `Accept: application/json, text/plain, * / *`
     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)
     *   - `Content-Type: application/json`
     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)
     *   - `Content-Type: application/json`
     *
     * To add or overwrite these defaults, simply add or remove a property from these configuration
     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
     * with the lowercased HTTP method name as the key, e.g.
     * `$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }.
     *
     * The defaults can also be set at runtime via the `$http.defaults` object in the same
     * fashion. In addition, you can supply a `headers` property in the config object passed when
     * calling `$http(config)`, which overrides the defaults without changing them globally.
     *
     *
     * # Transforming Requests and Responses
     *
     * Both requests and responses can be transformed using transform functions. By default, Angular
     * applies these transformations:
     *
     * Request transformations:
     *
     * - If the `data` property of the request configuration object contains an object, serialize it
     *   into JSON format.
     *
     * Response transformations:
     *
     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
     *  - If JSON response is detected, deserialize it using a JSON parser.
     *
     * To globally augment or override the default transforms, modify the
     * `$httpProvider.defaults.transformRequest` and `$httpProvider.defaults.transformResponse`
     * properties. These properties are by default an array of transform functions, which allows you
     * to `push` or `unshift` a new transformation function into the transformation chain. You can
     * also decide to completely override any default transformations by assigning your
     * transformation functions to these properties directly without the array wrapper.
     *
     * Similarly, to locally override the request/response transforms, augment the
     * `transformRequest` and/or `transformResponse` properties of the configuration object passed
     * into `$http`.
     *
     *
     * # Caching
     *
     * To enable caching, set the request configuration `cache` property to `true` (to use default
     * cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).
     * When the cache is enabled, `$http` stores the response from the server in the specified
     * cache. The next time the same request is made, the response is served from the cache without
     * sending a request to the server.
     *
     * Note that even if the response is served from cache, delivery of the data is asynchronous in
     * the same way that real requests are.
     *
     * If there are multiple GET requests for the same URL that should be cached using the same
     * cache, but the cache is not populated yet, only one request to the server will be made and
     * the remaining requests will be fulfilled using the response from the first request.
     *
     * You can change the default cache to a new object (built with
     * {@link ng.$cacheFactory `$cacheFactory`}) by updating the
     * {@link ng.$http#properties_defaults `$http.defaults.cache`} property. All requests who set
     * their `cache` property to `true` will now use this cache object.
     *
     * If you set the default cache to `false` then only requests that specify their own custom
     * cache object will be cached.
     *
     * # Interceptors
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication, or any kind of synchronous or
     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
     * able to intercept requests before they are handed to the server and
     * responses before they are handed over to the application code that
     * initiated these requests. The interceptors leverage the {@link ng.$q
     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
     *
     * The interceptors are service factories that are registered with the `$httpProvider` by
     * adding them to the `$httpProvider.interceptors` array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor.
     *
     * There are two kinds of interceptors (and two kinds of rejection interceptors):
     *
     *   * `request`: interceptors get called with http `config` object. The function is free to
     *     modify the `config` or create a new one. The function needs to return the `config`
     *     directly or as a promise.
     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or
     *     resolved with a rejection.
     *   * `response`: interceptors get called with http `response` object. The function is free to
     *     modify the `response` or create a new one. The function needs to return the `response`
     *     directly or as a promise.
     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or
     *     resolved with a rejection.
     *
     *
     * <pre>
     *   // register the interceptor as a service
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return {
     *       // optional method
     *       'request': function(config) {
     *         // do something on success
     *         return config || $q.when(config);
     *       },
     *
     *       // optional method
     *      'requestError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       },
     *
     *
     *
     *       // optional method
     *       'response': function(response) {
     *         // do something on success
     *         return response || $q.when(response);
     *       },
     *
     *       // optional method
     *      'responseError': function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       };
     *     }
     *   });
     *
     *   $httpProvider.interceptors.push('myHttpInterceptor');
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
     *     return {
     *      'request': function(config) {
     *          // same as above
     *       },
     *       'response': function(response) {
     *          // same as above
     *       }
     *     };
     *   });
     * </pre>
     *
     * # Response interceptors (DEPRECATED)
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication or any kind of synchronous or
     * asynchronous preprocessing of received responses, it is desirable to be able to intercept
     * responses for http requests before they are handed over to the application code that
     * initiated these requests. The response interceptors leverage the {@link ng.$q
     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.
     *
     * The interceptors are service factories that are registered with the $httpProvider by
     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor  — a function that
     * takes a {@link ng.$q promise} and returns the original or a new promise.
     *
     * <pre>
     *   // register the interceptor as a service
     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       return promise.then(function(response) {
     *         // do something on success
     *         return response;
     *       }, function(response) {
     *         // do something on error
     *         if (canRecover(response)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(response);
     *       });
     *     }
     *   });
     *
     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       // same as above
     *     }
     *   });
     * </pre>
     *
     *
     * # Security Considerations
     *
     * When designing web applications, consider security threats from:
     *
     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     *   JSON vulnerability}
     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}
     *
     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
     * pre-configured with strategies that address these issues, but for this to work backend server
     * cooperation is required.
     *
     * ## JSON Vulnerability Protection
     *
     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     * JSON vulnerability} allows third party website to turn your JSON resource URL into
     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To
     * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
     * Angular will automatically strip the prefix before processing it as JSON.
     *
     * For example if your server needs to return:
     * <pre>
     * ['one','two']
     * </pre>
     *
     * which is vulnerable to attack, your server can return:
     * <pre>
     * )]}',
     * ['one','two']
     * </pre>
     *
     * Angular will strip the prefix, before processing the JSON.
     *
     *
     * ## Cross Site Request Forgery (XSRF) Protection
     *
     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which
     * an unauthorized site can gain your user's private data. Angular provides a mechanism
     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only
     * JavaScript that runs on your domain could read the cookie, your server can be assured that
     * the XHR came from JavaScript running on your domain. The header will not be set for
     * cross-domain requests.
     *
     * To take advantage of this, your server needs to set a token in a JavaScript readable session
     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the
     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
     * that only JavaScript running on your domain could have sent the request. The token must be
     * unique for each user and must be verifiable by the server (to prevent the JavaScript from
     * making up its own tokens). We recommend that the token is a digest of your site's
     * authentication cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt}
     * for added security.
     *
     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
     * properties of either $httpProvider.defaults, or the per-request config object.
     *
     *
     * @param {object} config Object describing the request to be made and how it should be
     *    processed. The object has following properties:
     *
     *    - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)
     *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.
     *    - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be turned
     *      to `?key1=value1&key2=value2` after the url. If the value is not a string, it will be
     *      JSONified.
     *    - **data** – `{string|Object}` – Data to be sent as the request message data.
     *    - **headers** – `{Object}` – Map of strings or functions which return strings representing
     *      HTTP headers to send to the server. If the return value of a function is null, the
     *      header will not be sent.
     *    - **xsrfHeaderName** – `{string}` – Name of HTTP header to populate with the XSRF token.
     *    - **xsrfCookieName** – `{string}` – Name of cookie containing the XSRF token.
     *    - **transformRequest** –
     *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
     *      transform function or an array of such functions. The transform function takes the http
     *      request body and headers and returns its transformed (typically serialized) version.
     *    - **transformResponse** –
     *      `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
     *      transform function or an array of such functions. The transform function takes the http
     *      response body and headers and returns its transformed (typically deserialized) version.
     *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the
     *      GET request, otherwise if a cache instance built with
     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
     *      caching.
     *    - **timeout** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise}
     *      that should abort the request when resolved.
     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the
     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
     *      requests with credentials} for more information.
     *    - **responseType** - `{string}` - see {@link
     *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
     *
     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
     *   standard `then` method and two http specific methods: `success` and `error`. The `then`
     *   method takes two arguments a success and an error callback which will be called with a
     *   response object. The `success` and `error` methods take a single argument - a function that
     *   will be called when the request succeeds or fails respectively. The arguments passed into
     *   these functions are destructured representation of the response object passed into the
     *   `then` method. The response object has these properties:
     *
     *   - **data** – `{string|Object}` – The response body transformed with the transform
     *     functions.
     *   - **status** – `{number}` – HTTP status code of the response.
     *   - **headers** – `{function([headerName])}` – Header getter function.
     *   - **config** – `{Object}` – The configuration object that was used to generate the request.
     *
     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
     *   requests. This is primarily meant to be used for debugging purposes.
     *
     *
     * @example
<example>
<file name="index.html">
  <div ng-controller="FetchCtrl">
    <select ng-model="method">
      <option>GET</option>
      <option>JSONP</option>
    </select>
    <input type="text" ng-model="url" size="80"/>
    <button ng-click="fetch()">fetch</button><br>
    <button ng-click="updateModel('GET', 'http-hello.html')">Sample GET</button>
    <button
      ng-click="updateModel('JSONP',
                    'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">
      Sample JSONP
    </button>
    <button
      ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')">
        Invalid JSONP
      </button>
    <pre>http status code: {{status}}</pre>
    <pre>http response data: {{data}}</pre>
  </div>
</file>
<file name="script.js">
  function FetchCtrl($scope, $http, $templateCache) {
    $scope.method = 'GET';
    $scope.url = 'http-hello.html';

    $scope.fetch = function() {
      $scope.code = null;
      $scope.response = null;

      $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
        success(function(data, status) {
          $scope.status = status;
          $scope.data = data;
        }).
        error(function(data, status) {
          $scope.data = data || "Request failed";
          $scope.status = status;
      });
    };

    $scope.updateModel = function(method, url) {
      $scope.method = method;
      $scope.url = url;
    };
  }
</file>
<file name="http-hello.html">
  Hello, $http!
</file>
<file name="scenario.js">
  it('should make an xhr GET request', function() {
    element(':button:contains("Sample GET")').click();
    element(':button:contains("fetch")').click();
    expect(binding('status')).toBe('200');
    expect(binding('data')).toMatch(/Hello, \$http!/);
  });

  it('should make a JSONP request to angularjs.org', function() {
    element(':button:contains("Sample JSONP")').click();
    element(':button:contains("fetch")').click();
    expect(binding('status')).toBe('200');
    expect(binding('data')).toMatch(/Super Hero!/);
  });

  it('should make JSONP request to invalid URL and invoke the error handler',
      function() {
    element(':button:contains("Invalid JSONP")').click();
    element(':button:contains("fetch")').click();
    expect(binding('status')).toBe('0');
    expect(binding('data')).toBe('Request failed');
  });
</file>
</example>
     */
    function $http(requestConfig) {
      var config = {
        transformRequest: defaults.transformRequest,
        transformResponse: defaults.transformResponse
      };
      var headers = mergeHeaders(requestConfig);

      extend(config, requestConfig);
      config.headers = headers;
      config.method = uppercase(config.method);

      var xsrfValue = urlIsSameOrigin(config.url)
          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
          : undefined;
      if (xsrfValue) {
        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
      }


      var serverRequest = function(config) {
        headers = config.headers;
        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

        // strip content-type if data is undefined
        if (isUndefined(config.data)) {
          forEach(headers, function(value, header) {
            if (lowercase(header) === 'content-type') {
                delete headers[header];
            }
          });
        }

        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
          config.withCredentials = defaults.withCredentials;
        }

        // send request
        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
      };

      var chain = [serverRequest, undefined];
      var promise = $q.when(config);

      // apply interceptors
      forEach(reversedInterceptors, function(interceptor) {
        if (interceptor.request || interceptor.requestError) {
          chain.unshift(interceptor.request, interceptor.requestError);
        }
        if (interceptor.response || interceptor.responseError) {
          chain.push(interceptor.response, interceptor.responseError);
        }
      });

      while(chain.length) {
        var thenFn = chain.shift();
        var rejectFn = chain.shift();

        promise = promise.then(thenFn, rejectFn);
      }

      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      return promise;

      function transformResponse(response) {
        // make a copy since the response must be cacheable
        var resp = extend({}, response, {
          data: transformData(response.data, response.headers, config.transformResponse)
        });
        return (isSuccess(response.status))
          ? resp
          : $q.reject(resp);
      }

      function mergeHeaders(config) {
        var defHeaders = defaults.headers,
            reqHeaders = extend({}, config.headers),
            defHeaderName, lowercaseDefHeaderName, reqHeaderName;

        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);

        // execute if header value is function
        execHeaders(defHeaders);
        execHeaders(reqHeaders);

        // using for-in instead of forEach to avoid unecessary iteration after header has been found
        defaultHeadersIteration:
        for (defHeaderName in defHeaders) {
          lowercaseDefHeaderName = lowercase(defHeaderName);

          for (reqHeaderName in reqHeaders) {
            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
              continue defaultHeadersIteration;
            }
          }

          reqHeaders[defHeaderName] = defHeaders[defHeaderName];
        }

        return reqHeaders;

        function execHeaders(headers) {
          var headerContent;

          forEach(headers, function(headerFn, header) {
            if (isFunction(headerFn)) {
              headerContent = headerFn();
              if (headerContent != null) {
                headers[header] = headerContent;
              } else {
                delete headers[header];
              }
            }
          });
        }
      }
    }

    $http.pendingRequests = [];

    /**
     * @ngdoc method
     * @name ng.$http#get
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `GET` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#delete
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `DELETE` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#head
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `HEAD` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#jsonp
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `JSONP` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request.
     *                     Should contain `JSON_CALLBACK` string.
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethods('get', 'delete', 'head', 'jsonp');

    /**
     * @ngdoc method
     * @name ng.$http#post
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `POST` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#put
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform `PUT` request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethodsWithData('post', 'put');

        /**
         * @ngdoc property
         * @name ng.$http#defaults
         * @propertyOf ng.$http
         *
         * @description
         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
         * default headers, withCredentials as well as request and response transformations.
         *
         * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
         */
    $http.defaults = defaults;


    return $http;


    function createShortMethods(names) {
      forEach(arguments, function(name) {
        $http[name] = function(url, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url
          }));
        };
      });
    }


    function createShortMethodsWithData(name) {
      forEach(arguments, function(name) {
        $http[name] = function(url, data, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url,
            data: data
          }));
        };
      });
    }


    /**
     * Makes the request.
     *
     * !!! ACCESSES CLOSURE VARS:
     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
     */
    function sendReq(config, reqData, reqHeaders) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          cache,
          cachedResp,
          url = buildUrl(config.url, config.params);

      $http.pendingRequests.push(config);
      promise.then(removePendingReq, removePendingReq);


      if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {
        cache = isObject(config.cache) ? config.cache
              : isObject(defaults.cache) ? defaults.cache
              : defaultCache;
      }

      if (cache) {
        cachedResp = cache.get(url);
        if (isDefined(cachedResp)) {
          if (cachedResp.then) {
            // cached request has already been sent, but there is no response yet
            cachedResp.then(removePendingReq, removePendingReq);
            return cachedResp;
          } else {
            // serving from cache
            if (isArray(cachedResp)) {
              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
            } else {
              resolvePromise(cachedResp, 200, {});
            }
          }
        } else {
          // put the promise for the non-transformed response into cache as a placeholder
          cache.put(url, promise);
        }
      }

      // if we won't have the response in cache, send the request to the backend
      if (isUndefined(cachedResp)) {
        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
            config.withCredentials, config.responseType);
      }

      return promise;


      /**
       * Callback registered to $httpBackend():
       *  - caches the response if desired
       *  - resolves the raw $http promise
       *  - calls $apply
       */
      function done(status, response, headersString) {
        if (cache) {
          if (isSuccess(status)) {
            cache.put(url, [status, response, parseHeaders(headersString)]);
          } else {
            // remove promise from the cache
            cache.remove(url);
          }
        }

        resolvePromise(response, status, headersString);
        if (!$rootScope.$$phase) $rootScope.$apply();
      }


      /**
       * Resolves the raw $http promise.
       */
      function resolvePromise(response, status, headers) {
        // normalize internal statuses to 0
        status = Math.max(status, 0);

        (isSuccess(status) ? deferred.resolve : deferred.reject)({
          data: response,
          status: status,
          headers: headersGetter(headers),
          config: config
        });
      }


      function removePendingReq() {
        var idx = indexOf($http.pendingRequests, config);
        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
      }
    }


    function buildUrl(url, params) {
          if (!params) return url;
          var parts = [];
          forEachSorted(params, function(value, key) {
            if (value === null || isUndefined(value)) return;
            if (!isArray(value)) value = [value];

            forEach(value, function(v) {
              if (isObject(v)) {
                v = toJson(v);
              }
              parts.push(encodeUriQuery(key) + '=' +
                         encodeUriQuery(v));
            });
          });
          return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
        }


  }];
}

var XHR = window.XMLHttpRequest || function() {
  /* global ActiveXObject */
  try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch (e2) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP"); } catch (e3) {}
  throw minErr('$httpBackend')('noxhr', "This browser does not support XMLHttpRequest.");
};


/**
 * @ngdoc object
 * @name ng.$httpBackend
 * @requires $browser
 * @requires $window
 * @requires $document
 *
 * @description
 * HTTP backend used by the {@link ng.$http service} that delegates to
 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
 *
 * You should never need to use this service directly, instead use the higher-level abstractions:
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
 *
 * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
 * $httpBackend} which can be trained with responses.
 */
function $HttpBackendProvider() {
  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0]);
  }];
}

function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument) {
  var ABORTED = -1;

  // TODO(vojta): fix the signature
  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
    var status;
    $browser.$$incOutstandingRequestCount();
    url = url || $browser.url();

    if (lowercase(method) == 'jsonp') {
      var callbackId = '_' + (callbacks.counter++).toString(36);
      callbacks[callbackId] = function(data) {
        callbacks[callbackId].data = data;
      };

      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
          function() {
        if (callbacks[callbackId].data) {
          completeRequest(callback, 200, callbacks[callbackId].data);
        } else {
          completeRequest(callback, status || -2);
        }
        delete callbacks[callbackId];
      });
    } else {
      var xhr = new XHR();
      xhr.open(method, url, true);
      forEach(headers, function(value, key) {
        if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
        }
      });

      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the
      // response is in the cache. the promise api will ensure that to the app code the api is
      // always async
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          var responseHeaders = null,
              response = null;

          if(status !== ABORTED) {
            responseHeaders = xhr.getAllResponseHeaders();
            response = xhr.responseType ? xhr.response : xhr.responseText;
          }

          // responseText is the old-school way of retrieving response (supported by IE8 & 9)
          // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
          completeRequest(callback,
              status || xhr.status,
              response,
              responseHeaders);
        }
      };

      if (withCredentials) {
        xhr.withCredentials = true;
      }

      if (responseType) {
        xhr.responseType = responseType;
      }

      xhr.send(post || null);
    }

    if (timeout > 0) {
      var timeoutId = $browserDefer(timeoutRequest, timeout);
    } else if (timeout && timeout.then) {
      timeout.then(timeoutRequest);
    }


    function timeoutRequest() {
      status = ABORTED;
      jsonpDone && jsonpDone();
      xhr && xhr.abort();
    }

    function completeRequest(callback, status, response, headersString) {
      var protocol = urlResolve(url).protocol;

      // cancel timeout and subsequent timeout promise resolution
      timeoutId && $browserDefer.cancel(timeoutId);
      jsonpDone = xhr = null;

      // fix status code for file protocol (it's always 0)
      status = (protocol == 'file' && status === 0) ? (response ? 200 : 404) : status;

      // normalize IE bug (http://bugs.jquery.com/ticket/1450)
      status = status == 1223 ? 204 : status;

      callback(status, response, headersString);
      $browser.$$completeOutstandingRequest(noop);
    }
  };

  function jsonpReq(url, done) {
    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
    // - fetches local scripts via XHR and evals them
    // - adds and immediately removes script elements from the document
    var script = rawDocument.createElement('script'),
        doneWrapper = function() {
          script.onreadystatechange = script.onload = script.onerror = null;
          rawDocument.body.removeChild(script);
          if (done) done();
        };

    script.type = 'text/javascript';
    script.src = url;

    if (msie && msie <= 8) {
      script.onreadystatechange = function() {
        if (/loaded|complete/.test(script.readyState)) {
          doneWrapper();
        }
      };
    } else {
      script.onload = script.onerror = function() {
        doneWrapper();
      };
    }

    rawDocument.body.appendChild(script);
    return doneWrapper;
  }
}

var $interpolateMinErr = minErr('$interpolate');

/**
 * @ngdoc object
 * @name ng.$interpolateProvider
 * @function
 *
 * @description
 *
 * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
 *
 * @example
<doc:example module="customInterpolationApp">
<doc:source>
<script>
  var customInterpolationApp = angular.module('customInterpolationApp', []);

  customInterpolationApp.config(function($interpolateProvider) {
    $interpolateProvider.startSymbol('//');
    $interpolateProvider.endSymbol('//');
  });


  customInterpolationApp.controller('DemoController', function DemoController() {
      this.label = "This binding is brought you by // interpolation symbols.";
  });
</script>
<div ng-app="App" ng-controller="DemoController as demo">
    //demo.label//
</div>
</doc:source>
<doc:scenario>
 it('should interpolate binding with custom symbols', function() {
  expect(binding('demo.label')).toBe('This binding is brought you by // interpolation symbols.');
 });
</doc:scenario>
</doc:example>
 */
function $InterpolateProvider() {
  var startSymbol = '{{';
  var endSymbol = '}}';

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#startSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
   *
   * @param {string=} value new value to set the starting symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.startSymbol = function(value){
    if (value) {
      startSymbol = value;
      return this;
    } else {
      return startSymbol;
    }
  };

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#endSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
   *
   * @param {string=} value new value to set the ending symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.endSymbol = function(value){
    if (value) {
      endSymbol = value;
      return this;
    } else {
      return endSymbol;
    }
  };


  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
    var startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length;

    /**
     * @ngdoc function
     * @name ng.$interpolate
     * @function
     *
     * @requires $parse
     * @requires $sce
     *
     * @description
     *
     * Compiles a string with markup into an interpolation function. This service is used by the
     * HTML {@link ng.$compile $compile} service for data binding. See
     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
     * interpolation markup.
     *
     *
       <pre>
         var $interpolate = ...; // injected
         var exp = $interpolate('Hello {{name | uppercase}}!');
         expect(exp({name:'Angular'}).toEqual('Hello ANGULAR!');
       </pre>
     *
     *
     * @param {string} text The text with markup to interpolate.
     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
     *    embedded expression in order to return an interpolation function. Strings with no
     *    embedded expression will return null for the interpolation function.
     * @param {string=} trustedContext when provided, the returned function passes the interpolated
     *    result through {@link ng.$sce#methods_getTrusted $sce.getTrusted(interpolatedResult,
     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
     *    provides Strict Contextual Escaping for details.
     * @returns {function(context)} an interpolation function which is used to compute the
     *    interpolated string. The function has these parameters:
     *
     *    * `context`: an object against which any expressions embedded in the strings are evaluated
     *      against.
     *
     */
    function $interpolate(text, mustHaveExpression, trustedContext) {
      var startIndex,
          endIndex,
          index = 0,
          parts = [],
          length = text.length,
          hasInterpolation = false,
          fn,
          exp,
          concat = [];

      while(index < length) {
        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&
             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {
          (index != startIndex) && parts.push(text.substring(index, startIndex));
          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
          fn.exp = exp;
          index = endIndex + endSymbolLength;
          hasInterpolation = true;
        } else {
          // we did not find anything, so we have to add the remainder to the parts array
          (index != length) && parts.push(text.substring(index));
          index = length;
        }
      }

      if (!(length = parts.length)) {
        // we added, nothing, must have been an empty string.
        parts.push('');
        length = 1;
      }

      // Concatenating expressions makes it hard to reason about whether some combination of
      // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a
      // single expression be used for iframe[src], object[src], etc., we ensure that the value
      // that's used is assigned or constructed by some JS code somewhere that is more testable or
      // make it obvious that you bound the value to some user controlled value.  This helps reduce
      // the load when auditing for XSS issues.
      if (trustedContext && parts.length > 1) {
          throw $interpolateMinErr('noconcat',
              "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
              "interpolations that concatenate multiple expressions when a trusted value is " +
              "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      }

      if (!mustHaveExpression  || hasInterpolation) {
        concat.length = length;
        fn = function(context) {
          try {
            for(var i = 0, ii = length, part; i<ii; i++) {
              if (typeof (part = parts[i]) == 'function') {
                part = part(context);
                if (trustedContext) {
                  part = $sce.getTrusted(trustedContext, part);
                } else {
                  part = $sce.valueOf(part);
                }
                if (part === null || isUndefined(part)) {
                  part = '';
                } else if (typeof part != 'string') {
                  part = toJson(part);
                }
              }
              concat[i] = part;
            }
            return concat.join('');
          }
          catch(err) {
            var newErr = $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text,
                err.toString());
            $exceptionHandler(newErr);
          }
        };
        fn.exp = text;
        fn.parts = parts;
        return fn;
      }
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#startSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
     *
     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.startSymbol = function() {
      return startSymbol;
    };


    /**
     * @ngdoc method
     * @name ng.$interpolate#endSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
     *
     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.endSymbol = function() {
      return endSymbol;
    };

    return $interpolate;
  }];
}

function $IntervalProvider() {
  this.$get = ['$rootScope', '$window', '$q',
       function($rootScope,   $window,   $q) {
    var intervals = {};


     /**
      * @ngdoc function
      * @name ng.$interval
      *
      * @description
      * Angular's wrapper for `window.setInterval`. The `fn` function is executed every `delay`
      * milliseconds.
      *
      * The return value of registering an interval function is a promise. This promise will be
      * notified upon each tick of the interval, and will be resolved after `count` iterations, or
      * run indefinitely if `count` is not defined. The value of the notification will be the
      * number of iterations that have run.
      * To cancel an interval, call `$interval.cancel(promise)`.
      *
      * In tests you can use {@link ngMock.$interval#methods_flush `$interval.flush(millis)`} to
      * move forward by `millis` milliseconds and trigger any functions scheduled to run in that
      * time.
      * 
      * <div class="alert alert-warning">
      * **Note**: Intervals created by this service must be explicitly destroyed when you are finished
      * with them.  In particular they are not automatically destroyed when a controller's scope or a
      * directive's element are destroyed.
      * You should take this into consideration and make sure to always cancel the interval at the
      * appropriate moment.  See the example below for more details on how and when to do this.
      * </div>
      *
      * @param {function()} fn A function that should be called repeatedly.
      * @param {number} delay Number of milliseconds between each function call.
      * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
      *   indefinitely.
      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#methods_$apply $apply} block.
      * @returns {promise} A promise which will be notified on each iteration.
      *
      * @example
      <doc:example module="time">
        <doc:source>
          <script>
            function Ctrl2($scope,$interval) {
              $scope.format = 'M/d/yy h:mm:ss a';
              $scope.blood_1 = 100;
              $scope.blood_2 = 120;

              var stop;
              $scope.fight = function() {
                // Don't start a new fight if we are already fighting
                if ( angular.isDefined(stop) ) return;

                stop = $interval(function() {
                  if ($scope.blood_1 > 0 && $scope.blood_2 > 0) {
                      $scope.blood_1 = $scope.blood_1 - 3;
                      $scope.blood_2 = $scope.blood_2 - 4;
                  } else {
                      $scope.stopFight();
                  }
                }, 100);
              };

              $scope.stopFight = function() {
                if (angular.isDefined(stop)) {
                  $interval.cancel(stop);
                  stop = undefined;
                }
              };

              $scope.resetFight = function() {
                $scope.blood_1 = 100;
                $scope.blood_2 = 120;
              }

              $scope.$on('$destroy', function() {
                // Make sure that the interval is destroyed too
                $scope.stopFight();
              });
            }

            angular.module('time', [])
              // Register the 'myCurrentTime' directive factory method.
              // We inject $interval and dateFilter service since the factory method is DI.
              .directive('myCurrentTime', function($interval, dateFilter) {
                // return the directive link function. (compile function not needed)
                return function(scope, element, attrs) {
                  var format,  // date format
                  stopTime; // so that we can cancel the time updates

                  // used to update the UI
                  function updateTime() {
                    element.text(dateFilter(new Date(), format));
                  }

                  // watch the expression, and update the UI on change.
                  scope.$watch(attrs.myCurrentTime, function(value) {
                    format = value;
                    updateTime();
                  });

                  stopTime = $interval(updateTime, 1000);

                  // listen on DOM destroy (removal) event, and cancel the next UI update
                  // to prevent updating time ofter the DOM element was removed.
                  element.bind('$destroy', function() {
                    $interval.cancel(stopTime);
                  });
                }
              });
          </script>

          <div>
            <div ng-controller="Ctrl2">
              Date format: <input ng-model="format"> <hr/>
              Current time is: <span my-current-time="format"></span>
              <hr/>
              Blood 1 : <font color='red'>{{blood_1}}</font>
              Blood 2 : <font color='red'>{{blood_2}}</font>
              <button type="button" data-ng-click="fight()">Fight</button>
              <button type="button" data-ng-click="stopFight()">StopFight</button>
              <button type="button" data-ng-click="resetFight()">resetFight</button>
            </div>
          </div>

        </doc:source>
      </doc:example>
      */
    function interval(fn, delay, count, invokeApply) {
      var setInterval = $window.setInterval,
          clearInterval = $window.clearInterval,
          deferred = $q.defer(),
          promise = deferred.promise,
          iteration = 0,
          skipApply = (isDefined(invokeApply) && !invokeApply);
      
      count = isDefined(count) ? count : 0,

      promise.then(null, null, fn);

      promise.$$intervalId = setInterval(function tick() {
        deferred.notify(iteration++);

        if (count > 0 && iteration >= count) {
          deferred.resolve(iteration);
          clearInterval(promise.$$intervalId);
          delete intervals[promise.$$intervalId];
        }

        if (!skipApply) $rootScope.$apply();

      }, delay);

      intervals[promise.$$intervalId] = deferred;

      return promise;
    }


     /**
      * @ngdoc function
      * @name ng.$interval#cancel
      * @methodOf ng.$interval
      *
      * @description
      * Cancels a task associated with the `promise`.
      *
      * @param {number} promise Promise returned by the `$interval` function.
      * @returns {boolean} Returns `true` if the task was successfully canceled.
      */
    interval.cancel = function(promise) {
      if (promise && promise.$$intervalId in intervals) {
        intervals[promise.$$intervalId].reject('canceled');
        clearInterval(promise.$$intervalId);
        delete intervals[promise.$$intervalId];
        return true;
      }
      return false;
    };

    return interval;
  }];
}

/**
 * @ngdoc object
 * @name ng.$locale
 *
 * @description
 * $locale service provides localization rules for various Angular components. As of right now the
 * only public api is:
 *
 * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)
 */
function $LocaleProvider(){
  this.$get = function() {
    return {
      id: 'en-us',

      NUMBER_FORMATS: {
        DECIMAL_SEP: '.',
        GROUP_SEP: ',',
        PATTERNS: [
          { // Decimal Pattern
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: '',
            posSuf: '',
            negPre: '-',
            negSuf: '',
            gSize: 3,
            lgSize: 3
          },{ //Currency Pattern
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: '\u00A4',
            posSuf: '',
            negPre: '(\u00A4',
            negSuf: ')',
            gSize: 3,
            lgSize: 3
          }
        ],
        CURRENCY_SYM: '$'
      },

      DATETIME_FORMATS: {
        MONTH:
            'January,February,March,April,May,June,July,August,September,October,November,December'
            .split(','),
        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
        AMPMS: ['AM','PM'],
        medium: 'MMM d, y h:mm:ss a',
        short: 'M/d/yy h:mm a',
        fullDate: 'EEEE, MMMM d, y',
        longDate: 'MMMM d, y',
        mediumDate: 'MMM d, y',
        shortDate: 'M/d/yy',
        mediumTime: 'h:mm:ss a',
        shortTime: 'h:mm a'
      },

      pluralCat: function(num) {
        if (num === 1) {
          return 'one';
        }
        return 'other';
      }
    };
  };
}

var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};
var $locationMinErr = minErr('$location');


/**
 * Encode path using encodeUriSegment, ignoring forward slashes
 *
 * @param {string} path Path to encode
 * @returns {string}
 */
function encodePath(path) {
  var segments = path.split('/'),
      i = segments.length;

  while (i--) {
    segments[i] = encodeUriSegment(segments[i]);
  }

  return segments.join('/');
}

function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
  var parsedUrl = urlResolve(absoluteUrl, appBase);

  locationObj.$$protocol = parsedUrl.protocol;
  locationObj.$$host = parsedUrl.hostname;
  locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
}


function parseAppUrl(relativeUrl, locationObj, appBase) {
  var prefixed = (relativeUrl.charAt(0) !== '/');
  if (prefixed) {
    relativeUrl = '/' + relativeUrl;
  }
  var match = urlResolve(relativeUrl, appBase);
  locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ?
      match.pathname.substring(1) : match.pathname);
  locationObj.$$search = parseKeyValue(match.search);
  locationObj.$$hash = decodeURIComponent(match.hash);

  // make sure path starts with '/';
  if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
    locationObj.$$path = '/' + locationObj.$$path;
  }
}


/**
 *
 * @param {string} begin
 * @param {string} whole
 * @returns {string} returns text from whole after begin or undefined if it does not begin with
 *                   expected string.
 */
function beginsWith(begin, whole) {
  if (whole.indexOf(begin) === 0) {
    return whole.substr(begin.length);
  }
}


function stripHash(url) {
  var index = url.indexOf('#');
  return index == -1 ? url : url.substr(0, index);
}


function stripFile(url) {
  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
}

/* return the server only (scheme://host:port) */
function serverBase(url) {
  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
}


/**
 * LocationHtml5Url represents an url
 * This object is exposed as $location service when HTML5 mode is enabled and supported
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} basePrefix url path prefix
 */
function LocationHtml5Url(appBase, basePrefix) {
  this.$$html5 = true;
  basePrefix = basePrefix || '';
  var appBaseNoFile = stripFile(appBase);
  parseAbsoluteUrl(appBase, this, appBase);


  /**
   * Parse given html5 (regular) url string into properties
   * @param {string} newAbsoluteUrl HTML5 url
   * @private
   */
  this.$$parse = function(url) {
    var pathUrl = beginsWith(appBaseNoFile, url);
    if (!isString(pathUrl)) {
      throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url,
          appBaseNoFile);
    }

    parseAppUrl(pathUrl, this, appBase);

    if (!this.$$path) {
      this.$$path = '/';
    }

    this.$$compose();
  };

  /**
   * Compose url and update `absUrl` property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'
  };

  this.$$rewrite = function(url) {
    var appUrl, prevAppUrl;

    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {
      prevAppUrl = appUrl;
      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {
        return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
      } else {
        return appBase + prevAppUrl;
      }
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {
      return appBaseNoFile + appUrl;
    } else if (appBaseNoFile == url + '/') {
      return appBaseNoFile;
    }
  };
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when developer doesn't opt into html5 mode.
 * It also serves as the base class for html5 mode fallback on legacy browsers.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangUrl(appBase, hashPrefix) {
  var appBaseNoFile = stripFile(appBase);

  parseAbsoluteUrl(appBase, this, appBase);


  /**
   * Parse given hashbang url into properties
   * @param {string} url Hashbang url
   * @private
   */
  this.$$parse = function(url) {
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'
        ? beginsWith(hashPrefix, withoutBaseUrl)
        : (this.$$html5)
          ? withoutBaseUrl
          : '';

    if (!isString(withoutHashUrl)) {
      throw $locationMinErr('ihshprfx', 'Invalid url "{0}", missing hash prefix "{1}".', url,
          hashPrefix);
    }
    parseAppUrl(withoutHashUrl, this, appBase);

    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);

    this.$$compose();

    /*
     * In Windows, on an anchor node on documents loaded from
     * the filesystem, the browser will return a pathname
     * prefixed with the drive name ('/C:/path') when a
     * pathname without a drive is set:
     *  * a.setAttribute('href', '/foo')
     *   * a.pathname === '/C:/foo' //true
     *
     * Inside of Angular, we're always using pathnames that
     * do not include drive names for routing.
     */
    function removeWindowsDriveName (path, url, base) {
      /*
      Matches paths for file protocol on windows,
      such as /C:/foo/bar, and captures only /foo/bar.
      */
      var windowsFilePathExp = /^\/?.*?:(\/.*)/;

      var firstPathSegmentMatch;

      //Get the relative path from the input URL.
      if (url.indexOf(base) === 0) {
        url = url.replace(base, '');
      }

      /*
       * The input URL intentionally contains a
       * first path segment that ends with a colon.
       */
      if (windowsFilePathExp.exec(url)) {
        return path;
      }

      firstPathSegmentMatch = windowsFilePathExp.exec(path);
      return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
    }
  };

  /**
   * Compose hashbang url and update `absUrl` property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
  };

  this.$$rewrite = function(url) {
    if(stripHash(appBase) == stripHash(url)) {
      return url;
    }
  };
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when html5 history api is enabled but the browser
 * does not support it.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangInHtml5Url(appBase, hashPrefix) {
  this.$$html5 = true;
  LocationHashbangUrl.apply(this, arguments);

  var appBaseNoFile = stripFile(appBase);

  this.$$rewrite = function(url) {
    var appUrl;

    if ( appBase == stripHash(url) ) {
      return url;
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {
      return appBase + hashPrefix + appUrl;
    } else if ( appBaseNoFile === url + '/') {
      return appBaseNoFile;
    }
  };
}


LocationHashbangInHtml5Url.prototype =
  LocationHashbangUrl.prototype =
  LocationHtml5Url.prototype = {

  /**
   * Are we in html5 mode?
   * @private
   */
  $$html5: false,

  /**
   * Has any change been replacing ?
   * @private
   */
  $$replace: false,

  /**
   * @ngdoc method
   * @name ng.$location#absUrl
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return full url representation with all segments encoded according to rules specified in
   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.
   *
   * @return {string} full url
   */
  absUrl: locationGetter('$$absUrl'),

  /**
   * @ngdoc method
   * @name ng.$location#url
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
   *
   * Change path, search and hash, when called with parameter and return `$location`.
   *
   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
   * @param {string=} replace The path that will be changed
   * @return {string} url
   */
  url: function(url, replace) {
    if (isUndefined(url))
      return this.$$url;

    var match = PATH_MATCH.exec(url);
    if (match[1]) this.path(decodeURIComponent(match[1]));
    if (match[2] || match[1]) this.search(match[3] || '');
    this.hash(match[5] || '', replace);

    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#protocol
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return protocol of current url.
   *
   * @return {string} protocol of current url
   */
  protocol: locationGetter('$$protocol'),

  /**
   * @ngdoc method
   * @name ng.$location#host
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return host of current url.
   *
   * @return {string} host of current url.
   */
  host: locationGetter('$$host'),

  /**
   * @ngdoc method
   * @name ng.$location#port
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return port of current url.
   *
   * @return {Number} port
   */
  port: locationGetter('$$port'),

  /**
   * @ngdoc method
   * @name ng.$location#path
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return path of current url when called without any parameter.
   *
   * Change path when called with parameter and return `$location`.
   *
   * Note: Path should always begin with forward slash (/), this method will add the forward slash
   * if it is missing.
   *
   * @param {string=} path New path
   * @return {string} path
   */
  path: locationGetterSetter('$$path', function(path) {
    return path.charAt(0) == '/' ? path : '/' + path;
  }),

  /**
   * @ngdoc method
   * @name ng.$location#search
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return search part (as object) of current url when called without any parameter.
   *
   * Change search part when called with parameter and return `$location`.
   *
   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or
   * hash object. Hash object may contain an array of values, which will be decoded as duplicates in
   * the url.
   *
   * @param {(string|Array<string>)=} paramValue If `search` is a string, then `paramValue` will override only a
   * single search parameter. If `paramValue` is an array, it will set the parameter as a
   * comma-separated value. If `paramValue` is `null`, the parameter will be deleted.
   *
   * @return {string} search
   */
  search: function(search, paramValue) {
    switch (arguments.length) {
      case 0:
        return this.$$search;
      case 1:
        if (isString(search)) {
          this.$$search = parseKeyValue(search);
        } else if (isObject(search)) {
          this.$$search = search;
        } else {
          throw $locationMinErr('isrcharg',
              'The first argument of the `$location#search()` call must be a string or an object.');
        }
        break;
      default:
        if (isUndefined(paramValue) || paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
    }

    this.$$compose();
    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#hash
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return hash fragment when called without any parameter.
   *
   * Change hash fragment when called with parameter and return `$location`.
   *
   * @param {string=} hash New hash fragment
   * @return {string} hash
   */
  hash: locationGetterSetter('$$hash', identity),

  /**
   * @ngdoc method
   * @name ng.$location#replace
   * @methodOf ng.$location
   *
   * @description
   * If called, all changes to $location during current `$digest` will be replacing current history
   * record, instead of adding new one.
   */
  replace: function() {
    this.$$replace = true;
    return this;
  }
};

function locationGetter(property) {
  return function() {
    return this[property];
  };
}


function locationGetterSetter(property, preprocess) {
  return function(value) {
    if (isUndefined(value))
      return this[property];

    this[property] = preprocess(value);
    this.$$compose();

    return this;
  };
}


/**
 * @ngdoc object
 * @name ng.$location
 *
 * @requires $browser
 * @requires $sniffer
 * @requires $rootElement
 *
 * @description
 * The $location service parses the URL in the browser address bar (based on the
 * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL
 * available to your application. Changes to the URL in the address bar are reflected into
 * $location service and changes to $location are reflected into the browser address bar.
 *
 * **The $location service:**
 *
 * - Exposes the current URL in the browser address bar, so you can
 *   - Watch and observe the URL.
 *   - Change the URL.
 * - Synchronizes the URL with the browser when the user
 *   - Changes the address bar.
 *   - Clicks the back or forward button (or clicks a History link).
 *   - Clicks on a link.
 * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
 *
 * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular
 * Services: Using $location}
 */

/**
 * @ngdoc object
 * @name ng.$locationProvider
 * @description
 * Use the `$locationProvider` to configure how the application deep linking paths are stored.
 */
function $LocationProvider(){
  var hashPrefix = '',
      html5Mode = false;

  /**
   * @ngdoc property
   * @name ng.$locationProvider#hashPrefix
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} prefix Prefix for hash part (containing path and search)
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.hashPrefix = function(prefix) {
    if (isDefined(prefix)) {
      hashPrefix = prefix;
      return this;
    } else {
      return hashPrefix;
    }
  };

  /**
   * @ngdoc property
   * @name ng.$locationProvider#html5Mode
   * @methodOf ng.$locationProvider
   * @description
   * @param {boolean=} mode Use HTML5 strategy if available.
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.html5Mode = function(mode) {
    if (isDefined(mode)) {
      html5Mode = mode;
      return this;
    } else {
      return html5Mode;
    }
  };

  /**
   * @ngdoc event
   * @name ng.$location#$locationChangeStart
   * @eventOf ng.$location
   * @eventType broadcast on root scope
   * @description
   * Broadcasted before a URL will change. This change can be prevented by calling
   * `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on} for more
   * details about event object. Upon successful change
   * {@link ng.$location#$locationChangeSuccess $locationChangeSuccess} is fired.
   *
   * @param {Object} angularEvent Synthetic event object.
   * @param {string} newUrl New URL
   * @param {string=} oldUrl URL that was before it was changed.
   */

  /**
   * @ngdoc event
   * @name ng.$location#$locationChangeSuccess
   * @eventOf ng.$location
   * @eventType broadcast on root scope
   * @description
   * Broadcasted after a URL was changed.
   *
   * @param {Object} angularEvent Synthetic event object.
   * @param {string} newUrl New URL
   * @param {string=} oldUrl URL that was before it was changed.
   */

  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',
      function( $rootScope,   $browser,   $sniffer,   $rootElement) {
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''
        initialUrl = $browser.url(),
        appBase;

    if (html5Mode) {
      appBase = serverBase(initialUrl) + (baseHref || '/');
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    } else {
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    }
    $location = new LocationMode(appBase, '#' + hashPrefix);
    $location.$$parse($location.$$rewrite(initialUrl));

    $rootElement.on('click', function(event) {
      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
      // currently we open nice url link and redirect then

      if (event.ctrlKey || event.metaKey || event.which == 2) return;

      var elm = jqLite(event.target);

      // traverse the DOM up to find first A tag
      while (lowercase(elm[0].nodeName) !== 'a') {
        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
      }

      var absHref = elm.prop('href');

      if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
        // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
        // an animation.
        absHref = urlResolve(absHref.animVal).href;
      }

      var rewrittenUrl = $location.$$rewrite(absHref);

      if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {
        event.preventDefault();
        if (rewrittenUrl != $browser.url()) {
          // update location manually
          $location.$$parse(rewrittenUrl);
          $rootScope.$apply();
          // hack to work around FF6 bug 684208 when scenario runner clicks on links
          window.angular['ff-684208-preventDefault'] = true;
        }
      }
    });


    // rewrite hashbang url <> html5 url
    if ($location.absUrl() != initialUrl) {
      $browser.url($location.absUrl(), true);
    }

    // update $location when $browser url changes
    $browser.onUrlChange(function(newUrl) {
      if ($location.absUrl() != newUrl) {
        if ($rootScope.$broadcast('$locationChangeStart', newUrl,
                                  $location.absUrl()).defaultPrevented) {
          $browser.url($location.absUrl());
          return;
        }
        $rootScope.$evalAsync(function() {
          var oldUrl = $location.absUrl();

          $location.$$parse(newUrl);
          afterLocationChange(oldUrl);
        });
        if (!$rootScope.$$phase) $rootScope.$digest();
      }
    });

    // update browser
    var changeCounter = 0;
    $rootScope.$watch(function $locationWatch() {
      var oldUrl = $browser.url();
      var currentReplace = $location.$$replace;

      if (!changeCounter || oldUrl != $location.absUrl()) {
        changeCounter++;
        $rootScope.$evalAsync(function() {
          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).
              defaultPrevented) {
            $location.$$parse(oldUrl);
          } else {
            $browser.url($location.absUrl(), currentReplace);
            afterLocationChange(oldUrl);
          }
        });
      }
      $location.$$replace = false;

      return changeCounter;
    });

    return $location;

    function afterLocationChange(oldUrl) {
      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
    }
}];
}

/**
 * @ngdoc object
 * @name ng.$log
 * @requires $window
 *
 * @description
 * Simple service for logging. Default implementation safely writes the message
 * into the browser's console (if present).
 * 
 * The main purpose of this service is to simplify debugging and troubleshooting.
 *
 * The default is to log `debug` messages. You can use
 * {@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.
 *
 * @example
   <example>
     <file name="script.js">
       function LogCtrl($scope, $log) {
         $scope.$log = $log;
         $scope.message = 'Hello World!';
       }
     </file>
     <file name="index.html">
       <div ng-controller="LogCtrl">
         <p>Reload this page with open console, enter text and hit the log button...</p>
         Message:
         <input type="text" ng-model="message"/>
         <button ng-click="$log.log(message)">log</button>
         <button ng-click="$log.warn(message)">warn</button>
         <button ng-click="$log.info(message)">info</button>
         <button ng-click="$log.error(message)">error</button>
       </div>
     </file>
   </example>
 */

/**
 * @ngdoc object
 * @name ng.$logProvider
 * @description
 * Use the `$logProvider` to configure how the application logs messages
 */
function $LogProvider(){
  var debug = true,
      self = this;
  
  /**
   * @ngdoc property
   * @name ng.$logProvider#debugEnabled
   * @methodOf ng.$logProvider
   * @description
   * @param {string=} flag enable or disable debug level messages
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.debugEnabled = function(flag) {
    if (isDefined(flag)) {
      debug = flag;
    return this;
    } else {
      return debug;
    }
  };
  
  this.$get = ['$window', function($window){
    return {
      /**
       * @ngdoc method
       * @name ng.$log#log
       * @methodOf ng.$log
       *
       * @description
       * Write a log message
       */
      log: consoleLog('log'),

      /**
       * @ngdoc method
       * @name ng.$log#info
       * @methodOf ng.$log
       *
       * @description
       * Write an information message
       */
      info: consoleLog('info'),

      /**
       * @ngdoc method
       * @name ng.$log#warn
       * @methodOf ng.$log
       *
       * @description
       * Write a warning message
       */
      warn: consoleLog('warn'),

      /**
       * @ngdoc method
       * @name ng.$log#error
       * @methodOf ng.$log
       *
       * @description
       * Write an error message
       */
      error: consoleLog('error'),
      
      /**
       * @ngdoc method
       * @name ng.$log#debug
       * @methodOf ng.$log
       * 
       * @description
       * Write a debug message
       */
      debug: (function () {
        var fn = consoleLog('debug');

        return function() {
          if (debug) {
            fn.apply(self, arguments);
          }
        };
      }())
    };

    function formatError(arg) {
      if (arg instanceof Error) {
        if (arg.stack) {
          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
              ? 'Error: ' + arg.message + '\n' + arg.stack
              : arg.stack;
        } else if (arg.sourceURL) {
          arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
        }
      }
      return arg;
    }

    function consoleLog(type) {
      var console = $window.console || {},
          logFn = console[type] || console.log || noop,
          hasApply = false;

      // Note: reading logFn.apply throws an error in IE11 in IE8 document mode.
      // The reason behind this is that console.log has type "object" in IE8...
      try {
        hasApply = !! logFn.apply;
      } catch (e) {}

      if (hasApply) {
        return function() {
          var args = [];
          forEach(arguments, function(arg) {
            args.push(formatError(arg));
          });
          return logFn.apply(console, args);
        };
      }

      // we are IE which either doesn't have window.console => this is noop and we do nothing,
      // or we are IE where console.log doesn't have apply so we log at least first 2 args
      return function(arg1, arg2) {
        logFn(arg1, arg2 == null ? '' : arg2);
      };
    }
  }];
}

var $parseMinErr = minErr('$parse');
var promiseWarningCache = {};
var promiseWarning;

// Sandboxing Angular Expressions
// ------------------------------
// Angular expressions are generally considered safe because these expressions only have direct
// access to $scope and locals. However, one can obtain the ability to execute arbitrary JS code by
// obtaining a reference to native JS functions such as the Function constructor.
//
// As an example, consider the following Angular expression:
//
//   {}.toString.constructor(alert("evil JS code"))
//
// We want to prevent this type of access. For the sake of performance, during the lexing phase we
// disallow any "dotted" access to any member named "constructor".
//
// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor
// while evaluating the expression, which is a stronger but more expensive test. Since reflective
// calls are expensive anyway, this is not such a big deal compared to static dereferencing.
//
// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits
// against the expression language, but not to prevent exploits that were enabled by exposing
// sensitive JavaScript or browser apis on Scope. Exposing such objects on a Scope is never a good
// practice and therefore we are not even trying to protect against interaction with an object
// explicitly exposed in this way.
//
// A developer could foil the name check by aliasing the Function constructor under a different
// name on the scope.
//
// In general, it is not possible to access a Window object from an angular expression unless a
// window or some DOM object that has a reference to window is published onto a Scope.

function ensureSafeMemberName(name, fullExpression) {
  if (name === "constructor") {
    throw $parseMinErr('isecfld',
        'Referencing "constructor" field in Angular expressions is disallowed! Expression: {0}',
        fullExpression);
  }
  return name;
}

function ensureSafeObject(obj, fullExpression) {
  // nifty check if obj is Function that is fast and works across iframes and other contexts
  if (obj) {
    if (obj.constructor === obj) {
      throw $parseMinErr('isecfn',
          'Referencing Function in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
    } else if (// isWindow(obj)
        obj.document && obj.location && obj.alert && obj.setInterval) {
      throw $parseMinErr('isecwindow',
          'Referencing the Window in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
    } else if (// isElement(obj)
        obj.children && (obj.nodeName || (obj.on && obj.find))) {
      throw $parseMinErr('isecdom',
          'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}',
          fullExpression);
    }
  }
  return obj;
}

var OPERATORS = {
    /* jshint bitwise : false */
    'null':function(){return null;},
    'true':function(){return true;},
    'false':function(){return false;},
    undefined:noop,
    '+':function(self, locals, a,b){
      a=a(self, locals); b=b(self, locals);
      if (isDefined(a)) {
        if (isDefined(b)) {
          return a + b;
        }
        return a;
      }
      return isDefined(b)?b:undefined;},
    '-':function(self, locals, a,b){
          a=a(self, locals); b=b(self, locals);
          return (isDefined(a)?a:0)-(isDefined(b)?b:0);
        },
    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},
    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},
    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},
    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},
    '=':noop,
    '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},
    '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},
    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},
    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},
    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},
    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},
    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},
    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},
    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},
    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},
//    '|':function(self, locals, a,b){return a|b;},
    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
    '!':function(self, locals, a){return !a(self, locals);}
};
/* jshint bitwise: true */
var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};


/////////////////////////////////////////


/**
 * @constructor
 */
var Lexer = function (options) {
  this.options = options;
};

Lexer.prototype = {
  constructor: Lexer,

  lex: function (text) {
    this.text = text;

    this.index = 0;
    this.ch = undefined;
    this.lastCh = ':'; // can start regexp

    this.tokens = [];

    var token;
    var json = [];

    while (this.index < this.text.length) {
      this.ch = this.text.charAt(this.index);
      if (this.is('"\'')) {
        this.readString(this.ch);
      } else if (this.isNumber(this.ch) || this.is('.') && this.isNumber(this.peek())) {
        this.readNumber();
      } else if (this.isIdent(this.ch)) {
        this.readIdent();
        // identifiers can only be if the preceding char was a { or ,
        if (this.was('{,') && json[0] === '{' &&
            (token = this.tokens[this.tokens.length - 1])) {
          token.json = token.text.indexOf('.') === -1;
        }
      } else if (this.is('(){}[].,;:?')) {
        this.tokens.push({
          index: this.index,
          text: this.ch,
          json: (this.was(':[,') && this.is('{[')) || this.is('}]:,')
        });
        if (this.is('{[')) json.unshift(this.ch);
        if (this.is('}]')) json.shift();
        this.index++;
      } else if (this.isWhitespace(this.ch)) {
        this.index++;
        continue;
      } else {
        var ch2 = this.ch + this.peek();
        var ch3 = ch2 + this.peek(2);
        var fn = OPERATORS[this.ch];
        var fn2 = OPERATORS[ch2];
        var fn3 = OPERATORS[ch3];
        if (fn3) {
          this.tokens.push({index: this.index, text: ch3, fn: fn3});
          this.index += 3;
        } else if (fn2) {
          this.tokens.push({index: this.index, text: ch2, fn: fn2});
          this.index += 2;
        } else if (fn) {
          this.tokens.push({
            index: this.index,
            text: this.ch,
            fn: fn,
            json: (this.was('[,:') && this.is('+-'))
          });
          this.index += 1;
        } else {
          this.throwError('Unexpected next character ', this.index, this.index + 1);
        }
      }
      this.lastCh = this.ch;
    }
    return this.tokens;
  },

  is: function(chars) {
    return chars.indexOf(this.ch) !== -1;
  },

  was: function(chars) {
    return chars.indexOf(this.lastCh) !== -1;
  },

  peek: function(i) {
    var num = i || 1;
    return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
  },

  isNumber: function(ch) {
    return ('0' <= ch && ch <= '9');
  },

  isWhitespace: function(ch) {
    // IE treats non-breaking space as \u00A0
    return (ch === ' ' || ch === '\r' || ch === '\t' ||
            ch === '\n' || ch === '\v' || ch === '\u00A0');
  },

  isIdent: function(ch) {
    return ('a' <= ch && ch <= 'z' ||
            'A' <= ch && ch <= 'Z' ||
            '_' === ch || ch === '$');
  },

  isExpOperator: function(ch) {
    return (ch === '-' || ch === '+' || this.isNumber(ch));
  },

  throwError: function(error, start, end) {
    end = end || this.index;
    var colStr = (isDefined(start)
            ? 's ' + start +  '-' + this.index + ' [' + this.text.substring(start, end) + ']'
            : ' ' + end);
    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',
        error, colStr, this.text);
  },

  readNumber: function() {
    var number = '';
    var start = this.index;
    while (this.index < this.text.length) {
      var ch = lowercase(this.text.charAt(this.index));
      if (ch == '.' || this.isNumber(ch)) {
        number += ch;
      } else {
        var peekCh = this.peek();
        if (ch == 'e' && this.isExpOperator(peekCh)) {
          number += ch;
        } else if (this.isExpOperator(ch) &&
            peekCh && this.isNumber(peekCh) &&
            number.charAt(number.length - 1) == 'e') {
          number += ch;
        } else if (this.isExpOperator(ch) &&
            (!peekCh || !this.isNumber(peekCh)) &&
            number.charAt(number.length - 1) == 'e') {
          this.throwError('Invalid exponent');
        } else {
          break;
        }
      }
      this.index++;
    }
    number = 1 * number;
    this.tokens.push({
      index: start,
      text: number,
      json: true,
      fn: function() { return number; }
    });
  },

  readIdent: function() {
    var parser = this;

    var ident = '';
    var start = this.index;

    var lastDot, peekIndex, methodName, ch;

    while (this.index < this.text.length) {
      ch = this.text.charAt(this.index);
      if (ch === '.' || this.isIdent(ch) || this.isNumber(ch)) {
        if (ch === '.') lastDot = this.index;
        ident += ch;
      } else {
        break;
      }
      this.index++;
    }

    //check if this is not a method invocation and if it is back out to last dot
    if (lastDot) {
      peekIndex = this.index;
      while (peekIndex < this.text.length) {
        ch = this.text.charAt(peekIndex);
        if (ch === '(') {
          methodName = ident.substr(lastDot - start + 1);
          ident = ident.substr(0, lastDot - start);
          this.index = peekIndex;
          break;
        }
        if (this.isWhitespace(ch)) {
          peekIndex++;
        } else {
          break;
        }
      }
    }


    var token = {
      index: start,
      text: ident
    };

    // OPERATORS is our own object so we don't need to use special hasOwnPropertyFn
    if (OPERATORS.hasOwnProperty(ident)) {
      token.fn = OPERATORS[ident];
      token.json = OPERATORS[ident];
    } else {
      var getter = getterFn(ident, this.options, this.text);
      token.fn = extend(function(self, locals) {
        return (getter(self, locals));
      }, {
        assign: function(self, value) {
          return setter(self, ident, value, parser.text, parser.options);
        }
      });
    }

    this.tokens.push(token);

    if (methodName) {
      this.tokens.push({
        index:lastDot,
        text: '.',
        json: false
      });
      this.tokens.push({
        index: lastDot + 1,
        text: methodName,
        json: false
      });
    }
  },

  readString: function(quote) {
    var start = this.index;
    this.index++;
    var string = '';
    var rawString = quote;
    var escape = false;
    while (this.index < this.text.length) {
      var ch = this.text.charAt(this.index);
      rawString += ch;
      if (escape) {
        if (ch === 'u') {
          var hex = this.text.substring(this.index + 1, this.index + 5);
          if (!hex.match(/[\da-f]{4}/i))
            this.throwError('Invalid unicode escape [\\u' + hex + ']');
          this.index += 4;
          string += String.fromCharCode(parseInt(hex, 16));
        } else {
          var rep = ESCAPE[ch];
          if (rep) {
            string += rep;
          } else {
            string += ch;
          }
        }
        escape = false;
      } else if (ch === '\\') {
        escape = true;
      } else if (ch === quote) {
        this.index++;
        this.tokens.push({
          index: start,
          text: rawString,
          string: string,
          json: true,
          fn: function() { return string; }
        });
        return;
      } else {
        string += ch;
      }
      this.index++;
    }
    this.throwError('Unterminated quote', start);
  }
};


/**
 * @constructor
 */
var Parser = function (lexer, $filter, options) {
  this.lexer = lexer;
  this.$filter = $filter;
  this.options = options;
};

Parser.ZERO = function () { return 0; };

Parser.prototype = {
  constructor: Parser,

  parse: function (text, json) {
    this.text = text;

    //TODO(i): strip all the obsolte json stuff from this file
    this.json = json;

    this.tokens = this.lexer.lex(text);

    if (json) {
      // The extra level of aliasing is here, just in case the lexer misses something, so that
      // we prevent any accidental execution in JSON.
      this.assignment = this.logicalOR;

      this.functionCall =
      this.fieldAccess =
      this.objectIndex =
      this.filterChain = function() {
        this.throwError('is not valid json', {text: text, index: 0});
      };
    }

    var value = json ? this.primary() : this.statements();

    if (this.tokens.length !== 0) {
      this.throwError('is an unexpected token', this.tokens[0]);
    }

    value.literal = !!value.literal;
    value.constant = !!value.constant;

    return value;
  },

  primary: function () {
    var primary;
    if (this.expect('(')) {
      primary = this.filterChain();
      this.consume(')');
    } else if (this.expect('[')) {
      primary = this.arrayDeclaration();
    } else if (this.expect('{')) {
      primary = this.object();
    } else {
      var token = this.expect();
      primary = token.fn;
      if (!primary) {
        this.throwError('not a primary expression', token);
      }
      if (token.json) {
        primary.constant = true;
        primary.literal = true;
      }
    }

    var next, context;
    while ((next = this.expect('(', '[', '.'))) {
      if (next.text === '(') {
        primary = this.functionCall(primary, context);
        context = null;
      } else if (next.text === '[') {
        context = primary;
        primary = this.objectIndex(primary);
      } else if (next.text === '.') {
        context = primary;
        primary = this.fieldAccess(primary);
      } else {
        this.throwError('IMPOSSIBLE');
      }
    }
    return primary;
  },

  throwError: function(msg, token) {
    throw $parseMinErr('syntax',
        'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].',
          token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
  },

  peekToken: function() {
    if (this.tokens.length === 0)
      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
    return this.tokens[0];
  },

  peek: function(e1, e2, e3, e4) {
    if (this.tokens.length > 0) {
      var token = this.tokens[0];
      var t = token.text;
      if (t === e1 || t === e2 || t === e3 || t === e4 ||
          (!e1 && !e2 && !e3 && !e4)) {
        return token;
      }
    }
    return false;
  },

  expect: function(e1, e2, e3, e4){
    var token = this.peek(e1, e2, e3, e4);
    if (token) {
      if (this.json && !token.json) {
        this.throwError('is not valid json', token);
      }
      this.tokens.shift();
      return token;
    }
    return false;
  },

  consume: function(e1){
    if (!this.expect(e1)) {
      this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
    }
  },

  unaryFn: function(fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, right);
    }, {
      constant:right.constant
    });
  },

  ternaryFn: function(left, middle, right){
    return extend(function(self, locals){
      return left(self, locals) ? middle(self, locals) : right(self, locals);
    }, {
      constant: left.constant && middle.constant && right.constant
    });
  },

  binaryFn: function(left, fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, left, right);
    }, {
      constant:left.constant && right.constant
    });
  },

  statements: function() {
    var statements = [];
    while (true) {
      if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
        statements.push(this.filterChain());
      if (!this.expect(';')) {
        // optimize for the common case where there is only one statement.
        // TODO(size): maybe we should not support multiple statements?
        return (statements.length === 1)
            ? statements[0]
            : function(self, locals) {
                var value;
                for (var i = 0; i < statements.length; i++) {
                  var statement = statements[i];
                  if (statement) {
                    value = statement(self, locals);
                  }
                }
                return value;
              };
      }
    }
  },

  filterChain: function() {
    var left = this.expression();
    var token;
    while (true) {
      if ((token = this.expect('|'))) {
        left = this.binaryFn(left, token.fn, this.filter());
      } else {
        return left;
      }
    }
  },

  filter: function() {
    var token = this.expect();
    var fn = this.$filter(token.text);
    var argsFn = [];
    while (true) {
      if ((token = this.expect(':'))) {
        argsFn.push(this.expression());
      } else {
        var fnInvoke = function(self, locals, input) {
          var args = [input];
          for (var i = 0; i < argsFn.length; i++) {
            args.push(argsFn[i](self, locals));
          }
          return fn.apply(self, args);
        };
        return function() {
          return fnInvoke;
        };
      }
    }
  },

  expression: function() {
    return this.assignment();
  },

  assignment: function() {
    var left = this.ternary();
    var right;
    var token;
    if ((token = this.expect('='))) {
      if (!left.assign) {
        this.throwError('implies assignment but [' +
            this.text.substring(0, token.index) + '] can not be assigned to', token);
      }
      right = this.ternary();
      return function(scope, locals) {
        return left.assign(scope, right(scope, locals), locals);
      };
    }
    return left;
  },

  ternary: function() {
    var left = this.logicalOR();
    var middle;
    var token;
    if ((token = this.expect('?'))) {
      middle = this.ternary();
      if ((token = this.expect(':'))) {
        return this.ternaryFn(left, middle, this.ternary());
      } else {
        this.throwError('expected :', token);
      }
    } else {
      return left;
    }
  },

  logicalOR: function() {
    var left = this.logicalAND();
    var token;
    while (true) {
      if ((token = this.expect('||'))) {
        left = this.binaryFn(left, token.fn, this.logicalAND());
      } else {
        return left;
      }
    }
  },

  logicalAND: function() {
    var left = this.equality();
    var token;
    if ((token = this.expect('&&'))) {
      left = this.binaryFn(left, token.fn, this.logicalAND());
    }
    return left;
  },

  equality: function() {
    var left = this.relational();
    var token;
    if ((token = this.expect('==','!=','===','!=='))) {
      left = this.binaryFn(left, token.fn, this.equality());
    }
    return left;
  },

  relational: function() {
    var left = this.additive();
    var token;
    if ((token = this.expect('<', '>', '<=', '>='))) {
      left = this.binaryFn(left, token.fn, this.relational());
    }
    return left;
  },

  additive: function() {
    var left = this.multiplicative();
    var token;
    while ((token = this.expect('+','-'))) {
      left = this.binaryFn(left, token.fn, this.multiplicative());
    }
    return left;
  },

  multiplicative: function() {
    var left = this.unary();
    var token;
    while ((token = this.expect('*','/','%'))) {
      left = this.binaryFn(left, token.fn, this.unary());
    }
    return left;
  },

  unary: function() {
    var token;
    if (this.expect('+')) {
      return this.primary();
    } else if ((token = this.expect('-'))) {
      return this.binaryFn(Parser.ZERO, token.fn, this.unary());
    } else if ((token = this.expect('!'))) {
      return this.unaryFn(token.fn, this.unary());
    } else {
      return this.primary();
    }
  },

  fieldAccess: function(object) {
    var parser = this;
    var field = this.expect().text;
    var getter = getterFn(field, this.options, this.text);

    return extend(function(scope, locals, self) {
      return getter(self || object(scope, locals), locals);
    }, {
      assign: function(scope, value, locals) {
        return setter(object(scope, locals), field, value, parser.text, parser.options);
      }
    });
  },

  objectIndex: function(obj) {
    var parser = this;

    var indexFn = this.expression();
    this.consume(']');

    return extend(function(self, locals) {
      var o = obj(self, locals),
          i = indexFn(self, locals),
          v, p;

      if (!o) return undefined;
      v = ensureSafeObject(o[i], parser.text);
      if (v && v.then && parser.options.unwrapPromises) {
        p = v;
        if (!('$$v' in v)) {
          p.$$v = undefined;
          p.then(function(val) { p.$$v = val; });
        }
        v = v.$$v;
      }
      return v;
    }, {
      assign: function(self, value, locals) {
        var key = indexFn(self, locals);
        // prevent overwriting of Function.constructor which would break ensureSafeObject check
        var safe = ensureSafeObject(obj(self, locals), parser.text);
        return safe[key] = value;
      }
    });
  },

  functionCall: function(fn, contextGetter) {
    var argsFn = [];
    if (this.peekToken().text !== ')') {
      do {
        argsFn.push(this.expression());
      } while (this.expect(','));
    }
    this.consume(')');

    var parser = this;

    return function(scope, locals) {
      var args = [];
      var context = contextGetter ? contextGetter(scope, locals) : scope;

      for (var i = 0; i < argsFn.length; i++) {
        args.push(argsFn[i](scope, locals));
      }
      var fnPtr = fn(scope, locals, context) || noop;

      ensureSafeObject(context, parser.text);
      ensureSafeObject(fnPtr, parser.text);

      // IE stupidity! (IE doesn't have apply for some native functions)
      var v = fnPtr.apply
            ? fnPtr.apply(context, args)
            : fnPtr(args[0], args[1], args[2], args[3], args[4]);

      return ensureSafeObject(v, parser.text);
    };
  },

  // This is used with json array declaration
  arrayDeclaration: function () {
    var elementFns = [];
    var allConstant = true;
    if (this.peekToken().text !== ']') {
      do {
        var elementFn = this.expression();
        elementFns.push(elementFn);
        if (!elementFn.constant) {
          allConstant = false;
        }
      } while (this.expect(','));
    }
    this.consume(']');

    return extend(function(self, locals) {
      var array = [];
      for (var i = 0; i < elementFns.length; i++) {
        array.push(elementFns[i](self, locals));
      }
      return array;
    }, {
      literal: true,
      constant: allConstant
    });
  },

  object: function () {
    var keyValues = [];
    var allConstant = true;
    if (this.peekToken().text !== '}') {
      do {
        var token = this.expect(),
        key = token.string || token.text;
        this.consume(':');
        var value = this.expression();
        keyValues.push({key: key, value: value});
        if (!value.constant) {
          allConstant = false;
        }
      } while (this.expect(','));
    }
    this.consume('}');

    return extend(function(self, locals) {
      var object = {};
      for (var i = 0; i < keyValues.length; i++) {
        var keyValue = keyValues[i];
        object[keyValue.key] = keyValue.value(self, locals);
      }
      return object;
    }, {
      literal: true,
      constant: allConstant
    });
  }
};


//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

function setter(obj, path, setValue, fullExp, options) {
  //needed?
  options = options || {};

  var element = path.split('.'), key;
  for (var i = 0; element.length > 1; i++) {
    key = ensureSafeMemberName(element.shift(), fullExp);
    var propertyObj = obj[key];
    if (!propertyObj) {
      propertyObj = {};
      obj[key] = propertyObj;
    }
    obj = propertyObj;
    if (obj.then && options.unwrapPromises) {
      promiseWarning(fullExp);
      if (!("$$v" in obj)) {
        (function(promise) {
          promise.then(function(val) { promise.$$v = val; }); }
        )(obj);
      }
      if (obj.$$v === undefined) {
        obj.$$v = {};
      }
      obj = obj.$$v;
    }
  }
  key = ensureSafeMemberName(element.shift(), fullExp);
  obj[key] = setValue;
  return setValue;
}

var getterFnCache = {};

/**
 * Implementation of the "Black Hole" variant from:
 * - http://jsperf.com/angularjs-parse-getter/4
 * - http://jsperf.com/path-evaluation-simplified/7
 */
function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);
  ensureSafeMemberName(key2, fullExp);
  ensureSafeMemberName(key3, fullExp);
  ensureSafeMemberName(key4, fullExp);

  return !options.unwrapPromises
      ? function cspSafeGetter(scope, locals) {
          var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope;

          if (pathVal == null) return pathVal;
          pathVal = pathVal[key0];

          if (pathVal == null) return key1 ? undefined : pathVal;
          pathVal = pathVal[key1];

          if (pathVal == null) return key2 ? undefined : pathVal;
          pathVal = pathVal[key2];

          if (pathVal == null) return key3 ? undefined : pathVal;
          pathVal = pathVal[key3];

          if (pathVal == null) return key4 ? undefined : pathVal;
          pathVal = pathVal[key4];

          return pathVal;
        }
      : function cspSafePromiseEnabledGetter(scope, locals) {
          var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
              promise;

          if (pathVal == null) return pathVal;

          pathVal = pathVal[key0];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key1 ? undefined : pathVal;

          pathVal = pathVal[key1];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key2 ? undefined : pathVal;

          pathVal = pathVal[key2];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key3 ? undefined : pathVal;

          pathVal = pathVal[key3];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          if (pathVal == null) return key4 ? undefined : pathVal;

          pathVal = pathVal[key4];
          if (pathVal && pathVal.then) {
            promiseWarning(fullExp);
            if (!("$$v" in pathVal)) {
              promise = pathVal;
              promise.$$v = undefined;
              promise.then(function(val) { promise.$$v = val; });
            }
            pathVal = pathVal.$$v;
          }
          return pathVal;
        };
}

function simpleGetterFn1(key0, fullExp) {
  ensureSafeMemberName(key0, fullExp);

  return function simpleGetterFn1(scope, locals) {
    if (scope == null) return undefined;
    return ((locals && locals.hasOwnProperty(key0)) ? locals : scope)[key0];
  };
}

function simpleGetterFn2(key0, key1, fullExp) {
  ensureSafeMemberName(key0, fullExp);
  ensureSafeMemberName(key1, fullExp);

  return function simpleGetterFn2(scope, locals) {
    if (scope == null) return undefined;
    scope = ((locals && locals.hasOwnProperty(key0)) ? locals : scope)[key0];
    return scope == null ? undefined : scope[key1];
  };
}

function getterFn(path, options, fullExp) {
  // Check whether the cache has this getter already.
  // We can use hasOwnProperty directly on the cache because we ensure,
  // see below, that the cache never stores a path called 'hasOwnProperty'
  if (getterFnCache.hasOwnProperty(path)) {
    return getterFnCache[path];
  }

  var pathKeys = path.split('.'),
      pathKeysLength = pathKeys.length,
      fn;

  // When we have only 1 or 2 tokens, use optimized special case closures.
  // http://jsperf.com/angularjs-parse-getter/6
  if (!options.unwrapPromises && pathKeysLength === 1) {
    fn = simpleGetterFn1(pathKeys[0], fullExp);
  } else if (!options.unwrapPromises && pathKeysLength === 2) {
    fn = simpleGetterFn2(pathKeys[0], pathKeys[1], fullExp);
  } else if (options.csp) {
    if (pathKeysLength < 6) {
      fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp,
                          options);
    } else {
      fn = function(scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++],
                                pathKeys[i++], fullExp, options)(scope, locals);

          locals = undefined; // clear after first iteration
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    }
  } else {
    var code = 'var p;\n';
    forEach(pathKeys, function(key, index) {
      ensureSafeMemberName(key, fullExp);
      code += 'if(s == null) return undefined;\n' +
              's='+ (index
                      // we simply dereference 's' on any .dot notation
                      ? 's'
                      // but if we are first then we check locals first, and if so read it first
                      : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +
              (options.unwrapPromises
                ? 'if (s && s.then) {\n' +
                  ' pw("' + fullExp.replace(/(["\r\n])/g, '\\$1') + '");\n' +
                  ' if (!("$$v" in s)) {\n' +
                    ' p=s;\n' +
                    ' p.$$v = undefined;\n' +
                    ' p.then(function(v) {p.$$v=v;});\n' +
                    '}\n' +
                  ' s=s.$$v\n' +
                '}\n'
                : '');
    });
    code += 'return s;';

    /* jshint -W054 */
    var evaledFnGetter = new Function('s', 'k', 'pw', code); // s=scope, k=locals, pw=promiseWarning
    /* jshint +W054 */
    evaledFnGetter.toString = valueFn(code);
    fn = options.unwrapPromises ? function(scope, locals) {
      return evaledFnGetter(scope, locals, promiseWarning);
    } : evaledFnGetter;
  }

  // Only cache the value if it's not going to mess up the cache object
  // This is more performant that using Object.prototype.hasOwnProperty.call
  if (path !== 'hasOwnProperty') {
    getterFnCache[path] = fn;
  }
  return fn;
}

///////////////////////////////////

/**
 * @ngdoc function
 * @name ng.$parse
 * @function
 *
 * @description
 *
 * Converts Angular {@link guide/expression expression} into a function.
 *
 * <pre>
 *   var getter = $parse('user.name');
 *   var setter = getter.assign;
 *   var context = {user:{name:'angular'}};
 *   var locals = {user:{name:'local'}};
 *
 *   expect(getter(context)).toEqual('angular');
 *   setter(context, 'newValue');
 *   expect(context.user.name).toEqual('newValue');
 *   expect(getter(context, locals)).toEqual('local');
 * </pre>
 *
 *
 * @param {string} expression String expression to compile.
 * @returns {function(context, locals)} a function which represents the compiled expression:
 *
 *    * `context` – `{object}` – an object against which any expressions embedded in the strings
 *      are evaluated against (typically a scope object).
 *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
 *      `context`.
 *
 *    The returned function also has the following properties:
 *      * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript
 *        literal.
 *      * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript
 *        constant literals.
 *      * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be
 *        set to a function to change its value on the given context.
 *
 */


/**
 * @ngdoc object
 * @name ng.$parseProvider
 * @function
 *
 * @description
 * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}
 *  service.
 */
function $ParseProvider() {
  var cache = {};

  var $parseOptions = {
    csp: false,
    unwrapPromises: false,
    logPromiseWarnings: true
  };


  /**
   * @deprecated Promise unwrapping via $parse is deprecated and will be removed in the future.
   *
   * @ngdoc method
   * @name ng.$parseProvider#unwrapPromises
   * @methodOf ng.$parseProvider
   * @description
   *
   * **This feature is deprecated, see deprecation notes below for more info**
   *
   * If set to true (default is false), $parse will unwrap promises automatically when a promise is
   * found at any part of the expression. In other words, if set to true, the expression will always
   * result in a non-promise value.
   *
   * While the promise is unresolved, it's treated as undefined, but once resolved and fulfilled,
   * the fulfillment value is used in place of the promise while evaluating the expression.
   *
   * **Deprecation notice**
   *
   * This is a feature that didn't prove to be wildly useful or popular, primarily because of the
   * dichotomy between data access in templates (accessed as raw values) and controller code
   * (accessed as promises).
   *
   * In most code we ended up resolving promises manually in controllers anyway and thus unifying
   * the model access there.
   *
   * Other downsides of automatic promise unwrapping:
   *
   * - when building components it's often desirable to receive the raw promises
   * - adds complexity and slows down expression evaluation
   * - makes expression code pre-generation unattractive due to the amount of code that needs to be
   *   generated
   * - makes IDE auto-completion and tool support hard
   *
   * **Warning Logs**
   *
   * If the unwrapping is enabled, Angular will log a warning about each expression that unwraps a
   * promise (to reduce the noise, each expression is logged only once). To disable this logging use
   * `$parseProvider.logPromiseWarnings(false)` api.
   *
   *
   * @param {boolean=} value New value.
   * @returns {boolean|self} Returns the current setting when used as getter and self if used as
   *                         setter.
   */
  this.unwrapPromises = function(value) {
    if (isDefined(value)) {
      $parseOptions.unwrapPromises = !!value;
      return this;
    } else {
      return $parseOptions.unwrapPromises;
    }
  };


  /**
   * @deprecated Promise unwrapping via $parse is deprecated and will be removed in the future.
   *
   * @ngdoc method
   * @name ng.$parseProvider#logPromiseWarnings
   * @methodOf ng.$parseProvider
   * @description
   *
   * Controls whether Angular should log a warning on any encounter of a promise in an expression.
   *
   * The default is set to `true`.
   *
   * This setting applies only if `$parseProvider.unwrapPromises` setting is set to true as well.
   *
   * @param {boolean=} value New value.
   * @returns {boolean|self} Returns the current setting when used as getter and self if used as
   *                         setter.
   */
 this.logPromiseWarnings = function(value) {
    if (isDefined(value)) {
      $parseOptions.logPromiseWarnings = value;
      return this;
    } else {
      return $parseOptions.logPromiseWarnings;
    }
  };


  this.$get = ['$filter', '$sniffer', '$log', function($filter, $sniffer, $log) {
    $parseOptions.csp = $sniffer.csp;

    promiseWarning = function promiseWarningFn(fullExp) {
      if (!$parseOptions.logPromiseWarnings || promiseWarningCache.hasOwnProperty(fullExp)) return;
      promiseWarningCache[fullExp] = true;
      $log.warn('[$parse] Promise found in the expression `' + fullExp + '`. ' +
          'Automatic unwrapping of promises in Angular expressions is deprecated.');
    };

    return function(exp) {
      var parsedExpression;

      switch (typeof exp) {
        case 'string':

          if (cache.hasOwnProperty(exp)) {
            return cache[exp];
          }

          var lexer = new Lexer($parseOptions);
          var parser = new Parser(lexer, $filter, $parseOptions);
          parsedExpression = parser.parse(exp, false);

          if (exp !== 'hasOwnProperty') {
            // Only cache the value if it's not going to mess up the cache object
            // This is more performant that using Object.prototype.hasOwnProperty.call
            cache[exp] = parsedExpression;
          }

          return parsedExpression;

        case 'function':
          return exp;

        default:
          return noop;
      }
    };
  }];
}

/**
 * @ngdoc service
 * @name ng.$q
 * @requires $rootScope
 *
 * @description
 * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).
 *
 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
 * interface for interacting with an object that represents the result of an action that is
 * performed asynchronously, and may or may not be finished at any given point in time.
 *
 * From the perspective of dealing with error handling, deferred and promise APIs are to
 * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.
 *
 * <pre>
 *   // for the purpose of this example let's assume that variables `$q` and `scope` are
 *   // available in the current lexical scope (they could have been injected or passed in).
 *
 *   function asyncGreet(name) {
 *     var deferred = $q.defer();
 *
 *     setTimeout(function() {
 *       // since this fn executes async in a future turn of the event loop, we need to wrap
 *       // our code into an $apply call so that the model changes are properly observed.
 *       scope.$apply(function() {
 *         deferred.notify('About to greet ' + name + '.');
 *
 *         if (okToGreet(name)) {
 *           deferred.resolve('Hello, ' + name + '!');
 *         } else {
 *           deferred.reject('Greeting ' + name + ' is not allowed.');
 *         }
 *       });
 *     }, 1000);
 *
 *     return deferred.promise;
 *   }
 *
 *   var promise = asyncGreet('Robin Hood');
 *   promise.then(function(greeting) {
 *     alert('Success: ' + greeting);
 *   }, function(reason) {
 *     alert('Failed: ' + reason);
 *   }, function(update) {
 *     alert('Got notification: ' + update);
 *   });
 * </pre>
 *
 * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
 * comes in the way of guarantees that promise and deferred APIs make, see
 * https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.
 *
 * Additionally the promise api allows for composition that is very hard to do with the
 * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
 * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
 * section on serial or parallel joining of promises.
 *
 *
 * # The Deferred API
 *
 * A new instance of deferred is constructed by calling `$q.defer()`.
 *
 * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
 * that can be used for signaling the successful or unsuccessful completion, as well as the status
 * of the task.
 *
 * **Methods**
 *
 * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection
 *   constructed via `$q.reject`, the promise will be rejected instead.
 * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to
 *   resolving it with a rejection constructed via `$q.reject`.
 * - `notify(value)` - provides updates on the status of the promises execution. This may be called
 *   multiple times before the promise is either resolved or rejected.
 *
 * **Properties**
 *
 * - promise – `{Promise}` – promise object associated with this deferred.
 *
 *
 * # The Promise API
 *
 * A new promise instance is created when a deferred instance is created and can be retrieved by
 * calling `deferred.promise`.
 *
 * The purpose of the promise object is to allow for interested parties to get access to the result
 * of the deferred task when it completes.
 *
 * **Methods**
 *
 * - `then(successCallback, errorCallback, notifyCallback)` – regardless of when the promise was or
 *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously
 *   as soon as the result is available. The callbacks are called with a single argument: the result
 *   or rejection reason. Additionally, the notify callback may be called zero or more times to
 *   provide a progress indication, before the promise is resolved or rejected.
 *
 *   This method *returns a new promise* which is resolved or rejected via the return value of the
 *   `successCallback`, `errorCallback`. It also notifies via the return value of the
 *   `notifyCallback` method. The promise can not be resolved or rejected from the notifyCallback
 *   method.
 *
 * - `catch(errorCallback)` – shorthand for `promise.then(null, errorCallback)`
 *
 * - `finally(callback)` – allows you to observe either the fulfillment or rejection of a promise,
 *   but to do so without modifying the final value. This is useful to release resources or do some
 *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
 *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
 *   more information.
 *
 *   Because `finally` is a reserved word in JavaScript and reserved keywords are not supported as
 *   property names by ES3, you'll need to invoke the method like `promise['finally'](callback)` to
 *   make your code IE8 compatible.
 *
 * # Chaining promises
 *
 * Because calling the `then` method of a promise returns a new derived promise, it is easily
 * possible to create a chain of promises:
 *
 * <pre>
 *   promiseB = promiseA.then(function(result) {
 *     return result + 1;
 *   });
 *
 *   // promiseB will be resolved immediately after promiseA is resolved and its value
 *   // will be the result of promiseA incremented by 1
 * </pre>
 *
 * It is possible to create chains of any length and since a promise can be resolved with another
 * promise (which will defer its resolution further), it is possible to pause/defer resolution of
 * the promises at any point in the chain. This makes it possible to implement powerful APIs like
 * $http's response interceptors.
 *
 *
 * # Differences between Kris Kowal's Q and $q
 *
 *  There are two main differences:
 *
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
 *   mechanism in angular, which means faster propagation of resolution or rejection into your
 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
 * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
 *   all the important functionality needed for common async tasks.
 *
 *  # Testing
 *
 *  <pre>
 *    it('should simulate promise', inject(function($q, $rootScope) {
 *      var deferred = $q.defer();
 *      var promise = deferred.promise;
 *      var resolvedValue;
 *
 *      promise.then(function(value) { resolvedValue = value; });
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Simulate resolving of promise
 *      deferred.resolve(123);
 *      // Note that the 'then' function does not get called synchronously.
 *      // This is because we want the promise API to always be async, whether or not
 *      // it got called synchronously or asynchronously.
 *      expect(resolvedValue).toBeUndefined();
 *
 *      // Propagate promise resolution to 'then' functions using $apply().
 *      $rootScope.$apply();
 *      expect(resolvedValue).toEqual(123);
 *    }));
 *  </pre>
 */
function $QProvider() {

  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
    return qFactory(function(callback) {
      $rootScope.$evalAsync(callback);
    }, $exceptionHandler);
  }];
}


/**
 * Constructs a promise manager.
 *
 * @param {function(function)} nextTick Function for executing functions in the next turn.
 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
 *     debugging purposes.
 * @returns {object} Promise manager.
 */
function qFactory(nextTick, exceptionHandler) {

  /**
   * @ngdoc
   * @name ng.$q#defer
   * @methodOf ng.$q
   * @description
   * Creates a `Deferred` object which represents a task which will finish in the future.
   *
   * @returns {Deferred} Returns a new instance of deferred.
   */
  var defer = function() {
    var pending = [],
        value, deferred;

    deferred = {

      resolve: function(val) {
        if (pending) {
          var callbacks = pending;
          pending = undefined;
          value = ref(val);

          if (callbacks.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i < ii; i++) {
                callback = callbacks[i];
                value.then(callback[0], callback[1], callback[2]);
              }
            });
          }
        }
      },


      reject: function(reason) {
        deferred.resolve(reject(reason));
      },


      notify: function(progress) {
        if (pending) {
          var callbacks = pending;

          if (pending.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i < ii; i++) {
                callback = callbacks[i];
                callback[2](progress);
              }
            });
          }
        }
      },


      promise: {
        then: function(callback, errback, progressback) {
          var result = defer();

          var wrappedCallback = function(value) {
            try {
              result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
            } catch(e) {
              result.reject(e);
              exceptionHandler(e);
            }
          };

          var wrappedErrback = function(reason) {
            try {
              result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
            } catch(e) {
              result.reject(e);
              exceptionHandler(e);
            }
          };

          var wrappedProgressback = function(progress) {
            try {
              result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
            } catch(e) {
              exceptionHandler(e);
            }
          };

          if (pending) {
            pending.push([wrappedCallback, wrappedErrback, wrappedProgressback]);
          } else {
            value.then(wrappedCallback, wrappedErrback, wrappedProgressback);
          }

          return result.promise;
        },

        "catch": function(callback) {
          return this.then(null, callback);
        },

        "finally": function(callback) {

          function makePromise(value, resolved) {
            var result = defer();
            if (resolved) {
              result.resolve(value);
            } else {
              result.reject(value);
            }
            return result.promise;
          }

          function handleCallback(value, isResolved) {
            var callbackOutput = null;
            try {
              callbackOutput = (callback ||defaultCallback)();
            } catch(e) {
              return makePromise(e, false);
            }
            if (callbackOutput && isFunction(callbackOutput.then)) {
              return callbackOutput.then(function() {
                return makePromise(value, isResolved);
              }, function(error) {
                return makePromise(error, false);
              });
            } else {
              return makePromise(value, isResolved);
            }
          }

          return this.then(function(value) {
            return handleCallback(value, true);
          }, function(error) {
            return handleCallback(error, false);
          });
        }
      }
    };

    return deferred;
  };


  var ref = function(value) {
    if (value && isFunction(value.then)) return value;
    return {
      then: function(callback) {
        var result = defer();
        nextTick(function() {
          result.resolve(callback(value));
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#reject
   * @methodOf ng.$q
   * @description
   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
   * used to forward rejection in a chain of promises. If you are dealing with the last promise in
   * a promise chain, you don't need to worry about it.
   *
   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
   * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
   * a promise error callback and you want to forward the error to the promise derived from the
   * current promise, you have to "rethrow" the error by returning a rejection constructed via
   * `reject`.
   *
   * <pre>
   *   promiseB = promiseA.then(function(result) {
   *     // success: do something and resolve promiseB
   *     //          with the old or a new result
   *     return result;
   *   }, function(reason) {
   *     // error: handle the error if possible and
   *     //        resolve promiseB with newPromiseOrValue,
   *     //        otherwise forward the rejection to promiseB
   *     if (canHandle(reason)) {
   *      // handle the error and recover
   *      return newPromiseOrValue;
   *     }
   *     return $q.reject(reason);
   *   });
   * </pre>
   *
   * @param {*} reason Constant, message, exception or an object representing the rejection reason.
   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
   */
  var reject = function(reason) {
    return {
      then: function(callback, errback) {
        var result = defer();
        nextTick(function() {
          try {
            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
          } catch(e) {
            result.reject(e);
            exceptionHandler(e);
          }
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#when
   * @methodOf ng.$q
   * @description
   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
   * This is useful when you are dealing with an object that might or might not be a promise, or if
   * the promise comes from a source that can't be trusted.
   *
   * @param {*} value Value or a promise
   * @returns {Promise} Returns a promise of the passed value or promise
   */
  var when = function(value, callback, errback, progressback) {
    var result = defer(),
        done;

    var wrappedCallback = function(value) {
      try {
        return (isFunction(callback) ? callback : defaultCallback)(value);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedErrback = function(reason) {
      try {
        return (isFunction(errback) ? errback : defaultErrback)(reason);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedProgressback = function(progress) {
      try {
        return (isFunction(progressback) ? progressback : defaultCallback)(progress);
      } catch (e) {
        exceptionHandler(e);
      }
    };

    nextTick(function() {
      ref(value).then(function(value) {
        if (done) return;
        done = true;
        result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));
      }, function(reason) {
        if (done) return;
        done = true;
        result.resolve(wrappedErrback(reason));
      }, function(progress) {
        if (done) return;
        result.notify(wrappedProgressback(progress));
      });
    });

    return result.promise;
  };


  function defaultCallback(value) {
    return value;
  }


  function defaultErrback(reason) {
    return reject(reason);
  }


  /**
   * @ngdoc
   * @name ng.$q#all
   * @methodOf ng.$q
   * @description
   * Combines multiple promises into a single promise that is resolved when all of the input
   * promises are resolved.
   *
   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.
   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
   *   each value corresponding to the promise at the same index/key in the `promises` array/hash.
   *   If any of the promises is resolved with a rejection, this resulting promise will be rejected
   *   with the same rejection value.
   */
  function all(promises) {
    var deferred = defer(),
        counter = 0,
        results = isArray(promises) ? [] : {};

    forEach(promises, function(promise, key) {
      counter++;
      ref(promise).then(function(value) {
        if (results.hasOwnProperty(key)) return;
        results[key] = value;
        if (!(--counter)) deferred.resolve(results);
      }, function(reason) {
        if (results.hasOwnProperty(key)) return;
        deferred.reject(reason);
      });
    });

    if (counter === 0) {
      deferred.resolve(results);
    }

    return deferred.promise;
  }

  return {
    defer: defer,
    reject: reject,
    when: when,
    all: all
  };
}

/**
 * DESIGN NOTES
 *
 * The design decisions behind the scope are heavily favored for speed and memory consumption.
 *
 * The typical use of scope is to watch the expressions, which most of the time return the same
 * value as last time so we optimize the operation.
 *
 * Closures construction is expensive in terms of speed as well as memory:
 *   - No closures, instead use prototypical inheritance for API
 *   - Internal state needs to be stored on scope directly, which means that private state is
 *     exposed as $$____ properties
 *
 * Loop operations are optimized by using while(count--) { ... }
 *   - this means that in order to keep the same order of execution as addition we have to add
 *     items to the array at the beginning (shift) instead of at the end (push)
 *
 * Child scopes are created and removed often
 *   - Using an array would be slow since inserts in middle are expensive so we use linked list
 *
 * There are few watches then a lot of observers. This is why you don't want the observer to be
 * implemented in the same way as watch. Watch requires return of initialization function which
 * are expensive to construct.
 */


/**
 * @ngdoc object
 * @name ng.$rootScopeProvider
 * @description
 *
 * Provider for the $rootScope service.
 */

/**
 * @ngdoc function
 * @name ng.$rootScopeProvider#digestTtl
 * @methodOf ng.$rootScopeProvider
 * @description
 *
 * Sets the number of `$digest` iterations the scope should attempt to execute before giving up and
 * assuming that the model is unstable.
 *
 * The current default is 10 iterations.
 *
 * In complex applications it's possible that the dependencies between `$watch`s will result in
 * several digest iterations. However if an application needs more than the default 10 digest
 * iterations for its model to stabilize then you should investigate what is causing the model to
 * continuously change during the digest.
 *
 * Increasing the TTL could have performance implications, so you should not change it without
 * proper justification.
 *
 * @param {number} limit The number of digest iterations.
 */


/**
 * @ngdoc object
 * @name ng.$rootScope
 * @description
 *
 * Every application has a single root {@link ng.$rootScope.Scope scope}.
 * All other scopes are descendant scopes of the root scope. Scopes provide separation
 * between the model and the view, via a mechanism for watching the model for changes.
 * They also provide an event emission/broadcast and subscription facility. See the
 * {@link guide/scope developer guide on scopes}.
 */
function $RootScopeProvider(){
  var TTL = 10;
  var $rootScopeMinErr = minErr('$rootScope');
  var lastDirtyWatch = null;

  this.digestTtl = function(value) {
    if (arguments.length) {
      TTL = value;
    }
    return TTL;
  };

  this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',
      function( $injector,   $exceptionHandler,   $parse,   $browser) {

    /**
     * @ngdoc function
     * @name ng.$rootScope.Scope
     *
     * @description
     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
     * {@link AUTO.$injector $injector}. Child scopes are created using the
     * {@link ng.$rootScope.Scope#methods_$new $new()} method. (Most scopes are created automatically when
     * compiled HTML template is executed.)
     *
     * Here is a simple scope snippet to show how you can interact with the scope.
     * <pre>
     * <file src="./test/ng/rootScopeSpec.js" tag="docs1" />
     * </pre>
     *
     * # Inheritance
     * A scope can inherit from a parent scope, as in this example:
     * <pre>
         var parent = $rootScope;
         var child = parent.$new();

         parent.salutation = "Hello";
         child.name = "World";
         expect(child.salutation).toEqual('Hello');

         child.salutation = "Welcome";
         expect(child.salutation).toEqual('Welcome');
         expect(parent.salutation).toEqual('Hello');
     * </pre>
     *
     *
     * @param {Object.<string, function()>=} providers Map of service factory which need to be
     *                                       provided for the current scope. Defaults to {@link ng}.
     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
     *                              append/override services provided by `providers`. This is handy
     *                              when unit-testing and having the need to override a default
     *                              service.
     * @returns {Object} Newly created scope.
     *
     */
    function Scope() {
      this.$id = nextUid();
      this.$$phase = this.$parent = this.$$watchers =
                     this.$$nextSibling = this.$$prevSibling =
                     this.$$childHead = this.$$childTail = null;
      this['this'] = this.$root =  this;
      this.$$destroyed = false;
      this.$$asyncQueue = [];
      this.$$postDigestQueue = [];
      this.$$listeners = {};
      this.$$isolateBindings = {};
    }

    /**
     * @ngdoc property
     * @name ng.$rootScope.Scope#$id
     * @propertyOf ng.$rootScope.Scope
     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for
     *   debugging.
     */


    Scope.prototype = {
      constructor: Scope,
      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$new
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Creates a new child {@link ng.$rootScope.Scope scope}.
       *
       * The parent scope will propagate the {@link ng.$rootScope.Scope#methods_$digest $digest()} and
       * {@link ng.$rootScope.Scope#methods_$digest $digest()} events. The scope can be removed from the
       * scope hierarchy using {@link ng.$rootScope.Scope#methods_$destroy $destroy()}.
       *
       * {@link ng.$rootScope.Scope#methods_$destroy $destroy()} must be called on a scope when it is
       * desired for the scope and its child scopes to be permanently detached from the parent and
       * thus stop participating in model change detection and listener notification by invoking.
       *
       * @param {boolean} isolate If true, then the scope does not prototypically inherit from the
       *         parent scope. The scope is isolated, as it can not see parent scope properties.
       *         When creating widgets, it is useful for the widget to not accidentally read parent
       *         state.
       *
       * @returns {Object} The newly created child scope.
       *
       */
      $new: function(isolate) {
        var ChildScope,
            child;

        if (isolate) {
          child = new Scope();
          child.$root = this.$root;
          // ensure that there is just one async queue per $rootScope and its children
          child.$$asyncQueue = this.$$asyncQueue;
          child.$$postDigestQueue = this.$$postDigestQueue;
        } else {
          ChildScope = function() {}; // should be anonymous; This is so that when the minifier munges
            // the name it does not become random set of chars. This will then show up as class
            // name in the debugger.
          ChildScope.prototype = this;
          child = new ChildScope();
          child.$id = nextUid();
        }
        child['this'] = child;
        child.$$listeners = {};
        child.$parent = this;
        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
        child.$$prevSibling = this.$$childTail;
        if (this.$$childHead) {
          this.$$childTail.$$nextSibling = child;
          this.$$childTail = child;
        } else {
          this.$$childHead = this.$$childTail = child;
        }
        return child;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watch
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
       *
       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#methods_$digest
       *   $digest()} and should return the value that will be watched. (Since
       *   {@link ng.$rootScope.Scope#methods_$digest $digest()} reruns when it detects changes the
       *   `watchExpression` can execute multiple times per
       *   {@link ng.$rootScope.Scope#methods_$digest $digest()} and should be idempotent.)
       * - The `listener` is called only when the value from the current `watchExpression` and the
       *   previous call to `watchExpression` are not equal (with the exception of the initial run,
       *   see below). The inequality is determined according to
       *   {@link angular.equals} function. To save the value of the object for later comparison,
       *   the {@link angular.copy} function is used. It also means that watching complex options
       *   will have adverse memory and performance implications.
       * - The watch `listener` may change the model, which may trigger other `listener`s to fire.
       *   This is achieved by rerunning the watchers until no changes are detected. The rerun
       *   iteration limit is 10 to prevent an infinite loop deadlock.
       *
       *
       * If you want to be notified whenever {@link ng.$rootScope.Scope#methods_$digest $digest} is called,
       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`
       * can execute multiple times per {@link ng.$rootScope.Scope#methods_$digest $digest} cycle when a
       * change is detected, be prepared for multiple calls to your listener.)
       *
       * After a watcher is registered with the scope, the `listener` fn is called asynchronously
       * (via {@link ng.$rootScope.Scope#methods_$evalAsync $evalAsync}) to initialize the
       * watcher. In rare cases, this is undesirable because the listener is called when the result
       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
       * listener was called due to initialization.
       *
       * The example below contains an illustration of using a function as your $watch listener
       *
       *
       * # Example
       * <pre>
           // let's assume that scope was dependency injected as the $rootScope
           var scope = $rootScope;
           scope.name = 'misko';
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch('name', function(newValue, oldValue) {
             scope.counter = scope.counter + 1;
           });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = 'adam';
           scope.$digest();
           expect(scope.counter).toEqual(1);



           // Using a listener function
           var food;
           scope.foodCounter = 0;
           expect(scope.foodCounter).toEqual(0);
           scope.$watch(
             // This is the listener function
             function() { return food; },
             // This is the change handler
             function(newValue, oldValue) {
               if ( newValue !== oldValue ) {
                 // Only increment the counter if the value changed
                 scope.foodCounter = scope.foodCounter + 1;
               }
             }
           );
           // No digest has been run so the counter will be zero
           expect(scope.foodCounter).toEqual(0);

           // Run the digest but since food has not changed cout will still be zero
           scope.$digest();
           expect(scope.foodCounter).toEqual(0);

           // Update food and run digest.  Now the counter will increment
           food = 'cheeseburger';
           scope.$digest();
           expect(scope.foodCounter).toEqual(1);

       * </pre>
       *
       *
       *
       * @param {(function()|string)} watchExpression Expression that is evaluated on each
       *    {@link ng.$rootScope.Scope#methods_$digest $digest} cycle. A change in the return value triggers
       *    a call to the `listener`.
       *
       *    - `string`: Evaluated as {@link guide/expression expression}
       *    - `function(scope)`: called with current `scope` as a parameter.
       * @param {(function()|string)=} listener Callback called whenever the return value of
       *   the `watchExpression` changes.
       *
       *    - `string`: Evaluated as {@link guide/expression expression}
       *    - `function(newValue, oldValue, scope)`: called with current and previous values as
       *      parameters.
       *
       * @param {boolean=} objectEquality Compare object for equality rather than for reference.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $watch: function(watchExp, listener, objectEquality) {
        var scope = this,
            get = compileToFn(watchExp, 'watch'),
            array = scope.$$watchers,
            watcher = {
              fn: listener,
              last: initWatchVal,
              get: get,
              exp: watchExp,
              eq: !!objectEquality
            };

        lastDirtyWatch = null;

        // in the case user pass string, we need to compile it, do we really need this ?
        if (!isFunction(listener)) {
          var listenFn = compileToFn(listener || noop, 'listener');
          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};
        }

        if (typeof watchExp == 'string' && get.constant) {
          var originalFn = watcher.fn;
          watcher.fn = function(newVal, oldVal, scope) {
            originalFn.call(this, newVal, oldVal, scope);
            arrayRemove(array, watcher);
          };
        }

        if (!array) {
          array = scope.$$watchers = [];
        }
        // we use unshift since we use a while loop in $digest for speed.
        // the while loop reads in reverse order.
        array.unshift(watcher);

        return function() {
          arrayRemove(array, watcher);
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watchCollection
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Shallow watches the properties of an object and fires whenever any of the properties change
       * (for arrays, this implies watching the array items; for object maps, this implies watching
       * the properties). If a change is detected, the `listener` callback is fired.
       *
       * - The `obj` collection is observed via standard $watch operation and is examined on every
       *   call to $digest() to see if any items have been added, removed, or moved.
       * - The `listener` is called whenever anything within the `obj` has changed. Examples include
       *   adding, removing, and moving items belonging to an object or array.
       *
       *
       * # Example
       * <pre>
          $scope.names = ['igor', 'matias', 'misko', 'james'];
          $scope.dataCount = 4;

          $scope.$watchCollection('names', function(newNames, oldNames) {
            $scope.dataCount = newNames.length;
          });

          expect($scope.dataCount).toEqual(4);
          $scope.$digest();

          //still at 4 ... no changes
          expect($scope.dataCount).toEqual(4);

          $scope.names.pop();
          $scope.$digest();

          //now there's been a change
          expect($scope.dataCount).toEqual(3);
       * </pre>
       *
       *
       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The
       *    expression value should evaluate to an object or an array which is observed on each
       *    {@link ng.$rootScope.Scope#methods_$digest $digest} cycle. Any shallow change within the
       *    collection will trigger a call to the `listener`.
       *
       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is
       *    fired with both the `newCollection` and `oldCollection` as parameters.
       *    The `newCollection` object is the newly modified data obtained from the `obj` expression
       *    and the `oldCollection` object is a copy of the former collection data.
       *    The `scope` refers to the current scope.
       *
       * @returns {function()} Returns a de-registration function for this listener. When the
       *    de-registration function is executed, the internal watch operation is terminated.
       */
      $watchCollection: function(obj, listener) {
        var self = this;
        var oldValue;
        var newValue;
        var changeDetected = 0;
        var objGetter = $parse(obj);
        var internalArray = [];
        var internalObject = {};
        var oldLength = 0;

        function $watchCollectionWatch() {
          newValue = objGetter(self);
          var newLength, key;

          if (!isObject(newValue)) {
            if (oldValue !== newValue) {
              oldValue = newValue;
              changeDetected++;
            }
          } else if (isArrayLike(newValue)) {
            if (oldValue !== internalArray) {
              // we are transitioning from something which was not an array into array.
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            }

            newLength = newValue.length;

            if (oldLength !== newLength) {
              // if lengths do not match we need to trigger change notification
              changeDetected++;
              oldValue.length = oldLength = newLength;
            }
            // copy the items to oldValue and look for changes.
            for (var i = 0; i < newLength; i++) {
              if (oldValue[i] !== newValue[i]) {
                changeDetected++;
                oldValue[i] = newValue[i];
              }
            }
          } else {
            if (oldValue !== internalObject) {
              // we are transitioning from something which was not an object into object.
              oldValue = internalObject = {};
              oldLength = 0;
              changeDetected++;
            }
            // copy the items to oldValue and look for changes.
            newLength = 0;
            for (key in newValue) {
              if (newValue.hasOwnProperty(key)) {
                newLength++;
                if (oldValue.hasOwnProperty(key)) {
                  if (oldValue[key] !== newValue[key]) {
                    changeDetected++;
                    oldValue[key] = newValue[key];
                  }
                } else {
                  oldLength++;
                  oldValue[key] = newValue[key];
                  changeDetected++;
                }
              }
            }
            if (oldLength > newLength) {
              // we used to have more keys, need to find them and destroy them.
              changeDetected++;
              for(key in oldValue) {
                if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                  oldLength--;
                  delete oldValue[key];
                }
              }
            }
          }
          return changeDetected;
        }

        function $watchCollectionAction() {
          listener(newValue, oldValue, self);
        }

        return this.$watch($watchCollectionWatch, $watchCollectionAction);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$digest
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Processes all of the {@link ng.$rootScope.Scope#methods_$watch watchers} of the current scope and
       * its children. Because a {@link ng.$rootScope.Scope#methods_$watch watcher}'s listener can change
       * the model, the `$digest()` keeps calling the {@link ng.$rootScope.Scope#methods_$watch watchers}
       * until no more listeners are firing. This means that it is possible to get into an infinite
       * loop. This function will throw `'Maximum iteration limit exceeded.'` if the number of
       * iterations exceeds 10.
       *
       * Usually, you don't call `$digest()` directly in
       * {@link ng.directive:ngController controllers} or in
       * {@link ng.$compileProvider#methods_directive directives}.
       * Instead, you should call {@link ng.$rootScope.Scope#methods_$apply $apply()} (typically from within
       * a {@link ng.$compileProvider#methods_directive directives}), which will force a `$digest()`.
       *
       * If you want to be notified whenever `$digest()` is called,
       * you can register a `watchExpression` function with
       * {@link ng.$rootScope.Scope#methods_$watch $watch()} with no `listener`.
       *
       * In unit tests, you may need to call `$digest()` to simulate the scope life cycle.
       *
       * # Example
       * <pre>
           var scope = ...;
           scope.name = 'misko';
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch('name', function(newValue, oldValue) {
             scope.counter = scope.counter + 1;
           });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = 'adam';
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * </pre>
       *
       */
      $digest: function() {
        var watch, value, last,
            watchers,
            asyncQueue = this.$$asyncQueue,
            postDigestQueue = this.$$postDigestQueue,
            length,
            dirty, ttl = TTL,
            next, current, target = this,
            watchLog = [],
            logIdx, logMsg, asyncTask;

        beginPhase('$digest');

        lastDirtyWatch = null;

        do { // "while dirty" loop
          dirty = false;
          current = target;

          while(asyncQueue.length) {
            try {
              asyncTask = asyncQueue.shift();
              asyncTask.scope.$eval(asyncTask.expression);
            } catch (e) {
              clearPhase();
              $exceptionHandler(e);
            }
            lastDirtyWatch = null;
          }

          traverseScopesLoop:
          do { // "traverse the scopes" loop
            if ((watchers = current.$$watchers)) {
              // process our watches
              length = watchers.length;
              while (length--) {
                try {
                  watch = watchers[length];
                  // Most common watches are on primitives, in which case we can short
                  // circuit it with === operator, only when === fails do we use .equals
                  if (watch) {
                    if ((value = watch.get(current)) !== (last = watch.last) &&
                        !(watch.eq
                            ? equals(value, last)
                            : (typeof value == 'number' && typeof last == 'number'
                               && isNaN(value) && isNaN(last)))) {
                      dirty = true;
                      lastDirtyWatch = watch;
                      watch.last = watch.eq ? copy(value) : value;
                      watch.fn(value, ((last === initWatchVal) ? value : last), current);
                      if (ttl < 5) {
                        logIdx = 4 - ttl;
                        if (!watchLog[logIdx]) watchLog[logIdx] = [];
                        logMsg = (isFunction(watch.exp))
                            ? 'fn: ' + (watch.exp.name || watch.exp.toString())
                            : watch.exp;
                        logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                        watchLog[logIdx].push(logMsg);
                      }
                    } else if (watch === lastDirtyWatch) {
                      // If the most recently dirty watcher is now clean, short circuit since the remaining watchers
                      // have already been tested.
                      dirty = false;
                      break traverseScopesLoop;
                    }
                  }
                } catch (e) {
                  clearPhase();
                  $exceptionHandler(e);
                }
              }
            }

            // Insanity Warning: scope depth-first traversal
            // yes, this code is a bit crazy, but it works and we have tests to prove it!
            // this piece should be kept in sync with the traversal in $broadcast
            if (!(next = (current.$$childHead ||
                (current !== target && current.$$nextSibling)))) {
              while(current !== target && !(next = current.$$nextSibling)) {
                current = current.$parent;
              }
            }
          } while ((current = next));

          // `break traverseScopesLoop;` takes us to here

          if(dirty && !(ttl--)) {
            clearPhase();
            throw $rootScopeMinErr('infdig',
                '{0} $digest() iterations reached. Aborting!\n' +
                'Watchers fired in the last 5 iterations: {1}',
                TTL, toJson(watchLog));
          }

        } while (dirty || asyncQueue.length);

        clearPhase();

        while(postDigestQueue.length) {
          try {
            postDigestQueue.shift()();
          } catch (e) {
            $exceptionHandler(e);
          }
        }
      },


      /**
       * @ngdoc event
       * @name ng.$rootScope.Scope#$destroy
       * @eventOf ng.$rootScope.Scope
       * @eventType broadcast on scope being destroyed
       *
       * @description
       * Broadcasted when a scope and its children are being destroyed.
       *
       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
       * clean up DOM bindings before an element is removed from the DOM.
       */

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$destroy
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Removes the current scope (and all of its children) from the parent scope. Removal implies
       * that calls to {@link ng.$rootScope.Scope#methods_$digest $digest()} will no longer
       * propagate to the current scope and its children. Removal also implies that the current
       * scope is eligible for garbage collection.
       *
       * The `$destroy()` is usually used by directives such as
       * {@link ng.directive:ngRepeat ngRepeat} for managing the
       * unrolling of the loop.
       *
       * Just before a scope is destroyed, a `$destroy` event is broadcasted on this scope.
       * Application code can register a `$destroy` event handler that will give it a chance to
       * perform any necessary cleanup.
       *
       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to
       * clean up DOM bindings before an element is removed from the DOM.
       */
      $destroy: function() {
        // we can't destroy the root scope or a scope that has been already destroyed
        if (this.$$destroyed) return;
        var parent = this.$parent;

        this.$broadcast('$destroy');
        this.$$destroyed = true;
        if (this === $rootScope) return;

        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        // This is bogus code that works around Chrome's GC leak
        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
            this.$$childTail = null;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$eval
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the `expression` on the current scope and returns the result. Any exceptions in
       * the expression are propagated (uncaught). This is useful when evaluating Angular
       * expressions.
       *
       * # Example
       * <pre>
           var scope = ng.$rootScope.Scope();
           scope.a = 1;
           scope.b = 2;

           expect(scope.$eval('a+b')).toEqual(3);
           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
       * </pre>
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with the current `scope` parameter.
       *
       * @param {(object)=} locals Local variables object, useful for overriding values in scope.
       * @returns {*} The result of evaluating the expression.
       */
      $eval: function(expr, locals) {
        return $parse(expr)(this, locals);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$evalAsync
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the expression on the current scope at a later point in time.
       *
       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only
       * that:
       *
       *   - it will execute after the function that scheduled the evaluation (preferably before DOM
       *     rendering).
       *   - at least one {@link ng.$rootScope.Scope#methods_$digest $digest cycle} will be performed after
       *     `expression` execution.
       *
       * Any exceptions from the execution of the expression are forwarded to the
       * {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle
       * will be scheduled. However, it is encouraged to always call code that changes the model
       * from within an `$apply` call. That includes code evaluated via `$evalAsync`.
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with the current `scope` parameter.
       *
       */
      $evalAsync: function(expr) {
        // if we are outside of an $digest loop and this is the first time we are scheduling async
        // task also schedule async auto-flush
        if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {
          $browser.defer(function() {
            if ($rootScope.$$asyncQueue.length) {
              $rootScope.$digest();
            }
          });
        }

        this.$$asyncQueue.push({scope: this, expression: expr});
      },

      $$postDigest : function(fn) {
        this.$$postDigestQueue.push(fn);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$apply
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * `$apply()` is used to execute an expression in angular from outside of the angular
       * framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).
       * Because we are calling into the angular framework we need to perform proper scope life
       * cycle of {@link ng.$exceptionHandler exception handling},
       * {@link ng.$rootScope.Scope#methods_$digest executing watches}.
       *
       * ## Life cycle
       *
       * # Pseudo-Code of `$apply()`
       * <pre>
           function $apply(expr) {
             try {
               return $eval(expr);
             } catch (e) {
               $exceptionHandler(e);
             } finally {
               $root.$digest();
             }
           }
       * </pre>
       *
       *
       * Scope's `$apply()` method transitions through the following stages:
       *
       * 1. The {@link guide/expression expression} is executed using the
       *    {@link ng.$rootScope.Scope#methods_$eval $eval()} method.
       * 2. Any exceptions from the execution of the expression are forwarded to the
       *    {@link ng.$exceptionHandler $exceptionHandler} service.
       * 3. The {@link ng.$rootScope.Scope#methods_$watch watch} listeners are fired immediately after the
       *    expression was executed using the {@link ng.$rootScope.Scope#methods_$digest $digest()} method.
       *
       *
       * @param {(string|function())=} exp An angular expression to be executed.
       *
       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.
       *    - `function(scope)`: execute the function with current `scope` parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $apply: function(expr) {
        try {
          beginPhase('$apply');
          return this.$eval(expr);
        } catch (e) {
          $exceptionHandler(e);
        } finally {
          clearPhase();
          try {
            $rootScope.$digest();
          } catch (e) {
            $exceptionHandler(e);
            throw e;
          }
        }
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$on
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Listens on events of a given type. See {@link ng.$rootScope.Scope#methods_$emit $emit} for
       * discussion of event life cycle.
       *
       * The event listener function format is: `function(event, args...)`. The `event` object
       * passed into the listener has the following attributes:
       *
       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or
       *     `$broadcast`-ed.
       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.
       *   - `name` - `{string}`: name of the event.
       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel
       *     further event propagation (available only for events that were `$emit`-ed).
       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag
       *     to true.
       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.
       *
       * @param {string} name Event name to listen on.
       * @param {function(event, args...)} listener Function to call when the event is emitted.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $on: function(name, listener) {
        var namedListeners = this.$$listeners[name];
        if (!namedListeners) {
          this.$$listeners[name] = namedListeners = [];
        }
        namedListeners.push(listener);

        return function() {
          namedListeners[indexOf(namedListeners, listener)] = null;
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$emit
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event `name` upwards through the scope hierarchy notifying the
       * registered {@link ng.$rootScope.Scope#methods_$on} listeners.
       *
       * The event life cycle starts at the scope on which `$emit` was called. All
       * {@link ng.$rootScope.Scope#methods_$on listeners} listening for `name` event on this scope get
       * notified. Afterwards, the event traverses upwards toward the root scope and calls all
       * registered listeners along the way. The event will stop propagating if one of the listeners
       * cancels it.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#methods_$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to emit.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object (see {@link ng.$rootScope.Scope#methods_$on}).
       */
      $emit: function(name, args) {
        var empty = [],
            namedListeners,
            scope = this,
            stopPropagation = false,
            event = {
              name: name,
              targetScope: scope,
              stopPropagation: function() {stopPropagation = true;},
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            i, length;

        do {
          namedListeners = scope.$$listeners[name] || empty;
          event.currentScope = scope;
          for (i=0, length=namedListeners.length; i<length; i++) {

            // if listeners were deregistered, defragment the array
            if (!namedListeners[i]) {
              namedListeners.splice(i, 1);
              i--;
              length--;
              continue;
            }
            try {
              //allow all listeners attached to the current scope to run
              namedListeners[i].apply(null, listenerArgs);
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          //if any listener on the current scope stops propagation, prevent bubbling
          if (stopPropagation) return event;
          //traverse upwards
          scope = scope.$parent;
        } while (scope);

        return event;
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$broadcast
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
       * registered {@link ng.$rootScope.Scope#methods_$on} listeners.
       *
       * The event life cycle starts at the scope on which `$broadcast` was called. All
       * {@link ng.$rootScope.Scope#methods_$on listeners} listening for `name` event on this scope get
       * notified. Afterwards, the event propagates to all direct and indirect scopes of the current
       * scope and calls all registered listeners along the way. The event cannot be canceled.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#methods_$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to broadcast.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#methods_$on}
       */
      $broadcast: function(name, args) {
        var target = this,
            current = target,
            next = target,
            event = {
              name: name,
              targetScope: target,
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            listeners, i, length;

        //down while you can, then up and next sibling or up and next sibling until back at root
        do {
          current = next;
          event.currentScope = current;
          listeners = current.$$listeners[name] || [];
          for (i=0, length = listeners.length; i<length; i++) {
            // if listeners were deregistered, defragment the array
            if (!listeners[i]) {
              listeners.splice(i, 1);
              i--;
              length--;
              continue;
            }

            try {
              listeners[i].apply(null, listenerArgs);
            } catch(e) {
              $exceptionHandler(e);
            }
          }

          // Insanity Warning: scope depth-first traversal
          // yes, this code is a bit crazy, but it works and we have tests to prove it!
          // this piece should be kept in sync with the traversal in $digest
          if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
            while(current !== target && !(next = current.$$nextSibling)) {
              current = current.$parent;
            }
          }
        } while ((current = next));

        return event;
      }
    };

    var $rootScope = new Scope();

    return $rootScope;


    function beginPhase(phase) {
      if ($rootScope.$$phase) {
        throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
      }

      $rootScope.$$phase = phase;
    }

    function clearPhase() {
      $rootScope.$$phase = null;
    }

    function compileToFn(exp, name) {
      var fn = $parse(exp);
      assertArgFn(fn, name);
      return fn;
    }

    /**
     * function used as an initial value for watchers.
     * because it's unique we can easily tell it apart from other values
     */
    function initWatchVal() {}
  }];
}

/**
 * @description
 * Private service to sanitize uris for links and images. Used by $compile and $sanitize.
 */
function $$SanitizeUriProvider() {
  var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
    imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;

  /**
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.aHrefSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      aHrefSanitizationWhitelist = regexp;
      return this;
    }
    return aHrefSanitizationWhitelist;
  };


  /**
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during img[src] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
   * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`
   * regular expression. If a match is found, the original url is written into the dom. Otherwise,
   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.imgSrcSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      imgSrcSanitizationWhitelist = regexp;
      return this;
    }
    return imgSrcSanitizationWhitelist;
  };

  this.$get = function() {
    return function sanitizeUri(uri, isImage) {
      var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
      var normalizedVal;
      // NOTE: urlResolve() doesn't support IE < 8 so we don't sanitize for that case.
      if (!msie || msie >= 8 ) {
        normalizedVal = urlResolve(uri).href;
        if (normalizedVal !== '' && !normalizedVal.match(regex)) {
          return 'unsafe:'+normalizedVal;
        }
      }
      return uri;
    };
  };
}

var $sceMinErr = minErr('$sce');

var SCE_CONTEXTS = {
  HTML: 'html',
  CSS: 'css',
  URL: 'url',
  // RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a
  // url.  (e.g. ng-include, script src, templateUrl)
  RESOURCE_URL: 'resourceUrl',
  JS: 'js'
};

// Helper functions follow.

// Copied from:
// http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962
// Prereq: s is a string.
function escapeForRegexp(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
           replace(/\x08/g, '\\x08');
}


function adjustMatcher(matcher) {
  if (matcher === 'self') {
    return matcher;
  } else if (isString(matcher)) {
    // Strings match exactly except for 2 wildcards - '*' and '**'.
    // '*' matches any character except those from the set ':/.?&'.
    // '**' matches any character (like .* in a RegExp).
    // More than 2 *'s raises an error as it's ill defined.
    if (matcher.indexOf('***') > -1) {
      throw $sceMinErr('iwcard',
          'Illegal sequence *** in string matcher.  String: {0}', matcher);
    }
    matcher = escapeForRegexp(matcher).
                  replace('\\*\\*', '.*').
                  replace('\\*', '[^:/.?&;]*');
    return new RegExp('^' + matcher + '$');
  } else if (isRegExp(matcher)) {
    // The only other type of matcher allowed is a Regexp.
    // Match entire URL / disallow partial matches.
    // Flags are reset (i.e. no global, ignoreCase or multiline)
    return new RegExp('^' + matcher.source + '$');
  } else {
    throw $sceMinErr('imatcher',
        'Matchers may only be "self", string patterns or RegExp objects');
  }
}


function adjustMatchers(matchers) {
  var adjustedMatchers = [];
  if (isDefined(matchers)) {
    forEach(matchers, function(matcher) {
      adjustedMatchers.push(adjustMatcher(matcher));
    });
  }
  return adjustedMatchers;
}


/**
 * @ngdoc service
 * @name ng.$sceDelegate
 * @function
 *
 * @description
 *
 * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
 * Contextual Escaping (SCE)} services to AngularJS.
 *
 * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
 * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is
 * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
 * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
 * work because `$sce` delegates to `$sceDelegate` for these operations.
 *
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
 *
 * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
 * can override it completely to change the behavior of `$sce`, the common case would
 * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
 * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as
 * templates.  Refer {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist
 * $sceDelegateProvider.resourceUrlWhitelist} and {@link
 * ng.$sceDelegateProvider#methods_resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
 */

/**
 * @ngdoc object
 * @name ng.$sceDelegateProvider
 * @description
 *
 * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
 * $sceDelegate} service.  This allows one to get/set the whitelists and blacklists used to ensure
 * that the URLs used for sourcing Angular templates are safe.  Refer {@link
 * ng.$sceDelegateProvider#methods_resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and
 * {@link ng.$sceDelegateProvider#methods_resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}
 *
 * For the general details about this service in Angular, read the main page for {@link ng.$sce
 * Strict Contextual Escaping (SCE)}.
 *
 * **Example**:  Consider the following case. <a name="example"></a>
 *
 * - your app is hosted at url `http://myapp.example.com/`
 * - but some of your templates are hosted on other domains you control such as
 *   `http://srv01.assets.example.com/`,  `http://srv02.assets.example.com/`, etc.
 * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.
 *
 * Here is what a secure configuration for this scenario might look like:
 *
 * <pre class="prettyprint">
 *    angular.module('myApp', []).config(function($sceDelegateProvider) {
 *      $sceDelegateProvider.resourceUrlWhitelist([
 *        // Allow same origin resource loads.
 *        'self',
 *        // Allow loading from our assets domain.  Notice the difference between * and **.
 *        'http://srv*.assets.example.com/**']);
 *
 *      // The blacklist overrides the whitelist so the open redirect here is blocked.
 *      $sceDelegateProvider.resourceUrlBlacklist([
 *        'http://myapp.example.com/clickThru**']);
 *      });
 * </pre>
 */

function $SceDelegateProvider() {
  this.SCE_CONTEXTS = SCE_CONTEXTS;

  // Resource URLs can also be trusted by policy.
  var resourceUrlWhitelist = ['self'],
      resourceUrlBlacklist = [];

  /**
   * @ngdoc function
   * @name ng.sceDelegateProvider#resourceUrlWhitelist
   * @methodOf ng.$sceDelegateProvider
   * @function
   *
   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value
   *     provided.  This must be an array or null.  A snapshot of this array is used so further
   *     changes to the array are ignored.
   *
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
   *     allowed in this array.
   *
   *     Note: **an empty whitelist array will block all URLs**!
   *
   * @return {Array} the currently set whitelist array.
   *
   * The **default value** when no whitelist has been explicitly set is `['self']` allowing only
   * same origin resource requests.
   *
   * @description
   * Sets/Gets the whitelist of trusted resource URLs.
   */
  this.resourceUrlWhitelist = function (value) {
    if (arguments.length) {
      resourceUrlWhitelist = adjustMatchers(value);
    }
    return resourceUrlWhitelist;
  };

  /**
   * @ngdoc function
   * @name ng.sceDelegateProvider#resourceUrlBlacklist
   * @methodOf ng.$sceDelegateProvider
   * @function
   *
   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value
   *     provided.  This must be an array or null.  A snapshot of this array is used so further
   *     changes to the array are ignored.
   *
   *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
   *     allowed in this array.
   *
   *     The typical usage for the blacklist is to **block
   *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as
   *     these would otherwise be trusted but actually return content from the redirected domain.
   *
   *     Finally, **the blacklist overrides the whitelist** and has the final say.
   *
   * @return {Array} the currently set blacklist array.
   *
   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there
   * is no blacklist.)
   *
   * @description
   * Sets/Gets the blacklist of trusted resource URLs.
   */

  this.resourceUrlBlacklist = function (value) {
    if (arguments.length) {
      resourceUrlBlacklist = adjustMatchers(value);
    }
    return resourceUrlBlacklist;
  };

  this.$get = ['$injector', function($injector) {

    var htmlSanitizer = function htmlSanitizer(html) {
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
    };

    if ($injector.has('$sanitize')) {
      htmlSanitizer = $injector.get('$sanitize');
    }


    function matchUrl(matcher, parsedUrl) {
      if (matcher === 'self') {
        return urlIsSameOrigin(parsedUrl);
      } else {
        // definitely a regex.  See adjustMatchers()
        return !!matcher.exec(parsedUrl.href);
      }
    }

    function isResourceUrlAllowedByPolicy(url) {
      var parsedUrl = urlResolve(url.toString());
      var i, n, allowed = false;
      // Ensure that at least one item from the whitelist allows this url.
      for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
          allowed = true;
          break;
        }
      }
      if (allowed) {
        // Ensure that no item from the blacklist blocked this url.
        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
            allowed = false;
            break;
          }
        }
      }
      return allowed;
    }

    function generateHolderType(Base) {
      var holderType = function TrustedValueHolderType(trustedValue) {
        this.$$unwrapTrustedValue = function() {
          return trustedValue;
        };
      };
      if (Base) {
        holderType.prototype = new Base();
      }
      holderType.prototype.valueOf = function sceValueOf() {
        return this.$$unwrapTrustedValue();
      };
      holderType.prototype.toString = function sceToString() {
        return this.$$unwrapTrustedValue().toString();
      };
      return holderType;
    }

    var trustedValueHolderBase = generateHolderType(),
        byType = {};

    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#trustAs
     * @methodOf ng.$sceDelegate
     *
     * @description
     * Returns an object that is trusted by angular for use in specified strict
     * contextual escaping contexts (such as ng-html-bind-unsafe, ng-include, any src
     * attribute interpolation, any dom event binding attribute interpolation
     * such as for onclick,  etc.) that uses the provided value.
     * See {@link ng.$sce $sce} for enabling strict contextual escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resourceUrl, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */
    function trustAs(type, trustedValue) {
      var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      if (!Constructor) {
        throw $sceMinErr('icontext',
            'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',
            type, trustedValue);
      }
      if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
        return trustedValue;
      }
      // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
      // mutable objects, we ensure here that the value passed in is actually a string.
      if (typeof trustedValue !== 'string') {
        throw $sceMinErr('itype',
            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',
            type);
      }
      return new Constructor(trustedValue);
    }

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#valueOf
     * @methodOf ng.$sceDelegate
     *
     * @description
     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#methods_trustAs
     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link
     * ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}.
     *
     * If the passed parameter is not a value that had been returned by {@link
     * ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}, returns it as-is.
     *
     * @param {*} value The result of a prior {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}
     *      call or anything else.
     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#methods_trustAs
     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns
     *     `value` unchanged.
     */
    function valueOf(maybeTrusted) {
      if (maybeTrusted instanceof trustedValueHolderBase) {
        return maybeTrusted.$$unwrapTrustedValue();
      } else {
        return maybeTrusted;
      }
    }

    /**
     * @ngdoc method
     * @name ng.$sceDelegate#getTrusted
     * @methodOf ng.$sceDelegate
     *
     * @description
     * Takes the result of a {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`} call and
     * returns the originally supplied value if the queried context type is a supertype of the
     * created type.  If this condition isn't satisfied, throws an exception.
     *
     * @param {string} type The kind of context in which this value is to be used.
     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#methods_trustAs
     *     `$sceDelegate.trustAs`} call.
     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#methods_trustAs
     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.
     */
    function getTrusted(type, maybeTrusted) {
      if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
        return maybeTrusted;
      }
      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
      if (constructor && maybeTrusted instanceof constructor) {
        return maybeTrusted.$$unwrapTrustedValue();
      }
      // If we get here, then we may only take one of two actions.
      // 1. sanitize the value for the requested type, or
      // 2. throw an exception.
      if (type === SCE_CONTEXTS.RESOURCE_URL) {
        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
          return maybeTrusted;
        } else {
          throw $sceMinErr('insecurl',
              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}',
              maybeTrusted.toString());
        }
      } else if (type === SCE_CONTEXTS.HTML) {
        return htmlSanitizer(maybeTrusted);
      }
      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
    }

    return { trustAs: trustAs,
             getTrusted: getTrusted,
             valueOf: valueOf };
  }];
}


/**
 * @ngdoc object
 * @name ng.$sceProvider
 * @description
 *
 * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.
 * -   enable/disable Strict Contextual Escaping (SCE) in a module
 * -   override the default implementation with a custom delegate
 *
 * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.
 */

/* jshint maxlen: false*/

/**
 * @ngdoc service
 * @name ng.$sce
 * @function
 *
 * @description
 *
 * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.
 *
 * # Strict Contextual Escaping
 *
 * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain
 * contexts to result in a value that is marked as safe to use for that context.  One example of
 * such a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer
 * to these contexts as privileged or SCE contexts.
 *
 * As of version 1.2, Angular ships with SCE enabled by default.
 *
 * Note:  When enabled (the default), IE8 in quirks mode is not supported.  In this mode, IE8 allows
 * one to execute arbitrary javascript by the use of the expression() syntax.  Refer
 * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.
 * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`
 * to the top of your HTML document.
 *
 * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for
 * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.
 *
 * Here's an example of a binding in a privileged context:
 *
 * <pre class="prettyprint">
 *     <input ng-model="userHtml">
 *     <div ng-bind-html="userHtml">
 * </pre>
 *
 * Notice that `ng-bind-html` is bound to `userHtml` controlled by the user.  With SCE
 * disabled, this application allows the user to render arbitrary HTML into the DIV.
 * In a more realistic example, one may be rendering user comments, blog articles, etc. via
 * bindings.  (HTML is just one example of a context where rendering user controlled input creates
 * security vulnerabilities.)
 *
 * For the case of HTML, you might use a library, either on the client side, or on the server side,
 * to sanitize unsafe HTML before binding to the value and rendering it in the document.
 *
 * How would you ensure that every place that used these types of bindings was bound to a value that
 * was sanitized by your library (or returned as safe for rendering by your server?)  How can you
 * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some
 * properties/fields and forgot to update the binding to the sanitized value?
 *
 * To be secure by default, you want to ensure that any such bindings are disallowed unless you can
 * determine that something explicitly says it's safe to use a value for binding in that
 * context.  You can then audit your code (a simple grep would do) to ensure that this is only done
 * for those values that you can easily tell are safe - because they were received from your server,
 * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps
 * allowing only the files in a specific directory to do this.  Ensuring that the internal API
 * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.
 *
 * In the case of AngularJS' SCE service, one uses {@link ng.$sce#methods_trustAs $sce.trustAs} 
 * (and shorthand methods such as {@link ng.$sce#methods_trustAsHtml $sce.trustAsHtml}, etc.) to
 * obtain values that will be accepted by SCE / privileged contexts.
 *
 *
 * ## How does it work?
 *
 * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#methods_getTrusted
 * $sce.getTrusted(context, value)} rather than to the value directly.  Directives use {@link
 * ng.$sce#methods_parse $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the
 * {@link ng.$sce#methods_getTrusted $sce.getTrusted} behind the scenes on non-constant literals.
 *
 * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link
 * ng.$sce#methods_parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly
 * simplified):
 *
 * <pre class="prettyprint">
 *   var ngBindHtmlDirective = ['$sce', function($sce) {
 *     return function(scope, element, attr) {
 *       scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {
 *         element.html(value || '');
 *       });
 *     };
 *   }];
 * </pre>
 *
 * ## Impact on loading templates
 *
 * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as
 * `templateUrl`'s specified by {@link guide/directive directives}.
 *
 * By default, Angular only loads templates from the same domain and protocol as the application
 * document.  This is done by calling {@link ng.$sce#methods_getTrustedResourceUrl
 * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or
 * protocols, you may either either {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist whitelist
 * them} or {@link ng.$sce#methods_trustAsResourceUrl wrap it} into a trusted value.
 *
 * *Please note*:
 * The browser's
 * {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest
 * Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing (CORS)}
 * policy apply in addition to this and may further restrict whether the template is successfully
 * loaded.  This means that without the right CORS policy, loading templates from a different domain
 * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some
 * browsers.
 *
 * ## This feels like too much overhead for the developer?
 *
 * It's important to remember that SCE only applies to interpolation expressions.
 *
 * If your expressions are constant literals, they're automatically trusted and you don't need to
 * call `$sce.trustAs` on them.  (e.g.
 * `<div ng-html-bind-unsafe="'<b>implicitly trusted</b>'"></div>`) just works.
 *
 * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them
 * through {@link ng.$sce#methods_getTrusted $sce.getTrusted}.  SCE doesn't play a role here.
 *
 * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load
 * templates in `ng-include` from your application's domain without having to even know about SCE.
 * It blocks loading templates from other domains or loading templates over http from an https
 * served document.  You can change these by setting your own custom {@link
 * ng.$sceDelegateProvider#methods_resourceUrlWhitelist whitelists} and {@link
 * ng.$sceDelegateProvider#methods_resourceUrlBlacklist blacklists} for matching such URLs.
 *
 * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an
 * application that's secure and can be audited to verify that with much more ease than bolting
 * security onto an application later.
 *
 * <a name="contexts"></a>
 * ## What trusted context types are supported?
 *
 * | Context             | Notes          |
 * |---------------------|----------------|
 * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. |
 * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |
 * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't consititute an SCE context. |
 * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contens are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |
 * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |
 *
 * ## Format of items in {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist resourceUrlWhitelist}/{@link ng.$sceDelegateProvider#methods_resourceUrlBlacklist Blacklist} <a name="resourceUrlPatternItem"></a>
 *
 *  Each element in these arrays must be one of the following:
 *
 *  - **'self'**
 *    - The special **string**, `'self'`, can be used to match against all URLs of the **same
 *      domain** as the application document using the **same protocol**.
 *  - **String** (except the special value `'self'`)
 *    - The string is matched against the full *normalized / absolute URL* of the resource
 *      being tested (substring matches are not good enough.)
 *    - There are exactly **two wildcard sequences** - `*` and `**`.  All other characters
 *      match themselves.
 *    - `*`: matches zero or more occurances of any character other than one of the following 6
 *      characters: '`:`', '`/`', '`.`', '`?`', '`&`' and ';'.  It's a useful wildcard for use
 *      in a whitelist.
 *    - `**`: matches zero or more occurances of *any* character.  As such, it's not
 *      not appropriate to use in for a scheme, domain, etc. as it would match too much.  (e.g.
 *      http://**.example.com/ would match http://evil.com/?ignore=.example.com/ and that might
 *      not have been the intention.)  It's usage at the very end of the path is ok.  (e.g.
 *      http://foo.example.com/templates/**).
 *  - **RegExp** (*see caveat below*)
 *    - *Caveat*:  While regular expressions are powerful and offer great flexibility,  their syntax
 *      (and all the inevitable escaping) makes them *harder to maintain*.  It's easy to
 *      accidentally introduce a bug when one updates a complex expression (imho, all regexes should
 *      have good test coverage.).  For instance, the use of `.` in the regex is correct only in a
 *      small number of cases.  A `.` character in the regex used when matching the scheme or a
 *      subdomain could be matched against a `:` or literal `.` that was likely not intended.   It
 *      is highly recommended to use the string patterns and only fall back to regular expressions
 *      if they as a last resort.
 *    - The regular expression must be an instance of RegExp (i.e. not a string.)  It is
 *      matched against the **entire** *normalized / absolute URL* of the resource being tested
 *      (even when the RegExp did not have the `^` and `$` codes.)  In addition, any flags
 *      present on the RegExp (such as multiline, global, ignoreCase) are ignored.
 *    - If you are generating your Javascript from some other templating engine (not
 *      recommended, e.g. in issue [#4006](https://github.com/angular/angular.js/issues/4006)),
 *      remember to escape your regular expression (and be aware that you might need more than
 *      one level of escaping depending on your templating engine and the way you interpolated
 *      the value.)  Do make use of your platform's escaping mechanism as it might be good
 *      enough before coding your own.  e.g. Ruby has
 *      [Regexp.escape(str)](http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape)
 *      and Python has [re.escape](http://docs.python.org/library/re.html#re.escape).
 *      Javascript lacks a similar built in function for escaping.  Take a look at Google
 *      Closure library's [goog.string.regExpEscape(s)](
 *      http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962).
 *
 * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} for an example.
 *
 * ## Show me an example using SCE.
 *
 * @example
<example module="mySceApp">
<file name="index.html">
  <div ng-controller="myAppController as myCtrl">
    <i ng-bind-html="myCtrl.explicitlyTrustedHtml" id="explicitlyTrustedHtml"></i><br><br>
    <b>User comments</b><br>
    By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when
    $sanitize is available.  If $sanitize isn't available, this results in an error instead of an
    exploit.
    <div class="well">
      <div ng-repeat="userComment in myCtrl.userComments">
        <b>{{userComment.name}}</b>:
        <span ng-bind-html="userComment.htmlComment" class="htmlComment"></span>
        <br>
      </div>
    </div>
  </div>
</file>

<file name="script.js">
  var mySceApp = angular.module('mySceApp', ['ngSanitize']);

  mySceApp.controller("myAppController", function myAppController($http, $templateCache, $sce) {
    var self = this;
    $http.get("test_data.json", {cache: $templateCache}).success(function(userComments) {
      self.userComments = userComments;
    });
    self.explicitlyTrustedHtml = $sce.trustAsHtml(
        '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
        'sanitization.&quot;">Hover over this text.</span>');
  });
</file>

<file name="test_data.json">
[
  { "name": "Alice",
    "htmlComment":
        "<span onmouseover='this.textContent=\"PWN3D!\"'>Is <i>anyone</i> reading this?</span>"
  },
  { "name": "Bob",
    "htmlComment": "<i>Yes!</i>  Am I the only other one?"
  }
]
</file>

<file name="scenario.js">
  describe('SCE doc demo', function() {
    it('should sanitize untrusted values', function() {
      expect(element('.htmlComment').html()).toBe('<span>Is <i>anyone</i> reading this?</span>');
    });
    it('should NOT sanitize explicitly trusted values', function() {
      expect(element('#explicitlyTrustedHtml').html()).toBe(
          '<span onmouseover="this.textContent=&quot;Explicitly trusted HTML bypasses ' +
          'sanitization.&quot;">Hover over this text.</span>');
    });
  });
</file>
</example>
 *
 *
 *
 * ## Can I disable SCE completely?
 *
 * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits
 * for little coding overhead.  It will be much harder to take an SCE disabled application and
 * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE
 * for cases where you have a lot of existing code that was written before SCE was introduced and
 * you're migrating them a module at a time.
 *
 * That said, here's how you can completely disable SCE:
 *
 * <pre class="prettyprint">
 *   angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {
 *     // Completely disable SCE.  For demonstration purposes only!
 *     // Do not use in new projects.
 *     $sceProvider.enabled(false);
 *   });
 * </pre>
 *
 */
/* jshint maxlen: 100 */

function $SceProvider() {
  var enabled = true;

  /**
   * @ngdoc function
   * @name ng.sceProvider#enabled
   * @methodOf ng.$sceProvider
   * @function
   *
   * @param {boolean=} value If provided, then enables/disables SCE.
   * @return {boolean} true if SCE is enabled, false otherwise.
   *
   * @description
   * Enables/disables SCE and returns the current value.
   */
  this.enabled = function (value) {
    if (arguments.length) {
      enabled = !!value;
    }
    return enabled;
  };


  /* Design notes on the default implementation for SCE.
   *
   * The API contract for the SCE delegate
   * -------------------------------------
   * The SCE delegate object must provide the following 3 methods:
   *
   * - trustAs(contextEnum, value)
   *     This method is used to tell the SCE service that the provided value is OK to use in the
   *     contexts specified by contextEnum.  It must return an object that will be accepted by
   *     getTrusted() for a compatible contextEnum and return this value.
   *
   * - valueOf(value)
   *     For values that were not produced by trustAs(), return them as is.  For values that were
   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if
   *     trustAs is wrapping the given values into some type, this operation unwraps it when given
   *     such a value.
   *
   * - getTrusted(contextEnum, value)
   *     This function should return the a value that is safe to use in the context specified by
   *     contextEnum or throw and exception otherwise.
   *
   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be
   * opaque or wrapped in some holder object.  That happens to be an implementation detail.  For
   * instance, an implementation could maintain a registry of all trusted objects by context.  In
   * such a case, trustAs() would return the same object that was passed in.  getTrusted() would
   * return the same object passed in if it was found in the registry under a compatible context or
   * throw an exception otherwise.  An implementation might only wrap values some of the time based
   * on some criteria.  getTrusted() might return a value and not throw an exception for special
   * constants or objects even if not wrapped.  All such implementations fulfill this contract.
   *
   *
   * A note on the inheritance model for SCE contexts
   * ------------------------------------------------
   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This
   * is purely an implementation details.
   *
   * The contract is simply this:
   *
   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)
   *     will also succeed.
   *
   * Inheritance happens to capture this in a natural way.  In some future, we
   * may not use inheritance anymore.  That is OK because no code outside of
   * sce.js and sceSpecs.js would need to be aware of this detail.
   */

  this.$get = ['$parse', '$sniffer', '$sceDelegate', function(
                $parse,   $sniffer,   $sceDelegate) {
    // Prereq: Ensure that we're not running in IE8 quirks mode.  In that mode, IE allows
    // the "expression(javascript expression)" syntax which is insecure.
    if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) {
      throw $sceMinErr('iequirks',
        'Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks ' +
        'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +
        'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
    }

    var sce = copy(SCE_CONTEXTS);

    /**
     * @ngdoc function
     * @name ng.sce#isEnabled
     * @methodOf ng.$sce
     * @function
     *
     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you
     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
     *
     * @description
     * Returns a boolean indicating if SCE is enabled.
     */
    sce.isEnabled = function () {
      return enabled;
    };
    sce.trustAs = $sceDelegate.trustAs;
    sce.getTrusted = $sceDelegate.getTrusted;
    sce.valueOf = $sceDelegate.valueOf;

    if (!enabled) {
      sce.trustAs = sce.getTrusted = function(type, value) { return value; };
      sce.valueOf = identity;
    }

    /**
     * @ngdoc method
     * @name ng.$sce#parse
     * @methodOf ng.$sce
     *
     * @description
     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link
     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
     * wraps the expression in a call to {@link ng.$sce#methods_getTrusted $sce.getTrusted(*type*,
     * *result*)}
     *
     * @param {string} type The kind of SCE context in which this result will be used.
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
     *      `context`.
     */
    sce.parseAs = function sceParseAs(type, expr) {
      var parsed = $parse(expr);
      if (parsed.literal && parsed.constant) {
        return parsed;
      } else {
        return function sceParseAsTrusted(self, locals) {
          return sce.getTrusted(type, parsed(self, locals));
        };
      }
    };

    /**
     * @ngdoc method
     * @name ng.$sce#trustAs
     * @methodOf ng.$sce
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs`}.  As such,
     * returns an objectthat is trusted by angular for use in specified strict contextual
     * escaping contexts (such as ng-html-bind-unsafe, ng-include, any src attribute
     * interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)
     * that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual
     * escaping.
     *
     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,
     *   resource_url, html, js and css.
     * @param {*} value The value that that should be considered trusted/safe.
     * @returns {*} A value that can be used to stand in for the provided `value` in places
     * where Angular expects a $sce.trustAs() return value.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsHtml(value)` →
     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedHtml
     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsUrl(value)` →
     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedUrl
     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsResourceUrl(value)` →
     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedResourceUrl
     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the return
     *     value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#trustAsJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.trustAsJs(value)` →
     *     {@link ng.$sceDelegate#methods_trustAs `$sceDelegate.trustAs($sce.JS, value)`}
     *
     * @param {*} value The value to trustAs.
     * @returns {*} An object that can be passed to {@link ng.$sce#methods_getTrustedJs
     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives
     *     only accept expressions that are either literal constants or are the
     *     return value of {@link ng.$sce#methods_trustAs $sce.trustAs}.)
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrusted
     * @methodOf ng.$sce
     *
     * @description
     * Delegates to {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted`}.  As such,
     * takes the result of a {@link ng.$sce#methods_trustAs `$sce.trustAs`}() call and returns the
     * originally supplied value if the queried context type is a supertype of the created type.
     * If this condition isn't satisfied, throws an exception.
     *
     * @param {string} type The kind of context in which this value is to be used.
     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#methods_trustAs `$sce.trustAs`}
     *                         call.
     * @returns {*} The value the was originally provided to
     *              {@link ng.$sce#methods_trustAs `$sce.trustAs`} if valid in this context.
     *              Otherwise, throws an exception.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedHtml(value)` →
     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedCss
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedCss(value)` →
     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedUrl(value)` →
     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` →
     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
     *
     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#getTrustedJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.getTrustedJs(value)` →
     *     {@link ng.$sceDelegate#methods_getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
     *
     * @param {*} value The value to pass to `$sce.getTrusted`.
     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsHtml
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsHtml(expression string)` →
     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.HTML, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsCss
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsCss(value)` →
     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.CSS, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsUrl(value)` →
     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.URL, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsResourceUrl
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsResourceUrl(value)` →
     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.RESOURCE_URL, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
     *      `context`.
     */

    /**
     * @ngdoc method
     * @name ng.$sce#parseAsJs
     * @methodOf ng.$sce
     *
     * @description
     * Shorthand method.  `$sce.parseAsJs(value)` →
     *     {@link ng.$sce#methods_parse `$sce.parseAs($sce.JS, value)`}
     *
     * @param {string} expression String expression to compile.
     * @returns {function(context, locals)} a function which represents the compiled expression:
     *
     *    * `context` – `{object}` – an object against which any expressions embedded in the strings
     *      are evaluated against (typically a scope object).
     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in
     *      `context`.
     */

    // Shorthand delegations.
    var parse = sce.parseAs,
        getTrusted = sce.getTrusted,
        trustAs = sce.trustAs;

    forEach(SCE_CONTEXTS, function (enumValue, name) {
      var lName = lowercase(name);
      sce[camelCase("parse_as_" + lName)] = function (expr) {
        return parse(enumValue, expr);
      };
      sce[camelCase("get_trusted_" + lName)] = function (value) {
        return getTrusted(enumValue, value);
      };
      sce[camelCase("trust_as_" + lName)] = function (value) {
        return trustAs(enumValue, value);
      };
    });

    return sce;
  }];
}

/**
 * !!! This is an undocumented "private" service !!!
 *
 * @name ng.$sniffer
 * @requires $window
 * @requires $document
 *
 * @property {boolean} history Does the browser support html5 history api ?
 * @property {boolean} hashchange Does the browser support hashchange event ?
 * @property {boolean} transitions Does the browser support CSS transition events ?
 * @property {boolean} animations Does the browser support CSS animation events ?
 *
 * @description
 * This is very simple implementation of testing browser's features.
 */
function $SnifferProvider() {
  this.$get = ['$window', '$document', function($window, $document) {
    var eventSupport = {},
        android =
          int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
        document = $document[0] || {},
        documentMode = document.documentMode,
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
        bodyStyle = document.body && document.body.style,
        transitions = false,
        animations = false,
        match;

    if (bodyStyle) {
      for(var prop in bodyStyle) {
        if(match = vendorRegex.exec(prop)) {
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          break;
        }
      }

      if(!vendorPrefix) {
        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
      }

      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));

      if (android && (!transitions||!animations)) {
        transitions = isString(document.body.style.webkitTransition);
        animations = isString(document.body.style.webkitAnimation);
      }
    }


    return {
      // Android has history.pushState, but it does not update location correctly
      // so let's not use the history API at all.
      // http://code.google.com/p/android/issues/detail?id=17471
      // https://github.com/angular/angular.js/issues/904

      // older webit browser (533.9) on Boxee box has exactly the same problem as Android has
      // so let's not use the history API also
      // We are purposefully using `!(android < 4)` to cover the case when `android` is undefined
      // jshint -W018
      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
      // jshint +W018
      hashchange: 'onhashchange' in $window &&
                  // IE8 compatible mode lies
                  (!documentMode || documentMode > 7),
      hasEvent: function(event) {
        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have
        // it. In particular the event is not fired when backspace or delete key are pressed or
        // when cut operation is performed.
        if (event == 'input' && msie == 9) return false;

        if (isUndefined(eventSupport[event])) {
          var divElm = document.createElement('div');
          eventSupport[event] = 'on' + event in divElm;
        }

        return eventSupport[event];
      },
      csp: csp(),
      vendorPrefix: vendorPrefix,
      transitions : transitions,
      animations : animations,
      android: android,
      msie : msie,
      msieDocumentMode: documentMode
    };
  }];
}

function $TimeoutProvider() {
  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',
       function($rootScope,   $browser,   $q,   $exceptionHandler) {
    var deferreds = {};


     /**
      * @ngdoc function
      * @name ng.$timeout
      * @requires $browser
      *
      * @description
      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch
      * block and delegates any exceptions to
      * {@link ng.$exceptionHandler $exceptionHandler} service.
      *
      * The return value of registering a timeout function is a promise, which will be resolved when
      * the timeout is reached and the timeout function is executed.
      *
      * To cancel a timeout request, call `$timeout.cancel(promise)`.
      *
      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to
      * synchronously flush the queue of deferred functions.
      *
      * @param {function()} fn A function, whose execution should be delayed.
      * @param {number=} [delay=0] Delay in milliseconds.
      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise
      *   will invoke `fn` within the {@link ng.$rootScope.Scope#methods_$apply $apply} block.
      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
      *   promise will be resolved with is the return value of the `fn` function.
      * 
      */
    function timeout(fn, delay, invokeApply) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          skipApply = (isDefined(invokeApply) && !invokeApply),
          timeoutId;

      timeoutId = $browser.defer(function() {
        try {
          deferred.resolve(fn());
        } catch(e) {
          deferred.reject(e);
          $exceptionHandler(e);
        }
        finally {
          delete deferreds[promise.$$timeoutId];
        }

        if (!skipApply) $rootScope.$apply();
      }, delay);

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;

      return promise;
    }


     /**
      * @ngdoc function
      * @name ng.$timeout#cancel
      * @methodOf ng.$timeout
      *
      * @description
      * Cancels a task associated with the `promise`. As a result of this, the promise will be
      * resolved with a rejection.
      *
      * @param {Promise=} promise Promise returned by the `$timeout` function.
      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully
      *   canceled.
      */
    timeout.cancel = function(promise) {
      if (promise && promise.$$timeoutId in deferreds) {
        deferreds[promise.$$timeoutId].reject('canceled');
        delete deferreds[promise.$$timeoutId];
        return $browser.defer.cancel(promise.$$timeoutId);
      }
      return false;
    };

    return timeout;
  }];
}

// NOTE:  The usage of window and document instead of $window and $document here is
// deliberate.  This service depends on the specific behavior of anchor nodes created by the
// browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and
// cause us to break tests.  In addition, when the browser resolves a URL for XHR, it
// doesn't know about mocked locations and resolves URLs to the real document - which is
// exactly the behavior needed here.  There is little value is mocking these out for this
// service.
var urlParsingNode = document.createElement("a");
var originUrl = urlResolve(window.location.href, true);


/**
 *
 * Implementation Notes for non-IE browsers
 * ----------------------------------------
 * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,
 * results both in the normalizing and parsing of the URL.  Normalizing means that a relative
 * URL will be resolved into an absolute URL in the context of the application document.
 * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related
 * properties are all populated to reflect the normalized URL.  This approach has wide
 * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See
 * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
 *
 * Implementation Notes for IE
 * ---------------------------
 * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other
 * browsers.  However, the parsed components will not be set if the URL assigned did not specify
 * them.  (e.g. if you assign a.href = "foo", then a.protocol, a.host, etc. will be empty.)  We
 * work around that by performing the parsing in a 2nd step by taking a previously normalized
 * URL (e.g. by assigning to a.href) and assigning it a.href again.  This correctly populates the
 * properties such as protocol, hostname, port, etc.
 *
 * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one
 * uses the inner HTML approach to assign the URL as part of an HTML snippet -
 * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.
 * Unfortunately, setting img[src] to something like "javascript:foo" on IE throws an exception.
 * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that
 * method and IE < 8 is unsupported.
 *
 * References:
 *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement
 *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html
 *   http://url.spec.whatwg.org/#urlutils
 *   https://github.com/angular/angular.js/pull/2902
 *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/
 *
 * @function
 * @param {string} url The URL to be parsed.
 * @description Normalizes and parses a URL.
 * @returns {object} Returns the normalized URL as a dictionary.
 *
 *   | member name   | Description    |
 *   |---------------|----------------|
 *   | href          | A normalized version of the provided URL if it was not an absolute URL |
 *   | protocol      | The protocol including the trailing colon                              |
 *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |
 *   | search        | The search params, minus the question mark                             |
 *   | hash          | The hash string, minus the hash symbol
 *   | hostname      | The hostname
 *   | port          | The port, without ":"
 *   | pathname      | The pathname, beginning with "/"
 *
 */
function urlResolve(url, base) {
  var href = url;

  if (msie) {
    // Normalize before parse.  Refer Implementation Notes on why this is
    // done in two steps on IE.
    urlParsingNode.setAttribute("href", href);
    href = urlParsingNode.href;
  }

  urlParsingNode.setAttribute('href', href);

  // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
  return {
    href: urlParsingNode.href,
    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
    host: urlParsingNode.host,
    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
    hostname: urlParsingNode.hostname,
    port: urlParsingNode.port,
    pathname: (urlParsingNode.pathname.charAt(0) === '/')
      ? urlParsingNode.pathname
      : '/' + urlParsingNode.pathname
  };
}

/**
 * Parse a request URL and determine whether this is a same-origin request as the application document.
 *
 * @param {string|object} requestUrl The url of the request as a string that will be resolved
 * or a parsed URL object.
 * @returns {boolean} Whether the request is for the same origin as the application document.
 */
function urlIsSameOrigin(requestUrl) {
  var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
  return (parsed.protocol === originUrl.protocol &&
          parsed.host === originUrl.host);
}

/**
 * @ngdoc object
 * @name ng.$window
 *
 * @description
 * A reference to the browser's `window` object. While `window`
 * is globally available in JavaScript, it causes testability problems, because
 * it is a global variable. In angular we always refer to it through the
 * `$window` service, so it may be overridden, removed or mocked for testing.
 *
 * Expressions, like the one defined for the `ngClick` directive in the example
 * below, are evaluated with respect to the current scope.  Therefore, there is
 * no risk of inadvertently coding in a dependency on a global value in such an
 * expression.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope, $window) {
           $scope.greeting = 'Hello, World!';
           $scope.doGreeting = function(greeting) {
               $window.alert(greeting);
           };
         }
       </script>
       <div ng-controller="Ctrl">
         <input type="text" ng-model="greeting" />
         <button ng-click="doGreeting(greeting)">ALERT</button>
       </div>
     </doc:source>
     <doc:scenario>
      it('should display the greeting in the input box', function() {
       input('greeting').enter('Hello, E2E Tests');
       // If we click the button it will block the test runner
       // element(':button').click();
      });
     </doc:scenario>
   </doc:example>
 */
function $WindowProvider(){
  this.$get = valueFn(window);
}

/**
 * @ngdoc object
 * @name ng.$filterProvider
 * @description
 *
 * Filters are just functions which transform input to an output. However filters need to be
 * Dependency Injected. To achieve this a filter definition consists of a factory function which is
 * annotated with dependencies and is responsible for creating a filter function.
 *
 * <pre>
 *   // Filter registration
 *   function MyModule($provide, $filterProvider) {
 *     // create a service to demonstrate injection (not always needed)
 *     $provide.value('greet', function(name){
 *       return 'Hello ' + name + '!';
 *     });
 *
 *     // register a filter factory which uses the
 *     // greet service to demonstrate DI.
 *     $filterProvider.register('greet', function(greet){
 *       // return the filter function which uses the greet service
 *       // to generate salutation
 *       return function(text) {
 *         // filters need to be forgiving so check input validity
 *         return text && greet(text) || text;
 *       };
 *     });
 *   }
 * </pre>
 *
 * The filter function is registered with the `$injector` under the filter name suffix with
 * `Filter`.
 * 
 * <pre>
 *   it('should be the same instance', inject(
 *     function($filterProvider) {
 *       $filterProvider.register('reverse', function(){
 *         return ...;
 *       });
 *     },
 *     function($filter, reverseFilter) {
 *       expect($filter('reverse')).toBe(reverseFilter);
 *     });
 * </pre>
 *
 *
 * For more information about how angular filters work, and how to create your own filters, see
 * {@link guide/filter Filters} in the Angular Developer Guide.
 */
/**
 * @ngdoc method
 * @name ng.$filterProvider#register
 * @methodOf ng.$filterProvider
 * @description
 * Register filter factory function.
 *
 * @param {String} name Name of the filter.
 * @param {function} fn The filter factory function which is injectable.
 */


/**
 * @ngdoc function
 * @name ng.$filter
 * @function
 * @description
 * Filters are used for formatting data displayed to the user.
 *
 * The general syntax in templates is as follows:
 *
 *         {{ expression [| filter_name[:parameter_value] ... ] }}
 *
 * @param {String} name Name of the filter function to retrieve
 * @return {Function} the filter function
 */
$FilterProvider.$inject = ['$provide'];
function $FilterProvider($provide) {
  var suffix = 'Filter';

  /**
   * @ngdoc function
   * @name ng.$controllerProvider#register
   * @methodOf ng.$controllerProvider
   * @param {string|Object} name Name of the filter function, or an object map of filters where
   *    the keys are the filter names and the values are the filter factories.
   * @returns {Object} Registered filter instance, or if a map of filters was provided then a map
   *    of the registered filter instances.
   */
  function register(name, factory) {
    if(isObject(name)) {
      var filters = {};
      forEach(name, function(filter, key) {
        filters[key] = register(key, filter);
      });
      return filters;
    } else {
      return $provide.factory(name + suffix, factory);
    }
  }
  this.register = register;

  this.$get = ['$injector', function($injector) {
    return function(name) {
      return $injector.get(name + suffix);
    };
  }];

  ////////////////////////////////////////
  
  /* global
    currencyFilter: false,
    dateFilter: false,
    filterFilter: false,
    jsonFilter: false,
    limitToFilter: false,
    lowercaseFilter: false,
    numberFilter: false,
    orderByFilter: false,
    uppercaseFilter: false,
  */

  register('currency', currencyFilter);
  register('date', dateFilter);
  register('filter', filterFilter);
  register('json', jsonFilter);
  register('limitTo', limitToFilter);
  register('lowercase', lowercaseFilter);
  register('number', numberFilter);
  register('orderBy', orderByFilter);
  register('uppercase', uppercaseFilter);
}

/**
 * @ngdoc filter
 * @name ng.filter:filter
 * @function
 *
 * @description
 * Selects a subset of items from `array` and returns it as a new array.
 *
 * @param {Array} array The source array.
 * @param {string|Object|function()} expression The predicate to be used for selecting items from
 *   `array`.
 *
 *   Can be one of:
 *
 *   - `string`: Predicate that results in a substring match using the value of `expression`
 *     string. All strings or objects with string properties in `array` that contain this string
 *     will be returned. The predicate can be negated by prefixing the string with `!`.
 *
 *   - `Object`: A pattern object can be used to filter specific properties on objects contained
 *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
 *     which have property `name` containing "M" and property `phone` containing "1". A special
 *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
 *     property of the object. That's equivalent to the simple substring match with a `string`
 *     as described above.
 *
 *   - `function`: A predicate function can be used to write arbitrary filters. The function is
 *     called for each element of `array`. The final result is an array of those elements that
 *     the predicate returned true for.
 *
 * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in
 *     determining if the expected value (from the filter expression) and actual value (from
 *     the object in the array) should be considered a match.
 *
 *   Can be one of:
 *
 *     - `function(expected, actual)`:
 *       The function will be given the object value and the predicate value to compare and
 *       should return true if the item should be included in filtered result.
 *
 *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.
 *       this is essentially strict comparison of expected and actual.
 *
 *     - `false|undefined`: A short hand for a function which will look for a substring match in case
 *       insensitive way.
 *
 * @example
   <doc:example>
     <doc:source>
       <div ng-init="friends = [{name:'John', phone:'555-1276'},
                                {name:'Mary', phone:'800-BIG-MARY'},
                                {name:'Mike', phone:'555-4321'},
                                {name:'Adam', phone:'555-5678'},
                                {name:'Julie', phone:'555-8765'},
                                {name:'Juliette', phone:'555-5678'}]"></div>

       Search: <input ng-model="searchText">
       <table id="searchTextResults">
         <tr><th>Name</th><th>Phone</th></tr>
         <tr ng-repeat="friend in friends | filter:searchText">
           <td>{{friend.name}}</td>
           <td>{{friend.phone}}</td>
         </tr>
       </table>
       <hr>
       Any: <input ng-model="search.$"> <br>
       Name only <input ng-model="search.name"><br>
       Phone only <input ng-model="search.phone"><br>
       Equality <input type="checkbox" ng-model="strict"><br>
       <table id="searchObjResults">
         <tr><th>Name</th><th>Phone</th></tr>
         <tr ng-repeat="friend in friends | filter:search:strict">
           <td>{{friend.name}}</td>
           <td>{{friend.phone}}</td>
         </tr>
       </table>
     </doc:source>
     <doc:scenario>
       it('should search across all fields when filtering with a string', function() {
         input('searchText').enter('m');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Adam']);

         input('searchText').enter('76');
         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
           toEqual(['John', 'Julie']);
       });

       it('should search in specific fields when filtering with a predicate object', function() {
         input('search.$').enter('i');
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);
       });
       it('should use a equal comparison when comparator is true', function() {
         input('search.name').enter('Julie');
         input('strict').check();
         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
           toEqual(['Julie']);
       });
     </doc:scenario>
   </doc:example>
 */
function filterFilter() {
  return function(array, expression, comparator) {
    if (!isArray(array)) return array;

    var comparatorType = typeof(comparator),
        predicates = [];

    predicates.check = function(value) {
      for (var j = 0; j < predicates.length; j++) {
        if(!predicates[j](value)) {
          return false;
        }
      }
      return true;
    };

    if (comparatorType !== 'function') {
      if (comparatorType === 'boolean' && comparator) {
        comparator = function(obj, text) {
          return angular.equals(obj, text);
        };
      } else {
        comparator = function(obj, text) {
          text = (''+text).toLowerCase();
          return (''+obj).toLowerCase().indexOf(text) > -1;
        };
      }
    }

    var search = function(obj, text){
      if (typeof text == 'string' && text.charAt(0) === '!') {
        return !search(obj, text.substr(1));
      }
      switch (typeof obj) {
        case "boolean":
        case "number":
        case "string":
          return comparator(obj, text);
        case "object":
          switch (typeof text) {
            case "object":
              return comparator(obj, text);
            default:
              for ( var objKey in obj) {
                if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
                  return true;
                }
              }
              break;
          }
          return false;
        case "array":
          for ( var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
      }
    };
    switch (typeof expression) {
      case "boolean":
      case "number":
      case "string":
        // Set up expression object and fall through
        expression = {$:expression};
        // jshint -W086
      case "object":
        // jshint +W086
        for (var key in expression) {
          if (key == '$') {
            (function() {
              if (!expression[key]) return;
              var path = key;
              predicates.push(function(value) {
                return search(value, expression[path]);
              });
            })();
          } else {
            (function() {
              if (typeof(expression[key]) == 'undefined') { return; }
              var path = key;
              predicates.push(function(value) {
                return search(getter(value,path), expression[path]);
              });
            })();
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
    }
    var filtered = [];
    for ( var j = 0; j < array.length; j++) {
      var value = array[j];
      if (predicates.check(value)) {
        filtered.push(value);
      }
    }
    return filtered;
  };
}

/**
 * @ngdoc filter
 * @name ng.filter:currency
 * @function
 *
 * @description
 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
 * symbol for current locale is used.
 *
 * @param {number} amount Input to filter.
 * @param {string=} symbol Currency symbol or identifier to be displayed.
 * @returns {string} Formatted number.
 *
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.amount = 1234.56;
         }
       </script>
       <div ng-controller="Ctrl">
         <input type="number" ng-model="amount"> <br>
         default currency symbol ($): {{amount | currency}}<br>
         custom currency identifier (USD$): {{amount | currency:"USD$"}}
       </div>
     </doc:source>
     <doc:scenario>
       it('should init with 1234.56', function() {
         expect(binding('amount | currency')).toBe('$1,234.56');
         expect(binding('amount | currency:"USD$"')).toBe('USD$1,234.56');
       });
       it('should update', function() {
         input('amount').enter('-1234');
         expect(binding('amount | currency')).toBe('($1,234.00)');
         expect(binding('amount | currency:"USD$"')).toBe('(USD$1,234.00)');
       });
     </doc:scenario>
   </doc:example>
 */
currencyFilter.$inject = ['$locale'];
function currencyFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(amount, currencySymbol){
    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(/\u00A4/g, currencySymbol);
  };
}

/**
 * @ngdoc filter
 * @name ng.filter:number
 * @function
 *
 * @description
 * Formats a number as text.
 *
 * If the input is not a number an empty string is returned.
 *
 * @param {number|string} number Number to format.
 * @param {(number|string)=} fractionSize Number of decimal places to round the number to.
 * If this is not provided then the fraction size is computed from the current locale's number
 * formatting pattern. In the case of the default locale, it will be 3.
 * @returns {string} Number rounded to decimalPlaces and places a “,” after each third digit.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.val = 1234.56789;
         }
       </script>
       <div ng-controller="Ctrl">
         Enter number: <input ng-model='val'><br>
         Default formatting: {{val | number}}<br>
         No fractions: {{val | number:0}}<br>
         Negative number: {{-val | number:4}}
       </div>
     </doc:source>
     <doc:scenario>
       it('should format numbers', function() {
         expect(binding('val | number')).toBe('1,234.568');
         expect(binding('val | number:0')).toBe('1,235');
         expect(binding('-val | number:4')).toBe('-1,234.5679');
       });

       it('should update', function() {
         input('val').enter('3374.333');
         expect(binding('val | number')).toBe('3,374.333');
         expect(binding('val | number:0')).toBe('3,374');
         expect(binding('-val | number:4')).toBe('-3,374.3330');
       });
     </doc:scenario>
   </doc:example>
 */


numberFilter.$inject = ['$locale'];
function numberFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(number, fractionSize) {
    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
      fractionSize);
  };
}

var DECIMAL_SEP = '.';
function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
  if (isNaN(number) || !isFinite(number)) return '';

  var isNegative = number < 0;
  number = Math.abs(number);
  var numStr = number + '',
      formatedText = '',
      parts = [];

  var hasExponent = false;
  if (numStr.indexOf('e') !== -1) {
    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
    if (match && match[2] == '-' && match[3] > fractionSize + 1) {
      numStr = '0';
    } else {
      formatedText = numStr;
      hasExponent = true;
    }
  }

  if (!hasExponent) {
    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;

    // determine fractionSize if it is not specified
    if (isUndefined(fractionSize)) {
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    }

    var pow = Math.pow(10, fractionSize);
    number = Math.round(number * pow) / pow;
    var fraction = ('' + number).split(DECIMAL_SEP);
    var whole = fraction[0];
    fraction = fraction[1] || '';

    var i, pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    if (whole.length >= (lgroup + group)) {
      pos = whole.length - lgroup;
      for (i = 0; i < pos; i++) {
        if ((pos - i)%group === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
    }

    for (i = pos; i < whole.length; i++) {
      if ((whole.length - i)%lgroup === 0 && i !== 0) {
        formatedText += groupSep;
      }
      formatedText += whole.charAt(i);
    }

    // format fraction part.
    while(fraction.length < fractionSize) {
      fraction += '0';
    }

    if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
  } else {

    if (fractionSize > 0 && number > -1 && number < 1) {
      formatedText = number.toFixed(fractionSize);
    }
  }

  parts.push(isNegative ? pattern.negPre : pattern.posPre);
  parts.push(formatedText);
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
  return parts.join('');
}

function padNumber(num, digits, trim) {
  var neg = '';
  if (num < 0) {
    neg =  '-';
    num = -num;
  }
  num = '' + num;
  while(num.length < digits) num = '0' + num;
  if (trim)
    num = num.substr(num.length - digits);
  return neg + num;
}


function dateGetter(name, size, offset, trim) {
  offset = offset || 0;
  return function(date) {
    var value = date['get' + name]();
    if (offset > 0 || value > -offset)
      value += offset;
    if (value === 0 && offset == -12 ) value = 12;
    return padNumber(value, size, trim);
  };
}

function dateStrGetter(name, shortForm) {
  return function(date, formats) {
    var value = date['get' + name]();
    var get = uppercase(shortForm ? ('SHORT' + name) : name);

    return formats[get][value];
  };
}

function timeZoneGetter(date) {
  var zone = -1 * date.getTimezoneOffset();
  var paddedZone = (zone >= 0) ? "+" : "";

  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  return paddedZone;
}

function ampmGetter(date, formats) {
  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
}

var DATE_FORMATS = {
  yyyy: dateGetter('FullYear', 4),
    yy: dateGetter('FullYear', 2, 0, true),
     y: dateGetter('FullYear', 1),
  MMMM: dateStrGetter('Month'),
   MMM: dateStrGetter('Month', true),
    MM: dateGetter('Month', 2, 1),
     M: dateGetter('Month', 1, 1),
    dd: dateGetter('Date', 2),
     d: dateGetter('Date', 1),
    HH: dateGetter('Hours', 2),
     H: dateGetter('Hours', 1),
    hh: dateGetter('Hours', 2, -12),
     h: dateGetter('Hours', 1, -12),
    mm: dateGetter('Minutes', 2),
     m: dateGetter('Minutes', 1),
    ss: dateGetter('Seconds', 2),
     s: dateGetter('Seconds', 1),
     // while ISO 8601 requires fractions to be prefixed with `.` or `,`
     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions
   sss: dateGetter('Milliseconds', 3),
  EEEE: dateStrGetter('Day'),
   EEE: dateStrGetter('Day', true),
     a: ampmGetter,
     Z: timeZoneGetter
};

var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
    NUMBER_STRING = /^\-?\d+$/;

/**
 * @ngdoc filter
 * @name ng.filter:date
 * @function
 *
 * @description
 *   Formats `date` to a string based on the requested `format`.
 *
 *   `format` string can be composed of the following elements:
 *
 *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
 *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
 *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
 *   * `'MMMM'`: Month in year (January-December)
 *   * `'MMM'`: Month in year (Jan-Dec)
 *   * `'MM'`: Month in year, padded (01-12)
 *   * `'M'`: Month in year (1-12)
 *   * `'dd'`: Day in month, padded (01-31)
 *   * `'d'`: Day in month (1-31)
 *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
 *   * `'EEE'`: Day in Week, (Sun-Sat)
 *   * `'HH'`: Hour in day, padded (00-23)
 *   * `'H'`: Hour in day (0-23)
 *   * `'hh'`: Hour in am/pm, padded (01-12)
 *   * `'h'`: Hour in am/pm, (1-12)
 *   * `'mm'`: Minute in hour, padded (00-59)
 *   * `'m'`: Minute in hour (0-59)
 *   * `'ss'`: Second in minute, padded (00-59)
 *   * `'s'`: Second in minute (0-59)
 *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)
 *   * `'a'`: am/pm marker
 *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
 *
 *   `format` string can also be one of the following predefined
 *   {@link guide/i18n localizable formats}:
 *
 *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
 *     (e.g. Sep 3, 2010 12:05:08 pm)
 *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)
 *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale
 *     (e.g. Friday, September 3, 2010)
 *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)
 *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
 *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
 *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)
 *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)
 *
 *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.
 *   `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence
 *   (e.g. `"h 'o''clock'"`).
 *
 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
 *    specified in the string input, the time is considered to be in the local timezone.
 * @param {string=} format Formatting rules (see Description). If not specified,
 *    `mediumDate` is used.
 * @returns {string} Formatted string or the input if input is not recognized as date/millis.
 *
 * @example
   <doc:example>
     <doc:source>
       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
           {{1288323623006 | date:'medium'}}<br>
       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>
       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>
     </doc:source>
     <doc:scenario>
       it('should format date', function() {
         expect(binding("1288323623006 | date:'medium'")).
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
         expect(binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
         expect(binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
       });
     </doc:scenario>
   </doc:example>
 */
dateFilter.$inject = ['$locale'];
function dateFilter($locale) {


  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                     // 1        2       3         4          5          6          7          8  9     10      11
  function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
      var date = new Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = int(match[9] + match[10]);
        tzMin = int(match[9] + match[11]);
      }
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
      var h = int(match[4]||0) - tzHour;
      var m = int(match[5]||0) - tzMin;
      var s = int(match[6]||0);
      var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return string;
  }


  return function(date, format) {
    var text = '',
        parts = [],
        fn, match;

    format = format || 'mediumDate';
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
      if (NUMBER_STRING.test(date)) {
        date = int(date);
      } else {
        date = jsonStringToDate(date);
      }
    }

    if (isNumber(date)) {
      date = new Date(date);
    }

    if (!isDate(date)) {
      return date;
    }

    while(format) {
      match = DATE_FORMATS_SPLIT.exec(format);
      if (match) {
        parts = concat(parts, match, 1);
        format = parts.pop();
      } else {
        parts.push(format);
        format = null;
      }
    }

    forEach(parts, function(value){
      fn = DATE_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
    });

    return text;
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:json
 * @function
 *
 * @description
 *   Allows you to convert a JavaScript object into JSON string.
 *
 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
 *   the binding is automatically converted to JSON.
 *
 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
 * @returns {string} JSON string.
 *
 *
 * @example:
   <doc:example>
     <doc:source>
       <pre>{{ {'name':'value'} | json }}</pre>
     </doc:source>
     <doc:scenario>
       it('should jsonify filtered objects', function() {
         expect(binding("{'name':'value'}")).toMatch(/\{\n  "name": ?"value"\n}/);
       });
     </doc:scenario>
   </doc:example>
 *
 */
function jsonFilter() {
  return function(object) {
    return toJson(object, true);
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:lowercase
 * @function
 * @description
 * Converts string to lowercase.
 * @see angular.lowercase
 */
var lowercaseFilter = valueFn(lowercase);


/**
 * @ngdoc filter
 * @name ng.filter:uppercase
 * @function
 * @description
 * Converts string to uppercase.
 * @see angular.uppercase
 */
var uppercaseFilter = valueFn(uppercase);

/**
 * @ngdoc function
 * @name ng.filter:limitTo
 * @function
 *
 * @description
 * Creates a new array or string containing only a specified number of elements. The elements
 * are taken from either the beginning or the end of the source array or string, as specified by
 * the value and sign (positive or negative) of `limit`.
 *
 * @param {Array|string} input Source array or string to be limited.
 * @param {string|number} limit The length of the returned array or string. If the `limit` number 
 *     is positive, `limit` number of items from the beginning of the source array/string are copied.
 *     If the number is negative, `limit` number  of items from the end of the source array/string 
 *     are copied. The `limit` will be trimmed if it exceeds `array.length`
 * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array
 *     had less than `limit` elements.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.numbers = [1,2,3,4,5,6,7,8,9];
           $scope.letters = "abcdefghi";
           $scope.numLimit = 3;
           $scope.letterLimit = 3;
         }
       </script>
       <div ng-controller="Ctrl">
         Limit {{numbers}} to: <input type="integer" ng-model="numLimit">
         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>
         Limit {{letters}} to: <input type="integer" ng-model="letterLimit">
         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>
       </div>
     </doc:source>
     <doc:scenario>
       it('should limit the number array to first three items', function() {
         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');
         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');
       });

       it('should update the output when -3 is entered', function() {
         input('numLimit').enter(-3);
         input('letterLimit').enter(-3);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');
       });

       it('should not exceed the maximum size of input array', function() {
         input('numLimit').enter(100);
         input('letterLimit').enter(100);
         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');
         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');
       });
     </doc:scenario>
   </doc:example>
 */
function limitToFilter(){
  return function(input, limit) {
    if (!isArray(input) && !isString(input)) return input;
    
    limit = int(limit);

    if (isString(input)) {
      //NaN check on limit
      if (limit) {
        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
      } else {
        return "";
      }
    }

    var out = [],
      i, n;

    // if abs(limit) exceeds maximum length, trim it
    if (limit > input.length)
      limit = input.length;
    else if (limit < -input.length)
      limit = -input.length;

    if (limit > 0) {
      i = 0;
      n = limit;
    } else {
      i = input.length + limit;
      n = input.length;
    }

    for (; i<n; i++) {
      out.push(input[i]);
    }

    return out;
  };
}

/**
 * @ngdoc function
 * @name ng.filter:orderBy
 * @function
 *
 * @description
 * Orders a specified `array` by the `expression` predicate.
 *
 * @param {Array} array The array to sort.
 * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be
 *    used by the comparator to determine the order of elements.
 *
 *    Can be one of:
 *
 *    - `function`: Getter function. The result of this function will be sorted using the
 *      `<`, `=`, `>` operator.
 *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'
 *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control
 *      ascending or descending sort order (for example, +name or -name).
 *    - `Array`: An array of function or string predicates. The first predicate in the array
 *      is used for sorting, but when two items are equivalent, the next predicate is used.
 *
 * @param {boolean=} reverse Reverse the order the array.
 * @returns {Array} Sorted copy of the source array.
 *
 * @example
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.friends =
               [{name:'John', phone:'555-1212', age:10},
                {name:'Mary', phone:'555-9876', age:19},
                {name:'Mike', phone:'555-4321', age:21},
                {name:'Adam', phone:'555-5678', age:35},
                {name:'Julie', phone:'555-8765', age:29}]
           $scope.predicate = '-age';
         }
       </script>
       <div ng-controller="Ctrl">
         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
         <hr/>
         [ <a href="" ng-click="predicate=''">unsorted</a> ]
         <table class="friend">
           <tr>
             <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
                 (<a href="" ng-click="predicate = '-name'; reverse=false">^</a>)</th>
             <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
             <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
           </tr>
           <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
             <td>{{friend.name}}</td>
             <td>{{friend.phone}}</td>
             <td>{{friend.age}}</td>
           </tr>
         </table>
       </div>
     </doc:source>
     <doc:scenario>
       it('should be reverse ordered by aged', function() {
         expect(binding('predicate')).toBe('-age');
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '29', '21', '19', '10']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);
       });

       it('should reorder the table when user selects different predicate', function() {
         element('.doc-example-live a:contains("Name")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);
         expect(repeater('table.friend', 'friend in friends').column('friend.age')).
           toEqual(['35', '10', '29', '19', '21']);

         element('.doc-example-live a:contains("Phone")').click();
         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).
           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);
         expect(repeater('table.friend', 'friend in friends').column('friend.name')).
           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);
       });
     </doc:scenario>
   </doc:example>
 */
orderByFilter.$inject = ['$parse'];
function orderByFilter($parse){
  return function(array, sortPredicate, reverseOrder) {
    if (!isArray(array)) return array;
    if (!sortPredicate) return array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
    sortPredicate = map(sortPredicate, function(predicate){
      var descending = false, get = predicate || identity;
      if (isString(predicate)) {
        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
          descending = predicate.charAt(0) == '-';
          predicate = predicate.substring(1);
        }
        get = $parse(predicate);
      }
      return reverseComparator(function(a,b){
        return compare(get(a),get(b));
      }, descending);
    });
    var arrayCopy = [];
    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

    function comparator(o1, o2){
      for ( var i = 0; i < sortPredicate.length; i++) {
        var comp = sortPredicate[i](o1, o2);
        if (comp !== 0) return comp;
      }
      return 0;
    }
    function reverseComparator(comp, descending) {
      return toBoolean(descending)
          ? function(a,b){return comp(b,a);}
          : comp;
    }
    function compare(v1, v2){
      var t1 = typeof v1;
      var t2 = typeof v2;
      if (t1 == t2) {
        if (t1 == "string") {
           v1 = v1.toLowerCase();
           v2 = v2.toLowerCase();
        }
        if (v1 === v2) return 0;
        return v1 < v2 ? -1 : 1;
      } else {
        return t1 < t2 ? -1 : 1;
      }
    }
  };
}

function ngDirective(directive) {
  if (isFunction(directive)) {
    directive = {
      link: directive
    };
  }
  directive.restrict = directive.restrict || 'AC';
  return valueFn(directive);
}

/**
 * @ngdoc directive
 * @name ng.directive:a
 * @restrict E
 *
 * @description
 * Modifies the default behavior of the html A tag so that the default action is prevented when
 * the href attribute is empty.
 *
 * This change permits the easy creation of action links with the `ngClick` directive
 * without changing the location or causing page reloads, e.g.:
 * `<a href="" ng-click="list.addItem()">Add Item</a>`
 */
var htmlAnchorDirective = valueFn({
  restrict: 'E',
  compile: function(element, attr) {

    if (msie <= 8) {

      // turn <a href ng-click="..">link</a> into a stylable link in IE
      // but only if it doesn't have name attribute, in which case it's an anchor
      if (!attr.href && !attr.name) {
        attr.$set('href', '');
      }

      // add a comment node to anchors to workaround IE bug that causes element content to be reset
      // to new attribute content if attribute is updated with value containing @ and element also
      // contains value with @
      // see issue #1949
      element.append(document.createComment('IE fix'));
    }

    if (!attr.href && !attr.name) {
      return function(scope, element) {
        element.on('click', function(event){
          // if we have no href url, then don't navigate anywhere.
          if (!element.attr('href')) {
            event.preventDefault();
          }
        });
      };
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngHref
 * @restrict A
 * @priority 99
 *
 * @description
 * Using Angular markup like `{{hash}}` in an href attribute will
 * make the link go to the wrong URL if the user clicks it before
 * Angular has a chance to replace the `{{hash}}` markup with its
 * value. Until Angular replaces the markup the link will be broken
 * and will most likely return a 404 error.
 *
 * The `ngHref` directive solves this problem.
 *
 * The wrong way to write it:
 * <pre>
 * <a href="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <a ng-href="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * @element A
 * @param {template} ngHref any string which can contain `{{}}` markup.
 *
 * @example
 * This example shows various combinations of `href`, `ng-href` and `ng-click` attributes
 * in links and their different behaviors:
    <doc:example>
      <doc:source>
        <input ng-model="value" /><br />
        <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
        <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
        <a id="link-3" ng-href="/{{'123'}}">link 3</a> (link, reload!)<br />
        <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
        <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
        <a id="link-6" ng-href="{{value}}">link</a> (link, change location)
      </doc:source>
      <doc:scenario>
        it('should execute ng-click but not reload when href without value', function() {
          element('#link-1').click();
          expect(input('value').val()).toEqual('1');
          expect(element('#link-1').attr('href')).toBe("");
        });

        it('should execute ng-click but not reload when href empty string', function() {
          element('#link-2').click();
          expect(input('value').val()).toEqual('2');
          expect(element('#link-2').attr('href')).toBe("");
        });

        it('should execute ng-click and change url when ng-href specified', function() {
          expect(element('#link-3').attr('href')).toBe("/123");

          element('#link-3').click();
          expect(browser().window().path()).toEqual('/123');
        });

        it('should execute ng-click but not reload when href empty string and name specified', function() {
          element('#link-4').click();
          expect(input('value').val()).toEqual('4');
          expect(element('#link-4').attr('href')).toBe('');
        });

        it('should execute ng-click but not reload when no href but name specified', function() {
          element('#link-5').click();
          expect(input('value').val()).toEqual('5');
          expect(element('#link-5').attr('href')).toBe(undefined);
        });

        it('should only change url when only ng-href', function() {
          input('value').enter('6');
          expect(element('#link-6').attr('href')).toBe('6');

          element('#link-6').click();
          expect(browser().location().url()).toEqual('/6');
        });
      </doc:scenario>
    </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrc
 * @restrict A
 * @priority 99
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `src` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrc` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
 * </pre>
 *
 * @element IMG
 * @param {template} ngSrc any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrcset
 * @restrict A
 * @priority 99
 *
 * @description
 * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't
 * work right: The browser will fetch from the URL with the literal
 * text `{{hash}}` until Angular replaces the expression inside
 * `{{hash}}`. The `ngSrcset` directive solves this problem.
 *
 * The buggy way to write it:
 * <pre>
 * <img srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
 * </pre>
 *
 * The correct way to write it:
 * <pre>
 * <img ng-srcset="http://www.gravatar.com/avatar/{{hash}} 2x"/>
 * </pre>
 *
 * @element IMG
 * @param {template} ngSrcset any string which can contain `{{}}` markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngDisabled
 * @restrict A
 * @priority 100
 *
 * @description
 *
 * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
 * <pre>
 * <div ng-init="scope = { isDisabled: false }">
 *  <button disabled="{{scope.isDisabled}}">Disabled</button>
 * </div>
 * </pre>
 *
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as disabled. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngDisabled` directive solves this problem for the `disabled` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 *
 * @example
    <doc:example>
      <doc:source>
        Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
        <button ng-model="button" ng-disabled="checked">Button</button>
      </doc:source>
      <doc:scenario>
        it('should toggle button', function() {
          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngDisabled If the {@link guide/expression expression} is truthy, 
 *     then special attribute "disabled" will be set on the element
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngChecked
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as checked. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngChecked` directive solves this problem for the `checked` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * @example
    <doc:example>
      <doc:source>
        Check me to check both: <input type="checkbox" ng-model="master"><br/>
        <input id="checkSlave" type="checkbox" ng-checked="master">
      </doc:source>
      <doc:scenario>
        it('should check both checkBoxes', function() {
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();
          input('master').check();
          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngChecked If the {@link guide/expression expression} is truthy, 
 *     then special attribute "checked" will be set on the element
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngReadonly
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as readonly. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngReadonly` directive solves this problem for the `readonly` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * @example
    <doc:example>
      <doc:source>
        Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
        <input type="text" ng-readonly="checked" value="I'm Angular"/>
      </doc:source>
      <doc:scenario>
        it('should toggle readonly attr', function() {
          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();
          input('checked').check();
          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element INPUT
 * @param {expression} ngReadonly If the {@link guide/expression expression} is truthy, 
 *     then special attribute "readonly" will be set on the element
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSelected
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as selected. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngSelected` directive solves this problem for the `selected` atttribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * 
 * @example
    <doc:example>
      <doc:source>
        Check me to select: <input type="checkbox" ng-model="selected"><br/>
        <select>
          <option>Hello!</option>
          <option id="greet" ng-selected="selected">Greetings!</option>
        </select>
      </doc:source>
      <doc:scenario>
        it('should select Greetings!', function() {
          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();
          input('selected').check();
          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();
        });
      </doc:scenario>
    </doc:example>
 *
 * @element OPTION
 * @param {expression} ngSelected If the {@link guide/expression expression} is truthy, 
 *     then special attribute "selected" will be set on the element
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngOpen
 * @restrict A
 * @priority 100
 *
 * @description
 * The HTML specification does not require browsers to preserve the values of boolean attributes
 * such as open. (Their presence means true and their absence means false.)
 * If we put an Angular interpolation expression into such an attribute then the
 * binding information would be lost when the browser removes the attribute.
 * The `ngOpen` directive solves this problem for the `open` attribute.
 * This complementary directive is not removed by the browser and so provides
 * a permanent reliable place to store the binding information.
 * @example
     <doc:example>
       <doc:source>
         Check me check multiple: <input type="checkbox" ng-model="open"><br/>
         <details id="details" ng-open="open">
            <summary>Show/Hide me</summary>
         </details>
       </doc:source>
       <doc:scenario>
         it('should toggle open', function() {
           expect(element('#details').prop('open')).toBeFalsy();
           input('open').check();
           expect(element('#details').prop('open')).toBeTruthy();
         });
       </doc:scenario>
     </doc:example>
 *
 * @element DETAILS
 * @param {expression} ngOpen If the {@link guide/expression expression} is truthy, 
 *     then special attribute "open" will be set on the element
 */

var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
forEach(BOOLEAN_ATTR, function(propName, attrName) {
  // binding to multiple is not supported
  if (propName == "multiple") return;

  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 100,
      compile: function() {
        return function(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        };
      }
    };
  };
});


// ng-src, ng-srcset, ng-href are interpolated
forEach(['src', 'srcset', 'href'], function(attrName) {
  var normalized = directiveNormalize('ng-' + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 99, // it needs to run after the attributes are interpolated
      link: function(scope, element, attr) {
        attr.$observe(normalized, function(value) {
          if (!value)
             return;

          attr.$set(attrName, value);

          // on IE, if "ng:src" directive declaration is used and "src" attribute doesn't exist
          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need
          // to set the property as well to achieve the desired effect.
          // we use attr[attrName] value since $set can sanitize the url.
          if (msie) element.prop(attrName, attr[attrName]);
        });
      }
    };
  };
});

/* global -nullFormCtrl */
var nullFormCtrl = {
  $addControl: noop,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop
};

/**
 * @ngdoc object
 * @name ng.directive:form.FormController
 *
 * @property {boolean} $pristine True if user has not interacted with the form yet.
 * @property {boolean} $dirty True if user has already interacted with the form.
 * @property {boolean} $valid True if all of the containing forms and controls are valid.
 * @property {boolean} $invalid True if at least one containing control or form is invalid.
 *
 * @property {Object} $error Is an object hash, containing references to all invalid controls or
 *  forms, where:
 *
 *  - keys are validation tokens (error names),
 *  - values are arrays of controls or forms that are invalid for given error name.
 *
 *
 *  Built-in validation tokens:
 *
 *  - `email`
 *  - `max`
 *  - `maxlength`
 *  - `min`
 *  - `minlength`
 *  - `number`
 *  - `pattern`
 *  - `required`
 *  - `url`
 * 
 * @description
 * `FormController` keeps track of all its controls and nested forms as well as state of them,
 * such as being valid/invalid or dirty/pristine.
 *
 * Each {@link ng.directive:form form} directive creates an instance
 * of `FormController`.
 *
 */
//asks for $scope to fool the BC controller module
FormController.$inject = ['$element', '$attrs', '$scope'];
function FormController(element, attrs) {
  var form = this,
      parentForm = element.parent().controller('form') || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      errors = form.$error = {},
      controls = [];

  // init state
  form.$name = attrs.name || attrs.ngForm;
  form.$dirty = false;
  form.$pristine = true;
  form.$valid = true;
  form.$invalid = false;

  parentForm.$addControl(form);

  // Setup initial state of the control
  element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$addControl
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Register a control with the form.
   *
   * Input elements using ngModelController do this automatically when they are linked.
   */
  form.$addControl = function(control) {
    // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
    // and not added to the scope.  Now we throw an error.
    assertNotHasOwnProperty(control.$name, 'input');
    controls.push(control);

    if (control.$name) {
      form[control.$name] = control;
    }
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$removeControl
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Deregister a control from the form.
   *
   * Input elements using ngModelController do this automatically when they are destroyed.
   */
  form.$removeControl = function(control) {
    if (control.$name && form[control.$name] === control) {
      delete form[control.$name];
    }
    forEach(errors, function(queue, validationToken) {
      form.$setValidity(validationToken, true, control);
    });

    arrayRemove(controls, control);
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setValidity
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the validity of a form control.
   *
   * This method will also propagate to parent forms.
   */
  form.$setValidity = function(validationToken, isValid, control) {
    var queue = errors[validationToken];

    if (isValid) {
      if (queue) {
        arrayRemove(queue, control);
        if (!queue.length) {
          invalidCount--;
          if (!invalidCount) {
            toggleValidCss(isValid);
            form.$valid = true;
            form.$invalid = false;
          }
          errors[validationToken] = false;
          toggleValidCss(true, validationToken);
          parentForm.$setValidity(validationToken, true, form);
        }
      }

    } else {
      if (!invalidCount) {
        toggleValidCss(isValid);
      }
      if (queue) {
        if (includes(queue, control)) return;
      } else {
        errors[validationToken] = queue = [];
        invalidCount++;
        toggleValidCss(false, validationToken);
        parentForm.$setValidity(validationToken, false, form);
      }
      queue.push(control);

      form.$valid = false;
      form.$invalid = true;
    }
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setDirty
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to a dirty state.
   *
   * This method can be called to add the 'ng-dirty' class and set the form to a dirty
   * state (ng-dirty class). This method will also propagate to parent forms.
   */
  form.$setDirty = function() {
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
    form.$dirty = true;
    form.$pristine = false;
    parentForm.$setDirty();
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setPristine
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to its pristine state.
   *
   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine
   * state (ng-pristine class). This method will also propagate to all the controls contained
   * in this form.
   *
   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
   * saving or resetting it.
   */
  form.$setPristine = function () {
    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
    form.$dirty = false;
    form.$pristine = true;
    forEach(controls, function(control) {
      control.$setPristine();
    });
  };
}


/**
 * @ngdoc directive
 * @name ng.directive:ngForm
 * @restrict EAC
 *
 * @description
 * Nestable alias of {@link ng.directive:form `form`} directive. HTML
 * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
 * sub-group of controls needs to be determined.
 *
 * @param {string=} ngForm|name Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 */

 /**
 * @ngdoc directive
 * @name ng.directive:form
 * @restrict E
 *
 * @description
 * Directive that instantiates
 * {@link ng.directive:form.FormController FormController}.
 *
 * If the `name` attribute is specified, the form controller is published onto the current scope under
 * this name.
 *
 * # Alias: {@link ng.directive:ngForm `ngForm`}
 *
 * In Angular forms can be nested. This means that the outer form is valid when all of the child
 * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
 * Angular provides the {@link ng.directive:ngForm `ngForm`} directive which behaves identically to
 * `<form>` but can be nested.  This allows you to have nested forms, which is very useful when
 * using Angular validation directives in forms that are dynamically generated using the
 * {@link ng.directive:ngRepeat `ngRepeat`} directive. Since you cannot dynamically generate the `name`
 * attribute of input elements using interpolation, you have to wrap each set of repeated inputs in an
 * `ngForm` directive and nest these in an outer `form` element.
 *
 *
 * # CSS classes
 *  - `ng-valid` Is set if the form is valid.
 *  - `ng-invalid` Is set if the form is invalid.
 *  - `ng-pristine` Is set if the form is pristine.
 *  - `ng-dirty` Is set if the form is dirty.
 *
 *
 * # Submitting a form and preventing the default action
 *
 * Since the role of forms in client-side Angular applications is different than in classical
 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
 * page reload that sends the data to the server. Instead some javascript logic should be triggered
 * to handle the form submission in an application-specific way.
 *
 * For this reason, Angular prevents the default action (form submission to the server) unless the
 * `<form>` element has an `action` attribute specified.
 *
 * You can use one of the following two ways to specify what javascript method should be called when
 * a form is submitted:
 *
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
 * - {@link ng.directive:ngClick ngClick} directive on the first
  *  button or input field of type submit (input[type=submit])
 *
 * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}
 * or {@link ng.directive:ngClick ngClick} directives.
 * This is because of the following form submission rules in the HTML specification:
 *
 * - If a form has only one input field then hitting enter in this field triggers form submit
 * (`ngSubmit`)
 * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
 * doesn't trigger submit
 * - if a form has one or more input fields and one or more buttons or input[type=submit] then
 * hitting enter in any of the input fields will trigger the click handler on the *first* button or
 * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
 *
 * @param {string=} name Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.userType = 'guest';
         }
       </script>
       <form name="myForm" ng-controller="Ctrl">
         userType: <input name="input" ng-model="userType" required>
         <span class="error" ng-show="myForm.input.$error.required">Required!</span><br>
         <tt>userType = {{userType}}</tt><br>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
         expect(binding('userType')).toEqual('guest');
         expect(binding('myForm.input.$valid')).toEqual('true');
        });

        it('should be invalid if empty', function() {
         input('userType').enter('');
         expect(binding('userType')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
        });
      </doc:scenario>
    </doc:example>
 */
var formDirectiveFactory = function(isNgForm) {
  return ['$timeout', function($timeout) {
    var formDirective = {
      name: 'form',
      restrict: isNgForm ? 'EAC' : 'E',
      controller: FormController,
      compile: function() {
        return {
          pre: function(scope, formElement, attr, controller) {
            if (!attr.action) {
              // we can't use jq events because if a form is destroyed during submission the default
              // action is not prevented. see #1238
              //
              // IE 9 is not affected because it doesn't fire a submit event and try to do a full
              // page reload if the form was destroyed by submission of the form via a click handler
              // on a button in the form. Looks like an IE9 specific bug.
              var preventDefaultListener = function(event) {
                event.preventDefault
                  ? event.preventDefault()
                  : event.returnValue = false; // IE
              };

              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);

              // unregister the preventDefault listener so that we don't not leak memory but in a
              // way that will achieve the prevention of the default action.
              formElement.on('$destroy', function() {
                $timeout(function() {
                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                }, 0, false);
              });
            }

            var parentFormCtrl = formElement.parent().controller('form'),
                alias = attr.name || attr.ngForm;

            if (alias) {
              setter(scope, alias, controller, alias);
            }
            if (parentFormCtrl) {
              formElement.on('$destroy', function() {
                parentFormCtrl.$removeControl(controller);
                if (alias) {
                  setter(scope, alias, undefined, alias);
                }
                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
              });
            }
          }
        };
      }
    };

    return formDirective;
  }];
};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(true);

/* global

    -VALID_CLASS,
    -INVALID_CLASS,
    -PRISTINE_CLASS,
    -DIRTY_CLASS
*/

var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}$/;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

var inputType = {

  /**
   * @ngdoc inputType
   * @name ng.directive:input.text
   *
   * @description
   * Standard HTML text input with angular data binding.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Adds `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trim the input.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'guest';
             $scope.word = /^\s*\w*\s*$/;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Single word: <input type="text" name="input" ng-model="text"
                               ng-pattern="word" required ng-trim="false">
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.pattern">
             Single word only!</span>

           <tt>text = {{text}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('guest');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if multi word', function() {
            input('text').enter('hello world');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should not be trimmed', function() {
            input('text').enter('untrimmed ');
            expect(binding('text')).toEqual('untrimmed ');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });
        </doc:scenario>
      </doc:example>
   */
  'text': textInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.number
   *
   * @description
   * Text input with number validation and transformation. Sets the `number` validation
   * error if not a valid number.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.
   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.value = 12;
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Number: <input type="number" name="input" ng-model="value"
                          min="0" max="99" required>
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.number">
             Not valid number!</span>
           <tt>value = {{value}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
           expect(binding('value')).toEqual('12');
           expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
           input('value').enter('');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if over max', function() {
           input('value').enter('123');
           expect(binding('value')).toEqual('');
           expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'number': numberInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.url
   *
   * @description
   * Text input with URL validation. Sets the `url` validation error key if the content is not a
   * valid URL.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'http://google.com';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           URL: <input type="url" name="input" ng-model="text" required>
           <span class="error" ng-show="myForm.input.$error.required">
             Required!</span>
           <span class="error" ng-show="myForm.input.$error.url">
             Not valid url!</span>
           <tt>text = {{text}}</tt><br/>
           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('http://google.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if not url', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'url': urlInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.email
   *
   * @description
   * Text input with email validation. Sets the `email` validation error key if not a valid email
   * address.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets `required` validation error key if the value is not entered.
   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
   *    `required` when you want to data-bind to the `required` attribute.
   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.text = 'me@example.com';
           }
         </script>
           <form name="myForm" ng-controller="Ctrl">
             Email: <input type="email" name="input" ng-model="text" required>
             <span class="error" ng-show="myForm.input.$error.required">
               Required!</span>
             <span class="error" ng-show="myForm.input.$error.email">
               Not valid email!</span>
             <tt>text = {{text}}</tt><br/>
             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
           </form>
        </doc:source>
        <doc:scenario>
          it('should initialize to model', function() {
            expect(binding('text')).toEqual('me@example.com');
            expect(binding('myForm.input.$valid')).toEqual('true');
          });

          it('should be invalid if empty', function() {
            input('text').enter('');
            expect(binding('text')).toEqual('');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });

          it('should be invalid if not email', function() {
            input('text').enter('xxx');
            expect(binding('myForm.input.$valid')).toEqual('false');
          });
        </doc:scenario>
      </doc:example>
   */
  'email': emailInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.radio
   *
   * @description
   * HTML radio button.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string} value The value to which the expression should be set when selected.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.color = 'blue';
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           <input type="radio" ng-model="color" value="red">  Red <br/>
           <input type="radio" ng-model="color" value="green"> Green <br/>
           <input type="radio" ng-model="color" value="blue"> Blue <br/>
           <tt>color = {{color}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should change state', function() {
            expect(binding('color')).toEqual('blue');

            input('color').select('red');
            expect(binding('color')).toEqual('red');
          });
        </doc:scenario>
      </doc:example>
   */
  'radio': radioInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.checkbox
   *
   * @description
   * HTML checkbox.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngTrueValue The value to which the expression should be set when selected.
   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      <doc:example>
        <doc:source>
         <script>
           function Ctrl($scope) {
             $scope.value1 = true;
             $scope.value2 = 'YES'
           }
         </script>
         <form name="myForm" ng-controller="Ctrl">
           Value1: <input type="checkbox" ng-model="value1"> <br/>
           Value2: <input type="checkbox" ng-model="value2"
                          ng-true-value="YES" ng-false-value="NO"> <br/>
           <tt>value1 = {{value1}}</tt><br/>
           <tt>value2 = {{value2}}</tt><br/>
          </form>
        </doc:source>
        <doc:scenario>
          it('should change state', function() {
            expect(binding('value1')).toEqual('true');
            expect(binding('value2')).toEqual('YES');

            input('value1').check();
            input('value2').check();
            expect(binding('value1')).toEqual('false');
            expect(binding('value2')).toEqual('NO');
          });
        </doc:scenario>
      </doc:example>
   */
  'checkbox': checkboxInputType,

  'hidden': noop,
  'button': noop,
  'submit': noop,
  'reset': noop
};


function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  // In composition mode, users are still inputing intermediate text buffer,
  // hold the listener until composition is done.
  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
  if (!$sniffer.android) {
    var composing = false;

    element.on('compositionstart', function(data) {
      composing = true;
    });

    element.on('compositionend', function() {
      composing = false;
    });
  }

  var listener = function() {
    if (composing) return;
    var value = element.val();

    // By default we will trim the value
    // If the attribute ng-trim exists we will avoid trimming
    // e.g. <input ng-model="foo" ng-trim="false">
    if (toBoolean(attr.ngTrim || 'T')) {
      value = trim(value);
    }

    if (ctrl.$viewValue !== value) {
      scope.$apply(function() {
        ctrl.$setViewValue(value);
      });
    }
  };

  // if the browser does support "input" event, we are fine - except on IE9 which doesn't fire the
  // input event on backspace, delete or cut
  if ($sniffer.hasEvent('input')) {
    element.on('input', listener);
  } else {
    var timeout;

    var deferListener = function() {
      if (!timeout) {
        timeout = $browser.defer(function() {
          listener();
          timeout = null;
        });
      }
    };

    element.on('keydown', function(event) {
      var key = event.keyCode;

      // ignore
      //    command            modifiers                   arrows
      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

      deferListener();
    });

    // if user modifies input value using context menu in IE, we need "paste" and "cut" events to catch it
    if ($sniffer.hasEvent('paste')) {
      element.on('paste cut', deferListener);
    }
  }

  // if user paste into input using mouse on older browser
  // or form autocomplete on newer browser, we need "change" event to catch it
  element.on('change', listener);

  ctrl.$render = function() {
    element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
  };

  // pattern validator
  var pattern = attr.ngPattern,
      patternValidator,
      match;

  var validate = function(regexp, value) {
    if (ctrl.$isEmpty(value) || regexp.test(value)) {
      ctrl.$setValidity('pattern', true);
      return value;
    } else {
      ctrl.$setValidity('pattern', false);
      return undefined;
    }
  };

  if (pattern) {
    match = pattern.match(/^\/(.*)\/([gim]*)$/);
    if (match) {
      pattern = new RegExp(match[1], match[2]);
      patternValidator = function(value) {
        return validate(pattern, value);
      };
    } else {
      patternValidator = function(value) {
        var patternObj = scope.$eval(pattern);

        if (!patternObj || !patternObj.test) {
          throw minErr('ngPattern')('noregexp',
            'Expected {0} to be a RegExp but was {1}. Element: {2}', pattern,
            patternObj, startingTag(element));
        }
        return validate(patternObj, value);
      };
    }

    ctrl.$formatters.push(patternValidator);
    ctrl.$parsers.push(patternValidator);
  }

  // min length validator
  if (attr.ngMinlength) {
    var minlength = int(attr.ngMinlength);
    var minLengthValidator = function(value) {
      if (!ctrl.$isEmpty(value) && value.length < minlength) {
        ctrl.$setValidity('minlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('minlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(minLengthValidator);
    ctrl.$formatters.push(minLengthValidator);
  }

  // max length validator
  if (attr.ngMaxlength) {
    var maxlength = int(attr.ngMaxlength);
    var maxLengthValidator = function(value) {
      if (!ctrl.$isEmpty(value) && value.length > maxlength) {
        ctrl.$setValidity('maxlength', false);
        return undefined;
      } else {
        ctrl.$setValidity('maxlength', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxLengthValidator);
    ctrl.$formatters.push(maxLengthValidator);
  }
}

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$parsers.push(function(value) {
    var empty = ctrl.$isEmpty(value);
    if (empty || NUMBER_REGEXP.test(value)) {
      ctrl.$setValidity('number', true);
      return value === '' ? null : (empty ? value : parseFloat(value));
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });

  ctrl.$formatters.push(function(value) {
    return ctrl.$isEmpty(value) ? '' : '' + value;
  });

  if (attr.min) {
    var minValidator = function(value) {
      var min = parseFloat(attr.min);
      if (!ctrl.$isEmpty(value) && value < min) {
        ctrl.$setValidity('min', false);
        return undefined;
      } else {
        ctrl.$setValidity('min', true);
        return value;
      }
    };

    ctrl.$parsers.push(minValidator);
    ctrl.$formatters.push(minValidator);
  }

  if (attr.max) {
    var maxValidator = function(value) {
      var max = parseFloat(attr.max);
      if (!ctrl.$isEmpty(value) && value > max) {
        ctrl.$setValidity('max', false);
        return undefined;
      } else {
        ctrl.$setValidity('max', true);
        return value;
      }
    };

    ctrl.$parsers.push(maxValidator);
    ctrl.$formatters.push(maxValidator);
  }

  ctrl.$formatters.push(function(value) {

    if (ctrl.$isEmpty(value) || isNumber(value)) {
      ctrl.$setValidity('number', true);
      return value;
    } else {
      ctrl.$setValidity('number', false);
      return undefined;
    }
  });
}

function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var urlValidator = function(value) {
    if (ctrl.$isEmpty(value) || URL_REGEXP.test(value)) {
      ctrl.$setValidity('url', true);
      return value;
    } else {
      ctrl.$setValidity('url', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
}

function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var emailValidator = function(value) {
    if (ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)) {
      ctrl.$setValidity('email', true);
      return value;
    } else {
      ctrl.$setValidity('email', false);
      return undefined;
    }
  };

  ctrl.$formatters.push(emailValidator);
  ctrl.$parsers.push(emailValidator);
}

function radioInputType(scope, element, attr, ctrl) {
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.attr('name', nextUid());
  }

  element.on('click', function() {
    if (element[0].checked) {
      scope.$apply(function() {
        ctrl.$setViewValue(attr.value);
      });
    }
  });

  ctrl.$render = function() {
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  };

  attr.$observe('value', ctrl.$render);
}

function checkboxInputType(scope, element, attr, ctrl) {
  var trueValue = attr.ngTrueValue,
      falseValue = attr.ngFalseValue;

  if (!isString(trueValue)) trueValue = true;
  if (!isString(falseValue)) falseValue = false;

  element.on('click', function() {
    scope.$apply(function() {
      ctrl.$setViewValue(element[0].checked);
    });
  });

  ctrl.$render = function() {
    element[0].checked = ctrl.$viewValue;
  };

  // Override the standard `$isEmpty` because a value of `false` means empty in a checkbox.
  ctrl.$isEmpty = function(value) {
    return value !== trueValue;
  };

  ctrl.$formatters.push(function(value) {
    return value === trueValue;
  });

  ctrl.$parsers.push(function(value) {
    return value ? trueValue : falseValue;
  });
}


/**
 * @ngdoc directive
 * @name ng.directive:textarea
 * @restrict E
 *
 * @description
 * HTML textarea element control with angular data-binding. The data-binding and validation
 * properties of this element are exactly the same as those of the
 * {@link ng.directive:input input element}.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 */


/**
 * @ngdoc directive
 * @name ng.directive:input
 * @restrict E
 *
 * @description
 * HTML input element control with angular data-binding. Input control follows HTML5 input types
 * and polyfills the HTML5 validation behavior for older browsers.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets `required` validation error key if the value is not entered.
 * @param {boolean=} ngRequired Sets `required` attribute if set to true
 * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.user = {name: 'guest', last: 'visitor'};
         }
       </script>
       <div ng-controller="Ctrl">
         <form name="myForm">
           User name: <input type="text" name="userName" ng-model="user.name" required>
           <span class="error" ng-show="myForm.userName.$error.required">
             Required!</span><br>
           Last name: <input type="text" name="lastName" ng-model="user.last"
             ng-minlength="3" ng-maxlength="10">
           <span class="error" ng-show="myForm.lastName.$error.minlength">
             Too short!</span>
           <span class="error" ng-show="myForm.lastName.$error.maxlength">
             Too long!</span><br>
         </form>
         <hr>
         <tt>user = {{user}}</tt><br/>
         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
       </div>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('user')).toEqual('{"name":"guest","last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

        it('should be invalid if empty when required', function() {
          input('user.name').enter('');
          expect(binding('user')).toEqual('{"last":"visitor"}');
          expect(binding('myForm.userName.$valid')).toEqual('false');
          expect(binding('myForm.$valid')).toEqual('false');
        });

        it('should be valid if empty when min length is set', function() {
          input('user.last').enter('');
          expect(binding('user')).toEqual('{"name":"guest","last":""}');
          expect(binding('myForm.lastName.$valid')).toEqual('true');
          expect(binding('myForm.$valid')).toEqual('true');
        });

        it('should be invalid if less than required min length', function() {
          input('user.last').enter('xx');
          expect(binding('user')).toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });

        it('should be invalid if longer than max length', function() {
          input('user.last').enter('some ridiculously long name');
          expect(binding('user'))
            .toEqual('{"name":"guest"}');
          expect(binding('myForm.lastName.$valid')).toEqual('false');
          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);
          expect(binding('myForm.$valid')).toEqual('false');
        });
      </doc:scenario>
    </doc:example>
 */
var inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {
  return {
    restrict: 'E',
    require: '?ngModel',
    link: function(scope, element, attr, ctrl) {
      if (ctrl) {
        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                            $browser);
      }
    }
  };
}];

var VALID_CLASS = 'ng-valid',
    INVALID_CLASS = 'ng-invalid',
    PRISTINE_CLASS = 'ng-pristine',
    DIRTY_CLASS = 'ng-dirty';

/**
 * @ngdoc object
 * @name ng.directive:ngModel.NgModelController
 *
 * @property {string} $viewValue Actual string value in the view.
 * @property {*} $modelValue The value in the model, that the control is bound to.
 * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
       the control reads value from the DOM.  Each function is called, in turn, passing the value
       through to the next. Used to sanitize / convert the value as well as validation.
       For validation, the parsers should update the validity state using
       {@link ng.directive:ngModel.NgModelController#methods_$setValidity $setValidity()},
       and return `undefined` for invalid values.

 *
 * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
       the model value changes. Each function is called, in turn, passing the value through to the
       next. Used to format / convert values for display in the control and validation.
 *      <pre>
 *      function formatter(value) {
 *        if (value) {
 *          return value.toUpperCase();
 *        }
 *      }
 *      ngModel.$formatters.push(formatter);
 *      </pre>
 *
 * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever the
 *     view value has changed. It is called with no arguments, and its return value is ignored.
 *     This can be used in place of additional $watches against the model value.
 *
 * @property {Object} $error An object hash with all errors as keys.
 *
 * @property {boolean} $pristine True if user has not interacted with the control yet.
 * @property {boolean} $dirty True if user has already interacted with the control.
 * @property {boolean} $valid True if there is no error.
 * @property {boolean} $invalid True if at least one error on the control.
 *
 * @description
 *
 * `NgModelController` provides API for the `ng-model` directive. The controller contains
 * services for data-binding, validation, CSS updates, and value formatting and parsing. It
 * purposefully does not contain any logic which deals with DOM rendering or listening to
 * DOM events. Such DOM related logic should be provided by other directives which make use of
 * `NgModelController` for data-binding.
 *
 * ## Custom Control Example
 * This example shows how to use `NgModelController` with a custom control to achieve
 * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)
 * collaborate together to achieve the desired result.
 *
 * Note that `contenteditable` is an HTML5 attribute, which tells the browser to let the element
 * contents be edited in place by the user.  This will not work on older browsers.
 *
 * <example module="customControl">
    <file name="style.css">
      [contenteditable] {
        border: 1px solid black;
        background-color: white;
        min-height: 20px;
      }

      .ng-invalid {
        border: 1px solid red;
      }

    </file>
    <file name="script.js">
      angular.module('customControl', []).
        directive('contenteditable', function() {
          return {
            restrict: 'A', // only activate on element attribute
            require: '?ngModel', // get a hold of NgModelController
            link: function(scope, element, attrs, ngModel) {
              if(!ngModel) return; // do nothing if no ng-model

              // Specify how UI should be updated
              ngModel.$render = function() {
                element.html(ngModel.$viewValue || '');
              };

              // Listen for change events to enable binding
              element.on('blur keyup change', function() {
                scope.$apply(read);
              });
              read(); // initialize

              // Write data to the model
              function read() {
                var html = element.html();
                // When we clear the content editable the browser leaves a <br> behind
                // If strip-br attribute is provided then we strip this out
                if( attrs.stripBr && html == '<br>' ) {
                  html = '';
                }
                ngModel.$setViewValue(html);
              }
            }
          };
        });
    </file>
    <file name="index.html">
      <form name="myForm">
       <div contenteditable
            name="myWidget" ng-model="userContent"
            strip-br="true"
            required>Change me!</div>
        <span ng-show="myForm.myWidget.$error.required">Required!</span>
       <hr>
       <textarea ng-model="userContent"></textarea>
      </form>
    </file>
    <file name="scenario.js">
      it('should data-bind and become invalid', function() {
        var contentEditable = element('[contenteditable]');

        expect(contentEditable.text()).toEqual('Change me!');
        input('userContent').enter('');
        expect(contentEditable.text()).toEqual('');
        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);
      });
    </file>
 * </example>
 *
 *
 */
var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',
    function($scope, $exceptionHandler, $attr, $element, $parse) {
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$pristine = true;
  this.$dirty = false;
  this.$valid = true;
  this.$invalid = false;
  this.$name = $attr.name;

  var ngModelGet = $parse($attr.ngModel),
      ngModelSet = ngModelGet.assign;

  if (!ngModelSet) {
    throw minErr('ngModel')('nonassign', "Expression '{0}' is non-assignable. Element: {1}",
        $attr.ngModel, startingTag($element));
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$render
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Called when the view needs to be updated. It is expected that the user of the ng-model
   * directive will implement this method.
   */
  this.$render = noop;

  /**
   * @ngdoc function
   * @name { ng.directive:ngModel.NgModelController#$isEmpty
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * This is called when we need to determine if the value of the input is empty.
   *
   * For instance, the required directive does this to work out if the input has data or not.
   * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
   *
   * You can override this for input directives whose concept of being empty is different to the
   * default. The `checkboxInputType` directive does this because in its case a value of `false`
   * implies empty.
   */
  this.$isEmpty = function(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  };

  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      $error = this.$error = {}; // keep invalid keys here


  // Setup initial state of the control
  $element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
    $element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setValidity
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Change the validity state, and notifies the form when the control changes validity. (i.e. it
   * does not notify form if given validator is already marked as invalid).
   *
   * This method should be called by validators - i.e. the parser or formatter functions.
   *
   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign
   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.
   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).
   */
  this.$setValidity = function(validationErrorKey, isValid) {
    // Purposeful use of ! here to cast isValid to boolean in case it is undefined
    // jshint -W018
    if ($error[validationErrorKey] === !isValid) return;
    // jshint +W018

    if (isValid) {
      if ($error[validationErrorKey]) invalidCount--;
      if (!invalidCount) {
        toggleValidCss(true);
        this.$valid = true;
        this.$invalid = false;
      }
    } else {
      toggleValidCss(false);
      this.$invalid = true;
      this.$valid = false;
      invalidCount++;
    }

    $error[validationErrorKey] = !isValid;
    toggleValidCss(isValid, validationErrorKey);

    parentForm.$setValidity(validationErrorKey, isValid, this);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setPristine
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Sets the control to its pristine state.
   *
   * This method can be called to remove the 'ng-dirty' class and set the control to its pristine
   * state (ng-pristine class).
   */
  this.$setPristine = function () {
    this.$dirty = false;
    this.$pristine = true;
    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setViewValue
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Update the view value.
   *
   * This method should be called when the view value changes, typically from within a DOM event handler.
   * For example {@link ng.directive:input input} and
   * {@link ng.directive:select select} directives call it.
   *
   * It will update the $viewValue, then pass this value through each of the functions in `$parsers`,
   * which includes any validators. The value that comes out of this `$parsers` pipeline, be applied to
   * `$modelValue` and the **expression** specified in the `ng-model` attribute.
   *
   * Lastly, all the registered change listeners, in the `$viewChangeListeners` list, are called.
   *
   * Note that calling this function does not trigger a `$digest`.
   *
   * @param {string} value Value from the view.
   */
  this.$setViewValue = function(value) {
    this.$viewValue = value;

    // change to dirty
    if (this.$pristine) {
      this.$dirty = true;
      this.$pristine = false;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      parentForm.$setDirty();
    }

    forEach(this.$parsers, function(fn) {
      value = fn(value);
    });

    if (this.$modelValue !== value) {
      this.$modelValue = value;
      ngModelSet($scope, value);
      forEach(this.$viewChangeListeners, function(listener) {
        try {
          listener();
        } catch(e) {
          $exceptionHandler(e);
        }
      });
    }
  };

  // model -> value
  var ctrl = this;

  $scope.$watch(function ngModelWatch() {
    var value = ngModelGet($scope);

    // if scope model value and ngModel value are out of sync
    if (ctrl.$modelValue !== value) {

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      ctrl.$modelValue = value;
      while(idx--) {
        value = formatters[idx](value);
      }

      if (ctrl.$viewValue !== value) {
        ctrl.$viewValue = value;
        ctrl.$render();
      }
    }

    return value;
  });
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngModel
 *
 * @element input
 *
 * @description
 * The `ngModel` directive binds an `input`,`select`, `textarea` (or custom form control) to a
 * property on the scope using {@link ng.directive:ngModel.NgModelController NgModelController},
 * which is created and exposed by this directive.
 *
 * `ngModel` is responsible for:
 *
 * - Binding the view into the model, which other directives such as `input`, `textarea` or `select`
 *   require.
 * - Providing validation behavior (i.e. required, number, email, url).
 * - Keeping the state of the control (valid/invalid, dirty/pristine, validation errors).
 * - Setting related css classes on the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`).
 * - Registering the control with its parent {@link ng.directive:form form}.
 *
 * Note: `ngModel` will try to bind to the property given by evaluating the expression on the
 * current scope. If the property doesn't already exist on this scope, it will be created
 * implicitly and added to the scope.
 *
 * For best practices on using `ngModel`, see:
 *
 *  - {@link https://github.com/angular/angular.js/wiki/Understanding-Scopes}
 *
 * For basic examples, how to use `ngModel`, see:
 *
 *  - {@link ng.directive:input input}
 *    - {@link ng.directive:input.text text}
 *    - {@link ng.directive:input.checkbox checkbox}
 *    - {@link ng.directive:input.radio radio}
 *    - {@link ng.directive:input.number number}
 *    - {@link ng.directive:input.email email}
 *    - {@link ng.directive:input.url url}
 *  - {@link ng.directive:select select}
 *  - {@link ng.directive:textarea textarea}
 *
 */
var ngModelDirective = function() {
  return {
    require: ['ngModel', '^?form'],
    controller: NgModelController,
    link: function(scope, element, attr, ctrls) {
      // notify others, especially parent forms

      var modelCtrl = ctrls[0],
          formCtrl = ctrls[1] || nullFormCtrl;

      formCtrl.$addControl(modelCtrl);

      scope.$on('$destroy', function() {
        formCtrl.$removeControl(modelCtrl);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngChange
 *
 * @description
 * Evaluate given expression when user changes the input.
 * The expression is not evaluated when the value change is coming from the model.
 *
 * Note, this directive requires `ngModel` to be present.
 *
 * @element input
 * @param {expression} ngChange {@link guide/expression Expression} to evaluate upon change
 * in input value.
 *
 * @example
 * <doc:example>
 *   <doc:source>
 *     <script>
 *       function Controller($scope) {
 *         $scope.counter = 0;
 *         $scope.change = function() {
 *           $scope.counter++;
 *         };
 *       }
 *     </script>
 *     <div ng-controller="Controller">
 *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
 *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
 *       <label for="ng-change-example2">Confirmed</label><br />
 *       debug = {{confirmed}}<br />
 *       counter = {{counter}}
 *     </div>
 *   </doc:source>
 *   <doc:scenario>
 *     it('should evaluate the expression if changing from view', function() {
 *       expect(binding('counter')).toEqual('0');
 *       element('#ng-change-example1').click();
 *       expect(binding('counter')).toEqual('1');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
 *
 *     it('should not evaluate the expression if changing from model', function() {
 *       element('#ng-change-example2').click();
 *       expect(binding('counter')).toEqual('0');
 *       expect(binding('confirmed')).toEqual('true');
 *     });
 *   </doc:scenario>
 * </doc:example>
 */
var ngChangeDirective = valueFn({
  require: 'ngModel',
  link: function(scope, element, attr, ctrl) {
    ctrl.$viewChangeListeners.push(function() {
      scope.$eval(attr.ngChange);
    });
  }
});


var requiredDirective = function() {
  return {
    require: '?ngModel',
    link: function(scope, elm, attr, ctrl) {
      if (!ctrl) return;
      attr.required = true; // force truthy in case we are on non input element

      var validator = function(value) {
        if (attr.required && ctrl.$isEmpty(value)) {
          ctrl.$setValidity('required', false);
          return;
        } else {
          ctrl.$setValidity('required', true);
          return value;
        }
      };

      ctrl.$formatters.push(validator);
      ctrl.$parsers.unshift(validator);

      attr.$observe('required', function() {
        validator(ctrl.$viewValue);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngList
 *
 * @description
 * Text input that converts between a delimited string and an array of strings. The delimiter
 * can be a fixed string (by default a comma) or a regular expression.
 *
 * @element input
 * @param {string=} ngList optional delimiter that should be used to split the value. If
 *   specified in form `/something/` then the value will be converted into a regular expression.
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.names = ['igor', 'misko', 'vojta'];
         }
       </script>
       <form name="myForm" ng-controller="Ctrl">
         List: <input name="namesInput" ng-model="names" ng-list required>
         <span class="error" ng-show="myForm.namesInput.$error.required">
           Required!</span>
         <br>
         <tt>names = {{names}}</tt><br/>
         <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
         <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('names')).toEqual('["igor","misko","vojta"]');
          expect(binding('myForm.namesInput.$valid')).toEqual('true');
          expect(element('span.error').css('display')).toBe('none');
        });

        it('should be invalid if empty', function() {
          input('names').enter('');
          expect(binding('names')).toEqual('');
          expect(binding('myForm.namesInput.$valid')).toEqual('false');
          expect(element('span.error').css('display')).not().toBe('none');
        });
      </doc:scenario>
    </doc:example>
 */
var ngListDirective = function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attr, ctrl) {
      var match = /\/(.*)\//.exec(attr.ngList),
          separator = match && new RegExp(match[1]) || attr.ngList || ',';

      var parse = function(viewValue) {
        // If the viewValue is invalid (say required but empty) it will be `undefined`
        if (isUndefined(viewValue)) return;

        var list = [];

        if (viewValue) {
          forEach(viewValue.split(separator), function(value) {
            if (value) list.push(trim(value));
          });
        }

        return list;
      };

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(function(value) {
        if (isArray(value)) {
          return value.join(', ');
        }

        return undefined;
      });

      // Override the standard $isEmpty because an empty array means the input is empty.
      ctrl.$isEmpty = function(value) {
        return !value || !value.length;
      };
    }
  };
};


var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
/**
 * @ngdoc directive
 * @name ng.directive:ngValue
 *
 * @description
 * Binds the given expression to the value of `input[select]` or `input[radio]`, so
 * that when the element is selected, the `ngModel` of that element is set to the
 * bound value.
 *
 * `ngValue` is useful when dynamically generating lists of radio buttons using `ng-repeat`, as
 * shown below.
 *
 * @element input
 * @param {string=} ngValue angular expression, whose value will be bound to the `value` attribute
 *   of the `input` element
 *
 * @example
    <doc:example>
      <doc:source>
       <script>
          function Ctrl($scope) {
            $scope.names = ['pizza', 'unicorns', 'robots'];
            $scope.my = { favorite: 'unicorns' };
          }
       </script>
        <form ng-controller="Ctrl">
          <h2>Which is your favorite?</h2>
            <label ng-repeat="name in names" for="{{name}}">
              {{name}}
              <input type="radio"
                     ng-model="my.favorite"
                     ng-value="name"
                     id="{{name}}"
                     name="favorite">
            </label>
          <div>You chose {{my.favorite}}</div>
        </form>
      </doc:source>
      <doc:scenario>
        it('should initialize to model', function() {
          expect(binding('my.favorite')).toEqual('unicorns');
        });
        it('should bind the values to the inputs', function() {
          input('my.favorite').select('pizza');
          expect(binding('my.favorite')).toEqual('pizza');
        });
      </doc:scenario>
    </doc:example>
 */
var ngValueDirective = function() {
  return {
    priority: 100,
    compile: function(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function ngValueConstantLink(scope, elm, attr) {
          attr.$set('value', scope.$eval(attr.ngValue));
        };
      } else {
        return function ngValueLink(scope, elm, attr) {
          scope.$watch(attr.ngValue, function valueWatchAction(value) {
            attr.$set('value', value);
          });
        };
      }
    }
  };
};

/**
 * @ngdoc directive
 * @name ng.directive:ngBind
 * @restrict AC
 *
 * @description
 * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element
 * with the value of a given expression, and to update the text content when the value of that
 * expression changes.
 *
 * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like
 * `{{ expression }}` which is similar but less verbose.
 *
 * It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily
 * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an
 * element attribute, it makes the bindings invisible to the user while the page is loading.
 *
 * An alternative solution to this problem would be using the
 * {@link ng.directive:ngCloak ngCloak} directive.
 *
 *
 * @element ANY
 * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
 *
 * @example
 * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.name = 'Whirled';
         }
       </script>
       <div ng-controller="Ctrl">
         Enter name: <input type="text" ng-model="name"><br>
         Hello <span ng-bind="name"></span>!
       </div>
     </doc:source>
     <doc:scenario>
       it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('name')).toBe('Whirled');
         using('.doc-example-live').input('name').enter('world');
         expect(using('.doc-example-live').binding('name')).toBe('world');
       });
     </doc:scenario>
   </doc:example>
 */
var ngBindDirective = ngDirective(function(scope, element, attr) {
  element.addClass('ng-binding').data('$binding', attr.ngBind);
  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
    // We are purposefully using == here rather than === because we want to
    // catch when value is "null or undefined"
    // jshint -W041
    element.text(value == undefined ? '' : value);
  });
});


/**
 * @ngdoc directive
 * @name ng.directive:ngBindTemplate
 *
 * @description
 * The `ngBindTemplate` directive specifies that the element
 * text content should be replaced with the interpolation of the template
 * in the `ngBindTemplate` attribute.
 * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`
 * expressions. This directive is needed since some HTML elements
 * (such as TITLE and OPTION) cannot contain SPAN elements.
 *
 * @element ANY
 * @param {string} ngBindTemplate template of form
 *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
 *
 * @example
 * Try it here: enter text in text box and watch the greeting change.
   <doc:example>
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.salutation = 'Hello';
           $scope.name = 'World';
         }
       </script>
       <div ng-controller="Ctrl">
        Salutation: <input type="text" ng-model="salutation"><br>
        Name: <input type="text" ng-model="name"><br>
        <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
       </div>
     </doc:source>
     <doc:scenario>
       it('should check ng-bind', function() {
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Hello');
         expect(using('.doc-example-live').binding('name')).
           toBe('World');
         using('.doc-example-live').input('salutation').enter('Greetings');
         using('.doc-example-live').input('name').enter('user');
         expect(using('.doc-example-live').binding('salutation')).
           toBe('Greetings');
         expect(using('.doc-example-live').binding('name')).
           toBe('user');
       });
     </doc:scenario>
   </doc:example>
 */
var ngBindTemplateDirective = ['$interpolate', function($interpolate) {
  return function(scope, element, attr) {
    // TODO: move this to scenario runner
    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
    element.addClass('ng-binding').data('$binding', interpolateFn);
    attr.$observe('ngBindTemplate', function(value) {
      element.text(value);
    });
  };
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngBindHtml
 *
 * @description
 * Creates a binding that will innerHTML the result of evaluating the `expression` into the current
 * element in a secure way.  By default, the innerHTML-ed content will be sanitized using the {@link
 * ngSanitize.$sanitize $sanitize} service.  To utilize this functionality, ensure that `$sanitize`
 * is available, for example, by including {@link ngSanitize} in your module's dependencies (not in
 * core Angular.)  You may also bypass sanitization for values you know are safe. To do so, bind to
 * an explicitly trusted value via {@link ng.$sce#methods_trustAsHtml $sce.trustAsHtml}.  See the example
 * under {@link ng.$sce#Example Strict Contextual Escaping (SCE)}.
 *
 * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you
 * will have an exception (instead of an exploit.)
 *
 * @element ANY
 * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.
 *
 * @example
   Try it here: enter text in text box and watch the greeting change.
 
   <example module="ngBindHtmlExample" deps="angular-sanitize.js">
     <file name="index.html">
       <div ng-controller="ngBindHtmlCtrl">
        <p ng-bind-html="myHTML"></p>
       </div>
     </file>
     
     <file name="script.js">
       angular.module('ngBindHtmlExample', ['ngSanitize'])

       .controller('ngBindHtmlCtrl', ['$scope', function ngBindHtmlCtrl($scope) {
         $scope.myHTML =
            'I am an <code>HTML</code>string with <a href="#">links!</a> and other <em>stuff</em>';
       }]);
     </file>

     <file name="scenario.js">
       it('should check ng-bind-html', function() {
         expect(using('.doc-example-live').binding('myHTML')).
           toBe(
           'I am an <code>HTML</code>string with <a href="#">links!</a> and other <em>stuff</em>'
           );
       });
     </file>
   </example>
 */
var ngBindHtmlDirective = ['$sce', '$parse', function($sce, $parse) {
  return function(scope, element, attr) {
    element.addClass('ng-binding').data('$binding', attr.ngBindHtml);

    var parsed = $parse(attr.ngBindHtml);
    function getStringValue() { return (parsed(scope) || '').toString(); }

    scope.$watch(getStringValue, function ngBindHtmlWatchAction(value) {
      element.html($sce.getTrustedHtml(parsed(scope)) || '');
    });
  };
}];

function classDirective(name, selector) {
  name = 'ngClass' + name;
  return function() {
    return {
      restrict: 'AC',
      link: function(scope, element, attr) {
        var oldVal;

        scope.$watch(attr[name], ngClassWatchAction, true);

        attr.$observe('class', function(value) {
          ngClassWatchAction(scope.$eval(attr[name]));
        });


        if (name !== 'ngClass') {
          scope.$watch('$index', function($index, old$index) {
            // jshint bitwise: false
            var mod = $index & 1;
            if (mod !== old$index & 1) {
              var classes = flattenClasses(scope.$eval(attr[name]));
              mod === selector ?
                attr.$addClass(classes) :
                attr.$removeClass(classes);
            }
          });
        }


        function ngClassWatchAction(newVal) {
          if (selector === true || scope.$index % 2 === selector) {
            var newClasses = flattenClasses(newVal || '');
            if(!oldVal) {
              attr.$addClass(newClasses);
            } else if(!equals(newVal,oldVal)) {
              attr.$updateClass(newClasses, flattenClasses(oldVal));
            }
          }
          oldVal = copy(newVal);
        }


        function flattenClasses(classVal) {
          if(isArray(classVal)) {
            return classVal.join(' ');
          } else if (isObject(classVal)) {
            var classes = [], i = 0;
            forEach(classVal, function(v, k) {
              if (v) {
                classes.push(k);
              }
            });
            return classes.join(' ');
          }

          return classVal;
        }
      }
    };
  };
}

/**
 * @ngdoc directive
 * @name ng.directive:ngClass
 * @restrict AC
 *
 * @description
 * The `ngClass` directive allows you to dynamically set CSS classes on an HTML element by databinding
 * an expression that represents all classes to be added.
 *
 * The directive won't add duplicate classes if a particular class was already set.
 *
 * When the expression changes, the previously added classes are removed and only then the
 * new classes are added.
 *
 * @animations
 * add - happens just before the class is applied to the element
 * remove - happens just before the class is removed from the element
 *
 * @element ANY
 * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class
 *   names, an array, or a map of class names to boolean values. In the case of a map, the
 *   names of the properties whose values are truthy will be added as css classes to the
 *   element.
 *
 * @example Example that demonstrates basic bindings via ngClass directive.
   <example>
     <file name="index.html">
       <p ng-class="{strike: deleted, bold: important, red: error}">Map Syntax Example</p>
       <input type="checkbox" ng-model="deleted"> deleted (apply "strike" class)<br>
       <input type="checkbox" ng-model="important"> important (apply "bold" class)<br>
       <input type="checkbox" ng-model="error"> error (apply "red" class)
       <hr>
       <p ng-class="style">Using String Syntax</p>
       <input type="text" ng-model="style" placeholder="Type: bold strike red">
       <hr>
       <p ng-class="[style1, style2, style3]">Using Array Syntax</p>
       <input ng-model="style1" placeholder="Type: bold, strike or red"><br>
       <input ng-model="style2" placeholder="Type: bold, strike or red"><br>
       <input ng-model="style3" placeholder="Type: bold, strike or red"><br>
     </file>
     <file name="style.css">
       .strike {
         text-decoration: line-through;
       }
       .bold {
           font-weight: bold;
       }
       .red {
           color: red;
       }
     </file>
     <file name="scenario.js">
       it('should let you toggle the class', function() {

         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/bold/);
         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/red/);

         input('important').check();
         expect(element('.doc-example-live p:first').prop('className')).toMatch(/bold/);

         input('error').check();
         expect(element('.doc-example-live p:first').prop('className')).toMatch(/red/);
       });

       it('should let you toggle string example', function() {
         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('');
         input('style').enter('red');
         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('red');
       });

       it('array example should have 3 classes', function() {
         expect(element('.doc-example-live p:last').prop('className')).toBe('');
         input('style1').enter('bold');
         input('style2').enter('strike');
         input('style3').enter('red');
         expect(element('.doc-example-live p:last').prop('className')).toBe('bold strike red');
       });
     </file>
   </example>

   ## Animations

   The example below demonstrates how to perform animations using ngClass.

   <example animations="true">
     <file name="index.html">
      <input type="button" value="set" ng-click="myVar='my-class'">
      <input type="button" value="clear" ng-click="myVar=''">
      <br>
      <span class="base-class" ng-class="myVar">Sample Text</span>
     </file>
     <file name="style.css">
       .base-class {
         -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
       }

       .base-class.my-class {
         color: red;
         font-size:3em;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class', function() {
         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:first').click();

         expect(element('.doc-example-live span').prop('className')).
           toMatch(/my-class/);

         using('.doc-example-live').element(':button:last').click();

         expect(element('.doc-example-live span').prop('className')).not().
           toMatch(/my-class/);
       });
     </file>
   </example>


   ## ngClass and pre-existing CSS3 Transitions/Animations
   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.
   Upon animation ngAnimate will apply supplementary CSS classes to track the start and end of an animation, but this will not hinder
   any pre-existing CSS transitions already on the element. To get an idea of what happens during a class-based animation, be sure
   to view the step by step details of {@link ngAnimate.$animate#methods_addclass $animate.addClass} and
   {@link ngAnimate.$animate#methods_removeclass $animate.removeClass}.
 */
var ngClassDirective = classDirective('', true);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassOdd
 * @restrict AC
 *
 * @description
 * The `ngClassOdd` and `ngClassEven` directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except they work in
 * conjunction with `ngRepeat` and take effect only on odd (even) rows.
 *
 * This directive can be applied only within the scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   <example>
     <file name="index.html">
        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
          <li ng-repeat="name in names">
           <span ng-class-odd="'odd'" ng-class-even="'even'">
             {{name}}
           </span>
          </li>
        </ol>
     </file>
     <file name="style.css">
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
   </example>
 */
var ngClassOddDirective = classDirective('Odd', 0);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassEven
 * @restrict AC
 *
 * @description
 * The `ngClassOdd` and `ngClassEven` directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except they work in
 * conjunction with `ngRepeat` and take effect only on odd (even) rows.
 *
 * This directive can be applied only within the scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
 *   result of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   <example>
     <file name="index.html">
        <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
          <li ng-repeat="name in names">
           <span ng-class-odd="'odd'" ng-class-even="'even'">
             {{name}} &nbsp; &nbsp; &nbsp;
           </span>
          </li>
        </ol>
     </file>
     <file name="style.css">
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-class-odd and ng-class-even', function() {
         expect(element('.doc-example-live li:first span').prop('className')).
           toMatch(/odd/);
         expect(element('.doc-example-live li:last span').prop('className')).
           toMatch(/even/);
       });
     </file>
   </example>
 */
var ngClassEvenDirective = classDirective('Even', 1);

/**
 * @ngdoc directive
 * @name ng.directive:ngCloak
 * @restrict AC
 *
 * @description
 * The `ngCloak` directive is used to prevent the Angular html template from being briefly
 * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
 * directive to avoid the undesirable flicker effect caused by the html template display.
 *
 * The directive can be applied to the `<body>` element, but the preferred usage is to apply
 * multiple `ngCloak` directives to small portions of the page to permit progressive rendering
 * of the browser view.
 *
 * `ngCloak` works in cooperation with the following css rule embedded within `angular.js` and
 * `angular.min.js`.
 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
 *
 * <pre>
 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
 *   display: none !important;
 * }
 * </pre>
 *
 * When this css rule is loaded by the browser, all html elements (including their children) that
 * are tagged with the `ngCloak` directive are hidden. When Angular encounters this directive
 * during the compilation of the template it deletes the `ngCloak` element attribute, making
 * the compiled element visible.
 *
 * For the best result, the `angular.js` script must be loaded in the head section of the html
 * document; alternatively, the css rule above must be included in the external stylesheet of the
 * application.
 *
 * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
 * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
 * class `ng-cloak` in addition to the `ngCloak` directive as shown in the example below.
 *
 * @element ANY
 *
 * @example
   <doc:example>
     <doc:source>
        <div id="template1" ng-cloak>{{ 'hello' }}</div>
        <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
     </doc:source>
     <doc:scenario>
       it('should remove the template directive and css class', function() {
         expect(element('.doc-example-live #template1').attr('ng-cloak')).
           not().toBeDefined();
         expect(element('.doc-example-live #template2').attr('ng-cloak')).
           not().toBeDefined();
       });
     </doc:scenario>
   </doc:example>
 *
 */
var ngCloakDirective = ngDirective({
  compile: function(element, attr) {
    attr.$set('ngCloak', undefined);
    element.removeClass('ng-cloak');
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngController
 *
 * @description
 * The `ngController` directive attaches a controller class to the view. This is a key aspect of how angular
 * supports the principles behind the Model-View-Controller design pattern.
 *
 * MVC components in angular:
 *
 * * Model — The Model is scope properties; scopes are attached to the DOM where scope properties
 *   are accessed through bindings.
 * * View — The template (HTML with data bindings) that is rendered into the View.
 * * Controller — The `ngController` directive specifies a Controller class; the class contains business
 *   logic behind the application to decorate the scope with functions and values
 *
 * Note that you can also attach controllers to the DOM by declaring it in a route definition
 * via the {@link ngRoute.$route $route} service. A common mistake is to declare the controller
 * again using `ng-controller` in the template itself.  This will cause the controller to be attached
 * and executed twice.
 *
 * @element ANY
 * @scope
 * @param {expression} ngController Name of a globally accessible constructor function or an
 *     {@link guide/expression expression} that on the current scope evaluates to a
 *     constructor function. The controller instance can be published into a scope property
 *     by specifying `as propertyName`.
 *
 * @example
 * Here is a simple form for editing user contact information. Adding, removing, clearing, and
 * greeting are methods declared on the controller (see source tab). These methods can
 * easily be called from the angular markup. Notice that the scope becomes the `this` for the
 * controller's instance. This allows for easy access to the view data from the controller. Also
 * notice that any changes to the data are automatically reflected in the View without the need
 * for a manual update. The example is shown in two different declaration styles you may use
 * according to preference.
   <doc:example>
     <doc:source>
      <script>
        function SettingsController1() {
          this.name = "John Smith";
          this.contacts = [
            {type: 'phone', value: '408 555 1212'},
            {type: 'email', value: 'john.smith@example.org'} ];
          };

        SettingsController1.prototype.greet = function() {
          alert(this.name);
        };

        SettingsController1.prototype.addContact = function() {
          this.contacts.push({type: 'email', value: 'yourname@example.org'});
        };

        SettingsController1.prototype.removeContact = function(contactToRemove) {
         var index = this.contacts.indexOf(contactToRemove);
          this.contacts.splice(index, 1);
        };

        SettingsController1.prototype.clearContact = function(contact) {
          contact.type = 'phone';
          contact.value = '';
        };
      </script>
      <div id="ctrl-as-exmpl" ng-controller="SettingsController1 as settings">
        Name: <input type="text" ng-model="settings.name"/>
        [ <a href="" ng-click="settings.greet()">greet</a> ]<br/>
        Contact:
        <ul>
          <li ng-repeat="contact in settings.contacts">
            <select ng-model="contact.type">
               <option>phone</option>
               <option>email</option>
            </select>
            <input type="text" ng-model="contact.value"/>
            [ <a href="" ng-click="settings.clearContact(contact)">clear</a>
            | <a href="" ng-click="settings.removeContact(contact)">X</a> ]
          </li>
          <li>[ <a href="" ng-click="settings.addContact()">add</a> ]</li>
       </ul>
      </div>
     </doc:source>
     <doc:scenario>
       it('should check controller as', function() {
         expect(element('#ctrl-as-exmpl>:input').val()).toBe('John Smith');
         expect(element('#ctrl-as-exmpl li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('#ctrl-as-exmpl li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

         element('#ctrl-as-exmpl li:first a:contains("clear")').click();
         expect(element('#ctrl-as-exmpl li:first input').val()).toBe('');

         element('#ctrl-as-exmpl li:last a:contains("add")').click();
         expect(element('#ctrl-as-exmpl li:nth-child(3) input').val())
           .toBe('yourname@example.org');
       });
     </doc:scenario>
   </doc:example>
    <doc:example>
     <doc:source>
      <script>
        function SettingsController2($scope) {
          $scope.name = "John Smith";
          $scope.contacts = [
            {type:'phone', value:'408 555 1212'},
            {type:'email', value:'john.smith@example.org'} ];

          $scope.greet = function() {
           alert(this.name);
          };

          $scope.addContact = function() {
           this.contacts.push({type:'email', value:'yourname@example.org'});
          };

          $scope.removeContact = function(contactToRemove) {
           var index = this.contacts.indexOf(contactToRemove);
           this.contacts.splice(index, 1);
          };

          $scope.clearContact = function(contact) {
           contact.type = 'phone';
           contact.value = '';
          };
        }
      </script>
      <div id="ctrl-exmpl" ng-controller="SettingsController2">
        Name: <input type="text" ng-model="name"/>
        [ <a href="" ng-click="greet()">greet</a> ]<br/>
        Contact:
        <ul>
          <li ng-repeat="contact in contacts">
            <select ng-model="contact.type">
               <option>phone</option>
               <option>email</option>
            </select>
            <input type="text" ng-model="contact.value"/>
            [ <a href="" ng-click="clearContact(contact)">clear</a>
            | <a href="" ng-click="removeContact(contact)">X</a> ]
          </li>
          <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
       </ul>
      </div>
     </doc:source>
     <doc:scenario>
       it('should check controller', function() {
         expect(element('#ctrl-exmpl>:input').val()).toBe('John Smith');
         expect(element('#ctrl-exmpl li:nth-child(1) input').val())
           .toBe('408 555 1212');
         expect(element('#ctrl-exmpl li:nth-child(2) input').val())
           .toBe('john.smith@example.org');

         element('#ctrl-exmpl li:first a:contains("clear")').click();
         expect(element('#ctrl-exmpl li:first input').val()).toBe('');

         element('#ctrl-exmpl li:last a:contains("add")').click();
         expect(element('#ctrl-exmpl li:nth-child(3) input').val())
           .toBe('yourname@example.org');
       });
     </doc:scenario>
   </doc:example>

 */
var ngControllerDirective = [function() {
  return {
    scope: true,
    controller: '@',
    priority: 500
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngCsp
 *
 * @element html
 * @description
 * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
 *
 * This is necessary when developing things like Google Chrome Extensions.
 *
 * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).
 * For us to be compatible, we just need to implement the "getterFn" in $parse without violating
 * any of these restrictions.
 *
 * AngularJS uses `Function(string)` generated functions as a speed optimization. Applying the `ngCsp`
 * directive will cause Angular to use CSP compatibility mode. When this mode is on AngularJS will
 * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
 * be raised.
 *
 * CSP forbids JavaScript to inline stylesheet rules. In non CSP mode Angular automatically
 * includes some CSS rules (e.g. {@link ng.directive:ngCloak ngCloak}).
 * To make those directives work in CSP mode, include the `angular-csp.css` manually.
 *
 * In order to use this feature put the `ngCsp` directive on the root element of the application.
 *
 * *Note: This directive is only available in the `ng-csp` and `data-ng-csp` attribute form.*
 *
 * @example
 * This example shows how to apply the `ngCsp` directive to the `html` tag.
   <pre>
     <!doctype html>
     <html ng-app ng-csp>
     ...
     ...
     </html>
   </pre>
 */

// ngCsp is not implemented as a proper directive any more, because we need it be processed while we bootstrap
// the system (before $parse is instantiated), for this reason we just have a csp() fn that looks for ng-csp attribute
// anywhere in the current doc

/**
 * @ngdoc directive
 * @name ng.directive:ngClick
 *
 * @description
 * The ngClick directive allows you to specify custom behavior when
 * an element is clicked.
 *
 * @element ANY
 * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
 * click. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-click="count = count + 1" ng-init="count=0">
        Increment
      </button>
      count: {{count}}
     </doc:source>
     <doc:scenario>
       it('should check ng-click', function() {
         expect(binding('count')).toBe('0');
         element('.doc-example-live :button').click();
         expect(binding('count')).toBe('1');
       });
     </doc:scenario>
   </doc:example>
 */
/*
 * A directive that allows creation of custom onclick handlers that are defined as angular
 * expressions and are compiled and executed within the current scope.
 *
 * Events that are handled via these handler are always configured not to propagate further.
 */
var ngEventDirectives = {};
forEach(
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '),
  function(name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = ['$parse', function($parse) {
      return {
        compile: function($element, attr) {
          var fn = $parse(attr[directiveName]);
          return function(scope, element, attr) {
            element.on(lowercase(name), function(event) {
              scope.$apply(function() {
                fn(scope, {$event:event});
              });
            });
          };
        }
      };
    }];
  }
);

/**
 * @ngdoc directive
 * @name ng.directive:ngDblclick
 *
 * @description
 * The `ngDblclick` directive allows you to specify custom behavior on a dblclick event.
 *
 * @element ANY
 * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
 * a dblclick. (The Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-dblclick="count = count + 1" ng-init="count=0">
        Increment (on double click)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousedown
 *
 * @description
 * The ngMousedown directive allows you to specify custom behavior on mousedown event.
 *
 * @element ANY
 * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
 * mousedown. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-mousedown="count = count + 1" ng-init="count=0">
        Increment (on mouse down)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseup
 *
 * @description
 * Specify custom behavior on mouseup event.
 *
 * @element ANY
 * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
 * mouseup. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-mouseup="count = count + 1" ng-init="count=0">
        Increment (on mouse up)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngMouseover
 *
 * @description
 * Specify custom behavior on mouseover event.
 *
 * @element ANY
 * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
 * mouseover. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-mouseover="count = count + 1" ng-init="count=0">
        Increment (when mouse is over)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseenter
 *
 * @description
 * Specify custom behavior on mouseenter event.
 *
 * @element ANY
 * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
 * mouseenter. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-mouseenter="count = count + 1" ng-init="count=0">
        Increment (when mouse enters)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseleave
 *
 * @description
 * Specify custom behavior on mouseleave event.
 *
 * @element ANY
 * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
 * mouseleave. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-mouseleave="count = count + 1" ng-init="count=0">
        Increment (when mouse leaves)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousemove
 *
 * @description
 * Specify custom behavior on mousemove event.
 *
 * @element ANY
 * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
 * mousemove. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <button ng-mousemove="count = count + 1" ng-init="count=0">
        Increment (when mouse moves)
      </button>
      count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeydown
 *
 * @description
 * Specify custom behavior on keydown event.
 *
 * @element ANY
 * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
 * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
   <doc:example>
     <doc:source>
      <input ng-keydown="count = count + 1" ng-init="count=0">
      key down count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeyup
 *
 * @description
 * Specify custom behavior on keyup event.
 *
 * @element ANY
 * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
 * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
   <doc:example>
     <doc:source>
      <input ng-keyup="count = count + 1" ng-init="count=0">
      key up count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeypress
 *
 * @description
 * Specify custom behavior on keypress event.
 *
 * @element ANY
 * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
 * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
   <doc:example>
     <doc:source>
      <input ng-keypress="count = count + 1" ng-init="count=0">
      key press count: {{count}}
     </doc:source>
   </doc:example>
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSubmit
 *
 * @description
 * Enables binding angular expressions to onsubmit events.
 *
 * Additionally it prevents the default action (which for form means sending the request to the
 * server and reloading the current page) **but only if the form does not contain an `action`
 * attribute**.
 *
 * @element form
 * @param {expression} ngSubmit {@link guide/expression Expression} to eval. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <script>
        function Ctrl($scope) {
          $scope.list = [];
          $scope.text = 'hello';
          $scope.submit = function() {
            if (this.text) {
              this.list.push(this.text);
              this.text = '';
            }
          };
        }
      </script>
      <form ng-submit="submit()" ng-controller="Ctrl">
        Enter text and hit enter:
        <input type="text" ng-model="text" name="text" />
        <input type="submit" id="submit" value="Submit" />
        <pre>list={{list}}</pre>
      </form>
     </doc:source>
     <doc:scenario>
       it('should check ng-submit', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
         expect(input('text').val()).toBe('');
       });
       it('should ignore empty strings', function() {
         expect(binding('list')).toBe('[]');
         element('.doc-example-live #submit').click();
         element('.doc-example-live #submit').click();
         expect(binding('list')).toBe('["hello"]');
       });
     </doc:scenario>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngFocus
 *
 * @description
 * Specify custom behavior on focus event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon
 * focus. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngBlur
 *
 * @description
 * Specify custom behavior on blur event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon
 * blur. (Event object is available as `$event`)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngCopy
 *
 * @description
 * Specify custom behavior on copy event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngCopy {@link guide/expression Expression} to evaluate upon
 * copy. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <input ng-copy="copied=true" ng-init="copied=false; value='copy me'" ng-model="value">
      copied: {{copied}}
     </doc:source>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngCut
 *
 * @description
 * Specify custom behavior on cut event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngCut {@link guide/expression Expression} to evaluate upon
 * cut. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <input ng-cut="cut=true" ng-init="cut=false; value='cut me'" ng-model="value">
      cut: {{cut}}
     </doc:source>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngPaste
 *
 * @description
 * Specify custom behavior on paste event.
 *
 * @element window, input, select, textarea, a
 * @param {expression} ngPaste {@link guide/expression Expression} to evaluate upon
 * paste. (Event object is available as `$event`)
 *
 * @example
   <doc:example>
     <doc:source>
      <input ng-paste="paste=true" ng-init="paste=false" placeholder='paste here'>
      pasted: {{paste}}
     </doc:source>
   </doc:example>
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngIf
 * @restrict A
 *
 * @description
 * The `ngIf` directive removes or recreates a portion of the DOM tree based on an
 * {expression}. If the expression assigned to `ngIf` evaluates to a false
 * value then the element is removed from the DOM, otherwise a clone of the
 * element is reinserted into the DOM.
 *
 * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the
 * element in the DOM rather than changing its visibility via the `display` css property.  A common
 * case when this difference is significant is when using css selectors that rely on an element's
 * position within the DOM, such as the `:first-child` or `:last-child` pseudo-classes.
 *
 * Note that when an element is removed using `ngIf` its scope is destroyed and a new scope
 * is created when the element is restored.  The scope created within `ngIf` inherits from
 * its parent scope using
 * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.
 * An important implication of this is if `ngModel` is used within `ngIf` to bind to
 * a javascript primitive defined in the parent scope. In this case any modifications made to the
 * variable within the child scope will override (hide) the value in the parent scope.
 *
 * Also, `ngIf` recreates elements using their compiled state. An example of this behavior
 * is if an element's class attribute is directly modified after it's compiled, using something like
 * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element
 * the added class will be lost because the original compiled state is used to regenerate the element.
 *
 * Additionally, you can provide animations via the `ngAnimate` module to animate the `enter`
 * and `leave` effects.
 *
 * @animations
 * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container
 * leave - happens just before the ngIf contents are removed from the DOM
 *
 * @element ANY
 * @scope
 * @priority 600
 * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
 *     the element is removed from the DOM tree. If it is truthy a copy of the compiled
 *     element is added to the DOM tree.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked" ng-init="checked=true" /><br/>
      Show when checked:
      <span ng-if="checked" class="animate-if">
        I'm removed when the checkbox is unchecked.
      </span>
    </file>
    <file name="animations.css">
      .animate-if {
        background:white;
        border:1px solid black;
        padding:10px;
      }

      .animate-if.ng-enter, .animate-if.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

      .animate-if.ng-enter,
      .animate-if.ng-leave.ng-leave-active {
        opacity:0;
      }

      .animate-if.ng-leave,
      .animate-if.ng-enter.ng-enter-active {
        opacity:1;
      }
    </file>
  </example>
 */
var ngIfDirective = ['$animate', function($animate) {
  return {
    transclude: 'element',
    priority: 600,
    terminal: true,
    restrict: 'A',
    $$tlb: true,
    link: function ($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {

          if (toBoolean(value)) {
            if (!childScope) {
              childScope = $scope.$new();
              $transclude(childScope, function (clone) {
                clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                // by a directive with templateUrl when it's template arrives.
                block = {
                  clone: clone
                };
                $animate.enter(clone, $element.parent(), $element);
              });
            }
          } else {

            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }

            if (block) {
              $animate.leave(getBlockElements(block.clone));
              block = null;
            }
          }
        });
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInclude
 * @restrict ECA
 *
 * @description
 * Fetches, compiles and includes an external HTML fragment.
 *
 * By default, the template URL is restricted to the same domain and protocol as the
 * application document. This is done by calling {@link ng.$sce#methods_getTrustedResourceUrl
 * $sce.getTrustedResourceUrl} on it. To load templates from other domains or protocols
 * you may either {@link ng.$sceDelegateProvider#methods_resourceUrlWhitelist whitelist them} or
 * {@link ng.$sce#methods_trustAsResourceUrl wrap them} as trusted values. Refer to Angular's {@link
 * ng.$sce Strict Contextual Escaping}.
 *
 * In addition, the browser's
 * {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest
 * Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing
 * (CORS)} policy may further restrict whether the template is successfully loaded.
 * For example, `ngInclude` won't work for cross-domain requests on all browsers and for `file://`
 * access on some browsers.
 *
 * @animations
 * enter - animation is used to bring new content into the browser.
 * leave - animation is used to animate existing content away.
 *
 * The enter and leave animation occur concurrently.
 *
 * @scope
 * @priority 400
 *
 * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
 *                 make sure you wrap it in quotes, e.g. `src="'myPartialTemplate.html'"`.
 * @param {string=} onload Expression to evaluate when a new partial is loaded.
 *
 * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll
 *                  $anchorScroll} to scroll the viewport after the content is loaded.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
 *
 * @example
  <example animations="true">
    <file name="index.html">
     <div ng-controller="Ctrl">
       <select ng-model="template" ng-options="t.name for t in templates">
        <option value="">(blank)</option>
       </select>
       url of the template: <tt>{{template.url}}</tt>
       <hr/>
       <div class="slide-animate-container">
         <div class="slide-animate" ng-include="template.url"></div>
       </div>
     </div>
    </file>
    <file name="script.js">
      function Ctrl($scope) {
        $scope.templates =
          [ { name: 'template1.html', url: 'template1.html'}
          , { name: 'template2.html', url: 'template2.html'} ];
        $scope.template = $scope.templates[0];
      }
     </file>
    <file name="template1.html">
      Content of template1.html
    </file>
    <file name="template2.html">
      Content of template2.html
    </file>
    <file name="animations.css">
      .slide-animate-container {
        position:relative;
        background:white;
        border:1px solid black;
        height:40px;
        overflow:hidden;
      }

      .slide-animate {
        padding:10px;
      }

      .slide-animate.ng-enter, .slide-animate.ng-leave {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
        display:block;
        padding:10px;
      }

      .slide-animate.ng-enter {
        top:-50px;
      }
      .slide-animate.ng-enter.ng-enter-active {
        top:0;
      }

      .slide-animate.ng-leave {
        top:0;
      }
      .slide-animate.ng-leave.ng-leave-active {
        top:50px;
      }
    </file>
    <file name="scenario.js">
      it('should load template1.html', function() {
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template1.html/);
      });
      it('should load template2.html', function() {
       select('template').option('1');
       expect(element('.doc-example-live [ng-include]').text()).
         toMatch(/Content of template2.html/);
      });
      it('should change to blank', function() {
       select('template').option('');
       expect(element('.doc-example-live [ng-include]')).toBe(undefined);
      });
    </file>
  </example>
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentRequested
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the scope ngInclude was declared in
 * @description
 * Emitted every time the ngInclude content is requested.
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentLoaded
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the current ngInclude scope
 * @description
 * Emitted every time the ngInclude content is reloaded.
 */
var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$animate', '$sce',
                  function($http,   $templateCache,   $anchorScroll,   $animate,   $sce) {
  return {
    restrict: 'ECA',
    priority: 400,
    terminal: true,
    transclude: 'element',
    controller: angular.noop,
    compile: function(element, attr) {
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || '',
          autoScrollExp = attr.autoscroll;

      return function(scope, $element, $attr, ctrl, $transclude) {
        var changeCounter = 0,
            currentScope,
            currentElement;

        var cleanupLastIncludeContent = function() {
          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }
          if(currentElement) {
            $animate.leave(currentElement);
            currentElement = null;
          }
        };

        scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
          var afterAnimation = function() {
            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
              $anchorScroll();
            }
          };
          var thisChangeId = ++changeCounter;

          if (src) {
            $http.get(src, {cache: $templateCache}).success(function(response) {
              if (thisChangeId !== changeCounter) return;
              var newScope = scope.$new();
              ctrl.template = response;

              // Note: This will also link all children of ng-include that were contained in the original
              // html. If that content contains controllers, ... they could pollute/change the scope.
              // However, using ng-include on an element with additional content does not make sense...
              // Note: We can't remove them in the cloneAttchFn of $transclude as that
              // function is called before linking the content, which would apply child
              // directives to non existing elements.
              var clone = $transclude(newScope, function(clone) {
                cleanupLastIncludeContent();
                $animate.enter(clone, null, $element, afterAnimation);
              });

              currentScope = newScope;
              currentElement = clone;

              currentScope.$emit('$includeContentLoaded');
              scope.$eval(onloadExp);
            }).error(function() {
              if (thisChangeId === changeCounter) cleanupLastIncludeContent();
            });
            scope.$emit('$includeContentRequested');
          } else {
            cleanupLastIncludeContent();
            ctrl.template = null;
          }
        });
      };
    }
  };
}];

// This directive is called during the $transclude call of the first `ngInclude` directive.
// It will replace and compile the content of the element with the loaded template.
// We need this directive so that the element content is already filled when
// the link function of another directive on the same element as ngInclude
// is called.
var ngIncludeFillContentDirective = ['$compile',
  function($compile) {
    return {
      restrict: 'ECA',
      priority: -400,
      require: 'ngInclude',
      link: function(scope, $element, $attr, ctrl) {
        $element.html(ctrl.template);
        $compile($element.contents())(scope);
      }
    };
  }];

/**
 * @ngdoc directive
 * @name ng.directive:ngInit
 * @restrict AC
 *
 * @description
 * The `ngInit` directive allows you to evaluate an expression in the
 * current scope.
 *
 * <div class="alert alert-error">
 * The only appropriate use of `ngInit` is for aliasing special properties of
 * {@link api/ng.directive:ngRepeat `ngRepeat`}, as seen in the demo below. Besides this case, you
 * should use {@link guide/controller controllers} rather than `ngInit`
 * to initialize values on a scope.
 * </div>
 *
 * @priority 450
 *
 * @element ANY
 * @param {expression} ngInit {@link guide/expression Expression} to eval.
 *
 * @example
   <doc:example>
     <doc:source>
   <script>
     function Ctrl($scope) {
       $scope.list = [['a', 'b'], ['c', 'd']];
     }
   </script>
   <div ng-controller="Ctrl">
     <div ng-repeat="innerList in list" ng-init="outerIndex = $index">
       <div ng-repeat="value in innerList" ng-init="innerIndex = $index">
          <span class="example-init">list[ {{outerIndex}} ][ {{innerIndex}} ] = {{value}};</span>
       </div>
     </div>
   </div>
     </doc:source>
     <doc:scenario>
       it('should alias index positions', function() {
         expect(element('.example-init').text())
           .toBe('list[ 0 ][ 0 ] = a;' +
                 'list[ 0 ][ 1 ] = b;' +
                 'list[ 1 ][ 0 ] = c;' +
                 'list[ 1 ][ 1 ] = d;');
       });
     </doc:scenario>
   </doc:example>
 */
var ngInitDirective = ngDirective({
  priority: 450,
  compile: function() {
    return {
      pre: function(scope, element, attrs) {
        scope.$eval(attrs.ngInit);
      }
    };
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngNonBindable
 * @restrict AC
 * @priority 1000
 *
 * @description
 * The `ngNonBindable` directive tells Angular not to compile or bind the contents of the current
 * DOM element. This is useful if the element contains what appears to be Angular directives and
 * bindings but which should be ignored by Angular. This could be the case if you have a site that
 * displays snippets of code, for instance.
 *
 * @element ANY
 *
 * @example
 * In this example there are two locations where a simple interpolation binding (`{{}}`) is present,
 * but the one wrapped in `ngNonBindable` is left alone.
 *
 * @example
    <doc:example>
      <doc:source>
        <div>Normal: {{1 + 2}}</div>
        <div ng-non-bindable>Ignored: {{1 + 2}}</div>
      </doc:source>
      <doc:scenario>
       it('should check ng-non-bindable', function() {
         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');
         expect(using('.doc-example-live').element('div:last').text()).
           toMatch(/1 \+ 2/);
       });
      </doc:scenario>
    </doc:example>
 */
var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });

/**
 * @ngdoc directive
 * @name ng.directive:ngPluralize
 * @restrict EA
 *
 * @description
 * # Overview
 * `ngPluralize` is a directive that displays messages according to en-US localization rules.
 * These rules are bundled with angular.js, but can be overridden
 * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
 * by specifying the mappings between
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} and the strings to be displayed.
 *
 * # Plural categories and explicit number rules
 * There are two
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} in Angular's default en-US locale: "one" and "other".
 *
 * While a plural category may match many numbers (for example, in en-US locale, "other" can match
 * any number that is not 1), an explicit number rule can only match one number. For example, the
 * explicit number rule for "3" matches the number 3. There are examples of plural categories
 * and explicit number rules throughout the rest of this documentation.
 *
 * # Configuring ngPluralize
 * You configure ngPluralize by providing 2 attributes: `count` and `when`.
 * You can also provide an optional attribute, `offset`.
 *
 * The value of the `count` attribute can be either a string or an {@link guide/expression
 * Angular expression}; these are evaluated on the current scope for its bound value.
 *
 * The `when` attribute specifies the mappings between plural categories and the actual
 * string to be displayed. The value of the attribute should be a JSON object.
 *
 * The following example shows how to configure ngPluralize:
 *
 * <pre>
 * <ng-pluralize count="personCount"
                 when="{'0': 'Nobody is viewing.',
 *                      'one': '1 person is viewing.',
 *                      'other': '{} people are viewing.'}">
 * </ng-pluralize>
 *</pre>
 *
 * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
 * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
 * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
 * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
 * show "a dozen people are viewing".
 *
 * You can use a set of closed braces (`{}`) as a placeholder for the number that you want substituted
 * into pluralized strings. In the previous example, Angular will replace `{}` with
 * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
 * for <span ng-non-bindable>{{numberExpression}}</span>.
 *
 * # Configuring ngPluralize with offset
 * The `offset` attribute allows further customization of pluralized text, which can result in
 * a better user experience. For example, instead of the message "4 people are viewing this document",
 * you might display "John, Kate and 2 others are viewing this document".
 * The offset attribute allows you to offset a number by any desired value.
 * Let's take a look at an example:
 *
 * <pre>
 * <ng-pluralize count="personCount" offset=2
 *               when="{'0': 'Nobody is viewing.',
 *                      '1': '{{person1}} is viewing.',
 *                      '2': '{{person1}} and {{person2}} are viewing.',
 *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',
 *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
 * </ng-pluralize>
 * </pre>
 *
 * Notice that we are still using two plural categories(one, other), but we added
 * three explicit number rules 0, 1 and 2.
 * When one person, perhaps John, views the document, "John is viewing" will be shown.
 * When three people view the document, no explicit number rule is found, so
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
 * In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"
 * is shown.
 *
 * Note that when you specify offsets, you must provide explicit number rules for
 * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
 * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
 * plural categories "one" and "other".
 *
 * @param {string|expression} count The variable to be bounded to.
 * @param {string} when The mapping between plural category to its corresponding strings.
 * @param {number=} offset Offset to deduct from the total number.
 *
 * @example
    <doc:example>
      <doc:source>
        <script>
          function Ctrl($scope) {
            $scope.person1 = 'Igor';
            $scope.person2 = 'Misko';
            $scope.personCount = 1;
          }
        </script>
        <div ng-controller="Ctrl">
          Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
          Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
          Number of People:<input type="text" ng-model="personCount" value="1" /><br/>

          <!--- Example with simple pluralization rules for en locale --->
          Without Offset:
          <ng-pluralize count="personCount"
                        when="{'0': 'Nobody is viewing.',
                               'one': '1 person is viewing.',
                               'other': '{} people are viewing.'}">
          </ng-pluralize><br>

          <!--- Example with offset --->
          With Offset(2):
          <ng-pluralize count="personCount" offset=2
                        when="{'0': 'Nobody is viewing.',
                               '1': '{{person1}} is viewing.',
                               '2': '{{person1}} and {{person2}} are viewing.',
                               'one': '{{person1}}, {{person2}} and one other person are viewing.',
                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
          </ng-pluralize>
        </div>
      </doc:source>
      <doc:scenario>
        it('should show correct pluralized string', function() {
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                             toBe('1 person is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                                toBe('Igor is viewing.');

          using('.doc-example-live').input('personCount').enter('0');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                               toBe('Nobody is viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                                              toBe('Nobody is viewing.');

          using('.doc-example-live').input('personCount').enter('2');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('2 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor and Misko are viewing.');

          using('.doc-example-live').input('personCount').enter('3');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('3 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and one other person are viewing.');

          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:first').text()).
                                            toBe('4 people are viewing.');
          expect(element('.doc-example-live ng-pluralize:last').text()).
                              toBe('Igor, Misko and 2 other people are viewing.');
        });

        it('should show data-binded names', function() {
          using('.doc-example-live').input('personCount').enter('4');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Igor, Misko and 2 other people are viewing.');

          using('.doc-example-live').input('person1').enter('Di');
          using('.doc-example-live').input('person2').enter('Vojta');
          expect(element('.doc-example-live ng-pluralize:last').text()).
              toBe('Di, Vojta and 2 other people are viewing.');
        });
      </doc:scenario>
    </doc:example>
 */
var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {
  var BRACE = /{}/g;
  return {
    restrict: 'EA',
    link: function(scope, element, attr) {
      var numberExp = attr.count,
          whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp) || {},
          whensExpFns = {},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol(),
          isWhen = /^when(Minus)?(.+)$/;

      forEach(attr, function(expression, attributeName) {
        if (isWhen.test(attributeName)) {
          whens[lowercase(attributeName.replace('when', '').replace('Minus', '-'))] =
            element.attr(attr.$attr[attributeName]);
        }
      });
      forEach(whens, function(expression, key) {
        whensExpFns[key] =
          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +
            offset + endSymbol));
      });

      scope.$watch(function ngPluralizeWatch() {
        var value = parseFloat(scope.$eval(numberExp));

        if (!isNaN(value)) {
          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
          //check it against pluralization rules in $locale service
          if (!(value in whens)) value = $locale.pluralCat(value - offset);
           return whensExpFns[value](scope, element, true);
        } else {
          return '';
        }
      }, function ngPluralizeWatchAction(newVal) {
        element.text(newVal);
      });
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngRepeat
 *
 * @description
 * The `ngRepeat` directive instantiates a template once per item from a collection. Each template
 * instance gets its own scope, where the given loop variable is set to the current collection item,
 * and `$index` is set to the item index or key.
 *
 * Special properties are exposed on the local scope of each template instance, including:
 *
 * | Variable  | Type            | Details                                                                     |
 * |-----------|-----------------|-----------------------------------------------------------------------------|
 * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |
 * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |
 * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |
 * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |
 * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |
 * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |
 *
 *
 * # Special repeat start and end points
 * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending
 * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.
 * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)
 * up to and including the ending HTML tag where **ng-repeat-end** is placed.
 *
 * The example below makes use of this feature:
 * <pre>
 *   <header ng-repeat-start="item in items">
 *     Header {{ item }}
 *   </header>
 *   <div class="body">
 *     Body {{ item }}
 *   </div>
 *   <footer ng-repeat-end>
 *     Footer {{ item }}
 *   </footer>
 * </pre>
 *
 * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:
 * <pre>
 *   <header>
 *     Header A
 *   </header>
 *   <div class="body">
 *     Body A
 *   </div>
 *   <footer>
 *     Footer A
 *   </footer>
 *   <header>
 *     Header B
 *   </header>
 *   <div class="body">
 *     Body B
 *   </div>
 *   <footer>
 *     Footer B
 *   </footer>
 * </pre>
 *
 * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such
 * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).
 *
 * @animations
 * enter - when a new item is added to the list or when an item is revealed after a filter
 * leave - when an item is removed from the list or when an item is filtered out
 * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
 *
 * @element ANY
 * @scope
 * @priority 1000
 * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
 *   formats are currently supported:
 *
 *   * `variable in expression` – where variable is the user defined loop variable and `expression`
 *     is a scope expression giving the collection to enumerate.
 *
 *     For example: `album in artist.albums`.
 *
 *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,
 *     and `expression` is the scope expression giving the collection to enumerate.
 *
 *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
 *
 *   * `variable in expression track by tracking_expression` – You can also provide an optional tracking function
 *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function
 *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
 *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are
 *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,
 *     before specifying a tracking expression.
 *
 *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements
 *     will be associated by item identity in the array.
 *
 *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique
 *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements
 *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
 *     element in the same way in the DOM.
 *
 *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this
 *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`
 *     property is same.
 *
 *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter
 *     to items in conjunction with a tracking expression.
 *
 * @example
 * This example initializes the scope to a list of names and
 * then uses `ngRepeat` to display every person:
  <example animations="true">
    <file name="index.html">
      <div ng-init="friends = [
        {name:'John', age:25, gender:'boy'},
        {name:'Jessie', age:30, gender:'girl'},
        {name:'Johanna', age:28, gender:'girl'},
        {name:'Joy', age:15, gender:'girl'},
        {name:'Mary', age:28, gender:'girl'},
        {name:'Peter', age:95, gender:'boy'},
        {name:'Sebastian', age:50, gender:'boy'},
        {name:'Erika', age:27, gender:'girl'},
        {name:'Patrick', age:40, gender:'boy'},
        {name:'Samantha', age:60, gender:'girl'}
      ]">
        I have {{friends.length}} friends. They are:
        <input type="search" ng-model="q" placeholder="filter friends..." />
        <ul class="example-animate-container">
          <li class="animate-repeat" ng-repeat="friend in friends | filter:q">
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
          </li>
        </ul>
      </div>
    </file>
    <file name="animations.css">
      .example-animate-container {
        background:white;
        border:1px solid black;
        list-style:none;
        margin:0;
        padding:0 10px;
      }

      .animate-repeat {
        line-height:40px;
        list-style:none;
        box-sizing:border-box;
      }

      .animate-repeat.ng-move,
      .animate-repeat.ng-enter,
      .animate-repeat.ng-leave {
        -webkit-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .animate-repeat.ng-leave.ng-leave-active,
      .animate-repeat.ng-move,
      .animate-repeat.ng-enter {
        opacity:0;
        max-height:0;
      }

      .animate-repeat.ng-leave,
      .animate-repeat.ng-move.ng-move-active,
      .animate-repeat.ng-enter.ng-enter-active {
        opacity:1;
        max-height:40px;
      }
    </file>
    <file name="scenario.js">
       it('should render initial data set', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);
         expect(r.row(0)).toEqual(["1","John","25"]);
         expect(r.row(1)).toEqual(["2","Jessie","30"]);
         expect(r.row(9)).toEqual(["10","Samantha","60"]);
         expect(binding('friends.length')).toBe("10");
       });

       it('should update repeater when filter predicate changes', function() {
         var r = using('.doc-example-live').repeater('ul li');
         expect(r.count()).toBe(10);

         input('q').enter('ma');

         expect(r.count()).toBe(2);
         expect(r.row(0)).toEqual(["1","Mary","28"]);
         expect(r.row(1)).toEqual(["2","Samantha","60"]);
       });
      </file>
    </example>
 */
var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
  var NG_REMOVED = '$$NG_REMOVED';
  var ngRepeatMinErr = minErr('ngRepeat');
  return {
    transclude: 'element',
    priority: 1000,
    terminal: true,
    $$tlb: true,
    link: function($scope, $element, $attr, ctrl, $transclude){
        var expression = $attr.ngRepeat;
        var match = expression.match(/^\s*(.+)\s+in\s+([\r\n\s\S]*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
          trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn,
          lhs, rhs, valueIdentifier, keyIdentifier,
          hashFnLocals = {$id: hashKey};

        if (!match) {
          throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression);
        }

        lhs = match[1];
        rhs = match[2];
        trackByExp = match[4];

        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
          trackByIdExpFn = function(key, value, index) {
            // assign key, value, and $index to the locals so that they can be used in hash functions
            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          };
          trackByIdObjFn = function(key) {
            return key;
          };
        }

        match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
        if (!match) {
          throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
                                                                    lhs);
        }
        valueIdentifier = match[3] || match[1];
        keyIdentifier = match[2];

        // Store a list of elements from previous run. This is a hash where key is the item from the
        // iterator, and the value is objects with following properties.
        //   - scope: bound scope
        //   - element: previous element.
        //   - index: position
        var lastBlockMap = {};

        //watch props
        $scope.$watchCollection(rhs, function ngRepeatAction(collection){
          var index, length,
              previousNode = $element[0],     // current position of the node
              nextNode,
              // Same as lastBlockMap but it has the current state. It will become the
              // lastBlockMap on the next iteration.
              nextBlockMap = {},
              arrayLength,
              childScope,
              key, value, // key/value of iteration
              trackById,
              trackByIdFn,
              collectionKeys,
              block,       // last object information {scope, element, id}
              nextBlockOrder = [],
              elementsToRemove;


          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (key in collection) {
              if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                collectionKeys.push(key);
              }
            }
            collectionKeys.sort();
          }

          arrayLength = collectionKeys.length;

          // locate existing items
          length = nextBlockOrder.length = collectionKeys.length;
          for(index = 0; index < length; index++) {
           key = (collection === collectionKeys) ? index : collectionKeys[index];
           value = collection[key];
           trackById = trackByIdFn(key, value, index);
           assertNotHasOwnProperty(trackById, '`track by` id');
           if(lastBlockMap.hasOwnProperty(trackById)) {
             block = lastBlockMap[trackById];
             delete lastBlockMap[trackById];
             nextBlockMap[trackById] = block;
             nextBlockOrder[index] = block;
           } else if (nextBlockMap.hasOwnProperty(trackById)) {
             // restore lastBlockMap
             forEach(nextBlockOrder, function(block) {
               if (block && block.scope) lastBlockMap[block.id] = block;
             });
             // This is a duplicate and we need to throw an error
             throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}",
                                                                                                                                                    expression,       trackById);
           } else {
             // new never before seen block
             nextBlockOrder[index] = { id: trackById };
             nextBlockMap[trackById] = false;
           }
         }

          // remove existing items
          for (key in lastBlockMap) {
            // lastBlockMap is our own object so we don't need to use special hasOwnPropertyFn
            if (lastBlockMap.hasOwnProperty(key)) {
              block = lastBlockMap[key];
              elementsToRemove = getBlockElements(block.clone);
              $animate.leave(elementsToRemove);
              forEach(elementsToRemove, function(element) { element[NG_REMOVED] = true; });
              block.scope.$destroy();
            }
          }

          // we are not using forEach for perf reasons (trying to avoid #call)
          for (index = 0, length = collectionKeys.length; index < length; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];
            if (nextBlockOrder[index - 1]) previousNode = getBlockEnd(nextBlockOrder[index - 1]);

            if (block.scope) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element
              childScope = block.scope;

              nextNode = previousNode;
              do {
                nextNode = nextNode.nextSibling;
              } while(nextNode && nextNode[NG_REMOVED]);

              if (getBlockStart(block) != nextNode) {
                // existing item which got moved
                $animate.move(getBlockElements(block.clone), null, jqLite(previousNode));
              }
              previousNode = getBlockEnd(block);
            } else {
              // new item which we don't know about
              childScope = $scope.$new();
            }

            childScope[valueIdentifier] = value;
            if (keyIdentifier) childScope[keyIdentifier] = key;
            childScope.$index = index;
            childScope.$first = (index === 0);
            childScope.$last = (index === (arrayLength - 1));
            childScope.$middle = !(childScope.$first || childScope.$last);
            // jshint bitwise: false
            childScope.$odd = !(childScope.$even = (index&1) === 0);
            // jshint bitwise: true

            if (!block.scope) {
              $transclude(childScope, function(clone) {
                clone[clone.length++] = document.createComment(' end ngRepeat: ' + expression + ' ');
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = clone;
                block.scope = childScope;
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the jqlite wrapper as it might be changed later
                // by a directive with templateUrl when it's template arrives.
                block.clone = clone;
                nextBlockMap[block.id] = block;
              });
            }
          }
          lastBlockMap = nextBlockMap;
        });
    }
  };

  function getBlockStart(block) {
    return block.clone[0];
  }

  function getBlockEnd(block) {
    return block.clone[block.clone.length - 1];
  }
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngShow
 *
 * @description
 * The `ngShow` directive shows or hides the given HTML element based on the expression
 * provided to the ngShow attribute. The element is shown or hidden by removing or adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
 * in AngularJS and sets the display style to none (using an !important flag).
 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
 *
 * <pre>
 * <!-- when $scope.myValue is truthy (element is visible) -->
 * <div ng-show="myValue"></div>
 *
 * <!-- when $scope.myValue is falsy (element is hidden) -->
 * <div ng-show="myValue" class="ng-hide"></div>
 * </pre>
 *
 * When the ngShow expression evaluates to false then the ng-hide CSS class is added to the class attribute
 * on the element causing it to become hidden. When true, the ng-hide CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
 *
 * ### Overriding .ng-hide
 *
 * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
 * restating the styles for the .ng-hide class in CSS:
 * <pre>
 * .ng-hide {
 *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
 *   display:block!important;
 *
 *   //this is just another form of hiding an element
 *   position:absolute;
 *   top:-9999px;
 *   left:-9999px;
 * }
 * </pre>
 *
 * Just remember to include the important flag so the CSS override will function.
 *
 * ## A note about animations with ngShow
 *
 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
 * is true and false. This system works like the animation system present with ngClass except that
 * you must also include the !important flag to override the display property
 * so that you can perform an animation when the element is hidden during the time of the animation.
 *
 * <pre>
 * //
 * //a working example can be found at the bottom of this page
 * //
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
 *   transition:0.5s linear all;
 *   display:block!important;
 * }
 *
 * .my-element.ng-hide-add { ... }
 * .my-element.ng-hide-add.ng-hide-add-active { ... }
 * .my-element.ng-hide-remove { ... }
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
 * </pre>
 *
 * @animations
 * addClass: .ng-hide - happens after the ngShow expression evaluates to a truthy value and the just before contents are set to visible
 * removeClass: .ng-hide - happens after the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden
 *
 * @element ANY
 * @param {expression} ngShow If the {@link guide/expression expression} is truthy
 *     then the element is shown or hidden respectively.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked"><br/>
      <div>
        Show:
        <div class="check-element animate-show" ng-show="checked">
          <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
        </div>
      </div>
      <div>
        Hide:
        <div class="check-element animate-show" ng-hide="checked">
          <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
        </div>
      </div>
    </file>
    <file name="animations.css">
      .animate-show {
        -webkit-transition:all linear 0.5s;
        transition:all linear 0.5s;
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .animate-show.ng-hide-add,
      .animate-show.ng-hide-remove {
        display:block!important;
      }

      .animate-show.ng-hide {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    </file>
    <file name="scenario.js">
       it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);
       });
    </file>
  </example>
 */
var ngShowDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngShow, function ngShowWatchAction(value){
      $animate[toBoolean(value) ? 'removeClass' : 'addClass'](element, 'ng-hide');
    });
  };
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngHide
 *
 * @description
 * The `ngHide` directive shows or hides the given HTML element based on the expression
 * provided to the ngHide attribute. The element is shown or hidden by removing or adding
 * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is predefined
 * in AngularJS and sets the display style to none (using an !important flag).
 * For CSP mode please add `angular-csp.css` to your html file (see {@link ng.directive:ngCsp ngCsp}).
 *
 * <pre>
 * <!-- when $scope.myValue is truthy (element is hidden) -->
 * <div ng-hide="myValue"></div>
 *
 * <!-- when $scope.myValue is falsy (element is visible) -->
 * <div ng-hide="myValue" class="ng-hide"></div>
 * </pre>
 *
 * When the ngHide expression evaluates to true then the .ng-hide CSS class is added to the class attribute
 * on the element causing it to become hidden. When false, the ng-hide CSS class is removed
 * from the element causing the element not to appear hidden.
 *
 * ## Why is !important used?
 *
 * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector
 * can be easily overridden by heavier selectors. For example, something as simple
 * as changing the display style on a HTML list item would make hidden elements appear visible.
 * This also becomes a bigger issue when dealing with CSS frameworks.
 *
 * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector
 * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the
 * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.
 *
 * ### Overriding .ng-hide
 *
 * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by
 * restating the styles for the .ng-hide class in CSS:
 * <pre>
 * .ng-hide {
 *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...
 *   display:block!important;
 *
 *   //this is just another form of hiding an element
 *   position:absolute;
 *   top:-9999px;
 *   left:-9999px;
 * }
 * </pre>
 *
 * Just remember to include the important flag so the CSS override will function.
 *
 * ## A note about animations with ngHide
 *
 * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression
 * is true and false. This system works like the animation system present with ngClass, except that
 * you must also include the !important flag to override the display property so
 * that you can perform an animation when the element is hidden during the time of the animation.
 *
 * <pre>
 * //
 * //a working example can be found at the bottom of this page
 * //
 * .my-element.ng-hide-add, .my-element.ng-hide-remove {
 *   transition:0.5s linear all;
 *   display:block!important;
 * }
 *
 * .my-element.ng-hide-add { ... }
 * .my-element.ng-hide-add.ng-hide-add-active { ... }
 * .my-element.ng-hide-remove { ... }
 * .my-element.ng-hide-remove.ng-hide-remove-active { ... }
 * </pre>
 *
 * @animations
 * removeClass: .ng-hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden
 * addClass: .ng-hide - happens after the ngHide expression evaluates to a non truthy value and just before the contents are set to visible
 *
 * @element ANY
 * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
 *     the element is shown or hidden respectively.
 *
 * @example
  <example animations="true">
    <file name="index.html">
      Click me: <input type="checkbox" ng-model="checked"><br/>
      <div>
        Show:
        <div class="check-element animate-hide" ng-show="checked">
          <span class="icon-thumbs-up"></span> I show up when your checkbox is checked.
        </div>
      </div>
      <div>
        Hide:
        <div class="check-element animate-hide" ng-hide="checked">
          <span class="icon-thumbs-down"></span> I hide when your checkbox is checked.
        </div>
      </div>
    </file>
    <file name="animations.css">
      .animate-hide {
        -webkit-transition:all linear 0.5s;
        transition:all linear 0.5s;
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .animate-hide.ng-hide-add,
      .animate-hide.ng-hide-remove {
        display:block!important;
      }

      .animate-hide.ng-hide {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    </file>
    <file name="scenario.js">
       it('should check ng-show / ng-hide', function() {
         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);

         input('checked').check();

         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);
         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);
       });
    </file>
  </example>
 */
var ngHideDirective = ['$animate', function($animate) {
  return function(scope, element, attr) {
    scope.$watch(attr.ngHide, function ngHideWatchAction(value){
      $animate[toBoolean(value) ? 'addClass' : 'removeClass'](element, 'ng-hide');
    });
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngStyle
 * @restrict AC
 *
 * @description
 * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.
 *
 * @element ANY
 * @param {expression} ngStyle {@link guide/expression Expression} which evals to an
 *      object whose keys are CSS style names and values are corresponding values for those CSS
 *      keys.
 *
 * @example
   <example>
     <file name="index.html">
        <input type="button" value="set" ng-click="myStyle={color:'red'}">
        <input type="button" value="clear" ng-click="myStyle={}">
        <br/>
        <span ng-style="myStyle">Sample Text</span>
        <pre>myStyle={{myStyle}}</pre>
     </file>
     <file name="style.css">
       span {
         color: black;
       }
     </file>
     <file name="scenario.js">
       it('should check ng-style', function() {
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
         element('.doc-example-live :button[value=set]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');
         element('.doc-example-live :button[value=clear]').click();
         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
       });
     </file>
   </example>
 */
var ngStyleDirective = ngDirective(function(scope, element, attr) {
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
    if (oldStyles && (newStyles !== oldStyles)) {
      forEach(oldStyles, function(val, style) { element.css(style, '');});
    }
    if (newStyles) element.css(newStyles);
  }, true);
});

/**
 * @ngdoc directive
 * @name ng.directive:ngSwitch
 * @restrict EA
 *
 * @description
 * The `ngSwitch` directive is used to conditionally swap DOM structure on your template based on a scope expression.
 * Elements within `ngSwitch` but without `ngSwitchWhen` or `ngSwitchDefault` directives will be preserved at the location
 * as specified in the template.
 *
 * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
 * from the template cache), `ngSwitch` simply choses one of the nested elements and makes it visible based on which element
 * matches the value obtained from the evaluated expression. In other words, you define a container element
 * (where you place the directive), place an expression on the **`on="..."` attribute**
 * (or the **`ng-switch="..."` attribute**), define any inner elements inside of the directive and place
 * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
 * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
 * attribute is displayed.
 *
 * <div class="alert alert-info">
 * Be aware that the attribute values to match against cannot be expressions. They are interpreted
 * as literal string values to match against.
 * For example, **`ng-switch-when="someVal"`** will match against the string `"someVal"` not against the
 * value of the expression `$scope.someVal`.
 * </div>

 * @animations
 * enter - happens after the ngSwitch contents change and the matched child element is placed inside the container
 * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
 *
 * @usage
 * <ANY ng-switch="expression">
 *   <ANY ng-switch-when="matchValue1">...</ANY>
 *   <ANY ng-switch-when="matchValue2">...</ANY>
 *   <ANY ng-switch-default>...</ANY>
 * </ANY>
 *
 *
 * @scope
 * @priority 800
 * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.
 * @paramDescription
 * On child elements add:
 *
 * * `ngSwitchWhen`: the case statement to match against. If match then this
 *   case will be displayed. If the same match appears multiple times, all the
 *   elements will be displayed.
 * * `ngSwitchDefault`: the default case when no other case match. If there
 *   are multiple default cases, all of them will be displayed when no other
 *   case match.
 *
 *
 * @example
  <example animations="true">
    <file name="index.html">
      <div ng-controller="Ctrl">
        <select ng-model="selection" ng-options="item for item in items">
        </select>
        <tt>selection={{selection}}</tt>
        <hr/>
        <div class="animate-switch-container"
          ng-switch on="selection">
            <div class="animate-switch" ng-switch-when="settings">Settings Div</div>
            <div class="animate-switch" ng-switch-when="home">Home Span</div>
            <div class="animate-switch" ng-switch-default>default</div>
        </div>
      </div>
    </file>
    <file name="script.js">
      function Ctrl($scope) {
        $scope.items = ['settings', 'home', 'other'];
        $scope.selection = $scope.items[0];
      }
    </file>
    <file name="animations.css">
      .animate-switch-container {
        position:relative;
        background:white;
        border:1px solid black;
        height:40px;
        overflow:hidden;
      }

      .animate-switch {
        padding:10px;
      }

      .animate-switch.ng-animate {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

      .animate-switch.ng-leave.ng-leave-active,
      .animate-switch.ng-enter {
        top:-50px;
      }
      .animate-switch.ng-leave,
      .animate-switch.ng-enter.ng-enter-active {
        top:0;
      }
    </file>
    <file name="scenario.js">
      it('should start in settings', function() {
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);
      });
      it('should change to home', function() {
        select('selection').option('home');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);
      });
      it('should select default', function() {
        select('selection').option('other');
        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);
      });
    </file>
  </example>
 */
var ngSwitchDirective = ['$animate', function($animate) {
  return {
    restrict: 'EA',
    require: 'ngSwitch',

    // asks for $scope to fool the BC controller module
    controller: ['$scope', function ngSwitchController() {
     this.cases = {};
    }],
    link: function(scope, element, attr, ngSwitchController) {
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes,
          selectedElements,
          selectedScopes = [];

      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
        for (var i= 0, ii=selectedScopes.length; i<ii; i++) {
          selectedScopes[i].$destroy();
          $animate.leave(selectedElements[i]);
        }

        selectedElements = [];
        selectedScopes = [];

        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
          scope.$eval(attr.change);
          forEach(selectedTranscludes, function(selectedTransclude) {
            var selectedScope = scope.$new();
            selectedScopes.push(selectedScope);
            selectedTransclude.transclude(selectedScope, function(caseElement) {
              var anchor = selectedTransclude.element;

              selectedElements.push(caseElement);
              $animate.enter(caseElement, anchor.parent(), anchor);
            });
          });
        }
      });
    }
  };
}];

var ngSwitchWhenDirective = ngDirective({
  transclude: 'element',
  priority: 800,
  require: '^ngSwitch',
  compile: function(element, attrs) {
    return function(scope, element, attr, ctrl, $transclude) {
      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
      ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: $transclude, element: element });
    };
  }
});

var ngSwitchDefaultDirective = ngDirective({
  transclude: 'element',
  priority: 800,
  require: '^ngSwitch',
  link: function(scope, element, attr, ctrl, $transclude) {
    ctrl.cases['?'] = (ctrl.cases['?'] || []);
    ctrl.cases['?'].push({ transclude: $transclude, element: element });
   }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngTransclude
 * @restrict AC
 *
 * @description
 * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
 *
 * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.
 *
 * @element ANY
 *
 * @example
   <doc:example module="transclude">
     <doc:source>
       <script>
         function Ctrl($scope) {
           $scope.title = 'Lorem Ipsum';
           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
         }

         angular.module('transclude', [])
          .directive('pane', function(){
             return {
               restrict: 'E',
               transclude: true,
               scope: { title:'@' },
               template: '<div style="border: 1px solid black;">' +
                           '<div style="background-color: gray">{{title}}</div>' +
                           '<div ng-transclude></div>' +
                         '</div>'
             };
         });
       </script>
       <div ng-controller="Ctrl">
         <input ng-model="title"><br>
         <textarea ng-model="text"></textarea> <br/>
         <pane title="{{title}}">{{text}}</pane>
       </div>
     </doc:source>
     <doc:scenario>
        it('should have transcluded', function() {
          input('title').enter('TITLE');
          input('text').enter('TEXT');
          expect(binding('title')).toEqual('TITLE');
          expect(binding('text')).toEqual('TEXT');
        });
     </doc:scenario>
   </doc:example>
 *
 */
var ngTranscludeDirective = ngDirective({
  controller: ['$element', '$transclude', function($element, $transclude) {
    if (!$transclude) {
      throw minErr('ngTransclude')('orphan',
          'Illegal use of ngTransclude directive in the template! ' +
          'No parent directive that requires a transclusion found. ' +
          'Element: {0}',
          startingTag($element));
    }

    // remember the transclusion fn but call it during linking so that we don't process transclusion before directives on
    // the parent element even when the transclusion replaces the current element. (we can't use priority here because
    // that applies only to compile fns and not controllers
    this.$transclude = $transclude;
  }],

  link: function($scope, $element, $attrs, controller) {
    controller.$transclude(function(clone) {
      $element.empty();
      $element.append(clone);
    });
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:script
 * @restrict E
 *
 * @description
 * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the
 * template can be used by `ngInclude`, `ngView` or directive templates.
 *
 * @param {'text/ng-template'} type must be set to `'text/ng-template'`
 *
 * @example
  <doc:example>
    <doc:source>
      <script type="text/ng-template" id="/tpl.html">
        Content of the template.
      </script>

      <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
      <div id="tpl-content" ng-include src="currentTpl"></div>
    </doc:source>
    <doc:scenario>
      it('should load template defined inside script tag', function() {
        element('#tpl-link').click();
        expect(element('#tpl-content').text()).toMatch(/Content of the template/);
      });
    </doc:scenario>
  </doc:example>
 */
var scriptDirective = ['$templateCache', function($templateCache) {
  return {
    restrict: 'E',
    terminal: true,
    compile: function(element, attr) {
      if (attr.type == 'text/ng-template') {
        var templateUrl = attr.id,
            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      }
    }
  };
}];

var ngOptionsMinErr = minErr('ngOptions');
/**
 * @ngdoc directive
 * @name ng.directive:select
 * @restrict E
 *
 * @description
 * HTML `SELECT` element with angular data-binding.
 *
 * # `ngOptions`
 *
 * The `ngOptions` attribute can be used to dynamically generate a list of `<option>`
 * elements for the `<select>` element using the array or object obtained by evaluating the
 * `ngOptions` comprehension_expression.
 *
 * When an item in the `<select>` menu is selected, the array element or object property
 * represented by the selected option will be bound to the model identified by the `ngModel`
 * directive.
 *
 * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
 * be nested into the `<select>` element. This element will then represent the `null` or "not selected"
 * option. See example below for demonstration.
 *
 * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead
 * of {@link ng.directive:ngRepeat ngRepeat} when you want the
 * `select` model to be bound to a non-string value. This is because an option element can only
 * be bound to string values at present.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required The control is considered valid only if value is entered.
 * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of
 *    `required` when you want to data-bind to the `required` attribute.
 * @param {comprehension_expression=} ngOptions in one of the following forms:
 *
 *   * for array data sources:
 *     * `label` **`for`** `value` **`in`** `array`
 *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
 *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
 *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`
 *   * for object data sources:
 *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
 *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
 *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
 *     * `select` **`as`** `label` **`group by`** `group`
 *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
 *
 * Where:
 *
 *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
 *   * `value`: local variable which will refer to each item in the `array` or each property value
 *      of `object` during iteration.
 *   * `key`: local variable which will refer to a property name in `object` during iteration.
 *   * `label`: The result of this expression will be the label for `<option>` element. The
 *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
 *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
 *      element. If not specified, `select` expression will default to `value`.
 *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
 *      DOM element.
 *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be
 *      used to identify the objects in the array. The `trackexpr` will most likely refer to the
 *     `value` variable (e.g. `value.propertyName`).
 *
 * @example
    <doc:example>
      <doc:source>
        <script>
        function MyCntrl($scope) {
          $scope.colors = [
            {name:'black', shade:'dark'},
            {name:'white', shade:'light'},
            {name:'red', shade:'dark'},
            {name:'blue', shade:'dark'},
            {name:'yellow', shade:'light'}
          ];
          $scope.color = $scope.colors[2]; // red
        }
        </script>
        <div ng-controller="MyCntrl">
          <ul>
            <li ng-repeat="color in colors">
              Name: <input ng-model="color.name">
              [<a href ng-click="colors.splice($index, 1)">X</a>]
            </li>
            <li>
              [<a href ng-click="colors.push({})">add</a>]
            </li>
          </ul>
          <hr/>
          Color (null not allowed):
          <select ng-model="color" ng-options="c.name for c in colors"></select><br>

          Color (null allowed):
          <span  class="nullable">
            <select ng-model="color" ng-options="c.name for c in colors">
              <option value="">-- choose color --</option>
            </select>
          </span><br/>

          Color grouped by shade:
          <select ng-model="color" ng-options="c.name group by c.shade for c in colors">
          </select><br/>


          Select <a href ng-click="color={name:'not in list'}">bogus</a>.<br>
          <hr/>
          Currently selected: {{ {selected_color:color}  }}
          <div style="border:solid 1px black; height:20px"
               ng-style="{'background-color':color.name}">
          </div>
        </div>
      </doc:source>
      <doc:scenario>
         it('should check ng-options', function() {
           expect(binding('{selected_color:color}')).toMatch('red');
           select('color').option('0');
           expect(binding('{selected_color:color}')).toMatch('black');
           using('.nullable').select('color').option('');
           expect(binding('{selected_color:color}')).toMatch('null');
         });
      </doc:scenario>
    </doc:example>
 */

var ngOptionsDirective = valueFn({ terminal: true });
// jshint maxlen: false
var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444000000000555555555555555000000066666666666666600000000000000007777000000000000000000088888
  var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
      nullModelCtrl = {$setViewValue: noop};
// jshint maxlen: 100

  return {
    restrict: 'E',
    require: ['select', '?ngModel'],
    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
      var self = this,
          optionsMap = {},
          ngModelCtrl = nullModelCtrl,
          nullOption,
          unknownOption;


      self.databound = $attrs.ngModel;


      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
        ngModelCtrl = ngModelCtrl_;
        nullOption = nullOption_;
        unknownOption = unknownOption_;
      };


      self.addOption = function(value) {
        assertNotHasOwnProperty(value, '"option value"');
        optionsMap[value] = true;

        if (ngModelCtrl.$viewValue == value) {
          $element.val(value);
          if (unknownOption.parent()) unknownOption.remove();
        }
      };


      self.removeOption = function(value) {
        if (this.hasOption(value)) {
          delete optionsMap[value];
          if (ngModelCtrl.$viewValue == value) {
            this.renderUnknownOption(value);
          }
        }
      };


      self.renderUnknownOption = function(val) {
        var unknownVal = '? ' + hashKey(val) + ' ?';
        unknownOption.val(unknownVal);
        $element.prepend(unknownOption);
        $element.val(unknownVal);
        unknownOption.prop('selected', true); // needed for IE
      };


      self.hasOption = function(value) {
        return optionsMap.hasOwnProperty(value);
      };

      $scope.$on('$destroy', function() {
        // disable unknown option so that we don't do work when the whole select is being destroyed
        self.renderUnknownOption = noop;
      });
    }],

    link: function(scope, element, attr, ctrls) {
      // if ngModel is not defined, we don't need to do anything
      if (!ctrls[1]) return;

      var selectCtrl = ctrls[0],
          ngModelCtrl = ctrls[1],
          multiple = attr.multiple,
          optionsExp = attr.ngOptions,
          nullOption = false, // if false, user will not be able to select it (used by ngOptions)
          emptyOption,
          // we can't just jqLite('<option>') since jqLite is not smart enough
          // to create it in <select> and IE barfs otherwise.
          optionTemplate = jqLite(document.createElement('option')),
          optGroupTemplate =jqLite(document.createElement('optgroup')),
          unknownOption = optionTemplate.clone();

      // find "null" option
      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
        if (children[i].value === '') {
          emptyOption = nullOption = children.eq(i);
          break;
        }
      }

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      // required validator
      if (multiple) {
        ngModelCtrl.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      }

      if (optionsExp) setupAsOptions(scope, element, ngModelCtrl);
      else if (multiple) setupAsMultiple(scope, element, ngModelCtrl);
      else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);


      ////////////////////////////



      function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
        ngModelCtrl.$render = function() {
          var viewValue = ngModelCtrl.$viewValue;

          if (selectCtrl.hasOption(viewValue)) {
            if (unknownOption.parent()) unknownOption.remove();
            selectElement.val(viewValue);
            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy
          } else {
            if (isUndefined(viewValue) && emptyOption) {
              selectElement.val('');
            } else {
              selectCtrl.renderUnknownOption(viewValue);
            }
          }
        };

        selectElement.on('change', function() {
          scope.$apply(function() {
            if (unknownOption.parent()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          });
        });
      }

      function setupAsMultiple(scope, selectElement, ctrl) {
        var lastView;
        ctrl.$render = function() {
          var items = new HashMap(ctrl.$viewValue);
          forEach(selectElement.find('option'), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        scope.$watch(function selectMultipleWatch() {
          if (!equals(lastView, ctrl.$viewValue)) {
            lastView = copy(ctrl.$viewValue);
            ctrl.$render();
          }
        });

        selectElement.on('change', function() {
          scope.$apply(function() {
            var array = [];
            forEach(selectElement.find('option'), function(option) {
              if (option.selected) {
                array.push(option.value);
              }
            });
            ctrl.$setViewValue(array);
          });
        });
      }

      function setupAsOptions(scope, selectElement, ctrl) {
        var match;

        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw ngOptionsMinErr('iexp',
            "Expected expression in form of " +
            "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
            " but got '{0}'. Element: {1}",
            optionsExp, startingTag(selectElement));
        }

        var displayFn = $parse(match[2] || match[1]),
            valueName = match[4] || match[6],
            keyName = match[5],
            groupByFn = $parse(match[3] || ''),
            valueFn = $parse(match[2] ? match[1] : valueName),
            valuesFn = $parse(match[7]),
            track = match[8],
            trackFn = track ? $parse(match[8]) : null,
            // This is an array of array of existing option groups in DOM.
            // We try to reuse these if possible
            // - optionGroupsCache[0] is the options with no option group
            // - optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
            optionGroupsCache = [[{element: selectElement, label:''}]];

        if (nullOption) {
          // compile the element since there might be bindings in it
          $compile(nullOption)(scope);

          // remove the class, which is added automatically because we recompile the element and it
          // becomes the compilation root
          nullOption.removeClass('ng-scope');

          // we need to remove it before calling selectElement.empty() because otherwise IE will
          // remove the label from the element. wtf?
          nullOption.remove();
        }

        // clear contents, we'll add what's needed based on the model
        selectElement.empty();

        selectElement.on('change', function() {
          scope.$apply(function() {
            var optionGroup,
                collection = valuesFn(scope) || [],
                locals = {},
                key, value, optionElement, index, groupIndex, length, groupLength, trackIndex;

            if (multiple) {
              value = [];
              for (groupIndex = 0, groupLength = optionGroupsCache.length;
                   groupIndex < groupLength;
                   groupIndex++) {
                // list of options for that group. (first item has the parent)
                optionGroup = optionGroupsCache[groupIndex];

                for(index = 1, length = optionGroup.length; index < length; index++) {
                  if ((optionElement = optionGroup[index].element)[0].selected) {
                    key = optionElement.val();
                    if (keyName) locals[keyName] = key;
                    if (trackFn) {
                      for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                        locals[valueName] = collection[trackIndex];
                        if (trackFn(scope, locals) == key) break;
                      }
                    } else {
                      locals[valueName] = collection[key];
                    }
                    value.push(valueFn(scope, locals));
                  }
                }
              }
            } else {
              key = selectElement.val();
              if (key == '?') {
                value = undefined;
              } else if (key === ''){
                value = null;
              } else {
                if (trackFn) {
                  for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                    locals[valueName] = collection[trackIndex];
                    if (trackFn(scope, locals) == key) {
                      value = valueFn(scope, locals);
                      break;
                    }
                  }
                } else {
                  locals[valueName] = collection[key];
                  if (keyName) locals[keyName] = key;
                  value = valueFn(scope, locals);
                }
              }
            }
            ctrl.$setViewValue(value);
          });
        });

        ctrl.$render = render;

        // TODO(vojta): can't we optimize this ?
        scope.$watch(render);

        function render() {
              // Temporary location for the option groups before we render them
          var optionGroups = {'':[]},
              optionGroupNames = [''],
              optionGroupName,
              optionGroup,
              option,
              existingParent, existingOptions, existingOption,
              modelValue = ctrl.$modelValue,
              values = valuesFn(scope) || [],
              keys = keyName ? sortedKeys(values) : values,
              key,
              groupLength, length,
              groupIndex, index,
              locals = {},
              selected,
              selectedSet = false, // nothing is selected yet
              lastElement,
              element,
              label;

          if (multiple) {
            if (trackFn && isArray(modelValue)) {
              selectedSet = new HashMap([]);
              for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                locals[valueName] = modelValue[trackIndex];
                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
              }
            } else {
              selectedSet = new HashMap(modelValue);
            }
          }

          // We now build up the list of options we need (we merge later)
          for (index = 0; length = keys.length, index < length; index++) {
            
            key = index;
            if (keyName) {
              key = keys[index];
              if ( key.charAt(0) === '$' ) continue;
              locals[keyName] = key;
            }

            locals[valueName] = values[key];

            optionGroupName = groupByFn(scope, locals) || '';
            if (!(optionGroup = optionGroups[optionGroupName])) {
              optionGroup = optionGroups[optionGroupName] = [];
              optionGroupNames.push(optionGroupName);
            }
            if (multiple) {
              selected = isDefined(
                selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals))
              );
            } else {
              if (trackFn) {
                var modelCast = {};
                modelCast[valueName] = modelValue;
                selected = trackFn(scope, modelCast) === trackFn(scope, locals);
              } else {
                selected = modelValue === valueFn(scope, locals);
              }
              selectedSet = selectedSet || selected; // see if at least one item is selected
            }
            label = displayFn(scope, locals); // what will be seen by the user

            // doing displayFn(scope, locals) || '' overwrites zero values
            label = isDefined(label) ? label : '';
            optionGroup.push({
              // either the index into array or key from object
              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),
              label: label,
              selected: selected                   // determine if we should be selected
            });
          }
          if (!multiple) {
            if (nullOption || modelValue === null) {
              // insert null option if we have a placeholder, or the model is null
              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});
            } else if (!selectedSet) {
              // option could not be found, we have to insert the undefined item
              optionGroups[''].unshift({id:'?', label:'', selected:true});
            }
          }

          // Now we need to update the list of DOM nodes to match the optionGroups we computed above
          for (groupIndex = 0, groupLength = optionGroupNames.length;
               groupIndex < groupLength;
               groupIndex++) {
            // current option group name or '' if no group
            optionGroupName = optionGroupNames[groupIndex];

            // list of options for that group. (first item has the parent)
            optionGroup = optionGroups[optionGroupName];

            if (optionGroupsCache.length <= groupIndex) {
              // we need to grow the optionGroups
              existingParent = {
                element: optGroupTemplate.clone().attr('label', optionGroupName),
                label: optionGroup.label
              };
              existingOptions = [existingParent];
              optionGroupsCache.push(existingOptions);
              selectElement.append(existingParent.element);
            } else {
              existingOptions = optionGroupsCache[groupIndex];
              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

              // update the OPTGROUP label if not the same.
              if (existingParent.label != optionGroupName) {
                existingParent.element.attr('label', existingParent.label = optionGroupName);
              }
            }

            lastElement = null;  // start at the beginning
            for(index = 0, length = optionGroup.length; index < length; index++) {
              option = optionGroup[index];
              if ((existingOption = existingOptions[index+1])) {
                // reuse elements
                lastElement = existingOption.element;
                if (existingOption.label !== option.label) {
                  lastElement.text(existingOption.label = option.label);
                }
                if (existingOption.id !== option.id) {
                  lastElement.val(existingOption.id = option.id);
                }
                // lastElement.prop('selected') provided by jQuery has side-effects
                if (lastElement[0].selected !== option.selected) {
                  lastElement.prop('selected', (existingOption.selected = option.selected));
                }
              } else {
                // grow elements

                // if it's a null option
                if (option.id === '' && nullOption) {
                  // put back the pre-compiled element
                  element = nullOption;
                } else {
                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                  // in this version of jQuery on some browser the .text() returns a string
                  // rather then the element.
                  (element = optionTemplate.clone())
                      .val(option.id)
                      .attr('selected', option.selected)
                      .text(option.label);
                }

                existingOptions.push(existingOption = {
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                });
                if (lastElement) {
                  lastElement.after(element);
                } else {
                  existingParent.element.append(element);
                }
                lastElement = element;
              }
            }
            // remove any excessive OPTIONs in a group
            index++; // increment since the existingOptions[0] is parent element not OPTION
            while(existingOptions.length > index) {
              existingOptions.pop().element.remove();
            }
          }
          // remove any excessive OPTGROUPs from select
          while(optionGroupsCache.length > groupIndex) {
            optionGroupsCache.pop()[0].element.remove();
          }
        }
      }
    }
  };
}];

var optionDirective = ['$interpolate', function($interpolate) {
  var nullSelectCtrl = {
    addOption: noop,
    removeOption: noop
  };

  return {
    restrict: 'E',
    priority: 100,
    compile: function(element, attr) {
      if (isUndefined(attr.value)) {
        var interpolateFn = $interpolate(element.text(), true);
        if (!interpolateFn) {
          attr.$set('value', element.text());
        }
      }

      return function (scope, element, attr) {
        var selectCtrlName = '$selectController',
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); // in case we are in optgroup

        if (selectCtrl && selectCtrl.databound) {
          // For some reason Opera defaults to true and if not overridden this messes up the repeater.
          // We don't want the view to drive the initialization of the model anyway.
          element.prop('selected', false);
        } else {
          selectCtrl = nullSelectCtrl;
        }

        if (interpolateFn) {
          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
            attr.$set('value', newVal);
            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
            selectCtrl.addOption(newVal);
          });
        } else {
          selectCtrl.addOption(attr.value);
        }

        element.on('$destroy', function() {
          selectCtrl.removeOption(attr.value);
        });
      };
    }
  };
}];

var styleDirective = valueFn({
  restrict: 'E',
  terminal: true
});

  //try to bind to jquery now so that one can write angular.element().read()
  //but we will rebind on bootstrap again.
  bindJQuery();

  publishExternalAPI(angular);

  jqLite(document).ready(function() {
    angularInit(document, bootstrap);
  });

})(window, document);

!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}</style>');
; browserify_shim__define__module__export__(typeof angular != "undefined" ? angular : window.angular);

}).call(global, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

},{}],"liquidmetal":[function(require,module,exports){
module.exports=require('16GGEZ');
},{}],"16GGEZ":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, exports, define, browserify_shim__define__module__export__) {
/**
 * LiquidMetal, version: 1.2.1 (2012-04-21)
 *
 * A mimetic poly-alloy of Quicksilver's scoring algorithm, essentially
 * LiquidMetal.
 *
 * For usage and examples, visit:
 * http://github.com/rmm5t/liquidmetal
 *
 * Licensed under the MIT:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Copyright (c) 2009-2012, Ryan McGeary (ryan -[at]- mcgeary [*dot*] org)
 */
var LiquidMetal = (function() {
  var SCORE_NO_MATCH = 0.0;
  var SCORE_MATCH = 1.0;
  var SCORE_TRAILING = 0.8;
  var SCORE_TRAILING_BUT_STARTED = 0.9;
  var SCORE_BUFFER = 0.85;
  var WORD_SEPARATORS = " \t_-";

  return {
    lastScore: null,
    lastScoreArray: null,

    score: function(string, abbrev) {
      // short circuits
      if (abbrev.length === 0) return SCORE_TRAILING;
      if (abbrev.length > string.length) return SCORE_NO_MATCH;

      // match & score all
      var allScores = [];
      var search = string.toLowerCase();
      abbrev = abbrev.toLowerCase();
      this._scoreAll(string, search, abbrev, -1, 0, [], allScores);

      // complete miss
      if (allScores.length == 0) return 0;

      // sum per-character scores into overall scores,
      // selecting the maximum score
      var maxScore = 0.0, maxArray = [];
      for (var i = 0; i < allScores.length; i++) {
        var scores = allScores[i];
        var scoreSum = 0.0;
        for (var j = 0; j < string.length; j++) { scoreSum += scores[j]; }
        if (scoreSum > maxScore) {
          maxScore = scoreSum;
          maxArray = scores;
        }
      }

      // normalize max score by string length
      // s. t. the perfect match score = 1
      maxScore /= string.length;

      // record maximum score & score array, return
      this.lastScore = maxScore;
      this.lastScoreArray = maxArray;
      return maxScore;
    },

    _scoreAll: function(string, search, abbrev, searchIndex, abbrIndex, scores, allScores) {
      // save completed match scores at end of search
      if (abbrIndex == abbrev.length) {
        // add trailing score for the remainder of the match
        var started = (search.charAt(0) == abbrev.charAt(0));
        var trailScore = started ? SCORE_TRAILING_BUT_STARTED : SCORE_TRAILING;
        fillArray(scores, trailScore, scores.length, string.length);
        // save score clone (since reference is persisted in scores)
        allScores.push(scores.slice(0));
        return;
      }

      // consume current char to match
      var c = abbrev.charAt(abbrIndex);
      abbrIndex++;

      // cancel match if a character is missing
      var index = search.indexOf(c, searchIndex);
      if (index == -1) return;

      // match all instances of the abbreviaton char
      var scoreIndex = searchIndex; // score section to update
      while ((index = search.indexOf(c, searchIndex+1)) != -1) {
        // score this match according to context
        if (isNewWord(string, index)) {
          scores[index-1] = 1;
          fillArray(scores, SCORE_BUFFER, scoreIndex+1, index-1);
        }
        else if (isUpperCase(string, index)) {
          fillArray(scores, SCORE_BUFFER, scoreIndex+1, index);
        }
        else {
          fillArray(scores, SCORE_NO_MATCH, scoreIndex+1, index);
        }
        scores[index] = SCORE_MATCH;

        // consume matched string and continue search
        searchIndex = index;
        this._scoreAll(string, search, abbrev, searchIndex, abbrIndex, scores, allScores);
      }
    }
  };

  function isUpperCase(string, index) {
    var c = string.charAt(index);
    return ("A" <= c && c <= "Z");
  }

   function isNewWord(string, index) {
    var c = string.charAt(index-1);
    return (WORD_SEPARATORS.indexOf(c) != -1);
  }

  function fillArray(array, value, from, to) {
    for (var i = from; i < to; i++) { array[i] = value; }
    return array;
  }
})();

; browserify_shim__define__module__export__(typeof LiquidMetal != "undefined" ? LiquidMetal : window.LiquidMetal);

}).call(global, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

},{}],"lodash":[function(require,module,exports){
module.exports=require('aBLxx7');
},{}],"aBLxx7":[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};(function browserifyShim(module, exports, define, browserify_shim__define__module__export__) {
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

; browserify_shim__define__module__export__(typeof _ != "undefined" ? _ : window._);

}).call(global, undefined, undefined, undefined, function defineExport(ex) { module.exports = ex; });

},{}],"MpjZaV":[function(require,module,exports){
var angular = require('angular');

require('src/tune-lists/module');
require('src/set-lists/module');
require('angular-bootstrap');
require('angular-resource');
require('angular-cookies');
require('angular-route');
require('angular-animate');

var app = angular.module('jnr', [
    'ngResource',
    'ngCookies',
    'ngRoute',
    'ngAnimate',
    'ui.bootstrap',
    'jnr.tune-lists',
    'jnr.set-lists'
]);

app.value('jNow', new Date())
    .config(function ($locationProvider) {
        $locationProvider.html5Mode(true).hashPrefix('!');   
    });

module.exports = app
 .config(function ($routeProvider) {
    
        $routeProvider.otherwise({
            redirectTo: '/sets/list/mandolin'
        });
    });

 
},{"angular":"t5daAN","angular-animate":"7HlBcc","angular-bootstrap":"ZGQjzz","angular-cookies":"vNkBbw","angular-resource":"dIO6bv","angular-route":"auZsF/","src/set-lists/module":"Fi6dAY","src/tune-lists/module":"mKFmtN"}],"src/app":[function(require,module,exports){
module.exports=require('MpjZaV');
},{}],"aaMb1q":[function(require,module,exports){
module.exports = function (
    $scope, 
    $rootScope, 
    $location, 
    jPageState,
    jModals
) {
    $scope.currentUrl = $location.path();
    $scope.pageState = jPageState.get();
    $scope.isCollapsed = true;
    
    $rootScope.$on('locationChangeStart', function () {
        $scope.isCollapsed = true;
    });

    $scope.toggleNewTunes = function () {
        $rootScope.showNewTunes = !$rootScope.showNewTunes;
    };

    $scope.addTune = function () {
        jModals.open('addTune');
    };
};

},{}],"src/common/controllers/top-nav":[function(require,module,exports){
module.exports=require('aaMb1q');
},{}],"GpfO9m":[function(require,module,exports){
module.exports = function($rootScope, $resource, $http) {
    var tables = {},
        resources = {},
        updateFromTheSession = function() {
            $http({
                method: 'GET',
                url: '/rest/scraper'
            })
                .success(function(data, status, headers, config) {
                    data.map(function(item) {
                        tables.tunes.push(new resources.tunes(item));
                    });
                    if (data.length) {
                        $rootScope.$broadcast('newTunesFetched');
                    }
                });
        },

        initResource = function(resourceName, asTable) {
            resources[resourceName] = $resource('/rest/' + resourceName + '/:id', {
                id: '@_id'
            }, {
                'get': {
                    method: 'GET',
                    cache: true
                },
                'update': {
                    method: 'PUT'
                }
                // 'query' : { method:'GET', cache: true, isArray: true }
            });
            if (asTable) {
                tables[resourceName] = resources[resourceName].query(function(result) {
                    $rootScope.$broadcast('jDataLoaded', resourceName);
                });

                if (resourceName === 'tunes') {
                    updateFromTheSession();
                }
                return tables[resourceName];
            }

            return resources[resourceName];
            // },

            // init = function () {
            //     var resourceNames = Array.prototype.slice.apply(arguments);

            //     for (var i = resourceNames.length; --i; i>-1) {
            //         if (!resources[resourceNames[i]]) {
            //             initResource(resourceNames[i]);
            //         }
            //     }
        };

    return {
        getTable: function(name) {
            return tables[name] || initResource(name, 'table');
        },
        getResource: function(name) {
            return resources[name] || initResource(name);
        } //,
        // init: init

    };
};
},{}],"src/common/data/database":[function(require,module,exports){
module.exports=require('GpfO9m');
},{}],"PDNe9n":[function(require,module,exports){
module.exports = function($rootScope) {
    var dropdowns = {
        playback: [{
            value: 0,
            label: 'Novice'
        }, {
            value: 1,
            label: 'Hand-holding'
        }, {
            value: 2,
            label: 'Sloppy/Slow'
        }, {
            value: 3,
            label: 'Playalong'
        }, {
            value: 4,
            label: 'Starter'
        }, {
            value: 5,
            label: 'Solo'
        }],
        popularity: [{
            value: 0,
            label: 'Unknown'
        }, {
            value: 1,
            label: 'Rare'
        }, {
            value: 2,
            label: 'Common'
        }, {
            value: 3,
            label: 'Standard'
        }],
        rating: [{
            value: 1,
            label: 'Mediocre'
        }, {
            value: 2,
            label: 'Run of the mill'
        }, {
            value: 3,
            label: 'Pretty good'
        }, {
            value: 4,
            label: 'Really nice'
        }, {
            value: 5,
            label: 'Special'
        }],
        difficulty: [{
            value: 1,
            label: 'Easy-peasy'
        }, {
            value: 2,
            label: 'Straightforward'
        }, {
            value: 3,
            label: 'Tricky Bits'
        }, {
            value: 4,
            label: 'Really hard'
        }],
        rhythm: [
            'jig',
            'reel',
            'slip jig',
            'hornpipe',
            'polka',
            'slide',
            'waltz',
            'barndance',
            'strathspey',
            'three-two',
            'mazurka'
        ],
        root: [
            'A',
            'B',
            'C',
            'D',
            'E',
            'F',
            'G',
            'Bb',
            'Eb',
            'Ab',
            'Db',
            'F#',
            'C#',
            'G#'
        ],
        mode: [
            'maj',
            'min',
            'mix',
            'dor',
            'aeo'
        ]
    };

    $rootScope.dropdowns = dropdowns;

    return dropdowns;
};
},{}],"src/common/data/dropdowns":[function(require,module,exports){
module.exports=require('PDNe9n');
},{}],"XxoOEQ":[function(require,module,exports){
'use strict';
var angular = require('angular');
require('angular-resource');

module.exports = angular.module('jnr.common', ['ngResource'])
    
    .directive('jSelectOnClick', require('./ui/select-on-click'))
    .filter('capitalise', require('./ui/capitalise'))
    .service('jModals', require('./ui/modals'))
    .service('readCookie', require('./services/read-cookie'))
    .service('jPageState', require('./services/page-state'))
    .service('jDatabase', require('./data/database'))
    .service('jDropdowns', require('./data/dropdowns'))
    .controller('topNav', require('./controllers/top-nav'))
;
},{"./controllers/top-nav":"aaMb1q","./data/database":"GpfO9m","./data/dropdowns":"PDNe9n","./services/page-state":"mGISb5","./services/read-cookie":"kvUSy6","./ui/capitalise":"Z4XqQn","./ui/modals":"Bdfl6Z","./ui/select-on-click":"gJd0X8","angular":"t5daAN","angular-resource":"dIO6bv"}],"src/common/module":[function(require,module,exports){
module.exports=require('XxoOEQ');
},{}],"mGISb5":[function(require,module,exports){
module.exports = function ($rootScope, $cookies) {
    var params = {};
    $rootScope.pageState = params;
    return {
        set: function (data) {
            // params = data;
            for (var key in data) {
                params[key] = data[key];
                if (key === 'instrument') {
                    $cookies.instrument = data.instrument;
                }
                
            }
        },
        get: function (prop) {
            return prop ? params[prop] : params;
        }
    };
};

},{}],"src/common/services/page-state":[function(require,module,exports){
module.exports=require('mGISb5');
},{}],"kvUSy6":[function(require,module,exports){
'use strict';

/* istanbul ignore next: copied */ 
module.exports = function readCookie (name) {
    var nameEQ = name + '=';
    var ca = document.cookie.split(';');
    for(var i=0;i < ca.length;i++) {
        var c = ca[i];
        while (c.charAt(0) === ' ') {
            /* istanbul ignore next: copied */ 
            c = c.substring(1,c.length);
        }
        /* istanbul ignore if: copied */ 
        if (c.indexOf(nameEQ) === 0) {
            return c.substring(nameEQ.length,c.length);
        }
    }
    return null;
};
},{}],"src/common/services/read-cookie":[function(require,module,exports){
module.exports=require('kvUSy6');
},{}],"src/common/ui/capitalise":[function(require,module,exports){
module.exports=require('Z4XqQn');
},{}],"Z4XqQn":[function(require,module,exports){
'use strict';

module.exports = function() {
    return function(input) {
        return input.charAt(0).toUpperCase() + input.substr(1);
    };
};

},{}],"Bdfl6Z":[function(require,module,exports){
'use strict';

module.exports = function ($modal) {
    
    var configs = {
        tuneViewer: {
            templateUrl: '/src/tune/tpl/tune-viewer.html',
            controller: 'tuneViewer',
            windowClass:  'tune-viewer fade'
        },
        addTune: {
            templateUrl: '/src/tune/tpl/add-tune.html',
            controller: 'addTune',
            windowClass:  'add-tune fade'
        },
        performanceEditor: {
            templateUrl: '/src/tune/tpl/performance-editor.html',
            windowClass:  'fade'
        },
        arrangementConfirm: {
            templateUrl: '/src/tune/tpl/arrangement-confirm.html',
            windowClass:  'fade'
        },
        abcConfirm: {
            templateUrl: '/src/tune/tpl/abc-confirm.html',
            windowClass:  'fade'
        }
    };

    return {
        open: function (type, scope) {
            var conf = configs[type] || /* istanbul ignore next: paranoid fallback */ {};
            scope && (conf.scope = scope);
            
            return $modal.open(conf);

        }
    };
};

},{}],"src/common/ui/modals":[function(require,module,exports){
module.exports=require('Bdfl6Z');
},{}],"gJd0X8":[function(require,module,exports){
'use strict';
module.exports = function () {
    return function (scope, element, attrs) {
        element.bind('click', function () {
            element[0].select();
        });
    };
};

},{}],"src/common/ui/select-on-click":[function(require,module,exports){
module.exports=require('gJd0X8');
},{}],"src/controllers":[function(require,module,exports){
module.exports=require('uVj9MF');
},{}],"uVj9MF":[function(require,module,exports){
// var angular = require('angular'),
//     listTunes = require('src/tune-lists/controllers/list-tunes'),
//     // viewTune = require('src/controllers/view-tune'),
//     // setBuilder = require('src/controllers/set-builder'),
//     // listSets = require('src/controllers/list-sets'),
//     newTunes = require('src/tune-lists/controllers/new-tunes'),
//     tuneViewer = require('src/controllers/modals/tune-viewer'),
//     addTune = require('src/controllers/modals/add-tune'),
//     topNav = require('src/controllers/include/top-nav');


// module.exports = function () {

//     angular.module('jnr')
//         .controller('listTunes', listTunes)
//         //.controller('viewTune', viewTune)
//         //.controller('setBuilder', setBuilder)
//         //.controller('listSets', listSets)
//         .controller('newTunes', newTunes)
//         .controller('tuneViewer', tuneViewer)
//         .controller('addTune', addTune)
//         .controller('topNav', topNav);

// };

},{}],"nbHEfk":[function(require,module,exports){
var angular = require('angular');
require('src/app');

angular.bootstrap(document, ['jnr']);
},{"angular":"t5daAN","src/app":"MpjZaV"}],"src/main":[function(require,module,exports){
module.exports=require('nbHEfk');
},{}],"JZdZmN":[function(require,module,exports){
// 'use strict';

// var readCookie = require('src/common/read-cookie');

// module.exports = function () {

//     require('angular').module('jnr').config(['$routeProvider', '$locationProvider', function ($routeProvider, $locationProvider) {
        
//         $locationProvider.html5Mode(true).hashPrefix('!');   

//         $routeProvider.when('/tunes', {
//             templateUrl: '/views/list-tunes.html'
//         }).when('/tunes/:instrument', {
//             templateUrl: '/views/list-tunes.html'
//         // }).when('/tune/:id', {
//         //     templateUrl: '/views/tune.html'
//         // }).when('/tune/:id/:instrument', {
//         //     templateUrl: '/views/tune.html'
//         // }).when('/sets/new/', {
//         //     templateUrl: '/views/set-builder.html'
//         // }).when('/sets/list/', {
//         //     templateUrl: '/views/set-list.html'
//         // }).when('/sets/new/:instrument', {
//         //     templateUrl: '/views/set-builder.html'
//         // }).when('/sets/list/:instrument', {
//         //     templateUrl: '/views/set-list.html'
//         }).otherwise({
//             redirectTo: '/tunes/' + ( readCookie('instrument') || 'mandolin')
//         });
//     }]);
// };

    

},{}],"src/routes":[function(require,module,exports){
module.exports=require('JZdZmN');
},{}],"src/set-builder/set-builder_controller":[function(require,module,exports){
module.exports=require('cijzCk');
},{}],"cijzCk":[function(require,module,exports){
// 'use strict';

// require('src/services/page-state');

// module.exports = function (
//     $scope,     
//     $routeParams, 
//     jPageState
// ) {
//     jPageState.set({
//         section: 'sets',
//         instrument: $routeParams.instrument,
//         subsection: 'new', 
//         path: '/sets/new'
//     });
// };

},{}],"src/set-lists/controllers/list-sets":[function(require,module,exports){
module.exports=require('xfU5jY');
},{}],"xfU5jY":[function(require,module,exports){
'use strict';

require('src/set/services/set-model');
require('src/common/services/page-state');

var _ = require('lodash');

module.exports = function (
    $routeParams, 
    $scope, 
    $rootScope,
    jModals,
    jSet,
    $timeout,
    jPageState,
    jDatabase
) {

    // console.log(jDatabase.getTable('tunes'), 'red');
    jPageState.set({
        section: 'sets',
        instrument: $routeParams.instrument,
        subsection: 'list', 
        path: '/sets/list'
    });
    
    $scope.selectedTunes = [];

    $scope.arrangements = [];
    jDatabase.getTable('tunes').$promise.then(function (data){
        $scope.arrangements = _.sortBy(data.map(function (tune) {
            var perf = _.findWhere(tune.performances, {instrument: $routeParams.instrument});
            if (perf) {
                var arr = _.findWhere(tune.arrangements, {_id: perf.arrangement});
                arr.name = tune.name + ' ' + arr.root + tune.mode + ' ' + tune.rhythm;
                arr.sanitisedName = arr.name.replace(/^(The|A) /, '');
                return arr;
            }
        }).filter(function (item) {
            return item;
        }), 'sanitisedName');  
    });

    $scope.sets = [];
    jDatabase.getTable('tunes').$promise.then(function () {
        jDatabase.getTable('sets').$promise.then(function (data) {
            $scope.sets = data.map(function (set) {
                return new jSet(set);
            });

            $timeout(function () {
                $scope.sets = _.sortBy($scope.sets, function (set) {
                    return set.performance.lastPracticed - (set.performance.standard * 12 * 60 *24000);
                });
            });
        });

    
        // $scope.sets = $scope.sets.sort(function (set1, set2) {
        //     return set2.performance.lastPracticed - set1.performance.lastPracticed;
        // });
        
    });
        

    $scope.undo = function () {
        $scope.selectedTunes.pop();
    };

    $scope.selectTune = function () {
        $scope.selectedTunes.push(this.selectedTune);
        this.selectedTune = null;
    };

    $scope.selectedIndex = -1;

    $scope.expandRow = function ($index) {
        $scope.selectedIndex = $index;
    };


    $scope.saveSet = function () {
        var tunes = $scope.selectedTunes;
        if (tunes.length) {
            jDatabase.getResource('sets').save({
                name: 'fuzzy' + Math.random(),
                tunes: tunes
            }, function (set) {
                jDatabase.getTable('sets').shift(set);
            });
            $scope.selectedTunes = [];
        }
    };

    $scope.practice = function () {
        this.tune.update();
        var set = this.$parent.$parent.set;
        var tunesLeftToPractice = set.tunes.filter(function (tune) {
            return (new Date()) - (new Date(tune.performance.lastPracticed)) > 120000;
        }).length;

        if (!tunesLeftToPractice) {
            $scope.sets.splice($scope.sets.indexOf(set), 1);
            $scope.sets.push(set);
        }

    };

    $scope.expandTune = function (opts) {
        opts = opts || {};
        $rootScope.activeTune = this.tune;
        this.propertiesCollapsed = !opts.edit;
        this.showPerformance = !opts.noPerformance;
        jModals.open('tuneViewer', this);
    };

    $scope.practiceAll = function () {
        var set = this.ratee;
        set.tunes.forEach(function (tune) {
            tune.dummyStandard = set.dummyStandard;
            tune.update();
        });
        set.updatePerformance(true);

        $scope.sets.splice($scope.sets.indexOf(set), 1);
        $scope.sets.push(set);
    };
};
},{"lodash":"aBLxx7","src/common/services/page-state":"mGISb5","src/set/services/set-model":"eEBwhC"}],"src/set-lists/module":[function(require,module,exports){
module.exports=require('Fi6dAY');
},{}],"Fi6dAY":[function(require,module,exports){
'use strict';

require('src/common/module');
require('src/set/module');

var angular = require('angular'),
    readCookie = require('src/common/services/read-cookie'),
    setModule = angular.module('jnr.set-lists', ['jnr.common', 'jnr.set']),
    listSets = require('src/set-lists/controllers/list-sets');
    // addTune = require('src/set/controllers/add-set');
        

module.exports = setModule
    .controller('listSets', listSets)
    .config(function ($routeProvider) {
    
        $routeProvider.when('/sets/list/', {
            templateUrl: '/src/set-lists/tpl/list-sets.html'
        }).when('/sets/list/:instrument', {
            templateUrl: '/src/set-lists/tpl/list-sets.html'
        });
    });
},{"angular":"t5daAN","src/common/module":"XxoOEQ","src/common/services/read-cookie":"kvUSy6","src/set-lists/controllers/list-sets":"xfU5jY","src/set/module":"a5e9QZ"}],"src/set/module":[function(require,module,exports){
module.exports=require('a5e9QZ');
},{}],"a5e9QZ":[function(require,module,exports){
'use strict';

require('src/common/module');
require('src/tune/module');

var angular = require('angular'),
    setModule = angular.module('jnr.set', ['jnr.common', 'jnr.tune']);
    // setViewer = require('src/set/controllers/set-viewer'),
    // addTune = require('src/set/controllers/add-set');
        

module.exports = setModule;
    // .controller('setViewer', setViewer)
    // .controller('addTune', addTune);
},{"angular":"t5daAN","src/common/module":"XxoOEQ","src/tune/module":"Wotg+P"}],"eEBwhC":[function(require,module,exports){
var angular = require('angular'),
    _ = require('lodash');

// require('src/tune/services/abc-parser');

require('angular').module('jnr.set').factory('jSet', function (
    $routeParams,
    $rootScope,
    jDatabase,
    jTune
) {

    var tunesFetched = false;
        
    var Set = function (set, opts) {
        this.set = set;
        this.opts = opts || {};
        this.init();
    };

    Set.prototype = {
        init: function () {
            var self = this;
            this.overflow = 6 - this.set.tunes.length;
            if (!tunesFetched) {
                jDatabase.getTable('tunes').$promise.then(function () {
                    tunesFetched = true;
                    this.setTunes();
                }.bind(this));
                this.performance = {
                    standard: -1,
                    best: -1,
                    lastPracticed: 0
                };
            } else {
                this.setTunes();
            }
        },
        setTunes: function () {
            if (this.set.tunes) {
                this.tunes = this.set.tunes.map(function (arrangement) {
                    return jTune.getForArrangement(arrangement, $rootScope.pageState.instrument);                
                });   
                
                this.updatePerformance();
            } else {
                this.tunes = [];
            }
            
        },
        updatePerformance: function (practiced) {
            
            this.dummyStandard = -1;
            this.performance = {
                standard: this.tunes.reduce(function (prevVal, tune) {
                    return Math.min(prevVal, tune.performance.standard);
                }, 5),
                best: this.tunes.reduce(function (prevVal, tune) {
                    return Math.min(prevVal, tune.performance.best);
                }, 5),
                lastPracticed: //practiced ? Date.now() : 
                this.tunes.reduce(function (prevVal, tune) {
                    if (typeof prevVal === 'undefined') {
                        return (new Date(tune.performance.lastPracticed).getTime());
                    }
                    return Math.min(prevVal, (new Date(tune.performance.lastPracticed)).getTime());
                }, undefined)
            }; 
        }

    };

    return Set;
       
});

},{"angular":"t5daAN","lodash":"aBLxx7"}],"src/set/services/set-model":[function(require,module,exports){
module.exports=require('eEBwhC');
},{}],"src/tune-lists/controllers/list-tunes":[function(require,module,exports){
module.exports=require('spIL2A');
},{}],"spIL2A":[function(require,module,exports){
'use strict';

var liquidMetal = require('liquidmetal'),
    _ = require('lodash');

require('src/tune-lists/services/tune-list');
require('src/tune/ui/tune-heading');
require('src/tune/ui/performance-rater');
require('src/common/ui/select-on-click');
require('src/common/services/page-state');

module.exports = function (
    $scope, 
    $rootScope, 
    $routeParams, 
    jPageState, 
    jTuneList
) {
    var filters = {
            practice: function (tune) {
                return tune.tune.performances.length && (!$routeParams.instrument || _.filter(tune.tune.performances, function (performance) {
                    return performance.instrument === $routeParams.instrument && (performance.best > 2 || performance.special);
                }).length);
            },
            search: function (tune) {
                tune.searchScore = liquidMetal.score(tune.tune.name, $scope.searchTerm.replace(/\s/g, ''));
                return tune.searchScore > 0.3;
            }
        },
        sorters = {
            practice: function (tune) {
                var performance = tune.performance || tune._createPerformance(),
                    gap = performance.best - performance.standard,
                    difficulty = performance.difficulty === -1 ? 0 : performance.difficulty,
                    rating = tune.tune.rating === -1 ? 0 : tune.tune.rating,
                    popularity = tune.tune.popularity === -1 ? 0 : tune.tune.popularity,
                    practiceUrgency = 0,
                    uniqueVersion = tune.tune.performances.length < 2,
                    tuneRank = (performance.special * 5) + (1.5 * rating) + popularity + uniqueVersion;

                if (performance.best > 2 || performance.special) {
                    practiceUrgency = (gap + (difficulty / 2) + 1);
                    if (performance.standard < 3) {
                        practiceUrgency += gap;
                    }
                    if (performance.special && performance.best < 3 ) {
                        practiceUrgency += 2;
                    }
                } else {
                    practiceUrgency = (gap - (difficulty / 2) + 1);
                }
                tune.practiceRank = tuneRank * practiceUrgency * (tune.daysSinceLastPractice + 1);
                return -tune.practiceRank;
            },
            search: function (tune) {
                return -tune.searchScore; 
            }
        },
        getFilter = function (filterTerm) {
            var modeTerm = $scope.filterMode.trim(),
                rhythmTerm = $scope.filterRhythm.trim();

            var allTuneRhythms = $rootScope.dropdowns.rhythm,
                rhythms = {
                    included: [],
                    excluded: []
                };

            if (rhythmTerm) {
                rhythmTerm = rhythmTerm.split('|');
                for (var key in allTuneRhythms) {
                    if (rhythmTerm.indexOf(allTuneRhythms[key]) > -1) {
                        rhythms.included.push(allTuneRhythms[key]);
                    }
                    if (rhythmTerm.indexOf('!' + allTuneRhythms[key]) > -1) {
                        rhythms.excluded.push(allTuneRhythms[key]);
                    }
                }
            }

            if (modeTerm && /^(\!?([ABCDEFG](#|b)?)?([a-z]{3})?(\|)?)+$/.test(modeTerm)) {
                var modes = [],
                    mode,
                    modeMatchers = {
                        and: [],
                        or: []
                    };
                // modeTerm = modeTerm.replace(/\([^(]+\)/g, function ($1) {
                //     modes.push($1.substr(1, $1.length - 2));
                //     return '';
                // });

                modes = modes.concat(modeTerm);

                for (mode in modes) {
                    getSingleModeFilter(modes[mode], modeMatchers);
                }
                // filter by e.g G|aeo Dmaj, mix|maj. case sensitive, !G (not automatically becomes an and)

            }
            
            return function (tune) {
                if (rhythmTerm) {
                    if ((rhythms.included.length && rhythms.included.indexOf(tune.tune.rhythm) === -1) || (rhythms.excluded.length && rhythms.excluded.indexOf(tune.tune.rhythm) > -1)) {
                        return false;
                    }

                }

                if (modeMatchers) {
                    return runMatchers(tune, modeMatchers);
                }

                return true;
            };
            
        },

        getSingleModeFilter = function (mode, matchers) {
            // if (!mode) {
            //     return;
            // }
            var statements;
            // if (mode.indexOf('|!') > -1) {
            //     statements = mode.split('|!');
            //     statements.map(function (item, index) {
            //         getSingleModeFilter(index !== 0 ? '!' : '' + item, matchers);
            //     });
            //     return;
            // }
            if (/[a-z]\|[A-Z]/.test(mode)) {
                (function () {
                    var statements = mode.split('|'),
                        i, 
                        il,
                        statement = '';

                    for (i = 0, il = statements.length; i<il; i++) {
                        if (!statement) {
                            statement = statements[i];
                        } else {
                            /* istanbul ignore else: other code prevents it ever running */
                            if (/[a-z]/.test(statement.charAt(statement.length - 1)) && /[A-Z]/.test(statements[i].charAt(0))) {
                                getSingleModeFilter(statement, matchers);
                            }
                            statement = statements[i];
                        }
                    }   
                    getSingleModeFilter(statement, matchers);

                    
                }());
                return;
            }
            var roots = mode.match(/[A-Z]/g),
                modes = mode.match(/[a-z]{3}/g),
                negated = mode.indexOf('!') === 0;

            var matcher = function (tune) {
                var matches = true;
                if (roots) {
                    matches = matches && roots.indexOf(tune.arrangement.root) > -1;
                } 
                if (modes) {
                    matches = matches && modes.indexOf(tune.tune.mode) > -1;
                }
                
                return negated ? !matches : matches;
            };

            matchers[negated ? 'and' : 'or'].push(matcher);
        },

        runMatchers = function (tune, matchers) {
            var matcher,
                result = false;
            if (matchers.or.length) {
                for (matcher in matchers.or) {
                    if (matchers.or[matcher](tune)) {
                        result = true;
                        break;
                    }
                }
            } else {
                result = true;
            }

            if (matchers.and.length) {
                for (matcher in matchers.and) {
                    if (!matchers.and[matcher](tune)) {
                        return false;
                    }
                }
            }

            return result;
        };

    function updateCounts () {
        if ($scope.searchTerm) {return;}
        var allTunes = Array.prototype.concat.apply(tuneList.selectedTunes, tuneList.otherTunes);
        $scope.counts = [
            allTunes.length,
            {
                now: _.filter(allTunes, function (tune) {
                    return tune.performance.standard === 1;
                }).length,
                past: _.filter(allTunes, function (tune) {
                    return tune.performance.best === 1;
                }).length
            },
            {
                now: _.filter(allTunes, function (tune) {
                    return tune.performance.standard === 2;
                }).length,
                past: _.filter(allTunes, function (tune) {
                    return tune.performance.best === 2;
                }).length
            },
            {
                now: _.filter(allTunes, function (tune) {
                    return tune.performance.standard === 3;
                }).length,
                past: _.filter(allTunes, function (tune) {
                    return tune.performance.best === 3;
                }).length
            },
            {
                now: _.filter(allTunes, function (tune) {
                    return tune.performance.standard === 4;
                }).length,
                past: _.filter(allTunes, function (tune) {
                    return tune.performance.best === 4;
                }).length
            },
            {
                now: _.filter(allTunes, function (tune) {
                    return tune.performance.standard === 5;
                }).length,
                past: _.filter(allTunes, function (tune) {
                    return tune.performance.best === 5;
                }).length
            }
        ];

        $scope.counts.toScratch = {
            now: _.filter(allTunes, function (tune) {
                return tune.performance.standard > 2;
            }).length,
            past: _.filter(allTunes, function (tune) {
                return tune.performance.best > 2;
            }).length
        };
    }

    $scope.update = function () {
        // if (this.tune.dummyStandard > -1) {
        //     tuneList.moveToBottom(this.tune);    
        // }

        this.tune.update({
            performance: this.tune.performance,
            setPublicPerformance: true
        });
        
        //updateCounts();
    };

    $scope.searchTerm = '';
    $scope.filterMode = '';
    $scope.filterRhythm = '';
    $scope.summaryCollapsed = true;
    $rootScope.$on('tunePracticed', function (event, tune) {
        tuneList.moveToBottom(tune);
        updateCounts();

    });

    $scope.search = function () {
        if ($scope.searchTerm.trim().length > 3) {
            $scope.filterMode = '';
            $scope.filterRhythm = '';
            tuneList.relist({
                filter: filters.search,
                sort: sorters.search,
                forceRelist: true,
                limit: 0
            });
        } else {
            tuneList.relist({
                filter: filters.practice,
                sort: sorters.practice,
                limit: 15
            });
        }
    };

    $scope.filter = function () {
        
        if ($scope.filterMode.trim() || $scope.filterRhythm.trim()) {
            $scope.searchTerm = '';
            tuneList.relist({
                filter: getFilter(),
                sort: sorters.practice,
                forceRelist: true,
                limit: ($scope.filterRhythm.trim() && $scope.filterMode.trim()) ? 0 : 20
            });
        } else {
            tuneList.relist({
                filter: filters.practice,
                sort: sorters.practice,
                limit: 15
            });
        }
    };

    $scope.filters = filters;
    $scope.sorters = sorters;

    jPageState.set({
        section: 'tunes',
        instrument: $routeParams.instrument,
        path: '/tunes'
    });

    var tuneList = jTuneList({
        $scope: $scope,
        filter: filters.practice,
        sort: sorters.practice,
        tuneModifier: function (tune) {
            tune.dummyStandard = -1;
        }
    });

    try {
        updateCounts();
    } catch (e) {
        $scope.$on('tunesListed', function (event, list) {
            
            // if (list === tuneList) {
            updateCounts();
            // }
        });
    }    
};
},{"liquidmetal":"16GGEZ","lodash":"aBLxx7","src/common/services/page-state":"mGISb5","src/common/ui/select-on-click":"gJd0X8","src/tune-lists/services/tune-list":"QJe3JN","src/tune/ui/performance-rater":"Mmq9nn","src/tune/ui/tune-heading":"m/R8wK"}],"wTptoU":[function(require,module,exports){
var _ = require('lodash');

require('src/common/ui/modals');
require('src/tune/ui/tune-heading');
require('src/tune/ui/performance-rater');
require('src/tune-lists/services/tune-list');

module.exports = function (
    $scope,
    $rootScope,
    jTuneList,
    jModals
) {

    $rootScope.showNewTunes = false;

    var getPerformanceForInstrument = function (tune, instrument) {
            return (_.findWhere(tune.tune.performances, {
                    instrument: instrument
                }) || {
                    instrument: instrument,
                    dummy: true
                });
        },
        isNew = function (tune) {
            return tune.isNew();
        };

    $scope.lastTuneRemoved;

    $scope.finished = function () {
        tuneList.remove(this.tune);
        if (!$scope.newTunes.length) {
            $rootScope.showNewTunes = false;
        }
    };

    $scope.undo = function () {
        tuneList.undoRemove();
    };

    $scope.update = function (oldValue) {
        this.tune.update({
            oldProps: oldValue,
            setPublicPerformance: true
        });       
    }; 

    var performanceEditor;

    $scope.editPerformanceForInstrument = function (instrument) {
        this.tune.performance = getPerformanceForInstrument(this.tune, instrument);
        this.instrument = instrument;
        performanceEditor = jModals.open('performanceEditor', this);
    };
    /* istanbul ignore next: tricky to test */
    $scope.finishPerformanceEdit = function (tune) {
        tune.performance = {
            dummy: true
        };
        performanceEditor.dismiss();
    };

    var tuneList = jTuneList({
        $scope: $scope,
        listName: 'newTunes',
        filter: isNew,
        limit: 4
    });

    $rootScope.newTuneCount = tuneList.tuneCount;
    $scope.$on('tunesListed', function (event, tuneList) {
        $rootScope.newTuneCount = tuneList.tuneCount;
    });

    $rootScope.$on('newTunesFetched', function (event) {
        tuneList.relist({
            forceRelist: true
        });
    });
};
},{"lodash":"aBLxx7","src/common/ui/modals":"Bdfl6Z","src/tune-lists/services/tune-list":"QJe3JN","src/tune/ui/performance-rater":"Mmq9nn","src/tune/ui/tune-heading":"m/R8wK"}],"src/tune-lists/controllers/new-tunes":[function(require,module,exports){
module.exports=require('wTptoU');
},{}],"src/tune-lists/module":[function(require,module,exports){
module.exports=require('mKFmtN');
},{}],"mKFmtN":[function(require,module,exports){
'use strict';

require('src/common/module');
require('src/tune/module');

var angular = require('angular'),
    tuneListsModule = angular.module('jnr.tune-lists', ['jnr.common', 'jnr.tune']),
    readCookie = require('src/common/services/read-cookie'),
    listTunes = require('src/tune-lists/controllers/list-tunes'),
    newTunes = require('src/tune-lists/controllers/new-tunes');
        
module.exports = tuneListsModule
    .controller('listTunes', listTunes)
    .controller('newTunes', newTunes)
    .config(function ($routeProvider) {
    
        $routeProvider.when('/tunes', {
            templateUrl: '/src/tune-lists/tpl/list-tunes.html'
        }).when('/tunes/:instrument', {
            templateUrl: '/src/tune-lists/tpl/list-tunes.html'
        });
    });


},{"angular":"t5daAN","src/common/module":"XxoOEQ","src/common/services/read-cookie":"kvUSy6","src/tune-lists/controllers/list-tunes":"spIL2A","src/tune-lists/controllers/new-tunes":"wTptoU","src/tune/module":"Wotg+P"}],"src/tune-lists/services/tune-list":[function(require,module,exports){
module.exports=require('QJe3JN');
},{}],"QJe3JN":[function(require,module,exports){
require('src/common/data/database');
require('src/common/ui/modals');
require('src/tune/services/tune-model');
require('src/common/services/page-state');

var _ = require('lodash');

require('angular').module('jnr.tune-lists').factory('jTuneList', function (
    $rootScope, 
    jDatabase, 
    jModals,
    jPageState,
    jTune
) {

    var allTunes = jDatabase.getTable('tunes'),

        expandTune = function (opts) {
            opts = opts || {};
            $rootScope.activeTune = this.tune;
            this.propertiesCollapsed = !opts.edit;
            this.showPerformance = !opts.noPerformance;
            jModals.open('tuneViewer', this);
        },

        update = function () {
            this.tune.update();
        },

        tuneListFactory = function (conf) {
            return new TuneList(conf);
        },

        TuneList = function (conf) {
            this.conf = conf;
            this.init();
        };

    TuneList.prototype = {
        
        init: function () {
            var self = this;
            this.$scope = this.conf.$scope;
            
            this.tuneModifier = this.conf.tuneModifier || function () {};
            this.listName = this.conf.listName || 'tunes';
            this.setParams(this.conf);
            this.tuneCount = 0;

            if (!allTunes.length) {
                this.$scope.$on('jDataLoaded', function () {
                    self.populateList();
                });
            } else {
                this.populateList();
            }

            this.$scope.expandTune = this.$scope.expandTune || expandTune;
            this.$scope.update = this.$scope.update || update;
        },
        setParams: function (conf) {
            this.sort = conf.sort !== undefined ? conf.sort : this.sort;
            this.filter = conf.filter !== undefined ? conf.filter : this.filter;
            this.limit = conf.limit !== undefined ? conf.limit :
                        this.limit === undefined ? 15 : this.limit;
        },
        populateList: function () {
            var self = this,
                tunes = [];

            allTunes.map(function (tune) {
                var aggregates = jTune.extract(tune, {
                    performanceFilter: function (perf) {
                        return perf.instrument === $rootScope.pageState.instrument;
                    },
                    list: tunes
                }, {
                    modifier: self.tuneModifier
                });
            });
            if (this.filter) {
                tunes = _.filter(tunes, this.filter);    
            }
            this.tuneCount = tunes.length;
            if (this.sort) {
                tunes = _.sortBy(tunes, this.sort);
            }
            if (this.limit) {
                this.selectedTunes = _.first(tunes, this.limit);
                this.otherTunes = _.rest(tunes, this.limit);
            } else {
                this.selectedTunes = tunes;
                this.otherTunes = [];
            }
            this.$scope[this.listName] = this.selectedTunes;
            this.$scope.$emit('tunesListed', this);
        },
        relist: function (conf) {
            var oldLimit = this.limit;
            if (!conf.forceRelist) {
                if (conf.sort && conf.sort === this.sort) {
                    delete conf.sort;
                }
                if (conf.filter && conf.filter === this.filter) {
                    delete conf.filter;
                }
                if (!conf.filter && !conf.sort && conf.limit === undefined) {
                    return;
                }
            }
            this.setParams(conf);

            if (conf.sort || conf.filter) {
                this.populateList();
            } else if (typeof conf.limit !== 'undefined') {
                //change the size of the list
                if (this.limit === 0 && oldLimit !== 0) {
                    Array.prototype.push.apply(this.selectedTunes, this.otherTunes);
                    this.otherTunes = [];
                } else if (oldLimit > this.limit) {
                    Array.prototype.unshift.apply(this.otherTunes, this.selectedTunes.splice(this.limit, oldLimit - this.limit));
                } else if (oldLimit < this.limit) {
                    Array.prototype.push.apply(this.selectedTunes, this.otherTunes.splice(0, this.limit - oldLimit));
                }
            } else {
                this.populateList();
            }
        },
        moveToBottom: function (tune) {
            var self = this;
            this.selectedTunes.splice(this.selectedTunes.indexOf(tune), 1);
            if (this.otherTunes.length) {
                this.otherTunes.push(tune);
                this.selectedTunes.push(this.otherTunes.shift());
            } else {
                // timeout prevents a move event triggering instead of a leave event
                // and hence makes sure the animation happens
                setTimeout(function () {
                    self.selectedTunes.push(tune);
                }, 1);
            }
        },
        remove: function (tune) {
            var index = this.selectedTunes.indexOf(tune);
            this.selectedTunes.splice(index, 1 );
            this.lastRemoved = [index, tune];
            this.$scope.lastRemoved = true;
            if (this.otherTunes.length) {
                this.selectedTunes.push(this.otherTunes.shift());
            }
        },
        undoRemove: function () {
            this.otherTunes.unshift(this.selectedTunes.pop());
            this.selectedTunes.splice(this.lastRemoved[0], 0, this.lastRemoved[1]);
            this.$scope.lastRemoved = false;
            this.lastRemoved = null;
        }
    };

    return tuneListFactory;
}); 
},{"angular":"t5daAN","lodash":"aBLxx7","src/common/data/database":"GpfO9m","src/common/services/page-state":"mGISb5","src/common/ui/modals":"Bdfl6Z","src/tune/services/tune-model":"bTNFzr"}],"CkNMyn":[function(require,module,exports){
require('src/tune/ui/draw-score');
require('src/common/data/database');

module.exports = function (
    $scope,
    jTune
) {

    $scope.newTune = {
        performance: {}
    };

    $scope.save = function () {
        if (jTune.create($scope.newTune)) {
            $scope.$dismiss();
        } 
    };
    
};
},{"src/common/data/database":"GpfO9m","src/tune/ui/draw-score":"z4Lk0Z"}],"src/tune/controllers/add-tune":[function(require,module,exports){
module.exports=require('CkNMyn');
},{}],"oogQIt":[function(require,module,exports){
'use strict';
var angular = require('angular');
require('src/tune/ui/draw-score');
require('src/tune/ui/performance-rater');
require('src/common/ui/modals');

module.exports = function (
    $scope, 
    jModals
) {

    $scope.tune = $scope.activeTune;
    $scope.tune.dummyStandard = -1;
    $scope.editingAbc = false;
    $scope.isNewAbc = false;

    var oldArrangementValue,
        arrangementConfirm;

    $scope.update = function (redrawScore) {

        if($scope.tune.update({
            performance: $scope.tune.performance,
            setPublicPerformance: true,
            updateScore: redrawScore
        }).practiced) {
            $scope.$dismiss();
        }
    };

    $scope.editAbc = function () {
        $scope.editableScoreGenerator = angular.copy($scope.tune.scoreGenerator);  
        $scope.editingAbc = true;
        $scope.isNewAbc = false;
    };

    $scope.newAbc = function () {
        $scope.editableScoreGenerator = angular.copy($scope.tune.scoreGenerator);  
        $scope.editableScoreGenerator.arrangement.abc = ''; 
        $scope.editingAbc = true;
        $scope.isNewAbc = true;
    };

    $scope.updateArrangement = function (oldValue) {
        oldArrangementValue = oldValue;
        arrangementConfirm = jModals.open('arrangementConfirm', $scope);
    };

    $scope.saveThisAbc = function () {
        $scope.tune.arrangement.abc = editedAbc;
        editedAbc = null;
        $scope.tune.update({
            updateScore: true
        });
        abcConfirm.dismiss();
    };

    $scope.saveNewAbc = function () {
        var newArrangement = angular.extend({}, $scope.tune.arrangement);
        newArrangement.abc = editedAbc;
        editedAbc = null;
        $scope.tune.update({
            arrangement: newArrangement,
            useArrangement: true
        });
        abcConfirm && abcConfirm.dismiss();
    };

    var editedAbc,
        abcConfirm;

    $scope.saveAbcDialog = function () {

        
        editedAbc = $scope.editableScoreGenerator.arrangement.abc;
        
        $scope.editingAbc = false;
        if ($scope.isNewAbc) {
            $scope.saveNewAbc();
        } else {
            abcConfirm = jModals.open('abcConfirm', $scope);
        }
    };

    $scope.cancelAbcEdit = function () {
        $scope.editingAbc = false;
    };

    $scope.alterArrangement = function () {
        $scope.tune.update({
            updateScore: true
        });
        arrangementConfirm.dismiss();
    };

    $scope.cancelArrangementEdit = function () {
        angular.extend($scope.tune.arrangement, oldArrangementValue);
        oldArrangementValue = null;
        arrangementConfirm.dismiss();
    };

    $scope.saveNewArrangement = function () {
        var newArrangement = angular.extend({}, $scope.tune.arrangement);
        angular.extend($scope.tune.arrangement, oldArrangementValue);
        oldArrangementValue = null;
        $scope.tune.update({
            arrangement: newArrangement,
            useArrangement: true
        });
        arrangementConfirm.dismiss();
    };


    $scope.saveAbcToPerformance = function (newPerformance) {
        if (newPerformance) {
            $scope.tune.update({
                performance: {
                    dummy: true,
                    arrangement: $scope.tune.arrangement._id,
                    instrument: $scope.tune.performance.instrument
                },
                setPublicPerformance: true
            });
        } else {
            $scope.tune.performance.arrangement = $scope.tune.arrangement._id;
            $scope.tune.update();
        }
        
        $scope.abcSavePending = false;
    };

    $scope.revertAbc = function () {
        $scope.tune.resetArrangement();
        $scope.abcSavePending = false;
    };

    $scope.abcSavePending = false;

    $scope.nextAbc = function () {
        var arrangements = $scope.tune.tune.arrangements;
        $scope.tune.nextArrangement();
        // $scope.tune.arrangement = arrangements[(arrangements.indexOf($scope.tune.arrangement) + 1) % arrangements.length];
        $scope.abcSavePending = ($scope.tune.arrangement._id !== $scope.tune.performance.arrangement);
    };
};
},{"angular":"t5daAN","src/common/ui/modals":"Bdfl6Z","src/tune/ui/draw-score":"z4Lk0Z","src/tune/ui/performance-rater":"Mmq9nn"}],"src/tune/controllers/tune-viewer":[function(require,module,exports){
module.exports=require('oogQIt');
},{}],"Wotg+P":[function(require,module,exports){
'use strict';

require('src/common/module');

var angular = require('angular'),
    tuneModule = angular.module('jnr.tune', ['jnr.common']);

module.exports = tuneModule
    .controller('tuneViewer', require('src/tune/controllers/tune-viewer'))
    .controller('addTune', require('src/tune/controllers/add-tune'))
    .filter('tuneStatSummary', require('src/tune/ui/tune-stat-summary'));
},{"angular":"t5daAN","src/common/module":"XxoOEQ","src/tune/controllers/add-tune":"CkNMyn","src/tune/controllers/tune-viewer":"oogQIt","src/tune/ui/tune-stat-summary":"zUpAse"}],"src/tune/module":[function(require,module,exports){
module.exports=require('Wotg+P');
},{}],"c5bVYC":[function(require,module,exports){
var scale = 'cdefgab',
    roots = [
        'C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B', 
        'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
    ], 
    equivalentRoots = {
        'A#': 'Bb',
        'G#': 'Ab',
        'C#': 'Db',
        'D#': 'Eb',
        'Gb': 'F#',
        'Fb': 'E',
        'Cb': 'B',
        'B#': 'C',
        'E#': 'F'
    },
    modes = [
        'maj',
        undefined,
        'dor',
        undefined,
        'phr',
        'lyd',
        undefined,
        'mix',
        undefined,
        'min',
        undefined,
        'loc'
    ],
    majorKeySignatures = {
        Db: -5,
        Ab: -4,
        Eb: -3,
        Bb: -2,
        F: -1,
        C: 0,
        G: 1,
        D: 2,
        A: 3,
        E: 4,
        B: 5,
        'F#': 6
    },

    fullNoteRX = /(?:\=|_|\^)?[a-g](?:,|\')*/gi,
    accidentalsRX = /\=|_|\^/,
    lowNoteRX = /[A-G]/,
    
    extractedNotesCache = {},

    _getHighestOrLowestOfPair = function (note1, note2, highest) {
        
        //Start by identifying the lowest note
        
                    // compare octaves
        var result = note1[1] < note2[1]                                ? note1 :
                    note1[1] > note2[1]                                 ? note2 :
                    //compare position in scale
                    scale.indexOf(note1[0]) < scale.indexOf(note2[0])   ? note1 :
                    scale.indexOf(note1[0]) > scale.indexOf(note2[0])   ? note2 :
                    //compare flatness
                    note1[2] === '_' ? note1 : 
                    note2[2] === '_' ? note2 :
                    //compare naturalness
                    note1[2] === '=' ? note1 :
                    note2[2] === '=' ? note2 :
                    //compare not being sharp
                    !note1[2]        ? note1 :
                    !note2[2]        ? note2 :
                    // if we get here both notes are the same note sharpened in the same octve so doesn't matter which we return 
                                        note1;
        
        // if looking for highest return the one we didn't identify above    
        if (highest === true) {
            result = result === note1 ? note2 : note1;
        }
        return result;
    },

    _extractNotes = function (abc) {

        if (extractedNotesCache[abc]) {
            return extractedNotesCache[abc];
        }

        var notes = [];

        abc.replace(fullNoteRX, function ($0) {
            notes.push(_getNoteCoords($0));                
        });

        return extractedNotesCache[abc] = notes;
    },

    _getHighestOrLowestInAbc = function (abc, highest) {
        var notes = _extractNotes(abc),
            currentExtreme = notes[0];

        for (var n = 1, nl = notes.length; n<nl; n++) {
            currentExtreme = _getHighestOrLowestOfPair(currentExtreme, notes[n], highest);
        }

        return _getNoteFromCoords(currentExtreme);
    },
    
    // _getDuration = function (abcFragment) {
        
    //     var duration = 0;
    // },

    _getDirectionOfTransposition = function (direction, interval) {
        if (direction) {
            return direction > 0 ? 1 : -1;    
        } else {
            return interval < 5 ? 1: -1;
        }
    },

    _getNoteCoords = function (note) {
        var accidental;
        if (accidentalsRX.test(note.charAt(0))) {
            accidental = note.charAt(0);
            note = note.substr(1);
        }
        if (lowNoteRX.test(note.charAt(0))) {
            return [note.charAt(0).toLowerCase(), 1 - note.length, accidental];
        } else {
            return [note.charAt(0), note.length, accidental];
        }
    },

    _getNoteFromCoords = function (note) {
        var noteString;

        if (note[1] < 1) {
            noteString =  note[0].toUpperCase() + Array(1 - note[1]).join(',');
        } else {
            noteString =  note[0] + Array(note[1]).join('\'');
        }

        if (note[2]) {
            noteString = note[2] + noteString;
        }
        return noteString;
    },

    _keepInLimits = function (note, lowerBound, upperBound) {
        
        if (lowerBound) {
            lowerBound = _getNoteCoords(lowerBound);
            if (lowerBound[1] >= note[1]) {
                note[1] = lowerBound[1];
                if (scale.indexOf(note[0]) < scale.indexOf(lowerBound[0])) {
                    note[1]++;
                }
            }
        }

        if (upperBound) {
            upperBound = _getNoteCoords(upperBound);
            if (upperBound[1] <= note[1]) {
                note[1] = upperBound[1];
                if (scale.indexOf(note[0]) > scale.indexOf(upperBound[0])) {
                    note[1]--;
                }
            }
        }

        return note;
    },

    transpose = function (abcDef, opts) {
        var interval = scale.indexOf(opts.newRoot.substr(0, 1).toLowerCase()) - scale.indexOf(abcDef.root.substr(0, 1).toLowerCase()),
            direction = _getDirectionOfTransposition(opts.direction, interval),
            extraOctaves = opts.direction ? ((opts.direction / direction) - 1) : 0;
        
        if (direction < 0) {
            interval = -interval;
        }
        
        if (interval <= 0) {
            interval += 7;  
        }
         
        interval += extraOctaves * 7;
        
        return abcDef.abc.replace(fullNoteRX, function (note) {
            note = _getNoteCoords(note);

            var intervalWithinOctave = (interval * direction) % 7,
                newNoteIndex = scale.indexOf(note[0]) + intervalWithinOctave;

            note[0] = scale[(newNoteIndex + 7) % 7];

            note[1] += direction * Math.floor(interval / 7);

            if (newNoteIndex < 0 || newNoteIndex > 6) {
                note[1] += direction;  
            }

            note = _keepInLimits(note, opts.lowerLimit, opts.upperLimit);
            return _getNoteFromCoords(note);
            
        });

    },

    // getProps = function (abcDef) {

    //     return {
    //         lowest: getLowestNote(abcDef.abc, getSharpsAndFlats(abcDef.root, abcDef.mode)),
    //         highest: getHighestNote(abcDef.abc, getSharpsAndFlats(abcDef.root, abcDef.mode)),
    //         // first
    //         // last
    //         // leadInLength
    //         // leadIn
    //         keySignature: getSharpsAndFlats(abcDef.root, abcDef.mode)
    //     };
    // },

    getSharpsAndFlats = function (root, mode) {

        var equivalentMajorIndex = (roots.length + roots.indexOf(root) - modes.indexOf(mode)) % roots.length,
            equivalentMajor = roots[equivalentMajorIndex];

        equivalentMajor = equivalentRoots[equivalentMajor] || equivalentMajor;

        return majorKeySignatures[equivalentMajor];
    },

    getLowestNote = function (abc) {
        return _getHighestOrLowestInAbc(abc, false);
    },
    
    getHighestNote = function (abc) {
        return _getHighestOrLowestInAbc(abc, true);
    },
    clearExtractedNotes = function () {
        extractedNotesCache = {};
    };

module.exports = {
    transpose: transpose,
    extractNotes: _extractNotes,
    // getProps: getProps,
    getSharpsAndFlats: getSharpsAndFlats,
    getLowestNote: getLowestNote,
    getHighestNote: getHighestNote,
    clearExtractedNotes: clearExtractedNotes
};

},{}],"src/tune/services/abc-parser":[function(require,module,exports){
module.exports=require('c5bVYC');
},{}],"s1LyC9":[function(require,module,exports){
require('angular').module('jnr.tune').service('jScoreSnippets', function () {

    var indexedDB = window.indexedDB || null,
        snippetsDB = {
            open: function() {
                var version = 1;
                var request = indexedDB.open('score-snippets', version);

                request.onsuccess = function(e) {
                    snippetsDB.db = e.target.result;
                    // Do some more stuff in a minute
                };

                // We can only create Object stores in a versionchange transaction.
                request.onupgradeneeded = function(e) {
                    var db = e.target.result;

                    // A versionchange transaction is started automatically.
                    e.target.transaction.onerror = snippetsDB.onerror;

                    if(db.objectStoreNames.contains('snippets')) {
                        db.deleteObjectStore('snippets');
                    }

                    var store = db.createObjectStore('snippets', {keyPath: 'arrangementId'});
                };

                request.onerror = snippetsDB.onerror;
            },

            insert: function(arrangement, score) {
                if (!snippetsDB.inProgress[arrangement._id]) {
                    var db = snippetsDB.db;
                    var trans = db.transaction(['snippets'], 'readwrite');
                    var store = trans.objectStore('snippets');
                    
                    snippetsDB.inProgress[arrangement._id] = true;
                    var request = store.put({
                        arrangementId: arrangement._id,
                        score: score,
                        timestamp: (new Date()).toISOString()
                    });

                    request.onsuccess = function(e) {
                        // Re-render all the todo's
                        delete snippetsDB.inProgress[arrangement._id];
                    };

                    request.onerror = function(e) {
                        console.log(e.value);
                    };
                }
            },

            getById: function(id, success, failure) {
                var db = snippetsDB.db;
                var trans = db.transaction(['snippets'], 'readwrite');
                var store = trans.objectStore('snippets');

                var request = store.get(id);
                request.onerror = failure;
                request.onsuccess = function(event) {
                    var res = event.target.result;
                    if (res) {
                        success(res);
                    } else {
                        failure(res);
                    }

                };
            },

            inProgress: {}
        };

    if (indexedDB) {
        snippetsDB.open();
    }

    return {
        cacheScore: function (arrangement, score) {
            snippetsDB.insert(arrangement, score);
        },
        getCachedScore: function (arrangement, existsCallback, notExistsCallback) {
            snippetsDB.getById(arrangement._id, existsCallback, notExistsCallback);
        }
    };
});
},{"angular":"t5daAN"}],"src/tune/services/score-snippets":[function(require,module,exports){
module.exports=require('s1LyC9');
},{}],"bTNFzr":[function(require,module,exports){
var angular = require('angular'),
    _ = require('lodash');

// require('src/tune/services/abc-parser');

require('angular').module('jnr.tune').factory('jTune', function(
    $routeParams,
    $rootScope,
    jDatabase
) {

    var dayLength = (1000 * 60 * 60 * 24);

    var Tune = function(tune, opts) {
        this.tune = tune;
        this.opts = opts || {};
        this.init();
    };

    Tune.extract = function(tune, opts, instanceOpts) {
        var jTunes = [],
            filter;

        opts = opts || {};
        instanceOpts = instanceOpts || {};

        if (opts.performanceFilter) {
            jTunes = _.filter(tune.performances, opts.performanceFilter).map(function(performance) {
                return new Tune(tune, angular.extend({}, instanceOpts, {
                    performance: performance
                }));
            });
        }

        if (!jTunes.length) {
            jTunes = [new Tune(tune, angular.extend({}, instanceOpts))];
        }


        if (opts.list) {
            Array.prototype.push.apply(opts.list, jTunes);
        }

        return jTunes;

    };

    Tune.create = function(data) {

        if (!(
            data.name &&
            data.abc &&
            data.root &&
            data.meter &&
            data.mode &&
            data.rhythm
        )) {
            return;
        }

        var performance,
            newTune = {
                sessionId: 0,
                name: data.name,
                arrangements: [{
                    abc: data.abc,
                    highestNote: '',
                    lowestNote: '',
                    variants: '',
                    root: data.root,
                    author: data.author || 'wheresrhys',
                }],
                alternativeNames: [],
                meter: data.meter,
                mode: data.mode,
                rhythm: data.rhythm,
                rating: data.rating || -1,
                popularity: data.popularity || -1,
                performances: [],
                notes: data.notes
            };

        if (data.performance.instrument) {
            performance = {
                standard: data.performance.standard || 0,
                notes: '',
                best: data.performance.standard || 0,
                difficulty: data.performance.difficulty || (-1),
                lastPracticed: data.performance.standard ? new Date() : new Date(0),
                special: !! data.performance.special,
                instrument: data.performance.instrument
            };
        }

        jDatabase.getResource('tunes').save(newTune, function(tune) {
            if (performance) {
                performance.arrangement = tune.arrangements[0]._id;
                performance.tune = tune._id;
                tune.performances.push(performance);
                tune.$update();
            }
            jDatabase.getTable('tunes').push(tune);
        });

        return true;
    };
    /* istanbul ignore next */
    Tune.getForArrangement = function(arrangement, instrument) {
        var tunesTable = jDatabase.getTable('tunes');
        var tune = _.findWhere(tunesTable, {
            _id: arrangement.tune
        });

        return new Tune(tune, {
            performance: _.findWhere(tune.performances, {
                arrangement: arrangement._id,
                instrument: instrument
            })
        });
    };

    Tune.prototype = {
        init: function() {
            // if (this.opts.scope) {
            //     // if (typeof this.opts.scope === 'boolean') {
            //     //     $scope.tune = this;
            //     //     this.$scope = $scope;
            //     // } else {
            //     this.scope = this.opts.scope;
            //     this.scope.tune = this;
            //     // }  
            // }

            this._assignArrAndPerf();
            this._setLastPracticedDays();
            this.opts.modifier && this.opts.modifier(this);
        },
        _assignArrAndPerf: function() {
            var that = this,
                defaultArrangement = this.tune.arrangements[0];
            if (this.opts.performance) {
                this.performance = this.opts.performance;
                this.arrangement = _.find(this.tune.arrangements, function(arrangement) {
                    return arrangement._id === that.performance.arrangement;
                });
            } else {
                this.performance = {
                    dummy: true
                };
                this.arrangement = defaultArrangement;
            }

            this.updateScore();
        },

        updateScore: function() {
            this.scoreGenerator = {
                arrangement: this.arrangement,
                meter: this.tune.meter,
                mode: this.tune.mode
            };
        },

        _setLastPracticedDays: function() {
            var milliseconds = ((new Date()) - (new Date(this.performance.lastPracticed || 0)));
            this.daysSinceLastPractice = +Math.round((milliseconds / dayLength), 0);
        },

        _performanceNeedsSaving: function(performance) {
            if (this.dummyStandard > -1) {
                return true;
            }
            for (var key in performance) {
                if (['instrument', 'dummy'].indexOf(key) === -1 && performance.hasOwnProperty(key)) {
                    return true;
                }
            }
            return false;
        },
        _performanceIsReal: function(performance) {
            return !performance.dummy;
        },

        _createPerformance: function(performance) {
            performance = performance || {};
            return {
                tune: this.tune._id,
                instrument: (performance && performance.instrument) || $rootScope.pageState.instrument,
                special: performance.special || false,
                lastPracticed: new Date(0),
                difficulty: performance.difficulty || -1,
                best: 0,
                notes: '',
                standard: 0,
                arrangement: this.arrangement._id
            };
        },

        _updatePerformance: function(opts) {

            var practiced = false,
                performance = opts.performance || this.performance;
            if (this._performanceNeedsSaving(performance)) {

                if (!this._performanceIsReal(performance)) {
                    performance = this._createPerformance(performance);
                    this.tune.performances.push(performance);
                }

                if (this.dummyStandard > -1) {
                    if (this.dummyStandard > 2) {
                        performance.special = false;
                    }
                    performance.standard = this.dummyStandard;
                    this.dummyStandard = -1;
                    performance.lastPracticed = new Date();
                    this._setLastPracticedDays();
                    $rootScope.$broadcast('tunePracticed', this);
                    practiced = true;

                }
                performance.best = Math.max(performance.best, performance.standard);

                if (opts.setPublicPerformance) {
                    this.performance = performance;
                }

            }
            return practiced;
        },
        isNew: function() {
            return this.tune.rating < 0; // || tune.popularity < 0;
        },
        resetArrangement: function() {
            var testId = this.performance.arrangement;
            this.arrangement = _.find(this.tune.arrangements, function(arrangement) {
                return arrangement._id === testId;
            });
            this.arrangementChangePending = false;
            this.updateScore();
        },

        nextArrangement: function() {
            this.arrangement = this.tune.arrangements[(this.tune.arrangements.indexOf(this.arrangement) + 1) % this.tune.arrangements.length];
            this.arrangementChangePending = (this.arrangement._id !== this.performance.arrangement);
            this.updateScore();
        },

        update: function(opts) {
            opts = opts || {};

            var that = this,
                oldProps = opts.oldProps || {},
                practiced = this._updatePerformance(opts);

            if (oldProps && oldProps.rating === -1 && !this.isNew()) {
                $rootScope.newTuneCount--;
            }

            if (opts.arrangement) {
                this.tune.arrangements.push(opts.arrangement);
                if (opts.arrangement._id) {
                    delete opts.arrangement._id;
                }
                opts.arrangement.tune = this.tune._id;
                this._sync(function(savedTune) {
                    if (opts.useArrangement) {
                        that.updateScore();
                        that.arrangement = savedTune.arrangements[savedTune.arrangements.length - 1];
                        that.performance.arrangement = that.arrangement._id;
                        that._sync();
                    }
                });
                this.arrangementChangePending = false;

            } else {
                this._sync();
            }

            if (opts.arrangement || opts.updateScore) {
                this.updateScore();
            }

            return {
                practiced: practiced
            };
        },

        _sync: function(callback) {
            var that = this,
                performanceIndex = this.tune.performances.indexOf(this.performance),
                arrangementIndex = this.tune.arrangements.indexOf(this.arrangement);

            this.tune.$update(function(savedTune) {
                that.performance = that.tune.performances[performanceIndex];
                that.arrangement = that.tune.arrangements[arrangementIndex];
                callback && callback(savedTune);
            });
        }

    };

    return Tune;

});
},{"angular":"t5daAN","lodash":"aBLxx7"}],"src/tune/services/tune-model":[function(require,module,exports){
module.exports=require('bTNFzr');
},{}],"z4Lk0Z":[function(require,module,exports){
'use strict';

require('src/tune/services/score-snippets');

var ABCJS = require('abcjs'),
    snippetsStore;

var ScoreDrawer = function (scoreGenerator, snippetOnly, el) {
    this.el = el;
    this.scoreGenerator = scoreGenerator;
    this.snippetOnly = snippetOnly;
    this.exec();
};

ScoreDrawer.prototype = {
    exec: function () {
        
        this.el.html('');


        this.arrangement = this.scoreGenerator.arrangement;

        if (!this.arrangement) {
            return;
        }

        this.abc = this.arrangement.abc;
        this.conf = {
            scale: 0.6,
            paddingtop: 0,
            paddingbottom: 0,
            paddingright: 0,
            paddingleft: 0
        };

        

        if (this.snippetOnly) {
            this.getSnippet();
        } else {
            this.renderScore();
        } 
    },

    getSnippet: function () {
        var self = this;

        this.el.addClass('score-snippet');

        snippetsStore.getCachedScore(this.arrangement, function (obj) {
            self.el.html(obj.score);
            self.el[0].style.width = self.el.find('svg')[0].getAttribute('width') + 'px';
        }, function () {
            self.abc = self.abc.replace(/^\|*:?/, '');
            self.abc = self.abc.split('|');
            self.abc = self.abc.slice(0, (self.abc[0].length < 4 ? 4 : 3)).join('|');
            self.conf.scale = 0.5;
            self.conf.staffwidth = 450;
            self.renderScore();
        });
    },

    renderScore: function () {
        var self = this;
        this.abc = 'X:1' +
        //'\nT:' + scoreGenerator.name + 
        '\nM:' + this.scoreGenerator.meter + 
        '\nL:1/8' + 
        //'\nR:' + scoreGenerator.rhythm + 
        '\nK:' + this.arrangement.root + this.scoreGenerator.mode + 
        '\n' + this.abc;

        setTimeout(function () {
            ABCJS.renderAbc(self.el[0], self.abc, {}, self.conf, {});  

            if (self.snippetOnly) {
                snippetsStore.cacheScore(self.arrangement, self.el[0].innerHTML);
            }  
        }, 100);        
    }

};

require('angular').module('jnr.tune').directive('jDrawScore', function (jScoreSnippets) {
    snippetsStore = jScoreSnippets;

    return {
        link: function(scope, el, attrs) {
            
            var snippetOnly = !!attrs.snippet;

            attrs.$observe('tune', function(value) {
                if (value) {
                    new ScoreDrawer(JSON.parse(value), snippetOnly, el);
                }
            });
        }
    };
});

},{"abcjs":"n1ID3u","angular":"t5daAN","src/tune/services/score-snippets":"s1LyC9"}],"src/tune/ui/draw-score":[function(require,module,exports){
module.exports=require('z4Lk0Z');
},{}],"Mmq9nn":[function(require,module,exports){
'use strict';
require('angular').module('jnr.tune').directive('jPerformanceRater', function () {
    var colourings = 'default,danger,warning,success,info,primary'.split(',');
    return {
    // transclude: true,
        scope: true,
        templateUrl: '/src/tune/tpl/performance-rater.html',
        link: function (scope, element, attrs) {
            var ratee;
            try {
                ratee = JSON.parse(attrs.ratee);
            } catch (e) {
                ratee = scope[attrs.ratee || 'tune'];
            }
            
            scope.ratee = ratee;
            scope.colourings = colourings;
            scope.updatePerformance = function (rating) {
                ratee.dummyStandard = rating;
                attrs.callback ? scope[attrs.callback]() : ratee.update();
            };

            element.addClass('performance-rater');
        }
    };
});

},{"angular":"t5daAN"}],"src/tune/ui/performance-rater":[function(require,module,exports){
module.exports=require('Mmq9nn');
},{}],"m/R8wK":[function(require,module,exports){
require('src/tune/ui/tune-stat-summary');

require('angular').module('jnr.tune').directive('jTuneHeading', function () {
    return {
    // transclude: true,
        scope: true,
        templateUrl: '/src/tune/tpl/tune-heading.html',
        compile: function(element, attrs) {
            return function (scope, element, attrs) {
                var tune = scope[attrs.tune || 'tune'];
                
                scope.tune = tune.tune;
                scope.arrangement = tune.arrangement;
                if (attrs.stats) {
                    scope.stats = true;
                }
                element.addClass('tune-heading');
            };
        }
    };
});

},{"angular":"t5daAN","src/tune/ui/tune-stat-summary":"zUpAse"}],"src/tune/ui/tune-heading":[function(require,module,exports){
module.exports=require('m/R8wK');
},{}],"zUpAse":[function(require,module,exports){
'use strict';

require('src/common/data/dropdowns');

 

module.exports = function (jDropdowns) {
    return function(input) {
        var message = '';

        if (input.rating !== -1 || input.popularity !== -1) {
            message += 'A ';
            if (input.rating !== -1) {
                message += jDropdowns.rating[input.rating - 1].label.toLowerCase() + ' ';
            }
            if (input.popularity !== -1) {
                message += jDropdowns.popularity[input.popularity].label.toLowerCase() + ' ';
            }
            message += 'tune';
        }
        return message;
    };
};

},{"src/common/data/dropdowns":"PDNe9n"}],"src/tune/ui/tune-stat-summary":[function(require,module,exports){
module.exports=require('zUpAse');
},{}]},{},["nbHEfk"])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL2Jvd2VyX2NvbXBvbmVudHMvYWJjanMvaW5kZXguanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci1hbmltYXRlL2FuZ3VsYXItYW5pbWF0ZS5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWJvb3RzdHJhcC91aS1ib290c3RyYXAtdHBscy5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLWNvb2tpZXMvYW5ndWxhci1jb29raWVzLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXItcmVzb3VyY2UvYW5ndWxhci1yZXNvdXJjZS5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyLXJvdXRlL2FuZ3VsYXItcm91dGUuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci9hbmd1bGFyLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9ib3dlcl9jb21wb25lbnRzL2xpcXVpZE1ldGFsL2xpcXVpZG1ldGFsLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9ib3dlcl9jb21wb25lbnRzL2xvZGFzaC9kaXN0L2xvZGFzaC5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy9hcHAuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvY29tbW9uL2NvbnRyb2xsZXJzL3RvcC1uYXYuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvY29tbW9uL2RhdGEvZGF0YWJhc2UuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvY29tbW9uL2RhdGEvZHJvcGRvd25zLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL2NvbW1vbi9tb2R1bGUuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvY29tbW9uL3NlcnZpY2VzL3BhZ2Utc3RhdGUuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvY29tbW9uL3NlcnZpY2VzL3JlYWQtY29va2llLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL2NvbW1vbi91aS9jYXBpdGFsaXNlLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL2NvbW1vbi91aS9tb2RhbHMuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvY29tbW9uL3VpL3NlbGVjdC1vbi1jbGljay5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy9jb250cm9sbGVycy5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy9tYWluLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3JvdXRlcy5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy9zZXQtYnVpbGRlci9zZXQtYnVpbGRlcl9jb250cm9sbGVyLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3NldC1saXN0cy9jb250cm9sbGVycy9saXN0LXNldHMuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvc2V0LWxpc3RzL21vZHVsZS5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy9zZXQvbW9kdWxlLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3NldC9zZXJ2aWNlcy9zZXQtbW9kZWwuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvdHVuZS1saXN0cy9jb250cm9sbGVycy9saXN0LXR1bmVzLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3R1bmUtbGlzdHMvY29udHJvbGxlcnMvbmV3LXR1bmVzLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3R1bmUtbGlzdHMvbW9kdWxlLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3R1bmUtbGlzdHMvc2VydmljZXMvdHVuZS1saXN0LmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3R1bmUvY29udHJvbGxlcnMvYWRkLXR1bmUuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvdHVuZS9jb250cm9sbGVycy90dW5lLXZpZXdlci5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy90dW5lL21vZHVsZS5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy90dW5lL3NlcnZpY2VzL2FiYy1wYXJzZXIuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvdHVuZS9zZXJ2aWNlcy9zY29yZS1zbmlwcGV0cy5qcyIsIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvcHVibGljL3NyYy90dW5lL3NlcnZpY2VzL3R1bmUtbW9kZWwuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvdHVuZS91aS9kcmF3LXNjb3JlLmpzIiwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9wdWJsaWMvc3JjL3R1bmUvdWkvcGVyZm9ybWFuY2UtcmF0ZXIuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvdHVuZS91aS90dW5lLWhlYWRpbmcuanMiLCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL3B1YmxpYy9zcmMvdHVuZS91aS90dW5lLXN0YXQtc3VtbWFyeS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3AyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3A1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL2pvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0b05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbD10eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge307KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuKGZ1bmN0aW9uKGkpe3ZhciBlPVwiMC4zLjRcIixqPVwiaGFzT3duUHJvcGVydHlcIixiPS9bXFwuXFwvXS8sYT1cIipcIixnPWZ1bmN0aW9uKCl7fSxmPWZ1bmN0aW9uKG0sbCl7cmV0dXJuIG0tbH0sZCxoLGs9e246e319LGM9ZnVuY3Rpb24obSxDKXt2YXIgdj1rLHM9aCx3PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKSx5PWMubGlzdGVuZXJzKG0pLHg9MCx1PWZhbHNlLHAsbz1bXSx0PXt9LHE9W10sbj1kLEE9W107ZD1tO2g9MDtmb3IodmFyIHI9MCxCPXkubGVuZ3RoO3I8QjtyKyspe2lmKFwiekluZGV4XCIgaW4geVtyXSl7by5wdXNoKHlbcl0uekluZGV4KTtpZih5W3JdLnpJbmRleDwwKXt0W3lbcl0uekluZGV4XT15W3JdfX19by5zb3J0KGYpO3doaWxlKG9beF08MCl7cD10W29beCsrXV07cS5wdXNoKHAuYXBwbHkoQyx3KSk7aWYoaCl7aD1zO3JldHVybiBxfX1mb3Iocj0wO3I8QjtyKyspe3A9eVtyXTtpZihcInpJbmRleFwiIGluIHApe2lmKHAuekluZGV4PT1vW3hdKXtxLnB1c2gocC5hcHBseShDLHcpKTtpZihoKXticmVha31kb3t4Kys7cD10W29beF1dO3AmJnEucHVzaChwLmFwcGx5KEMsdykpO2lmKGgpe2JyZWFrfX13aGlsZShwKX1lbHNle3RbcC56SW5kZXhdPXB9fWVsc2V7cS5wdXNoKHAuYXBwbHkoQyx3KSk7aWYoaCl7YnJlYWt9fX1oPXM7ZD1uO3JldHVybiBxLmxlbmd0aD9xOm51bGx9O2MubGlzdGVuZXJzPWZ1bmN0aW9uKGwpe3ZhciB0PWwuc3BsaXQoYikscj1rLHgscyxtLHAsdyxvLHEsdSx2PVtyXSxuPVtdO2ZvcihwPTAsdz10Lmxlbmd0aDtwPHc7cCsrKXt1PVtdO2ZvcihvPTAscT12Lmxlbmd0aDtvPHE7bysrKXtyPXZbb10ubjtzPVtyW3RbcF1dLHJbYV1dO209Mjt3aGlsZShtLS0pe3g9c1ttXTtpZih4KXt1LnB1c2goeCk7bj1uLmNvbmNhdCh4LmZ8fFtdKX19fXY9dX1yZXR1cm4gbn07Yy5vbj1mdW5jdGlvbihsLG8pe3ZhciBxPWwuc3BsaXQoYikscD1rO2Zvcih2YXIgbT0wLG49cS5sZW5ndGg7bTxuO20rKyl7cD1wLm47IXBbcVttXV0mJihwW3FbbV1dPXtuOnt9fSk7cD1wW3FbbV1dfXAuZj1wLmZ8fFtdO2ZvcihtPTAsbj1wLmYubGVuZ3RoO208bjttKyspe2lmKHAuZlttXT09byl7cmV0dXJuIGd9fXAuZi5wdXNoKG8pO3JldHVybiBmdW5jdGlvbihyKXtpZigrcj09K3Ipe28uekluZGV4PStyfX19O2Muc3RvcD1mdW5jdGlvbigpe2g9MX07Yy5udD1mdW5jdGlvbihsKXtpZihsKXtyZXR1cm4gbmV3IFJlZ0V4cChcIig/OlxcXFwufFxcXFwvfF4pXCIrbCtcIig/OlxcXFwufFxcXFwvfCQpXCIpLnRlc3QoZCl9cmV0dXJuIGR9O2Mub2ZmPWMudW5iaW5kPWZ1bmN0aW9uKG0scil7dmFyIHQ9bS5zcGxpdChiKSxzLHYsbixwLHcsbyxxLHU9W2tdO2ZvcihwPTAsdz10Lmxlbmd0aDtwPHc7cCsrKXtmb3Iobz0wO288dS5sZW5ndGg7bys9bi5sZW5ndGgtMil7bj1bbywxXTtzPXVbb10ubjtpZih0W3BdIT1hKXtpZihzW3RbcF1dKXtuLnB1c2goc1t0W3BdXSl9fWVsc2V7Zm9yKHYgaW4gcyl7aWYoc1tqXSh2KSl7bi5wdXNoKHNbdl0pfX19dS5zcGxpY2UuYXBwbHkodSxuKX19Zm9yKHA9MCx3PXUubGVuZ3RoO3A8dztwKyspe3M9dVtwXTt3aGlsZShzLm4pe2lmKHIpe2lmKHMuZil7Zm9yKG89MCxxPXMuZi5sZW5ndGg7bzxxO28rKyl7aWYocy5mW29dPT1yKXtzLmYuc3BsaWNlKG8sMSk7YnJlYWt9fSFzLmYubGVuZ3RoJiZkZWxldGUgcy5mfWZvcih2IGluIHMubil7aWYocy5uW2pdKHYpJiZzLm5bdl0uZil7dmFyIGw9cy5uW3ZdLmY7Zm9yKG89MCxxPWwubGVuZ3RoO288cTtvKyspe2lmKGxbb109PXIpe2wuc3BsaWNlKG8sMSk7YnJlYWt9fSFsLmxlbmd0aCYmZGVsZXRlIHMublt2XS5mfX19ZWxzZXtkZWxldGUgcy5mO2Zvcih2IGluIHMubil7aWYocy5uW2pdKHYpJiZzLm5bdl0uZil7ZGVsZXRlIHMublt2XS5mfX19cz1zLm59fX07Yy5vbmNlPWZ1bmN0aW9uKGwsbSl7dmFyIG49ZnVuY3Rpb24oKXt2YXIgbz1tLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtjLnVuYmluZChsLG4pO3JldHVybiBvfTtyZXR1cm4gYy5vbihsLG4pfTtjLnZlcnNpb249ZTtjLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJZb3UgYXJlIHJ1bm5pbmcgRXZlIFwiK2V9Oyh0eXBlb2YgbW9kdWxlIT1cInVuZGVmaW5lZFwiJiZtb2R1bGUuZXhwb3J0cyk/KG1vZHVsZS5leHBvcnRzPWMpOih0eXBlb2YgZGVmaW5lIT1cInVuZGVmaW5lZFwiPyhkZWZpbmUoXCJldmVcIixbXSxmdW5jdGlvbigpe3JldHVybiBjfSkpOihpLmV2ZT1jKSl9KSh0aGlzKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBhUihnKXtpZihhUi5pcyhnLFwiZnVuY3Rpb25cIikpe3JldHVybiBhbz9nKCk6ZXZlLm9uKFwicmFwaGFlbC5ET01sb2FkXCIsZyl9ZWxzZXtpZihhUi5pcyhnLGJkKSl7cmV0dXJuIGFSLl9lbmdpbmUuY3JlYXRlW2JHXShhUixnLnNwbGljZSgwLDMrYVIuaXMoZ1swXSxhTCkpKS5hZGQoZyl9ZWxzZXt2YXIgYj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7aWYoYVIuaXMoYltiLmxlbmd0aC0xXSxcImZ1bmN0aW9uXCIpKXt2YXIgZD1iLnBvcCgpO3JldHVybiBhbz9kLmNhbGwoYVIuX2VuZ2luZS5jcmVhdGVbYkddKGFSLGIpKTpldmUub24oXCJyYXBoYWVsLkRPTWxvYWRcIixmdW5jdGlvbigpe2QuY2FsbChhUi5fZW5naW5lLmNyZWF0ZVtiR10oYVIsYikpfSl9ZWxzZXtyZXR1cm4gYVIuX2VuZ2luZS5jcmVhdGVbYkddKGFSLGFyZ3VtZW50cyl9fX19YVIudmVyc2lvbj1cIjIuMS4wXCI7YVIuZXZlPWV2ZTt2YXIgYW8sYT0vWywgXSsvLGJ3PXtjaXJjbGU6MSxyZWN0OjEscGF0aDoxLGVsbGlwc2U6MSx0ZXh0OjEsaW1hZ2U6MX0sYnI9L1xceyhcXGQrKVxcfS9nLGJKPVwicHJvdG90eXBlXCIsYWs9XCJoYXNPd25Qcm9wZXJ0eVwiLGFBPXtkb2M6ZG9jdW1lbnQsd2luOndpbmRvd30scz17d2FzOk9iamVjdC5wcm90b3R5cGVbYWtdLmNhbGwoYUEud2luLFwiUmFwaGFlbFwiKSxpczphQS53aW4uUmFwaGFlbH0sYkY9ZnVuY3Rpb24oKXt0aGlzLmNhPXRoaXMuY3VzdG9tQXR0cmlidXRlcz17fX0sYTQsYm89XCJhcHBlbmRDaGlsZFwiLGJHPVwiYXBwbHlcIixiRT1cImNvbmNhdFwiLFo9XCJjcmVhdGVUb3VjaFwiIGluIGFBLmRvYyxhWD1cIlwiLGFRPVwiIFwiLGJIPVN0cmluZyxGPVwic3BsaXRcIixRPVwiY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNlbW92ZSBtb3VzZW91dCBtb3VzZW92ZXIgbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiW0ZdKGFRKSxieD17bW91c2Vkb3duOlwidG91Y2hzdGFydFwiLG1vdXNlbW92ZTpcInRvdWNobW92ZVwiLG1vdXNldXA6XCJ0b3VjaGVuZFwifSxiSz1iSC5wcm90b3R5cGUudG9Mb3dlckNhc2UsYXU9TWF0aCxtPWF1Lm1heCxibT1hdS5taW4sYXc9YXUuYWJzLGJwPWF1LnBvdyxhVj1hdS5QSSxhTD1cIm51bWJlclwiLGFqPVwic3RyaW5nXCIsYmQ9XCJhcnJheVwiLGE1PVwidG9TdHJpbmdcIixhOT1cImZpbGxcIixhMT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLGJ6PXt9LGo9XCJwdXNoXCIsZj1hUi5fSVNVUkw9L151cmxcXChbJ1wiXT8oW15cXCldKz8pWydcIl0/XFwpJC9pLEE9L15cXHMqKCgjW2EtZlxcZF17Nn0pfCgjW2EtZlxcZF17M30pfHJnYmE/XFwoXFxzKihbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyU/XFxzKixcXHMqW1xcZFxcLl0rJT8oPzpcXHMqLFxccypbXFxkXFwuXSslPyk/KVxccypcXCl8aHNiYT9cXChcXHMqKFtcXGRcXC5dKyg/OmRlZ3xcXHhiMHwlKT9cXHMqLFxccypbXFxkXFwuXSslP1xccyosXFxzKltcXGRcXC5dKyg/OiU/XFxzKixcXHMqW1xcZFxcLl0rKT8pJT9cXHMqXFwpfGhzbGE/XFwoXFxzKihbXFxkXFwuXSsoPzpkZWd8XFx4YjB8JSk/XFxzKixcXHMqW1xcZFxcLl0rJT9cXHMqLFxccypbXFxkXFwuXSsoPzolP1xccyosXFxzKltcXGRcXC5dKyk/KSU/XFxzKlxcKSlcXHMqJC9pLGF2PXtcIk5hTlwiOjEsXCJJbmZpbml0eVwiOjEsXCItSW5maW5pdHlcIjoxfSxjPS9eKD86Y3ViaWMtKT9iZXppZXJcXCgoW14sXSspLChbXixdKyksKFteLF0rKSwoW15cXCldKylcXCkvLGFoPWF1LnJvdW5kLHo9XCJzZXRBdHRyaWJ1dGVcIixhbj1wYXJzZUZsb2F0LFU9cGFyc2VJbnQsYnQ9YkgucHJvdG90eXBlLnRvVXBwZXJDYXNlLHI9YVIuX2F2YWlsYWJsZUF0dHJzPXtcImFycm93LWVuZFwiOlwibm9uZVwiLFwiYXJyb3ctc3RhcnRcIjpcIm5vbmVcIixibHVyOjAsXCJjbGlwLXJlY3RcIjpcIjAgMCAxZTkgMWU5XCIsY3Vyc29yOlwiZGVmYXVsdFwiLGN4OjAsY3k6MCxmaWxsOlwiI2ZmZlwiLFwiZmlsbC1vcGFjaXR5XCI6MSxmb250OicxMHB4IFwiQXJpYWxcIicsXCJmb250LWZhbWlseVwiOidcIkFyaWFsXCInLFwiZm9udC1zaXplXCI6XCIxMFwiLFwiZm9udC1zdHlsZVwiOlwibm9ybWFsXCIsXCJmb250LXdlaWdodFwiOjQwMCxncmFkaWVudDowLGhlaWdodDowLGhyZWY6XCJodHRwOi8vcmFwaGFlbGpzLmNvbS9cIixcImxldHRlci1zcGFjaW5nXCI6MCxvcGFjaXR5OjEscGF0aDpcIk0wLDBcIixyOjAscng6MCxyeTowLHNyYzpcIlwiLHN0cm9rZTpcIiMwMDBcIixcInN0cm9rZS1kYXNoYXJyYXlcIjpcIlwiLFwic3Ryb2tlLWxpbmVjYXBcIjpcImJ1dHRcIixcInN0cm9rZS1saW5lam9pblwiOlwiYnV0dFwiLFwic3Ryb2tlLW1pdGVybGltaXRcIjowLFwic3Ryb2tlLW9wYWNpdHlcIjoxLFwic3Ryb2tlLXdpZHRoXCI6MSx0YXJnZXQ6XCJfYmxhbmtcIixcInRleHQtYW5jaG9yXCI6XCJtaWRkbGVcIix0aXRsZTpcIlJhcGhhZWxcIix0cmFuc2Zvcm06XCJcIix3aWR0aDowLHg6MCx5OjB9LGFyPWFSLl9hdmFpbGFibGVBbmltQXR0cnM9e2JsdXI6YUwsXCJjbGlwLXJlY3RcIjpcImNzdlwiLGN4OmFMLGN5OmFMLGZpbGw6XCJjb2xvdXJcIixcImZpbGwtb3BhY2l0eVwiOmFMLFwiZm9udC1zaXplXCI6YUwsaGVpZ2h0OmFMLG9wYWNpdHk6YUwscGF0aDpcInBhdGhcIixyOmFMLHJ4OmFMLHJ5OmFMLHN0cm9rZTpcImNvbG91clwiLFwic3Ryb2tlLW9wYWNpdHlcIjphTCxcInN0cm9rZS13aWR0aFwiOmFMLHRyYW5zZm9ybTpcInRyYW5zZm9ybVwiLHdpZHRoOmFMLHg6YUwseTphTH0sYWM9L1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0vZyxiaT0vW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSosW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSovLG49e2hzOjEscmc6MX0sYmc9Lyw/KFthY2hsbXFyc3R2eHpdKSw/L2dpLGEwPS8oW2FjaGxtcnFzdHZ6XSlbXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjksXSooKC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT9bXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldKiw/W1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSopKykvaWcsYWk9LyhbcnN0bV0pW1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5LF0qKCgtP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/W1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSosP1tcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qKSspL2lnLGFQPS8oLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjldKiw/W1xceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgyMFxceGEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdTIwMjhcXHUyMDI5XSovaWcsYVc9YVIuX3JhZGlhbF9ncmFkaWVudD0vXnIoPzpcXCgoW14sXSs/KVtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qLFtcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOV0qKFteXFwpXSs/KVxcKSk/LyxhVT17fSxicT1mdW5jdGlvbihnLGQpe3JldHVybiBnLmtleS1kLmtleX0sdT1mdW5jdGlvbihnLGQpe3JldHVybiBhbihnKS1hbihkKX0sST1mdW5jdGlvbigpe30sYkI9ZnVuY3Rpb24oYil7cmV0dXJuIGJcbn0sYXo9YVIuX3JlY3RQYXRoPWZ1bmN0aW9uKGIsRSxkLGcsaSl7aWYoaSl7cmV0dXJuW1tcIk1cIixiK2ksRV0sW1wibFwiLGQtaSoyLDBdLFtcImFcIixpLGksMCwwLDEsaSxpXSxbXCJsXCIsMCxnLWkqMl0sW1wiYVwiLGksaSwwLDAsMSwtaSxpXSxbXCJsXCIsaSoyLWQsMF0sW1wiYVwiLGksaSwwLDAsMSwtaSwtaV0sW1wibFwiLDAsaSoyLWddLFtcImFcIixpLGksMCwwLDEsaSwtaV0sW1wielwiXV19cmV0dXJuW1tcIk1cIixiLEVdLFtcImxcIixkLDBdLFtcImxcIiwwLGddLFtcImxcIiwtZCwwXSxbXCJ6XCJdXX0sSz1mdW5jdGlvbihiLGksZyxkKXtpZihkPT1udWxsKXtkPWd9cmV0dXJuW1tcIk1cIixiLGldLFtcIm1cIiwwLC1kXSxbXCJhXCIsZyxkLDAsMSwxLDAsMipkXSxbXCJhXCIsZyxkLDAsMSwxLDAsLTIqZF0sW1wielwiXV19LE49YVIuX2dldFBhdGg9e3BhdGg6ZnVuY3Rpb24oYil7cmV0dXJuIGIuYXR0cihcInBhdGhcIil9LGNpcmNsZTpmdW5jdGlvbihkKXt2YXIgYj1kLmF0dHJzO3JldHVybiBLKGIuY3gsYi5jeSxiLnIpfSxlbGxpcHNlOmZ1bmN0aW9uKGQpe3ZhciBiPWQuYXR0cnM7cmV0dXJuIEsoYi5jeCxiLmN5LGIucngsYi5yeSl9LHJlY3Q6ZnVuY3Rpb24oZCl7dmFyIGI9ZC5hdHRycztyZXR1cm4gYXooYi54LGIueSxiLndpZHRoLGIuaGVpZ2h0LGIucil9LGltYWdlOmZ1bmN0aW9uKGQpe3ZhciBiPWQuYXR0cnM7cmV0dXJuIGF6KGIueCxiLnksYi53aWR0aCxiLmhlaWdodCl9LHRleHQ6ZnVuY3Rpb24oYil7dmFyIGQ9Yi5fZ2V0QkJveCgpO3JldHVybiBheihkLngsZC55LGQud2lkdGgsZC5oZWlnaHQpfX0sTD1hUi5tYXBQYXRoPWZ1bmN0aW9uKGJOLFMpe2lmKCFTKXtyZXR1cm4gYk59dmFyIGJMLFIsZyxiLGJNLEUsZDtiTj1XKGJOKTtmb3IoZz0wLGJNPWJOLmxlbmd0aDtnPGJNO2crKyl7ZD1iTltnXTtmb3IoYj0xLEU9ZC5sZW5ndGg7YjxFO2IrPTIpe2JMPVMueChkW2JdLGRbYisxXSk7Uj1TLnkoZFtiXSxkW2IrMV0pO2RbYl09Ykw7ZFtiKzFdPVJ9fXJldHVybiBiTn07YVIuX2c9YUE7YVIudHlwZT0oYUEud2luLlNWR0FuZ2xlfHxhQS5kb2MuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIixcIjEuMVwiKT9cIlNWR1wiOlwiVk1MXCIpO2lmKGFSLnR5cGU9PVwiVk1MXCIpe3ZhciBhRT1hQS5kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhSDthRS5pbm5lckhUTUw9Jzx2OnNoYXBlIGFkaj1cIjFcIi8+JzthSD1hRS5maXJzdENoaWxkO2FILnN0eWxlLmJlaGF2aW9yPVwidXJsKCNkZWZhdWx0I1ZNTClcIjtpZighKGFIJiZ0eXBlb2YgYUguYWRqPT1cIm9iamVjdFwiKSl7cmV0dXJuKGFSLnR5cGU9YVgpfWFFPW51bGx9YVIuc3ZnPSEoYVIudm1sPWFSLnR5cGU9PVwiVk1MXCIpO2FSLl9QYXBlcj1iRjthUi5mbj1hND1iRi5wcm90b3R5cGU9YVIucHJvdG90eXBlO2FSLl9pZD0wO2FSLl9vaWQ9MDthUi5pcz1mdW5jdGlvbihkLGIpe2I9YksuY2FsbChiKTtpZihiPT1cImZpbml0ZVwiKXtyZXR1cm4gIWF2W2FrXSgrZCl9aWYoYj09XCJhcnJheVwiKXtyZXR1cm4gZCBpbnN0YW5jZW9mIEFycmF5fXJldHVybihiPT1cIm51bGxcIiYmZD09PW51bGwpfHwoYj09dHlwZW9mIGQmJmQhPT1udWxsKXx8KGI9PVwib2JqZWN0XCImJmQ9PT1PYmplY3QoZCkpfHwoYj09XCJhcnJheVwiJiZBcnJheS5pc0FycmF5JiZBcnJheS5pc0FycmF5KGQpKXx8YTEuY2FsbChkKS5zbGljZSg4LC0xKS50b0xvd2VyQ2FzZSgpPT1ifTtmdW5jdGlvbiBYKGcpe2lmKE9iamVjdChnKSE9PWcpe3JldHVybiBnfXZhciBkPW5ldyBnLmNvbnN0cnVjdG9yO2Zvcih2YXIgYiBpbiBnKXtpZihnW2FrXShiKSl7ZFtiXT1YKGdbYl0pfX1yZXR1cm4gZH1hUi5hbmdsZT1mdW5jdGlvbihFLFMsZyxSLGQsaSl7aWYoZD09bnVsbCl7dmFyIGI9RS1nLGJMPVMtUjtpZighYiYmIWJMKXtyZXR1cm4gMH1yZXR1cm4oMTgwK2F1LmF0YW4yKC1iTCwtYikqMTgwL2FWKzM2MCklMzYwfWVsc2V7cmV0dXJuIGFSLmFuZ2xlKEUsUyxkLGkpLWFSLmFuZ2xlKGcsUixkLGkpfX07YVIucmFkPWZ1bmN0aW9uKGIpe3JldHVybiBiJTM2MCphVi8xODB9O2FSLmRlZz1mdW5jdGlvbihiKXtyZXR1cm4gYioxODAvYVYlMzYwfTthUi5zbmFwVG89ZnVuY3Rpb24oZCxFLGIpe2I9YVIuaXMoYixcImZpbml0ZVwiKT9iOjEwO2lmKGFSLmlzKGQsYmQpKXt2YXIgZz1kLmxlbmd0aDt3aGlsZShnLS0pe2lmKGF3KGRbZ10tRSk8PWIpe3JldHVybiBkW2ddfX19ZWxzZXtkPStkO3ZhciBSPUUlZDtpZihSPGIpe3JldHVybiBFLVJ9aWYoUj5kLWIpe3JldHVybiBFLVIrZH19cmV0dXJuIEV9O3ZhciBoPWFSLmNyZWF0ZVVVSUQ9KGZ1bmN0aW9uKGIsZCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuXCJ4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHhcIi5yZXBsYWNlKGIsZCkudG9VcHBlckNhc2UoKX19KSgvW3h5XS9nLGZ1bmN0aW9uKGcpe3ZhciBkPWF1LnJhbmRvbSgpKjE2fDAsYj1nPT1cInhcIj9kOihkJjN8OCk7cmV0dXJuIGIudG9TdHJpbmcoMTYpfSk7YVIuc2V0V2luZG93PWZ1bmN0aW9uKGIpe2V2ZShcInJhcGhhZWwuc2V0V2luZG93XCIsYVIsYUEud2luLGIpO2FBLndpbj1iO2FBLmRvYz1hQS53aW4uZG9jdW1lbnQ7aWYoYVIuX2VuZ2luZS5pbml0V2luKXthUi5fZW5naW5lLmluaXRXaW4oYUEud2luKX19O3ZhciBiZj1mdW5jdGlvbihnKXtpZihhUi52bWwpe3ZhciBiPS9eXFxzK3xcXHMrJC9nO3ZhciBSO3RyeXt2YXIgUz1uZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpO1Mud3JpdGUoXCI8Ym9keT5cIik7Uy5jbG9zZSgpO1I9Uy5ib2R5fWNhdGNoKGJMKXtSPWNyZWF0ZVBvcHVwKCkuZG9jdW1lbnQuYm9keX12YXIgZD1SLmNyZWF0ZVRleHRSYW5nZSgpO2JmPWFHKGZ1bmN0aW9uKGkpe3RyeXtSLnN0eWxlLmNvbG9yPWJIKGkpLnJlcGxhY2UoYixhWCk7dmFyIGJNPWQucXVlcnlDb21tYW5kVmFsdWUoXCJGb3JlQ29sb3JcIik7Yk09KChiTSYyNTUpPDwxNil8KGJNJjY1MjgwKXwoKGJNJjE2NzExNjgwKT4+PjE2KTtyZXR1cm5cIiNcIisoXCIwMDAwMDBcIitiTS50b1N0cmluZygxNikpLnNsaWNlKC02KX1jYXRjaChiTil7cmV0dXJuXCJub25lXCJ9fSl9ZWxzZXt2YXIgRT1hQS5kb2MuY3JlYXRlRWxlbWVudChcImlcIik7RS50aXRsZT1cIlJhcGhhXFx4ZWJsIENvbG91ciBQaWNrZXJcIjtFLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7YUEuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoRSk7YmY9YUcoZnVuY3Rpb24oaSl7RS5zdHlsZS5jb2xvcj1pO3JldHVybiBhQS5kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShFLGFYKS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29sb3JcIil9KX1yZXR1cm4gYmYoZyl9LGFJPWZ1bmN0aW9uKCl7cmV0dXJuXCJoc2IoXCIrW3RoaXMuaCx0aGlzLnMsdGhpcy5iXStcIilcIn0sTT1mdW5jdGlvbigpe3JldHVyblwiaHNsKFwiK1t0aGlzLmgsdGhpcy5zLHRoaXMubF0rXCIpXCJ9LHg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZXh9LGFZPWZ1bmN0aW9uKFIsRSxkKXtpZihFPT1udWxsJiZhUi5pcyhSLFwib2JqZWN0XCIpJiZcInJcIiBpbiBSJiZcImdcIiBpbiBSJiZcImJcIiBpbiBSKXtkPVIuYjtFPVIuZztSPVIucn1pZihFPT1udWxsJiZhUi5pcyhSLGFqKSl7dmFyIGk9YVIuZ2V0UkdCKFIpO1I9aS5yO0U9aS5nO2Q9aS5ifWlmKFI+MXx8RT4xfHxkPjEpe1IvPTI1NTtFLz0yNTU7ZC89MjU1fXJldHVybltSLEUsZF19LGEyPWZ1bmN0aW9uKFIsRSxkLFMpe1IqPTI1NTtFKj0yNTU7ZCo9MjU1O3ZhciBpPXtyOlIsZzpFLGI6ZCxoZXg6YVIucmdiKFIsRSxkKSx0b1N0cmluZzp4fTthUi5pcyhTLFwiZmluaXRlXCIpJiYoaS5vcGFjaXR5PVMpO3JldHVybiBpfTthUi5jb2xvcj1mdW5jdGlvbihiKXt2YXIgZDtpZihhUi5pcyhiLFwib2JqZWN0XCIpJiZcImhcIiBpbiBiJiZcInNcIiBpbiBiJiZcImJcIiBpbiBiKXtkPWFSLmhzYjJyZ2IoYik7Yi5yPWQucjtiLmc9ZC5nO2IuYj1kLmI7Yi5oZXg9ZC5oZXh9ZWxzZXtpZihhUi5pcyhiLFwib2JqZWN0XCIpJiZcImhcIiBpbiBiJiZcInNcIiBpbiBiJiZcImxcIiBpbiBiKXtkPWFSLmhzbDJyZ2IoYik7Yi5yPWQucjtiLmc9ZC5nO2IuYj1kLmI7Yi5oZXg9ZC5oZXh9ZWxzZXtpZihhUi5pcyhiLFwic3RyaW5nXCIpKXtiPWFSLmdldFJHQihiKX1pZihhUi5pcyhiLFwib2JqZWN0XCIpJiZcInJcIiBpbiBiJiZcImdcIiBpbiBiJiZcImJcIiBpbiBiKXtkPWFSLnJnYjJoc2woYik7Yi5oPWQuaDtiLnM9ZC5zO2IubD1kLmw7ZD1hUi5yZ2IyaHNiKGIpO2Iudj1kLmJ9ZWxzZXtiPXtoZXg6XCJub25lXCJ9O2Iucj1iLmc9Yi5iPWIuaD1iLnM9Yi52PWIubD0tMX19fWIudG9TdHJpbmc9eDtyZXR1cm4gYn07YVIuaHNiMnJnYj1mdW5jdGlvbihTLGJOLGJMLGkpe2lmKHRoaXMuaXMoUyxcIm9iamVjdFwiKSYmXCJoXCIgaW4gUyYmXCJzXCIgaW4gUyYmXCJiXCIgaW4gUyl7Ykw9Uy5iO2JOPVMucztTPVMuaDtpPVMub31TKj0zNjA7dmFyIEUsYk0sZCxnLGI7Uz0oUyUzNjApLzYwO2I9YkwqYk47Zz1iKigxLWF3KFMlMi0xKSk7RT1iTT1kPWJMLWI7Uz1+flM7RSs9W2IsZywwLDAsZyxiXVtTXTtiTSs9W2csYixiLGcsMCwwXVtTXTtkKz1bMCwwLGcsYixiLGddW1NdO3JldHVybiBhMihFLGJNLGQsaSl9O2FSLmhzbDJyZ2I9ZnVuY3Rpb24oYkwsYk4sRSxpKXtpZih0aGlzLmlzKGJMLFwib2JqZWN0XCIpJiZcImhcIiBpbiBiTCYmXCJzXCIgaW4gYkwmJlwibFwiIGluIGJMKXtFPWJMLmw7Yk49YkwucztiTD1iTC5ofWlmKGJMPjF8fGJOPjF8fEU+MSl7YkwvPTM2MDtiTi89MTAwO0UvPTEwMH1iTCo9MzYwO3ZhciBTLGJNLGQsZyxiO2JMPShiTCUzNjApLzYwO2I9MipiTiooRTwwLjU/RToxLUUpO2c9YiooMS1hdyhiTCUyLTEpKTtTPWJNPWQ9RS1iLzI7Ykw9fn5iTDtTKz1bYixnLDAsMCxnLGJdW2JMXTtiTSs9W2csYixiLGcsMCwwXVtiTF07ZCs9WzAsMCxnLGIsYixnXVtiTF07cmV0dXJuIGEyKFMsYk0sZCxpKX07YVIucmdiMmhzYj1mdW5jdGlvbihiTSxiTCxkKXtkPWFZKGJNLGJMLGQpO2JNPWRbMF07Ykw9ZFsxXTtkPWRbMl07dmFyIFIsRSxpLGJOO2k9bShiTSxiTCxkKTtiTj1pLWJtKGJNLGJMLGQpO1I9KGJOPT0wP251bGw6aT09Yk0/KGJMLWQpL2JOOmk9PWJMPyhkLWJNKS9iTisyOihiTS1iTCkvYk4rNCk7Uj0oKFIrMzYwKSU2KSo2MC8zNjA7RT1iTj09MD8wOmJOL2k7cmV0dXJue2g6UixzOkUsYjppLHRvU3RyaW5nOmFJfX07YVIucmdiMmhzbD1mdW5jdGlvbihkLGJMLGJPKXtiTz1hWShkLGJMLGJPKTtkPWJPWzBdO2JMPWJPWzFdO2JPPWJPWzJdO3ZhciBiUCxSLGJOLGJNLEUsaTtiTT1tKGQsYkwsYk8pO0U9Ym0oZCxiTCxiTyk7aT1iTS1FO2JQPShpPT0wP251bGw6Yk09PWQ/KGJMLWJPKS9pOmJNPT1iTD8oYk8tZCkvaSsyOihkLWJMKS9pKzQpO2JQPSgoYlArMzYwKSU2KSo2MC8zNjA7Yk49KGJNK0UpLzI7Uj0oaT09MD8wOmJOPDAuNT9pLygyKmJOKTppLygyLTIqYk4pKTtyZXR1cm57aDpiUCxzOlIsbDpiTix0b1N0cmluZzpNfX07YVIuX3BhdGgyc3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pbihcIixcIikucmVwbGFjZShiZyxcIiQxXCIpfTtmdW5jdGlvbiBiayhFLGcpe2Zvcih2YXIgYj0wLGQ9RS5sZW5ndGg7YjxkO2IrKyl7aWYoRVtiXT09PWcpe3JldHVybiBFLnB1c2goRS5zcGxpY2UoYiwxKVswXSl9fX1mdW5jdGlvbiBhRyhpLGQsYil7ZnVuY3Rpb24gZygpe3ZhciBFPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSxTPUUuam9pbihcIlxcdTI0MDBcIiksUj1nLmNhY2hlPWcuY2FjaGV8fHt9LGJMPWcuY291bnQ9Zy5jb3VudHx8W107aWYoUltha10oUykpe2JrKGJMLFMpO3JldHVybiBiP2IoUltTXSk6UltTXX1iTC5sZW5ndGg+PTEwMDAmJmRlbGV0ZSBSW2JMLnNoaWZ0KCldO2JMLnB1c2goUyk7UltTXT1pW2JHXShkLEUpO3JldHVybiBiP2IoUltTXSk6UltTXX1yZXR1cm4gZ312YXIgYnY9YVIuX3ByZWxvYWQ9ZnVuY3Rpb24oZyxkKXt2YXIgYj1hQS5kb2MuY3JlYXRlRWxlbWVudChcImltZ1wiKTtiLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW1cIjtiLm9ubG9hZD1mdW5jdGlvbigpe2QuY2FsbCh0aGlzKTt0aGlzLm9ubG9hZD1udWxsO2FBLmRvYy5ib2R5LnJlbW92ZUNoaWxkKHRoaXMpfTtiLm9uZXJyb3I9ZnVuY3Rpb24oKXthQS5kb2MuYm9keS5yZW1vdmVDaGlsZCh0aGlzKX07YUEuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYik7Yi5zcmM9Z307ZnVuY3Rpb24gYXEoKXtyZXR1cm4gdGhpcy5oZXh9YVIuZ2V0UkdCPWFHKGZ1bmN0aW9uKGIpe2lmKCFifHwhISgoYj1iSChiKSkuaW5kZXhPZihcIi1cIikrMSkpe3JldHVybntyOi0xLGc6LTEsYjotMSxoZXg6XCJub25lXCIsZXJyb3I6MSx0b1N0cmluZzphcX19aWYoYj09XCJub25lXCIpe3JldHVybntyOi0xLGc6LTEsYjotMSxoZXg6XCJub25lXCIsdG9TdHJpbmc6YXF9fSEobltha10oYi50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygwLDIpKXx8Yi5jaGFyQXQoKT09XCIjXCIpJiYoYj1iZihiKSk7dmFyIEUsZCxnLFMsaSxiTSxiTCxSPWIubWF0Y2goQSk7aWYoUil7aWYoUlsyXSl7Uz1VKFJbMl0uc3Vic3RyaW5nKDUpLDE2KTtnPVUoUlsyXS5zdWJzdHJpbmcoMyw1KSwxNik7ZD1VKFJbMl0uc3Vic3RyaW5nKDEsMyksMTYpfWlmKFJbM10pe1M9VSgoYk09UlszXS5jaGFyQXQoMykpK2JNLDE2KTtnPVUoKGJNPVJbM10uY2hhckF0KDIpKStiTSwxNik7ZD1VKChiTT1SWzNdLmNoYXJBdCgxKSkrYk0sMTYpfWlmKFJbNF0pe2JMPVJbNF1bRl0oYmkpO2Q9YW4oYkxbMF0pO2JMWzBdLnNsaWNlKC0xKT09XCIlXCImJihkKj0yLjU1KTtnPWFuKGJMWzFdKTtiTFsxXS5zbGljZSgtMSk9PVwiJVwiJiYoZyo9Mi41NSk7Uz1hbihiTFsyXSk7YkxbMl0uc2xpY2UoLTEpPT1cIiVcIiYmKFMqPTIuNTUpO1JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLDQpPT1cInJnYmFcIiYmKGk9YW4oYkxbM10pKTtiTFszXSYmYkxbM10uc2xpY2UoLTEpPT1cIiVcIiYmKGkvPTEwMCl9aWYoUls1XSl7Ykw9Uls1XVtGXShiaSk7ZD1hbihiTFswXSk7YkxbMF0uc2xpY2UoLTEpPT1cIiVcIiYmKGQqPTIuNTUpO2c9YW4oYkxbMV0pO2JMWzFdLnNsaWNlKC0xKT09XCIlXCImJihnKj0yLjU1KTtcblM9YW4oYkxbMl0pO2JMWzJdLnNsaWNlKC0xKT09XCIlXCImJihTKj0yLjU1KTsoYkxbMF0uc2xpY2UoLTMpPT1cImRlZ1wifHxiTFswXS5zbGljZSgtMSk9PVwiXFx4YjBcIikmJihkLz0zNjApO1JbMV0udG9Mb3dlckNhc2UoKS5zbGljZSgwLDQpPT1cImhzYmFcIiYmKGk9YW4oYkxbM10pKTtiTFszXSYmYkxbM10uc2xpY2UoLTEpPT1cIiVcIiYmKGkvPTEwMCk7cmV0dXJuIGFSLmhzYjJyZ2IoZCxnLFMsaSl9aWYoUls2XSl7Ykw9Uls2XVtGXShiaSk7ZD1hbihiTFswXSk7YkxbMF0uc2xpY2UoLTEpPT1cIiVcIiYmKGQqPTIuNTUpO2c9YW4oYkxbMV0pO2JMWzFdLnNsaWNlKC0xKT09XCIlXCImJihnKj0yLjU1KTtTPWFuKGJMWzJdKTtiTFsyXS5zbGljZSgtMSk9PVwiJVwiJiYoUyo9Mi41NSk7KGJMWzBdLnNsaWNlKC0zKT09XCJkZWdcInx8YkxbMF0uc2xpY2UoLTEpPT1cIlxceGIwXCIpJiYoZC89MzYwKTtSWzFdLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw0KT09XCJoc2xhXCImJihpPWFuKGJMWzNdKSk7YkxbM10mJmJMWzNdLnNsaWNlKC0xKT09XCIlXCImJihpLz0xMDApO3JldHVybiBhUi5oc2wycmdiKGQsZyxTLGkpfVI9e3I6ZCxnOmcsYjpTLHRvU3RyaW5nOmFxfTtSLmhleD1cIiNcIisoMTY3NzcyMTZ8U3woZzw8OCl8KGQ8PDE2KSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpO2FSLmlzKGksXCJmaW5pdGVcIikmJihSLm9wYWNpdHk9aSk7cmV0dXJuIFJ9cmV0dXJue3I6LTEsZzotMSxiOi0xLGhleDpcIm5vbmVcIixlcnJvcjoxLHRvU3RyaW5nOmFxfX0sYVIpO2FSLmhzYj1hRyhmdW5jdGlvbihpLGcsZCl7cmV0dXJuIGFSLmhzYjJyZ2IoaSxnLGQpLmhleH0pO2FSLmhzbD1hRyhmdW5jdGlvbihnLGQsYil7cmV0dXJuIGFSLmhzbDJyZ2IoZyxkLGIpLmhleH0pO2FSLnJnYj1hRyhmdW5jdGlvbihFLGksZCl7cmV0dXJuXCIjXCIrKDE2Nzc3MjE2fGR8KGk8PDgpfChFPDwxNikpLnRvU3RyaW5nKDE2KS5zbGljZSgxKX0pO2FSLmdldENvbG9yPWZ1bmN0aW9uKGQpe3ZhciBnPXRoaXMuZ2V0Q29sb3Iuc3RhcnQ9dGhpcy5nZXRDb2xvci5zdGFydHx8e2g6MCxzOjEsYjpkfHwwLjc1fSxiPXRoaXMuaHNiMnJnYihnLmgsZy5zLGcuYik7Zy5oKz0wLjA3NTtpZihnLmg+MSl7Zy5oPTA7Zy5zLT0wLjI7Zy5zPD0wJiYodGhpcy5nZXRDb2xvci5zdGFydD17aDowLHM6MSxiOmcuYn0pfXJldHVybiBiLmhleH07YVIuZ2V0Q29sb3IucmVzZXQ9ZnVuY3Rpb24oKXtkZWxldGUgdGhpcy5zdGFydH07ZnVuY3Rpb24gYmIoRSxiTCl7dmFyIFM9W107Zm9yKHZhciBnPTAsYj1FLmxlbmd0aDtiLTIqIWJMPmc7Zys9Mil7dmFyIFI9W3t4OitFW2ctMl0seTorRVtnLTFdfSx7eDorRVtnXSx5OitFW2crMV19LHt4OitFW2crMl0seTorRVtnKzNdfSx7eDorRVtnKzRdLHk6K0VbZys1XX1dO2lmKGJMKXtpZighZyl7UlswXT17eDorRVtiLTJdLHk6K0VbYi0xXX19ZWxzZXtpZihiLTQ9PWcpe1JbM109e3g6K0VbMF0seTorRVsxXX19ZWxzZXtpZihiLTI9PWcpe1JbMl09e3g6K0VbMF0seTorRVsxXX07UlszXT17eDorRVsyXSx5OitFWzNdfX19fX1lbHNle2lmKGItND09Zyl7UlszXT1SWzJdfWVsc2V7aWYoIWcpe1JbMF09e3g6K0VbZ10seTorRVtnKzFdfX19fVMucHVzaChbXCJDXCIsKC1SWzBdLngrNipSWzFdLngrUlsyXS54KS82LCgtUlswXS55KzYqUlsxXS55K1JbMl0ueSkvNiwoUlsxXS54KzYqUlsyXS54LVJbM10ueCkvNiwoUlsxXS55KzYqUlsyXS55LVJbM10ueSkvNixSWzJdLngsUlsyXS55XSl9cmV0dXJuIFN9YVIucGFyc2VQYXRoU3RyaW5nPWZ1bmN0aW9uKGIpe2lmKCFiKXtyZXR1cm4gbnVsbH12YXIgZz1ZKGIpO2lmKGcuYXJyKXtyZXR1cm4gYVooZy5hcnIpfXZhciBpPXthOjcsYzo2LGg6MSxsOjIsbToyLHI6NCxxOjQsczo0LHQ6Mix2OjEsejowfSxkPVtdO2lmKGFSLmlzKGIsYmQpJiZhUi5pcyhiWzBdLGJkKSl7ZD1hWihiKX1pZighZC5sZW5ndGgpe2JIKGIpLnJlcGxhY2UoYTAsZnVuY3Rpb24oUixFLGJNKXt2YXIgYkw9W10sUz1FLnRvTG93ZXJDYXNlKCk7Yk0ucmVwbGFjZShhUCxmdW5jdGlvbihiTyxiTil7Yk4mJmJMLnB1c2goK2JOKX0pO2lmKFM9PVwibVwiJiZiTC5sZW5ndGg+Mil7ZC5wdXNoKFtFXVtiRV0oYkwuc3BsaWNlKDAsMikpKTtTPVwibFwiO0U9RT09XCJtXCI/XCJsXCI6XCJMXCJ9aWYoUz09XCJyXCIpe2QucHVzaChbRV1bYkVdKGJMKSl9ZWxzZXt3aGlsZShiTC5sZW5ndGg+PWlbU10pe2QucHVzaChbRV1bYkVdKGJMLnNwbGljZSgwLGlbU10pKSk7aWYoIWlbU10pe2JyZWFrfX19fSl9ZC50b1N0cmluZz1hUi5fcGF0aDJzdHJpbmc7Zy5hcnI9YVooZCk7cmV0dXJuIGR9O2FSLnBhcnNlVHJhbnNmb3JtU3RyaW5nPWFHKGZ1bmN0aW9uKGQpe2lmKCFkKXtyZXR1cm4gbnVsbH12YXIgZz17cjozLHM6NCx0OjIsbTo2fSxiPVtdO2lmKGFSLmlzKGQsYmQpJiZhUi5pcyhkWzBdLGJkKSl7Yj1hWihkKX1pZighYi5sZW5ndGgpe2JIKGQpLnJlcGxhY2UoYWksZnVuY3Rpb24oRSxpLGJMKXt2YXIgUz1bXSxSPWJLLmNhbGwoaSk7YkwucmVwbGFjZShhUCxmdW5jdGlvbihiTixiTSl7Yk0mJlMucHVzaCgrYk0pfSk7Yi5wdXNoKFtpXVtiRV0oUykpfSl9Yi50b1N0cmluZz1hUi5fcGF0aDJzdHJpbmc7cmV0dXJuIGJ9KTt2YXIgWT1mdW5jdGlvbihkKXt2YXIgYj1ZLnBzPVkucHN8fHt9O2lmKGJbZF0pe2JbZF0uc2xlZXA9MTAwfWVsc2V7YltkXT17c2xlZXA6MTAwfX1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zm9yKHZhciBnIGluIGIpe2lmKGJbYWtdKGcpJiZnIT1kKXtiW2ddLnNsZWVwLS07IWJbZ10uc2xlZXAmJmRlbGV0ZSBiW2ddfX19KTtyZXR1cm4gYltkXX07YVIuZmluZERvdHNBdFNlZ21lbnQ9ZnVuY3Rpb24oZCxiLGIyLGIwLFMsRSxiTixiTCxiVil7dmFyIGJTPTEtYlYsYlg9YnAoYlMsMyksYlk9YnAoYlMsMiksYlA9YlYqYlYsYk09YlAqYlYsYlI9YlgqZCtiWSozKmJWKmIyK2JTKjMqYlYqYlYqUytiTSpiTixiTz1iWCpiK2JZKjMqYlYqYjArYlMqMypiVipiVipFK2JNKmJMLGJXPWQrMipiViooYjItZCkrYlAqKFMtMipiMitkKSxiVT1iKzIqYlYqKGIwLWIpK2JQKihFLTIqYjArYiksYjE9YjIrMipiViooUy1iMikrYlAqKGJOLTIqUytiMiksYlo9YjArMipiViooRS1iMCkrYlAqKGJMLTIqRStiMCksYlQ9YlMqZCtiVipiMixiUT1iUypiK2JWKmIwLGk9YlMqUytiVipiTixnPWJTKkUrYlYqYkwsUj0oOTAtYXUuYXRhbjIoYlctYjEsYlUtYlopKjE4MC9hVik7KGJXPmIxfHxiVTxiWikmJihSKz0xODApO3JldHVybnt4OmJSLHk6Yk8sbTp7eDpiVyx5OmJVfSxuOnt4OmIxLHk6Ylp9LHN0YXJ0Ont4OmJULHk6YlF9LGVuZDp7eDppLHk6Z30sYWxwaGE6Un19O2FSLmJlemllckJCb3g9ZnVuY3Rpb24oZCxiLGksZyxiTSxTLFIsRSl7aWYoIWFSLmlzKGQsXCJhcnJheVwiKSl7ZD1bZCxiLGksZyxiTSxTLFIsRV19dmFyIGJMPWJhLmFwcGx5KG51bGwsZCk7cmV0dXJue3g6YkwubWluLngseTpiTC5taW4ueSx4MjpiTC5tYXgueCx5MjpiTC5tYXgueSx3aWR0aDpiTC5tYXgueC1iTC5taW4ueCxoZWlnaHQ6YkwubWF4LnktYkwubWluLnl9fTthUi5pc1BvaW50SW5zaWRlQkJveD1mdW5jdGlvbihkLGIsZyl7cmV0dXJuIGI+PWQueCYmYjw9ZC54MiYmZz49ZC55JiZnPD1kLnkyfTthUi5pc0JCb3hJbnRlcnNlY3Q9ZnVuY3Rpb24oZyxkKXt2YXIgYj1hUi5pc1BvaW50SW5zaWRlQkJveDtyZXR1cm4gYihkLGcueCxnLnkpfHxiKGQsZy54MixnLnkpfHxiKGQsZy54LGcueTIpfHxiKGQsZy54MixnLnkyKXx8YihnLGQueCxkLnkpfHxiKGcsZC54MixkLnkpfHxiKGcsZC54LGQueTIpfHxiKGcsZC54MixkLnkyKXx8KGcueDxkLngyJiZnLng+ZC54fHxkLng8Zy54MiYmZC54PmcueCkmJihnLnk8ZC55MiYmZy55PmQueXx8ZC55PGcueTImJmQueT5nLnkpfTtmdW5jdGlvbiBiaihiLFMsUixFLGkpe3ZhciBnPS0zKlMrOSpSLTkqRSszKmksZD1iKmcrNipTLTEyKlIrNipFO3JldHVybiBiKmQtMypTKzMqUn1mdW5jdGlvbiBxKGJXLFIsYlYsZyxiVSxkLGJSLGIsYk8pe2lmKGJPPT1udWxsKXtiTz0xfWJPPWJPPjE/MTpiTzwwPzA6Yk87dmFyIGJQPWJPLzIsYlE9MTIsYkw9Wy0wLjEyNTIsMC4xMjUyLC0wLjM2NzgsMC4zNjc4LC0wLjU4NzMsMC41ODczLC0wLjc2OTksMC43Njk5LC0wLjkwNDEsMC45MDQxLC0wLjk4MTYsMC45ODE2XSxiVD1bMC4yNDkxLDAuMjQ5MSwwLjIzMzUsMC4yMzM1LDAuMjAzMiwwLjIwMzIsMC4xNjAxLDAuMTYwMSwwLjEwNjksMC4xMDY5LDAuMDQ3MiwwLjA0NzJdLEU9MDtmb3IodmFyIGJTPTA7YlM8YlE7YlMrKyl7dmFyIGJNPWJQKmJMW2JTXStiUCxiTj1iaihiTSxiVyxiVixiVSxiUiksYlg9YmooYk0sUixnLGQsYiksUz1iTipiTitiWCpiWDtFKz1iVFtiU10qYXUuc3FydChTKX1yZXR1cm4gYlAqRX1mdW5jdGlvbiBDKGcsYlAsZCxiTyxiLGJNLGJSLGJMLGJOKXtpZihiTjwwfHxxKGcsYlAsZCxiTyxiLGJNLGJSLGJMKTxiTil7cmV0dXJufXZhciBiUT0xLGk9YlEvMixSPWJRLWksRSxTPTAuMDE7RT1xKGcsYlAsZCxiTyxiLGJNLGJSLGJMLFIpO3doaWxlKGF3KEUtYk4pPlMpe2kvPTI7Uis9KEU8Yk4/MTotMSkqaTtFPXEoZyxiUCxkLGJPLGIsYk0sYlIsYkwsUil9cmV0dXJuIFJ9ZnVuY3Rpb24gTyhpLGJRLGcsYk8sYixiTixiUyxiTSl7aWYobShpLGcpPGJtKGIsYlMpfHxibShpLGcpPm0oYixiUyl8fG0oYlEsYk8pPGJtKGJOLGJNKXx8Ym0oYlEsYk8pPm0oYk4sYk0pKXtyZXR1cm59dmFyIGJMPShpKmJPLWJRKmcpKihiLWJTKS0oaS1nKSooYipiTS1iTipiUyksUz0oaSpiTy1iUSpnKSooYk4tYk0pLShiUS1iTykqKGIqYk0tYk4qYlMpLEU9KGktZykqKGJOLWJNKS0oYlEtYk8pKihiLWJTKTtpZighRSl7cmV0dXJufXZhciBiUj1iTC9FLGJQPVMvRSxSPStiUi50b0ZpeGVkKDIpLGQ9K2JQLnRvRml4ZWQoMik7aWYoUjwrYm0oaSxnKS50b0ZpeGVkKDIpfHxSPittKGksZykudG9GaXhlZCgyKXx8UjwrYm0oYixiUykudG9GaXhlZCgyKXx8Uj4rbShiLGJTKS50b0ZpeGVkKDIpfHxkPCtibShiUSxiTykudG9GaXhlZCgyKXx8ZD4rbShiUSxiTykudG9GaXhlZCgyKXx8ZDwrYm0oYk4sYk0pLnRvRml4ZWQoMil8fGQ+K20oYk4sYk0pLnRvRml4ZWQoMikpe3JldHVybn1yZXR1cm57eDpiUix5OmJQfX1mdW5jdGlvbiBheShkLGIpe3JldHVybiBhZihkLGIpfWZ1bmN0aW9uIHQoZCxiKXtyZXR1cm4gYWYoZCxiLDEpfWZ1bmN0aW9uIGFmKGIyLGIxLGIwKXt2YXIgRT1hUi5iZXppZXJCQm94KGIyKSxkPWFSLmJlemllckJCb3goYjEpO2lmKCFhUi5pc0JCb3hJbnRlcnNlY3QoRSxkKSl7cmV0dXJuIGIwPzA6W119dmFyIGJWPXEuYXBwbHkoMCxiMiksYlU9cS5hcHBseSgwLGIxKSxiTT1+fihiVi81KSxiTD1+fihiVS81KSxiUz1bXSxiUj1bXSxnPXt9LGIzPWIwPzA6W107Zm9yKHZhciBiWD0wO2JYPGJNKzE7YlgrKyl7dmFyIGJUPWFSLmZpbmREb3RzQXRTZWdtZW50LmFwcGx5KGFSLGIyLmNvbmNhdChiWC9iTSkpO2JTLnB1c2goe3g6YlQueCx5OmJULnksdDpiWC9iTX0pfWZvcihiWD0wO2JYPGJMKzE7YlgrKyl7YlQ9YVIuZmluZERvdHNBdFNlZ21lbnQuYXBwbHkoYVIsYjEuY29uY2F0KGJYL2JMKSk7YlIucHVzaCh7eDpiVC54LHk6YlQueSx0OmJYL2JMfSl9Zm9yKGJYPTA7Ylg8Yk07YlgrKyl7Zm9yKHZhciBiVz0wO2JXPGJMO2JXKyspe3ZhciBiWj1iU1tiWF0sYj1iU1tiWCsxXSxiWT1iUltiV10sUz1iUltiVysxXSxiUT1hdyhiLngtYloueCk8MC4wMDE/XCJ5XCI6XCJ4XCIsYlA9YXcoUy54LWJZLngpPDAuMDAxP1wieVwiOlwieFwiLFI9TyhiWi54LGJaLnksYi54LGIueSxiWS54LGJZLnksUy54LFMueSk7aWYoUil7aWYoZ1tSLngudG9GaXhlZCg0KV09PVIueS50b0ZpeGVkKDQpKXtjb250aW51ZX1nW1IueC50b0ZpeGVkKDQpXT1SLnkudG9GaXhlZCg0KTt2YXIgYk89YloudCthdygoUltiUV0tYlpbYlFdKS8oYltiUV0tYlpbYlFdKSkqKGIudC1iWi50KSxiTj1iWS50K2F3KChSW2JQXS1iWVtiUF0pLyhTW2JQXS1iWVtiUF0pKSooUy50LWJZLnQpO2lmKGJPPj0wJiZiTzw9MSYmYk4+PTAmJmJOPD0xKXtpZihiMCl7YjMrK31lbHNle2IzLnB1c2goe3g6Ui54LHk6Ui55LHQxOmJPLHQyOmJOfSl9fX19fXJldHVybiBiM31hUi5wYXRoSW50ZXJzZWN0aW9uPWZ1bmN0aW9uKGQsYil7cmV0dXJuIEQoZCxiKX07YVIucGF0aEludGVyc2VjdGlvbk51bWJlcj1mdW5jdGlvbihkLGIpe3JldHVybiBEKGQsYiwxKX07ZnVuY3Rpb24gRChnLGIsYlcpe2c9YVIuX3BhdGgyY3VydmUoZyk7Yj1hUi5fcGF0aDJjdXJ2ZShiKTt2YXIgYlUsUyxiVCxFLGJSLGJMLGQsYk8sYjAsYlosYjE9Ylc/MDpbXTtmb3IodmFyIGJTPTAsYk09Zy5sZW5ndGg7YlM8Yk07YlMrKyl7dmFyIGJZPWdbYlNdO2lmKGJZWzBdPT1cIk1cIil7YlU9YlI9YllbMV07Uz1iTD1iWVsyXX1lbHNle2lmKGJZWzBdPT1cIkNcIil7YjA9W2JVLFNdLmNvbmNhdChiWS5zbGljZSgxKSk7YlU9YjBbNl07Uz1iMFs3XX1lbHNle2IwPVtiVSxTLGJVLFMsYlIsYkwsYlIsYkxdO2JVPWJSO1M9Ykx9Zm9yKHZhciBiUT0wLGJWPWIubGVuZ3RoO2JRPGJWO2JRKyspe3ZhciBiWD1iW2JRXTtpZihiWFswXT09XCJNXCIpe2JUPWQ9YlhbMV07RT1iTz1iWFsyXX1lbHNle2lmKGJYWzBdPT1cIkNcIil7Ylo9W2JULEVdLmNvbmNhdChiWC5zbGljZSgxKSk7YlQ9YlpbNl07RT1iWls3XX1lbHNle2JaPVtiVCxFLGJULEUsZCxiTyxkLGJPXTtiVD1kO0U9Yk99dmFyIGJOPWFmKGIwLGJaLGJXKTtpZihiVyl7YjErPWJOfWVsc2V7Zm9yKHZhciBiUD0wLFI9Yk4ubGVuZ3RoO2JQPFI7YlArKyl7Yk5bYlBdLnNlZ21lbnQxPWJTO2JOW2JQXS5zZWdtZW50Mj1iUTtiTltiUF0uYmV6MT1iMDtiTltiUF0uYmV6Mj1iWn1iMT1iMS5jb25jYXQoYk4pfX19fX1yZXR1cm4gYjF9YVIuaXNQb2ludEluc2lkZVBhdGg9ZnVuY3Rpb24oZCxiLGkpe3ZhciBnPWFSLnBhdGhCQm94KGQpO3JldHVybiBhUi5pc1BvaW50SW5zaWRlQkJveChnLGIsaSkmJkQoZCxbW1wiTVwiLGIsaV0sW1wiSFwiLGcueDIrMTBdXSwxKSUyPT0xfTthUi5fcmVtb3ZlZEZhY3Rvcnk9ZnVuY3Rpb24oYil7cmV0dXJuIGZ1bmN0aW9uKCl7ZXZlKFwicmFwaGFlbC5sb2dcIixudWxsLFwiUmFwaGFcXHhlYmw6IHlvdSBhcmUgY2FsbGluZyB0byBtZXRob2QgXFx1MjAxY1wiK2IrXCJcXHUyMDFkIG9mIHJlbW92ZWQgb2JqZWN0XCIsYilcbn19O3ZhciBhbT1hUi5wYXRoQkJveD1mdW5jdGlvbihiVCl7dmFyIGJOPVkoYlQpO2lmKGJOLmJib3gpe3JldHVybiBiTi5iYm94fWlmKCFiVCl7cmV0dXJue3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MCx4MjowLHkyOjB9fWJUPVcoYlQpO3ZhciBiUT0wLGJQPTAsUj1bXSxkPVtdLGc7Zm9yKHZhciBiTD0wLGJTPWJULmxlbmd0aDtiTDxiUztiTCsrKXtnPWJUW2JMXTtpZihnWzBdPT1cIk1cIil7YlE9Z1sxXTtiUD1nWzJdO1IucHVzaChiUSk7ZC5wdXNoKGJQKX1lbHNle3ZhciBiTT1iYShiUSxiUCxnWzFdLGdbMl0sZ1szXSxnWzRdLGdbNV0sZ1s2XSk7Uj1SW2JFXShiTS5taW4ueCxiTS5tYXgueCk7ZD1kW2JFXShiTS5taW4ueSxiTS5tYXgueSk7YlE9Z1s1XTtiUD1nWzZdfX12YXIgYj1ibVtiR10oMCxSKSxiUj1ibVtiR10oMCxkKSxTPW1bYkddKDAsUiksRT1tW2JHXSgwLGQpLGJPPXt4OmIseTpiUix4MjpTLHkyOkUsd2lkdGg6Uy1iLGhlaWdodDpFLWJSfTtiTi5iYm94PVgoYk8pO3JldHVybiBiT30sYVo9ZnVuY3Rpb24oZCl7dmFyIGI9WChkKTtiLnRvU3RyaW5nPWFSLl9wYXRoMnN0cmluZztyZXR1cm4gYn0sYUM9YVIuX3BhdGhUb1JlbGF0aXZlPWZ1bmN0aW9uKEUpe3ZhciBiTT1ZKEUpO2lmKGJNLnJlbCl7cmV0dXJuIGFaKGJNLnJlbCl9aWYoIWFSLmlzKEUsYmQpfHwhYVIuaXMoRSYmRVswXSxiZCkpe0U9YVIucGFyc2VQYXRoU3RyaW5nKEUpfXZhciBiUD1bXSxiUj0wLGJRPTAsYlU9MCxiVD0wLGc9MDtpZihFWzBdWzBdPT1cIk1cIil7YlI9RVswXVsxXTtiUT1FWzBdWzJdO2JVPWJSO2JUPWJRO2crKztiUC5wdXNoKFtcIk1cIixiUixiUV0pfWZvcih2YXIgYkw9ZyxiVj1FLmxlbmd0aDtiTDxiVjtiTCsrKXt2YXIgYj1iUFtiTF09W10sYlM9RVtiTF07aWYoYlNbMF0hPWJLLmNhbGwoYlNbMF0pKXtiWzBdPWJLLmNhbGwoYlNbMF0pO3N3aXRjaChiWzBdKXtjYXNlXCJhXCI6YlsxXT1iU1sxXTtiWzJdPWJTWzJdO2JbM109YlNbM107Yls0XT1iU1s0XTtiWzVdPWJTWzVdO2JbNl09KyhiU1s2XS1iUikudG9GaXhlZCgzKTtiWzddPSsoYlNbN10tYlEpLnRvRml4ZWQoMyk7YnJlYWs7Y2FzZVwidlwiOmJbMV09KyhiU1sxXS1iUSkudG9GaXhlZCgzKTticmVhaztjYXNlXCJtXCI6YlU9YlNbMV07YlQ9YlNbMl07ZGVmYXVsdDpmb3IodmFyIFM9MSxiTj1iUy5sZW5ndGg7UzxiTjtTKyspe2JbU109KyhiU1tTXS0oKFMlMik/YlI6YlEpKS50b0ZpeGVkKDMpfX19ZWxzZXtiPWJQW2JMXT1bXTtpZihiU1swXT09XCJtXCIpe2JVPWJTWzFdK2JSO2JUPWJTWzJdK2JRfWZvcih2YXIgUj0wLGQ9YlMubGVuZ3RoO1I8ZDtSKyspe2JQW2JMXVtSXT1iU1tSXX19dmFyIGJPPWJQW2JMXS5sZW5ndGg7c3dpdGNoKGJQW2JMXVswXSl7Y2FzZVwielwiOmJSPWJVO2JRPWJUO2JyZWFrO2Nhc2VcImhcIjpiUis9K2JQW2JMXVtiTy0xXTticmVhaztjYXNlXCJ2XCI6YlErPStiUFtiTF1bYk8tMV07YnJlYWs7ZGVmYXVsdDpiUis9K2JQW2JMXVtiTy0yXTtiUSs9K2JQW2JMXVtiTy0xXX19YlAudG9TdHJpbmc9YVIuX3BhdGgyc3RyaW5nO2JNLnJlbD1hWihiUCk7cmV0dXJuIGJQfSx3PWFSLl9wYXRoVG9BYnNvbHV0ZT1mdW5jdGlvbihiUSl7dmFyIGc9WShiUSk7aWYoZy5hYnMpe3JldHVybiBhWihnLmFicyl9aWYoIWFSLmlzKGJRLGJkKXx8IWFSLmlzKGJRJiZiUVswXSxiZCkpe2JRPWFSLnBhcnNlUGF0aFN0cmluZyhiUSl9aWYoIWJRfHwhYlEubGVuZ3RoKXtyZXR1cm5bW1wiTVwiLDAsMF1dfXZhciBiVz1bXSxiTD0wLFM9MCxiTz0wLGJOPTAsRT0wO2lmKGJRWzBdWzBdPT1cIk1cIil7Ykw9K2JRWzBdWzFdO1M9K2JRWzBdWzJdO2JPPWJMO2JOPVM7RSsrO2JXWzBdPVtcIk1cIixiTCxTXX12YXIgYlY9YlEubGVuZ3RoPT0zJiZiUVswXVswXT09XCJNXCImJmJRWzFdWzBdLnRvVXBwZXJDYXNlKCk9PVwiUlwiJiZiUVsyXVswXS50b1VwcGVyQ2FzZSgpPT1cIlpcIjtmb3IodmFyIGJQLGIsYlQ9RSxiTT1iUS5sZW5ndGg7YlQ8Yk07YlQrKyl7YlcucHVzaChiUD1bXSk7Yj1iUVtiVF07aWYoYlswXSE9YnQuY2FsbChiWzBdKSl7YlBbMF09YnQuY2FsbChiWzBdKTtzd2l0Y2goYlBbMF0pe2Nhc2VcIkFcIjpiUFsxXT1iWzFdO2JQWzJdPWJbMl07YlBbM109YlszXTtiUFs0XT1iWzRdO2JQWzVdPWJbNV07YlBbNl09KyhiWzZdK2JMKTtiUFs3XT0rKGJbN10rUyk7YnJlYWs7Y2FzZVwiVlwiOmJQWzFdPStiWzFdK1M7YnJlYWs7Y2FzZVwiSFwiOmJQWzFdPStiWzFdK2JMO2JyZWFrO2Nhc2VcIlJcIjp2YXIgUj1bYkwsU11bYkVdKGIuc2xpY2UoMSkpO2Zvcih2YXIgYlM9MixiVT1SLmxlbmd0aDtiUzxiVTtiUysrKXtSW2JTXT0rUltiU10rYkw7UlsrK2JTXT0rUltiU10rU31iVy5wb3AoKTtiVz1iV1tiRV0oYmIoUixiVikpO2JyZWFrO2Nhc2VcIk1cIjpiTz0rYlsxXStiTDtiTj0rYlsyXStTO2RlZmF1bHQ6Zm9yKGJTPTEsYlU9Yi5sZW5ndGg7YlM8YlU7YlMrKyl7YlBbYlNdPStiW2JTXSsoKGJTJTIpP2JMOlMpfX19ZWxzZXtpZihiWzBdPT1cIlJcIil7Uj1bYkwsU11bYkVdKGIuc2xpY2UoMSkpO2JXLnBvcCgpO2JXPWJXW2JFXShiYihSLGJWKSk7YlA9W1wiUlwiXVtiRV0oYi5zbGljZSgtMikpfWVsc2V7Zm9yKHZhciBiUj0wLGQ9Yi5sZW5ndGg7YlI8ZDtiUisrKXtiUFtiUl09YltiUl19fX1zd2l0Y2goYlBbMF0pe2Nhc2VcIlpcIjpiTD1iTztTPWJOO2JyZWFrO2Nhc2VcIkhcIjpiTD1iUFsxXTticmVhaztjYXNlXCJWXCI6Uz1iUFsxXTticmVhaztjYXNlXCJNXCI6Yk89YlBbYlAubGVuZ3RoLTJdO2JOPWJQW2JQLmxlbmd0aC0xXTtkZWZhdWx0OmJMPWJQW2JQLmxlbmd0aC0yXTtTPWJQW2JQLmxlbmd0aC0xXX19YlcudG9TdHJpbmc9YVIuX3BhdGgyc3RyaW5nO2cuYWJzPWFaKGJXKTtyZXR1cm4gYld9LGJJPWZ1bmN0aW9uKGQsaSxiLGcpe3JldHVybltkLGksYixnLGIsZ119LGJuPWZ1bmN0aW9uKGQsaSxTLEUsYixnKXt2YXIgUj0xLzMsYkw9Mi8zO3JldHVybltSKmQrYkwqUyxSKmkrYkwqRSxSKmIrYkwqUyxSKmcrYkwqRSxiLGddfSxhZT1mdW5jdGlvbihiUyxjbixiMSxiWixiVCxiTixFLGJSLGNtLGJVKXt2YXIgYlk9YVYqMTIwLzE4MCxiPWFWLzE4MCooK2JUfHwwKSxiNT1bXSxiMixjaj1hRyhmdW5jdGlvbihjbyxjcixpKXt2YXIgY3E9Y28qYXUuY29zKGkpLWNyKmF1LnNpbihpKSxjcD1jbyphdS5zaW4oaSkrY3IqYXUuY29zKGkpO3JldHVybnt4OmNxLHk6Y3B9fSk7aWYoIWJVKXtiMj1jaihiUyxjbiwtYik7YlM9YjIueDtjbj1iMi55O2IyPWNqKGJSLGNtLC1iKTtiUj1iMi54O2NtPWIyLnk7dmFyIGQ9YXUuY29zKGFWLzE4MCpiVCksYlA9YXUuc2luKGFWLzE4MCpiVCksYjc9KGJTLWJSKS8yLGI2PShjbi1jbSkvMjt2YXIgY2g9KGI3KmI3KS8oYjEqYjEpKyhiNipiNikvKGJaKmJaKTtpZihjaD4xKXtjaD1hdS5zcXJ0KGNoKTtiMT1jaCpiMTtiWj1jaCpiWn12YXIgZz1iMSpiMSxjYT1iWipiWixjYz0oYk49PUU/LTE6MSkqYXUuc3FydChhdygoZypjYS1nKmI2KmI2LWNhKmI3KmI3KS8oZypiNipiNitjYSpiNypiNykpKSxiVz1jYypiMSpiNi9iWisoYlMrYlIpLzIsYlY9Y2MqLWJaKmI3L2IxKyhjbitjbSkvMixiTT1hdS5hc2luKCgoY24tYlYpL2JaKS50b0ZpeGVkKDkpKSxiTD1hdS5hc2luKCgoY20tYlYpL2JaKS50b0ZpeGVkKDkpKTtiTT1iUzxiVz9hVi1iTTpiTTtiTD1iUjxiVz9hVi1iTDpiTDtiTTwwJiYoYk09YVYqMitiTSk7Ykw8MCYmKGJMPWFWKjIrYkwpO2lmKEUmJmJNPmJMKXtiTT1iTS1hVioyfWlmKCFFJiZiTD5iTSl7Ykw9YkwtYVYqMn19ZWxzZXtiTT1iVVswXTtiTD1iVVsxXTtiVz1iVVsyXTtiVj1iVVszXX12YXIgYlE9YkwtYk07aWYoYXcoYlEpPmJZKXt2YXIgYlg9YkwsYjA9YlIsYk89Y207Ykw9Yk0rYlkqKEUmJmJMPmJNPzE6LTEpO2JSPWJXK2IxKmF1LmNvcyhiTCk7Y209YlYrYloqYXUuc2luKGJMKTtiNT1hZShiUixjbSxiMSxiWixiVCwwLEUsYjAsYk8sW2JMLGJYLGJXLGJWXSl9YlE9YkwtYk07dmFyIFM9YXUuY29zKGJNKSxjbD1hdS5zaW4oYk0pLFI9YXUuY29zKGJMKSxjaz1hdS5zaW4oYkwpLGI4PWF1LnRhbihiUS80KSxjYj00LzMqYjEqYjgsYjk9NC8zKmJaKmI4LGNpPVtiUyxjbl0sY2c9W2JTK2NiKmNsLGNuLWI5KlNdLGNmPVtiUitjYipjayxjbS1iOSpSXSxjZD1bYlIsY21dO2NnWzBdPTIqY2lbMF0tY2dbMF07Y2dbMV09MipjaVsxXS1jZ1sxXTtpZihiVSl7cmV0dXJuW2NnLGNmLGNkXVtiRV0oYjUpfWVsc2V7YjU9W2NnLGNmLGNkXVtiRV0oYjUpLmpvaW4oKVtGXShcIixcIik7dmFyIGIzPVtdO2Zvcih2YXIgY2U9MCxiND1iNS5sZW5ndGg7Y2U8YjQ7Y2UrKyl7YjNbY2VdPWNlJTI/Y2ooYjVbY2UtMV0sYjVbY2VdLGIpLnk6Y2ooYjVbY2VdLGI1W2NlKzFdLGIpLnh9cmV0dXJuIGIzfX0sYWc9ZnVuY3Rpb24oZCxiLGksZyxiTSxiTCxTLFIsYk4pe3ZhciBFPTEtYk47cmV0dXJue3g6YnAoRSwzKSpkK2JwKEUsMikqMypiTippK0UqMypiTipiTipiTSticChiTiwzKSpTLHk6YnAoRSwzKSpiK2JwKEUsMikqMypiTipnK0UqMypiTipiTipiTCticChiTiwzKSpSfX0sYmE9YUcoZnVuY3Rpb24oaSxkLFIsRSxiVSxiVCxiUSxiTil7dmFyIGJTPShiVS0yKlIraSktKGJRLTIqYlUrUiksYlA9MiooUi1pKS0yKihiVS1SKSxiTT1pLVIsYkw9KC1iUCthdS5zcXJ0KGJQKmJQLTQqYlMqYk0pKS8yL2JTLFM9KC1iUC1hdS5zcXJ0KGJQKmJQLTQqYlMqYk0pKS8yL2JTLGJPPVtkLGJOXSxiUj1baSxiUV0sZzthdyhiTCk+XCIxZTEyXCImJihiTD0wLjUpO2F3KFMpPlwiMWUxMlwiJiYoUz0wLjUpO2lmKGJMPjAmJmJMPDEpe2c9YWcoaSxkLFIsRSxiVSxiVCxiUSxiTixiTCk7YlIucHVzaChnLngpO2JPLnB1c2goZy55KX1pZihTPjAmJlM8MSl7Zz1hZyhpLGQsUixFLGJVLGJULGJRLGJOLFMpO2JSLnB1c2goZy54KTtiTy5wdXNoKGcueSl9YlM9KGJULTIqRStkKS0oYk4tMipiVCtFKTtiUD0yKihFLWQpLTIqKGJULUUpO2JNPWQtRTtiTD0oLWJQK2F1LnNxcnQoYlAqYlAtNCpiUypiTSkpLzIvYlM7Uz0oLWJQLWF1LnNxcnQoYlAqYlAtNCpiUypiTSkpLzIvYlM7YXcoYkwpPlwiMWUxMlwiJiYoYkw9MC41KTthdyhTKT5cIjFlMTJcIiYmKFM9MC41KTtpZihiTD4wJiZiTDwxKXtnPWFnKGksZCxSLEUsYlUsYlQsYlEsYk4sYkwpO2JSLnB1c2goZy54KTtiTy5wdXNoKGcueSl9aWYoUz4wJiZTPDEpe2c9YWcoaSxkLFIsRSxiVSxiVCxiUSxiTixTKTtiUi5wdXNoKGcueCk7Yk8ucHVzaChnLnkpfXJldHVybnttaW46e3g6Ym1bYkddKDAsYlIpLHk6Ym1bYkddKDAsYk8pfSxtYXg6e3g6bVtiR10oMCxiUikseTptW2JHXSgwLGJPKX19fSksVz1hUi5fcGF0aDJjdXJ2ZT1hRyhmdW5jdGlvbihiVSxiUCl7dmFyIGJOPSFiUCYmWShiVSk7aWYoIWJQJiZiTi5jdXJ2ZSl7cmV0dXJuIGFaKGJOLmN1cnZlKX12YXIgRT13KGJVKSxiUT1iUCYmdyhiUCksYlI9e3g6MCx5OjAsYng6MCxieTowLFg6MCxZOjAscXg6bnVsbCxxeTpudWxsfSxkPXt4OjAseTowLGJ4OjAsYnk6MCxYOjAsWTowLHF4Om51bGwscXk6bnVsbH0sUz1mdW5jdGlvbihiVixiVyl7dmFyIGksYlg7aWYoIWJWKXtyZXR1cm5bXCJDXCIsYlcueCxiVy55LGJXLngsYlcueSxiVy54LGJXLnldfSEoYlZbMF0gaW4ge1Q6MSxROjF9KSYmKGJXLnF4PWJXLnF5PW51bGwpO3N3aXRjaChiVlswXSl7Y2FzZVwiTVwiOmJXLlg9YlZbMV07YlcuWT1iVlsyXTticmVhaztjYXNlXCJBXCI6YlY9W1wiQ1wiXVtiRV0oYWVbYkddKDAsW2JXLngsYlcueV1bYkVdKGJWLnNsaWNlKDEpKSkpO2JyZWFrO2Nhc2VcIlNcIjppPWJXLngrKGJXLngtKGJXLmJ4fHxiVy54KSk7Ylg9YlcueSsoYlcueS0oYlcuYnl8fGJXLnkpKTtiVj1bXCJDXCIsaSxiWF1bYkVdKGJWLnNsaWNlKDEpKTticmVhaztjYXNlXCJUXCI6YlcucXg9YlcueCsoYlcueC0oYlcucXh8fGJXLngpKTtiVy5xeT1iVy55KyhiVy55LShiVy5xeXx8YlcueSkpO2JWPVtcIkNcIl1bYkVdKGJuKGJXLngsYlcueSxiVy5xeCxiVy5xeSxiVlsxXSxiVlsyXSkpO2JyZWFrO2Nhc2VcIlFcIjpiVy5xeD1iVlsxXTtiVy5xeT1iVlsyXTtiVj1bXCJDXCJdW2JFXShibihiVy54LGJXLnksYlZbMV0sYlZbMl0sYlZbM10sYlZbNF0pKTticmVhaztjYXNlXCJMXCI6YlY9W1wiQ1wiXVtiRV0oYkkoYlcueCxiVy55LGJWWzFdLGJWWzJdKSk7YnJlYWs7Y2FzZVwiSFwiOmJWPVtcIkNcIl1bYkVdKGJJKGJXLngsYlcueSxiVlsxXSxiVy55KSk7YnJlYWs7Y2FzZVwiVlwiOmJWPVtcIkNcIl1bYkVdKGJJKGJXLngsYlcueSxiVy54LGJWWzFdKSk7YnJlYWs7Y2FzZVwiWlwiOmJWPVtcIkNcIl1bYkVdKGJJKGJXLngsYlcueSxiVy5YLGJXLlkpKTticmVha31yZXR1cm4gYlZ9LGI9ZnVuY3Rpb24oYlYsYlcpe2lmKGJWW2JXXS5sZW5ndGg+Nyl7YlZbYlddLnNoaWZ0KCk7dmFyIGJYPWJWW2JXXTt3aGlsZShiWC5sZW5ndGgpe2JWLnNwbGljZShiVysrLDAsW1wiQ1wiXVtiRV0oYlguc3BsaWNlKDAsNikpKX1iVi5zcGxpY2UoYlcsMSk7YlM9bShFLmxlbmd0aCxiUSYmYlEubGVuZ3RofHwwKX19LGc9ZnVuY3Rpb24oYlosYlksYlcsYlYsYlgpe2lmKGJaJiZiWSYmYlpbYlhdWzBdPT1cIk1cIiYmYllbYlhdWzBdIT1cIk1cIil7Ylkuc3BsaWNlKGJYLDAsW1wiTVwiLGJWLngsYlYueV0pO2JXLmJ4PTA7YlcuYnk9MDtiVy54PWJaW2JYXVsxXTtiVy55PWJaW2JYXVsyXTtiUz1tKEUubGVuZ3RoLGJRJiZiUS5sZW5ndGh8fDApfX07Zm9yKHZhciBiTT0wLGJTPW0oRS5sZW5ndGgsYlEmJmJRLmxlbmd0aHx8MCk7Yk08YlM7Yk0rKyl7RVtiTV09UyhFW2JNXSxiUik7YihFLGJNKTtiUSYmKGJRW2JNXT1TKGJRW2JNXSxkKSk7YlEmJmIoYlEsYk0pO2coRSxiUSxiUixkLGJNKTtnKGJRLEUsZCxiUixiTSk7dmFyIGJMPUVbYk1dLGJUPWJRJiZiUVtiTV0sUj1iTC5sZW5ndGgsYk89YlEmJmJULmxlbmd0aDtiUi54PWJMW1ItMl07YlIueT1iTFtSLTFdO2JSLmJ4PWFuKGJMW1ItNF0pfHxiUi54O2JSLmJ5PWFuKGJMW1ItM10pfHxiUi55O2QuYng9YlEmJihhbihiVFtiTy00XSl8fGQueCk7ZC5ieT1iUSYmKGFuKGJUW2JPLTNdKXx8ZC55KTtkLng9YlEmJmJUW2JPLTJdO2QueT1iUSYmYlRbYk8tMV19aWYoIWJRKXtiTi5jdXJ2ZT1hWihFKVxufXJldHVybiBiUT9bRSxiUV06RX0sbnVsbCxhWiksdj1hUi5fcGFyc2VEb3RzPWFHKGZ1bmN0aW9uKGJPKXt2YXIgYk49W107Zm9yKHZhciBTPTAsYlA9Yk8ubGVuZ3RoO1M8YlA7UysrKXt2YXIgYj17fSxiTT1iT1tTXS5tYXRjaCgvXihbXjpdKik6PyhbXFxkXFwuXSopLyk7Yi5jb2xvcj1hUi5nZXRSR0IoYk1bMV0pO2lmKGIuY29sb3IuZXJyb3Ipe3JldHVybiBudWxsfWIuY29sb3I9Yi5jb2xvci5oZXg7Yk1bMl0mJihiLm9mZnNldD1iTVsyXStcIiVcIik7Yk4ucHVzaChiKX1mb3IoUz0xLGJQPWJOLmxlbmd0aC0xO1M8YlA7UysrKXtpZighYk5bU10ub2Zmc2V0KXt2YXIgZz1hbihiTltTLTFdLm9mZnNldHx8MCksRT0wO2Zvcih2YXIgUj1TKzE7UjxiUDtSKyspe2lmKGJOW1JdLm9mZnNldCl7RT1iTltSXS5vZmZzZXQ7YnJlYWt9fWlmKCFFKXtFPTEwMDtSPWJQfUU9YW4oRSk7dmFyIGJMPShFLWcpLyhSLVMrMSk7Zm9yKDtTPFI7UysrKXtnKz1iTDtiTltTXS5vZmZzZXQ9ZytcIiVcIn19fXJldHVybiBiTn0pLGFLPWFSLl90ZWFyPWZ1bmN0aW9uKGIsZCl7Yj09ZC50b3AmJihkLnRvcD1iLnByZXYpO2I9PWQuYm90dG9tJiYoZC5ib3R0b209Yi5uZXh0KTtiLm5leHQmJihiLm5leHQucHJldj1iLnByZXYpO2IucHJldiYmKGIucHJldi5uZXh0PWIubmV4dCl9LGFwPWFSLl90b2Zyb250PWZ1bmN0aW9uKGIsZCl7aWYoZC50b3A9PT1iKXtyZXR1cm59YUsoYixkKTtiLm5leHQ9bnVsbDtiLnByZXY9ZC50b3A7ZC50b3AubmV4dD1iO2QudG9wPWJ9LHA9YVIuX3RvYmFjaz1mdW5jdGlvbihiLGQpe2lmKGQuYm90dG9tPT09Yil7cmV0dXJufWFLKGIsZCk7Yi5uZXh0PWQuYm90dG9tO2IucHJldj1udWxsO2QuYm90dG9tLnByZXY9YjtkLmJvdHRvbT1ifSxHPWFSLl9pbnNlcnRhZnRlcj1mdW5jdGlvbihkLGIsZyl7YUsoZCxnKTtiPT1nLnRvcCYmKGcudG9wPWQpO2IubmV4dCYmKGIubmV4dC5wcmV2PWQpO2QubmV4dD1iLm5leHQ7ZC5wcmV2PWI7Yi5uZXh0PWR9LGFUPWFSLl9pbnNlcnRiZWZvcmU9ZnVuY3Rpb24oZCxiLGcpe2FLKGQsZyk7Yj09Zy5ib3R0b20mJihnLmJvdHRvbT1kKTtiLnByZXYmJihiLnByZXYubmV4dD1kKTtkLnByZXY9Yi5wcmV2O2IucHJldj1kO2QubmV4dD1ifSxibD1hUi50b01hdHJpeD1mdW5jdGlvbihnLGIpe3ZhciBpPWFtKGcpLGQ9e186e3RyYW5zZm9ybTphWH0sZ2V0QkJveDpmdW5jdGlvbigpe3JldHVybiBpfX07YU8oZCxiKTtyZXR1cm4gZC5tYXRyaXh9LFQ9YVIudHJhbnNmb3JtUGF0aD1mdW5jdGlvbihkLGIpe3JldHVybiBMKGQsYmwoZCxiKSl9LGFPPWFSLl9leHRyYWN0VHJhbnNmb3JtPWZ1bmN0aW9uKGQsYlope2lmKGJaPT1udWxsKXtyZXR1cm4gZC5fLnRyYW5zZm9ybX1iWj1iSChiWikucmVwbGFjZSgvXFwuezN9fFxcdTIwMjYvZyxkLl8udHJhbnNmb3JtfHxhWCk7dmFyIGJSPWFSLnBhcnNlVHJhbnNmb3JtU3RyaW5nKGJaKSxiUD0wLGJOPTAsYk09MCxiVD0xLGJTPTEsYjA9ZC5fLGJVPW5ldyBhRjtiMC50cmFuc2Zvcm09YlJ8fFtdO2lmKGJSKXtmb3IodmFyIGJWPTAsYk89YlIubGVuZ3RoO2JWPGJPO2JWKyspe3ZhciBiUT1iUltiVl0sYj1iUS5sZW5ndGgsUj1iSChiUVswXSkudG9Mb3dlckNhc2UoKSxiWT1iUVswXSE9UixiTD1iWT9iVS5pbnZlcnQoKTowLGJYLEUsYlcsZyxTO2lmKFI9PVwidFwiJiZiPT0zKXtpZihiWSl7Ylg9YkwueCgwLDApO0U9YkwueSgwLDApO2JXPWJMLngoYlFbMV0sYlFbMl0pO2c9YkwueShiUVsxXSxiUVsyXSk7YlUudHJhbnNsYXRlKGJXLWJYLGctRSl9ZWxzZXtiVS50cmFuc2xhdGUoYlFbMV0sYlFbMl0pfX1lbHNle2lmKFI9PVwiclwiKXtpZihiPT0yKXtTPVN8fGQuZ2V0QkJveCgxKTtiVS5yb3RhdGUoYlFbMV0sUy54K1Mud2lkdGgvMixTLnkrUy5oZWlnaHQvMik7YlArPWJRWzFdfWVsc2V7aWYoYj09NCl7aWYoYlkpe2JXPWJMLngoYlFbMl0sYlFbM10pO2c9YkwueShiUVsyXSxiUVszXSk7YlUucm90YXRlKGJRWzFdLGJXLGcpfWVsc2V7YlUucm90YXRlKGJRWzFdLGJRWzJdLGJRWzNdKX1iUCs9YlFbMV19fX1lbHNle2lmKFI9PVwic1wiKXtpZihiPT0yfHxiPT0zKXtTPVN8fGQuZ2V0QkJveCgxKTtiVS5zY2FsZShiUVsxXSxiUVtiLTFdLFMueCtTLndpZHRoLzIsUy55K1MuaGVpZ2h0LzIpO2JUKj1iUVsxXTtiUyo9YlFbYi0xXX1lbHNle2lmKGI9PTUpe2lmKGJZKXtiVz1iTC54KGJRWzNdLGJRWzRdKTtnPWJMLnkoYlFbM10sYlFbNF0pO2JVLnNjYWxlKGJRWzFdLGJRWzJdLGJXLGcpfWVsc2V7YlUuc2NhbGUoYlFbMV0sYlFbMl0sYlFbM10sYlFbNF0pfWJUKj1iUVsxXTtiUyo9YlFbMl19fX1lbHNle2lmKFI9PVwibVwiJiZiPT03KXtiVS5hZGQoYlFbMV0sYlFbMl0sYlFbM10sYlFbNF0sYlFbNV0sYlFbNl0pfX19fWIwLmRpcnR5VD0xO2QubWF0cml4PWJVfX1kLm1hdHJpeD1iVTtiMC5zeD1iVDtiMC5zeT1iUztiMC5kZWc9YlA7YjAuZHg9Yk49YlUuZTtiMC5keT1iTT1iVS5mO2lmKGJUPT0xJiZiUz09MSYmIWJQJiZiMC5iYm94KXtiMC5iYm94LngrPStiTjtiMC5iYm94LnkrPStiTX1lbHNle2IwLmRpcnR5VD0xfX0sbD1mdW5jdGlvbihkKXt2YXIgYj1kWzBdO3N3aXRjaChiLnRvTG93ZXJDYXNlKCkpe2Nhc2VcInRcIjpyZXR1cm5bYiwwLDBdO2Nhc2VcIm1cIjpyZXR1cm5bYiwxLDAsMCwxLDAsMF07Y2FzZVwiclwiOmlmKGQubGVuZ3RoPT00KXtyZXR1cm5bYiwwLGRbMl0sZFszXV19ZWxzZXtyZXR1cm5bYiwwXX1jYXNlXCJzXCI6aWYoZC5sZW5ndGg9PTUpe3JldHVybltiLDEsMSxkWzNdLGRbNF1dfWVsc2V7aWYoZC5sZW5ndGg9PTMpe3JldHVybltiLDEsMV19ZWxzZXtyZXR1cm5bYiwxXX19fX0sYUI9YVIuX2VxdWFsaXNlVHJhbnNmb3JtPWZ1bmN0aW9uKFIsRSl7RT1iSChFKS5yZXBsYWNlKC9cXC57M318XFx1MjAyNi9nLFIpO1I9YVIucGFyc2VUcmFuc2Zvcm1TdHJpbmcoUil8fFtdO0U9YVIucGFyc2VUcmFuc2Zvcm1TdHJpbmcoRSl8fFtdO3ZhciBiPW0oUi5sZW5ndGgsRS5sZW5ndGgpLGJOPVtdLGJPPVtdLGc9MCxkLFMsYk0sYkw7Zm9yKDtnPGI7ZysrKXtiTT1SW2ddfHxsKEVbZ10pO2JMPUVbZ118fGwoYk0pO2lmKChiTVswXSE9YkxbMF0pfHwoYk1bMF0udG9Mb3dlckNhc2UoKT09XCJyXCImJihiTVsyXSE9YkxbMl18fGJNWzNdIT1iTFszXSkpfHwoYk1bMF0udG9Mb3dlckNhc2UoKT09XCJzXCImJihiTVszXSE9YkxbM118fGJNWzRdIT1iTFs0XSkpKXtyZXR1cm59Yk5bZ109W107Yk9bZ109W107Zm9yKGQ9MCxTPW0oYk0ubGVuZ3RoLGJMLmxlbmd0aCk7ZDxTO2QrKyl7ZCBpbiBiTSYmKGJOW2ddW2RdPWJNW2RdKTtkIGluIGJMJiYoYk9bZ11bZF09YkxbZF0pfX1yZXR1cm57ZnJvbTpiTix0bzpiT319O2FSLl9nZXRDb250YWluZXI9ZnVuY3Rpb24oYixFLGcsaSl7dmFyIGQ7ZD1pPT1udWxsJiYhYVIuaXMoYixcIm9iamVjdFwiKT9hQS5kb2MuZ2V0RWxlbWVudEJ5SWQoYik6YjtpZihkPT1udWxsKXtyZXR1cm59aWYoZC50YWdOYW1lKXtpZihFPT1udWxsKXtyZXR1cm57Y29udGFpbmVyOmQsd2lkdGg6ZC5zdHlsZS5waXhlbFdpZHRofHxkLm9mZnNldFdpZHRoLGhlaWdodDpkLnN0eWxlLnBpeGVsSGVpZ2h0fHxkLm9mZnNldEhlaWdodH19ZWxzZXtyZXR1cm57Y29udGFpbmVyOmQsd2lkdGg6RSxoZWlnaHQ6Z319fXJldHVybntjb250YWluZXI6MSx4OmIseTpFLHdpZHRoOmcsaGVpZ2h0Oml9fTthUi5wYXRoVG9SZWxhdGl2ZT1hQzthUi5fZW5naW5lPXt9O2FSLnBhdGgyY3VydmU9VzthUi5tYXRyaXg9ZnVuY3Rpb24oaSxnLGJMLFMsUixFKXtyZXR1cm4gbmV3IGFGKGksZyxiTCxTLFIsRSl9O2Z1bmN0aW9uIGFGKGksZyxiTCxTLFIsRSl7aWYoaSE9bnVsbCl7dGhpcy5hPStpO3RoaXMuYj0rZzt0aGlzLmM9K2JMO3RoaXMuZD0rUzt0aGlzLmU9K1I7dGhpcy5mPStFfWVsc2V7dGhpcy5hPTE7dGhpcy5iPTA7dGhpcy5jPTA7dGhpcy5kPTE7dGhpcy5lPTA7dGhpcy5mPTB9fShmdW5jdGlvbihnKXtnLmFkZD1mdW5jdGlvbihiVCxiUSxiTyxiTSxTLFIpe3ZhciBFPVtbXSxbXSxbXV0saT1bW3RoaXMuYSx0aGlzLmMsdGhpcy5lXSxbdGhpcy5iLHRoaXMuZCx0aGlzLmZdLFswLDAsMV1dLGJTPVtbYlQsYk8sU10sW2JRLGJNLFJdLFswLDAsMV1dLGJSLGJQLGJOLGJMO2lmKGJUJiZiVCBpbnN0YW5jZW9mIGFGKXtiUz1bW2JULmEsYlQuYyxiVC5lXSxbYlQuYixiVC5kLGJULmZdLFswLDAsMV1dfWZvcihiUj0wO2JSPDM7YlIrKyl7Zm9yKGJQPTA7YlA8MztiUCsrKXtiTD0wO2ZvcihiTj0wO2JOPDM7Yk4rKyl7YkwrPWlbYlJdW2JOXSpiU1tiTl1bYlBdfUVbYlJdW2JQXT1iTH19dGhpcy5hPUVbMF1bMF07dGhpcy5iPUVbMV1bMF07dGhpcy5jPUVbMF1bMV07dGhpcy5kPUVbMV1bMV07dGhpcy5lPUVbMF1bMl07dGhpcy5mPUVbMV1bMl19O2cuaW52ZXJ0PWZ1bmN0aW9uKCl7dmFyIEU9dGhpcyxpPUUuYSpFLmQtRS5iKkUuYztyZXR1cm4gbmV3IGFGKEUuZC9pLC1FLmIvaSwtRS5jL2ksRS5hL2ksKEUuYypFLmYtRS5kKkUuZSkvaSwoRS5iKkUuZS1FLmEqRS5mKS9pKX07Zy5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYUYodGhpcy5hLHRoaXMuYix0aGlzLmMsdGhpcy5kLHRoaXMuZSx0aGlzLmYpfTtnLnRyYW5zbGF0ZT1mdW5jdGlvbihpLEUpe3RoaXMuYWRkKDEsMCwwLDEsaSxFKX07Zy5zY2FsZT1mdW5jdGlvbihFLFMsaSxSKXtTPT1udWxsJiYoUz1FKTsoaXx8UikmJnRoaXMuYWRkKDEsMCwwLDEsaSxSKTt0aGlzLmFkZChFLDAsMCxTLDAsMCk7KGl8fFIpJiZ0aGlzLmFkZCgxLDAsMCwxLC1pLC1SKX07Zy5yb3RhdGU9ZnVuY3Rpb24oRSxpLGJMKXtFPWFSLnJhZChFKTtpPWl8fDA7Ykw9Ykx8fDA7dmFyIFM9K2F1LmNvcyhFKS50b0ZpeGVkKDkpLFI9K2F1LnNpbihFKS50b0ZpeGVkKDkpO3RoaXMuYWRkKFMsUiwtUixTLGksYkwpO3RoaXMuYWRkKDEsMCwwLDEsLWksLWJMKX07Zy54PWZ1bmN0aW9uKGksRSl7cmV0dXJuIGkqdGhpcy5hK0UqdGhpcy5jK3RoaXMuZX07Zy55PWZ1bmN0aW9uKGksRSl7cmV0dXJuIGkqdGhpcy5iK0UqdGhpcy5kK3RoaXMuZn07Zy5nZXQ9ZnVuY3Rpb24oRSl7cmV0dXJuICt0aGlzW2JILmZyb21DaGFyQ29kZSg5NytFKV0udG9GaXhlZCg0KX07Zy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBhUi5zdmc/XCJtYXRyaXgoXCIrW3RoaXMuZ2V0KDApLHRoaXMuZ2V0KDEpLHRoaXMuZ2V0KDIpLHRoaXMuZ2V0KDMpLHRoaXMuZ2V0KDQpLHRoaXMuZ2V0KDUpXS5qb2luKCkrXCIpXCI6W3RoaXMuZ2V0KDApLHRoaXMuZ2V0KDIpLHRoaXMuZ2V0KDEpLHRoaXMuZ2V0KDMpLDAsMF0uam9pbigpfTtnLnRvRmlsdGVyPWZ1bmN0aW9uKCl7cmV0dXJuXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT1cIit0aGlzLmdldCgwKStcIiwgTTEyPVwiK3RoaXMuZ2V0KDIpK1wiLCBNMjE9XCIrdGhpcy5nZXQoMSkrXCIsIE0yMj1cIit0aGlzLmdldCgzKStcIiwgRHg9XCIrdGhpcy5nZXQoNCkrXCIsIER5PVwiK3RoaXMuZ2V0KDUpK1wiLCBzaXppbmdtZXRob2Q9J2F1dG8gZXhwYW5kJylcIn07Zy5vZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5lLnRvRml4ZWQoNCksdGhpcy5mLnRvRml4ZWQoNCldfTtmdW5jdGlvbiBkKGkpe3JldHVybiBpWzBdKmlbMF0raVsxXSppWzFdfWZ1bmN0aW9uIGIoaSl7dmFyIEU9YXUuc3FydChkKGkpKTtpWzBdJiYoaVswXS89RSk7aVsxXSYmKGlbMV0vPUUpfWcuc3BsaXQ9ZnVuY3Rpb24oKXt2YXIgRT17fTtFLmR4PXRoaXMuZTtFLmR5PXRoaXMuZjt2YXIgUz1bW3RoaXMuYSx0aGlzLmNdLFt0aGlzLmIsdGhpcy5kXV07RS5zY2FsZXg9YXUuc3FydChkKFNbMF0pKTtiKFNbMF0pO0Uuc2hlYXI9U1swXVswXSpTWzFdWzBdK1NbMF1bMV0qU1sxXVsxXTtTWzFdPVtTWzFdWzBdLVNbMF1bMF0qRS5zaGVhcixTWzFdWzFdLVNbMF1bMV0qRS5zaGVhcl07RS5zY2FsZXk9YXUuc3FydChkKFNbMV0pKTtiKFNbMV0pO0Uuc2hlYXIvPUUuc2NhbGV5O3ZhciBpPS1TWzBdWzFdLFI9U1sxXVsxXTtpZihSPDApe0Uucm90YXRlPWFSLmRlZyhhdS5hY29zKFIpKTtpZihpPDApe0Uucm90YXRlPTM2MC1FLnJvdGF0ZX19ZWxzZXtFLnJvdGF0ZT1hUi5kZWcoYXUuYXNpbihpKSl9RS5pc1NpbXBsZT0hK0Uuc2hlYXIudG9GaXhlZCg5KSYmKEUuc2NhbGV4LnRvRml4ZWQoOSk9PUUuc2NhbGV5LnRvRml4ZWQoOSl8fCFFLnJvdGF0ZSk7RS5pc1N1cGVyU2ltcGxlPSErRS5zaGVhci50b0ZpeGVkKDkpJiZFLnNjYWxleC50b0ZpeGVkKDkpPT1FLnNjYWxleS50b0ZpeGVkKDkpJiYhRS5yb3RhdGU7RS5ub1JvdGF0aW9uPSErRS5zaGVhci50b0ZpeGVkKDkpJiYhRS5yb3RhdGU7cmV0dXJuIEV9O2cudG9UcmFuc2Zvcm1TdHJpbmc9ZnVuY3Rpb24oaSl7dmFyIEU9aXx8dGhpc1tGXSgpO2lmKEUuaXNTaW1wbGUpe0Uuc2NhbGV4PStFLnNjYWxleC50b0ZpeGVkKDQpO0Uuc2NhbGV5PStFLnNjYWxleS50b0ZpeGVkKDQpO0Uucm90YXRlPStFLnJvdGF0ZS50b0ZpeGVkKDQpO3JldHVybihFLmR4fHxFLmR5P1widFwiK1tFLmR4LEUuZHldOmFYKSsoRS5zY2FsZXghPTF8fEUuc2NhbGV5IT0xP1wic1wiK1tFLnNjYWxleCxFLnNjYWxleSwwLDBdOmFYKSsoRS5yb3RhdGU/XCJyXCIrW0Uucm90YXRlLDAsMF06YVgpfWVsc2V7cmV0dXJuXCJtXCIrW3RoaXMuZ2V0KDApLHRoaXMuZ2V0KDEpLHRoaXMuZ2V0KDIpLHRoaXMuZ2V0KDMpLHRoaXMuZ2V0KDQpLHRoaXMuZ2V0KDUpXX19fSkoYUYucHJvdG90eXBlKTt2YXIgVj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKC4qPylcXHMvKXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7aWYoKG5hdmlnYXRvci52ZW5kb3I9PVwiQXBwbGUgQ29tcHV0ZXIsIEluYy5cIikmJihWJiZWWzFdPDR8fG5hdmlnYXRvci5wbGF0Zm9ybS5zbGljZSgwLDIpPT1cImlQXCIpfHwobmF2aWdhdG9yLnZlbmRvcj09XCJHb29nbGUgSW5jLlwiJiZWJiZWWzFdPDgpKXthNC5zYWZhcmk9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLnJlY3QoLTk5LC05OSx0aGlzLndpZHRoKzk5LHRoaXMuaGVpZ2h0Kzk5KS5hdHRyKHtzdHJva2U6XCJub25lXCJ9KTtcbnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnJlbW92ZSgpfSl9fWVsc2V7YTQuc2FmYXJpPUl9dmFyIFA9ZnVuY3Rpb24oKXt0aGlzLnJldHVyblZhbHVlPWZhbHNlfSxiRD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKX0sYTg9ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbEJ1YmJsZT10cnVlfSxhSj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9LGFEPShmdW5jdGlvbigpe2lmKGFBLmRvYy5hZGRFdmVudExpc3RlbmVyKXtyZXR1cm4gZnVuY3Rpb24oUixpLGcsZCl7dmFyIGI9WiYmYnhbaV0/YnhbaV06aSxFPWZ1bmN0aW9uKGJQKXt2YXIgYk89YUEuZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B8fGFBLmRvYy5ib2R5LnNjcm9sbFRvcCxiUT1hQS5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnR8fGFBLmRvYy5ib2R5LnNjcm9sbExlZnQsUz1iUC5jbGllbnRYK2JRLGJSPWJQLmNsaWVudFkrYk87aWYoWiYmYnhbYWtdKGkpKXtmb3IodmFyIGJNPTAsYk49YlAudGFyZ2V0VG91Y2hlcyYmYlAudGFyZ2V0VG91Y2hlcy5sZW5ndGg7Yk08Yk47Yk0rKyl7aWYoYlAudGFyZ2V0VG91Y2hlc1tiTV0udGFyZ2V0PT1SKXt2YXIgYkw9YlA7YlA9YlAudGFyZ2V0VG91Y2hlc1tiTV07YlAub3JpZ2luYWxFdmVudD1iTDtiUC5wcmV2ZW50RGVmYXVsdD1iRDtiUC5zdG9wUHJvcGFnYXRpb249YUo7YnJlYWt9fX1yZXR1cm4gZy5jYWxsKGQsYlAsUyxiUil9O1IuYWRkRXZlbnRMaXN0ZW5lcihiLEUsZmFsc2UpO3JldHVybiBmdW5jdGlvbigpe1IucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLEUsZmFsc2UpO3JldHVybiB0cnVlfX19ZWxzZXtpZihhQS5kb2MuYXR0YWNoRXZlbnQpe3JldHVybiBmdW5jdGlvbihSLGksZyxkKXt2YXIgRT1mdW5jdGlvbihiTSl7Yk09Yk18fGFBLndpbi5ldmVudDt2YXIgYkw9YUEuZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B8fGFBLmRvYy5ib2R5LnNjcm9sbFRvcCxiTj1hQS5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnR8fGFBLmRvYy5ib2R5LnNjcm9sbExlZnQsUz1iTS5jbGllbnRYK2JOLGJPPWJNLmNsaWVudFkrYkw7Yk0ucHJldmVudERlZmF1bHQ9Yk0ucHJldmVudERlZmF1bHR8fFA7Yk0uc3RvcFByb3BhZ2F0aW9uPWJNLnN0b3BQcm9wYWdhdGlvbnx8YTg7cmV0dXJuIGcuY2FsbChkLGJNLFMsYk8pfTtSLmF0dGFjaEV2ZW50KFwib25cIitpLEUpO3ZhciBiPWZ1bmN0aW9uKCl7Ui5kZXRhY2hFdmVudChcIm9uXCIraSxFKTtyZXR1cm4gdHJ1ZX07cmV0dXJuIGJ9fX19KSgpLGJlPVtdLGJ5PWZ1bmN0aW9uKGJNKXt2YXIgYlA9Yk0uY2xpZW50WCxiTz1iTS5jbGllbnRZLGJSPWFBLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfHxhQS5kb2MuYm9keS5zY3JvbGxUb3AsYlM9YUEuZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0fHxhQS5kb2MuYm9keS5zY3JvbGxMZWZ0LGcsRT1iZS5sZW5ndGg7d2hpbGUoRS0tKXtnPWJlW0VdO2lmKFope3ZhciBTPWJNLnRvdWNoZXMubGVuZ3RoLFI7d2hpbGUoUy0tKXtSPWJNLnRvdWNoZXNbU107aWYoUi5pZGVudGlmaWVyPT1nLmVsLl9kcmFnLmlkKXtiUD1SLmNsaWVudFg7Yk89Ui5jbGllbnRZOyhiTS5vcmlnaW5hbEV2ZW50P2JNLm9yaWdpbmFsRXZlbnQ6Yk0pLnByZXZlbnREZWZhdWx0KCk7YnJlYWt9fX1lbHNle2JNLnByZXZlbnREZWZhdWx0KCl9dmFyIGQ9Zy5lbC5ub2RlLGIsYkw9ZC5uZXh0U2libGluZyxiUT1kLnBhcmVudE5vZGUsYk49ZC5zdHlsZS5kaXNwbGF5O2FBLndpbi5vcGVyYSYmYlEucmVtb3ZlQ2hpbGQoZCk7ZC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO2I9Zy5lbC5wYXBlci5nZXRFbGVtZW50QnlQb2ludChiUCxiTyk7ZC5zdHlsZS5kaXNwbGF5PWJOO2FBLndpbi5vcGVyYSYmKGJMP2JRLmluc2VydEJlZm9yZShkLGJMKTpiUS5hcHBlbmRDaGlsZChkKSk7YiYmZXZlKFwicmFwaGFlbC5kcmFnLm92ZXIuXCIrZy5lbC5pZCxnLmVsLGIpO2JQKz1iUztiTys9YlI7ZXZlKFwicmFwaGFlbC5kcmFnLm1vdmUuXCIrZy5lbC5pZCxnLm1vdmVfc2NvcGV8fGcuZWwsYlAtZy5lbC5fZHJhZy54LGJPLWcuZWwuX2RyYWcueSxiUCxiTyxiTSl9fSxlPWZ1bmN0aW9uKGcpe2FSLnVubW91c2Vtb3ZlKGJ5KS51bm1vdXNldXAoZSk7dmFyIGQ9YmUubGVuZ3RoLGI7d2hpbGUoZC0tKXtiPWJlW2RdO2IuZWwuX2RyYWc9e307ZXZlKFwicmFwaGFlbC5kcmFnLmVuZC5cIitiLmVsLmlkLGIuZW5kX3Njb3BlfHxiLnN0YXJ0X3Njb3BlfHxiLm1vdmVfc2NvcGV8fGIuZWwsZyl9YmU9W119LGJoPWFSLmVsPXt9O2Zvcih2YXIgYXg9US5sZW5ndGg7YXgtLTspeyhmdW5jdGlvbihiKXthUltiXT1iaFtiXT1mdW5jdGlvbihnLGQpe2lmKGFSLmlzKGcsXCJmdW5jdGlvblwiKSl7dGhpcy5ldmVudHM9dGhpcy5ldmVudHN8fFtdO3RoaXMuZXZlbnRzLnB1c2goe25hbWU6YixmOmcsdW5iaW5kOmFEKHRoaXMuc2hhcGV8fHRoaXMubm9kZXx8YUEuZG9jLGIsZyxkfHx0aGlzKX0pfXJldHVybiB0aGlzfTthUltcInVuXCIrYl09YmhbXCJ1blwiK2JdPWZ1bmN0aW9uKGkpe3ZhciBnPXRoaXMuZXZlbnRzfHxbXSxkPWcubGVuZ3RoO3doaWxlKGQtLSl7aWYoZ1tkXS5uYW1lPT1iJiZnW2RdLmY9PWkpe2dbZF0udW5iaW5kKCk7Zy5zcGxpY2UoZCwxKTshZy5sZW5ndGgmJmRlbGV0ZSB0aGlzLmV2ZW50cztyZXR1cm4gdGhpc319cmV0dXJuIHRoaXN9fSkoUVtheF0pfWJoLmRhdGE9ZnVuY3Rpb24oZCxFKXt2YXIgZz1hVVt0aGlzLmlkXT1hVVt0aGlzLmlkXXx8e307aWYoYXJndW1lbnRzLmxlbmd0aD09MSl7aWYoYVIuaXMoZCxcIm9iamVjdFwiKSl7Zm9yKHZhciBiIGluIGQpe2lmKGRbYWtdKGIpKXt0aGlzLmRhdGEoYixkW2JdKX19cmV0dXJuIHRoaXN9ZXZlKFwicmFwaGFlbC5kYXRhLmdldC5cIit0aGlzLmlkLHRoaXMsZ1tkXSxkKTtyZXR1cm4gZ1tkXX1nW2RdPUU7ZXZlKFwicmFwaGFlbC5kYXRhLnNldC5cIit0aGlzLmlkLHRoaXMsRSxkKTtyZXR1cm4gdGhpc307YmgucmVtb3ZlRGF0YT1mdW5jdGlvbihiKXtpZihiPT1udWxsKXthVVt0aGlzLmlkXT17fX1lbHNle2FVW3RoaXMuaWRdJiZkZWxldGUgYVVbdGhpcy5pZF1bYl19cmV0dXJuIHRoaXN9O2JoLmhvdmVyPWZ1bmN0aW9uKGksYixnLGQpe3JldHVybiB0aGlzLm1vdXNlb3ZlcihpLGcpLm1vdXNlb3V0KGIsZHx8Zyl9O2JoLnVuaG92ZXI9ZnVuY3Rpb24oZCxiKXtyZXR1cm4gdGhpcy51bm1vdXNlb3ZlcihkKS51bm1vdXNlb3V0KGIpfTt2YXIgYnU9W107YmguZHJhZz1mdW5jdGlvbihkLFIsRSxiLGcsaSl7ZnVuY3Rpb24gUyhiTSl7KGJNLm9yaWdpbmFsRXZlbnR8fGJNKS5wcmV2ZW50RGVmYXVsdCgpO3ZhciBiTD1hQS5kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcHx8YUEuZG9jLmJvZHkuc2Nyb2xsVG9wLGJOPWFBLmRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdHx8YUEuZG9jLmJvZHkuc2Nyb2xsTGVmdDt0aGlzLl9kcmFnLng9Yk0uY2xpZW50WCtiTjt0aGlzLl9kcmFnLnk9Yk0uY2xpZW50WStiTDt0aGlzLl9kcmFnLmlkPWJNLmlkZW50aWZpZXI7IWJlLmxlbmd0aCYmYVIubW91c2Vtb3ZlKGJ5KS5tb3VzZXVwKGUpO2JlLnB1c2goe2VsOnRoaXMsbW92ZV9zY29wZTpiLHN0YXJ0X3Njb3BlOmcsZW5kX3Njb3BlOml9KTtSJiZldmUub24oXCJyYXBoYWVsLmRyYWcuc3RhcnQuXCIrdGhpcy5pZCxSKTtkJiZldmUub24oXCJyYXBoYWVsLmRyYWcubW92ZS5cIit0aGlzLmlkLGQpO0UmJmV2ZS5vbihcInJhcGhhZWwuZHJhZy5lbmQuXCIrdGhpcy5pZCxFKTtldmUoXCJyYXBoYWVsLmRyYWcuc3RhcnQuXCIrdGhpcy5pZCxnfHxifHx0aGlzLGJNLmNsaWVudFgrYk4sYk0uY2xpZW50WStiTCxiTSl9dGhpcy5fZHJhZz17fTtidS5wdXNoKHtlbDp0aGlzLHN0YXJ0OlN9KTt0aGlzLm1vdXNlZG93bihTKTtyZXR1cm4gdGhpc307Ymgub25EcmFnT3Zlcj1mdW5jdGlvbihiKXtiP2V2ZS5vbihcInJhcGhhZWwuZHJhZy5vdmVyLlwiK3RoaXMuaWQsYik6ZXZlLnVuYmluZChcInJhcGhhZWwuZHJhZy5vdmVyLlwiK3RoaXMuaWQpfTtiaC51bmRyYWc9ZnVuY3Rpb24oKXt2YXIgYj1idS5sZW5ndGg7d2hpbGUoYi0tKXtpZihidVtiXS5lbD09dGhpcyl7dGhpcy51bm1vdXNlZG93bihidVtiXS5zdGFydCk7YnUuc3BsaWNlKGIsMSk7ZXZlLnVuYmluZChcInJhcGhhZWwuZHJhZy4qLlwiK3RoaXMuaWQpfX0hYnUubGVuZ3RoJiZhUi51bm1vdXNlbW92ZShieSkudW5tb3VzZXVwKGUpfTthNC5jaXJjbGU9ZnVuY3Rpb24oYixpLGcpe3ZhciBkPWFSLl9lbmdpbmUuY2lyY2xlKHRoaXMsYnx8MCxpfHwwLGd8fDApO3RoaXMuX19zZXRfXyYmdGhpcy5fX3NldF9fLnB1c2goZCk7cmV0dXJuIGR9O2E0LnJlY3Q9ZnVuY3Rpb24oYixSLGQsaSxFKXt2YXIgZz1hUi5fZW5naW5lLnJlY3QodGhpcyxifHwwLFJ8fDAsZHx8MCxpfHwwLEV8fDApO3RoaXMuX19zZXRfXyYmdGhpcy5fX3NldF9fLnB1c2goZyk7cmV0dXJuIGd9O2E0LmVsbGlwc2U9ZnVuY3Rpb24oYixFLGksZyl7dmFyIGQ9YVIuX2VuZ2luZS5lbGxpcHNlKHRoaXMsYnx8MCxFfHwwLGl8fDAsZ3x8MCk7dGhpcy5fX3NldF9fJiZ0aGlzLl9fc2V0X18ucHVzaChkKTtyZXR1cm4gZH07YTQucGF0aD1mdW5jdGlvbihiKXtiJiYhYVIuaXMoYixhaikmJiFhUi5pcyhiWzBdLGJkKSYmKGIrPWFYKTt2YXIgZD1hUi5fZW5naW5lLnBhdGgoYVIuZm9ybWF0W2JHXShhUixhcmd1bWVudHMpLHRoaXMpO3RoaXMuX19zZXRfXyYmdGhpcy5fX3NldF9fLnB1c2goZCk7cmV0dXJuIGR9O2E0LmltYWdlPWZ1bmN0aW9uKEUsYixSLGQsaSl7dmFyIGc9YVIuX2VuZ2luZS5pbWFnZSh0aGlzLEV8fFwiYWJvdXQ6YmxhbmtcIixifHwwLFJ8fDAsZHx8MCxpfHwwKTt0aGlzLl9fc2V0X18mJnRoaXMuX19zZXRfXy5wdXNoKGcpO3JldHVybiBnfTthNC50ZXh0PWZ1bmN0aW9uKGIsaSxnKXt2YXIgZD1hUi5fZW5naW5lLnRleHQodGhpcyxifHwwLGl8fDAsYkgoZykpO3RoaXMuX19zZXRfXyYmdGhpcy5fX3NldF9fLnB1c2goZCk7cmV0dXJuIGR9O2E0LnNldD1mdW5jdGlvbihkKXshYVIuaXMoZCxcImFycmF5XCIpJiYoZD1BcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLDAsYXJndW1lbnRzLmxlbmd0aCkpO3ZhciBiPW5ldyBhbChkKTt0aGlzLl9fc2V0X18mJnRoaXMuX19zZXRfXy5wdXNoKGIpO3JldHVybiBifTthNC5zZXRTdGFydD1mdW5jdGlvbihiKXt0aGlzLl9fc2V0X189Ynx8dGhpcy5zZXQoKX07YTQuc2V0RmluaXNoPWZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMuX19zZXRfXztkZWxldGUgdGhpcy5fX3NldF9fO3JldHVybiBifTthNC5zZXRTaXplPWZ1bmN0aW9uKGQsYil7cmV0dXJuIGFSLl9lbmdpbmUuc2V0U2l6ZS5jYWxsKHRoaXMsZCxiKX07YTQuc2V0Vmlld0JveD1mdW5jdGlvbihiLEUsZCxpLGcpe3JldHVybiBhUi5fZW5naW5lLnNldFZpZXdCb3guY2FsbCh0aGlzLGIsRSxkLGksZyl9O2E0LnRvcD1hNC5ib3R0b209bnVsbDthNC5yYXBoYWVsPWFSO3ZhciBicz1mdW5jdGlvbihnKXt2YXIgRT1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGJNPWcub3duZXJEb2N1bWVudCxSPWJNLmJvZHksYj1iTS5kb2N1bWVudEVsZW1lbnQsaT1iLmNsaWVudFRvcHx8Ui5jbGllbnRUb3B8fDAsUz1iLmNsaWVudExlZnR8fFIuY2xpZW50TGVmdHx8MCxiTD1FLnRvcCsoYUEud2luLnBhZ2VZT2Zmc2V0fHxiLnNjcm9sbFRvcHx8Ui5zY3JvbGxUb3ApLWksZD1FLmxlZnQrKGFBLndpbi5wYWdlWE9mZnNldHx8Yi5zY3JvbGxMZWZ0fHxSLnNjcm9sbExlZnQpLVM7cmV0dXJue3k6YkwseDpkfX07YTQuZ2V0RWxlbWVudEJ5UG9pbnQ9ZnVuY3Rpb24oZCxiTCl7dmFyIFM9dGhpcyxnPVMuY2FudmFzLFI9YUEuZG9jLmVsZW1lbnRGcm9tUG9pbnQoZCxiTCk7aWYoYUEud2luLm9wZXJhJiZSLnRhZ05hbWU9PVwic3ZnXCIpe3ZhciBFPWJzKGcpLGk9Zy5jcmVhdGVTVkdSZWN0KCk7aS54PWQtRS54O2kueT1iTC1FLnk7aS53aWR0aD1pLmhlaWdodD0xO3ZhciBiPWcuZ2V0SW50ZXJzZWN0aW9uTGlzdChpLG51bGwpO2lmKGIubGVuZ3RoKXtSPWJbYi5sZW5ndGgtMV19fWlmKCFSKXtyZXR1cm4gbnVsbH13aGlsZShSLnBhcmVudE5vZGUmJlIhPWcucGFyZW50Tm9kZSYmIVIucmFwaGFlbCl7Uj1SLnBhcmVudE5vZGV9Uj09Uy5jYW52YXMucGFyZW50Tm9kZSYmKFI9Zyk7Uj1SJiZSLnJhcGhhZWw/Uy5nZXRCeUlkKFIucmFwaGFlbGlkKTpudWxsO3JldHVybiBSfTthNC5nZXRCeUlkPWZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMuYm90dG9tO3doaWxlKGIpe2lmKGIuaWQ9PWQpe3JldHVybiBifWI9Yi5uZXh0fXJldHVybiBudWxsfTthNC5mb3JFYWNoPWZ1bmN0aW9uKGcsYil7dmFyIGQ9dGhpcy5ib3R0b207d2hpbGUoZCl7aWYoZy5jYWxsKGIsZCk9PT1mYWxzZSl7cmV0dXJuIHRoaXN9ZD1kLm5leHR9cmV0dXJuIHRoaXN9O2E0LmdldEVsZW1lbnRzQnlQb2ludD1mdW5jdGlvbihiLGcpe3ZhciBkPXRoaXMuc2V0KCk7dGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGkpe2lmKGkuaXNQb2ludEluc2lkZShiLGcpKXtkLnB1c2goaSl9fSk7cmV0dXJuIGR9O2Z1bmN0aW9uIHkoKXtyZXR1cm4gdGhpcy54K2FRK3RoaXMueX1mdW5jdGlvbiBhdCgpe3JldHVybiB0aGlzLngrYVErdGhpcy55K2FRK3RoaXMud2lkdGgrXCIgXFx4ZDcgXCIrdGhpcy5oZWlnaHR9YmguaXNQb2ludEluc2lkZT1mdW5jdGlvbihiLGcpe3ZhciBkPXRoaXMucmVhbFBhdGg9dGhpcy5yZWFsUGF0aHx8Tlt0aGlzLnR5cGVdKHRoaXMpO3JldHVybiBhUi5pc1BvaW50SW5zaWRlUGF0aChkLGIsZyl9O2JoLmdldEJCb3g9ZnVuY3Rpb24oZCl7aWYodGhpcy5yZW1vdmVkKXtyZXR1cm57fX12YXIgYj10aGlzLl87aWYoZCl7aWYoYi5kaXJ0eXx8IWIuYmJveHd0KXt0aGlzLnJlYWxQYXRoPU5bdGhpcy50eXBlXSh0aGlzKTtiLmJib3h3dD1hbSh0aGlzLnJlYWxQYXRoKTtiLmJib3h3dC50b1N0cmluZz1hdDtiLmRpcnR5PTB9cmV0dXJuIGIuYmJveHd0fWlmKGIuZGlydHl8fGIuZGlydHlUfHwhYi5iYm94KXtpZihiLmRpcnR5fHwhdGhpcy5yZWFsUGF0aCl7Yi5iYm94d3Q9MDtcbnRoaXMucmVhbFBhdGg9Tlt0aGlzLnR5cGVdKHRoaXMpfWIuYmJveD1hbShMKHRoaXMucmVhbFBhdGgsdGhpcy5tYXRyaXgpKTtiLmJib3gudG9TdHJpbmc9YXQ7Yi5kaXJ0eT1iLmRpcnR5VD0wfXJldHVybiBiLmJib3h9O2JoLmNsb25lPWZ1bmN0aW9uKCl7aWYodGhpcy5yZW1vdmVkKXtyZXR1cm4gbnVsbH12YXIgYj10aGlzLnBhcGVyW3RoaXMudHlwZV0oKS5hdHRyKHRoaXMuYXR0cigpKTt0aGlzLl9fc2V0X18mJnRoaXMuX19zZXRfXy5wdXNoKGIpO3JldHVybiBifTtiaC5nbG93PWZ1bmN0aW9uKGJMKXtpZih0aGlzLnR5cGU9PVwidGV4dFwiKXtyZXR1cm4gbnVsbH1iTD1iTHx8e307dmFyIGc9e3dpZHRoOihiTC53aWR0aHx8MTApKygrdGhpcy5hdHRyKFwic3Ryb2tlLXdpZHRoXCIpfHwxKSxmaWxsOmJMLmZpbGx8fGZhbHNlLG9wYWNpdHk6Ykwub3BhY2l0eXx8MC41LG9mZnNldHg6Ykwub2Zmc2V0eHx8MCxvZmZzZXR5OmJMLm9mZnNldHl8fDAsY29sb3I6YkwuY29sb3J8fFwiIzAwMFwifSxTPWcud2lkdGgvMixFPXRoaXMucGFwZXIsYj1FLnNldCgpLFI9dGhpcy5yZWFsUGF0aHx8Tlt0aGlzLnR5cGVdKHRoaXMpO1I9dGhpcy5tYXRyaXg/TChSLHRoaXMubWF0cml4KTpSO2Zvcih2YXIgZD0xO2Q8UysxO2QrKyl7Yi5wdXNoKEUucGF0aChSKS5hdHRyKHtzdHJva2U6Zy5jb2xvcixmaWxsOmcuZmlsbD9nLmNvbG9yOlwibm9uZVwiLFwic3Ryb2tlLWxpbmVqb2luXCI6XCJyb3VuZFwiLFwic3Ryb2tlLWxpbmVjYXBcIjpcInJvdW5kXCIsXCJzdHJva2Utd2lkdGhcIjorKGcud2lkdGgvUypkKS50b0ZpeGVkKDMpLG9wYWNpdHk6KyhnLm9wYWNpdHkvUykudG9GaXhlZCgzKX0pKX1yZXR1cm4gYi5pbnNlcnRCZWZvcmUodGhpcykudHJhbnNsYXRlKGcub2Zmc2V0eCxnLm9mZnNldHkpfTt2YXIgYTc9e30saz1mdW5jdGlvbihkLGIsRSxpLGJNLGJMLFMsUixnKXtpZihnPT1udWxsKXtyZXR1cm4gcShkLGIsRSxpLGJNLGJMLFMsUil9ZWxzZXtyZXR1cm4gYVIuZmluZERvdHNBdFNlZ21lbnQoZCxiLEUsaSxiTSxiTCxTLFIsQyhkLGIsRSxpLGJNLGJMLFMsUixnKSl9fSxhNj1mdW5jdGlvbihiLGQpe3JldHVybiBmdW5jdGlvbihiVCxSLFMpe2JUPVcoYlQpO3ZhciBiUCxiTyxnLGJMLEU9XCJcIixiUz17fSxiUSxiTj0wO2Zvcih2YXIgYk09MCxiUj1iVC5sZW5ndGg7Yk08YlI7Yk0rKyl7Zz1iVFtiTV07aWYoZ1swXT09XCJNXCIpe2JQPStnWzFdO2JPPStnWzJdfWVsc2V7Ykw9ayhiUCxiTyxnWzFdLGdbMl0sZ1szXSxnWzRdLGdbNV0sZ1s2XSk7aWYoYk4rYkw+Uil7aWYoZCYmIWJTLnN0YXJ0KXtiUT1rKGJQLGJPLGdbMV0sZ1syXSxnWzNdLGdbNF0sZ1s1XSxnWzZdLFItYk4pO0UrPVtcIkNcIitiUS5zdGFydC54LGJRLnN0YXJ0LnksYlEubS54LGJRLm0ueSxiUS54LGJRLnldO2lmKFMpe3JldHVybiBFfWJTLnN0YXJ0PUU7RT1bXCJNXCIrYlEueCxiUS55K1wiQ1wiK2JRLm4ueCxiUS5uLnksYlEuZW5kLngsYlEuZW5kLnksZ1s1XSxnWzZdXS5qb2luKCk7Yk4rPWJMO2JQPStnWzVdO2JPPStnWzZdO2NvbnRpbnVlfWlmKCFiJiYhZCl7YlE9ayhiUCxiTyxnWzFdLGdbMl0sZ1szXSxnWzRdLGdbNV0sZ1s2XSxSLWJOKTtyZXR1cm57eDpiUS54LHk6YlEueSxhbHBoYTpiUS5hbHBoYX19fWJOKz1iTDtiUD0rZ1s1XTtiTz0rZ1s2XX1FKz1nLnNoaWZ0KCkrZ31iUy5lbmQ9RTtiUT1iP2JOOmQ/YlM6YVIuZmluZERvdHNBdFNlZ21lbnQoYlAsYk8sZ1swXSxnWzFdLGdbMl0sZ1szXSxnWzRdLGdbNV0sMSk7YlEuYWxwaGEmJihiUT17eDpiUS54LHk6YlEueSxhbHBoYTpiUS5hbHBoYX0pO3JldHVybiBiUX19O3ZhciBhUz1hNigxKSxKPWE2KCksYWQ9YTYoMCwxKTthUi5nZXRUb3RhbExlbmd0aD1hUzthUi5nZXRQb2ludEF0TGVuZ3RoPUo7YVIuZ2V0U3VicGF0aD1mdW5jdGlvbihkLGksZyl7aWYodGhpcy5nZXRUb3RhbExlbmd0aChkKS1nPDAuMDAwMDAxKXtyZXR1cm4gYWQoZCxpKS5lbmR9dmFyIGI9YWQoZCxnLDEpO3JldHVybiBpP2FkKGIsaSkuZW5kOmJ9O2JoLmdldFRvdGFsTGVuZ3RoPWZ1bmN0aW9uKCl7aWYodGhpcy50eXBlIT1cInBhdGhcIil7cmV0dXJufWlmKHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCl7cmV0dXJuIHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCgpfXJldHVybiBhUyh0aGlzLmF0dHJzLnBhdGgpfTtiaC5nZXRQb2ludEF0TGVuZ3RoPWZ1bmN0aW9uKGIpe2lmKHRoaXMudHlwZSE9XCJwYXRoXCIpe3JldHVybn1yZXR1cm4gSih0aGlzLmF0dHJzLnBhdGgsYil9O2JoLmdldFN1YnBhdGg9ZnVuY3Rpb24oZCxiKXtpZih0aGlzLnR5cGUhPVwicGF0aFwiKXtyZXR1cm59cmV0dXJuIGFSLmdldFN1YnBhdGgodGhpcy5hdHRycy5wYXRoLGQsYil9O3ZhciBvPWFSLmVhc2luZ19mb3JtdWxhcz17bGluZWFyOmZ1bmN0aW9uKGIpe3JldHVybiBifSxcIjxcIjpmdW5jdGlvbihiKXtyZXR1cm4gYnAoYiwxLjcpfSxcIj5cIjpmdW5jdGlvbihiKXtyZXR1cm4gYnAoYiwwLjQ4KX0sXCI8PlwiOmZ1bmN0aW9uKGJMKXt2YXIgaT0wLjQ4LWJMLzEuMDQsZz1hdS5zcXJ0KDAuMTczNCtpKmkpLGI9Zy1pLFM9YnAoYXcoYiksMS8zKSooYjwwPy0xOjEpLFI9LWctaSxFPWJwKGF3KFIpLDEvMykqKFI8MD8tMToxKSxkPVMrRSswLjU7cmV0dXJuKDEtZCkqMypkKmQrZCpkKmR9LGJhY2tJbjpmdW5jdGlvbihkKXt2YXIgYj0xLjcwMTU4O3JldHVybiBkKmQqKChiKzEpKmQtYil9LGJhY2tPdXQ6ZnVuY3Rpb24oZCl7ZD1kLTE7dmFyIGI9MS43MDE1ODtyZXR1cm4gZCpkKigoYisxKSpkK2IpKzF9LGVsYXN0aWM6ZnVuY3Rpb24oYil7aWYoYj09ISFiKXtyZXR1cm4gYn1yZXR1cm4gYnAoMiwtMTAqYikqYXUuc2luKChiLTAuMDc1KSooMiphVikvMC4zKSsxfSxib3VuY2U6ZnVuY3Rpb24oaSl7dmFyIGQ9Ny41NjI1LGc9Mi43NSxiO2lmKGk8KDEvZykpe2I9ZCppKml9ZWxzZXtpZihpPCgyL2cpKXtpLT0oMS41L2cpO2I9ZCppKmkrMC43NX1lbHNle2lmKGk8KDIuNS9nKSl7aS09KDIuMjUvZyk7Yj1kKmkqaSswLjkzNzV9ZWxzZXtpLT0oMi42MjUvZyk7Yj1kKmkqaSswLjk4NDM3NX19fXJldHVybiBifX07by5lYXNlSW49b1tcImVhc2UtaW5cIl09b1tcIjxcIl07by5lYXNlT3V0PW9bXCJlYXNlLW91dFwiXT1vW1wiPlwiXTtvLmVhc2VJbk91dD1vW1wiZWFzZS1pbi1vdXRcIl09b1tcIjw+XCJdO29bXCJiYWNrLWluXCJdPW8uYmFja0luO29bXCJiYWNrLW91dFwiXT1vLmJhY2tPdXQ7dmFyIGFiPVtdLGFOPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGIpe3NldFRpbWVvdXQoYiwxNil9LGJDPWZ1bmN0aW9uKCl7dmFyIGJMPStuZXcgRGF0ZSxiVD0wO2Zvcig7YlQ8YWIubGVuZ3RoO2JUKyspe3ZhciBiWj1hYltiVF07aWYoYlouZWwucmVtb3ZlZHx8YloucGF1c2VkKXtjb250aW51ZX12YXIgRT1iTC1iWi5zdGFydCxiUj1iWi5tcyxiUT1iWi5lYXNpbmcsYlU9YlouZnJvbSxiTz1iWi5kaWZmLGQ9YloudG8sYk49YloudCxTPWJaLmVsLGJQPXt9LGIsYlg9e30sYjE7aWYoYlouaW5pdHN0YXR1cyl7RT0oYlouaW5pdHN0YXR1cypiWi5hbmltLnRvcC1iWi5wcmV2KS8oYloucGVyY2VudC1iWi5wcmV2KSpiUjtiWi5zdGF0dXM9YlouaW5pdHN0YXR1cztkZWxldGUgYlouaW5pdHN0YXR1cztiWi5zdG9wJiZhYi5zcGxpY2UoYlQtLSwxKX1lbHNle2JaLnN0YXR1cz0oYloucHJldisoYloucGVyY2VudC1iWi5wcmV2KSooRS9iUikpL2JaLmFuaW0udG9wfWlmKEU8MCl7Y29udGludWV9aWYoRTxiUil7dmFyIGc9YlEoRS9iUik7Zm9yKHZhciBiUyBpbiBiVSl7aWYoYlVbYWtdKGJTKSl7c3dpdGNoKGFyW2JTXSl7Y2FzZSBhTDpiPStiVVtiU10rZypiUipiT1tiU107YnJlYWs7Y2FzZVwiY29sb3VyXCI6Yj1cInJnYihcIitbSChhaChiVVtiU10ucitnKmJSKmJPW2JTXS5yKSksSChhaChiVVtiU10uZytnKmJSKmJPW2JTXS5nKSksSChhaChiVVtiU10uYitnKmJSKmJPW2JTXS5iKSldLmpvaW4oXCIsXCIpK1wiKVwiO2JyZWFrO2Nhc2VcInBhdGhcIjpiPVtdO2Zvcih2YXIgYlc9MCxiTT1iVVtiU10ubGVuZ3RoO2JXPGJNO2JXKyspe2JbYlddPVtiVVtiU11bYlddWzBdXTtmb3IodmFyIGJWPTEsYlk9YlVbYlNdW2JXXS5sZW5ndGg7YlY8Ylk7YlYrKyl7YltiV11bYlZdPStiVVtiU11bYlddW2JWXStnKmJSKmJPW2JTXVtiV11bYlZdfWJbYlddPWJbYlddLmpvaW4oYVEpfWI9Yi5qb2luKGFRKTticmVhaztjYXNlXCJ0cmFuc2Zvcm1cIjppZihiT1tiU10ucmVhbCl7Yj1bXTtmb3IoYlc9MCxiTT1iVVtiU10ubGVuZ3RoO2JXPGJNO2JXKyspe2JbYlddPVtiVVtiU11bYlddWzBdXTtmb3IoYlY9MSxiWT1iVVtiU11bYlddLmxlbmd0aDtiVjxiWTtiVisrKXtiW2JXXVtiVl09YlVbYlNdW2JXXVtiVl0rZypiUipiT1tiU11bYlddW2JWXX19fWVsc2V7dmFyIGIwPWZ1bmN0aW9uKGIyKXtyZXR1cm4gK2JVW2JTXVtiMl0rZypiUipiT1tiU11bYjJdfTtiPVtbXCJtXCIsYjAoMCksYjAoMSksYjAoMiksYjAoMyksYjAoNCksYjAoNSldXX1icmVhaztjYXNlXCJjc3ZcIjppZihiUz09XCJjbGlwLXJlY3RcIil7Yj1bXTtiVz00O3doaWxlKGJXLS0pe2JbYlddPStiVVtiU11bYlddK2cqYlIqYk9bYlNdW2JXXX19YnJlYWs7ZGVmYXVsdDp2YXIgUj1bXVtiRV0oYlVbYlNdKTtiPVtdO2JXPVMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tiU10ubGVuZ3RoO3doaWxlKGJXLS0pe2JbYlddPStSW2JXXStnKmJSKmJPW2JTXVtiV119YnJlYWt9YlBbYlNdPWJ9fVMuYXR0cihiUCk7KGZ1bmN0aW9uKGIzLGksYjIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtldmUoXCJyYXBoYWVsLmFuaW0uZnJhbWUuXCIrYjMsaSxiMil9KX0pKFMuaWQsUyxiWi5hbmltKX1lbHNleyhmdW5jdGlvbihiMyxiMixpKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZXZlKFwicmFwaGFlbC5hbmltLmZyYW1lLlwiK2IyLmlkLGIyLGkpO2V2ZShcInJhcGhhZWwuYW5pbS5maW5pc2guXCIrYjIuaWQsYjIsaSk7YVIuaXMoYjMsXCJmdW5jdGlvblwiKSYmYjMuY2FsbChiMil9KX0pKGJaLmNhbGxiYWNrLFMsYlouYW5pbSk7Uy5hdHRyKGQpO2FiLnNwbGljZShiVC0tLDEpO2lmKGJaLnJlcGVhdD4xJiYhYloubmV4dCl7Zm9yKGIxIGluIGQpe2lmKGRbYWtdKGIxKSl7YlhbYjFdPWJaLnRvdGFsT3JpZ2luW2IxXX19YlouZWwuYXR0cihiWCk7YU0oYlouYW5pbSxiWi5lbCxiWi5hbmltLnBlcmNlbnRzWzBdLG51bGwsYloudG90YWxPcmlnaW4sYloucmVwZWF0LTEpfWlmKGJaLm5leHQmJiFiWi5zdG9wKXthTShiWi5hbmltLGJaLmVsLGJaLm5leHQsbnVsbCxiWi50b3RhbE9yaWdpbixiWi5yZXBlYXQpfX19YVIuc3ZnJiZTJiZTLnBhcGVyJiZTLnBhcGVyLnNhZmFyaSgpO2FiLmxlbmd0aCYmYU4oYkMpfSxIPWZ1bmN0aW9uKGIpe3JldHVybiBiPjI1NT8yNTU6YjwwPzA6Yn07YmguYW5pbWF0ZVdpdGg9ZnVuY3Rpb24oZCxFLGcsYixiTCxiUSl7dmFyIFM9dGhpcztpZihTLnJlbW92ZWQpe2JRJiZiUS5jYWxsKFMpO3JldHVybiBTfXZhciBiTz1nIGluc3RhbmNlb2YgYkE/ZzphUi5hbmltYXRpb24oZyxiLGJMLGJRKSxiTixiTTthTShiTyxTLGJPLnBlcmNlbnRzWzBdLG51bGwsUy5hdHRyKCkpO2Zvcih2YXIgUj0wLGJQPWFiLmxlbmd0aDtSPGJQO1IrKyl7aWYoYWJbUl0uYW5pbT09RSYmYWJbUl0uZWw9PWQpe2FiW2JQLTFdLnN0YXJ0PWFiW1JdLnN0YXJ0O2JyZWFrfX1yZXR1cm4gU307ZnVuY3Rpb24gYTMoYlIsaSxkLGJRLGJQLGJMKXt2YXIgYk09MyppLGJPPTMqKGJRLWkpLWJNLGI9MS1iTS1iTyxTPTMqZCxiTj0zKihiUC1kKS1TLGJTPTEtUy1iTjtmdW5jdGlvbiBSKGJUKXtyZXR1cm4oKGIqYlQrYk8pKmJUK2JNKSpiVH1mdW5jdGlvbiBnKGJULGJWKXt2YXIgYlU9RShiVCxiVik7cmV0dXJuKChiUypiVStiTikqYlUrUykqYlV9ZnVuY3Rpb24gRShiVCxiMCl7dmFyIGJaLGJZLGJXLGJVLGJYLGJWO2ZvcihiVz1iVCxiVj0wO2JWPDg7YlYrKyl7YlU9UihiVyktYlQ7aWYoYXcoYlUpPGIwKXtyZXR1cm4gYld9Ylg9KDMqYipiVysyKmJPKSpiVytiTTtpZihhdyhiWCk8MC4wMDAwMDEpe2JyZWFrfWJXPWJXLWJVL2JYfWJaPTA7Ylk9MTtiVz1iVDtpZihiVzxiWil7cmV0dXJuIGJafWlmKGJXPmJZKXtyZXR1cm4gYll9d2hpbGUoYlo8Ylkpe2JVPVIoYlcpO2lmKGF3KGJVLWJUKTxiMCl7cmV0dXJuIGJXfWlmKGJUPmJVKXtiWj1iV31lbHNle2JZPWJXfWJXPShiWS1iWikvMitiWn1yZXR1cm4gYld9cmV0dXJuIGcoYlIsMS8oMjAwKmJMKSl9Ymgub25BbmltYXRpb249ZnVuY3Rpb24oYil7Yj9ldmUub24oXCJyYXBoYWVsLmFuaW0uZnJhbWUuXCIrdGhpcy5pZCxiKTpldmUudW5iaW5kKFwicmFwaGFlbC5hbmltLmZyYW1lLlwiK3RoaXMuaWQpO3JldHVybiB0aGlzfTtmdW5jdGlvbiBiQShFLGcpe3ZhciBkPVtdLGk9e307dGhpcy5tcz1nO3RoaXMudGltZXM9MTtpZihFKXtmb3IodmFyIGIgaW4gRSl7aWYoRVtha10oYikpe2lbYW4oYildPUVbYl07ZC5wdXNoKGFuKGIpKX19ZC5zb3J0KHUpfXRoaXMuYW5pbT1pO3RoaXMudG9wPWRbZC5sZW5ndGgtMV07dGhpcy5wZXJjZW50cz1kfWJBLnByb3RvdHlwZS5kZWxheT1mdW5jdGlvbihkKXt2YXIgYj1uZXcgYkEodGhpcy5hbmltLHRoaXMubXMpO2IudGltZXM9dGhpcy50aW1lcztiLmRlbD0rZHx8MDtyZXR1cm4gYn07YkEucHJvdG90eXBlLnJlcGVhdD1mdW5jdGlvbihkKXt2YXIgYj1uZXcgYkEodGhpcy5hbmltLHRoaXMubXMpO2IuZGVsPXRoaXMuZGVsO2IudGltZXM9YXUuZmxvb3IobShkLDApKXx8MTtyZXR1cm4gYn07ZnVuY3Rpb24gYU0oYjMsZyxiLGIxLGJMLGJQKXtiPWFuKGIpO3ZhciBjYSxTLGJPLGNiPVtdLGJWLGJVLFIsYlg9YjMubXMsYjI9e30sRT17fSxiUj17fTtpZihiMSl7Zm9yKGI2PTAsYlE9YWIubGVuZ3RoO2I2PGJRO2I2Kyspe3ZhciBiOD1hYltiNl07aWYoYjguZWwuaWQ9PWcuaWQmJmI4LmFuaW09PWIzKXtpZihiOC5wZXJjZW50IT1iKXthYi5zcGxpY2UoYjYsMSk7XG5iTz0xfWVsc2V7Uz1iOH1nLmF0dHIoYjgudG90YWxPcmlnaW4pO2JyZWFrfX19ZWxzZXtiMT0rRX1mb3IodmFyIGI2PTAsYlE9YjMucGVyY2VudHMubGVuZ3RoO2I2PGJRO2I2Kyspe2lmKGIzLnBlcmNlbnRzW2I2XT09Ynx8YjMucGVyY2VudHNbYjZdPmIxKmIzLnRvcCl7Yj1iMy5wZXJjZW50c1tiNl07YlU9YjMucGVyY2VudHNbYjYtMV18fDA7Ylg9YlgvYjMudG9wKihiLWJVKTtiVj1iMy5wZXJjZW50c1tiNisxXTtjYT1iMy5hbmltW2JdO2JyZWFrfWVsc2V7aWYoYjEpe2cuYXR0cihiMy5hbmltW2IzLnBlcmNlbnRzW2I2XV0pfX19aWYoIWNhKXtyZXR1cm59aWYoIVMpe2Zvcih2YXIgYlogaW4gY2Epe2lmKGNhW2FrXShiWikpe2lmKGFyW2FrXShiWil8fGcucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tha10oYlopKXtiMltiWl09Zy5hdHRyKGJaKTsoYjJbYlpdPT1udWxsKSYmKGIyW2JaXT1yW2JaXSk7RVtiWl09Y2FbYlpdO3N3aXRjaChhcltiWl0pe2Nhc2UgYUw6YlJbYlpdPShFW2JaXS1iMltiWl0pL2JYO2JyZWFrO2Nhc2VcImNvbG91clwiOmIyW2JaXT1hUi5nZXRSR0IoYjJbYlpdKTt2YXIgYjA9YVIuZ2V0UkdCKEVbYlpdKTtiUltiWl09e3I6KGIwLnItYjJbYlpdLnIpL2JYLGc6KGIwLmctYjJbYlpdLmcpL2JYLGI6KGIwLmItYjJbYlpdLmIpL2JYfTticmVhaztjYXNlXCJwYXRoXCI6dmFyIGJNPVcoYjJbYlpdLEVbYlpdKSxiVD1iTVsxXTtiMltiWl09Yk1bMF07YlJbYlpdPVtdO2ZvcihiNj0wLGJRPWIyW2JaXS5sZW5ndGg7YjY8YlE7YjYrKyl7YlJbYlpdW2I2XT1bMF07Zm9yKHZhciBiNT0xLGI3PWIyW2JaXVtiNl0ubGVuZ3RoO2I1PGI3O2I1Kyspe2JSW2JaXVtiNl1bYjVdPShiVFtiNl1bYjVdLWIyW2JaXVtiNl1bYjVdKS9iWH19YnJlYWs7Y2FzZVwidHJhbnNmb3JtXCI6dmFyIGNkPWcuXyxjYz1hQihjZFtiWl0sRVtiWl0pO2lmKGNjKXtiMltiWl09Y2MuZnJvbTtFW2JaXT1jYy50bztiUltiWl09W107YlJbYlpdLnJlYWw9dHJ1ZTtmb3IoYjY9MCxiUT1iMltiWl0ubGVuZ3RoO2I2PGJRO2I2Kyspe2JSW2JaXVtiNl09W2IyW2JaXVtiNl1bMF1dO2ZvcihiNT0xLGI3PWIyW2JaXVtiNl0ubGVuZ3RoO2I1PGI3O2I1Kyspe2JSW2JaXVtiNl1bYjVdPShFW2JaXVtiNl1bYjVdLWIyW2JaXVtiNl1bYjVdKS9iWH19fWVsc2V7dmFyIGJZPShnLm1hdHJpeHx8bmV3IGFGKSxiOT17Xzp7dHJhbnNmb3JtOmNkLnRyYW5zZm9ybX0sZ2V0QkJveDpmdW5jdGlvbigpe3JldHVybiBnLmdldEJCb3goMSl9fTtiMltiWl09W2JZLmEsYlkuYixiWS5jLGJZLmQsYlkuZSxiWS5mXTthTyhiOSxFW2JaXSk7RVtiWl09YjkuXy50cmFuc2Zvcm07YlJbYlpdPVsoYjkubWF0cml4LmEtYlkuYSkvYlgsKGI5Lm1hdHJpeC5iLWJZLmIpL2JYLChiOS5tYXRyaXguYy1iWS5jKS9iWCwoYjkubWF0cml4LmQtYlkuZCkvYlgsKGI5Lm1hdHJpeC5lLWJZLmUpL2JYLChiOS5tYXRyaXguZi1iWS5mKS9iWF19YnJlYWs7Y2FzZVwiY3N2XCI6dmFyIGQ9YkgoY2FbYlpdKVtGXShhKSxiTj1iSChiMltiWl0pW0ZdKGEpO2lmKGJaPT1cImNsaXAtcmVjdFwiKXtiMltiWl09Yk47YlJbYlpdPVtdO2I2PWJOLmxlbmd0aDt3aGlsZShiNi0tKXtiUltiWl1bYjZdPShkW2I2XS1iMltiWl1bYjZdKS9iWH19RVtiWl09ZDticmVhaztkZWZhdWx0OmQ9W11bYkVdKGNhW2JaXSk7Yk49W11bYkVdKGIyW2JaXSk7YlJbYlpdPVtdO2I2PWcucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tiWl0ubGVuZ3RoO3doaWxlKGI2LS0pe2JSW2JaXVtiNl09KChkW2I2XXx8MCktKGJOW2I2XXx8MCkpL2JYfWJyZWFrfX19fXZhciBiVz1jYS5lYXNpbmcsYjQ9YVIuZWFzaW5nX2Zvcm11bGFzW2JXXTtpZighYjQpe2I0PWJIKGJXKS5tYXRjaChjKTtpZihiNCYmYjQubGVuZ3RoPT01KXt2YXIgYlM9YjQ7YjQ9ZnVuY3Rpb24oaSl7cmV0dXJuIGEzKGksK2JTWzFdLCtiU1syXSwrYlNbM10sK2JTWzRdLGJYKX19ZWxzZXtiND1iQn19Uj1jYS5zdGFydHx8YjMuc3RhcnR8fCtuZXcgRGF0ZTtiOD17YW5pbTpiMyxwZXJjZW50OmIsdGltZXN0YW1wOlIsc3RhcnQ6UisoYjMuZGVsfHwwKSxzdGF0dXM6MCxpbml0c3RhdHVzOmIxfHwwLHN0b3A6ZmFsc2UsbXM6YlgsZWFzaW5nOmI0LGZyb206YjIsZGlmZjpiUix0bzpFLGVsOmcsY2FsbGJhY2s6Y2EuY2FsbGJhY2sscHJldjpiVSxuZXh0OmJWLHJlcGVhdDpiUHx8YjMudGltZXMsb3JpZ2luOmcuYXR0cigpLHRvdGFsT3JpZ2luOmJMfTthYi5wdXNoKGI4KTtpZihiMSYmIVMmJiFiTyl7Yjguc3RvcD10cnVlO2I4LnN0YXJ0PW5ldyBEYXRlLWJYKmIxO2lmKGFiLmxlbmd0aD09MSl7cmV0dXJuIGJDKCl9fWlmKGJPKXtiOC5zdGFydD1uZXcgRGF0ZS1iOC5tcypiMX1hYi5sZW5ndGg9PTEmJmFOKGJDKX1lbHNle1MuaW5pdHN0YXR1cz1iMTtTLnN0YXJ0PW5ldyBEYXRlLVMubXMqYjF9ZXZlKFwicmFwaGFlbC5hbmltLnN0YXJ0LlwiK2cuaWQsZyxiMyl9YVIuYW5pbWF0aW9uPWZ1bmN0aW9uKEUsZCxTLFIpe2lmKEUgaW5zdGFuY2VvZiBiQSl7cmV0dXJuIEV9aWYoYVIuaXMoUyxcImZ1bmN0aW9uXCIpfHwhUyl7Uj1SfHxTfHxudWxsO1M9bnVsbH1FPU9iamVjdChFKTtkPStkfHwwO3ZhciBpPXt9LGcsYjtmb3IoYiBpbiBFKXtpZihFW2FrXShiKSYmYW4oYikhPWImJmFuKGIpK1wiJVwiIT1iKXtnPXRydWU7aVtiXT1FW2JdfX1pZighZyl7cmV0dXJuIG5ldyBiQShFLGQpfWVsc2V7UyYmKGkuZWFzaW5nPVMpO1ImJihpLmNhbGxiYWNrPVIpO3JldHVybiBuZXcgYkEoezEwMDppfSxkKX19O2JoLmFuaW1hdGU9ZnVuY3Rpb24oaSxiLFIsRSl7dmFyIGQ9dGhpcztpZihkLnJlbW92ZWQpe0UmJkUuY2FsbChkKTtyZXR1cm4gZH12YXIgZz1pIGluc3RhbmNlb2YgYkE/aTphUi5hbmltYXRpb24oaSxiLFIsRSk7YU0oZyxkLGcucGVyY2VudHNbMF0sbnVsbCxkLmF0dHIoKSk7cmV0dXJuIGR9O2JoLnNldFRpbWU9ZnVuY3Rpb24oZCxiKXtpZihkJiZiIT1udWxsKXt0aGlzLnN0YXR1cyhkLGJtKGIsZC5tcykvZC5tcyl9cmV0dXJuIHRoaXN9O2JoLnN0YXR1cz1mdW5jdGlvbihSLEUpe3ZhciBkPVtdLGc9MCxiLFM7aWYoRSE9bnVsbCl7YU0oUix0aGlzLC0xLGJtKEUsMSkpO3JldHVybiB0aGlzfWVsc2V7Yj1hYi5sZW5ndGg7Zm9yKDtnPGI7ZysrKXtTPWFiW2ddO2lmKFMuZWwuaWQ9PXRoaXMuaWQmJighUnx8Uy5hbmltPT1SKSl7aWYoUil7cmV0dXJuIFMuc3RhdHVzfWQucHVzaCh7YW5pbTpTLmFuaW0sc3RhdHVzOlMuc3RhdHVzfSl9fWlmKFIpe3JldHVybiAwfXJldHVybiBkfX07YmgucGF1c2U9ZnVuY3Rpb24oZCl7Zm9yKHZhciBiPTA7YjxhYi5sZW5ndGg7YisrKXtpZihhYltiXS5lbC5pZD09dGhpcy5pZCYmKCFkfHxhYltiXS5hbmltPT1kKSl7aWYoZXZlKFwicmFwaGFlbC5hbmltLnBhdXNlLlwiK3RoaXMuaWQsdGhpcyxhYltiXS5hbmltKSE9PWZhbHNlKXthYltiXS5wYXVzZWQ9dHJ1ZX19fXJldHVybiB0aGlzfTtiaC5yZXN1bWU9ZnVuY3Rpb24oZCl7Zm9yKHZhciBiPTA7YjxhYi5sZW5ndGg7YisrKXtpZihhYltiXS5lbC5pZD09dGhpcy5pZCYmKCFkfHxhYltiXS5hbmltPT1kKSl7dmFyIGc9YWJbYl07aWYoZXZlKFwicmFwaGFlbC5hbmltLnJlc3VtZS5cIit0aGlzLmlkLHRoaXMsZy5hbmltKSE9PWZhbHNlKXtkZWxldGUgZy5wYXVzZWQ7dGhpcy5zdGF0dXMoZy5hbmltLGcuc3RhdHVzKX19fXJldHVybiB0aGlzfTtiaC5zdG9wPWZ1bmN0aW9uKGQpe2Zvcih2YXIgYj0wO2I8YWIubGVuZ3RoO2IrKyl7aWYoYWJbYl0uZWwuaWQ9PXRoaXMuaWQmJighZHx8YWJbYl0uYW5pbT09ZCkpe2lmKGV2ZShcInJhcGhhZWwuYW5pbS5zdG9wLlwiK3RoaXMuaWQsdGhpcyxhYltiXS5hbmltKSE9PWZhbHNlKXthYi5zcGxpY2UoYi0tLDEpfX19cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIGFhKGQpe2Zvcih2YXIgYj0wO2I8YWIubGVuZ3RoO2IrKyl7aWYoYWJbYl0uZWwucGFwZXI9PWQpe2FiLnNwbGljZShiLS0sMSl9fX1ldmUub24oXCJyYXBoYWVsLnJlbW92ZVwiLGFhKTtldmUub24oXCJyYXBoYWVsLmNsZWFyXCIsYWEpO2JoLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJSYXBoYVxceGVibFxcdTIwMTlzIG9iamVjdFwifTt2YXIgYWw9ZnVuY3Rpb24oYil7dGhpcy5pdGVtcz1bXTt0aGlzLmxlbmd0aD0wO3RoaXMudHlwZT1cInNldFwiO2lmKGIpe2Zvcih2YXIgZD0wLGc9Yi5sZW5ndGg7ZDxnO2QrKyl7aWYoYltkXSYmKGJbZF0uY29uc3RydWN0b3I9PWJoLmNvbnN0cnVjdG9yfHxiW2RdLmNvbnN0cnVjdG9yPT1hbCkpe3RoaXNbdGhpcy5pdGVtcy5sZW5ndGhdPXRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGhdPWJbZF07dGhpcy5sZW5ndGgrK319fX0sYmM9YWwucHJvdG90eXBlO2JjLnB1c2g9ZnVuY3Rpb24oKXt2YXIgRSxiO2Zvcih2YXIgZD0wLGc9YXJndW1lbnRzLmxlbmd0aDtkPGc7ZCsrKXtFPWFyZ3VtZW50c1tkXTtpZihFJiYoRS5jb25zdHJ1Y3Rvcj09YmguY29uc3RydWN0b3J8fEUuY29uc3RydWN0b3I9PWFsKSl7Yj10aGlzLml0ZW1zLmxlbmd0aDt0aGlzW2JdPXRoaXMuaXRlbXNbYl09RTt0aGlzLmxlbmd0aCsrfX1yZXR1cm4gdGhpc307YmMucG9wPWZ1bmN0aW9uKCl7dGhpcy5sZW5ndGgmJmRlbGV0ZSB0aGlzW3RoaXMubGVuZ3RoLS1dO3JldHVybiB0aGlzLml0ZW1zLnBvcCgpfTtiYy5mb3JFYWNoPWZ1bmN0aW9uKEUsYil7Zm9yKHZhciBkPTAsZz10aGlzLml0ZW1zLmxlbmd0aDtkPGc7ZCsrKXtpZihFLmNhbGwoYix0aGlzLml0ZW1zW2RdLGQpPT09ZmFsc2Upe3JldHVybiB0aGlzfX1yZXR1cm4gdGhpc307Zm9yKHZhciBCIGluIGJoKXtpZihiaFtha10oQikpe2JjW0JdPShmdW5jdGlvbihiKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZD1hcmd1bWVudHM7cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihnKXtnW2JdW2JHXShnLGQpfSl9fSkoQil9fWJjLmF0dHI9ZnVuY3Rpb24oZCxTKXtpZihkJiZhUi5pcyhkLGJkKSYmYVIuaXMoZFswXSxcIm9iamVjdFwiKSl7Zm9yKHZhciBiPTAsUj1kLmxlbmd0aDtiPFI7YisrKXt0aGlzLml0ZW1zW2JdLmF0dHIoZFtiXSl9fWVsc2V7Zm9yKHZhciBnPTAsRT10aGlzLml0ZW1zLmxlbmd0aDtnPEU7ZysrKXt0aGlzLml0ZW1zW2ddLmF0dHIoZCxTKX19cmV0dXJuIHRoaXN9O2JjLmNsZWFyPWZ1bmN0aW9uKCl7d2hpbGUodGhpcy5sZW5ndGgpe3RoaXMucG9wKCl9fTtiYy5zcGxpY2U9ZnVuY3Rpb24oRSxiTCxiTSl7RT1FPDA/bSh0aGlzLmxlbmd0aCtFLDApOkU7Ykw9bSgwLGJtKHRoaXMubGVuZ3RoLUUsYkwpKTt2YXIgZz1bXSxiPVtdLGQ9W10sUjtmb3IoUj0yO1I8YXJndW1lbnRzLmxlbmd0aDtSKyspe2QucHVzaChhcmd1bWVudHNbUl0pfWZvcihSPTA7UjxiTDtSKyspe2IucHVzaCh0aGlzW0UrUl0pfWZvcig7Ujx0aGlzLmxlbmd0aC1FO1IrKyl7Zy5wdXNoKHRoaXNbRStSXSl9dmFyIFM9ZC5sZW5ndGg7Zm9yKFI9MDtSPFMrZy5sZW5ndGg7UisrKXt0aGlzLml0ZW1zW0UrUl09dGhpc1tFK1JdPVI8Uz9kW1JdOmdbUi1TXX1SPXRoaXMuaXRlbXMubGVuZ3RoPXRoaXMubGVuZ3RoLT1iTC1TO3doaWxlKHRoaXNbUl0pe2RlbGV0ZSB0aGlzW1IrK119cmV0dXJuIG5ldyBhbChiKX07YmMuZXhjbHVkZT1mdW5jdGlvbihnKXtmb3IodmFyIGI9MCxkPXRoaXMubGVuZ3RoO2I8ZDtiKyspe2lmKHRoaXNbYl09PWcpe3RoaXMuc3BsaWNlKGIsMSk7cmV0dXJuIHRydWV9fX07YmMuYW5pbWF0ZT1mdW5jdGlvbihnLGIsYkwsYk4peyhhUi5pcyhiTCxcImZ1bmN0aW9uXCIpfHwhYkwpJiYoYk49Ykx8fG51bGwpO3ZhciBTPXRoaXMuaXRlbXMubGVuZ3RoLEU9UyxiTyxiTT10aGlzLFI7aWYoIVMpe3JldHVybiB0aGlzfWJOJiYoUj1mdW5jdGlvbigpeyEtLVMmJmJOLmNhbGwoYk0pfSk7Ykw9YVIuaXMoYkwsYWopP2JMOlI7dmFyIGQ9YVIuYW5pbWF0aW9uKGcsYixiTCxSKTtiTz10aGlzLml0ZW1zWy0tRV0uYW5pbWF0ZShkKTt3aGlsZShFLS0pe3RoaXMuaXRlbXNbRV0mJiF0aGlzLml0ZW1zW0VdLnJlbW92ZWQmJnRoaXMuaXRlbXNbRV0uYW5pbWF0ZVdpdGgoYk8sZCxkKX1yZXR1cm4gdGhpc307YmMuaW5zZXJ0QWZ0ZXI9ZnVuY3Rpb24oZCl7dmFyIGI9dGhpcy5pdGVtcy5sZW5ndGg7d2hpbGUoYi0tKXt0aGlzLml0ZW1zW2JdLmluc2VydEFmdGVyKGQpfXJldHVybiB0aGlzfTtiYy5nZXRCQm94PWZ1bmN0aW9uKCl7dmFyIGI9W10sUz1bXSxkPVtdLEU9W107Zm9yKHZhciBnPXRoaXMuaXRlbXMubGVuZ3RoO2ctLTspe2lmKCF0aGlzLml0ZW1zW2ddLnJlbW92ZWQpe3ZhciBSPXRoaXMuaXRlbXNbZ10uZ2V0QkJveCgpO2IucHVzaChSLngpO1MucHVzaChSLnkpO2QucHVzaChSLngrUi53aWR0aCk7RS5wdXNoKFIueStSLmhlaWdodCl9fWI9Ym1bYkddKDAsYik7Uz1ibVtiR10oMCxTKTtkPW1bYkddKDAsZCk7RT1tW2JHXSgwLEUpO3JldHVybnt4OmIseTpTLHgyOmQseTI6RSx3aWR0aDpkLWIsaGVpZ2h0OkUtU319O2JjLmNsb25lPWZ1bmN0aW9uKGcpe2c9bmV3IGFsO2Zvcih2YXIgYj0wLGQ9dGhpcy5pdGVtcy5sZW5ndGg7YjxkO2IrKyl7Zy5wdXNoKHRoaXMuaXRlbXNbYl0uY2xvbmUoKSl9cmV0dXJuIGd9O2JjLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJSYXBoYVxceGVibFxcdTIwMThzIHNldFwifTthUi5yZWdpc3RlckZvbnQ9ZnVuY3Rpb24oZCl7aWYoIWQuZmFjZSl7cmV0dXJuIGR9dGhpcy5mb250cz10aGlzLmZvbnRzfHx7fTt2YXIgaT17dzpkLncsZmFjZTp7fSxnbHlwaHM6e319LGc9ZC5mYWNlW1wiZm9udC1mYW1pbHlcIl07Zm9yKHZhciBTIGluIGQuZmFjZSl7aWYoZC5mYWNlW2FrXShTKSl7aS5mYWNlW1NdPWQuZmFjZVtTXX19aWYodGhpcy5mb250c1tnXSl7dGhpcy5mb250c1tnXS5wdXNoKGkpfWVsc2V7dGhpcy5mb250c1tnXT1baV19aWYoIWQuc3ZnKXtpLmZhY2VbXCJ1bml0cy1wZXItZW1cIl09VShkLmZhY2VbXCJ1bml0cy1wZXItZW1cIl0sMTApO2Zvcih2YXIgRSBpbiBkLmdseXBocyl7aWYoZC5nbHlwaHNbYWtdKEUpKXt2YXIgUj1kLmdseXBoc1tFXTtpLmdseXBoc1tFXT17dzpSLncsazp7fSxkOlIuZCYmXCJNXCIrUi5kLnJlcGxhY2UoL1ttbGN4dHJ2XS9nLGZ1bmN0aW9uKGJMKXtyZXR1cm57bDpcIkxcIixjOlwiQ1wiLHg6XCJ6XCIsdDpcIm1cIixyOlwibFwiLHY6XCJjXCJ9W2JMXXx8XCJNXCJcbn0pK1wielwifTtpZihSLmspe2Zvcih2YXIgYiBpbiBSLmspe2lmKFJbYWtdKGIpKXtpLmdseXBoc1tFXS5rW2JdPVIua1tiXX19fX19fXJldHVybiBkfTthNC5nZXRGb250PWZ1bmN0aW9uKGJNLGJOLGQsRSl7RT1FfHxcIm5vcm1hbFwiO2Q9ZHx8XCJub3JtYWxcIjtiTj0rYk58fHtub3JtYWw6NDAwLGJvbGQ6NzAwLGxpZ2h0ZXI6MzAwLGJvbGRlcjo4MDB9W2JOXXx8NDAwO2lmKCFhUi5mb250cyl7cmV0dXJufXZhciBSPWFSLmZvbnRzW2JNXTtpZighUil7dmFyIGc9bmV3IFJlZ0V4cChcIihefFxcXFxzKVwiK2JNLnJlcGxhY2UoL1teXFx3XFxkXFxzKyF+LjpfLV0vZyxhWCkrXCIoXFxcXHN8JClcIixcImlcIik7Zm9yKHZhciBiIGluIGFSLmZvbnRzKXtpZihhUi5mb250c1tha10oYikpe2lmKGcudGVzdChiKSl7Uj1hUi5mb250c1tiXTticmVha319fX12YXIgUztpZihSKXtmb3IodmFyIGJMPTAsYk89Ui5sZW5ndGg7Ykw8Yk87YkwrKyl7Uz1SW2JMXTtpZihTLmZhY2VbXCJmb250LXdlaWdodFwiXT09Yk4mJihTLmZhY2VbXCJmb250LXN0eWxlXCJdPT1kfHwhUy5mYWNlW1wiZm9udC1zdHlsZVwiXSkmJlMuZmFjZVtcImZvbnQtc3RyZXRjaFwiXT09RSl7YnJlYWt9fX1yZXR1cm4gU307YTQucHJpbnQ9ZnVuY3Rpb24oYkwsUyxiLGJPLGJQLGJZLGQpe2JZPWJZfHxcIm1pZGRsZVwiO2Q9bShibShkfHwwLDEpLC0xKTt2YXIgYlg9YkgoYilbRl0oYVgpLGJVPTAsYlc9MCxiUz1hWCxiWjthUi5pcyhiTyxiKSYmKGJPPXRoaXMuZ2V0Rm9udChiTykpO2lmKGJPKXtiWj0oYlB8fDE2KS9iTy5mYWNlW1widW5pdHMtcGVyLWVtXCJdO3ZhciBFPWJPLmZhY2UuYmJveFtGXShhKSxiTj0rRVswXSxnPUVbM10tRVsxXSxSPTAsYlE9K0VbMV0rKGJZPT1cImJhc2VsaW5lXCI/ZysoK2JPLmZhY2UuZGVzY2VudCk6Zy8yKTtmb3IodmFyIGJUPTAsYk09YlgubGVuZ3RoO2JUPGJNO2JUKyspe2lmKGJYW2JUXT09XCJcXG5cIil7YlU9MDtiVj0wO2JXPTA7Uis9Z31lbHNle3ZhciBiUj1iVyYmYk8uZ2x5cGhzW2JYW2JULTFdXXx8e30sYlY9Yk8uZ2x5cGhzW2JYW2JUXV07YlUrPWJXPyhiUi53fHxiTy53KSsoYlIuayYmYlIua1tiWFtiVF1dfHwwKSsoYk8udypkKTowO2JXPTF9aWYoYlYmJmJWLmQpe2JTKz1hUi50cmFuc2Zvcm1QYXRoKGJWLmQsW1widFwiLGJVKmJaLFIqYlosXCJzXCIsYlosYlosYk4sYlEsXCJ0XCIsKGJMLWJOKS9iWiwoUy1iUSkvYlpdKX19fXJldHVybiB0aGlzLnBhdGgoYlMpLmF0dHIoe2ZpbGw6XCIjMDAwXCIsc3Ryb2tlOlwibm9uZVwifSl9O2E0LmFkZD1mdW5jdGlvbihFKXtpZihhUi5pcyhFLFwiYXJyYXlcIikpe3ZhciBnPXRoaXMuc2V0KCksZD0wLFI9RS5sZW5ndGgsYjtmb3IoO2Q8UjtkKyspe2I9RVtkXXx8e307YndbYWtdKGIudHlwZSkmJmcucHVzaCh0aGlzW2IudHlwZV0oKS5hdHRyKGIpKX19cmV0dXJuIGd9O2FSLmZvcm1hdD1mdW5jdGlvbihkLGcpe3ZhciBiPWFSLmlzKGcsYmQpP1swXVtiRV0oZyk6YXJndW1lbnRzO2QmJmFSLmlzKGQsYWopJiZiLmxlbmd0aC0xJiYoZD1kLnJlcGxhY2UoYnIsZnVuY3Rpb24oUixFKXtyZXR1cm4gYlsrK0VdPT1udWxsP2FYOmJbRV19KSk7cmV0dXJuIGR8fGFYfTthUi5mdWxsZmlsbD0oZnVuY3Rpb24oKXt2YXIgZz0vXFx7KFteXFx9XSspXFx9L2csYj0vKD86KD86XnxcXC4pKC4rPykoPz1cXFt8XFwufCR8XFwoKXxcXFsoJ3xcIikoLis/KVxcMlxcXSkoXFwoXFwpKT8vZyxkPWZ1bmN0aW9uKFIsRSxTKXt2YXIgaT1TO0UucmVwbGFjZShiLGZ1bmN0aW9uKGJOLGJNLGJMLGJQLGJPKXtiTT1iTXx8YlA7aWYoaSl7aWYoYk0gaW4gaSl7aT1pW2JNXX10eXBlb2YgaT09XCJmdW5jdGlvblwiJiZiTyYmKGk9aSgpKX19KTtpPShpPT1udWxsfHxpPT1TP1I6aSkrXCJcIjtyZXR1cm4gaX07cmV0dXJuIGZ1bmN0aW9uKEUsaSl7cmV0dXJuIFN0cmluZyhFKS5yZXBsYWNlKGcsZnVuY3Rpb24oUyxSKXtyZXR1cm4gZChTLFIsaSl9KX19KSgpO2FSLm5pbmphPWZ1bmN0aW9uKCl7cy53YXM/KGFBLndpbi5SYXBoYWVsPXMuaXMpOmRlbGV0ZSBSYXBoYWVsO3JldHVybiBhUn07YVIuc3Q9YmM7KGZ1bmN0aW9uKGksZCxnKXtpZihpLnJlYWR5U3RhdGU9PW51bGwmJmkuYWRkRXZlbnRMaXN0ZW5lcil7aS5hZGRFdmVudExpc3RlbmVyKGQsZz1mdW5jdGlvbigpe2kucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLGcsZmFsc2UpO2kucmVhZHlTdGF0ZT1cImNvbXBsZXRlXCJ9LGZhbHNlKTtpLnJlYWR5U3RhdGU9XCJsb2FkaW5nXCJ9ZnVuY3Rpb24gYigpeygvaW4vKS50ZXN0KGkucmVhZHlTdGF0ZSk/c2V0VGltZW91dChiLDkpOmFSLmV2ZShcInJhcGhhZWwuRE9NbG9hZFwiKX1iKCl9KShkb2N1bWVudCxcIkRPTUNvbnRlbnRMb2FkZWRcIik7cy53YXM/KGFBLndpbi5SYXBoYWVsPWFSKTooUmFwaGFlbD1hUik7ZXZlLm9uKFwicmFwaGFlbC5ET01sb2FkXCIsZnVuY3Rpb24oKXthbz10cnVlfSl9KSgpO3dpbmRvdy5SYXBoYWVsLnN2ZyYmZnVuY3Rpb24obCl7dmFyIGQ9XCJoYXNPd25Qcm9wZXJ0eVwiLEI9U3RyaW5nLG49cGFyc2VGbG9hdCxxPXBhcnNlSW50LGY9TWF0aCxDPWYubWF4LHM9Zi5hYnMsaD1mLnBvdyxnPS9bLCBdKy8sej1sLmV2ZSxyPVwiXCIsaj1cIiBcIjt2YXIgbz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIix5PXtibG9jazpcIk01LDAgMCwyLjUgNSw1elwiLGNsYXNzaWM6XCJNNSwwIDAsMi41IDUsNSAzLjUsMyAzLjUsMnpcIixkaWFtb25kOlwiTTIuNSwwIDUsMi41IDIuNSw1IDAsMi41elwiLG9wZW46XCJNNiwxIDEsMy41IDYsNlwiLG92YWw6XCJNMi41LDBBMi41LDIuNSwwLDAsMSwyLjUsNSAyLjUsMi41LDAsMCwxLDIuNSwwelwifSx1PXt9O2wudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIllvdXIgYnJvd3NlciBzdXBwb3J0cyBTVkcuXFxuWW91IGFyZSBydW5uaW5nIFJhcGhhXFx4ZWJsIFwiK3RoaXMudmVyc2lvbn07dmFyIGk9ZnVuY3Rpb24oRixEKXtpZihEKXtpZih0eXBlb2YgRj09XCJzdHJpbmdcIil7Rj1pKEYpfWZvcih2YXIgRSBpbiBEKXtpZihEW2RdKEUpKXtpZihFLnN1YnN0cmluZygwLDYpPT1cInhsaW5rOlwiKXtGLnNldEF0dHJpYnV0ZU5TKG8sRS5zdWJzdHJpbmcoNiksQihEW0VdKSl9ZWxzZXtGLnNldEF0dHJpYnV0ZShFLEIoRFtFXSkpfX19fWVsc2V7Rj1sLl9nLmRvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLEYpO0Yuc3R5bGUmJihGLnN0eWxlLndlYmtpdFRhcEhpZ2hsaWdodENvbG9yPVwicmdiYSgwLDAsMCwwKVwiKX1yZXR1cm4gRn0sYT1mdW5jdGlvbihNLFEpe3ZhciBPPVwibGluZWFyXCIsRT1NLmlkK1EsSz0wLjUsST0wLjUsRz1NLm5vZGUsRD1NLnBhcGVyLFM9Ry5zdHlsZSxGPWwuX2cuZG9jLmdldEVsZW1lbnRCeUlkKEUpO2lmKCFGKXtRPUIoUSkucmVwbGFjZShsLl9yYWRpYWxfZ3JhZGllbnQsZnVuY3Rpb24oVixULFcpe089XCJyYWRpYWxcIjtpZihUJiZXKXtLPW4oVCk7ST1uKFcpO3ZhciBVPSgoST4wLjUpKjItMSk7aChLLTAuNSwyKStoKEktMC41LDIpPjAuMjUmJihJPWYuc3FydCgwLjI1LWgoSy0wLjUsMikpKlUrMC41KSYmSSE9MC41JiYoST1JLnRvRml4ZWQoNSktMC4wMDAwMSpVKX1yZXR1cm4gcn0pO1E9US5zcGxpdCgvXFxzKlxcLVxccyovKTtpZihPPT1cImxpbmVhclwiKXt2YXIgSj1RLnNoaWZ0KCk7Sj0tbihKKTtpZihpc05hTihKKSl7cmV0dXJuIG51bGx9dmFyIEg9WzAsMCxmLmNvcyhsLnJhZChKKSksZi5zaW4obC5yYWQoSikpXSxQPTEvKEMocyhIWzJdKSxzKEhbM10pKXx8MSk7SFsyXSo9UDtIWzNdKj1QO2lmKEhbMl08MCl7SFswXT0tSFsyXTtIWzJdPTB9aWYoSFszXTwwKXtIWzFdPS1IWzNdO0hbM109MH19dmFyIE49bC5fcGFyc2VEb3RzKFEpO2lmKCFOKXtyZXR1cm4gbnVsbH1FPUUucmVwbGFjZSgvW1xcKFxcKVxccyxcXHhiMCNdL2csXCJfXCIpO2lmKE0uZ3JhZGllbnQmJkUhPU0uZ3JhZGllbnQuaWQpe0QuZGVmcy5yZW1vdmVDaGlsZChNLmdyYWRpZW50KTtkZWxldGUgTS5ncmFkaWVudH1pZighTS5ncmFkaWVudCl7Rj1pKE8rXCJHcmFkaWVudFwiLHtpZDpFfSk7TS5ncmFkaWVudD1GO2koRixPPT1cInJhZGlhbFwiP3tmeDpLLGZ5Okl9Ont4MTpIWzBdLHkxOkhbMV0seDI6SFsyXSx5MjpIWzNdLGdyYWRpZW50VHJhbnNmb3JtOk0ubWF0cml4LmludmVydCgpfSk7RC5kZWZzLmFwcGVuZENoaWxkKEYpO2Zvcih2YXIgTD0wLFI9Ti5sZW5ndGg7TDxSO0wrKyl7Ri5hcHBlbmRDaGlsZChpKFwic3RvcFwiLHtvZmZzZXQ6TltMXS5vZmZzZXQ/TltMXS5vZmZzZXQ6TD9cIjEwMCVcIjpcIjAlXCIsXCJzdG9wLWNvbG9yXCI6TltMXS5jb2xvcnx8XCIjZmZmXCJ9KSl9fX1pKEcse2ZpbGw6XCJ1cmwoI1wiK0UrXCIpXCIsb3BhY2l0eToxLFwiZmlsbC1vcGFjaXR5XCI6MX0pO1MuZmlsbD1yO1Mub3BhY2l0eT0xO1MuZmlsbE9wYWNpdHk9MTtyZXR1cm4gMX0sYj1mdW5jdGlvbihFKXt2YXIgRD1FLmdldEJCb3goMSk7aShFLnBhdHRlcm4se3BhdHRlcm5UcmFuc2Zvcm06RS5tYXRyaXguaW52ZXJ0KCkrXCIgdHJhbnNsYXRlKFwiK0QueCtcIixcIitELnkrXCIpXCJ9KX0sYz1mdW5jdGlvbihPLFEsSil7aWYoTy50eXBlPT1cInBhdGhcIil7dmFyIEQ9QihRKS50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLVwiKSxOPU8ucGFwZXIsYWI9Sj9cImVuZFwiOlwic3RhcnRcIixTPU8ubm9kZSxQPU8uYXR0cnMsST1QW1wic3Ryb2tlLXdpZHRoXCJdLFc9RC5sZW5ndGgsRz1cImNsYXNzaWNcIixWLEYsTCxULFIsSz0zLFg9MyxNPTU7d2hpbGUoVy0tKXtzd2l0Y2goRFtXXSl7Y2FzZVwiYmxvY2tcIjpjYXNlXCJjbGFzc2ljXCI6Y2FzZVwib3ZhbFwiOmNhc2VcImRpYW1vbmRcIjpjYXNlXCJvcGVuXCI6Y2FzZVwibm9uZVwiOkc9RFtXXTticmVhaztjYXNlXCJ3aWRlXCI6WD01O2JyZWFrO2Nhc2VcIm5hcnJvd1wiOlg9MjticmVhaztjYXNlXCJsb25nXCI6Sz01O2JyZWFrO2Nhc2VcInNob3J0XCI6Sz0yO2JyZWFrfX1pZihHPT1cIm9wZW5cIil7Sys9MjtYKz0yO00rPTI7TD0xO1Q9Sj80OjE7Uj17ZmlsbDpcIm5vbmVcIixzdHJva2U6UC5zdHJva2V9fWVsc2V7VD1MPUsvMjtSPXtmaWxsOlAuc3Ryb2tlLHN0cm9rZTpcIm5vbmVcIn19aWYoTy5fLmFycm93cyl7aWYoSil7Ty5fLmFycm93cy5lbmRQYXRoJiZ1W08uXy5hcnJvd3MuZW5kUGF0aF0tLTtPLl8uYXJyb3dzLmVuZE1hcmtlciYmdVtPLl8uYXJyb3dzLmVuZE1hcmtlcl0tLX1lbHNle08uXy5hcnJvd3Muc3RhcnRQYXRoJiZ1W08uXy5hcnJvd3Muc3RhcnRQYXRoXS0tO08uXy5hcnJvd3Muc3RhcnRNYXJrZXImJnVbTy5fLmFycm93cy5zdGFydE1hcmtlcl0tLX19ZWxzZXtPLl8uYXJyb3dzPXt9fWlmKEchPVwibm9uZVwiKXt2YXIgRT1cInJhcGhhZWwtbWFya2VyLVwiK0csYWE9XCJyYXBoYWVsLW1hcmtlci1cIithYitHK0srWDtpZighbC5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQoRSkpe04uZGVmcy5hcHBlbmRDaGlsZChpKGkoXCJwYXRoXCIpLHtcInN0cm9rZS1saW5lY2FwXCI6XCJyb3VuZFwiLGQ6eVtHXSxpZDpFfSkpO3VbRV09MX1lbHNle3VbRV0rK312YXIgSD1sLl9nLmRvYy5nZXRFbGVtZW50QnlJZChhYSksVTtpZighSCl7SD1pKGkoXCJtYXJrZXJcIikse2lkOmFhLG1hcmtlckhlaWdodDpYLG1hcmtlcldpZHRoOkssb3JpZW50OlwiYXV0b1wiLHJlZlg6VCxyZWZZOlgvMn0pO1U9aShpKFwidXNlXCIpLHtcInhsaW5rOmhyZWZcIjpcIiNcIitFLHRyYW5zZm9ybTooSj9cInJvdGF0ZSgxODAgXCIrSy8yK1wiIFwiK1gvMitcIikgXCI6cikrXCJzY2FsZShcIitLL00rXCIsXCIrWC9NK1wiKVwiLFwic3Ryb2tlLXdpZHRoXCI6KDEvKChLL00rWC9NKS8yKSkudG9GaXhlZCg0KX0pO0guYXBwZW5kQ2hpbGQoVSk7Ti5kZWZzLmFwcGVuZENoaWxkKEgpO3VbYWFdPTF9ZWxzZXt1W2FhXSsrO1U9SC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInVzZVwiKVswXX1pKFUsUik7dmFyIFo9TCooRyE9XCJkaWFtb25kXCImJkchPVwib3ZhbFwiKTtpZihKKXtWPU8uXy5hcnJvd3Muc3RhcnRkeCpJfHwwO0Y9bC5nZXRUb3RhbExlbmd0aChQLnBhdGgpLVoqSX1lbHNle1Y9WipJO0Y9bC5nZXRUb3RhbExlbmd0aChQLnBhdGgpLShPLl8uYXJyb3dzLmVuZGR4Kkl8fDApfVI9e307UltcIm1hcmtlci1cIithYl09XCJ1cmwoI1wiK2FhK1wiKVwiO2lmKEZ8fFYpe1IuZD1SYXBoYWVsLmdldFN1YnBhdGgoUC5wYXRoLFYsRil9aShTLFIpO08uXy5hcnJvd3NbYWIrXCJQYXRoXCJdPUU7Ty5fLmFycm93c1thYitcIk1hcmtlclwiXT1hYTtPLl8uYXJyb3dzW2FiK1wiZHhcIl09WjtPLl8uYXJyb3dzW2FiK1wiVHlwZVwiXT1HO08uXy5hcnJvd3NbYWIrXCJTdHJpbmdcIl09UX1lbHNle2lmKEope1Y9Ty5fLmFycm93cy5zdGFydGR4Kkl8fDA7Rj1sLmdldFRvdGFsTGVuZ3RoKFAucGF0aCktVn1lbHNle1Y9MDtGPWwuZ2V0VG90YWxMZW5ndGgoUC5wYXRoKS0oTy5fLmFycm93cy5lbmRkeCpJfHwwKX1PLl8uYXJyb3dzW2FiK1wiUGF0aFwiXSYmaShTLHtkOlJhcGhhZWwuZ2V0U3VicGF0aChQLnBhdGgsVixGKX0pO2RlbGV0ZSBPLl8uYXJyb3dzW2FiK1wiUGF0aFwiXTtkZWxldGUgTy5fLmFycm93c1thYitcIk1hcmtlclwiXTtkZWxldGUgTy5fLmFycm93c1thYitcImR4XCJdO2RlbGV0ZSBPLl8uYXJyb3dzW2FiK1wiVHlwZVwiXTtkZWxldGUgTy5fLmFycm93c1thYitcIlN0cmluZ1wiXX1mb3IoUiBpbiB1KXtpZih1W2RdKFIpJiYhdVtSXSl7dmFyIFk9bC5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQoUik7WSYmWS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKFkpfX19fSx2PXtcIlwiOlswXSxub25lOlswXSxcIi1cIjpbMywxXSxcIi5cIjpbMSwxXSxcIi0uXCI6WzMsMSwxLDFdLFwiLS4uXCI6WzMsMSwxLDEsMSwxXSxcIi4gXCI6WzEsM10sXCItIFwiOls0LDNdLFwiLS1cIjpbOCwzXSxcIi0gLlwiOls0LDMsMSwzXSxcIi0tLlwiOls4LDMsMSwzXSxcIi0tLi5cIjpbOCwzLDEsMywxLDNdfSxrPWZ1bmN0aW9uKEosSCxJKXtIPXZbQihIKS50b0xvd2VyQ2FzZSgpXTtpZihIKXt2YXIgRj1KLmF0dHJzW1wic3Ryb2tlLXdpZHRoXCJdfHxcIjFcIixEPXtyb3VuZDpGLHNxdWFyZTpGLGJ1dHQ6MH1bSi5hdHRyc1tcInN0cm9rZS1saW5lY2FwXCJdfHxJW1wic3Ryb2tlLWxpbmVjYXBcIl1dfHwwLEc9W10sRT1ILmxlbmd0aDt3aGlsZShFLS0pe0dbRV09SFtFXSpGKygoRSUyKT8xOi0xKSpEfWkoSi5ub2RlLHtcInN0cm9rZS1kYXNoYXJyYXlcIjpHLmpvaW4oXCIsXCIpfSl9fSx3PWZ1bmN0aW9uKE8sVyl7dmFyIFM9Ty5ub2RlLFA9Ty5hdHRycyxNPVMuc3R5bGUudmlzaWJpbGl0eTtcblMuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiO2Zvcih2YXIgUiBpbiBXKXtpZihXW2RdKFIpKXtpZighbC5fYXZhaWxhYmxlQXR0cnNbZF0oUikpe2NvbnRpbnVlfXZhciBRPVdbUl07UFtSXT1RO3N3aXRjaChSKXtjYXNlXCJibHVyXCI6Ty5ibHVyKFEpO2JyZWFrO2Nhc2VcImhyZWZcIjpjYXNlXCJ0aXRsZVwiOmNhc2VcInRhcmdldFwiOnZhciBVPVMucGFyZW50Tm9kZTtpZihVLnRhZ05hbWUudG9Mb3dlckNhc2UoKSE9XCJhXCIpe3ZhciBIPWkoXCJhXCIpO1UuaW5zZXJ0QmVmb3JlKEgsUyk7SC5hcHBlbmRDaGlsZChTKTtVPUh9aWYoUj09XCJ0YXJnZXRcIil7VS5zZXRBdHRyaWJ1dGVOUyhvLFwic2hvd1wiLFE9PVwiYmxhbmtcIj9cIm5ld1wiOlEpfWVsc2V7VS5zZXRBdHRyaWJ1dGVOUyhvLFIsUSl9YnJlYWs7Y2FzZVwiY3Vyc29yXCI6Uy5zdHlsZS5jdXJzb3I9UTticmVhaztjYXNlXCJ0cmFuc2Zvcm1cIjpPLnRyYW5zZm9ybShRKTticmVhaztjYXNlXCJhcnJvdy1zdGFydFwiOmMoTyxRKTticmVhaztjYXNlXCJhcnJvdy1lbmRcIjpjKE8sUSwxKTticmVhaztjYXNlXCJjbGlwLXJlY3RcIjp2YXIgRT1CKFEpLnNwbGl0KGcpO2lmKEUubGVuZ3RoPT00KXtPLmNsaXAmJk8uY2xpcC5wYXJlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoTy5jbGlwLnBhcmVudE5vZGUpO3ZhciBGPWkoXCJjbGlwUGF0aFwiKSxUPWkoXCJyZWN0XCIpO0YuaWQ9bC5jcmVhdGVVVUlEKCk7aShULHt4OkVbMF0seTpFWzFdLHdpZHRoOkVbMl0saGVpZ2h0OkVbM119KTtGLmFwcGVuZENoaWxkKFQpO08ucGFwZXIuZGVmcy5hcHBlbmRDaGlsZChGKTtpKFMse1wiY2xpcC1wYXRoXCI6XCJ1cmwoI1wiK0YuaWQrXCIpXCJ9KTtPLmNsaXA9VH1pZighUSl7dmFyIE49Uy5nZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIik7aWYoTil7dmFyIFY9bC5fZy5kb2MuZ2V0RWxlbWVudEJ5SWQoTi5yZXBsYWNlKC8oXnVybFxcKCN8XFwpJCkvZyxyKSk7ViYmVi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKFYpO2koUyx7XCJjbGlwLXBhdGhcIjpyfSk7ZGVsZXRlIE8uY2xpcH19YnJlYWs7Y2FzZVwicGF0aFwiOmlmKE8udHlwZT09XCJwYXRoXCIpe2koUyx7ZDpRP1AucGF0aD1sLl9wYXRoVG9BYnNvbHV0ZShRKTpcIk0wLDBcIn0pO08uXy5kaXJ0eT0xO2lmKE8uXy5hcnJvd3Mpe1wic3RhcnRTdHJpbmdcIiBpbiBPLl8uYXJyb3dzJiZjKE8sTy5fLmFycm93cy5zdGFydFN0cmluZyk7XCJlbmRTdHJpbmdcIiBpbiBPLl8uYXJyb3dzJiZjKE8sTy5fLmFycm93cy5lbmRTdHJpbmcsMSl9fWJyZWFrO2Nhc2VcIndpZHRoXCI6Uy5zZXRBdHRyaWJ1dGUoUixRKTtPLl8uZGlydHk9MTtpZihQLmZ4KXtSPVwieFwiO1E9UC54fWVsc2V7YnJlYWt9Y2FzZVwieFwiOmlmKFAuZngpe1E9LVAueC0oUC53aWR0aHx8MCl9Y2FzZVwicnhcIjppZihSPT1cInJ4XCImJk8udHlwZT09XCJyZWN0XCIpe2JyZWFrfWNhc2VcImN4XCI6Uy5zZXRBdHRyaWJ1dGUoUixRKTtPLnBhdHRlcm4mJmIoTyk7Ty5fLmRpcnR5PTE7YnJlYWs7Y2FzZVwiaGVpZ2h0XCI6Uy5zZXRBdHRyaWJ1dGUoUixRKTtPLl8uZGlydHk9MTtpZihQLmZ5KXtSPVwieVwiO1E9UC55fWVsc2V7YnJlYWt9Y2FzZVwieVwiOmlmKFAuZnkpe1E9LVAueS0oUC5oZWlnaHR8fDApfWNhc2VcInJ5XCI6aWYoUj09XCJyeVwiJiZPLnR5cGU9PVwicmVjdFwiKXticmVha31jYXNlXCJjeVwiOlMuc2V0QXR0cmlidXRlKFIsUSk7Ty5wYXR0ZXJuJiZiKE8pO08uXy5kaXJ0eT0xO2JyZWFrO2Nhc2VcInJcIjppZihPLnR5cGU9PVwicmVjdFwiKXtpKFMse3J4OlEscnk6UX0pfWVsc2V7Uy5zZXRBdHRyaWJ1dGUoUixRKX1PLl8uZGlydHk9MTticmVhaztjYXNlXCJzcmNcIjppZihPLnR5cGU9PVwiaW1hZ2VcIil7Uy5zZXRBdHRyaWJ1dGVOUyhvLFwiaHJlZlwiLFEpfWJyZWFrO2Nhc2VcInN0cm9rZS13aWR0aFwiOmlmKE8uXy5zeCE9MXx8Ty5fLnN5IT0xKXtRLz1DKHMoTy5fLnN4KSxzKE8uXy5zeSkpfHwxfWlmKE8ucGFwZXIuX3ZiU2l6ZSl7USo9Ty5wYXBlci5fdmJTaXplfVMuc2V0QXR0cmlidXRlKFIsUSk7aWYoUFtcInN0cm9rZS1kYXNoYXJyYXlcIl0pe2soTyxQW1wic3Ryb2tlLWRhc2hhcnJheVwiXSxXKX1pZihPLl8uYXJyb3dzKXtcInN0YXJ0U3RyaW5nXCIgaW4gTy5fLmFycm93cyYmYyhPLE8uXy5hcnJvd3Muc3RhcnRTdHJpbmcpO1wiZW5kU3RyaW5nXCIgaW4gTy5fLmFycm93cyYmYyhPLE8uXy5hcnJvd3MuZW5kU3RyaW5nLDEpfWJyZWFrO2Nhc2VcInN0cm9rZS1kYXNoYXJyYXlcIjprKE8sUSxXKTticmVhaztjYXNlXCJmaWxsXCI6dmFyIEk9QihRKS5tYXRjaChsLl9JU1VSTCk7aWYoSSl7Rj1pKFwicGF0dGVyblwiKTt2YXIgTD1pKFwiaW1hZ2VcIik7Ri5pZD1sLmNyZWF0ZVVVSUQoKTtpKEYse3g6MCx5OjAscGF0dGVyblVuaXRzOlwidXNlclNwYWNlT25Vc2VcIixoZWlnaHQ6MSx3aWR0aDoxfSk7aShMLHt4OjAseTowLFwieGxpbms6aHJlZlwiOklbMV19KTtGLmFwcGVuZENoaWxkKEwpOyhmdW5jdGlvbihYKXtsLl9wcmVsb2FkKElbMV0sZnVuY3Rpb24oKXt2YXIgWT10aGlzLm9mZnNldFdpZHRoLFo9dGhpcy5vZmZzZXRIZWlnaHQ7aShYLHt3aWR0aDpZLGhlaWdodDpafSk7aShMLHt3aWR0aDpZLGhlaWdodDpafSk7Ty5wYXBlci5zYWZhcmkoKX0pfSkoRik7Ty5wYXBlci5kZWZzLmFwcGVuZENoaWxkKEYpO2koUyx7ZmlsbDpcInVybCgjXCIrRi5pZCtcIilcIn0pO08ucGF0dGVybj1GO08ucGF0dGVybiYmYihPKTticmVha312YXIgRz1sLmdldFJHQihRKTtpZighRy5lcnJvcil7ZGVsZXRlIFcuZ3JhZGllbnQ7ZGVsZXRlIFAuZ3JhZGllbnQ7IWwuaXMoUC5vcGFjaXR5LFwidW5kZWZpbmVkXCIpJiZsLmlzKFcub3BhY2l0eSxcInVuZGVmaW5lZFwiKSYmaShTLHtvcGFjaXR5OlAub3BhY2l0eX0pOyFsLmlzKFBbXCJmaWxsLW9wYWNpdHlcIl0sXCJ1bmRlZmluZWRcIikmJmwuaXMoV1tcImZpbGwtb3BhY2l0eVwiXSxcInVuZGVmaW5lZFwiKSYmaShTLHtcImZpbGwtb3BhY2l0eVwiOlBbXCJmaWxsLW9wYWNpdHlcIl19KX1lbHNle2lmKChPLnR5cGU9PVwiY2lyY2xlXCJ8fE8udHlwZT09XCJlbGxpcHNlXCJ8fEIoUSkuY2hhckF0KCkhPVwiclwiKSYmYShPLFEpKXtpZihcIm9wYWNpdHlcIiBpbiBQfHxcImZpbGwtb3BhY2l0eVwiIGluIFApe3ZhciBEPWwuX2cuZG9jLmdldEVsZW1lbnRCeUlkKFMuZ2V0QXR0cmlidXRlKFwiZmlsbFwiKS5yZXBsYWNlKC9edXJsXFwoI3xcXCkkL2cscikpO2lmKEQpe3ZhciBKPUQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdG9wXCIpO2koSltKLmxlbmd0aC0xXSx7XCJzdG9wLW9wYWNpdHlcIjooXCJvcGFjaXR5XCIgaW4gUD9QLm9wYWNpdHk6MSkqKFwiZmlsbC1vcGFjaXR5XCIgaW4gUD9QW1wiZmlsbC1vcGFjaXR5XCJdOjEpfSl9fVAuZ3JhZGllbnQ9UTtQLmZpbGw9XCJub25lXCI7YnJlYWt9fUdbZF0oXCJvcGFjaXR5XCIpJiZpKFMse1wiZmlsbC1vcGFjaXR5XCI6Ry5vcGFjaXR5PjE/Ry5vcGFjaXR5LzEwMDpHLm9wYWNpdHl9KTtjYXNlXCJzdHJva2VcIjpHPWwuZ2V0UkdCKFEpO1Muc2V0QXR0cmlidXRlKFIsRy5oZXgpO1I9PVwic3Ryb2tlXCImJkdbZF0oXCJvcGFjaXR5XCIpJiZpKFMse1wic3Ryb2tlLW9wYWNpdHlcIjpHLm9wYWNpdHk+MT9HLm9wYWNpdHkvMTAwOkcub3BhY2l0eX0pO2lmKFI9PVwic3Ryb2tlXCImJk8uXy5hcnJvd3Mpe1wic3RhcnRTdHJpbmdcIiBpbiBPLl8uYXJyb3dzJiZjKE8sTy5fLmFycm93cy5zdGFydFN0cmluZyk7XCJlbmRTdHJpbmdcIiBpbiBPLl8uYXJyb3dzJiZjKE8sTy5fLmFycm93cy5lbmRTdHJpbmcsMSl9YnJlYWs7Y2FzZVwiZ3JhZGllbnRcIjooTy50eXBlPT1cImNpcmNsZVwifHxPLnR5cGU9PVwiZWxsaXBzZVwifHxCKFEpLmNoYXJBdCgpIT1cInJcIikmJmEoTyxRKTticmVhaztjYXNlXCJvcGFjaXR5XCI6aWYoUC5ncmFkaWVudCYmIVBbZF0oXCJzdHJva2Utb3BhY2l0eVwiKSl7aShTLHtcInN0cm9rZS1vcGFjaXR5XCI6UT4xP1EvMTAwOlF9KX1jYXNlXCJmaWxsLW9wYWNpdHlcIjppZihQLmdyYWRpZW50KXtEPWwuX2cuZG9jLmdldEVsZW1lbnRCeUlkKFMuZ2V0QXR0cmlidXRlKFwiZmlsbFwiKS5yZXBsYWNlKC9edXJsXFwoI3xcXCkkL2cscikpO2lmKEQpe0o9RC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0b3BcIik7aShKW0oubGVuZ3RoLTFdLHtcInN0b3Atb3BhY2l0eVwiOlF9KX1icmVha31kZWZhdWx0OlI9PVwiZm9udC1zaXplXCImJihRPXEoUSwxMCkrXCJweFwiKTt2YXIgSz1SLnJlcGxhY2UoLyhcXC0uKS9nLGZ1bmN0aW9uKFgpe3JldHVybiBYLnN1YnN0cmluZygxKS50b1VwcGVyQ2FzZSgpfSk7Uy5zdHlsZVtLXT1RO08uXy5kaXJ0eT0xO1Muc2V0QXR0cmlidXRlKFIsUSk7YnJlYWt9fX1wKE8sVyk7Uy5zdHlsZS52aXNpYmlsaXR5PU19LEE9MS4yLHA9ZnVuY3Rpb24oRCxIKXtpZihELnR5cGUhPVwidGV4dFwifHwhKEhbZF0oXCJ0ZXh0XCIpfHxIW2RdKFwiZm9udFwiKXx8SFtkXShcImZvbnQtc2l6ZVwiKXx8SFtkXShcInhcIil8fEhbZF0oXCJ5XCIpKSl7cmV0dXJufXZhciBNPUQuYXR0cnMsRj1ELm5vZGUsTz1GLmZpcnN0Q2hpbGQ/cShsLl9nLmRvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKEYuZmlyc3RDaGlsZCxyKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1zaXplXCIpLDEwKToxMDtpZihIW2RdKFwidGV4dFwiKSl7TS50ZXh0PUgudGV4dDt3aGlsZShGLmZpcnN0Q2hpbGQpe0YucmVtb3ZlQ2hpbGQoRi5maXJzdENoaWxkKX12YXIgRz1CKEgudGV4dCkuc3BsaXQoXCJcXG5cIiksRT1bXSxLO2Zvcih2YXIgST0wLE49Ry5sZW5ndGg7STxOO0krKyl7Sz1pKFwidHNwYW5cIik7SSYmaShLLHtkeTpPKkEseDpNLnh9KTtLLmFwcGVuZENoaWxkKGwuX2cuZG9jLmNyZWF0ZVRleHROb2RlKEdbSV0pKTtGLmFwcGVuZENoaWxkKEspO0VbSV09S319ZWxzZXtFPUYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKTtmb3IoST0wLE49RS5sZW5ndGg7STxOO0krKyl7aWYoSSl7aShFW0ldLHtkeTpPKkEseDpNLnh9KX1lbHNle2koRVswXSx7ZHk6MH0pfX19aShGLHt4Ok0ueCx5Ok0ueX0pO0QuXy5kaXJ0eT0xO3ZhciBKPUQuX2dldEJCb3goKSxMPU0ueS0oSi55K0ouaGVpZ2h0LzIpO0wmJmwuaXMoTCxcImZpbml0ZVwiKSYmaShFWzBdLHtkeTpMfSl9LHQ9ZnVuY3Rpb24oRSxEKXt2YXIgRz0wLEY9MDt0aGlzWzBdPXRoaXMubm9kZT1FO0UucmFwaGFlbD10cnVlO3RoaXMuaWQ9bC5fb2lkKys7RS5yYXBoYWVsaWQ9dGhpcy5pZDt0aGlzLm1hdHJpeD1sLm1hdHJpeCgpO3RoaXMucmVhbFBhdGg9bnVsbDt0aGlzLnBhcGVyPUQ7dGhpcy5hdHRycz10aGlzLmF0dHJzfHx7fTt0aGlzLl89e3RyYW5zZm9ybTpbXSxzeDoxLHN5OjEsZGVnOjAsZHg6MCxkeTowLGRpcnR5OjF9OyFELmJvdHRvbSYmKEQuYm90dG9tPXRoaXMpO3RoaXMucHJldj1ELnRvcDtELnRvcCYmKEQudG9wLm5leHQ9dGhpcyk7RC50b3A9dGhpczt0aGlzLm5leHQ9bnVsbH0sbT1sLmVsO3QucHJvdG90eXBlPW07bS5jb25zdHJ1Y3Rvcj10O2wuX2VuZ2luZS5wYXRoPWZ1bmN0aW9uKEQsRyl7dmFyIEU9aShcInBhdGhcIik7Ry5jYW52YXMmJkcuY2FudmFzLmFwcGVuZENoaWxkKEUpO3ZhciBGPW5ldyB0KEUsRyk7Ri50eXBlPVwicGF0aFwiO3coRix7ZmlsbDpcIm5vbmVcIixzdHJva2U6XCIjMDAwXCIscGF0aDpEfSk7cmV0dXJuIEZ9O20ucm90YXRlPWZ1bmN0aW9uKEUsRCxHKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfUU9QihFKS5zcGxpdChnKTtpZihFLmxlbmd0aC0xKXtEPW4oRVsxXSk7Rz1uKEVbMl0pfUU9bihFWzBdKTsoRz09bnVsbCkmJihEPUcpO2lmKEQ9PW51bGx8fEc9PW51bGwpe3ZhciBGPXRoaXMuZ2V0QkJveCgxKTtEPUYueCtGLndpZHRoLzI7Rz1GLnkrRi5oZWlnaHQvMn10aGlzLnRyYW5zZm9ybSh0aGlzLl8udHJhbnNmb3JtLmNvbmNhdChbW1wiclwiLEUsRCxHXV0pKTtyZXR1cm4gdGhpc307bS5zY2FsZT1mdW5jdGlvbihILEYsRCxHKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfUg9QihIKS5zcGxpdChnKTtpZihILmxlbmd0aC0xKXtGPW4oSFsxXSk7RD1uKEhbMl0pO0c9bihIWzNdKX1IPW4oSFswXSk7KEY9PW51bGwpJiYoRj1IKTsoRz09bnVsbCkmJihEPUcpO2lmKEQ9PW51bGx8fEc9PW51bGwpe3ZhciBFPXRoaXMuZ2V0QkJveCgxKX1EPUQ9PW51bGw/RS54K0Uud2lkdGgvMjpEO0c9Rz09bnVsbD9FLnkrRS5oZWlnaHQvMjpHO3RoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJzXCIsSCxGLEQsR11dKSk7cmV0dXJuIHRoaXN9O20udHJhbnNsYXRlPWZ1bmN0aW9uKEUsRCl7aWYodGhpcy5yZW1vdmVkKXtyZXR1cm4gdGhpc31FPUIoRSkuc3BsaXQoZyk7aWYoRS5sZW5ndGgtMSl7RD1uKEVbMV0pfUU9bihFWzBdKXx8MDtEPStEfHwwO3RoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJ0XCIsRSxEXV0pKTtyZXR1cm4gdGhpc307bS50cmFuc2Zvcm09ZnVuY3Rpb24oRSl7dmFyIEY9dGhpcy5fO2lmKEU9PW51bGwpe3JldHVybiBGLnRyYW5zZm9ybX1sLl9leHRyYWN0VHJhbnNmb3JtKHRoaXMsRSk7dGhpcy5jbGlwJiZpKHRoaXMuY2xpcCx7dHJhbnNmb3JtOnRoaXMubWF0cml4LmludmVydCgpfSk7dGhpcy5wYXR0ZXJuJiZiKHRoaXMpO3RoaXMubm9kZSYmaSh0aGlzLm5vZGUse3RyYW5zZm9ybTp0aGlzLm1hdHJpeH0pO2lmKEYuc3ghPTF8fEYuc3khPTEpe3ZhciBEPXRoaXMuYXR0cnNbZF0oXCJzdHJva2Utd2lkdGhcIik/dGhpcy5hdHRyc1tcInN0cm9rZS13aWR0aFwiXToxO3RoaXMuYXR0cih7XCJzdHJva2Utd2lkdGhcIjpEfSl9cmV0dXJuIHRoaXN9O20uaGlkZT1mdW5jdGlvbigpeyF0aGlzLnJlbW92ZWQmJnRoaXMucGFwZXIuc2FmYXJpKHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKTtyZXR1cm4gdGhpc307bS5zaG93PWZ1bmN0aW9uKCl7IXRoaXMucmVtb3ZlZCYmdGhpcy5wYXBlci5zYWZhcmkodGhpcy5ub2RlLnN0eWxlLmRpc3BsYXk9XCJcIik7cmV0dXJuIHRoaXN9O20ucmVtb3ZlPWZ1bmN0aW9uKCl7aWYodGhpcy5yZW1vdmVkfHwhdGhpcy5ub2RlLnBhcmVudE5vZGUpe3JldHVybn12YXIgRT10aGlzLnBhcGVyO0UuX19zZXRfXyYmRS5fX3NldF9fLmV4Y2x1ZGUodGhpcyk7ei51bmJpbmQoXCJyYXBoYWVsLiouKi5cIit0aGlzLmlkKTtpZih0aGlzLmdyYWRpZW50KXtFLmRlZnMucmVtb3ZlQ2hpbGQodGhpcy5ncmFkaWVudCl9bC5fdGVhcih0aGlzLEUpO1xuaWYodGhpcy5ub2RlLnBhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1cImFcIil7dGhpcy5ub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUucGFyZW50Tm9kZSl9ZWxzZXt0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpfWZvcih2YXIgRCBpbiB0aGlzKXt0aGlzW0RdPXR5cGVvZiB0aGlzW0RdPT1cImZ1bmN0aW9uXCI/bC5fcmVtb3ZlZEZhY3RvcnkoRCk6bnVsbH10aGlzLnJlbW92ZWQ9dHJ1ZX07bS5fZ2V0QkJveD1mdW5jdGlvbigpe2lmKHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5PT1cIm5vbmVcIil7dGhpcy5zaG93KCk7dmFyIEQ9dHJ1ZX12YXIgRj17fTt0cnl7Rj10aGlzLm5vZGUuZ2V0QkJveCgpfWNhdGNoKEUpe31maW5hbGx5e0Y9Rnx8e319RCYmdGhpcy5oaWRlKCk7cmV0dXJuIEZ9O20uYXR0cj1mdW5jdGlvbihELE0pe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJuIHRoaXN9aWYoRD09bnVsbCl7dmFyIEo9e307Zm9yKHZhciBMIGluIHRoaXMuYXR0cnMpe2lmKHRoaXMuYXR0cnNbZF0oTCkpe0pbTF09dGhpcy5hdHRyc1tMXX19Si5ncmFkaWVudCYmSi5maWxsPT1cIm5vbmVcIiYmKEouZmlsbD1KLmdyYWRpZW50KSYmZGVsZXRlIEouZ3JhZGllbnQ7Si50cmFuc2Zvcm09dGhpcy5fLnRyYW5zZm9ybTtyZXR1cm4gSn1pZihNPT1udWxsJiZsLmlzKEQsXCJzdHJpbmdcIikpe2lmKEQ9PVwiZmlsbFwiJiZ0aGlzLmF0dHJzLmZpbGw9PVwibm9uZVwiJiZ0aGlzLmF0dHJzLmdyYWRpZW50KXtyZXR1cm4gdGhpcy5hdHRycy5ncmFkaWVudH1pZihEPT1cInRyYW5zZm9ybVwiKXtyZXR1cm4gdGhpcy5fLnRyYW5zZm9ybX12YXIgSz1ELnNwbGl0KGcpLEc9e307Zm9yKHZhciBIPTAsTz1LLmxlbmd0aDtIPE87SCsrKXtEPUtbSF07aWYoRCBpbiB0aGlzLmF0dHJzKXtHW0RdPXRoaXMuYXR0cnNbRF19ZWxzZXtpZihsLmlzKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tEXSxcImZ1bmN0aW9uXCIpKXtHW0RdPXRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tEXS5kZWZ9ZWxzZXtHW0RdPWwuX2F2YWlsYWJsZUF0dHJzW0RdfX19cmV0dXJuIE8tMT9HOkdbS1swXV19aWYoTT09bnVsbCYmbC5pcyhELFwiYXJyYXlcIikpe0c9e307Zm9yKEg9MCxPPUQubGVuZ3RoO0g8TztIKyspe0dbRFtIXV09dGhpcy5hdHRyKERbSF0pfXJldHVybiBHfWlmKE0hPW51bGwpe3ZhciBFPXt9O0VbRF09TX1lbHNle2lmKEQhPW51bGwmJmwuaXMoRCxcIm9iamVjdFwiKSl7RT1EfX1mb3IodmFyIE4gaW4gRSl7eihcInJhcGhhZWwuYXR0ci5cIitOK1wiLlwiK3RoaXMuaWQsdGhpcyxFW05dKX1mb3IoTiBpbiB0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXMpe2lmKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tkXShOKSYmRVtkXShOKSYmbC5pcyh0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbTl0sXCJmdW5jdGlvblwiKSl7dmFyIEk9dGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW05dLmFwcGx5KHRoaXMsW10uY29uY2F0KEVbTl0pKTt0aGlzLmF0dHJzW05dPUVbTl07Zm9yKHZhciBGIGluIEkpe2lmKElbZF0oRikpe0VbRl09SVtGXX19fX13KHRoaXMsRSk7cmV0dXJuIHRoaXN9O20udG9Gcm9udD1mdW5jdGlvbigpe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJuIHRoaXN9aWYodGhpcy5ub2RlLnBhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1cImFcIil7dGhpcy5ub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUucGFyZW50Tm9kZSl9ZWxzZXt0aGlzLm5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpfXZhciBEPXRoaXMucGFwZXI7RC50b3AhPXRoaXMmJmwuX3RvZnJvbnQodGhpcyxEKTtyZXR1cm4gdGhpc307bS50b0JhY2s9ZnVuY3Rpb24oKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfXZhciBFPXRoaXMubm9kZS5wYXJlbnROb2RlO2lmKEUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1cImFcIil7RS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUucGFyZW50Tm9kZSx0aGlzLm5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpfWVsc2V7aWYoRS5maXJzdENoaWxkIT10aGlzLm5vZGUpe0UuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSx0aGlzLm5vZGUucGFyZW50Tm9kZS5maXJzdENoaWxkKX19bC5fdG9iYWNrKHRoaXMsdGhpcy5wYXBlcik7dmFyIEQ9dGhpcy5wYXBlcjtyZXR1cm4gdGhpc307bS5pbnNlcnRBZnRlcj1mdW5jdGlvbihEKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfXZhciBFPUQubm9kZXx8RFtELmxlbmd0aC0xXS5ub2RlO2lmKEUubmV4dFNpYmxpbmcpe0UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLEUubmV4dFNpYmxpbmcpfWVsc2V7RS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSl9bC5faW5zZXJ0YWZ0ZXIodGhpcyxELHRoaXMucGFwZXIpO3JldHVybiB0aGlzfTttLmluc2VydEJlZm9yZT1mdW5jdGlvbihEKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfXZhciBFPUQubm9kZXx8RFswXS5ub2RlO0UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLEUpO2wuX2luc2VydGJlZm9yZSh0aGlzLEQsdGhpcy5wYXBlcik7cmV0dXJuIHRoaXN9O20uYmx1cj1mdW5jdGlvbihFKXt2YXIgRD10aGlzO2lmKCtFIT09MCl7dmFyIEY9aShcImZpbHRlclwiKSxHPWkoXCJmZUdhdXNzaWFuQmx1clwiKTtELmF0dHJzLmJsdXI9RTtGLmlkPWwuY3JlYXRlVVVJRCgpO2koRyx7c3RkRGV2aWF0aW9uOitFfHwxLjV9KTtGLmFwcGVuZENoaWxkKEcpO0QucGFwZXIuZGVmcy5hcHBlbmRDaGlsZChGKTtELl9ibHVyPUY7aShELm5vZGUse2ZpbHRlcjpcInVybCgjXCIrRi5pZCtcIilcIn0pfWVsc2V7aWYoRC5fYmx1cil7RC5fYmx1ci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKEQuX2JsdXIpO2RlbGV0ZSBELl9ibHVyO2RlbGV0ZSBELmF0dHJzLmJsdXJ9RC5ub2RlLnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKX19O2wuX2VuZ2luZS5jaXJjbGU9ZnVuY3Rpb24oRSxELEksSCl7dmFyIEc9aShcImNpcmNsZVwiKTtFLmNhbnZhcyYmRS5jYW52YXMuYXBwZW5kQ2hpbGQoRyk7dmFyIEY9bmV3IHQoRyxFKTtGLmF0dHJzPXtjeDpELGN5OkkscjpILGZpbGw6XCJub25lXCIsc3Ryb2tlOlwiIzAwMFwifTtGLnR5cGU9XCJjaXJjbGVcIjtpKEcsRi5hdHRycyk7cmV0dXJuIEZ9O2wuX2VuZ2luZS5yZWN0PWZ1bmN0aW9uKEYsRCxLLEUsSSxKKXt2YXIgSD1pKFwicmVjdFwiKTtGLmNhbnZhcyYmRi5jYW52YXMuYXBwZW5kQ2hpbGQoSCk7dmFyIEc9bmV3IHQoSCxGKTtHLmF0dHJzPXt4OkQseTpLLHdpZHRoOkUsaGVpZ2h0OkkscjpKfHwwLHJ4Okp8fDAscnk6Snx8MCxmaWxsOlwibm9uZVwiLHN0cm9rZTpcIiMwMDBcIn07Ry50eXBlPVwicmVjdFwiO2koSCxHLmF0dHJzKTtyZXR1cm4gR307bC5fZW5naW5lLmVsbGlwc2U9ZnVuY3Rpb24oRSxELEosSSxIKXt2YXIgRz1pKFwiZWxsaXBzZVwiKTtFLmNhbnZhcyYmRS5jYW52YXMuYXBwZW5kQ2hpbGQoRyk7dmFyIEY9bmV3IHQoRyxFKTtGLmF0dHJzPXtjeDpELGN5Okoscng6SSxyeTpILGZpbGw6XCJub25lXCIsc3Ryb2tlOlwiIzAwMFwifTtGLnR5cGU9XCJlbGxpcHNlXCI7aShHLEYuYXR0cnMpO3JldHVybiBGfTtsLl9lbmdpbmUuaW1hZ2U9ZnVuY3Rpb24oRixKLEQsSyxFLEkpe3ZhciBIPWkoXCJpbWFnZVwiKTtpKEgse3g6RCx5Okssd2lkdGg6RSxoZWlnaHQ6SSxwcmVzZXJ2ZUFzcGVjdFJhdGlvOlwibm9uZVwifSk7SC5zZXRBdHRyaWJ1dGVOUyhvLFwiaHJlZlwiLEopO0YuY2FudmFzJiZGLmNhbnZhcy5hcHBlbmRDaGlsZChIKTt2YXIgRz1uZXcgdChILEYpO0cuYXR0cnM9e3g6RCx5Okssd2lkdGg6RSxoZWlnaHQ6SSxzcmM6Sn07Ry50eXBlPVwiaW1hZ2VcIjtyZXR1cm4gR307bC5fZW5naW5lLnRleHQ9ZnVuY3Rpb24oRSxELEksSCl7dmFyIEc9aShcInRleHRcIik7RS5jYW52YXMmJkUuY2FudmFzLmFwcGVuZENoaWxkKEcpO3ZhciBGPW5ldyB0KEcsRSk7Ri5hdHRycz17eDpELHk6SSxcInRleHQtYW5jaG9yXCI6XCJtaWRkbGVcIix0ZXh0OkgsZm9udDpsLl9hdmFpbGFibGVBdHRycy5mb250LHN0cm9rZTpcIm5vbmVcIixmaWxsOlwiIzAwMFwifTtGLnR5cGU9XCJ0ZXh0XCI7dyhGLEYuYXR0cnMpO3JldHVybiBGfTtsLl9lbmdpbmUuc2V0U2l6ZT1mdW5jdGlvbihFLEQpe3RoaXMud2lkdGg9RXx8dGhpcy53aWR0aDt0aGlzLmhlaWdodD1EfHx0aGlzLmhlaWdodDt0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLHRoaXMud2lkdGgpO3RoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLHRoaXMuaGVpZ2h0KTtpZih0aGlzLl92aWV3Qm94KXt0aGlzLnNldFZpZXdCb3guYXBwbHkodGhpcyx0aGlzLl92aWV3Qm94KX1yZXR1cm4gdGhpc307bC5fZW5naW5lLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBHPWwuX2dldENvbnRhaW5lci5hcHBseSgwLGFyZ3VtZW50cyksRT1HJiZHLmNvbnRhaW5lcixLPUcueCxKPUcueSxGPUcud2lkdGgsTD1HLmhlaWdodDtpZighRSl7dGhyb3cgbmV3IEVycm9yKFwiU1ZHIGNvbnRhaW5lciBub3QgZm91bmQuXCIpfXZhciBEPWkoXCJzdmdcIiksST1cIm92ZXJmbG93OmhpZGRlbjtcIixIO0s9S3x8MDtKPUp8fDA7Rj1GfHw1MTI7TD1MfHwzNDI7aShELHtoZWlnaHQ6TCx2ZXJzaW9uOjEuMSx3aWR0aDpGLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0pO2lmKEU9PTEpe0Quc3R5bGUuY3NzVGV4dD1JK1wicG9zaXRpb246YWJzb2x1dGU7bGVmdDpcIitLK1wicHg7dG9wOlwiK0orXCJweFwiO2wuX2cuZG9jLmJvZHkuYXBwZW5kQ2hpbGQoRCk7SD0xfWVsc2V7RC5zdHlsZS5jc3NUZXh0PUkrXCJwb3NpdGlvbjpyZWxhdGl2ZVwiO2lmKEUuZmlyc3RDaGlsZCl7RS5pbnNlcnRCZWZvcmUoRCxFLmZpcnN0Q2hpbGQpfWVsc2V7RS5hcHBlbmRDaGlsZChEKX19RT1uZXcgbC5fUGFwZXI7RS53aWR0aD1GO0UuaGVpZ2h0PUw7RS5jYW52YXM9RDtFLmNsZWFyKCk7RS5fbGVmdD1FLl90b3A9MDtIJiYoRS5yZW5kZXJmaXg9ZnVuY3Rpb24oKXt9KTtFLnJlbmRlcmZpeCgpO3JldHVybiBFfTtsLl9lbmdpbmUuc2V0Vmlld0JveD1mdW5jdGlvbihJLEcsSyxELEUpe3ooXCJyYXBoYWVsLnNldFZpZXdCb3hcIix0aGlzLHRoaXMuX3ZpZXdCb3gsW0ksRyxLLEQsRV0pO3ZhciBNPUMoSy90aGlzLndpZHRoLEQvdGhpcy5oZWlnaHQpLEg9dGhpcy50b3AsTD1FP1wibWVldFwiOlwieE1pbllNaW5cIixGLEo7aWYoST09bnVsbCl7aWYodGhpcy5fdmJTaXplKXtNPTF9ZGVsZXRlIHRoaXMuX3ZiU2l6ZTtGPVwiMCAwIFwiK3RoaXMud2lkdGgrait0aGlzLmhlaWdodH1lbHNle3RoaXMuX3ZiU2l6ZT1NO0Y9SStqK0craitLK2orRH1pKHRoaXMuY2FudmFzLHt2aWV3Qm94OkYscHJlc2VydmVBc3BlY3RSYXRpbzpMfSk7d2hpbGUoTSYmSCl7Sj1cInN0cm9rZS13aWR0aFwiIGluIEguYXR0cnM/SC5hdHRyc1tcInN0cm9rZS13aWR0aFwiXToxO0guYXR0cih7XCJzdHJva2Utd2lkdGhcIjpKfSk7SC5fLmRpcnR5PTE7SC5fLmRpcnR5VD0xO0g9SC5wcmV2fXRoaXMuX3ZpZXdCb3g9W0ksRyxLLEQsISFFXTtyZXR1cm4gdGhpc307bC5wcm90b3R5cGUucmVuZGVyZml4PWZ1bmN0aW9uKCl7dmFyIEk9dGhpcy5jYW52YXMsRD1JLnN0eWxlLEg7dHJ5e0g9SS5nZXRTY3JlZW5DVE0oKXx8SS5jcmVhdGVTVkdNYXRyaXgoKX1jYXRjaChHKXtIPUkuY3JlYXRlU1ZHTWF0cml4KCl9dmFyIEY9LUguZSUxLEU9LUguZiUxO2lmKEZ8fEUpe2lmKEYpe3RoaXMuX2xlZnQ9KHRoaXMuX2xlZnQrRiklMTtELmxlZnQ9dGhpcy5fbGVmdCtcInB4XCJ9aWYoRSl7dGhpcy5fdG9wPSh0aGlzLl90b3ArRSklMTtELnRvcD10aGlzLl90b3ArXCJweFwifX19O2wucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7bC5ldmUoXCJyYXBoYWVsLmNsZWFyXCIsdGhpcyk7dmFyIEQ9dGhpcy5jYW52YXM7d2hpbGUoRC5maXJzdENoaWxkKXtELnJlbW92ZUNoaWxkKEQuZmlyc3RDaGlsZCl9dGhpcy5ib3R0b209dGhpcy50b3A9bnVsbDsodGhpcy5kZXNjPWkoXCJkZXNjXCIpKS5hcHBlbmRDaGlsZChsLl9nLmRvYy5jcmVhdGVUZXh0Tm9kZShcIkNyZWF0ZWQgd2l0aCBSYXBoYVxceGVibCBcIitsLnZlcnNpb24pKTtELmFwcGVuZENoaWxkKHRoaXMuZGVzYyk7RC5hcHBlbmRDaGlsZCh0aGlzLmRlZnM9aShcImRlZnNcIikpfTtsLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt6KFwicmFwaGFlbC5yZW1vdmVcIix0aGlzKTt0aGlzLmNhbnZhcy5wYXJlbnROb2RlJiZ0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtmb3IodmFyIEQgaW4gdGhpcyl7dGhpc1tEXT10eXBlb2YgdGhpc1tEXT09XCJmdW5jdGlvblwiP2wuX3JlbW92ZWRGYWN0b3J5KEQpOm51bGx9fTt2YXIgeD1sLnN0O2Zvcih2YXIgZSBpbiBtKXtpZihtW2RdKGUpJiYheFtkXShlKSl7eFtlXT0oZnVuY3Rpb24oRCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIEU9YXJndW1lbnRzO3JldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oRil7RltEXS5hcHBseShGLEUpfSl9fSkoZSl9fX0od2luZG93LlJhcGhhZWwpO3dpbmRvdy5SYXBoYWVsLnZtbCYmZnVuY3Rpb24obCl7dmFyIGU9XCJoYXNPd25Qcm9wZXJ0eVwiLEY9U3RyaW5nLG49cGFyc2VGbG9hdCxoPU1hdGgsQj1oLnJvdW5kLEk9aC5tYXgsQz1oLm1pbixzPWguYWJzLHY9XCJmaWxsXCIsaT0vWywgXSsvLEE9bC5ldmUsdz1cIiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnRcIixrPVwiIFwiLHE9XCJcIixEPXtNOlwibVwiLEw6XCJsXCIsQzpcImNcIixaOlwieFwiLG06XCJ0XCIsbDpcInJcIixjOlwidlwiLHo6XCJ4XCJ9LGo9LyhbY2xtel0pLD8oW15jbG16XSopL2dpLHQ9LyBwcm9naWQ6XFxTK0JsdXJcXChbXlxcKV0rXFwpL2csSD0vLT9bXixcXHMtXSsvZyxkPVwicG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4XCIsYj0yMTYwMCx6PXtwYXRoOjEscmVjdDoxLGltYWdlOjF9LHI9e2NpcmNsZToxLGVsbGlwc2U6MX0sZj1mdW5jdGlvbihTKXt2YXIgUD0vW2FocXN0dl0vaWcsSz1sLl9wYXRoVG9BYnNvbHV0ZTtGKFMpLm1hdGNoKFApJiYoSz1sLl9wYXRoMmN1cnZlKTtcblA9L1tjbG16XS9nO2lmKEs9PWwuX3BhdGhUb0Fic29sdXRlJiYhRihTKS5tYXRjaChQKSl7dmFyIE89RihTKS5yZXBsYWNlKGosZnVuY3Rpb24oVyxZLFUpe3ZhciBYPVtdLFQ9WS50b0xvd2VyQ2FzZSgpPT1cIm1cIixWPURbWV07VS5yZXBsYWNlKEgsZnVuY3Rpb24oWil7aWYoVCYmWC5sZW5ndGg9PTIpe1YrPVgrRFtZPT1cIm1cIj9cImxcIjpcIkxcIl07WD1bXX1YLnB1c2goQihaKmIpKX0pO3JldHVybiBWK1h9KTtyZXR1cm4gT312YXIgUT1LKFMpLEosRTtPPVtdO2Zvcih2YXIgTT0wLFI9US5sZW5ndGg7TTxSO00rKyl7Sj1RW01dO0U9UVtNXVswXS50b0xvd2VyQ2FzZSgpO0U9PVwielwiJiYoRT1cInhcIik7Zm9yKHZhciBMPTEsTj1KLmxlbmd0aDtMPE47TCsrKXtFKz1CKEpbTF0qYikrKEwhPU4tMT9cIixcIjpxKX1PLnB1c2goRSl9cmV0dXJuIE8uam9pbihrKX0sbz1mdW5jdGlvbihMLEssSil7dmFyIEU9bC5tYXRyaXgoKTtFLnJvdGF0ZSgtTCwwLjUsMC41KTtyZXR1cm57ZHg6RS54KEssSiksZHk6RS55KEssSil9fSxwPWZ1bmN0aW9uKFIsUSxQLE0sTCxOKXt2YXIgWj1SLl8sVD1SLm1hdHJpeCxFPVouZmlsbHBvcyxTPVIubm9kZSxPPVMuc3R5bGUsSz0xLEo9XCJcIixWLFg9Yi9RLFc9Yi9QO08udmlzaWJpbGl0eT1cImhpZGRlblwiO2lmKCFRfHwhUCl7cmV0dXJufVMuY29vcmRzaXplPXMoWCkraytzKFcpO08ucm90YXRpb249TiooUSpQPDA/LTE6MSk7aWYoTil7dmFyIFk9byhOLE0sTCk7TT1ZLmR4O0w9WS5keX1RPDAmJihKKz1cInhcIik7UDwwJiYoSis9XCIgeVwiKSYmKEs9LTEpO08uZmxpcD1KO1MuY29vcmRvcmlnaW49KE0qLVgpK2srKEwqLVcpO2lmKEV8fFouZmlsbHNpemUpe3ZhciBVPVMuZ2V0RWxlbWVudHNCeVRhZ05hbWUodik7VT1VJiZVWzBdO1MucmVtb3ZlQ2hpbGQoVSk7aWYoRSl7WT1vKE4sVC54KEVbMF0sRVsxXSksVC55KEVbMF0sRVsxXSkpO1UucG9zaXRpb249WS5keCpLK2srWS5keSpLfWlmKFouZmlsbHNpemUpe1Uuc2l6ZT1aLmZpbGxzaXplWzBdKnMoUSkraytaLmZpbGxzaXplWzFdKnMoUCl9Uy5hcHBlbmRDaGlsZChVKX1PLnZpc2liaWxpdHk9XCJ2aXNpYmxlXCJ9O2wudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIllvdXIgYnJvd3NlciBkb2VzblxcdTIwMTl0IHN1cHBvcnQgU1ZHLiBGYWxsaW5nIGRvd24gdG8gVk1MLlxcbllvdSBhcmUgcnVubmluZyBSYXBoYVxceGVibCBcIit0aGlzLnZlcnNpb259O3ZhciBjPWZ1bmN0aW9uKEUsTyxKKXt2YXIgUT1GKE8pLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCItXCIpLE09Sj9cImVuZFwiOlwic3RhcnRcIixLPVEubGVuZ3RoLE49XCJjbGFzc2ljXCIsUD1cIm1lZGl1bVwiLEw9XCJtZWRpdW1cIjt3aGlsZShLLS0pe3N3aXRjaChRW0tdKXtjYXNlXCJibG9ja1wiOmNhc2VcImNsYXNzaWNcIjpjYXNlXCJvdmFsXCI6Y2FzZVwiZGlhbW9uZFwiOmNhc2VcIm9wZW5cIjpjYXNlXCJub25lXCI6Tj1RW0tdO2JyZWFrO2Nhc2VcIndpZGVcIjpjYXNlXCJuYXJyb3dcIjpMPVFbS107YnJlYWs7Y2FzZVwibG9uZ1wiOmNhc2VcInNob3J0XCI6UD1RW0tdO2JyZWFrfX12YXIgUj1FLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJva2VcIilbMF07UltNK1wiYXJyb3dcIl09TjtSW00rXCJhcnJvd2xlbmd0aFwiXT1QO1JbTStcImFycm93d2lkdGhcIl09TH0seD1mdW5jdGlvbihaLGFqKXtaLmF0dHJzPVouYXR0cnN8fHt9O3ZhciBhZT1aLm5vZGUsYW49Wi5hdHRycyxWPWFlLnN0eWxlLFIsYWg9eltaLnR5cGVdJiYoYWoueCE9YW4ueHx8YWoueSE9YW4ueXx8YWoud2lkdGghPWFuLndpZHRofHxhai5oZWlnaHQhPWFuLmhlaWdodHx8YWouY3ghPWFuLmN4fHxhai5jeSE9YW4uY3l8fGFqLnJ4IT1hbi5yeHx8YWoucnkhPWFuLnJ5fHxhai5yIT1hbi5yKSxZPXJbWi50eXBlXSYmKGFuLmN4IT1hai5jeHx8YW4uY3khPWFqLmN5fHxhbi5yIT1hai5yfHxhbi5yeCE9YWoucnh8fGFuLnJ5IT1hai5yeSksYXE9Wjtmb3IodmFyIFcgaW4gYWope2lmKGFqW2VdKFcpKXthbltXXT1haltXXX19aWYoYWgpe2FuLnBhdGg9bC5fZ2V0UGF0aFtaLnR5cGVdKFopO1ouXy5kaXJ0eT0xfWFqLmhyZWYmJihhZS5ocmVmPWFqLmhyZWYpO2FqLnRpdGxlJiYoYWUudGl0bGU9YWoudGl0bGUpO2FqLnRhcmdldCYmKGFlLnRhcmdldD1hai50YXJnZXQpO2FqLmN1cnNvciYmKFYuY3Vyc29yPWFqLmN1cnNvcik7XCJibHVyXCIgaW4gYWomJlouYmx1cihhai5ibHVyKTtpZihhai5wYXRoJiZaLnR5cGU9PVwicGF0aFwifHxhaCl7YWUucGF0aD1mKH5GKGFuLnBhdGgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJcIik/bC5fcGF0aFRvQWJzb2x1dGUoYW4ucGF0aCk6YW4ucGF0aCk7aWYoWi50eXBlPT1cImltYWdlXCIpe1ouXy5maWxscG9zPVthbi54LGFuLnldO1ouXy5maWxsc2l6ZT1bYW4ud2lkdGgsYW4uaGVpZ2h0XTtwKFosMSwxLDAsMCwwKX19XCJ0cmFuc2Zvcm1cIiBpbiBhaiYmWi50cmFuc2Zvcm0oYWoudHJhbnNmb3JtKTtpZihZKXt2YXIgTT0rYW4uY3gsSz0rYW4uY3ksUT0rYW4ucnh8fCthbi5yfHwwLFA9K2FuLnJ5fHwrYW4ucnx8MDthZS5wYXRoPWwuZm9ybWF0KFwiYXJ7MH0sezF9LHsyfSx7M30sezR9LHsxfSx7NH0sezF9eFwiLEIoKE0tUSkqYiksQigoSy1QKSpiKSxCKChNK1EpKmIpLEIoKEsrUCkqYiksQihNKmIpKX1pZihcImNsaXAtcmVjdFwiIGluIGFqKXt2YXIgSj1GKGFqW1wiY2xpcC1yZWN0XCJdKS5zcGxpdChpKTtpZihKLmxlbmd0aD09NCl7SlsyXT0rSlsyXSsoK0pbMF0pO0pbM109K0pbM10rKCtKWzFdKTt2YXIgWD1hZS5jbGlwUmVjdHx8bC5fZy5kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhcD1YLnN0eWxlO2FwLmNsaXA9bC5mb3JtYXQoXCJyZWN0KHsxfXB4IHsyfXB4IHszfXB4IHswfXB4KVwiLEopO2lmKCFhZS5jbGlwUmVjdCl7YXAucG9zaXRpb249XCJhYnNvbHV0ZVwiO2FwLnRvcD0wO2FwLmxlZnQ9MDthcC53aWR0aD1aLnBhcGVyLndpZHRoK1wicHhcIjthcC5oZWlnaHQ9Wi5wYXBlci5oZWlnaHQrXCJweFwiO2FlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFgsYWUpO1guYXBwZW5kQ2hpbGQoYWUpO2FlLmNsaXBSZWN0PVh9fWlmKCFhaltcImNsaXAtcmVjdFwiXSl7YWUuY2xpcFJlY3QmJihhZS5jbGlwUmVjdC5zdHlsZS5jbGlwPVwiYXV0b1wiKX19aWYoWi50ZXh0cGF0aCl7dmFyIGFsPVoudGV4dHBhdGguc3R5bGU7YWouZm9udCYmKGFsLmZvbnQ9YWouZm9udCk7YWpbXCJmb250LWZhbWlseVwiXSYmKGFsLmZvbnRGYW1pbHk9J1wiJythaltcImZvbnQtZmFtaWx5XCJdLnNwbGl0KFwiLFwiKVswXS5yZXBsYWNlKC9eWydcIl0rfFsnXCJdKyQvZyxxKSsnXCInKTthaltcImZvbnQtc2l6ZVwiXSYmKGFsLmZvbnRTaXplPWFqW1wiZm9udC1zaXplXCJdKTthaltcImZvbnQtd2VpZ2h0XCJdJiYoYWwuZm9udFdlaWdodD1haltcImZvbnQtd2VpZ2h0XCJdKTthaltcImZvbnQtc3R5bGVcIl0mJihhbC5mb250U3R5bGU9YWpbXCJmb250LXN0eWxlXCJdKX1pZihcImFycm93LXN0YXJ0XCIgaW4gYWope2MoYXEsYWpbXCJhcnJvdy1zdGFydFwiXSl9aWYoXCJhcnJvdy1lbmRcIiBpbiBhail7YyhhcSxhaltcImFycm93LWVuZFwiXSwxKX1pZihhai5vcGFjaXR5IT1udWxsfHxhaltcInN0cm9rZS13aWR0aFwiXSE9bnVsbHx8YWouZmlsbCE9bnVsbHx8YWouc3JjIT1udWxsfHxhai5zdHJva2UhPW51bGx8fGFqW1wic3Ryb2tlLXdpZHRoXCJdIT1udWxsfHxhaltcInN0cm9rZS1vcGFjaXR5XCJdIT1udWxsfHxhaltcImZpbGwtb3BhY2l0eVwiXSE9bnVsbHx8YWpbXCJzdHJva2UtZGFzaGFycmF5XCJdIT1udWxsfHxhaltcInN0cm9rZS1taXRlcmxpbWl0XCJdIT1udWxsfHxhaltcInN0cm9rZS1saW5lam9pblwiXSE9bnVsbHx8YWpbXCJzdHJva2UtbGluZWNhcFwiXSE9bnVsbCl7dmFyIGFmPWFlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHYpLGFtPWZhbHNlO2FmPWFmJiZhZlswXTshYWYmJihhbT1hZj1HKHYpKTtpZihaLnR5cGU9PVwiaW1hZ2VcIiYmYWouc3JjKXthZi5zcmM9YWouc3JjfWFqLmZpbGwmJihhZi5vbj10cnVlKTtpZihhZi5vbj09bnVsbHx8YWouZmlsbD09XCJub25lXCJ8fGFqLmZpbGw9PT1udWxsKXthZi5vbj1mYWxzZX1pZihhZi5vbiYmYWouZmlsbCl7dmFyIE89Rihhai5maWxsKS5tYXRjaChsLl9JU1VSTCk7aWYoTyl7YWYucGFyZW50Tm9kZT09YWUmJmFlLnJlbW92ZUNoaWxkKGFmKTthZi5yb3RhdGU9dHJ1ZTthZi5zcmM9T1sxXTthZi50eXBlPVwidGlsZVwiO3ZhciBFPVouZ2V0QkJveCgxKTthZi5wb3NpdGlvbj1FLngraytFLnk7Wi5fLmZpbGxwb3M9W0UueCxFLnldO2wuX3ByZWxvYWQoT1sxXSxmdW5jdGlvbigpe1ouXy5maWxsc2l6ZT1bdGhpcy5vZmZzZXRXaWR0aCx0aGlzLm9mZnNldEhlaWdodF19KX1lbHNle2FmLmNvbG9yPWwuZ2V0UkdCKGFqLmZpbGwpLmhleDthZi5zcmM9cTthZi50eXBlPVwic29saWRcIjtpZihsLmdldFJHQihhai5maWxsKS5lcnJvciYmKGFxLnR5cGUgaW4ge2NpcmNsZToxLGVsbGlwc2U6MX18fEYoYWouZmlsbCkuY2hhckF0KCkhPVwiclwiKSYmYShhcSxhai5maWxsLGFmKSl7YW4uZmlsbD1cIm5vbmVcIjthbi5ncmFkaWVudD1hai5maWxsO2FmLnJvdGF0ZT1mYWxzZX19fWlmKFwiZmlsbC1vcGFjaXR5XCIgaW4gYWp8fFwib3BhY2l0eVwiIGluIGFqKXt2YXIgTj0oKCthbltcImZpbGwtb3BhY2l0eVwiXSsxfHwyKS0xKSooKCthbi5vcGFjaXR5KzF8fDIpLTEpKigoK2wuZ2V0UkdCKGFqLmZpbGwpLm8rMXx8MiktMSk7Tj1DKEkoTiwwKSwxKTthZi5vcGFjaXR5PU47aWYoYWYuc3JjKXthZi5jb2xvcj1cIm5vbmVcIn19YWUuYXBwZW5kQ2hpbGQoYWYpO3ZhciBTPShhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInN0cm9rZVwiKSYmYWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzdHJva2VcIilbMF0pLGFvPWZhbHNlOyFTJiYoYW89Uz1HKFwic3Ryb2tlXCIpKTtpZigoYWouc3Ryb2tlJiZhai5zdHJva2UhPVwibm9uZVwiKXx8YWpbXCJzdHJva2Utd2lkdGhcIl18fGFqW1wic3Ryb2tlLW9wYWNpdHlcIl0hPW51bGx8fGFqW1wic3Ryb2tlLWRhc2hhcnJheVwiXXx8YWpbXCJzdHJva2UtbWl0ZXJsaW1pdFwiXXx8YWpbXCJzdHJva2UtbGluZWpvaW5cIl18fGFqW1wic3Ryb2tlLWxpbmVjYXBcIl0pe1Mub249dHJ1ZX0oYWouc3Ryb2tlPT1cIm5vbmVcInx8YWouc3Ryb2tlPT09bnVsbHx8Uy5vbj09bnVsbHx8YWouc3Ryb2tlPT0wfHxhaltcInN0cm9rZS13aWR0aFwiXT09MCkmJihTLm9uPWZhbHNlKTt2YXIgYWQ9bC5nZXRSR0IoYWouc3Ryb2tlKTtTLm9uJiZhai5zdHJva2UmJihTLmNvbG9yPWFkLmhleCk7Tj0oKCthbltcInN0cm9rZS1vcGFjaXR5XCJdKzF8fDIpLTEpKigoK2FuLm9wYWNpdHkrMXx8MiktMSkqKCgrYWQubysxfHwyKS0xKTt2YXIgYWE9KG4oYWpbXCJzdHJva2Utd2lkdGhcIl0pfHwxKSowLjc1O049QyhJKE4sMCksMSk7YWpbXCJzdHJva2Utd2lkdGhcIl09PW51bGwmJihhYT1hbltcInN0cm9rZS13aWR0aFwiXSk7YWpbXCJzdHJva2Utd2lkdGhcIl0mJihTLndlaWdodD1hYSk7YWEmJmFhPDEmJihOKj1hYSkmJihTLndlaWdodD0xKTtTLm9wYWNpdHk9TjthaltcInN0cm9rZS1saW5lam9pblwiXSYmKFMuam9pbnN0eWxlPWFqW1wic3Ryb2tlLWxpbmVqb2luXCJdfHxcIm1pdGVyXCIpO1MubWl0ZXJsaW1pdD1haltcInN0cm9rZS1taXRlcmxpbWl0XCJdfHw4O2FqW1wic3Ryb2tlLWxpbmVjYXBcIl0mJihTLmVuZGNhcD1haltcInN0cm9rZS1saW5lY2FwXCJdPT1cImJ1dHRcIj9cImZsYXRcIjphaltcInN0cm9rZS1saW5lY2FwXCJdPT1cInNxdWFyZVwiP1wic3F1YXJlXCI6XCJyb3VuZFwiKTtpZihhaltcInN0cm9rZS1kYXNoYXJyYXlcIl0pe3ZhciBhYz17XCItXCI6XCJzaG9ydGRhc2hcIixcIi5cIjpcInNob3J0ZG90XCIsXCItLlwiOlwic2hvcnRkYXNoZG90XCIsXCItLi5cIjpcInNob3J0ZGFzaGRvdGRvdFwiLFwiLiBcIjpcImRvdFwiLFwiLSBcIjpcImRhc2hcIixcIi0tXCI6XCJsb25nZGFzaFwiLFwiLSAuXCI6XCJkYXNoZG90XCIsXCItLS5cIjpcImxvbmdkYXNoZG90XCIsXCItLS4uXCI6XCJsb25nZGFzaGRvdGRvdFwifTtTLmRhc2hzdHlsZT1hY1tlXShhaltcInN0cm9rZS1kYXNoYXJyYXlcIl0pP2FjW2FqW1wic3Ryb2tlLWRhc2hhcnJheVwiXV06cX1hbyYmYWUuYXBwZW5kQ2hpbGQoUyl9aWYoYXEudHlwZT09XCJ0ZXh0XCIpe2FxLnBhcGVyLmNhbnZhcy5zdHlsZS5kaXNwbGF5PXE7dmFyIGFnPWFxLnBhcGVyLnNwYW4sYWI9MTAwLEw9YW4uZm9udCYmYW4uZm9udC5tYXRjaCgvXFxkKyg/OlxcLlxcZCopPyg/PXB4KS8pO1Y9YWcuc3R5bGU7YW4uZm9udCYmKFYuZm9udD1hbi5mb250KTthbltcImZvbnQtZmFtaWx5XCJdJiYoVi5mb250RmFtaWx5PWFuW1wiZm9udC1mYW1pbHlcIl0pO2FuW1wiZm9udC13ZWlnaHRcIl0mJihWLmZvbnRXZWlnaHQ9YW5bXCJmb250LXdlaWdodFwiXSk7YW5bXCJmb250LXN0eWxlXCJdJiYoVi5mb250U3R5bGU9YW5bXCJmb250LXN0eWxlXCJdKTtMPW4oYW5bXCJmb250LXNpemVcIl18fEwmJkxbMF0pfHwxMDtWLmZvbnRTaXplPUwqYWIrXCJweFwiO2FxLnRleHRwYXRoLnN0cmluZyYmKGFnLmlubmVySFRNTD1GKGFxLnRleHRwYXRoLnN0cmluZykucmVwbGFjZSgvPC9nLFwiJiM2MDtcIikucmVwbGFjZSgvJi9nLFwiJiMzODtcIikucmVwbGFjZSgvXFxuL2csXCI8YnI+XCIpKTt2YXIgVT1hZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTthcS5XPWFuLnc9KFUucmlnaHQtVS5sZWZ0KS9hYjthcS5IPWFuLmg9KFUuYm90dG9tLVUudG9wKS9hYjthcS5YPWFuLng7YXEuWT1hbi55K2FxLkgvMjsoXCJ4XCIgaW4gYWp8fFwieVwiIGluIGFqKSYmKGFxLnBhdGgudj1sLmZvcm1hdChcIm17MH0sezF9bHsyfSx7MX1cIixCKGFuLngqYiksQihhbi55KmIpLEIoYW4ueCpiKSsxKSk7dmFyIFQ9W1wieFwiLFwieVwiLFwidGV4dFwiLFwiZm9udFwiLFwiZm9udC1mYW1pbHlcIixcImZvbnQtd2VpZ2h0XCIsXCJmb250LXN0eWxlXCIsXCJmb250LXNpemVcIl07Zm9yKHZhciBhaT0wLGFrPVQubGVuZ3RoO2FpPGFrO2FpKyspe2lmKFRbYWldIGluIGFqKXthcS5fLmRpcnR5PTE7YnJlYWt9fXN3aXRjaChhbltcInRleHQtYW5jaG9yXCJdKXtjYXNlXCJzdGFydFwiOmFxLnRleHRwYXRoLnN0eWxlW1widi10ZXh0LWFsaWduXCJdPVwibGVmdFwiO2FxLmJieD1hcS5XLzI7YnJlYWs7Y2FzZVwiZW5kXCI6YXEudGV4dHBhdGguc3R5bGVbXCJ2LXRleHQtYWxpZ25cIl09XCJyaWdodFwiO2FxLmJieD0tYXEuVy8yO2JyZWFrO2RlZmF1bHQ6YXEudGV4dHBhdGguc3R5bGVbXCJ2LXRleHQtYWxpZ25cIl09XCJjZW50ZXJcIjtcbmFxLmJieD0wO2JyZWFrfWFxLnRleHRwYXRoLnN0eWxlW1widi10ZXh0LWtlcm5cIl09dHJ1ZX19LGE9ZnVuY3Rpb24oRSxSLFUpe0UuYXR0cnM9RS5hdHRyc3x8e307dmFyIFM9RS5hdHRycyxMPU1hdGgucG93LE0sTixQPVwibGluZWFyXCIsUT1cIi41IC41XCI7RS5hdHRycy5ncmFkaWVudD1SO1I9RihSKS5yZXBsYWNlKGwuX3JhZGlhbF9ncmFkaWVudCxmdW5jdGlvbihYLFksVyl7UD1cInJhZGlhbFwiO2lmKFkmJlcpe1k9bihZKTtXPW4oVyk7TChZLTAuNSwyKStMKFctMC41LDIpPjAuMjUmJihXPWguc3FydCgwLjI1LUwoWS0wLjUsMikpKigoVz4wLjUpKjItMSkrMC41KTtRPVkraytXfXJldHVybiBxfSk7Uj1SLnNwbGl0KC9cXHMqXFwtXFxzKi8pO2lmKFA9PVwibGluZWFyXCIpe3ZhciBKPVIuc2hpZnQoKTtKPS1uKEopO2lmKGlzTmFOKEopKXtyZXR1cm4gbnVsbH19dmFyIE89bC5fcGFyc2VEb3RzKFIpO2lmKCFPKXtyZXR1cm4gbnVsbH1FPUUuc2hhcGV8fEUubm9kZTtpZihPLmxlbmd0aCl7RS5yZW1vdmVDaGlsZChVKTtVLm9uPXRydWU7VS5tZXRob2Q9XCJub25lXCI7VS5jb2xvcj1PWzBdLmNvbG9yO1UuY29sb3IyPU9bTy5sZW5ndGgtMV0uY29sb3I7dmFyIFY9W107Zm9yKHZhciBLPTAsVD1PLmxlbmd0aDtLPFQ7SysrKXtPW0tdLm9mZnNldCYmVi5wdXNoKE9bS10ub2Zmc2V0K2srT1tLXS5jb2xvcil9VS5jb2xvcnM9Vi5sZW5ndGg/Vi5qb2luKCk6XCIwJSBcIitVLmNvbG9yO2lmKFA9PVwicmFkaWFsXCIpe1UudHlwZT1cImdyYWRpZW50VGl0bGVcIjtVLmZvY3VzPVwiMTAwJVwiO1UuZm9jdXNzaXplPVwiMCAwXCI7VS5mb2N1c3Bvc2l0aW9uPVE7VS5hbmdsZT0wfWVsc2V7VS50eXBlPVwiZ3JhZGllbnRcIjtVLmFuZ2xlPSgyNzAtSiklMzYwfUUuYXBwZW5kQ2hpbGQoVSl9cmV0dXJuIDF9LHU9ZnVuY3Rpb24oSixFKXt0aGlzWzBdPXRoaXMubm9kZT1KO0oucmFwaGFlbD10cnVlO3RoaXMuaWQ9bC5fb2lkKys7Si5yYXBoYWVsaWQ9dGhpcy5pZDt0aGlzLlg9MDt0aGlzLlk9MDt0aGlzLmF0dHJzPXt9O3RoaXMucGFwZXI9RTt0aGlzLm1hdHJpeD1sLm1hdHJpeCgpO3RoaXMuXz17dHJhbnNmb3JtOltdLHN4OjEsc3k6MSxkeDowLGR5OjAsZGVnOjAsZGlydHk6MSxkaXJ0eVQ6MX07IUUuYm90dG9tJiYoRS5ib3R0b209dGhpcyk7dGhpcy5wcmV2PUUudG9wO0UudG9wJiYoRS50b3AubmV4dD10aGlzKTtFLnRvcD10aGlzO3RoaXMubmV4dD1udWxsfTt2YXIgbT1sLmVsO3UucHJvdG90eXBlPW07bS5jb25zdHJ1Y3Rvcj11O20udHJhbnNmb3JtPWZ1bmN0aW9uKE0pe2lmKE09PW51bGwpe3JldHVybiB0aGlzLl8udHJhbnNmb3JtfXZhciBPPXRoaXMucGFwZXIuX3ZpZXdCb3hTaGlmdCxOPU8/XCJzXCIrW08uc2NhbGUsTy5zY2FsZV0rXCItMS0xdFwiK1tPLmR4LE8uZHldOnEsUjtpZihPKXtSPU09RihNKS5yZXBsYWNlKC9cXC57M318XFx1MjAyNi9nLHRoaXMuXy50cmFuc2Zvcm18fHEpfWwuX2V4dHJhY3RUcmFuc2Zvcm0odGhpcyxOK00pO3ZhciBTPXRoaXMubWF0cml4LmNsb25lKCksVT10aGlzLnNrZXcsSz10aGlzLm5vZGUsUSxMPX5GKHRoaXMuYXR0cnMuZmlsbCkuaW5kZXhPZihcIi1cIiksRT0hRih0aGlzLmF0dHJzLmZpbGwpLmluZGV4T2YoXCJ1cmwoXCIpO1MudHJhbnNsYXRlKC0wLjUsLTAuNSk7aWYoRXx8THx8dGhpcy50eXBlPT1cImltYWdlXCIpe1UubWF0cml4PVwiMSAwIDAgMVwiO1Uub2Zmc2V0PVwiMCAwXCI7UT1TLnNwbGl0KCk7aWYoKEwmJlEubm9Sb3RhdGlvbil8fCFRLmlzU2ltcGxlKXtLLnN0eWxlLmZpbHRlcj1TLnRvRmlsdGVyKCk7dmFyIFA9dGhpcy5nZXRCQm94KCksSj10aGlzLmdldEJCb3goMSksVj1QLngtSi54LFQ9UC55LUoueTtLLmNvb3Jkb3JpZ2luPShWKi1iKStrKyhUKi1iKTtwKHRoaXMsMSwxLFYsVCwwKX1lbHNle0suc3R5bGUuZmlsdGVyPXE7cCh0aGlzLFEuc2NhbGV4LFEuc2NhbGV5LFEuZHgsUS5keSxRLnJvdGF0ZSl9fWVsc2V7Sy5zdHlsZS5maWx0ZXI9cTtVLm1hdHJpeD1GKFMpO1Uub2Zmc2V0PVMub2Zmc2V0KCl9UiYmKHRoaXMuXy50cmFuc2Zvcm09Uik7cmV0dXJuIHRoaXN9O20ucm90YXRlPWZ1bmN0aW9uKEosRSxMKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfWlmKEo9PW51bGwpe3JldHVybn1KPUYoSikuc3BsaXQoaSk7aWYoSi5sZW5ndGgtMSl7RT1uKEpbMV0pO0w9bihKWzJdKX1KPW4oSlswXSk7KEw9PW51bGwpJiYoRT1MKTtpZihFPT1udWxsfHxMPT1udWxsKXt2YXIgSz10aGlzLmdldEJCb3goMSk7RT1LLngrSy53aWR0aC8yO0w9Sy55K0suaGVpZ2h0LzJ9dGhpcy5fLmRpcnR5VD0xO3RoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJyXCIsSixFLExdXSkpO3JldHVybiB0aGlzfTttLnRyYW5zbGF0ZT1mdW5jdGlvbihKLEUpe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJuIHRoaXN9Sj1GKEopLnNwbGl0KGkpO2lmKEoubGVuZ3RoLTEpe0U9bihKWzFdKX1KPW4oSlswXSl8fDA7RT0rRXx8MDtpZih0aGlzLl8uYmJveCl7dGhpcy5fLmJib3gueCs9Sjt0aGlzLl8uYmJveC55Kz1FfXRoaXMudHJhbnNmb3JtKHRoaXMuXy50cmFuc2Zvcm0uY29uY2F0KFtbXCJ0XCIsSixFXV0pKTtyZXR1cm4gdGhpc307bS5zY2FsZT1mdW5jdGlvbihNLEssRSxMKXtpZih0aGlzLnJlbW92ZWQpe3JldHVybiB0aGlzfU09RihNKS5zcGxpdChpKTtpZihNLmxlbmd0aC0xKXtLPW4oTVsxXSk7RT1uKE1bMl0pO0w9bihNWzNdKTtpc05hTihFKSYmKEU9bnVsbCk7aXNOYU4oTCkmJihMPW51bGwpfU09bihNWzBdKTsoSz09bnVsbCkmJihLPU0pOyhMPT1udWxsKSYmKEU9TCk7aWYoRT09bnVsbHx8TD09bnVsbCl7dmFyIEo9dGhpcy5nZXRCQm94KDEpfUU9RT09bnVsbD9KLngrSi53aWR0aC8yOkU7TD1MPT1udWxsP0oueStKLmhlaWdodC8yOkw7dGhpcy50cmFuc2Zvcm0odGhpcy5fLnRyYW5zZm9ybS5jb25jYXQoW1tcInNcIixNLEssRSxMXV0pKTt0aGlzLl8uZGlydHlUPTE7cmV0dXJuIHRoaXN9O20uaGlkZT1mdW5jdGlvbigpeyF0aGlzLnJlbW92ZWQmJih0aGlzLm5vZGUuc3R5bGUuZGlzcGxheT1cIm5vbmVcIik7cmV0dXJuIHRoaXN9O20uc2hvdz1mdW5jdGlvbigpeyF0aGlzLnJlbW92ZWQmJih0aGlzLm5vZGUuc3R5bGUuZGlzcGxheT1xKTtyZXR1cm4gdGhpc307bS5fZ2V0QkJveD1mdW5jdGlvbigpe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJue319cmV0dXJue3g6dGhpcy5YKyh0aGlzLmJieHx8MCktdGhpcy5XLzIseTp0aGlzLlktdGhpcy5ILHdpZHRoOnRoaXMuVyxoZWlnaHQ6dGhpcy5IfX07bS5yZW1vdmU9ZnVuY3Rpb24oKXtpZih0aGlzLnJlbW92ZWR8fCF0aGlzLm5vZGUucGFyZW50Tm9kZSl7cmV0dXJufXRoaXMucGFwZXIuX19zZXRfXyYmdGhpcy5wYXBlci5fX3NldF9fLmV4Y2x1ZGUodGhpcyk7bC5ldmUudW5iaW5kKFwicmFwaGFlbC4qLiouXCIrdGhpcy5pZCk7bC5fdGVhcih0aGlzLHRoaXMucGFwZXIpO3RoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZSk7dGhpcy5zaGFwZSYmdGhpcy5zaGFwZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2hhcGUpO2Zvcih2YXIgRSBpbiB0aGlzKXt0aGlzW0VdPXR5cGVvZiB0aGlzW0VdPT1cImZ1bmN0aW9uXCI/bC5fcmVtb3ZlZEZhY3RvcnkoRSk6bnVsbH10aGlzLnJlbW92ZWQ9dHJ1ZX07bS5hdHRyPWZ1bmN0aW9uKEUsUil7aWYodGhpcy5yZW1vdmVkKXtyZXR1cm4gdGhpc31pZihFPT1udWxsKXt2YXIgTz17fTtmb3IodmFyIFEgaW4gdGhpcy5hdHRycyl7aWYodGhpcy5hdHRyc1tlXShRKSl7T1tRXT10aGlzLmF0dHJzW1FdfX1PLmdyYWRpZW50JiZPLmZpbGw9PVwibm9uZVwiJiYoTy5maWxsPU8uZ3JhZGllbnQpJiZkZWxldGUgTy5ncmFkaWVudDtPLnRyYW5zZm9ybT10aGlzLl8udHJhbnNmb3JtO3JldHVybiBPfWlmKFI9PW51bGwmJmwuaXMoRSxcInN0cmluZ1wiKSl7aWYoRT09diYmdGhpcy5hdHRycy5maWxsPT1cIm5vbmVcIiYmdGhpcy5hdHRycy5ncmFkaWVudCl7cmV0dXJuIHRoaXMuYXR0cnMuZ3JhZGllbnR9dmFyIFA9RS5zcGxpdChpKSxMPXt9O2Zvcih2YXIgTT0wLFQ9UC5sZW5ndGg7TTxUO00rKyl7RT1QW01dO2lmKEUgaW4gdGhpcy5hdHRycyl7TFtFXT10aGlzLmF0dHJzW0VdfWVsc2V7aWYobC5pcyh0aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbRV0sXCJmdW5jdGlvblwiKSl7TFtFXT10aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbRV0uZGVmfWVsc2V7TFtFXT1sLl9hdmFpbGFibGVBdHRyc1tFXX19fXJldHVybiBULTE/TDpMW1BbMF1dfWlmKHRoaXMuYXR0cnMmJlI9PW51bGwmJmwuaXMoRSxcImFycmF5XCIpKXtMPXt9O2ZvcihNPTAsVD1FLmxlbmd0aDtNPFQ7TSsrKXtMW0VbTV1dPXRoaXMuYXR0cihFW01dKX1yZXR1cm4gTH12YXIgSjtpZihSIT1udWxsKXtKPXt9O0pbRV09Un1SPT1udWxsJiZsLmlzKEUsXCJvYmplY3RcIikmJihKPUUpO2Zvcih2YXIgUyBpbiBKKXtBKFwicmFwaGFlbC5hdHRyLlwiK1MrXCIuXCIrdGhpcy5pZCx0aGlzLEpbU10pfWlmKEope2ZvcihTIGluIHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlcyl7aWYodGhpcy5wYXBlci5jdXN0b21BdHRyaWJ1dGVzW2VdKFMpJiZKW2VdKFMpJiZsLmlzKHRoaXMucGFwZXIuY3VzdG9tQXR0cmlidXRlc1tTXSxcImZ1bmN0aW9uXCIpKXt2YXIgTj10aGlzLnBhcGVyLmN1c3RvbUF0dHJpYnV0ZXNbU10uYXBwbHkodGhpcyxbXS5jb25jYXQoSltTXSkpO3RoaXMuYXR0cnNbU109SltTXTtmb3IodmFyIEsgaW4gTil7aWYoTltlXShLKSl7SltLXT1OW0tdfX19fWlmKEoudGV4dCYmdGhpcy50eXBlPT1cInRleHRcIil7dGhpcy50ZXh0cGF0aC5zdHJpbmc9Si50ZXh0fXgodGhpcyxKKX1yZXR1cm4gdGhpc307bS50b0Zyb250PWZ1bmN0aW9uKCl7IXRoaXMucmVtb3ZlZCYmdGhpcy5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTt0aGlzLnBhcGVyJiZ0aGlzLnBhcGVyLnRvcCE9dGhpcyYmbC5fdG9mcm9udCh0aGlzLHRoaXMucGFwZXIpO3JldHVybiB0aGlzfTttLnRvQmFjaz1mdW5jdGlvbigpe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJuIHRoaXN9aWYodGhpcy5ub2RlLnBhcmVudE5vZGUuZmlyc3RDaGlsZCE9dGhpcy5ub2RlKXt0aGlzLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLHRoaXMubm9kZS5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO2wuX3RvYmFjayh0aGlzLHRoaXMucGFwZXIpfXJldHVybiB0aGlzfTttLmluc2VydEFmdGVyPWZ1bmN0aW9uKEUpe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJuIHRoaXN9aWYoRS5jb25zdHJ1Y3Rvcj09bC5zdC5jb25zdHJ1Y3Rvcil7RT1FW0UubGVuZ3RoLTFdfWlmKEUubm9kZS5uZXh0U2libGluZyl7RS5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMubm9kZSxFLm5vZGUubmV4dFNpYmxpbmcpfWVsc2V7RS5ub2RlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKX1sLl9pbnNlcnRhZnRlcih0aGlzLEUsdGhpcy5wYXBlcik7cmV0dXJuIHRoaXN9O20uaW5zZXJ0QmVmb3JlPWZ1bmN0aW9uKEUpe2lmKHRoaXMucmVtb3ZlZCl7cmV0dXJuIHRoaXN9aWYoRS5jb25zdHJ1Y3Rvcj09bC5zdC5jb25zdHJ1Y3Rvcil7RT1FWzBdfUUubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLm5vZGUsRS5ub2RlKTtsLl9pbnNlcnRiZWZvcmUodGhpcyxFLHRoaXMucGFwZXIpO3JldHVybiB0aGlzfTttLmJsdXI9ZnVuY3Rpb24oRSl7dmFyIEo9dGhpcy5ub2RlLnJ1bnRpbWVTdHlsZSxLPUouZmlsdGVyO0s9Sy5yZXBsYWNlKHQscSk7aWYoK0UhPT0wKXt0aGlzLmF0dHJzLmJsdXI9RTtKLmZpbHRlcj1LK2srdytcIi5CbHVyKHBpeGVscmFkaXVzPVwiKygrRXx8MS41KStcIilcIjtKLm1hcmdpbj1sLmZvcm1hdChcIi17MH1weCAwIDAgLXswfXB4XCIsQigrRXx8MS41KSl9ZWxzZXtKLmZpbHRlcj1LO0oubWFyZ2luPTA7ZGVsZXRlIHRoaXMuYXR0cnMuYmx1cn19O2wuX2VuZ2luZS5wYXRoPWZ1bmN0aW9uKEwsSil7dmFyIE09RyhcInNoYXBlXCIpO00uc3R5bGUuY3NzVGV4dD1kO00uY29vcmRzaXplPWIraytiO00uY29vcmRvcmlnaW49Si5jb29yZG9yaWdpbjt2YXIgTj1uZXcgdShNLEopLEU9e2ZpbGw6XCJub25lXCIsc3Ryb2tlOlwiIzAwMFwifTtMJiYoRS5wYXRoPUwpO04udHlwZT1cInBhdGhcIjtOLnBhdGg9W107Ti5QYXRoPXE7eChOLEUpO0ouY2FudmFzLmFwcGVuZENoaWxkKE0pO3ZhciBLPUcoXCJza2V3XCIpO0sub249dHJ1ZTtNLmFwcGVuZENoaWxkKEspO04uc2tldz1LO04udHJhbnNmb3JtKHEpO3JldHVybiBOfTtsLl9lbmdpbmUucmVjdD1mdW5jdGlvbihKLE8sTSxQLEssRSl7dmFyIFE9bC5fcmVjdFBhdGgoTyxNLFAsSyxFKSxMPUoucGF0aChRKSxOPUwuYXR0cnM7TC5YPU4ueD1PO0wuWT1OLnk9TTtMLlc9Ti53aWR0aD1QO0wuSD1OLmhlaWdodD1LO04ucj1FO04ucGF0aD1RO0wudHlwZT1cInJlY3RcIjtyZXR1cm4gTH07bC5fZW5naW5lLmVsbGlwc2U9ZnVuY3Rpb24oSixFLE8sTixNKXt2YXIgTD1KLnBhdGgoKSxLPUwuYXR0cnM7TC5YPUUtTjtMLlk9Ty1NO0wuVz1OKjI7TC5IPU0qMjtMLnR5cGU9XCJlbGxpcHNlXCI7eChMLHtjeDpFLGN5Ok8scng6TixyeTpNfSk7cmV0dXJuIEx9O2wuX2VuZ2luZS5jaXJjbGU9ZnVuY3Rpb24oSixFLE4sTSl7dmFyIEw9Si5wYXRoKCksSz1MLmF0dHJzO0wuWD1FLU07TC5ZPU4tTTtMLlc9TC5IPU0qMjtMLnR5cGU9XCJjaXJjbGVcIjt4KEwse2N4OkUsY3k6TixyOk19KTtyZXR1cm4gTH07bC5fZW5naW5lLmltYWdlPWZ1bmN0aW9uKEosRSxQLE4sUSxMKXt2YXIgUz1sLl9yZWN0UGF0aChQLE4sUSxMKSxNPUoucGF0aChTKS5hdHRyKHtzdHJva2U6XCJub25lXCJ9KSxPPU0uYXR0cnMsSz1NLm5vZGUsUj1LLmdldEVsZW1lbnRzQnlUYWdOYW1lKHYpWzBdO08uc3JjPUU7TS5YPU8ueD1QO00uWT1PLnk9TjtNLlc9Ty53aWR0aD1RO00uSD1PLmhlaWdodD1MO08ucGF0aD1TO00udHlwZT1cImltYWdlXCI7Ui5wYXJlbnROb2RlPT1LJiZLLnJlbW92ZUNoaWxkKFIpO1Iucm90YXRlPXRydWU7Ui5zcmM9RTtSLnR5cGU9XCJ0aWxlXCI7TS5fLmZpbGxwb3M9W1AsTl07TS5fLmZpbGxzaXplPVtRLExdO1xuSy5hcHBlbmRDaGlsZChSKTtwKE0sMSwxLDAsMCwwKTtyZXR1cm4gTX07bC5fZW5naW5lLnRleHQ9ZnVuY3Rpb24oRSxPLE4sUCl7dmFyIEw9RyhcInNoYXBlXCIpLFI9RyhcInBhdGhcIiksSz1HKFwidGV4dHBhdGhcIik7Tz1PfHwwO049Tnx8MDtQPVB8fFwiXCI7Ui52PWwuZm9ybWF0KFwibXswfSx7MX1sezJ9LHsxfVwiLEIoTypiKSxCKE4qYiksQihPKmIpKzEpO1IudGV4dHBhdGhvaz10cnVlO0suc3RyaW5nPUYoUCk7Sy5vbj10cnVlO0wuc3R5bGUuY3NzVGV4dD1kO0wuY29vcmRzaXplPWIraytiO0wuY29vcmRvcmlnaW49XCIwIDBcIjt2YXIgSj1uZXcgdShMLEUpLE09e2ZpbGw6XCIjMDAwXCIsc3Ryb2tlOlwibm9uZVwiLGZvbnQ6bC5fYXZhaWxhYmxlQXR0cnMuZm9udCx0ZXh0OlB9O0ouc2hhcGU9TDtKLnBhdGg9UjtKLnRleHRwYXRoPUs7Si50eXBlPVwidGV4dFwiO0ouYXR0cnMudGV4dD1GKFApO0ouYXR0cnMueD1PO0ouYXR0cnMueT1OO0ouYXR0cnMudz0xO0ouYXR0cnMuaD0xO3goSixNKTtMLmFwcGVuZENoaWxkKEspO0wuYXBwZW5kQ2hpbGQoUik7RS5jYW52YXMuYXBwZW5kQ2hpbGQoTCk7dmFyIFE9RyhcInNrZXdcIik7US5vbj10cnVlO0wuYXBwZW5kQ2hpbGQoUSk7Si5za2V3PVE7Si50cmFuc2Zvcm0ocSk7cmV0dXJuIEp9O2wuX2VuZ2luZS5zZXRTaXplPWZ1bmN0aW9uKEssRSl7dmFyIEo9dGhpcy5jYW52YXMuc3R5bGU7dGhpcy53aWR0aD1LO3RoaXMuaGVpZ2h0PUU7Sz09K0smJihLKz1cInB4XCIpO0U9PStFJiYoRSs9XCJweFwiKTtKLndpZHRoPUs7Si5oZWlnaHQ9RTtKLmNsaXA9XCJyZWN0KDAgXCIrSytcIiBcIitFK1wiIDApXCI7aWYodGhpcy5fdmlld0JveCl7bC5fZW5naW5lLnNldFZpZXdCb3guYXBwbHkodGhpcyx0aGlzLl92aWV3Qm94KX1yZXR1cm4gdGhpc307bC5fZW5naW5lLnNldFZpZXdCb3g9ZnVuY3Rpb24oTixNLE8sSyxMKXtsLmV2ZShcInJhcGhhZWwuc2V0Vmlld0JveFwiLHRoaXMsdGhpcy5fdmlld0JveCxbTixNLE8sSyxMXSk7dmFyIEU9dGhpcy53aWR0aCxRPXRoaXMuaGVpZ2h0LFI9MS9JKE8vRSxLL1EpLFAsSjtpZihMKXtQPVEvSztKPUUvTztpZihPKlA8RSl7Ti09KEUtTypQKS8yL1B9aWYoSypKPFEpe00tPShRLUsqSikvMi9KfX10aGlzLl92aWV3Qm94PVtOLE0sTyxLLCEhTF07dGhpcy5fdmlld0JveFNoaWZ0PXtkeDotTixkeTotTSxzY2FsZTpSfTt0aGlzLmZvckVhY2goZnVuY3Rpb24oUyl7Uy50cmFuc2Zvcm0oXCIuLi5cIil9KTtyZXR1cm4gdGhpc307dmFyIEc7bC5fZW5naW5lLmluaXRXaW49ZnVuY3Rpb24oSyl7dmFyIEo9Sy5kb2N1bWVudDtKLmNyZWF0ZVN0eWxlU2hlZXQoKS5hZGRSdWxlKFwiLnJ2bWxcIixcImJlaGF2aW9yOnVybCgjZGVmYXVsdCNWTUwpXCIpO3RyeXshSi5uYW1lc3BhY2VzLnJ2bWwmJkoubmFtZXNwYWNlcy5hZGQoXCJydm1sXCIsXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiKTtHPWZ1bmN0aW9uKEwpe3JldHVybiBKLmNyZWF0ZUVsZW1lbnQoXCI8cnZtbDpcIitMKycgY2xhc3M9XCJydm1sXCI+Jyl9fWNhdGNoKEUpe0c9ZnVuY3Rpb24oTCl7cmV0dXJuIEouY3JlYXRlRWxlbWVudChcIjxcIitMKycgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwicnZtbFwiPicpfX19O2wuX2VuZ2luZS5pbml0V2luKGwuX2cud2luKTtsLl9lbmdpbmUuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIEs9bC5fZ2V0Q29udGFpbmVyLmFwcGx5KDAsYXJndW1lbnRzKSxFPUsuY29udGFpbmVyLFE9Sy5oZWlnaHQsUixKPUsud2lkdGgsUD1LLngsTz1LLnk7aWYoIUUpe3Rocm93IG5ldyBFcnJvcihcIlZNTCBjb250YWluZXIgbm90IGZvdW5kLlwiKX12YXIgTT1uZXcgbC5fUGFwZXIsTj1NLmNhbnZhcz1sLl9nLmRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLEw9Ti5zdHlsZTtQPVB8fDA7Tz1PfHwwO0o9Snx8NTEyO1E9UXx8MzQyO00ud2lkdGg9SjtNLmhlaWdodD1RO0o9PStKJiYoSis9XCJweFwiKTtRPT0rUSYmKFErPVwicHhcIik7TS5jb29yZHNpemU9YioxMDAwK2srYioxMDAwO00uY29vcmRvcmlnaW49XCIwIDBcIjtNLnNwYW49bC5fZy5kb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7TS5zcGFuLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW07cGFkZGluZzowO21hcmdpbjowO2xpbmUtaGVpZ2h0OjE7XCI7Ti5hcHBlbmRDaGlsZChNLnNwYW4pO0wuY3NzVGV4dD1sLmZvcm1hdChcInRvcDowO2xlZnQ6MDt3aWR0aDp7MH07aGVpZ2h0OnsxfTtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtjbGlwOnJlY3QoMCB7MH0gezF9IDApO292ZXJmbG93OmhpZGRlblwiLEosUSk7aWYoRT09MSl7bC5fZy5kb2MuYm9keS5hcHBlbmRDaGlsZChOKTtMLmxlZnQ9UCtcInB4XCI7TC50b3A9TytcInB4XCI7TC5wb3NpdGlvbj1cImFic29sdXRlXCJ9ZWxzZXtpZihFLmZpcnN0Q2hpbGQpe0UuaW5zZXJ0QmVmb3JlKE4sRS5maXJzdENoaWxkKX1lbHNle0UuYXBwZW5kQ2hpbGQoTil9fU0ucmVuZGVyZml4PWZ1bmN0aW9uKCl7fTtyZXR1cm4gTX07bC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXtsLmV2ZShcInJhcGhhZWwuY2xlYXJcIix0aGlzKTt0aGlzLmNhbnZhcy5pbm5lckhUTUw9cTt0aGlzLnNwYW49bC5fZy5kb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7dGhpcy5zcGFuLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi05OTk5ZW07dG9wOi05OTk5ZW07cGFkZGluZzowO21hcmdpbjowO2xpbmUtaGVpZ2h0OjE7ZGlzcGxheTppbmxpbmU7XCI7dGhpcy5jYW52YXMuYXBwZW5kQ2hpbGQodGhpcy5zcGFuKTt0aGlzLmJvdHRvbT10aGlzLnRvcD1udWxsfTtsLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXtsLmV2ZShcInJhcGhhZWwucmVtb3ZlXCIsdGhpcyk7dGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7Zm9yKHZhciBFIGluIHRoaXMpe3RoaXNbRV09dHlwZW9mIHRoaXNbRV09PVwiZnVuY3Rpb25cIj9sLl9yZW1vdmVkRmFjdG9yeShFKTpudWxsfXJldHVybiB0cnVlfTt2YXIgeT1sLnN0O2Zvcih2YXIgZyBpbiBtKXtpZihtW2VdKGcpJiYheVtlXShnKSl7eVtnXT0oZnVuY3Rpb24oRSl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIEo9YXJndW1lbnRzO3JldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oSyl7S1tFXS5hcHBseShLLEopfSl9fSkoZyl9fX0od2luZG93LlJhcGhhZWwpO2lmKCF3aW5kb3cuQUJDSlMpe3dpbmRvdy5BQkNKUz17fX0oZnVuY3Rpb24oKXtBQkNKUy5udW1iZXJPZlR1bmVzPWZ1bmN0aW9uKGQpe3ZhciBiPWQuc3BsaXQoXCJcXG5YOlwiKTt2YXIgYz1iLmxlbmd0aDtpZihjPT09MCl7Yz0xfXJldHVybiBjfTtBQkNKUy5UdW5lQm9vaz1mdW5jdGlvbihkKXt2YXIgaD10aGlzO3ZhciBnPVwiXCI7ZD13aW5kb3cuQUJDSlMucGFyc2Uuc3RyaXAoZCk7dmFyIGI9ZC5zcGxpdChcIlxcblg6XCIpO2Zvcih2YXIgZj0xO2Y8Yi5sZW5ndGg7ZisrKXtiW2ZdPVwiWDpcIitiW2ZdfXZhciBqPTA7aC50dW5lcz1bXTt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChiLGZ1bmN0aW9uKGkpe2gudHVuZXMucHVzaCh7YWJjOmksc3RhcnRQb3M6an0pO2orPWkubGVuZ3RofSk7aWYoaC50dW5lcy5sZW5ndGg+MSYmIXdpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKGgudHVuZXNbMF0uYWJjLFwiWDpcIikpe3ZhciBjPWgudHVuZXMuc2hpZnQoKTt2YXIgZT1jLmFiYy5zcGxpdChcIlxcblwiKTt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChlLGZ1bmN0aW9uKGkpe2lmKHdpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKGksXCIlJVwiKSl7Zys9aStcIlxcblwifX0pfWguaGVhZGVyPWc7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goaC50dW5lcyxmdW5jdGlvbihrKXt2YXIgaT1rLmFiYy5pbmRleE9mKFwiXFxuXFxuXCIpO2lmKGk+MCl7ay5hYmM9ay5hYmMuc3Vic3RyaW5nKDAsaSl9ay5wdXJlPWsuYWJjO2suYWJjPWcray5hYmM7dmFyIGw9ay5wdXJlLnNwbGl0KFwiVDpcIik7aWYobC5sZW5ndGg+MSl7bD1sWzFdLnNwbGl0KFwiXFxuXCIpO2sudGl0bGU9bFswXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfWVsc2V7ay50aXRsZT1cIlwifXZhciBtPWsucHVyZS5zdWJzdHJpbmcoMixrLnB1cmUuaW5kZXhPZihcIlxcblwiKSk7ay5pZD1tLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9KX07QUJDSlMuVHVuZUJvb2sucHJvdG90eXBlLmdldFR1bmVCeUlkPWZ1bmN0aW9uKGMpe2Zvcih2YXIgYj0wO2I8dGhpcy50dW5lcy5sZW5ndGg7YisrKXtpZih0aGlzLnR1bmVzW2JdLmlkPT09Yyl7cmV0dXJuIHRoaXMudHVuZXNbYl19fXJldHVybiBudWxsfTtBQkNKUy5UdW5lQm9vay5wcm90b3R5cGUuZ2V0VHVuZUJ5VGl0bGU9ZnVuY3Rpb24oYyl7Zm9yKHZhciBiPTA7Yjx0aGlzLnR1bmVzLmxlbmd0aDtiKyspe2lmKHRoaXMudHVuZXNbYl0udGl0bGU9PT1jKXtyZXR1cm4gdGhpcy50dW5lc1tiXX19cmV0dXJuIG51bGx9O2Z1bmN0aW9uIGEobixlLG0sbCxkKXt2YXIgaz1mdW5jdGlvbihpKXtyZXR1cm4gaSYmIShpLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwibGVuZ3RoXCIpKSYmdHlwZW9mIGk9PT1cIm9iamVjdFwiJiZ0eXBlb2YgaS5sZW5ndGg9PT1cIm51bWJlclwifTtpZihlPT09dW5kZWZpbmVkfHxtPT09dW5kZWZpbmVkKXtyZXR1cm59aWYoIWsoZSkpe2U9W2VdfWlmKGw9PT11bmRlZmluZWQpe2w9e319aWYoZD09PXVuZGVmaW5lZCl7ZD17fX12YXIgZz1kLnN0YXJ0aW5nVHVuZT9kLnN0YXJ0aW5nVHVuZTowO3ZhciBmPW5ldyBBQkNKUy5UdW5lQm9vayhtKTt2YXIgYz1uZXcgd2luZG93LkFCQ0pTLnBhcnNlLlBhcnNlKCk7Zm9yKHZhciBoPTA7aDxlLmxlbmd0aDtoKyspe3ZhciBiPWVbaF07aWYodHlwZW9mKGIpPT09XCJzdHJpbmdcIil7Yj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKX1pZihiKXtiLmlubmVySFRNTD1cIlwiO2lmKGc8Zi50dW5lcy5sZW5ndGgpe2MucGFyc2UoZi50dW5lc1tnXS5hYmMsbCk7dmFyIGo9Yy5nZXRUdW5lKCk7bihiLGopfX1nKyt9fUFCQ0pTLnJlbmRlckFiYz1mdW5jdGlvbihjLGUsYixkLGYpe2Z1bmN0aW9uIGcobCxqKXt2YXIgaD1mP2Yud2lkdGg/Zi53aWR0aDo4MDA6ODAwO3ZhciBrPVJhcGhhZWwobCxoLDQwMCk7aWYoZD09PXVuZGVmaW5lZCl7ZD17fX12YXIgaT1uZXcgQUJDSlMud3JpdGUuUHJpbnRlcihrLGQpO2kucHJpbnRBQkMoail9YShnLGMsZSxiLGYpfTtBQkNKUy5yZW5kZXJNaWRpPWZ1bmN0aW9uKGMsZCxiLGYsZSl7ZnVuY3Rpb24gZyhqLGgpe2lmKGY9PT11bmRlZmluZWQpe2Y9e319dmFyIGk9bmV3IEFCQ0pTLm1pZGkuTWlkaVdyaXRlcihqLGYpO2kud3JpdGVBQkMoaCl9YShnLGMsZCxiLGUpfX0pKCk7aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMuZGF0YSl7d2luZG93LkFCQ0pTLmRhdGE9e319d2luZG93LkFCQ0pTLmRhdGEuVHVuZT1mdW5jdGlvbigpe3RoaXMucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLnZlcnNpb249XCIxLjAuMVwiO3RoaXMubWVkaWE9XCJzY3JlZW5cIjt0aGlzLm1ldGFUZXh0PXt9O3RoaXMuZm9ybWF0dGluZz17fTt0aGlzLmxpbmVzPVtdO3RoaXMuc3RhZmZOdW09MDt0aGlzLnZvaWNlTnVtPTA7dGhpcy5saW5lTnVtPTB9O3RoaXMuY2xlYW5VcD1mdW5jdGlvbihmLHAseSxxKXt0aGlzLmNsb3NlTGluZSgpO3ZhciBiPWZhbHNlO3ZhciB4LG8saztmb3IoeD0wO3g8dGhpcy5saW5lcy5sZW5ndGg7eCsrKXtpZih0aGlzLmxpbmVzW3hdLnN0YWZmIT09dW5kZWZpbmVkKXt2YXIgbT1mYWxzZTtmb3Iobz0wO288dGhpcy5saW5lc1t4XS5zdGFmZi5sZW5ndGg7bysrKXtpZih0aGlzLmxpbmVzW3hdLnN0YWZmW29dPT09dW5kZWZpbmVkKXtiPXRydWU7dGhpcy5saW5lc1t4XS5zdGFmZltvXT1udWxsfWVsc2V7Zm9yKGs9MDtrPHRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzLmxlbmd0aDtrKyspe2lmKHRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdPT09dW5kZWZpbmVkKXt0aGlzLmxpbmVzW3hdLnN0YWZmW29dLnZvaWNlc1trXT1bXX1lbHNle2lmKHRoaXMuY29udGFpbnNOb3Rlcyh0aGlzLmxpbmVzW3hdLnN0YWZmW29dLnZvaWNlc1trXSkpe209dHJ1ZX19fX19aWYoIW0pe3RoaXMubGluZXNbeF09bnVsbDtiPXRydWV9fX1pZihiKXt0aGlzLmxpbmVzPXdpbmRvdy5BQkNKUy5wYXJzZS5jb21wYWN0KHRoaXMubGluZXMpO3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKHRoaXMubGluZXMsZnVuY3Rpb24oaSl7aWYoaS5zdGFmZil7aS5zdGFmZj13aW5kb3cuQUJDSlMucGFyc2UuY29tcGFjdChpLnN0YWZmKX19KX1pZih5KXtmb3IoeD0wO3g8dGhpcy5saW5lcy5sZW5ndGg7eCsrKXtpZih0aGlzLmxpbmVzW3hdLnN0YWZmIT09dW5kZWZpbmVkKXtmb3Iobz0wO288dGhpcy5saW5lc1t4XS5zdGFmZi5sZW5ndGg7bysrKXtmb3Ioaz0wO2s8dGhpcy5saW5lc1t4XS5zdGFmZltvXS52b2ljZXMubGVuZ3RoO2srKyl7dmFyIGQ9MDtmb3IodmFyIHQ9MDt0PHRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdLmxlbmd0aDt0Kyspe2lmKHRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdW3RdLmVsX3R5cGU9PT1cImJhclwiKXtkKys7aWYoZD49eSl7aWYodDx0aGlzLmxpbmVzW3hdLnN0YWZmW29dLnZvaWNlc1trXS5sZW5ndGgtMSl7aWYoeD09PXRoaXMubGluZXMubGVuZ3RoLTEpe3ZhciBnPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5saW5lc1t4XSkpO3RoaXMubGluZXMucHVzaCh3aW5kb3cuQUJDSlMucGFyc2UuY2xvbmUoZykpO2Zvcih2YXIgdT0wO3U8dGhpcy5saW5lc1t4KzFdLnN0YWZmLmxlbmd0aDt1Kyspe2Zvcih2YXIgcj0wO3I8dGhpcy5saW5lc1t4KzFdLnN0YWZmW3VdLnZvaWNlcy5sZW5ndGg7cisrKXt0aGlzLmxpbmVzW3grMV0uc3RhZmZbdV0udm9pY2VzW3JdPVtdfX19dmFyIGE9dCsxO3ZhciBoPXRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdLnNsaWNlKGEpO3RoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdPXRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdLnNsaWNlKDAsYSk7dGhpcy5saW5lc1t4KzFdLnN0YWZmW29dLnZvaWNlc1trXT1oLmNvbmNhdCh0aGlzLmxpbmVzW3grMV0uc3RhZmZbb10udm9pY2VzW2tdKVxufX19fX19fX19aWYoeSl7Yj1mYWxzZTtmb3IoeD0wO3g8dGhpcy5saW5lcy5sZW5ndGg7eCsrKXtpZih0aGlzLmxpbmVzW3hdLnN0YWZmIT09dW5kZWZpbmVkKXtmb3Iobz0wO288dGhpcy5saW5lc1t4XS5zdGFmZi5sZW5ndGg7bysrKXt2YXIgYz1mYWxzZTtmb3Ioaz0wO2s8dGhpcy5saW5lc1t4XS5zdGFmZltvXS52b2ljZXMubGVuZ3RoO2srKyl7aWYodGhpcy5jb250YWluc05vdGVzU3RyaWN0KHRoaXMubGluZXNbeF0uc3RhZmZbb10udm9pY2VzW2tdKSl7Yz10cnVlfX1pZighYyl7Yj10cnVlO3RoaXMubGluZXNbeF0uc3RhZmZbb109bnVsbH19fX1pZihiKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaCh0aGlzLmxpbmVzLGZ1bmN0aW9uKGkpe2lmKGkuc3RhZmYpe2kuc3RhZmY9d2luZG93LkFCQ0pTLnBhcnNlLmNvbXBhY3QoaS5zdGFmZil9fSl9fWZvcih4PTA7eDx0aGlzLmxpbmVzLmxlbmd0aDt4Kyspe2lmKHRoaXMubGluZXNbeF0uc3RhZmYpe2ZvcihvPTA7bzx0aGlzLmxpbmVzW3hdLnN0YWZmLmxlbmd0aDtvKyspe2RlbGV0ZSB0aGlzLmxpbmVzW3hdLnN0YWZmW29dLndvcmtpbmdDbGVmfX19ZnVuY3Rpb24gbChLKXt2YXIgSj1bXTt2YXIgSDt2YXIgST1mdW5jdGlvbihOLGosUCl7aWYoSltQXT09PXVuZGVmaW5lZCl7Zm9yKEg9MDtIPEoubGVuZ3RoO0grKyl7aWYoSltIXSE9PXVuZGVmaW5lZCl7UD1IO2JyZWFrfX1pZihKW1BdPT09dW5kZWZpbmVkKXt2YXIgTz1QKjEwMDt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChOLmVuZFNsdXIsZnVuY3Rpb24oaSl7aWYoTz09PWkpey0tT319KTtKW1BdPVtPXX19dmFyIE07Zm9yKHZhciBMPTA7TDxqO0wrKyl7TT1KW1BdLnBvcCgpO04uZW5kU2x1ci5wdXNoKE0pfWlmKEpbUF0ubGVuZ3RoPT09MCl7ZGVsZXRlIEpbUF19cmV0dXJuIE19O3ZhciBDPWZ1bmN0aW9uKE4saixPLE0pe04uc3RhcnRTbHVyPVtdO2lmKEpbT109PT11bmRlZmluZWQpe0pbT109W119dmFyIFA9TyoxMDArMTtmb3IodmFyIEw9MDtMPGo7TCsrKXtpZihNKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChNLGZ1bmN0aW9uKGkpe2lmKFA9PT1pKXsrK1B9fSk7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goTSxmdW5jdGlvbihpKXtpZihQPT09aSl7KytQfX0pO3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKE0sZnVuY3Rpb24oaSl7aWYoUD09PWkpeysrUH19KX13aW5kb3cuQUJDSlMucGFyc2UuZWFjaChKW09dLGZ1bmN0aW9uKGkpe2lmKFA9PT1pKXsrK1B9fSk7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goSltPXSxmdW5jdGlvbihpKXtpZihQPT09aSl7KytQfX0pO0pbT10ucHVzaChQKTtOLnN0YXJ0U2x1ci5wdXNoKHtsYWJlbDpQfSk7UCsrfX07Zm9yKHZhciBEPTA7RDxLLmxlbmd0aDtEKyspe3ZhciB2PUtbRF07aWYodi5lbF90eXBlPT09XCJub3RlXCIpe2lmKHYuZ3JhY2Vub3Rlcyl7Zm9yKHZhciBFPTA7RTx2LmdyYWNlbm90ZXMubGVuZ3RoO0UrKyl7aWYodi5ncmFjZW5vdGVzW0VdLmVuZFNsdXIpe3ZhciBGPXYuZ3JhY2Vub3Rlc1tFXS5lbmRTbHVyO3YuZ3JhY2Vub3Rlc1tFXS5lbmRTbHVyPVtdO2Zvcih2YXIgbj0wO248RjtuKyspe0kodi5ncmFjZW5vdGVzW0VdLDEsMjApfX1pZih2LmdyYWNlbm90ZXNbRV0uc3RhcnRTbHVyKXtIPXYuZ3JhY2Vub3Rlc1tFXS5zdGFydFNsdXI7Qyh2LmdyYWNlbm90ZXNbRV0sSCwyMCl9fX1pZih2LmVuZFNsdXIpe0g9di5lbmRTbHVyO3YuZW5kU2x1cj1bXTtJKHYsSCwwKX1pZih2LnN0YXJ0U2x1cil7SD12LnN0YXJ0U2x1cjtDKHYsSCwwKX1pZih2LnBpdGNoZXMpe3ZhciBHPVtdO2Zvcih2YXIgcz0wO3M8di5waXRjaGVzLmxlbmd0aDtzKyspe2lmKHYucGl0Y2hlc1tzXS5lbmRTbHVyKXt2YXIgQT12LnBpdGNoZXNbc10uZW5kU2x1cjt2LnBpdGNoZXNbc10uZW5kU2x1cj1bXTtmb3IodmFyIEI9MDtCPEE7QisrKXt2YXIgej1JKHYucGl0Y2hlc1tzXSwxLHMrMSk7Ry5wdXNoKHopfX19Zm9yKHM9MDtzPHYucGl0Y2hlcy5sZW5ndGg7cysrKXtpZih2LnBpdGNoZXNbc10uc3RhcnRTbHVyKXtIPXYucGl0Y2hlc1tzXS5zdGFydFNsdXI7Qyh2LnBpdGNoZXNbc10sSCxzKzEsRyl9fWlmKHYuZ3JhY2Vub3RlcyYmdi5waXRjaGVzWzBdLmVuZFNsdXImJnYucGl0Y2hlc1swXS5lbmRTbHVyWzBdPT09MTAwJiZ2LnBpdGNoZXNbMF0uc3RhcnRTbHVyKXtpZih2LmdyYWNlbm90ZXNbMF0uZW5kU2x1cil7di5ncmFjZW5vdGVzWzBdLmVuZFNsdXIucHVzaCh2LnBpdGNoZXNbMF0uc3RhcnRTbHVyWzBdLmxhYmVsKX1lbHNle3YuZ3JhY2Vub3Rlc1swXS5lbmRTbHVyPVt2LnBpdGNoZXNbMF0uc3RhcnRTbHVyWzBdLmxhYmVsXX1pZih2LnBpdGNoZXNbMF0uZW5kU2x1ci5sZW5ndGg9PT0xKXtkZWxldGUgdi5waXRjaGVzWzBdLmVuZFNsdXJ9ZWxzZXtpZih2LnBpdGNoZXNbMF0uZW5kU2x1clswXT09PTEwMCl7di5waXRjaGVzWzBdLmVuZFNsdXIuc2hpZnQoKX1lbHNle2lmKHYucGl0Y2hlc1swXS5lbmRTbHVyW3YucGl0Y2hlc1swXS5lbmRTbHVyLmxlbmd0aC0xXT09PTEwMCl7di5waXRjaGVzWzBdLmVuZFNsdXIucG9wKCl9fX1pZihKWzFdLmxlbmd0aD09PTEpe2RlbGV0ZSBKWzFdfWVsc2V7SlsxXS5wb3AoKX19fX19fWZ1bmN0aW9uIGUoaSl7d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UuZml4Q2xlZihpKX1mb3IodGhpcy5saW5lTnVtPTA7dGhpcy5saW5lTnVtPHRoaXMubGluZXMubGVuZ3RoO3RoaXMubGluZU51bSsrKXtpZih0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmYpe2Zvcih0aGlzLnN0YWZmTnVtPTA7dGhpcy5zdGFmZk51bTx0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmYubGVuZ3RoO3RoaXMuc3RhZmZOdW0rKyl7aWYodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLmNsZWYpe2UodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLmNsZWYpfWZvcih0aGlzLnZvaWNlTnVtPTA7dGhpcy52b2ljZU51bTx0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzLmxlbmd0aDt0aGlzLnZvaWNlTnVtKyspe2wodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXSk7Zm9yKHZhciB3PTA7dzx0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzW3RoaXMudm9pY2VOdW1dLmxlbmd0aDt3Kyspe2lmKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV1bd10uZWxfdHlwZT09PVwiY2xlZlwiKXtlKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV1bd10pfX19fX19aWYoIXRoaXMuZm9ybWF0dGluZy5wYWdld2lkdGgpe3RoaXMuZm9ybWF0dGluZy5wYWdld2lkdGg9Zn1pZighdGhpcy5mb3JtYXR0aW5nLnBhZ2VoZWlnaHQpe3RoaXMuZm9ybWF0dGluZy5wYWdlaGVpZ2h0PXB9ZGVsZXRlIHRoaXMuc3RhZmZOdW07ZGVsZXRlIHRoaXMudm9pY2VOdW07ZGVsZXRlIHRoaXMubGluZU51bTtkZWxldGUgdGhpcy5wb3RlbnRpYWxTdGFydEJlYW07ZGVsZXRlIHRoaXMucG90ZW50aWFsRW5kQmVhbTtkZWxldGUgdGhpcy52c2tpcFBlbmRpbmd9O3RoaXMucmVzZXQoKTt0aGlzLmdldExhc3ROb3RlPWZ1bmN0aW9uKCl7aWYodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dJiZ0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmYmJnRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXSYmdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXSl7Zm9yKHZhciBhPXRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV0ubGVuZ3RoLTE7YT49MDthLS0pe3ZhciBiPXRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV1bYV07aWYoYi5lbF90eXBlPT09XCJub3RlXCIpe3JldHVybiBifX19cmV0dXJuIG51bGx9O3RoaXMuYWRkVGllVG9MYXN0Tm90ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0TGFzdE5vdGUoKTtpZihhJiZhLnBpdGNoZXMmJmEucGl0Y2hlcy5sZW5ndGg+MCl7YS5waXRjaGVzWzBdLnN0YXJ0VGllPXt9O3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dGhpcy5nZXREdXJhdGlvbj1mdW5jdGlvbihhKXtpZihhLmR1cmF0aW9uKXtyZXR1cm4gYS5kdXJhdGlvbn1yZXR1cm4gMH07dGhpcy5jbG9zZUxpbmU9ZnVuY3Rpb24oKXtpZih0aGlzLnBvdGVudGlhbFN0YXJ0QmVhbSYmdGhpcy5wb3RlbnRpYWxFbmRCZWFtKXt0aGlzLnBvdGVudGlhbFN0YXJ0QmVhbS5zdGFydEJlYW09dHJ1ZTt0aGlzLnBvdGVudGlhbEVuZEJlYW0uZW5kQmVhbT10cnVlfWRlbGV0ZSB0aGlzLnBvdGVudGlhbFN0YXJ0QmVhbTtkZWxldGUgdGhpcy5wb3RlbnRpYWxFbmRCZWFtfTt0aGlzLmFwcGVuZEVsZW1lbnQ9ZnVuY3Rpb24oaCxpLGUsYSl7dmFyIGM9dGhpczt2YXIgZz1mdW5jdGlvbihsKXtpZihsLnBpdGNoZXMhPT11bmRlZmluZWQpe3ZhciBqPWMubGluZXNbYy5saW5lTnVtXS5zdGFmZltjLnN0YWZmTnVtXS53b3JraW5nQ2xlZi52ZXJ0aWNhbFBvczt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChsLnBpdGNoZXMsZnVuY3Rpb24obSl7bS52ZXJ0aWNhbFBvcz1tLnBpdGNoLWp9KX1pZihsLmdyYWNlbm90ZXMhPT11bmRlZmluZWQpe3ZhciBrPWMubGluZXNbYy5saW5lTnVtXS5zdGFmZltjLnN0YWZmTnVtXS53b3JraW5nQ2xlZi52ZXJ0aWNhbFBvczt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChsLmdyYWNlbm90ZXMsZnVuY3Rpb24obSl7bS52ZXJ0aWNhbFBvcz1tLnBpdGNoLWt9KX1jLmxpbmVzW2MubGluZU51bV0uc3RhZmZbYy5zdGFmZk51bV0udm9pY2VzW2Mudm9pY2VOdW1dLnB1c2gobCl9O2EuZWxfdHlwZT1oO2lmKGkhPT1udWxsKXthLnN0YXJ0Q2hhcj1pfWlmKGUhPT1udWxsKXthLmVuZENoYXI9ZX12YXIgZD1mdW5jdGlvbigpe2MucG90ZW50aWFsU3RhcnRCZWFtLnN0YXJ0QmVhbT10cnVlO2EuZW5kQmVhbT10cnVlO2RlbGV0ZSBjLnBvdGVudGlhbFN0YXJ0QmVhbTtkZWxldGUgYy5wb3RlbnRpYWxFbmRCZWFtfTt2YXIgZj1mdW5jdGlvbigpe2lmKGMucG90ZW50aWFsU3RhcnRCZWFtIT09dW5kZWZpbmVkJiZjLnBvdGVudGlhbEVuZEJlYW0hPT11bmRlZmluZWQpe2MucG90ZW50aWFsU3RhcnRCZWFtLnN0YXJ0QmVhbT10cnVlO2MucG90ZW50aWFsRW5kQmVhbS5lbmRCZWFtPXRydWV9ZGVsZXRlIGMucG90ZW50aWFsU3RhcnRCZWFtO2RlbGV0ZSBjLnBvdGVudGlhbEVuZEJlYW19O2lmKGg9PT1cIm5vdGVcIil7dmFyIGI9Yy5nZXREdXJhdGlvbihhKTtpZihiPj0wLjI1KXtmKCl9ZWxzZXtpZihhLmZvcmNlX2VuZF9iZWFtX2xhc3QmJmMucG90ZW50aWFsU3RhcnRCZWFtIT09dW5kZWZpbmVkKXtmKCl9ZWxzZXtpZihhLmVuZF9iZWFtJiZjLnBvdGVudGlhbFN0YXJ0QmVhbSE9PXVuZGVmaW5lZCl7aWYoYS5yZXN0PT09dW5kZWZpbmVkKXtkKCl9ZWxzZXtmKCl9fWVsc2V7aWYoYS5yZXN0PT09dW5kZWZpbmVkKXtpZihjLnBvdGVudGlhbFN0YXJ0QmVhbT09PXVuZGVmaW5lZCl7aWYoIWEuZW5kX2JlYW0pe2MucG90ZW50aWFsU3RhcnRCZWFtPWE7ZGVsZXRlIGMucG90ZW50aWFsRW5kQmVhbX19ZWxzZXtjLnBvdGVudGlhbEVuZEJlYW09YX19fX19fWVsc2V7ZigpfWRlbGV0ZSBhLmVuZF9iZWFtO2RlbGV0ZSBhLmZvcmNlX2VuZF9iZWFtX2xhc3Q7ZyhhKX07dGhpcy5hcHBlbmRTdGFydGluZ0VsZW1lbnQ9ZnVuY3Rpb24oZixhLGgsYyl7dGhpcy5jbG9zZUxpbmUoKTt2YXIgZTtpZihmPT09XCJrZXlcIil7ZT1jLmltcGxpZWROYXR1cmFscztkZWxldGUgYy5pbXBsaWVkTmF0dXJhbHN9dmFyIGI9d2luZG93LkFCQ0pTLnBhcnNlLmNsb25lKGMpO2lmKGY9PT1cImNsZWZcIil7dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLndvcmtpbmdDbGVmPWJ9aWYodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmLmxlbmd0aDw9dGhpcy5zdGFmZk51bSl7dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dPXt9O3RoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS5jbGVmPXdpbmRvdy5BQkNKUy5wYXJzZS5jbG9uZSh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbMF0uY2xlZik7dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLmtleT13aW5kb3cuQUJDSlMucGFyc2UuY2xvbmUodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmWzBdLmtleSk7dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLm1ldGVyPXdpbmRvdy5BQkNKUy5wYXJzZS5jbG9uZSh0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbMF0ubWV0ZXIpO3RoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS53b3JraW5nQ2xlZj13aW5kb3cuQUJDSlMucGFyc2UuY2xvbmUodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmWzBdLndvcmtpbmdDbGVmKTt0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzPVtbXV19dmFyIGc9dGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXTtmb3IodmFyIGQ9MDtkPGcubGVuZ3RoO2QrKyl7aWYoZ1tkXS5lbF90eXBlPT09XCJub3RlXCJ8fGdbZF0uZWxfdHlwZT09PVwiYmFyXCIpe2IuZWxfdHlwZT1mO2Iuc3RhcnRDaGFyPWE7Yi5lbmRDaGFyPWg7aWYoZSl7Yi5hY2NpZGVudGFscz1lLmNvbmNhdChiLmFjY2lkZW50YWxzKX1nLnB1c2goYik7cmV0dXJufWlmKGdbZF0uZWxfdHlwZT09PWYpe2IuZWxfdHlwZT1mO2Iuc3RhcnRDaGFyPWE7XG5iLmVuZENoYXI9aDtpZihlKXtiLmFjY2lkZW50YWxzPWUuY29uY2F0KGIuYWNjaWRlbnRhbHMpfWdbZF09YjtyZXR1cm59fXRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXVtmXT1jfTt0aGlzLmdldE51bUxpbmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZXMubGVuZ3RofTt0aGlzLnB1c2hMaW5lPWZ1bmN0aW9uKGEpe2lmKHRoaXMudnNraXBQZW5kaW5nKXthLnZza2lwPXRoaXMudnNraXBQZW5kaW5nO2RlbGV0ZSB0aGlzLnZza2lwUGVuZGluZ310aGlzLmxpbmVzLnB1c2goYSl9O3RoaXMuYWRkU3VidGl0bGU9ZnVuY3Rpb24oYSl7dGhpcy5wdXNoTGluZSh7c3VidGl0bGU6YX0pfTt0aGlzLmFkZFNwYWNpbmc9ZnVuY3Rpb24oYSl7dGhpcy52c2tpcFBlbmRpbmc9YX07dGhpcy5hZGROZXdQYWdlPWZ1bmN0aW9uKGEpe3RoaXMucHVzaExpbmUoe25ld3BhZ2U6YX0pfTt0aGlzLmFkZFNlcGFyYXRvcj1mdW5jdGlvbihjLGIsYSl7dGhpcy5wdXNoTGluZSh7c2VwYXJhdG9yOntzcGFjZUFib3ZlOmMsc3BhY2VCZWxvdzpiLGxpbmVMZW5ndGg6YX19KX07dGhpcy5hZGRUZXh0PWZ1bmN0aW9uKGEpe3RoaXMucHVzaExpbmUoe3RleHQ6YX0pfTt0aGlzLmFkZENlbnRlcmVkPWZ1bmN0aW9uKGEpe3RoaXMucHVzaExpbmUoe3RleHQ6W3t0ZXh0OmEsY2VudGVyOnRydWV9XX0pfTt0aGlzLmNvbnRhaW5zTm90ZXM9ZnVuY3Rpb24oYil7Zm9yKHZhciBhPTA7YTxiLmxlbmd0aDthKyspe2lmKGJbYV0uZWxfdHlwZT09PVwibm90ZVwifHxiW2FdLmVsX3R5cGU9PT1cImJhclwiKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTt0aGlzLmNvbnRhaW5zTm90ZXNTdHJpY3Q9ZnVuY3Rpb24oYil7Zm9yKHZhciBhPTA7YTxiLmxlbmd0aDthKyspe2lmKGJbYV0uZWxfdHlwZT09PVwibm90ZVwiJiZiW2FdLnJlc3Q9PT11bmRlZmluZWQpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O3RoaXMuc3RhcnROZXdMaW5lPWZ1bmN0aW9uKGUpe3ZhciBkPXRoaXM7dGhpcy5jbG9zZUxpbmUoKTt2YXIgYz1mdW5jdGlvbihqKXtkLmxpbmVzW2QubGluZU51bV0uc3RhZmZbZC5zdGFmZk51bV0udm9pY2VzW2Qudm9pY2VOdW1dPVtdO2lmKGQuaXNGaXJzdExpbmUoZC5saW5lTnVtKSl7aWYoai5uYW1lKXtpZighZC5saW5lc1tkLmxpbmVOdW1dLnN0YWZmW2Quc3RhZmZOdW1dLnRpdGxlKXtkLmxpbmVzW2QubGluZU51bV0uc3RhZmZbZC5zdGFmZk51bV0udGl0bGU9W119ZC5saW5lc1tkLmxpbmVOdW1dLnN0YWZmW2Quc3RhZmZOdW1dLnRpdGxlW2Qudm9pY2VOdW1dPWoubmFtZX19ZWxzZXtpZihqLnN1Ym5hbWUpe2lmKCFkLmxpbmVzW2QubGluZU51bV0uc3RhZmZbZC5zdGFmZk51bV0udGl0bGUpe2QubGluZXNbZC5saW5lTnVtXS5zdGFmZltkLnN0YWZmTnVtXS50aXRsZT1bXX1kLmxpbmVzW2QubGluZU51bV0uc3RhZmZbZC5zdGFmZk51bV0udGl0bGVbZC52b2ljZU51bV09ai5zdWJuYW1lfX1pZihqLnN0eWxlKXtkLmFwcGVuZEVsZW1lbnQoXCJzdHlsZVwiLG51bGwsbnVsbCx7aGVhZDpqLnN0eWxlfSl9aWYoai5zdGVtKXtkLmFwcGVuZEVsZW1lbnQoXCJzdGVtXCIsbnVsbCxudWxsLHtkaXJlY3Rpb246ai5zdGVtfSl9ZWxzZXtpZihkLnZvaWNlTnVtPjApe2lmKGQubGluZXNbZC5saW5lTnVtXS5zdGFmZltkLnN0YWZmTnVtXS52b2ljZXNbMF0hPT11bmRlZmluZWQpe3ZhciBnPWZhbHNlO2Zvcih2YXIgZj0wO2Y8ZC5saW5lc1tkLmxpbmVOdW1dLnN0YWZmW2Quc3RhZmZOdW1dLnZvaWNlc1swXS5sZW5ndGg7ZisrKXtpZihkLmxpbmVzW2QubGluZU51bV0uc3RhZmZbZC5zdGFmZk51bV0udm9pY2VzWzBdLmVsX3R5cGU9PT1cInN0ZW1cIil7Zz10cnVlfX1pZighZyl7dmFyIGg9e2VsX3R5cGU6XCJzdGVtXCIsZGlyZWN0aW9uOlwidXBcIn07ZC5saW5lc1tkLmxpbmVOdW1dLnN0YWZmW2Quc3RhZmZOdW1dLnZvaWNlc1swXS5zcGxpY2UoMCwwLGgpfX1kLmFwcGVuZEVsZW1lbnQoXCJzdGVtXCIsbnVsbCxudWxsLHtkaXJlY3Rpb246XCJkb3duXCJ9KX19aWYoai5zY2FsZSl7ZC5hcHBlbmRFbGVtZW50KFwic2NhbGVcIixudWxsLG51bGwse3NpemU6ai5zY2FsZX0pfX07dmFyIGE9ZnVuY3Rpb24oZil7ZC5saW5lc1tkLmxpbmVOdW1dLnN0YWZmW2Quc3RhZmZOdW1dPXt2b2ljZXM6W10sY2xlZjpmLmNsZWYsa2V5OmYua2V5LHdvcmtpbmdDbGVmOmYuY2xlZn07aWYoZi52b2NhbGZvbnQpe2QubGluZXNbZC5saW5lTnVtXS5zdGFmZltkLnN0YWZmTnVtXS52b2NhbGZvbnQ9Zi52b2NhbGZvbnR9aWYoZi5icmFja2V0KXtkLmxpbmVzW2QubGluZU51bV0uc3RhZmZbZC5zdGFmZk51bV0uYnJhY2tldD1mLmJyYWNrZXR9aWYoZi5icmFjZSl7ZC5saW5lc1tkLmxpbmVOdW1dLnN0YWZmW2Quc3RhZmZOdW1dLmJyYWNlPWYuYnJhY2V9aWYoZi5jb25uZWN0QmFyTGluZXMpe2QubGluZXNbZC5saW5lTnVtXS5zdGFmZltkLnN0YWZmTnVtXS5jb25uZWN0QmFyTGluZXM9Zi5jb25uZWN0QmFyTGluZXN9YyhmKTtpZihmLnBhcnQpe2QuYXBwZW5kRWxlbWVudChcInBhcnRcIixmLnN0YXJ0Q2hhcixmLmVuZENoYXIse3RpdGxlOmYucGFydH0pfWlmKGYubWV0ZXIhPT11bmRlZmluZWQpe2QubGluZXNbZC5saW5lTnVtXS5zdGFmZltkLnN0YWZmTnVtXS5tZXRlcj1mLm1ldGVyfX07dmFyIGI9ZnVuY3Rpb24oZil7ZC5saW5lc1tkLmxpbmVOdW1dPXtzdGFmZjpbXX07YShmKX07aWYodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dPT09dW5kZWZpbmVkKXtiKGUpfWVsc2V7aWYodGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmPT09dW5kZWZpbmVkKXt0aGlzLmxpbmVOdW0rKzt0aGlzLnN0YXJ0TmV3TGluZShlKX1lbHNle2lmKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXT09PXVuZGVmaW5lZCl7YShlKX1lbHNle2lmKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV09PT11bmRlZmluZWQpe2MoZSl9ZWxzZXtpZighdGhpcy5jb250YWluc05vdGVzKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXS5zdGFmZlt0aGlzLnN0YWZmTnVtXS52b2ljZXNbdGhpcy52b2ljZU51bV0pKXtyZXR1cm59ZWxzZXt0aGlzLmxpbmVOdW0rKzt0aGlzLnN0YXJ0TmV3TGluZShlKX19fX19fTt0aGlzLmhhc0JlZ2luTXVzaWM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lcy5sZW5ndGg+MH07dGhpcy5pc0ZpcnN0TGluZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9YS0xO2I+PTA7Yi0tKXtpZih0aGlzLmxpbmVzW2JdLnN0YWZmIT09dW5kZWZpbmVkKXtyZXR1cm4gZmFsc2V9fXJldHVybiB0cnVlfTt0aGlzLmdldEN1cnJlbnRWb2ljZT1mdW5jdGlvbigpe2lmKHRoaXMubGluZXNbdGhpcy5saW5lTnVtXSE9PXVuZGVmaW5lZCYmdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dIT09dW5kZWZpbmVkJiZ0aGlzLmxpbmVzW3RoaXMubGluZU51bV0uc3RhZmZbdGhpcy5zdGFmZk51bV0udm9pY2VzW3RoaXMudm9pY2VOdW1dIT09dW5kZWZpbmVkKXtyZXR1cm4gdGhpcy5saW5lc1t0aGlzLmxpbmVOdW1dLnN0YWZmW3RoaXMuc3RhZmZOdW1dLnZvaWNlc1t0aGlzLnZvaWNlTnVtXX1lbHNle3JldHVybiBudWxsfX07dGhpcy5zZXRDdXJyZW50Vm9pY2U9ZnVuY3Rpb24oYyxiKXt0aGlzLnN0YWZmTnVtPWM7dGhpcy52b2ljZU51bT1iO2Zvcih2YXIgYT0wO2E8dGhpcy5saW5lcy5sZW5ndGg7YSsrKXtpZih0aGlzLmxpbmVzW2FdLnN0YWZmKXtpZih0aGlzLmxpbmVzW2FdLnN0YWZmW2NdPT09dW5kZWZpbmVkfHx0aGlzLmxpbmVzW2FdLnN0YWZmW2NdLnZvaWNlc1tiXT09PXVuZGVmaW5lZHx8IXRoaXMuY29udGFpbnNOb3Rlcyh0aGlzLmxpbmVzW2FdLnN0YWZmW2NdLnZvaWNlc1tiXSkpe3RoaXMubGluZU51bT1hO3JldHVybn19fXRoaXMubGluZU51bT1hfTt0aGlzLmFkZE1ldGFUZXh0PWZ1bmN0aW9uKGEsYil7aWYodGhpcy5tZXRhVGV4dFthXT09PXVuZGVmaW5lZCl7dGhpcy5tZXRhVGV4dFthXT1ifWVsc2V7dGhpcy5tZXRhVGV4dFthXSs9XCJcXG5cIitifX07dGhpcy5hZGRNZXRhVGV4dEFycmF5PWZ1bmN0aW9uKGEsYil7aWYodGhpcy5tZXRhVGV4dFthXT09PXVuZGVmaW5lZCl7dGhpcy5tZXRhVGV4dFthXT1bYl19ZWxzZXt0aGlzLm1ldGFUZXh0W2FdLnB1c2goYil9fTt0aGlzLmFkZE1ldGFUZXh0T2JqPWZ1bmN0aW9uKGEsYil7dGhpcy5tZXRhVGV4dFthXT1ifX07aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMubWlkaSl7d2luZG93LkFCQ0pTLm1pZGk9e319KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShqLGkpe2Zvcih2YXIgaCBpbiBpKXtpZihpLmhhc093blByb3BlcnR5KGgpKXtqLnNldEF0dHJpYnV0ZShoLGlbaF0pfX1yZXR1cm4gan1mdW5jdGlvbiBnKGgsaSl7dGhpcy5qYXZhbWlkaT1oO3RoaXMucXRtaWRpPWl9Zy5wcm90b3R5cGUuc2V0VGVtcG89ZnVuY3Rpb24oaCl7dGhpcy5qYXZhbWlkaS5zZXRUZW1wbyhoKTt0aGlzLnF0bWlkaS5zZXRUZW1wbyhoKX07Zy5wcm90b3R5cGUuc3RhcnRUcmFjaz1mdW5jdGlvbigpe3RoaXMuamF2YW1pZGkuc3RhcnRUcmFjaygpO3RoaXMucXRtaWRpLnN0YXJ0VHJhY2soKX07Zy5wcm90b3R5cGUuZW5kVHJhY2s9ZnVuY3Rpb24oKXt0aGlzLmphdmFtaWRpLmVuZFRyYWNrKCk7dGhpcy5xdG1pZGkuZW5kVHJhY2soKX07Zy5wcm90b3R5cGUuc2V0SW5zdHJ1bWVudD1mdW5jdGlvbihoKXt0aGlzLmphdmFtaWRpLnNldEluc3RydW1lbnQoaCk7dGhpcy5xdG1pZGkuc2V0SW5zdHJ1bWVudChoKX07Zy5wcm90b3R5cGUuc3RhcnROb3RlPWZ1bmN0aW9uKGosaCxpKXt0aGlzLmphdmFtaWRpLnN0YXJ0Tm90ZShqLGgsaSk7dGhpcy5xdG1pZGkuc3RhcnROb3RlKGosaCxpKX07Zy5wcm90b3R5cGUuZW5kTm90ZT1mdW5jdGlvbihpLGgpe3RoaXMuamF2YW1pZGkuZW5kTm90ZShpLGgpO3RoaXMucXRtaWRpLmVuZE5vdGUoaSxoKX07Zy5wcm90b3R5cGUuYWRkUmVzdD1mdW5jdGlvbihoKXt0aGlzLmphdmFtaWRpLmFkZFJlc3QoaCk7dGhpcy5xdG1pZGkuYWRkUmVzdChoKX07Zy5wcm90b3R5cGUuZW1iZWQ9ZnVuY3Rpb24oaCl7dGhpcy5qYXZhbWlkaS5lbWJlZChoKTt0aGlzLnF0bWlkaS5lbWJlZChoLHRydWUpfTtmdW5jdGlvbiBiKGgpe3RoaXMucGxheWxpc3Q9W107dGhpcy50cmFja2NvdW50PTA7dGhpcy50aW1lY291bnQ9MDt0aGlzLnRlbXBvPTYwO3RoaXMubWlkaWFwaT1NSURJUGx1Z2luO3RoaXMubWlkaXdyaXRlcj1oO3RoaXMubm90ZU9uQW5kQ2hhbm5lbD1cIiU5MFwifWIucHJvdG90eXBlLnNldFRlbXBvPWZ1bmN0aW9uKGgpe3RoaXMudGVtcG89aH07Yi5wcm90b3R5cGUuc3RhcnRUcmFjaz1mdW5jdGlvbigpe3RoaXMuc2lsZW5jZWxlbmd0aD0wO3RoaXMudHJhY2tjb3VudCsrO3RoaXMudGltZWNvdW50PTA7dGhpcy5wbGF5bGlzdHBvcz0wO3RoaXMuZmlyc3Q9dHJ1ZTtpZih0aGlzLmluc3RydW1lbnQpe3RoaXMuc2V0SW5zdHJ1bWVudCh0aGlzLmluc3RydW1lbnQpfWlmKHRoaXMuY2hhbm5lbCl7dGhpcy5zZXRDaGFubmVsKHRoaXMuY2hhbm5lbCl9fTtiLnByb3RvdHlwZS5lbmRUcmFjaz1mdW5jdGlvbigpe307Yi5wcm90b3R5cGUuc2V0SW5zdHJ1bWVudD1mdW5jdGlvbihoKXt0aGlzLmluc3RydW1lbnQ9aDt0aGlzLm1pZGlhcGkuc2V0SW5zdHJ1bWVudChoKX07Yi5wcm90b3R5cGUuc2V0Q2hhbm5lbD1mdW5jdGlvbihoKXt0aGlzLmNoYW5uZWw9aDt0aGlzLm1pZGlhcGkuc2V0Q2hhbm5lbChoKX07Yi5wcm90b3R5cGUudXBkYXRlUG9zPWZ1bmN0aW9uKCl7d2hpbGUodGhpcy5wbGF5bGlzdFt0aGlzLnBsYXlsaXN0cG9zXSYmdGhpcy5wbGF5bGlzdFt0aGlzLnBsYXlsaXN0cG9zXS50aW1lPHRoaXMudGltZWNvdW50KXt0aGlzLnBsYXlsaXN0cG9zKyt9fTtiLnByb3RvdHlwZS5zdGFydE5vdGU9ZnVuY3Rpb24oayxpLGope3RoaXMudGltZWNvdW50Kz10aGlzLnNpbGVuY2VsZW5ndGg7dGhpcy5zaWxlbmNlbGVuZ3RoPTA7aWYodGhpcy5maXJzdCl7fXRoaXMudXBkYXRlUG9zKCk7dmFyIGg9dGhpczt0aGlzLnBsYXlsaXN0LnNwbGljZSh0aGlzLnBsYXlsaXN0cG9zLDAse3RpbWU6dGhpcy50aW1lY291bnQsZnVuY3Q6ZnVuY3Rpb24oKXtoLm1pZGlhcGkucGxheU5vdGUoayk7aC5taWRpd3JpdGVyLm5vdGlmeVNlbGVjdChqKX19KX07Yi5wcm90b3R5cGUuZW5kTm90ZT1mdW5jdGlvbihqLGkpe3RoaXMudGltZWNvdW50Kz1pO3RoaXMudXBkYXRlUG9zKCk7dmFyIGg9dGhpczt0aGlzLnBsYXlsaXN0LnNwbGljZSh0aGlzLnBsYXlsaXN0cG9zLDAse3RpbWU6dGhpcy50aW1lY291bnQsZnVuY3Q6ZnVuY3Rpb24oKXtoLm1pZGlhcGkuc3RvcE5vdGUoail9fSl9O2IucHJvdG90eXBlLmFkZFJlc3Q9ZnVuY3Rpb24oaCl7dGhpcy5zaWxlbmNlbGVuZ3RoKz1ofTtiLnByb3RvdHlwZS5lbWJlZD1mdW5jdGlvbihpKXt0aGlzLnBsYXlsaW5rPWEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikse3N0eWxlOlwiYm9yZGVyOjFweCBzb2xpZCBibGFjazsgbWFyZ2luOjNweDtcIn0pO3RoaXMucGxheWxpbmsuaW5uZXJIVE1MPVwicGxheVwiO3ZhciBoPXRoaXM7dGhpcy5wbGF5bGluay5vbm1vdXNlZG93bj1mdW5jdGlvbigpe2lmKGgucGxheWluZyl7dGhpcy5pbm5lckhUTUw9XCJwbGF5XCI7aC5wYXVzZVBsYXkoKX1lbHNle3RoaXMuaW5uZXJIVE1MPVwicGF1c2VcIjtoLnN0YXJ0UGxheSgpfX07aS5hcHBlbmRDaGlsZCh0aGlzLnBsYXlsaW5rKTt2YXIgaj1hKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLHtzdHlsZTpcImJvcmRlcjoxcHggc29saWQgYmxhY2s7IG1hcmdpbjozcHg7XCJ9KTtqLmlubmVySFRNTD1cInN0b3BcIjtqLm9ubW91c2Vkb3duPWZ1bmN0aW9uKCl7aC5zdG9wUGxheSgpfTtpLmFwcGVuZENoaWxkKGopO3RoaXMuaT0wO3RoaXMuY3VycmVudHRpbWU9MDt0aGlzLnBsYXlpbmc9ZmFsc2V9O2IucHJvdG90eXBlLnN0b3BQbGF5PWZ1bmN0aW9uKCl7dGhpcy5pPTA7dGhpcy5jdXJyZW50dGltZT0wO1xudGhpcy5wYXVzZVBsYXkoKTt0aGlzLnBsYXlsaW5rLmlubmVySFRNTD1cInBsYXlcIn07Yi5wcm90b3R5cGUuc3RhcnRQbGF5PWZ1bmN0aW9uKCl7dGhpcy5wbGF5aW5nPXRydWU7dmFyIGg9dGhpczt0aGlzLnRpY2tzcGVyaW50ZXJ2YWw9NDgwLzQ7dGhpcy5kb1BsYXkoKTt0aGlzLnBsYXlpbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtoLmRvUGxheSgpfSwoNjAwMDAvKHRoaXMudGVtcG8qNCkpKX07Yi5wcm90b3R5cGUucGF1c2VQbGF5PWZ1bmN0aW9uKCl7dGhpcy5wbGF5aW5nPWZhbHNlO3dpbmRvdy5jbGVhckludGVydmFsKHRoaXMucGxheWludGVydmFsKTt0aGlzLm1pZGlhcGkuc3RvcEFsbE5vdGVzKCl9O2IucHJvdG90eXBlLmRvUGxheT1mdW5jdGlvbigpe3doaWxlKHRoaXMucGxheWxpc3RbdGhpcy5pXSYmdGhpcy5wbGF5bGlzdFt0aGlzLmldLnRpbWU8PXRoaXMuY3VycmVudHRpbWUpe3RoaXMucGxheWxpc3RbdGhpcy5pXS5mdW5jdCgpO3RoaXMuaSsrfWlmKHRoaXMucGxheWxpc3RbdGhpcy5pXSl7dGhpcy5jdXJyZW50dGltZSs9dGhpcy50aWNrc3BlcmludGVydmFsfWVsc2V7dGhpcy5zdG9wUGxheSgpfX07ZnVuY3Rpb24gZCgpe3RoaXMudHJhY2tzdHJpbmdzPVwiXCI7dGhpcy50cmFja2NvdW50PTA7dGhpcy5ub3RlT25BbmRDaGFubmVsPVwiJTkwXCJ9ZC5wcm90b3R5cGUuc2V0VGVtcG89ZnVuY3Rpb24oaCl7aWYodGhpcy50cmFja2NvdW50PT09MCl7dGhpcy5zdGFydFRyYWNrKCk7dGhpcy50cmFjays9XCIlMDAlRkYlNTElMDNcIitjKE1hdGgucm91bmQoNjAwMDAwMDAvaCksNik7dGhpcy5lbmRUcmFjaygpfX07ZC5wcm90b3R5cGUuc3RhcnRUcmFjaz1mdW5jdGlvbigpe3RoaXMudHJhY2s9XCJcIjt0aGlzLnNpbGVuY2VsZW5ndGg9MDt0aGlzLnRyYWNrY291bnQrKzt0aGlzLmZpcnN0PXRydWU7aWYodGhpcy5pbnN0cnVtZW50KXt0aGlzLnNldEluc3RydW1lbnQodGhpcy5pbnN0cnVtZW50KX19O2QucHJvdG90eXBlLmVuZFRyYWNrPWZ1bmN0aW9uKCl7dmFyIGg9Yyh0aGlzLnRyYWNrLmxlbmd0aC8zKzQsOCk7dGhpcy50cmFjaz1cIk1UcmtcIitoK3RoaXMudHJhY2srXCIlMDAlRkYlMkYlMDBcIjt0aGlzLnRyYWNrc3RyaW5ncys9dGhpcy50cmFja307ZC5wcm90b3R5cGUuc2V0SW5zdHJ1bWVudD1mdW5jdGlvbihoKXtpZih0aGlzLnRyYWNrKXt0aGlzLnRyYWNrPVwiJTAwJUMwXCIrYyhoLDIpK3RoaXMudHJhY2t9ZWxzZXt0aGlzLnRyYWNrPVwiJTAwJUMwXCIrYyhoLDIpfXRoaXMuaW5zdHJ1bWVudD1ofTtkLnByb3RvdHlwZS5zZXRDaGFubmVsPWZ1bmN0aW9uKGgpe3RoaXMuY2hhbm5lbD1oLTE7dGhpcy5ub3RlT25BbmRDaGFubmVsPVwiJTlcIit0aGlzLmNoYW5uZWwudG9TdHJpbmcoMTYpfTtkLnByb3RvdHlwZS5zdGFydE5vdGU9ZnVuY3Rpb24oaSxoKXt0aGlzLnRyYWNrKz1lKHRoaXMuc2lsZW5jZWxlbmd0aCk7dGhpcy5zaWxlbmNlbGVuZ3RoPTA7aWYodGhpcy5maXJzdCl7dGhpcy5maXJzdD1mYWxzZTt0aGlzLnRyYWNrKz10aGlzLm5vdGVPbkFuZENoYW5uZWx9dGhpcy50cmFjays9XCIlXCIraS50b1N0cmluZygxNikrXCIlXCIraH07ZC5wcm90b3R5cGUuZW5kTm90ZT1mdW5jdGlvbihpLGgpe3RoaXMudHJhY2srPWUoaCk7dGhpcy50cmFjays9XCIlXCIraS50b1N0cmluZygxNikrXCIlMDBcIn07ZC5wcm90b3R5cGUuYWRkUmVzdD1mdW5jdGlvbihoKXt0aGlzLnNpbGVuY2VsZW5ndGgrPWh9O2QucHJvdG90eXBlLmVtYmVkPWZ1bmN0aW9uKGksaCl7dmFyIGs9XCJkYXRhOmF1ZGlvL21pZGksTVRoZCUwMCUwMCUwMCUwNiUwMCUwMVwiK2ModGhpcy50cmFja2NvdW50LDQpK1wiJTAxJWUwXCIrdGhpcy50cmFja3N0cmluZ3M7dmFyIGo9YShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSx7aHJlZjprfSk7ai5pbm5lckhUTUw9XCJkb3dubG9hZCBtaWRpXCI7aS5pbnNlcnRCZWZvcmUoaixpLmZpcnN0Q2hpbGQpO2lmKGgpe3JldHVybn12YXIgbD1hKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJlbWJlZFwiKSx7c3JjOmssdHlwZTpcInZpZGVvL3F1aWNrdGltZVwiLGNvbnRyb2xsZXI6XCJ0cnVlXCIsYXV0b3BsYXk6XCJmYWxzZVwiLGxvb3A6XCJmYWxzZVwiLGVuYWJsZWphdmFzY3JpcHQ6XCJ0cnVlXCIsc3R5bGU6XCJkaXNwbGF5OmJsb2NrOyBoZWlnaHQ6IDIwcHg7XCJ9KTtpLmluc2VydEJlZm9yZShsLGkuZmlyc3RDaGlsZCl9O2Z1bmN0aW9uIGYoayl7dmFyIGg9XCJcIjtmb3IodmFyIGo9MDtqPGsubGVuZ3RoO2orPTIpe2grPVwiJVwiO2grPWsuc3Vic3RyKGosMil9cmV0dXJuIGh9ZnVuY3Rpb24gYyhqLGkpe3ZhciBoPWoudG9TdHJpbmcoMTYpO3doaWxlKGgubGVuZ3RoPGkpe2g9XCIwXCIraH1yZXR1cm4gZihoKX1mdW5jdGlvbiBlKG8pe3ZhciBrPTA7dmFyIGg9W107d2hpbGUobyE9PTApe2gucHVzaChvJjEyNyk7bz1vPj43fWZvcih2YXIgaj1oLmxlbmd0aC0xO2o+PTA7ai0tKXtrPWs8PDg7dmFyIGw9aFtqXTtpZihqIT09MCl7bD1sfDEyOH1rPWt8bH12YXIgbT1rLnRvU3RyaW5nKDE2KS5sZW5ndGg7bSs9bSUyO3JldHVybiBjKGssbSl9QUJDSlMubWlkaS5NaWRpV3JpdGVyPWZ1bmN0aW9uKGksaCl7aD1ofHx7fTt0aGlzLnBhcmVudD1pO3RoaXMuc2NhbGU9WzAsMiw0LDUsNyw5LDExXTt0aGlzLnJlc3RhcnQ9e2xpbmU6MCxzdGFmZjowLHZvaWNlOjAscG9zOjB9O3RoaXMudmlzaXRlZD17fTt0aGlzLm11bHRpcGxpZXI9MTt0aGlzLm5leHQ9bnVsbDt0aGlzLnFwbT1oLnFwbXx8MTgwO3RoaXMucHJvZ3JhbT1oLnByb2dyYW18fDI7dGhpcy5ub3RlT25BbmRDaGFubmVsPVwiJTkwXCI7dGhpcy5qYXZhbWlkaT1oLnR5cGU9PT1cImphdmFcInx8ZmFsc2U7dGhpcy5saXN0ZW5lcnM9W107dGhpcy50cmFuc3Bvc2U9MDtpZih0aGlzLmphdmFtaWRpKXtNSURJUGx1Z2luPWRvY3VtZW50Lk1JRElQbHVnaW47c2V0VGltZW91dChmdW5jdGlvbigpe3RyeXtNSURJUGx1Z2luLm9wZW5QbHVnaW4oKX1jYXRjaChrKXt2YXIgaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtqLmhyZWY9XCJodHRwOi8vamF2YS5zdW4uY29tL3Byb2R1Y3RzL2phdmEtbWVkaWEvc291bmQvc291bmRiYW5rcy5odG1sXCI7ai50YXJnZXQ9XCJfYmxhbmtcIjtqLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiRG93bmxvYWQgU291bmRiYW5rXCIpKTtpLmFwcGVuZENoaWxkKGopfX0sMCl9fTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyPWZ1bmN0aW9uKGgpe3RoaXMubGlzdGVuZXJzLnB1c2goaCl9O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUubm90aWZ5U2VsZWN0PWZ1bmN0aW9uKGope2Zvcih2YXIgaD0wO2g8dGhpcy5saXN0ZW5lcnMubGVuZ3RoO2grKyl7dGhpcy5saXN0ZW5lcnNbaF0ubm90aWZ5U2VsZWN0KGouYWJzZWxlbSl9fTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLmdldE1hcms9ZnVuY3Rpb24oKXtyZXR1cm57bGluZTp0aGlzLmxpbmUsc3RhZmY6dGhpcy5zdGFmZix2b2ljZTp0aGlzLnZvaWNlLHBvczp0aGlzLnBvc319O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuZ2V0TWFya1N0cmluZz1mdW5jdGlvbihoKXtoPWh8fHRoaXM7cmV0dXJuXCJsaW5lXCIraC5saW5lK1wic3RhZmZcIitoLnN0YWZmK1widm9pY2VcIitoLnZvaWNlK1wicG9zXCIraC5wb3N9O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuZ29Ub01hcms9ZnVuY3Rpb24oaCl7dGhpcy5saW5lPWgubGluZTt0aGlzLnN0YWZmPWguc3RhZmY7dGhpcy52b2ljZT1oLnZvaWNlO3RoaXMucG9zPWgucG9zfTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLm1hcmtWaXNpdGVkPWZ1bmN0aW9uKCl7dGhpcy5sYXN0bWFyaz10aGlzLmdldE1hcmtTdHJpbmcoKTt0aGlzLnZpc2l0ZWRbdGhpcy5sYXN0bWFya109dHJ1ZX07QUJDSlMubWlkaS5NaWRpV3JpdGVyLnByb3RvdHlwZS5pc1Zpc2l0ZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLnZpc2l0ZWRbdGhpcy5nZXRNYXJrU3RyaW5nKCldKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuc2V0SnVtcE1hcms9ZnVuY3Rpb24oaCl7dGhpcy52aXNpdGVkW3RoaXMubGFzdG1hcmtdPWh9O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuZ2V0SnVtcE1hcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aXNpdGVkW3RoaXMuZ2V0TWFya1N0cmluZygpXX07QUJDSlMubWlkaS5NaWRpV3JpdGVyLnByb3RvdHlwZS5nZXRMaW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWJjdHVuZS5saW5lc1t0aGlzLmxpbmVdfTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLmdldFN0YWZmPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiB0aGlzLmdldExpbmUoKS5zdGFmZlt0aGlzLnN0YWZmXX1jYXRjaChoKXt9fTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLmdldFZvaWNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U3RhZmYoKS52b2ljZXNbdGhpcy52b2ljZV19O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuZ2V0RWxlbT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFZvaWNlKClbdGhpcy5wb3NdfTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLndyaXRlQUJDPWZ1bmN0aW9uKGwpe3RyeXt0aGlzLm1pZGk9KHRoaXMuamF2YW1pZGkpP25ldyBnKG5ldyBiKHRoaXMpLG5ldyBkKCkpOm5ldyBkKCk7dGhpcy5iYXJhY2NpZGVudGFscz1bXTt0aGlzLmFiY3R1bmU9bDt0aGlzLmJhc2VkdXJhdGlvbj00ODAqNDtpZihsLmZvcm1hdHRpbmcubWlkaSYmbC5mb3JtYXR0aW5nLm1pZGkudHJhbnNwb3NlKXt0aGlzLnRyYW5zcG9zZT1sLmZvcm1hdHRpbmcubWlkaS50cmFuc3Bvc2V9aWYobC5mb3JtYXR0aW5nLm1pZGkmJmwuZm9ybWF0dGluZy5taWRpLnByb2dyYW0mJmwuZm9ybWF0dGluZy5taWRpLnByb2dyYW0ucHJvZ3JhbSl7dGhpcy5taWRpLnNldEluc3RydW1lbnQobC5mb3JtYXR0aW5nLm1pZGkucHJvZ3JhbS5wcm9ncmFtKX1lbHNle3RoaXMubWlkaS5zZXRJbnN0cnVtZW50KHRoaXMucHJvZ3JhbSl9aWYobC5mb3JtYXR0aW5nLm1pZGkmJmwuZm9ybWF0dGluZy5taWRpLmNoYW5uZWwpe3RoaXMubWlkaS5zZXRDaGFubmVsKGwuZm9ybWF0dGluZy5taWRpLmNoYW5uZWwpfWlmKGwubWV0YVRleHQudGVtcG8pe3ZhciBrPTEvNDtpZihsLm1ldGFUZXh0LnRlbXBvLmR1cmF0aW9uKXtrPWwubWV0YVRleHQudGVtcG8uZHVyYXRpb25bMF19dmFyIGo9NjA7aWYobC5tZXRhVGV4dC50ZW1wby5icG0pe2o9bC5tZXRhVGV4dC50ZW1wby5icG19dGhpcy5xcG09aiprKjR9dGhpcy5taWRpLnNldFRlbXBvKHRoaXMucXBtKTt0aGlzLnN0YWZmY291bnQ9MTtmb3IodGhpcy5zdGFmZj0wO3RoaXMuc3RhZmY8dGhpcy5zdGFmZmNvdW50O3RoaXMuc3RhZmYrKyl7dGhpcy52b2ljZWNvdW50PTE7Zm9yKHRoaXMudm9pY2U9MDt0aGlzLnZvaWNlPHRoaXMudm9pY2Vjb3VudDt0aGlzLnZvaWNlKyspe3RoaXMubWlkaS5zdGFydFRyYWNrKCk7dGhpcy5yZXN0YXJ0PXtsaW5lOjAsc3RhZmY6dGhpcy5zdGFmZix2b2ljZTp0aGlzLnZvaWNlLHBvczowfTt0aGlzLm5leHQ9bnVsbDtmb3IodGhpcy5saW5lPTA7dGhpcy5saW5lPGwubGluZXMubGVuZ3RoO3RoaXMubGluZSsrKXt2YXIgaD1sLmxpbmVzW3RoaXMubGluZV07aWYodGhpcy5nZXRMaW5lKCkuc3RhZmYpe3RoaXMud3JpdGVBQkNMaW5lKCl9fXRoaXMubWlkaS5lbmRUcmFjaygpfX10aGlzLm1pZGkuZW1iZWQodGhpcy5wYXJlbnQpfWNhdGNoKGkpe3RoaXMucGFyZW50LmlubmVySFRNTD1cIkNvdWxkbid0IHdyaXRlIG1pZGk6IFwiK2l9fTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLndyaXRlQUJDTGluZT1mdW5jdGlvbigpe3RoaXMuc3RhZmZjb3VudD10aGlzLmdldExpbmUoKS5zdGFmZi5sZW5ndGg7dGhpcy52b2ljZWNvdW50PXRoaXMuZ2V0U3RhZmYoKS52b2ljZXMubGVuZ3RoO3RoaXMuc2V0S2V5U2lnbmF0dXJlKHRoaXMuZ2V0U3RhZmYoKS5rZXkpO3RoaXMud3JpdGVBQkNWb2ljZUxpbmUoKX07QUJDSlMubWlkaS5NaWRpV3JpdGVyLnByb3RvdHlwZS53cml0ZUFCQ1ZvaWNlTGluZT1mdW5jdGlvbigpe3RoaXMucG9zPTA7d2hpbGUodGhpcy5wb3M8dGhpcy5nZXRWb2ljZSgpLmxlbmd0aCl7dGhpcy53cml0ZUFCQ0VsZW1lbnQodGhpcy5nZXRFbGVtKCkpO2lmKHRoaXMubmV4dCl7dGhpcy5nb1RvTWFyayh0aGlzLm5leHQpO3RoaXMubmV4dD1udWxsO2lmKCF0aGlzLmdldExpbmUoKS5zdGFmZil7cmV0dXJufX1lbHNle3RoaXMucG9zKyt9fX07QUJDSlMubWlkaS5NaWRpV3JpdGVyLnByb3RvdHlwZS53cml0ZUFCQ0VsZW1lbnQ9ZnVuY3Rpb24oaCl7dmFyIGk7c3dpdGNoKGguZWxfdHlwZSl7Y2FzZVwibm90ZVwiOnRoaXMud3JpdGVOb3RlKGgpO2JyZWFrO2Nhc2VcImtleVwiOnRoaXMuc2V0S2V5U2lnbmF0dXJlKGgpO2JyZWFrO2Nhc2VcImJhclwiOnRoaXMuaGFuZGxlQmFyKGgpO2JyZWFrO2Nhc2VcIm1ldGVyXCI6Y2FzZVwiY2xlZlwiOmJyZWFrO2RlZmF1bHQ6fX07QUJDSlMubWlkaS5NaWRpV3JpdGVyLnByb3RvdHlwZS53cml0ZU5vdGU9ZnVuY3Rpb24obSl7aWYobS5zdGFydFRyaXBsZXQpe2lmKG0uc3RhcnRUcmlwbGV0PT09Mil7dGhpcy5tdWx0aXBsaWVyPTMvMn1lbHNle3RoaXMubXVsdGlwbGllcj0obS5zdGFydFRyaXBsZXQtMSkvbS5zdGFydFRyaXBsZXR9fXZhciBoPW0uZHVyYXRpb24qdGhpcy5iYXNlZHVyYXRpb24qdGhpcy5tdWx0aXBsaWVyO2lmKG0ucGl0Y2hlcyl7dmFyIGw9W107Zm9yKHZhciBqPTA7ajxtLnBpdGNoZXMubGVuZ3RoO2orKyl7dmFyIGs9bS5waXRjaGVzW2pdO3ZhciBuPWsucGl0Y2g7aWYoay5hY2NpZGVudGFsKXtzd2l0Y2goay5hY2NpZGVudGFsKXtjYXNlXCJzaGFycFwiOnRoaXMuYmFyYWNjaWRlbnRhbHNbbl09MTticmVhaztjYXNlXCJmbGF0XCI6dGhpcy5iYXJhY2NpZGVudGFsc1tuXT0tMTticmVhaztjYXNlXCJuYXR1cmFsXCI6dGhpcy5iYXJhY2NpZGVudGFsc1tuXT0wO2JyZWFrO2Nhc2VcImRibHNoYXJwXCI6dGhpcy5iYXJhY2NpZGVudGFsc1tuXT0yO1xuYnJlYWs7Y2FzZVwiZGJsZmxhdFwiOnRoaXMuYmFyYWNjaWRlbnRhbHNbbl09LTI7YnJlYWt9fWxbal09NjArMTIqdGhpcy5leHRyYWN0T2N0YXZlKG4pK3RoaXMuc2NhbGVbdGhpcy5leHRyYWN0Tm90ZShuKV07aWYodGhpcy5iYXJhY2NpZGVudGFsc1tuXSE9PXVuZGVmaW5lZCl7bFtqXSs9dGhpcy5iYXJhY2NpZGVudGFsc1tuXX1lbHNle2xbal0rPXRoaXMuYWNjaWRlbnRhbHNbdGhpcy5leHRyYWN0Tm90ZShuKV19bFtqXSs9dGhpcy50cmFuc3Bvc2U7dGhpcy5taWRpLnN0YXJ0Tm90ZShsW2pdLDY0LG0pO2lmKGsuc3RhcnRUaWUpe3RoaXMudGllZHVyYXRpb249aH19Zm9yKGo9MDtqPG0ucGl0Y2hlcy5sZW5ndGg7aisrKXt2YXIgaz1tLnBpdGNoZXNbal07dmFyIG49ay5waXRjaCt0aGlzLnRyYW5zcG9zZTtpZihrLnN0YXJ0VGllKXtjb250aW51ZX1pZihrLmVuZFRpZSl7dGhpcy5taWRpLmVuZE5vdGUobFtqXSxoK3RoaXMudGllZHVyYXRpb24pfWVsc2V7dGhpcy5taWRpLmVuZE5vdGUobFtqXSxoKX1oPTA7dGhpcy50aWVkdXJhdGlvbj0wfX1lbHNle2lmKG0ucmVzdCYmbS5yZXN0LnR5cGUhPT1cInNwYWNlclwiKXt0aGlzLm1pZGkuYWRkUmVzdChoKX19aWYobS5lbmRUcmlwbGV0KXt0aGlzLm11bHRpcGxpZXI9MX19O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuaGFuZGxlQmFyPWZ1bmN0aW9uKGwpe3RoaXMuYmFyYWNjaWRlbnRhbHM9W107dmFyIG09KGwudHlwZT09PVwiYmFyX3JpZ2h0X3JlcGVhdFwifHxsLnR5cGU9PT1cImJhcl9kYmxfcmVwZWF0XCIpO3ZhciBrPShsLnN0YXJ0RW5kaW5nKT90cnVlOmZhbHNlO3ZhciBoPShtfHxrKTt2YXIgaj0obC50eXBlPT09XCJiYXJfbGVmdF9yZXBlYXRcInx8bC50eXBlPT09XCJiYXJfZGJsX3JlcGVhdFwifHxsLnR5cGU9PT1cImJhcl90aGlja190aGluXCJ8fGwudHlwZT09PVwiYmFyX3RoaW5fdGhpY2tcInx8bC50eXBlPT09XCJiYXJfdGhpbl90aGluXCJ8fGwudHlwZT09PVwiYmFyX3JpZ2h0X3JlcGVhdFwiKTt2YXIgaT1udWxsO2lmKHRoaXMuaXNWaXNpdGVkKCkpe2k9dGhpcy5nZXRKdW1wTWFyaygpfWVsc2V7aWYoa3x8bSl7aWYodGhpcy52aXNpdGVkW3RoaXMubGFzdG1hcmtdPT09dHJ1ZSl7dGhpcy5zZXRKdW1wTWFyayh0aGlzLmdldE1hcmsoKSl9fWlmKGgpe3RoaXMubWFya1Zpc2l0ZWQoKX1pZihtKXtpPXRoaXMucmVzdGFydDt0aGlzLnNldEp1bXBNYXJrKHRoaXMuZ2V0TWFyaygpKX19aWYoail7dGhpcy5yZXN0YXJ0PXRoaXMuZ2V0TWFyaygpfWlmKGkmJnRoaXMuZ2V0TWFya1N0cmluZyhpKSE9PXRoaXMuZ2V0TWFya1N0cmluZygpKXt0aGlzLm5leHQ9aX19O0FCQ0pTLm1pZGkuTWlkaVdyaXRlci5wcm90b3R5cGUuc2V0S2V5U2lnbmF0dXJlPWZ1bmN0aW9uKGgpe3RoaXMuYWNjaWRlbnRhbHM9WzAsMCwwLDAsMCwwLDBdO2lmKHRoaXMuYWJjdHVuZS5mb3JtYXR0aW5nLmJhZ3BpcGVzKXtoLmFjY2lkZW50YWxzPVt7YWNjOlwibmF0dXJhbFwiLG5vdGU6XCJnXCJ9LHthY2M6XCJzaGFycFwiLG5vdGU6XCJmXCJ9LHthY2M6XCJzaGFycFwiLG5vdGU6XCJjXCJ9XX1pZighaC5hY2NpZGVudGFscyl7cmV0dXJufXdpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKGguYWNjaWRlbnRhbHMsZnVuY3Rpb24oayl7dmFyIGw9KGsuYWNjPT09XCJzaGFycFwiKT8xOihrLmFjYz09PVwibmF0dXJhbFwiKT8wOi0xO3ZhciBqPWsubm90ZS50b0xvd2VyQ2FzZSgpO3ZhciBpPXRoaXMuZXh0cmFjdE5vdGUoai5jaGFyQ29kZUF0KDApLVwiY1wiLmNoYXJDb2RlQXQoMCkpO3RoaXMuYWNjaWRlbnRhbHNbaV0rPWx9LHRoaXMpfTtBQkNKUy5taWRpLk1pZGlXcml0ZXIucHJvdG90eXBlLmV4dHJhY3ROb3RlPWZ1bmN0aW9uKGgpe2g9aCU3O2lmKGg8MCl7aCs9N31yZXR1cm4gaH07QUJDSlMubWlkaS5NaWRpV3JpdGVyLnByb3RvdHlwZS5leHRyYWN0T2N0YXZlPWZ1bmN0aW9uKGgpe3JldHVybiBNYXRoLmZsb29yKGgvNyl9fSkoKTtpZighd2luZG93LkFCQ0pTKXt3aW5kb3cuQUJDSlM9e319aWYoIXdpbmRvdy5BQkNKUy5wYXJzZSl7d2luZG93LkFCQ0pTLnBhcnNlPXt9fXdpbmRvdy5BQkNKUy5wYXJzZS5jbG9uZT1mdW5jdGlvbihjKXt2YXIgYT17fTtmb3IodmFyIGIgaW4gYyl7aWYoYy5oYXNPd25Qcm9wZXJ0eShiKSl7YVtiXT1jW2JdfX1yZXR1cm4gYX07d2luZG93LkFCQ0pTLnBhcnNlLmdzdWI9ZnVuY3Rpb24oYyxiLGEpe3JldHVybiBjLnNwbGl0KGIpLmpvaW4oYSl9O3dpbmRvdy5BQkNKUy5wYXJzZS5zdHJpcD1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC9eXFxzKy8sXCJcIikucmVwbGFjZSgvXFxzKyQvLFwiXCIpfTt3aW5kb3cuQUJDSlMucGFyc2Uuc3RhcnRzV2l0aD1mdW5jdGlvbihiLGEpe3JldHVybiBiLmluZGV4T2YoYSk9PT0wfTt3aW5kb3cuQUJDSlMucGFyc2UuZW5kc1dpdGg9ZnVuY3Rpb24oYyxhKXt2YXIgYj1jLmxlbmd0aC1hLmxlbmd0aDtyZXR1cm4gYj49MCYmYy5sYXN0SW5kZXhPZihhKT09PWJ9O3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoPWZ1bmN0aW9uKGEsZCxjKXtmb3IodmFyIGI9MCxlPWEubGVuZ3RoO2I8ZTtiKyspe2QuYXBwbHkoYyxbYVtiXSxiXSl9fTt3aW5kb3cuQUJDSlMucGFyc2UubGFzdD1mdW5jdGlvbihhKXtpZihhLmxlbmd0aD09PTApe3JldHVybiBudWxsfXJldHVybiBhW2EubGVuZ3RoLTFdfTt3aW5kb3cuQUJDSlMucGFyc2UuY29tcGFjdD1mdW5jdGlvbihhKXt2YXIgYj1bXTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7aWYoYVtjXSl7Yi5wdXNoKGFbY10pfX1yZXR1cm4gYn07d2luZG93LkFCQ0pTLnBhcnNlLmRldGVjdD1mdW5jdGlvbihhLGMpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXtpZihjKGFbYl0pKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTtpZighd2luZG93LkFCQ0pTKXt3aW5kb3cuQUJDSlM9e319aWYoIXdpbmRvdy5BQkNKUy5wYXJzZSl7d2luZG93LkFCQ0pTLnBhcnNlPXt9fXdpbmRvdy5BQkNKUy5wYXJzZS5QYXJzZT1mdW5jdGlvbigpe3ZhciBmPW5ldyB3aW5kb3cuQUJDSlMuZGF0YS5UdW5lKCk7dmFyIG49bmV3IHdpbmRvdy5BQkNKUy5wYXJzZS50b2tlbml6ZXIoKTt0aGlzLmdldFR1bmU9ZnVuY3Rpb24oKXtyZXR1cm4gZn07dmFyIHk9e3Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBBIGluIHRoaXMpe2lmKHRoaXMuaGFzT3duUHJvcGVydHkoQSkmJnR5cGVvZiB0aGlzW0FdIT09XCJmdW5jdGlvblwiKXtkZWxldGUgdGhpc1tBXX19dGhpcy5pQ2hhcj0wO3RoaXMua2V5PXthY2NpZGVudGFsczpbXSxyb290Olwibm9uZVwiLGFjYzpcIlwiLG1vZGU6XCJcIn07dGhpcy5tZXRlcj17dHlwZTpcInNwZWNpZmllZFwiLHZhbHVlOlt7bnVtOlwiNFwiLGRlbjpcIjRcIn1dfTt0aGlzLm9yaWdNZXRlcj17dHlwZTpcInNwZWNpZmllZFwiLHZhbHVlOlt7bnVtOlwiNFwiLGRlbjpcIjRcIn1dfTt0aGlzLmhhc01haW5UaXRsZT1mYWxzZTt0aGlzLmRlZmF1bHRfbGVuZ3RoPTAuMTI1O3RoaXMuY2xlZj17dHlwZTpcInRyZWJsZVwiLHZlcnRpY2FsUG9zOjB9O3RoaXMubmV4dF9ub3RlX2R1cmF0aW9uPTA7dGhpcy5zdGFydF9uZXdfbGluZT10cnVlO3RoaXMuaXNfaW5faGVhZGVyPXRydWU7dGhpcy5pc19pbl9oaXN0b3J5PWZhbHNlO3RoaXMucGFydEZvck5leHRMaW5lPVwiXCI7dGhpcy5oYXZlbnRfc2V0X2xlbmd0aD10cnVlO3RoaXMudm9pY2VzPXt9O3RoaXMuc3RhdmVzPVtdO3RoaXMubWFjcm9zPXt9O3RoaXMuY3VyckJhck51bWJlcj0xO3RoaXMuaW5UZXh0QmxvY2s9ZmFsc2U7dGhpcy5pblBzQmxvY2s9ZmFsc2U7dGhpcy5pZ25vcmVkRGVjb3JhdGlvbnM9W107dGhpcy50ZXh0QmxvY2s9XCJcIjt0aGlzLnNjb3JlX2lzX3ByZXNlbnQ9ZmFsc2U7dGhpcy5pbkVuZGluZz1mYWxzZTt0aGlzLmluVGllPWZhbHNlO3RoaXMuaW5UaWVDaG9yZD17fX19O3ZhciB6PWZ1bmN0aW9uKEEpe2lmKCF5Lndhcm5pbmdzKXt5Lndhcm5pbmdzPVtdfXkud2FybmluZ3MucHVzaChBKX07dmFyIGM9ZnVuY3Rpb24oQil7dmFyIEE9d2luZG93LkFCQ0pTLnBhcnNlLmdzdWIoQixcIlxceDEyXCIsXCIgXCIpO0E9d2luZG93LkFCQ0pTLnBhcnNlLmdzdWIoQSxcIiZcIixcIiZhbXA7XCIpO0E9d2luZG93LkFCQ0pTLnBhcnNlLmdzdWIoQSxcIjxcIixcIiZsdDtcIik7cmV0dXJuIHdpbmRvdy5BQkNKUy5wYXJzZS5nc3ViKEEsXCI+XCIsXCImZ3Q7XCIpfTt2YXIgeD1mdW5jdGlvbihFLEEsRCl7dmFyIEM9QS5jaGFyQXQoRCk7aWYoQz09PVwiIFwiKXtDPVwiU1BBQ0VcIn12YXIgQj1jKEEuc3Vic3RyaW5nKDAsRCkpKyc8c3BhbiBzdHlsZT1cInRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Zm9udC1zaXplOjEuM2VtO2ZvbnQtd2VpZ2h0OmJvbGQ7XCI+JytDK1wiPC9zcGFuPlwiK2MoQS5zdWJzdHJpbmcoRCsxKSk7eihcIk11c2ljIExpbmU6XCIrZi5nZXROdW1MaW5lcygpK1wiOlwiKyhEKzEpK1wiOiBcIitFK1wiOiAgXCIrQil9O3ZhciB1PW5ldyB3aW5kb3cuQUJDSlMucGFyc2UuUGFyc2VIZWFkZXIobix4LHksZik7dGhpcy5nZXRXYXJuaW5ncz1mdW5jdGlvbigpe3JldHVybiB5Lndhcm5pbmdzfTt2YXIgdD1mdW5jdGlvbihDLEQpe2lmKEMuY2hhckF0KEQpPT09J1wiJyl7dmFyIEU9bi5nZXRCcmFja2V0dGVkU3Vic3RyaW5nKEMsRCw1KTtpZighRVsyXSl7eChcIk1pc3NpbmcgdGhlIGNsb3NpbmcgcXVvdGUgd2hpbGUgcGFyc2luZyB0aGUgY2hvcmQgc3ltYm9sXCIsQyxEKX1pZihFWzBdPjAmJkVbMV0ubGVuZ3RoPjAmJkVbMV0uY2hhckF0KDApPT09XCJeXCIpe0VbMV09RVsxXS5zdWJzdHJpbmcoMSk7RVsyXT1cImFib3ZlXCJ9ZWxzZXtpZihFWzBdPjAmJkVbMV0ubGVuZ3RoPjAmJkVbMV0uY2hhckF0KDApPT09XCJfXCIpe0VbMV09RVsxXS5zdWJzdHJpbmcoMSk7RVsyXT1cImJlbG93XCJ9ZWxzZXtpZihFWzBdPjAmJkVbMV0ubGVuZ3RoPjAmJkVbMV0uY2hhckF0KDApPT09XCI8XCIpe0VbMV09RVsxXS5zdWJzdHJpbmcoMSk7RVsyXT1cImxlZnRcIn1lbHNle2lmKEVbMF0+MCYmRVsxXS5sZW5ndGg+MCYmRVsxXS5jaGFyQXQoMCk9PT1cIj5cIil7RVsxXT1FWzFdLnN1YnN0cmluZygxKTtFWzJdPVwicmlnaHRcIn1lbHNle2lmKEVbMF0+MCYmRVsxXS5sZW5ndGg+MCYmRVsxXS5jaGFyQXQoMCk9PT1cIkBcIil7RVsxXT1FWzFdLnN1YnN0cmluZygxKTt2YXIgQT1uLmdldEZsb2F0KEVbMV0pO2lmKEEuZGlnaXRzPT09MCl7eChcIk1pc3NpbmcgZmlyc3QgcG9zaXRpb24gaW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGFubm90YXRpb24uXCIsQyxEKX1FWzFdPUVbMV0uc3Vic3RyaW5nKEEuZGlnaXRzKTtpZihFWzFdWzBdIT09XCIsXCIpe3goXCJNaXNzaW5nIGNvbW1hIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbm5vdGF0aW9uLlwiLEMsRCl9RVsxXT1FWzFdLnN1YnN0cmluZygxKTt2YXIgRj1uLmdldEZsb2F0KEVbMV0pO2lmKEYuZGlnaXRzPT09MCl7eChcIk1pc3Npbmcgc2Vjb25kIHBvc2l0aW9uIGluIGFic29sdXRlbHkgcG9zaXRpb25lZCBhbm5vdGF0aW9uLlwiLEMsRCl9RVsxXT1FWzFdLnN1YnN0cmluZyhGLmRpZ2l0cyk7dmFyIEI9bi5za2lwV2hpdGVTcGFjZShFWzFdKTtFWzFdPUVbMV0uc3Vic3RyaW5nKEIpO0VbMl09bnVsbDtFWzNdPXt4OkEudmFsdWUseTpGLnZhbHVlfX1lbHNle0VbMV09RVsxXS5yZXBsYWNlKC8oW0FCQ0RFRkddKWIvZyxcIiQx4pmtXCIpO0VbMV09RVsxXS5yZXBsYWNlKC8oW0FCQ0RFRkddKSMvZyxcIiQx4pmvXCIpO0VbMl09XCJkZWZhdWx0XCJ9fX19fXJldHVybiBFfXJldHVyblswLFwiXCJdfTt2YXIgcD1bXCJ0cmlsbFwiLFwibG93ZXJtb3JkZW50XCIsXCJ1cHBlcm1vcmRlbnRcIixcIm1vcmRlbnRcIixcInByYWxsdHJpbGxlclwiLFwiYWNjZW50XCIsXCJmZXJtYXRhXCIsXCJpbnZlcnRlZGZlcm1hdGFcIixcInRlbnV0b1wiLFwiMFwiLFwiMVwiLFwiMlwiLFwiM1wiLFwiNFwiLFwiNVwiLFwiK1wiLFwid2VkZ2VcIixcIm9wZW5cIixcInRodW1iXCIsXCJzbmFwXCIsXCJ0dXJuXCIsXCJyb2xsXCIsXCJicmVhdGhcIixcInNob3J0cGhyYXNlXCIsXCJtZWRpdW1waHJhc2VcIixcImxvbmdwaHJhc2VcIixcInNlZ25vXCIsXCJjb2RhXCIsXCJELlMuXCIsXCJELkMuXCIsXCJmaW5lXCIsXCJjcmVzY2VuZG8oXCIsXCJjcmVzY2VuZG8pXCIsXCJkaW1pbnVlbmRvKFwiLFwiZGltaW51ZW5kbylcIixcInBcIixcInBwXCIsXCJmXCIsXCJmZlwiLFwibWZcIixcIm1wXCIsXCJwcHBcIixcInBwcHBcIixcImZmZlwiLFwiZmZmZlwiLFwic2Z6XCIsXCJyZXBlYXRiYXJcIixcInJlcGVhdGJhcjJcIixcInNsaWRlXCIsXCJ1cGJvd1wiLFwiZG93bmJvd1wiLFwiL1wiLFwiLy9cIixcIi8vL1wiLFwiLy8vL1wiLFwidHJlbTFcIixcInRyZW0yXCIsXCJ0cmVtM1wiLFwidHJlbTRcIixcInR1cm54XCIsXCJpbnZlcnRlZHR1cm5cIixcImludmVydGVkdHVybnhcIixcInRyaWxsKFwiLFwidHJpbGwpXCIsXCJhcnBlZ2dpb1wiLFwieHN0ZW1cIixcIm1hcmtcIixcInVtYXJjYXRvXCIsXCJzdHlsZT1ub3JtYWxcIixcInN0eWxlPWhhcm1vbmljXCIsXCJzdHlsZT1yaHl0aG1cIixcInN0eWxlPXhcIl07dmFyIHM9W1tcIjxcIixcImFjY2VudFwiXSxbXCI+XCIsXCJhY2NlbnRcIl0sW1widHJcIixcInRyaWxsXCJdLFtcIjwoXCIsXCJjcmVzY2VuZG8oXCJdLFtcIjwpXCIsXCJjcmVzY2VuZG8pXCJdLFtcIj4oXCIsXCJkaW1pbnVlbmRvKFwiXSxbXCI+KVwiLFwiZGltaW51ZW5kbylcIl0sW1wicGx1c1wiLFwiK1wiXSxbXCJlbXBoYXNpc1wiLFwiYWNjZW50XCJdXTt2YXIgaD1mdW5jdGlvbihBLEMpe3ZhciBEPXkubWFjcm9zW0EuY2hhckF0KEMpXTtpZihEIT09dW5kZWZpbmVkKXtpZihELmNoYXJBdCgwKT09PVwiIVwifHxELmNoYXJBdCgwKT09PVwiK1wiKXtEPUQuc3Vic3RyaW5nKDEpfWlmKEQuY2hhckF0KEQubGVuZ3RoLTEpPT09XCIhXCJ8fEQuY2hhckF0KEQubGVuZ3RoLTEpPT09XCIrXCIpe0Q9RC5zdWJzdHJpbmcoMCxELmxlbmd0aC0xKX1pZih3aW5kb3cuQUJDSlMucGFyc2UuZGV0ZWN0KHAsZnVuY3Rpb24oRSl7cmV0dXJuKEQ9PT1FKX0pKXtyZXR1cm5bMSxEXX1lbHNle2lmKCF3aW5kb3cuQUJDSlMucGFyc2UuZGV0ZWN0KHkuaWdub3JlZERlY29yYXRpb25zLGZ1bmN0aW9uKEUpe3JldHVybihEPT09RSl9KSl7eChcIlVua25vd24gbWFjcm86IFwiK0QsQSxDKX1yZXR1cm5bMSxcIlwiXX19c3dpdGNoKEEuY2hhckF0KEMpKXtjYXNlXCIuXCI6cmV0dXJuWzEsXCJzdGFjY2F0b1wiXTtjYXNlXCJ1XCI6cmV0dXJuWzEsXCJ1cGJvd1wiXTtjYXNlXCJ2XCI6cmV0dXJuWzEsXCJkb3duYm93XCJdO2Nhc2VcIn5cIjpyZXR1cm5bMSxcImlyaXNocm9sbFwiXTtcbmNhc2VcIiFcIjpjYXNlXCIrXCI6dmFyIEI9bi5nZXRCcmFja2V0dGVkU3Vic3RyaW5nKEEsQyw1KTtpZihCWzFdLmxlbmd0aD4wJiYoQlsxXS5jaGFyQXQoMCk9PT1cIl5cInx8QlsxXS5jaGFyQXQoMCk9PT1cIl9cIikpe0JbMV09QlsxXS5zdWJzdHJpbmcoMSl9aWYod2luZG93LkFCQ0pTLnBhcnNlLmRldGVjdChwLGZ1bmN0aW9uKEUpe3JldHVybihCWzFdPT09RSl9KSl7cmV0dXJuIEJ9aWYod2luZG93LkFCQ0pTLnBhcnNlLmRldGVjdChzLGZ1bmN0aW9uKEUpe2lmKEJbMV09PT1FWzBdKXtCWzFdPUVbMV07cmV0dXJuIHRydWV9ZWxzZXtyZXR1cm4gZmFsc2V9fSkpe3JldHVybiBCfWlmKEEuY2hhckF0KEMpPT09XCIhXCImJihCWzBdPT09MXx8QS5jaGFyQXQoQytCWzBdLTEpIT09XCIhXCIpKXtyZXR1cm5bMSxudWxsXX14KFwiVW5rbm93biBkZWNvcmF0aW9uOiBcIitCWzFdLEEsQyk7QlsxXT1cIlwiO3JldHVybiBCO2Nhc2VcIkhcIjpyZXR1cm5bMSxcImZlcm1hdGFcIl07Y2FzZVwiSlwiOnJldHVyblsxLFwic2xpZGVcIl07Y2FzZVwiTFwiOnJldHVyblsxLFwiYWNjZW50XCJdO2Nhc2VcIk1cIjpyZXR1cm5bMSxcIm1vcmRlbnRcIl07Y2FzZVwiT1wiOnJldHVyblsxLFwiY29kYVwiXTtjYXNlXCJQXCI6cmV0dXJuWzEsXCJwcmFsbHRyaWxsZXJcIl07Y2FzZVwiUlwiOnJldHVyblsxLFwicm9sbFwiXTtjYXNlXCJTXCI6cmV0dXJuWzEsXCJzZWdub1wiXTtjYXNlXCJUXCI6cmV0dXJuWzEsXCJ0cmlsbFwiXX1yZXR1cm5bMCwwXX07dmFyIGU9ZnVuY3Rpb24oQSxCKXt2YXIgQz1CO3doaWxlKG4uaXNXaGl0ZVNwYWNlKEEuY2hhckF0KEIpKSl7QisrfXJldHVybltCLUNdfTt2YXIgcj1mdW5jdGlvbihDLEYpe3ZhciBEPW4uZ2V0QmFyTGluZShDLEYpO2lmKEQubGVuPT09MCl7cmV0dXJuWzAsXCJcIl19aWYoRC53YXJuKXt4KEQud2FybixDLEYpO3JldHVybltELmxlbixcIlwiXX1mb3IodmFyIEI9MDtCPEMubGVuZ3RoO0IrKyl7aWYoQy5jaGFyQXQoRitELmxlbitCKSE9PVwiIFwiKXticmVha319dmFyIEc9RC5sZW47aWYoQy5jaGFyQXQoRitELmxlbitCKT09PVwiW1wiKXtELmxlbis9QisxfWlmKEMuY2hhckF0KEYrRC5sZW4pPT09J1wiJyYmQy5jaGFyQXQoRitELmxlbi0xKT09PVwiW1wiKXt2YXIgQT1uLmdldEJyYWNrZXR0ZWRTdWJzdHJpbmcoQyxGK0QubGVuLDUpO3JldHVybltELmxlbitBWzBdLEQudG9rZW4sQVsxXV19dmFyIEU9bi5nZXRUb2tlbk9mKEMuc3Vic3RyaW5nKEYrRC5sZW4pLFwiMTIzNDU2Nzg5MC0sXCIpO2lmKEUubGVuPT09MHx8RS50b2tlblswXT09PVwiLVwiKXtyZXR1cm5bRyxELnRva2VuXX1yZXR1cm5bRC5sZW4rRS5sZW4sRC50b2tlbixFLnRva2VuXX07dmFyIG89ZnVuY3Rpb24oQSxDKXt2YXIgQj17fTt2YXIgRD1DO3doaWxlKEEuY2hhckF0KEMpPT09XCIoXCJ8fG4uaXNXaGl0ZVNwYWNlKEEuY2hhckF0KEMpKSl7aWYoQS5jaGFyQXQoQyk9PT1cIihcIil7aWYoQysxPEEubGVuZ3RoJiYoQS5jaGFyQXQoQysxKT49XCIyXCImJkEuY2hhckF0KEMrMSk8PVwiOVwiKSl7aWYoQi50cmlwbGV0IT09dW5kZWZpbmVkKXt4KFwiQ2FuJ3QgbmVzdCB0cmlwbGV0c1wiLEEsQyl9ZWxzZXtCLnRyaXBsZXQ9QS5jaGFyQXQoQysxKS1cIjBcIjtpZihDKzI8QS5sZW5ndGgmJkEuY2hhckF0KEMrMik9PT1cIjpcIil7aWYoQyszPEEubGVuZ3RoJiZBLmNoYXJBdChDKzMpPT09XCI6XCIpe2lmKEMrNDxBLmxlbmd0aCYmKEEuY2hhckF0KEMrNCk+PVwiMVwiJiZBLmNoYXJBdChDKzQpPD1cIjlcIikpe0IubnVtX25vdGVzPUEuY2hhckF0KEMrNCktXCIwXCI7Qys9M31lbHNle3goXCJleHBlY3RlZCBudW1iZXIgYWZ0ZXIgdGhlIHR3byBjb2xvbnMgYWZ0ZXIgdGhlIHRyaXBsZXQgdG8gbWFyayB0aGUgZHVyYXRpb25cIixBLEMpfX1lbHNle2lmKEMrMzxBLmxlbmd0aCYmKEEuY2hhckF0KEMrMyk+PVwiMVwiJiZBLmNoYXJBdChDKzMpPD1cIjlcIikpe2lmKEMrNDxBLmxlbmd0aCYmQS5jaGFyQXQoQys0KT09PVwiOlwiKXtpZihDKzU8QS5sZW5ndGgmJihBLmNoYXJBdChDKzUpPj1cIjFcIiYmQS5jaGFyQXQoQys1KTw9XCI5XCIpKXtCLm51bV9ub3Rlcz1BLmNoYXJBdChDKzUpLVwiMFwiO0MrPTR9fWVsc2V7Qi5udW1fbm90ZXM9Qi50cmlwbGV0O0MrPTN9fWVsc2V7eChcImV4cGVjdGVkIG51bWJlciBhZnRlciB0aGUgdHJpcGxldCB0byBtYXJrIHRoZSBkdXJhdGlvblwiLEEsQyl9fX19QysrfWVsc2V7aWYoQi5zdGFydFNsdXI9PT11bmRlZmluZWQpe0Iuc3RhcnRTbHVyPTF9ZWxzZXtCLnN0YXJ0U2x1cisrfX19QysrfUIuY29uc3VtZWQ9Qy1EO3JldHVybiBCfTt2YXIgbT1mdW5jdGlvbihCLEgpe2lmKCFCKXt4KFwiQ2FuJ3QgYWRkIHdvcmRzIGJlZm9yZSB0aGUgZmlyc3QgbGluZSBvZiBtdWxzaWNcIixCLDApO3JldHVybn1IPXdpbmRvdy5BQkNKUy5wYXJzZS5zdHJpcChIKTtpZihILmNoYXJBdChILmxlbmd0aC0xKSE9PVwiLVwiKXtIPUgrXCIgXCJ9dmFyIEc9W107dmFyIEY9MDt2YXIgRD1mYWxzZTt2YXIgQT1mdW5jdGlvbihJKXt2YXIgSj13aW5kb3cuQUJDSlMucGFyc2Uuc3RyaXAoSC5zdWJzdHJpbmcoRixJKSk7Rj1JKzE7aWYoSi5sZW5ndGg+MCl7aWYoRCl7Sj13aW5kb3cuQUJDSlMucGFyc2UuZ3N1YihKLFwiflwiLFwiIFwiKX12YXIgSz1ILmNoYXJBdChJKTtpZihLIT09XCJfXCImJkshPT1cIi1cIil7Sz1cIiBcIn1HLnB1c2goe3N5bGxhYmxlOm4udHJhbnNsYXRlU3RyaW5nKEopLGRpdmlkZXI6S30pO0Q9ZmFsc2U7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTtmb3IodmFyIEM9MDtDPEgubGVuZ3RoO0MrKyl7c3dpdGNoKEguY2hhckF0KEMpKXtjYXNlXCIgXCI6Y2FzZVwiXFx4MTJcIjpBKEMpO2JyZWFrO2Nhc2VcIi1cIjppZighQShDKSYmRy5sZW5ndGg+MCl7d2luZG93LkFCQ0pTLnBhcnNlLmxhc3QoRykuZGl2aWRlcj1cIi1cIjtHLnB1c2goe3NraXA6dHJ1ZSx0bzpcIm5leHRcIn0pfWJyZWFrO2Nhc2VcIl9cIjpBKEMpO0cucHVzaCh7c2tpcDp0cnVlLHRvOlwic2x1clwifSk7YnJlYWs7Y2FzZVwiKlwiOkEoQyk7Ry5wdXNoKHtza2lwOnRydWUsdG86XCJuZXh0XCJ9KTticmVhaztjYXNlXCJ8XCI6QShDKTtHLnB1c2goe3NraXA6dHJ1ZSx0bzpcImJhclwifSk7YnJlYWs7Y2FzZVwiflwiOkQ9dHJ1ZTticmVha319dmFyIEU9ZmFsc2U7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goQixmdW5jdGlvbihKKXtpZihHLmxlbmd0aCE9PTApe2lmKEdbMF0uc2tpcCl7c3dpdGNoKEdbMF0udG8pe2Nhc2VcIm5leHRcIjppZihKLmVsX3R5cGU9PT1cIm5vdGVcIiYmSi5waXRjaGVzIT09bnVsbCYmIUUpe0cuc2hpZnQoKX1icmVhaztjYXNlXCJzbHVyXCI6aWYoSi5lbF90eXBlPT09XCJub3RlXCImJkoucGl0Y2hlcyE9PW51bGwpe0cuc2hpZnQoKX1icmVhaztjYXNlXCJiYXJcIjppZihKLmVsX3R5cGU9PT1cImJhclwiKXtHLnNoaWZ0KCl9YnJlYWt9fWVsc2V7aWYoSi5lbF90eXBlPT09XCJub3RlXCImJkoucmVzdD09PXVuZGVmaW5lZCYmIUUpe3ZhciBJPUcuc2hpZnQoKTtpZihKLmx5cmljPT09dW5kZWZpbmVkKXtKLmx5cmljPVtJXX1lbHNle0oubHlyaWMucHVzaChJKX19fX19KX07dmFyIGQ9ZnVuY3Rpb24oQixIKXtpZighQil7eChcIkNhbid0IGFkZCBzeW1ib2xzIGJlZm9yZSB0aGUgZmlyc3QgbGluZSBvZiBtdWxzaWNcIixCLDApO3JldHVybn1IPXdpbmRvdy5BQkNKUy5wYXJzZS5zdHJpcChIKTtpZihILmNoYXJBdChILmxlbmd0aC0xKSE9PVwiLVwiKXtIPUgrXCIgXCJ9dmFyIEc9W107dmFyIEY9MDt2YXIgRD1mYWxzZTt2YXIgQT1mdW5jdGlvbihJKXt2YXIgSj13aW5kb3cuQUJDSlMucGFyc2Uuc3RyaXAoSC5zdWJzdHJpbmcoRixJKSk7Rj1JKzE7aWYoSi5sZW5ndGg+MCl7aWYoRCl7Sj13aW5kb3cuQUJDSlMucGFyc2UuZ3N1YihKLFwiflwiLFwiIFwiKX12YXIgSz1ILmNoYXJBdChJKTtpZihLIT09XCJfXCImJkshPT1cIi1cIil7Sz1cIiBcIn1HLnB1c2goe3N5bGxhYmxlOm4udHJhbnNsYXRlU3RyaW5nKEopLGRpdmlkZXI6S30pO0Q9ZmFsc2U7cmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlfTtmb3IodmFyIEM9MDtDPEgubGVuZ3RoO0MrKyl7c3dpdGNoKEguY2hhckF0KEMpKXtjYXNlXCIgXCI6Y2FzZVwiXFx4MTJcIjpBKEMpO2JyZWFrO2Nhc2VcIi1cIjppZighQShDKSYmRy5sZW5ndGg+MCl7d2luZG93LkFCQ0pTLnBhcnNlLmxhc3QoRykuZGl2aWRlcj1cIi1cIjtHLnB1c2goe3NraXA6dHJ1ZSx0bzpcIm5leHRcIn0pfWJyZWFrO2Nhc2VcIl9cIjpBKEMpO0cucHVzaCh7c2tpcDp0cnVlLHRvOlwic2x1clwifSk7YnJlYWs7Y2FzZVwiKlwiOkEoQyk7Ry5wdXNoKHtza2lwOnRydWUsdG86XCJuZXh0XCJ9KTticmVhaztjYXNlXCJ8XCI6QShDKTtHLnB1c2goe3NraXA6dHJ1ZSx0bzpcImJhclwifSk7YnJlYWs7Y2FzZVwiflwiOkQ9dHJ1ZTticmVha319dmFyIEU9ZmFsc2U7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goQixmdW5jdGlvbihKKXtpZihHLmxlbmd0aCE9PTApe2lmKEdbMF0uc2tpcCl7c3dpdGNoKEdbMF0udG8pe2Nhc2VcIm5leHRcIjppZihKLmVsX3R5cGU9PT1cIm5vdGVcIiYmSi5waXRjaGVzIT09bnVsbCYmIUUpe0cuc2hpZnQoKX1icmVhaztjYXNlXCJzbHVyXCI6aWYoSi5lbF90eXBlPT09XCJub3RlXCImJkoucGl0Y2hlcyE9PW51bGwpe0cuc2hpZnQoKX1icmVhaztjYXNlXCJiYXJcIjppZihKLmVsX3R5cGU9PT1cImJhclwiKXtHLnNoaWZ0KCl9YnJlYWt9fWVsc2V7aWYoSi5lbF90eXBlPT09XCJub3RlXCImJkoucmVzdD09PXVuZGVmaW5lZCYmIUUpe3ZhciBJPUcuc2hpZnQoKTtpZihKLmx5cmljPT09dW5kZWZpbmVkKXtKLmx5cmljPVtJXX1lbHNle0oubHlyaWMucHVzaChJKX19fX19KX07dmFyIGI9ZnVuY3Rpb24oQSxCKXtzd2l0Y2goQS5jaGFyQXQoQikpe2Nhc2VcIj5cIjppZihCPEEubGVuZ3RoLTEmJkEuY2hhckF0KEIrMSk9PT1cIj5cIil7cmV0dXJuWzIsMS43NSwwLjI1XX1lbHNle3JldHVyblsxLDEuNSwwLjVdfWJyZWFrO2Nhc2VcIjxcIjppZihCPEEubGVuZ3RoLTEmJkEuY2hhckF0KEIrMSk9PT1cIjxcIil7cmV0dXJuWzIsMC4yNSwxLjc1XX1lbHNle3JldHVyblsxLDAuNSwxLjVdfWJyZWFrfXJldHVybiBudWxsfTt2YXIgZz1mdW5jdGlvbihBKXtpZihBLmR1cmF0aW9uIT09dW5kZWZpbmVkJiZBLmR1cmF0aW9uPDAuMjUpe0EuZW5kX2JlYW09dHJ1ZX1yZXR1cm4gQX07dmFyIGo9e0E6NSxCOjYsQzowLEQ6MSxFOjIsRjozLEc6NCxhOjEyLGI6MTMsYzo3LGQ6OCxlOjksZjoxMCxnOjExfTt2YXIgYT17eDpcImludmlzaWJsZVwiLHk6XCJzcGFjZXJcIix6OlwicmVzdFwiLFo6XCJtdWx0aW1lYXN1cmVcIn07dmFyIGk9ZnVuY3Rpb24oSixHLEMsQSl7dmFyIEg9ZnVuY3Rpb24oSyl7cmV0dXJuKEs9PT1cIm9jdGF2ZVwifHxLPT09XCJkdXJhdGlvblwifHxLPT09XCJaZHVyYXRpb25cInx8Sz09PVwiYnJva2VuX3JoeXRobVwifHxLPT09XCJlbmRfc2x1clwiKX07dmFyIEI9XCJzdGFydFNsdXJcIjt2YXIgRD1mYWxzZTt3aGlsZSgxKXtzd2l0Y2goSi5jaGFyQXQoRykpe2Nhc2VcIihcIjppZihCPT09XCJzdGFydFNsdXJcIil7aWYoQy5zdGFydFNsdXI9PT11bmRlZmluZWQpe0Muc3RhcnRTbHVyPTF9ZWxzZXtDLnN0YXJ0U2x1cisrfX1lbHNle2lmKEgoQikpe0MuZW5kQ2hhcj1HO3JldHVybiBDfWVsc2V7cmV0dXJuIG51bGx9fWJyZWFrO2Nhc2VcIilcIjppZihIKEIpKXtpZihDLmVuZFNsdXI9PT11bmRlZmluZWQpe0MuZW5kU2x1cj0xfWVsc2V7Qy5lbmRTbHVyKyt9fWVsc2V7cmV0dXJuIG51bGx9YnJlYWs7Y2FzZVwiXlwiOmlmKEI9PT1cInN0YXJ0U2x1clwiKXtDLmFjY2lkZW50YWw9XCJzaGFycFwiO0I9XCJzaGFycDJcIn1lbHNle2lmKEI9PT1cInNoYXJwMlwiKXtDLmFjY2lkZW50YWw9XCJkYmxzaGFycFwiO0I9XCJwaXRjaFwifWVsc2V7aWYoSChCKSl7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9ZWxzZXtyZXR1cm4gbnVsbH19fWJyZWFrO2Nhc2VcIl9cIjppZihCPT09XCJzdGFydFNsdXJcIil7Qy5hY2NpZGVudGFsPVwiZmxhdFwiO0I9XCJmbGF0MlwifWVsc2V7aWYoQj09PVwiZmxhdDJcIil7Qy5hY2NpZGVudGFsPVwiZGJsZmxhdFwiO0I9XCJwaXRjaFwifWVsc2V7aWYoSChCKSl7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9ZWxzZXtyZXR1cm4gbnVsbH19fWJyZWFrO2Nhc2VcIj1cIjppZihCPT09XCJzdGFydFNsdXJcIil7Qy5hY2NpZGVudGFsPVwibmF0dXJhbFwiO0I9XCJwaXRjaFwifWVsc2V7aWYoSChCKSl7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9ZWxzZXtyZXR1cm4gbnVsbH19YnJlYWs7Y2FzZVwiQVwiOmNhc2VcIkJcIjpjYXNlXCJDXCI6Y2FzZVwiRFwiOmNhc2VcIkVcIjpjYXNlXCJGXCI6Y2FzZVwiR1wiOmNhc2VcImFcIjpjYXNlXCJiXCI6Y2FzZVwiY1wiOmNhc2VcImRcIjpjYXNlXCJlXCI6Y2FzZVwiZlwiOmNhc2VcImdcIjppZihCPT09XCJzdGFydFNsdXJcInx8Qj09PVwic2hhcnAyXCJ8fEI9PT1cImZsYXQyXCJ8fEI9PT1cInBpdGNoXCIpe0MucGl0Y2g9altKLmNoYXJBdChHKV07Qj1cIm9jdGF2ZVwiO2lmKEEmJnkubmV4dF9ub3RlX2R1cmF0aW9uIT09MCl7Qy5kdXJhdGlvbj15Lm5leHRfbm90ZV9kdXJhdGlvbjt5Lm5leHRfbm90ZV9kdXJhdGlvbj0wO0Q9dHJ1ZX1lbHNle0MuZHVyYXRpb249eS5kZWZhdWx0X2xlbmd0aH19ZWxzZXtpZihIKEIpKXtDLmVuZENoYXI9RztyZXR1cm4gQ31lbHNle3JldHVybiBudWxsfX1icmVhaztjYXNlXCIsXCI6aWYoQj09PVwib2N0YXZlXCIpe0MucGl0Y2gtPTd9ZWxzZXtpZihIKEIpKXtDLmVuZENoYXI9RztyZXR1cm4gQ31lbHNle3JldHVybiBudWxsfX1icmVhaztjYXNlXCInXCI6aWYoQj09PVwib2N0YXZlXCIpe0MucGl0Y2grPTd9ZWxzZXtpZihIKEIpKXtDLmVuZENoYXI9RztyZXR1cm4gQ31lbHNle3JldHVybiBudWxsfX1icmVhaztjYXNlXCJ4XCI6Y2FzZVwieVwiOmNhc2VcInpcIjpjYXNlXCJaXCI6aWYoQj09PVwic3RhcnRTbHVyXCIpe0MucmVzdD17dHlwZTphW0ouY2hhckF0KEcpXX07ZGVsZXRlIEMuYWNjaWRlbnRhbDtkZWxldGUgQy5zdGFydFNsdXI7ZGVsZXRlIEMuc3RhcnRUaWU7ZGVsZXRlIEMuZW5kU2x1cjtkZWxldGUgQy5lbmRUaWU7ZGVsZXRlIEMuZW5kX2JlYW07ZGVsZXRlIEMuZ3JhY2Vfbm90ZXM7aWYoQy5yZXN0LnR5cGU9PT1cIm11bHRpbWVhc3VyZVwiKXtDLmR1cmF0aW9uPTE7Qj1cIlpkdXJhdGlvblwifWVsc2V7aWYoQSYmeS5uZXh0X25vdGVfZHVyYXRpb24hPT0wKXtDLmR1cmF0aW9uPXkubmV4dF9ub3RlX2R1cmF0aW9uO3kubmV4dF9ub3RlX2R1cmF0aW9uPTA7RD10cnVlfWVsc2V7Qy5kdXJhdGlvbj15LmRlZmF1bHRfbGVuZ3RoXG59Qj1cImR1cmF0aW9uXCJ9fWVsc2V7aWYoSChCKSl7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9ZWxzZXtyZXR1cm4gbnVsbH19YnJlYWs7Y2FzZVwiMVwiOmNhc2VcIjJcIjpjYXNlXCIzXCI6Y2FzZVwiNFwiOmNhc2VcIjVcIjpjYXNlXCI2XCI6Y2FzZVwiN1wiOmNhc2VcIjhcIjpjYXNlXCI5XCI6Y2FzZVwiMFwiOmNhc2VcIi9cIjppZihCPT09XCJvY3RhdmVcInx8Qj09PVwiZHVyYXRpb25cIil7dmFyIEk9bi5nZXRGcmFjdGlvbihKLEcpO2lmKCFEKXtDLmR1cmF0aW9uPUMuZHVyYXRpb24qSS52YWx1ZX1DLmVuZENoYXI9SS5pbmRleDt3aGlsZShJLmluZGV4PEoubGVuZ3RoJiYobi5pc1doaXRlU3BhY2UoSi5jaGFyQXQoSS5pbmRleCkpfHxKLmNoYXJBdChJLmluZGV4KT09PVwiLVwiKSl7aWYoSi5jaGFyQXQoSS5pbmRleCk9PT1cIi1cIil7Qy5zdGFydFRpZT17fX1lbHNle0M9ZyhDKX1JLmluZGV4Kyt9Rz1JLmluZGV4LTE7Qj1cImJyb2tlbl9yaHl0aG1cIn1lbHNle2lmKEI9PT1cInNoYXJwMlwiKXtDLmFjY2lkZW50YWw9XCJxdWFydGVyc2hhcnBcIjtCPVwicGl0Y2hcIn1lbHNle2lmKEI9PT1cImZsYXQyXCIpe0MuYWNjaWRlbnRhbD1cInF1YXJ0ZXJmbGF0XCI7Qj1cInBpdGNoXCJ9ZWxzZXtpZihCPT09XCJaZHVyYXRpb25cIil7dmFyIEY9bi5nZXROdW1iZXIoSixHKTtDLmR1cmF0aW9uPUYubnVtO0MuZW5kQ2hhcj1GLmluZGV4O3JldHVybiBDfWVsc2V7cmV0dXJuIG51bGx9fX19YnJlYWs7Y2FzZVwiLVwiOmlmKEI9PT1cInN0YXJ0U2x1clwiKXtmLmFkZFRpZVRvTGFzdE5vdGUoKTtDLmVuZFRpZT10cnVlfWVsc2V7aWYoQj09PVwib2N0YXZlXCJ8fEI9PT1cImR1cmF0aW9uXCJ8fEI9PT1cImVuZF9zbHVyXCIpe0Muc3RhcnRUaWU9e307aWYoIUQmJkEpe0I9XCJicm9rZW5fcmh5dGhtXCJ9ZWxzZXtpZihuLmlzV2hpdGVTcGFjZShKLmNoYXJBdChHKzEpKSl7ZyhDKX1DLmVuZENoYXI9RysxO3JldHVybiBDfX1lbHNle2lmKEI9PT1cImJyb2tlbl9yaHl0aG1cIil7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9ZWxzZXtyZXR1cm4gbnVsbH19fWJyZWFrO2Nhc2VcIiBcIjpjYXNlXCJcXHRcIjppZihIKEIpKXtDLmVuZF9iZWFtPXRydWU7ZG97aWYoSi5jaGFyQXQoRyk9PT1cIi1cIil7Qy5zdGFydFRpZT17fX1HKyt9d2hpbGUoRzxKLmxlbmd0aCYmKG4uaXNXaGl0ZVNwYWNlKEouY2hhckF0KEcpKXx8Si5jaGFyQXQoRyk9PT1cIi1cIikpO0MuZW5kQ2hhcj1HO2lmKCFEJiZBJiYoSi5jaGFyQXQoRyk9PT1cIjxcInx8Si5jaGFyQXQoRyk9PT1cIj5cIikpe0ctLTtCPVwiYnJva2VuX3JoeXRobVwifWVsc2V7cmV0dXJuIEN9fWVsc2V7cmV0dXJuIG51bGx9YnJlYWs7Y2FzZVwiPlwiOmNhc2VcIjxcIjppZihIKEIpKXtpZihBKXt2YXIgRT1iKEosRyk7Rys9RVswXS0xO3kubmV4dF9ub3RlX2R1cmF0aW9uPUVbMl0qQy5kdXJhdGlvbjtDLmR1cmF0aW9uPUVbMV0qQy5kdXJhdGlvbjtCPVwiZW5kX3NsdXJcIn1lbHNle0MuZW5kQ2hhcj1HO3JldHVybiBDfX1lbHNle3JldHVybiBudWxsfWJyZWFrO2RlZmF1bHQ6aWYoSChCKSl7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9cmV0dXJuIG51bGx9RysrO2lmKEc9PT1KLmxlbmd0aCl7aWYoSChCKSl7Qy5lbmRDaGFyPUc7cmV0dXJuIEN9ZWxzZXtyZXR1cm4gbnVsbH19fXJldHVybiBudWxsfTtmdW5jdGlvbiB2KCl7dmFyIEI9e3N0YXJ0Q2hhcjotMSxlbmRDaGFyOi0xfTtpZih5LnBhcnRGb3JOZXh0TGluZS5sZW5ndGgpe0IucGFydD15LnBhcnRGb3JOZXh0TGluZX1CLmNsZWY9eS5jdXJyZW50Vm9pY2UmJnkuc3RhdmVzW3kuY3VycmVudFZvaWNlLnN0YWZmTnVtXS5jbGVmIT09dW5kZWZpbmVkP3dpbmRvdy5BQkNKUy5wYXJzZS5jbG9uZSh5LnN0YXZlc1t5LmN1cnJlbnRWb2ljZS5zdGFmZk51bV0uY2xlZik6d2luZG93LkFCQ0pTLnBhcnNlLmNsb25lKHkuY2xlZik7Qi5rZXk9d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UuZGVlcENvcHlLZXkoeS5rZXkpO3dpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmFkZFBvc1RvS2V5KEIuY2xlZixCLmtleSk7aWYoeS5tZXRlciE9PW51bGwpe2lmKHkuY3VycmVudFZvaWNlKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaCh5LnN0YXZlcyxmdW5jdGlvbihDKXtDLm1ldGVyPXkubWV0ZXJ9KTtCLm1ldGVyPXkuc3RhdmVzW3kuY3VycmVudFZvaWNlLnN0YWZmTnVtXS5tZXRlcjt5LnN0YXZlc1t5LmN1cnJlbnRWb2ljZS5zdGFmZk51bV0ubWV0ZXI9bnVsbH1lbHNle0IubWV0ZXI9eS5tZXRlcn15Lm1ldGVyPW51bGx9ZWxzZXtpZih5LmN1cnJlbnRWb2ljZSYmeS5zdGF2ZXNbeS5jdXJyZW50Vm9pY2Uuc3RhZmZOdW1dLm1ldGVyKXtCLm1ldGVyPXkuc3RhdmVzW3kuY3VycmVudFZvaWNlLnN0YWZmTnVtXS5tZXRlcjt5LnN0YXZlc1t5LmN1cnJlbnRWb2ljZS5zdGFmZk51bV0ubWV0ZXI9bnVsbH19aWYoeS5jdXJyZW50Vm9pY2UmJnkuY3VycmVudFZvaWNlLm5hbWUpe0IubmFtZT15LmN1cnJlbnRWb2ljZS5uYW1lfWlmKHkudm9jYWxmb250KXtCLnZvY2FsZm9udD15LnZvY2FsZm9udH1pZih5LnN0eWxlKXtCLnN0eWxlPXkuc3R5bGV9aWYoeS5jdXJyZW50Vm9pY2Upe3ZhciBBPXkuc3RhdmVzW3kuY3VycmVudFZvaWNlLnN0YWZmTnVtXTtpZihBLmJyYWNlKXtCLmJyYWNlPUEuYnJhY2V9aWYoQS5icmFja2V0KXtCLmJyYWNrZXQ9QS5icmFja2V0fWlmKEEuY29ubmVjdEJhckxpbmVzKXtCLmNvbm5lY3RCYXJMaW5lcz1BLmNvbm5lY3RCYXJMaW5lc31pZihBLm5hbWUpe0IubmFtZT1BLm5hbWVbeS5jdXJyZW50Vm9pY2UuaW5kZXhdfWlmKEEuc3VibmFtZSl7Qi5zdWJuYW1lPUEuc3VibmFtZVt5LmN1cnJlbnRWb2ljZS5pbmRleF19aWYoeS5jdXJyZW50Vm9pY2Uuc3RlbSl7Qi5zdGVtPXkuY3VycmVudFZvaWNlLnN0ZW19aWYoeS5jdXJyZW50Vm9pY2Uuc2NhbGUpe0Iuc2NhbGU9eS5jdXJyZW50Vm9pY2Uuc2NhbGV9aWYoeS5jdXJyZW50Vm9pY2Uuc3R5bGUpe0Iuc3R5bGU9eS5jdXJyZW50Vm9pY2Uuc3R5bGV9fWYuc3RhcnROZXdMaW5lKEIpO3kucGFydEZvck5leHRMaW5lPVwiXCI7aWYoeS5jdXJyZW50Vm9pY2U9PT11bmRlZmluZWR8fCh5LmN1cnJlbnRWb2ljZS5zdGFmZk51bT09PXkuc3RhdmVzLmxlbmd0aC0xJiZ5LnN0YXZlc1t5LmN1cnJlbnRWb2ljZS5zdGFmZk51bV0ubnVtVm9pY2VzLTE9PT15LmN1cnJlbnRWb2ljZS5pbmRleCkpe2lmKHkuYmFyTnVtYmVycz09PTApe3kuYmFyTnVtT25OZXh0Tm90ZT15LmN1cnJCYXJOdW1iZXJ9fX12YXIgdz1mdW5jdGlvbihCLEQpe2lmKEIuY2hhckF0KEQpPT09XCJ7XCIpe3ZhciBDPW4uZ2V0QnJhY2tldHRlZFN1YnN0cmluZyhCLEQsMSxcIn1cIik7aWYoIUNbMl0pe3goXCJNaXNzaW5nIHRoZSBjbG9zaW5nICd9JyB3aGlsZSBwYXJzaW5nIGdyYWNlIG5vdGVcIixCLEQpfWlmKEJbRCtDWzBdXT09PVwiKVwiKXtDWzBdKys7Q1sxXSs9XCIpXCJ9dmFyIEE9W107dmFyIEY9MDt2YXIgRz1mYWxzZTt3aGlsZShGPENbMV0ubGVuZ3RoKXt2YXIgSD1mYWxzZTtpZihDWzFdLmNoYXJBdChGKT09PVwiL1wiKXtIPXRydWU7RisrfXZhciBFPWkoQ1sxXSxGLHt9LGZhbHNlKTtpZihFIT09bnVsbCl7aWYoSCl7RS5hY2NpYWNjYXR1cmE9dHJ1ZX1BLnB1c2goRSk7aWYoRyl7RS5lbmRUaWU9dHJ1ZTtHPWZhbHNlfWlmKEUuc3RhcnRUaWUpe0c9dHJ1ZX1GPUUuZW5kQ2hhcjtkZWxldGUgRS5lbmRDaGFyfWVsc2V7aWYoQ1sxXS5jaGFyQXQoRik9PT1cIiBcIil7aWYoQS5sZW5ndGg+MCl7QVtBLmxlbmd0aC0xXS5lbmRfYmVhbT10cnVlfX1lbHNle3goXCJVbmtub3duIGNoYXJhY3RlciAnXCIrQ1sxXS5jaGFyQXQoRikrXCInIHdoaWxlIHBhcnNpbmcgZ3JhY2Ugbm90ZVwiLEIsRCl9RisrfX1pZihBLmxlbmd0aCl7cmV0dXJuW0NbMF0sQV19fXJldHVyblswXX07dmFyIHE9XCJBQkNERUZHYWJjZGVmZ3h5elpbXXxeX3tcIjt2YXIgbD1mdW5jdGlvbihLKXt1LnJlc29sdmVUZW1wbygpO3kuaXNfaW5faGVhZGVyPWZhbHNlO3ZhciBSPTA7dmFyIFE9eS5pQ2hhcjt3aGlsZShuLmlzV2hpdGVTcGFjZShLLmNoYXJBdChSKSkmJlI8Sy5sZW5ndGgpe1IrK31pZihSPT09Sy5sZW5ndGh8fEsuY2hhckF0KFIpPT09XCIlXCIpe3JldHVybn12YXIgVT15LnN0YXJ0X25ld19saW5lO2lmKHkuY29udGludWVhbGw9PT11bmRlZmluZWQpe3kuc3RhcnRfbmV3X2xpbmU9dHJ1ZX1lbHNle3kuc3RhcnRfbmV3X2xpbmU9ZmFsc2V9dmFyIEg9MDt2YXIgTj11LmxldHRlcl90b19ib2R5X2hlYWRlcihLLFIpO2lmKE5bMF0+MCl7Uis9TlswXX12YXIgQz17fTt3aGlsZShSPEsubGVuZ3RoKXt2YXIgRD1SO2lmKEsuY2hhckF0KFIpPT09XCIlXCIpe2JyZWFrfXZhciBCPXUubGV0dGVyX3RvX2lubGluZV9oZWFkZXIoSyxSKTtpZihCWzBdPjApe1IrPUJbMF19ZWxzZXtpZihVKXt2KCk7VT1mYWxzZX12YXIgVzt3aGlsZSgxKXtXPW4uZWF0V2hpdGVTcGFjZShLLFIpO2lmKFc+MCl7Uis9V31pZihSPjAmJksuY2hhckF0KFItMSk9PT1cIlxceDEyXCIpe1c9dS5sZXR0ZXJfdG9fYm9keV9oZWFkZXIoSyxSKTtpZihXWzBdPjApe1I9V1swXTt5LnN0YXJ0X25ld19saW5lPWZhbHNlfX1XPWUoSyxSKTtpZihXWzBdPjApe1IrPVdbMF19Vz10KEssUik7aWYoV1swXT4wKXtpZighQy5jaG9yZCl7Qy5jaG9yZD1bXX12YXIgRz1uLnRyYW5zbGF0ZVN0cmluZyhXWzFdKTtHPUcucmVwbGFjZSgvOy9nLFwiXFxuXCIpO3ZhciBGPWZhbHNlO2Zvcih2YXIgTD0wO0w8Qy5jaG9yZC5sZW5ndGg7TCsrKXtpZihDLmNob3JkW0xdLnBvc2l0aW9uPT09V1syXSl7Rj10cnVlO0MuY2hvcmRbTF0ubmFtZSs9XCJcXG5cIitHfX1pZihGPT09ZmFsc2Upe2lmKFdbMl09PT1udWxsJiZXWzNdKXtDLmNob3JkLnB1c2goe25hbWU6RyxyZWxfcG9zaXRpb246V1szXX0pfWVsc2V7Qy5jaG9yZC5wdXNoKHtuYW1lOkcscG9zaXRpb246V1syXX0pfX1SKz1XWzBdO3ZhciBNPW4uc2tpcFdoaXRlU3BhY2UoSy5zdWJzdHJpbmcoUikpO2lmKE0+MCl7Qy5mb3JjZV9lbmRfYmVhbV9sYXN0PXRydWV9Uis9TX1lbHNle2lmKHEuaW5kZXhPZihLLmNoYXJBdChSKSk9PT0tMSl7Vz1oKEssUil9ZWxzZXtXPVswXX1pZihXWzBdPjApe2lmKFdbMV09PT1udWxsKXtpZihSKzE8Sy5sZW5ndGgpe3YoKX19ZWxzZXtpZihXWzFdLmxlbmd0aD4wKXtpZihDLmRlY29yYXRpb249PT11bmRlZmluZWQpe0MuZGVjb3JhdGlvbj1bXX1DLmRlY29yYXRpb24ucHVzaChXWzFdKX19Uis9V1swXX1lbHNle1c9dyhLLFIpO2lmKFdbMF0+MCl7Qy5ncmFjZW5vdGVzPVdbMV07Uis9V1swXX1lbHNle2JyZWFrfX19fVc9cihLLFIpO2lmKFdbMF0+MCl7aWYoQy5ncmFjZW5vdGVzIT09dW5kZWZpbmVkKXtDLnJlc3Q9e3R5cGU6XCJzcGFjZXJcIn07Qy5kdXJhdGlvbj0wLjEyNTtmLmFwcGVuZEVsZW1lbnQoXCJub3RlXCIsUStSLFErUitXWzBdLEMpO3kubWVhc3VyZU5vdEVtcHR5PXRydWU7Qz17fX12YXIgVD17dHlwZTpXWzFdfTtpZihULnR5cGUubGVuZ3RoPT09MCl7eChcIlVua25vd24gYmFyIHR5cGVcIixLLFIpfWVsc2V7aWYoeS5pbkVuZGluZyYmVC50eXBlIT09XCJiYXJfdGhpblwiKXtULmVuZEVuZGluZz10cnVlO3kuaW5FbmRpbmc9ZmFsc2V9aWYoV1syXSl7VC5zdGFydEVuZGluZz1XWzJdO2lmKHkuaW5FbmRpbmcpe1QuZW5kRW5kaW5nPXRydWV9eS5pbkVuZGluZz10cnVlfWlmKEMuZGVjb3JhdGlvbiE9PXVuZGVmaW5lZCl7VC5kZWNvcmF0aW9uPUMuZGVjb3JhdGlvbn1pZihDLmNob3JkIT09dW5kZWZpbmVkKXtULmNob3JkPUMuY2hvcmR9aWYoVC5zdGFydEVuZGluZyYmeS5iYXJGaXJzdEVuZGluZ051bT09PXVuZGVmaW5lZCl7eS5iYXJGaXJzdEVuZGluZ051bT15LmN1cnJCYXJOdW1iZXJ9ZWxzZXtpZihULnN0YXJ0RW5kaW5nJiZULmVuZEVuZGluZyYmeS5iYXJGaXJzdEVuZGluZ051bSl7eS5jdXJyQmFyTnVtYmVyPXkuYmFyRmlyc3RFbmRpbmdOdW19ZWxzZXtpZihULmVuZEVuZGluZyl7eS5iYXJGaXJzdEVuZGluZ051bT11bmRlZmluZWR9fX1pZihULnR5cGUhPT1cImJhcl9pbnZpc2libGVcIiYmeS5tZWFzdXJlTm90RW1wdHkpe3kuY3VyckJhck51bWJlcisrO2lmKHkuYmFyTnVtYmVycyYmeS5jdXJyQmFyTnVtYmVyJXkuYmFyTnVtYmVycz09PTApe3kuYmFyTnVtT25OZXh0Tm90ZT15LmN1cnJCYXJOdW1iZXJ9fWYuYXBwZW5kRWxlbWVudChcImJhclwiLFErUixRK1IrV1swXSxUKTt5Lm1lYXN1cmVOb3RFbXB0eT1mYWxzZTtDPXt9fVIrPVdbMF19ZWxzZXtpZihLW1JdPT09XCImXCIpe3goXCJPdmVybGF5IG5vdCB5ZXQgc3VwcG9ydGVkXCIsSyxSKTtSKyt9ZWxzZXtXPW8oSyxSKTtpZihXLmNvbnN1bWVkPjApe2lmKFcuc3RhcnRTbHVyIT09dW5kZWZpbmVkKXtDLnN0YXJ0U2x1cj1XLnN0YXJ0U2x1cn1pZihXLnRyaXBsZXQhPT11bmRlZmluZWQpe2lmKEg+MCl7eChcIkNhbid0IG5lc3QgdHJpcGxldHNcIixLLFIpfWVsc2V7Qy5zdGFydFRyaXBsZXQ9Vy50cmlwbGV0O0g9Vy5udW1fbm90ZXM9PT11bmRlZmluZWQ/Vy50cmlwbGV0OlcubnVtX25vdGVzfX1SKz1XLmNvbnN1bWVkfWlmKEsuY2hhckF0KFIpPT09XCJbXCIpe1IrKzt2YXIgQT1udWxsO3ZhciBQPWZhbHNlO3doaWxlKCFQKXt2YXIgSj1pKEssUix7fSxmYWxzZSk7aWYoSiE9PW51bGwpe2lmKEouZW5kX2JlYW0pe0MuZW5kX2JlYW09dHJ1ZTtkZWxldGUgSi5lbmRfYmVhbX1pZihDLnBpdGNoZXM9PT11bmRlZmluZWQpe0MuZHVyYXRpb249Si5kdXJhdGlvbjtDLnBpdGNoZXM9W0pdfWVsc2V7Qy5waXRjaGVzLnB1c2goSil9ZGVsZXRlIEouZHVyYXRpb247aWYoeS5pblRpZUNob3JkW0MucGl0Y2hlcy5sZW5ndGhdKXtKLmVuZFRpZT10cnVlO3kuaW5UaWVDaG9yZFtDLnBpdGNoZXMubGVuZ3RoXT11bmRlZmluZWR9aWYoSi5zdGFydFRpZSl7eS5pblRpZUNob3JkW0MucGl0Y2hlcy5sZW5ndGhdPXRydWV9Uj1KLmVuZENoYXI7ZGVsZXRlIEouZW5kQ2hhcn1lbHNle2lmKEsuY2hhckF0KFIpPT09XCIgXCIpe3goXCJTcGFjZXMgYXJlIG5vdCBhbGxvd2VkIGluIGNob3Jkc1wiLEssUik7UisrfWVsc2V7aWYoUjxLLmxlbmd0aCYmSy5jaGFyQXQoUik9PT1cIl1cIil7UisrO2lmKHkubmV4dF9ub3RlX2R1cmF0aW9uIT09MCl7Qy5kdXJhdGlvbj1DLmR1cmF0aW9uKnkubmV4dF9ub3RlX2R1cmF0aW9uO1xueS5uZXh0X25vdGVfZHVyYXRpb249MH1pZih5LmluVGllKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChDLnBpdGNoZXMsZnVuY3Rpb24oWCl7WC5lbmRUaWU9dHJ1ZX0pO3kuaW5UaWU9ZmFsc2V9aWYoSD4wKXtILS07aWYoSD09PTApe0MuZW5kVHJpcGxldD10cnVlfX12YXIgST1mYWxzZTt3aGlsZShSPEsubGVuZ3RoJiYhSSl7c3dpdGNoKEsuY2hhckF0KFIpKXtjYXNlXCIgXCI6Y2FzZVwiXFx0XCI6ZyhDKTticmVhaztjYXNlXCIpXCI6aWYoQy5lbmRTbHVyPT09dW5kZWZpbmVkKXtDLmVuZFNsdXI9MX1lbHNle0MuZW5kU2x1cisrfWJyZWFrO2Nhc2VcIi1cIjp3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChDLnBpdGNoZXMsZnVuY3Rpb24oWCl7WC5zdGFydFRpZT17fX0pO3kuaW5UaWU9dHJ1ZTticmVhaztjYXNlXCI+XCI6Y2FzZVwiPFwiOnZhciBWPWIoSyxSKTtSKz1WWzBdLTE7eS5uZXh0X25vdGVfZHVyYXRpb249VlsyXTtBPVZbMV07YnJlYWs7Y2FzZVwiMVwiOmNhc2VcIjJcIjpjYXNlXCIzXCI6Y2FzZVwiNFwiOmNhc2VcIjVcIjpjYXNlXCI2XCI6Y2FzZVwiN1wiOmNhc2VcIjhcIjpjYXNlXCI5XCI6Y2FzZVwiL1wiOnZhciBFPW4uZ2V0RnJhY3Rpb24oSyxSKTtBPUUudmFsdWU7Uj1FLmluZGV4O2lmKEsuY2hhckF0KFIpPT09XCItXCJ8fEsuY2hhckF0KFIpPT09XCIpXCIpe1ItLX1lbHNle0k9dHJ1ZX1icmVhaztkZWZhdWx0Okk9dHJ1ZTticmVha31pZighSSl7UisrfX19ZWxzZXt4KFwiRXhwZWN0ZWQgJ10nIHRvIGVuZCB0aGUgY2hvcmRzXCIsSyxSKX1pZihDLnBpdGNoZXMhPT11bmRlZmluZWQpe2lmKEEhPT1udWxsKXtDLmR1cmF0aW9uPUMuZHVyYXRpb24qQX1pZih5LmJhck51bU9uTmV4dE5vdGUpe0MuYmFyTnVtYmVyPXkuYmFyTnVtT25OZXh0Tm90ZTt5LmJhck51bU9uTmV4dE5vdGU9bnVsbH1mLmFwcGVuZEVsZW1lbnQoXCJub3RlXCIsUStSLFErUixDKTt5Lm1lYXN1cmVOb3RFbXB0eT10cnVlO0M9e319UD10cnVlfX19fWVsc2V7dmFyIE89e307dmFyIFM9aShLLFIsTyx0cnVlKTtpZihPLmVuZFRpZSE9PXVuZGVmaW5lZCl7eS5pblRpZT10cnVlfWlmKFMhPT1udWxsKXtpZihTLnBpdGNoIT09dW5kZWZpbmVkKXtDLnBpdGNoZXM9W3t9XTtpZihTLmFjY2lkZW50YWwhPT11bmRlZmluZWQpe0MucGl0Y2hlc1swXS5hY2NpZGVudGFsPVMuYWNjaWRlbnRhbH1DLnBpdGNoZXNbMF0ucGl0Y2g9Uy5waXRjaDtpZihTLmVuZFNsdXIhPT11bmRlZmluZWQpe0MucGl0Y2hlc1swXS5lbmRTbHVyPVMuZW5kU2x1cn1pZihTLmVuZFRpZSE9PXVuZGVmaW5lZCl7Qy5waXRjaGVzWzBdLmVuZFRpZT1TLmVuZFRpZX1pZihTLnN0YXJ0U2x1ciE9PXVuZGVmaW5lZCl7Qy5waXRjaGVzWzBdLnN0YXJ0U2x1cj1TLnN0YXJ0U2x1cn1pZihDLnN0YXJ0U2x1ciE9PXVuZGVmaW5lZCl7Qy5waXRjaGVzWzBdLnN0YXJ0U2x1cj1DLnN0YXJ0U2x1cn1pZihTLnN0YXJ0VGllIT09dW5kZWZpbmVkKXtDLnBpdGNoZXNbMF0uc3RhcnRUaWU9Uy5zdGFydFRpZX1pZihDLnN0YXJ0VGllIT09dW5kZWZpbmVkKXtDLnBpdGNoZXNbMF0uc3RhcnRUaWU9Qy5zdGFydFRpZX19ZWxzZXtDLnJlc3Q9Uy5yZXN0O2lmKFMuZW5kU2x1ciE9PXVuZGVmaW5lZCl7Qy5lbmRTbHVyPVMuZW5kU2x1cn1pZihTLmVuZFRpZSE9PXVuZGVmaW5lZCl7Qy5yZXN0LmVuZFRpZT1TLmVuZFRpZX1pZihTLnN0YXJ0U2x1ciE9PXVuZGVmaW5lZCl7Qy5zdGFydFNsdXI9Uy5zdGFydFNsdXJ9aWYoUy5zdGFydFRpZSE9PXVuZGVmaW5lZCl7Qy5yZXN0LnN0YXJ0VGllPVMuc3RhcnRUaWV9aWYoQy5zdGFydFRpZSE9PXVuZGVmaW5lZCl7Qy5yZXN0LnN0YXJ0VGllPUMuc3RhcnRUaWV9fWlmKFMuY2hvcmQhPT11bmRlZmluZWQpe0MuY2hvcmQ9Uy5jaG9yZH1pZihTLmR1cmF0aW9uIT09dW5kZWZpbmVkKXtDLmR1cmF0aW9uPVMuZHVyYXRpb259aWYoUy5kZWNvcmF0aW9uIT09dW5kZWZpbmVkKXtDLmRlY29yYXRpb249Uy5kZWNvcmF0aW9ufWlmKFMuZ3JhY2VOb3RlcyE9PXVuZGVmaW5lZCl7Qy5ncmFjZU5vdGVzPVMuZ3JhY2VOb3Rlc31kZWxldGUgQy5zdGFydFNsdXI7aWYoeS5pblRpZSl7aWYoQy5waXRjaGVzIT09dW5kZWZpbmVkKXtDLnBpdGNoZXNbMF0uZW5kVGllPXRydWV9ZWxzZXtDLnJlc3QuZW5kVGllPXRydWV9eS5pblRpZT1mYWxzZX1pZihTLnN0YXJ0VGllfHxDLnN0YXJ0VGllKXt5LmluVGllPXRydWV9Uj1TLmVuZENoYXI7aWYoSD4wKXtILS07aWYoSD09PTApe0MuZW5kVHJpcGxldD10cnVlfX1pZihTLmVuZF9iZWFtKXtnKEMpfWlmKHkuYmFyTnVtT25OZXh0Tm90ZSl7Qy5iYXJOdW1iZXI9eS5iYXJOdW1Pbk5leHROb3RlO3kuYmFyTnVtT25OZXh0Tm90ZT1udWxsfWYuYXBwZW5kRWxlbWVudChcIm5vdGVcIixRK0QsUStSLEMpO3kubWVhc3VyZU5vdEVtcHR5PXRydWU7Qz17fX19aWYoUj09PUQpe2lmKEsuY2hhckF0KFIpIT09XCIgXCImJksuY2hhckF0KFIpIT09XCJgXCIpe3goXCJVbmtub3duIGNoYXJhY3RlciBpZ25vcmVkXCIsSyxSKX1SKyt9fX19fX07dmFyIGs9ZnVuY3Rpb24oQSl7dmFyIEI9dS5wYXJzZUhlYWRlcihBKTtpZihCLnJlZ3VsYXIpe2woQi5zdHIpfWlmKEIubmV3bGluZSYmeS5jb250aW51ZWFsbD09PXVuZGVmaW5lZCl7digpfWlmKEIud29yZHMpe20oZi5nZXRDdXJyZW50Vm9pY2UoKSxBLnN1YnN0cmluZygyKSl9aWYoQi5zeW1ib2xzKXtkKGYuZ2V0Q3VycmVudFZvaWNlKCksQS5zdWJzdHJpbmcoMikpfWlmKEIucmVjdXJzZSl7ayhCLnN0cil9fTt0aGlzLnBhcnNlPWZ1bmN0aW9uKEcsRSl7Zi5yZXNldCgpO2lmKEUmJkUucHJpbnQpe2YubWVkaWE9XCJwcmludFwifXkucmVzZXQoKTt1LnJlc2V0KG4seCx5LGYpO0c9d2luZG93LkFCQ0pTLnBhcnNlLmdzdWIoRyxcIlxcclxcblwiLFwiXFxuXCIpO0c9d2luZG93LkFCQ0pTLnBhcnNlLmdzdWIoRyxcIlxcclwiLFwiXFxuXCIpO0crPVwiXFxuXCI7Rz1HLnJlcGxhY2UoL1xcblxcXFwuKlxcbi9nLFwiXFxuXCIpO3ZhciBDPWZ1bmN0aW9uKEosTCxNKXt2YXIgST1cIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI7dmFyIEs9TT9JLnN1YnN0cmluZygwLE0ubGVuZ3RoKTpcIlwiO3JldHVybiBMK1wiIFxceDEyXCIrS307Rz1HLnJlcGxhY2UoL1xcXFwoWyBcXHRdKikoJS4qKSpcXG4vZyxDKTt2YXIgQj1HLnNwbGl0KFwiXFxuXCIpO2lmKHdpbmRvdy5BQkNKUy5wYXJzZS5sYXN0KEIpLmxlbmd0aD09PTApe0IucG9wKCl9dHJ5e3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKEIsZnVuY3Rpb24oSSl7aWYoRSl7aWYoRS5oZWFkZXJfb25seSYmeS5pc19pbl9oZWFkZXI9PT1mYWxzZSl7dGhyb3dcIm5vcm1hbF9hYm9ydFwifWlmKEUuc3RvcF9vbl93YXJuaW5nJiZ5Lndhcm5pbmdzKXt0aHJvd1wibm9ybWFsX2Fib3J0XCJ9fWlmKHkuaXNfaW5faGlzdG9yeSl7aWYoSS5jaGFyQXQoMSk9PT1cIjpcIil7eS5pc19pbl9oaXN0b3J5PWZhbHNlO2soSSl9ZWxzZXtmLmFkZE1ldGFUZXh0KFwiaGlzdG9yeVwiLG4udHJhbnNsYXRlU3RyaW5nKG4uc3RyaXBDb21tZW50KEkpKSl9fWVsc2V7aWYoeS5pblRleHRCbG9jayl7aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgoSSxcIiUlZW5kdGV4dFwiKSl7Zi5hZGRUZXh0KHkudGV4dEJsb2NrKTt5LmluVGV4dEJsb2NrPWZhbHNlfWVsc2V7aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgoSSxcIiUlXCIpKXt5LnRleHRCbG9jays9XCIgXCIrSS5zdWJzdHJpbmcoMil9ZWxzZXt5LnRleHRCbG9jays9XCIgXCIrSX19fWVsc2V7aWYoeS5pblBzQmxvY2spe2lmKHdpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKEksXCIlJWVuZHBzXCIpKXt5LmluUHNCbG9jaz1mYWxzZX1lbHNle3kudGV4dEJsb2NrKz1cIiBcIitJfX1lbHNle2soSSl9fX15LmlDaGFyKz1JLmxlbmd0aCsxfSk7dmFyIEg9MTEqNzI7dmFyIEQ9OC41KjcyO3N3aXRjaCh5LnBhcGVyc2l6ZSl7Y2FzZVwibGVnYWxcIjpIPTE0KjcyO0Q9OC41KjcyO2JyZWFrO2Nhc2VcIkE0XCI6SD0xMS43KjcyO0Q9OC4zKjcyO2JyZWFrfWlmKHkubGFuZHNjYXBlKXt2YXIgQT1IO0g9RDtEPUF9Zi5jbGVhblVwKEQsSCx5LmJhcnNwZXJzdGFmZix5LnN0YWZmbm9ub3RlKX1jYXRjaChGKXtpZihGIT09XCJub3JtYWxfYWJvcnRcIil7dGhyb3cgRn19fX07aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMucGFyc2Upe3dpbmRvdy5BQkNKUy5wYXJzZT17fX13aW5kb3cuQUJDSlMucGFyc2UucGFyc2VEaXJlY3RpdmU9e307KGZ1bmN0aW9uKCl7dmFyIGI7dmFyIGQ7dmFyIGE7dmFyIGM7d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLmluaXRpYWxpemU9ZnVuY3Rpb24oaCxmLGcsZSl7Yj1oO2Q9ZjthPWc7Yz1lfTt3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VEaXJlY3RpdmUucGFyc2VGb250Q2hhbmdlTGluZT1mdW5jdGlvbihnKXt2YXIgZT1nLnNwbGl0KFwiJFwiKTtpZihlLmxlbmd0aD4xJiZhLnNldGZvbnQpe3ZhciBoPVt7dGV4dDplWzBdfV07Zm9yKHZhciBmPTE7ZjxlLmxlbmd0aDtmKyspe2lmKGVbZl0uY2hhckF0KDApPT09XCIwXCIpe2gucHVzaCh7dGV4dDplW2ZdLnN1YnN0cmluZygxKX0pfWVsc2V7aWYoZVtmXS5jaGFyQXQoMCk9PT1cIjFcIiYmYS5zZXRmb250WzFdKXtoLnB1c2goe2ZvbnQ6YS5zZXRmb250WzFdLHRleHQ6ZVtmXS5zdWJzdHJpbmcoMSl9KX1lbHNle2lmKGVbZl0uY2hhckF0KDApPT09XCIyXCImJmEuc2V0Zm9udFsyXSl7aC5wdXNoKHtmb250OmEuc2V0Zm9udFsyXSx0ZXh0OmVbZl0uc3Vic3RyaW5nKDEpfSl9ZWxzZXtpZihlW2ZdLmNoYXJBdCgwKT09PVwiM1wiJiZhLnNldGZvbnRbM10pe2gucHVzaCh7Zm9udDphLnNldGZvbnRbM10sdGV4dDplW2ZdLnN1YnN0cmluZygxKX0pfWVsc2V7aWYoZVtmXS5jaGFyQXQoMCk9PT1cIjRcIiYmYS5zZXRmb250WzRdKXtoLnB1c2goe2ZvbnQ6YS5zZXRmb250WzRdLHRleHQ6ZVtmXS5zdWJzdHJpbmcoMSl9KX1lbHNle2hbaC5sZW5ndGgtMV0udGV4dCs9XCIkXCIrZVtmXX19fX19fWlmKGgubGVuZ3RoPjEpe3JldHVybiBofX1yZXR1cm4gZ307d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLmFkZERpcmVjdGl2ZT1mdW5jdGlvbihNKXt2YXIgVj1mdW5jdGlvbih0LGFnKXt2YXIgcD1iLmdldE1lYXN1cmVtZW50KGFnKTtpZihwLnVzZWQ9PT0wfHxhZy5sZW5ndGghPT0wKXtyZXR1cm57ZXJyb3I6J0RpcmVjdGl2ZSBcIicrdCsnXCIgcmVxdWlyZXMgYSBtZWFzdXJlbWVudCBhcyBhIHBhcmFtZXRlci4nfX1yZXR1cm4gcC52YWx1ZX07dmFyIFI9ZnVuY3Rpb24odCxhZyl7dmFyIHA9Yi5nZXRNZWFzdXJlbWVudChhZyk7aWYocC51c2VkPT09MHx8YWcubGVuZ3RoIT09MCl7cmV0dXJuJ0RpcmVjdGl2ZSBcIicrdCsnXCIgcmVxdWlyZXMgYSBtZWFzdXJlbWVudCBhcyBhIHBhcmFtZXRlci4nfWMuZm9ybWF0dGluZ1t0XT1wLnZhbHVlO3JldHVybiBudWxsfTt2YXIgQj1mdW5jdGlvbihhaCl7dmFyIHA9e307dmFyIHQ9d2luZG93LkFCQ0pTLnBhcnNlLmxhc3QoYWgpO2lmKHQudHlwZT09PVwibnVtYmVyXCIpe3Auc2l6ZT1wYXJzZUludCh0LnRva2VuKTthaC5wb3AoKX1pZihhaC5sZW5ndGg+MCl7dmFyIGFnPVwiXCI7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goYWgsZnVuY3Rpb24oYWkpe2lmKGFpLnRva2VuIT09XCItXCIpe2lmKGFnLmxlbmd0aD4wKXthZys9XCIgXCJ9YWcrPWFpLnRva2VufX0pO3AuZm9udD1hZ31yZXR1cm4gcH07dmFyIGs9ZnVuY3Rpb24ocCx0KXtpZih0Lmxlbmd0aD09PTApe3JldHVybidEaXJlY3RpdmUgXCInK3ArJ1wiIHJlcXVpcmVzIGEgZm9udCBhcyBhIHBhcmFtZXRlci4nfWFbcF09Qih0KTtyZXR1cm4gbnVsbH07dmFyIHE9ZnVuY3Rpb24ocCx0KXtpZih0Lmxlbmd0aD09PTApe3JldHVybidEaXJlY3RpdmUgXCInK3ArJ1wiIHJlcXVpcmVzIGEgZm9udCBhcyBhIHBhcmFtZXRlci4nfWMuZm9ybWF0dGluZ1twXT1CKHQpO3JldHVybiBudWxsfTt2YXIgZz1mdW5jdGlvbihhaCxhaSxhaixhZyxwKXtpZihhai5sZW5ndGghPT0xfHxhalswXS50eXBlIT09XCJudW1iZXJcIil7cmV0dXJuJ0RpcmVjdGl2ZSBcIicrYWkrJ1wiIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGEgcGFyYW1ldGVyLid9dmFyIHQ9YWpbMF0uaW50dDtpZihhZyE9PXVuZGVmaW5lZCYmdDxhZyl7cmV0dXJuJ0RpcmVjdGl2ZSBcIicrYWkrJ1wiIHJlcXVpcmVzIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAnK2FnK1wiIGFzIGEgcGFyYW1ldGVyLlwifWlmKHAhPT11bmRlZmluZWQmJnQ+cCl7cmV0dXJuJ0RpcmVjdGl2ZSBcIicrYWkrJ1wiIHJlcXVpcmVzIGEgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byAnK3ArXCIgYXMgYSBwYXJhbWV0ZXIuXCJ9YVthaF09dDtyZXR1cm4gbnVsbH07dmFyIEU9ZnVuY3Rpb24ocCx0LGFnKXt2YXIgYWg9ZyhwLHQsYWcsMCwxKTtpZihhaCE9PW51bGwpe3JldHVybiBhaH1hW3BdPShhW3BdPT09MSk7cmV0dXJuIG51bGx9O3ZhciBLPWIudG9rZW5pemUoTSwwLE0ubGVuZ3RoKTtpZihLLmxlbmd0aD09PTB8fEtbMF0udHlwZSE9PVwiYWxwaGFcIil7cmV0dXJuIG51bGx9dmFyIGY9TS5zdWJzdHJpbmcoTS5pbmRleE9mKEtbMF0udG9rZW4pK0tbMF0udG9rZW4ubGVuZ3RoKTtmPWIuc3RyaXBDb21tZW50KGYpO3ZhciBaPUsuc2hpZnQoKS50b2tlbi50b0xvd2VyQ2FzZSgpO3ZhciBhYzt2YXIgaj1cIlwiO3N3aXRjaChaKXtjYXNlXCJiYWdwaXBlc1wiOmMuZm9ybWF0dGluZy5iYWdwaXBlcz10cnVlO2JyZWFrO2Nhc2VcImxhbmRzY2FwZVwiOmEubGFuZHNjYXBlPXRydWU7YnJlYWs7Y2FzZVwicGFwZXJzaXplXCI6YS5wYXBlcnNpemU9ZjticmVhaztjYXNlXCJzbHVyZ3JhY2VzXCI6Yy5mb3JtYXR0aW5nLnNsdXJncmFjZXM9dHJ1ZTticmVhaztjYXNlXCJzdHJldGNobGFzdFwiOmMuZm9ybWF0dGluZy5zdHJldGNobGFzdD10cnVlO2JyZWFrO2Nhc2VcInRpdGxlY2Fwc1wiOmEudGl0bGVjYXBzPXRydWU7XG5icmVhaztjYXNlXCJ0aXRsZWxlZnRcIjpjLmZvcm1hdHRpbmcudGl0bGVsZWZ0PXRydWU7YnJlYWs7Y2FzZVwibWVhc3VyZWJveFwiOmMuZm9ybWF0dGluZy5tZWFzdXJlYm94PXRydWU7YnJlYWs7Y2FzZVwiYm90bWFyZ2luXCI6Y2FzZVwiYm90c3BhY2VcIjpjYXNlXCJjb21wb3NlcnNwYWNlXCI6Y2FzZVwiaW5kZW50XCI6Y2FzZVwibGVmdG1hcmdpblwiOmNhc2VcImxpbmVzZXBcIjpjYXNlXCJtdXNpY3NwYWNlXCI6Y2FzZVwicGFydHNzcGFjZVwiOmNhc2VcInBhZ2VoZWlnaHRcIjpjYXNlXCJwYWdld2lkdGhcIjpjYXNlXCJyaWdodG1hcmdpblwiOmNhc2VcInN0YWZmc2VwXCI6Y2FzZVwic3RhZmZ3aWR0aFwiOmNhc2VcInN1YnRpdGxlc3BhY2VcIjpjYXNlXCJzeXNzdGFmZnNlcFwiOmNhc2VcInN5c3RlbXNlcFwiOmNhc2VcInRleHRzcGFjZVwiOmNhc2VcInRpdGxlc3BhY2VcIjpjYXNlXCJ0b3BtYXJnaW5cIjpjYXNlXCJ0b3BzcGFjZVwiOmNhc2VcInZvY2Fsc3BhY2VcIjpjYXNlXCJ3b3Jkc3NwYWNlXCI6cmV0dXJuIFIoWixLKTtjYXNlXCJ2c2tpcFwiOnZhciBpPVYoWixLKTtpZihpLmVycm9yKXtyZXR1cm4gaS5lcnJvcn1jLmFkZFNwYWNpbmcoaSk7cmV0dXJuIG51bGw7Y2FzZVwic2NhbGVcIjpqPVwiXCI7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goSyxmdW5jdGlvbihwKXtqKz1wLnRva2VufSk7YWM9cGFyc2VGbG9hdChqKTtpZihpc05hTihhYyl8fGFjPT09MCl7cmV0dXJuJ0RpcmVjdGl2ZSBcIicrWisnXCIgcmVxdWlyZXMgYSBudW1iZXIgYXMgYSBwYXJhbWV0ZXIuJ31jLmZvcm1hdHRpbmcuc2NhbGU9YWM7YnJlYWs7Y2FzZVwic2VwXCI6aWYoSy5sZW5ndGg9PT0wKXtjLmFkZFNlcGFyYXRvcigpfWVsc2V7dmFyIFE9Yi5nZXRNZWFzdXJlbWVudChLKTtpZihRLnVzZWQ9PT0wKXtyZXR1cm4nRGlyZWN0aXZlIFwiJytaKydcIiByZXF1aXJlcyAzIG51bWJlcnM6IHNwYWNlIGFib3ZlLCBzcGFjZSBiZWxvdywgbGVuZ3RoIG9mIGxpbmUnfXZhciBKPVEudmFsdWU7UT1iLmdldE1lYXN1cmVtZW50KEspO2lmKFEudXNlZD09PTApe3JldHVybidEaXJlY3RpdmUgXCInK1orJ1wiIHJlcXVpcmVzIDMgbnVtYmVyczogc3BhY2UgYWJvdmUsIHNwYWNlIGJlbG93LCBsZW5ndGggb2YgbGluZSd9dmFyIGFmPVEudmFsdWU7UT1iLmdldE1lYXN1cmVtZW50KEspO2lmKFEudXNlZD09PTB8fEsubGVuZ3RoIT09MCl7cmV0dXJuJ0RpcmVjdGl2ZSBcIicrWisnXCIgcmVxdWlyZXMgMyBudW1iZXJzOiBzcGFjZSBhYm92ZSwgc3BhY2UgYmVsb3csIGxlbmd0aCBvZiBsaW5lJ312YXIgQT1RLnZhbHVlO2MuYWRkU2VwYXJhdG9yKEosYWYsQSl9YnJlYWs7Y2FzZVwiYmFyc3BlcnN0YWZmXCI6aj1nKFwiYmFyc3BlcnN0YWZmXCIsWixLKTtpZihqIT09bnVsbCl7cmV0dXJuIGp9YnJlYWs7Y2FzZVwic3RhZmZub25vdGVcIjpqPUUoXCJzdGFmZm5vbm90ZVwiLFosSyk7aWYoaiE9PW51bGwpe3JldHVybiBqfWJyZWFrO2Nhc2VcInByaW50dGVtcG9cIjpqPUUoXCJwcmludFRlbXBvXCIsWixLKTtpZihqIT09bnVsbCl7cmV0dXJuIGp9YnJlYWs7Y2FzZVwibWVhc3VyZW5iXCI6Y2FzZVwiYmFybnVtYmVyc1wiOmo9ZyhcImJhck51bWJlcnNcIixaLEspO2lmKGohPT1udWxsKXtyZXR1cm4gan1icmVhaztjYXNlXCJiZWdpbnRleHRcIjphLmluVGV4dEJsb2NrPXRydWU7YnJlYWs7Y2FzZVwiY29udGludWVhbGxcIjphLmNvbnRpbnVlYWxsPXRydWU7YnJlYWs7Y2FzZVwiYmVnaW5wc1wiOmEuaW5Qc0Jsb2NrPXRydWU7ZChcIlBvc3RzY3JpcHQgaWdub3JlZFwiLE0sMCk7YnJlYWs7Y2FzZVwiZGVjb1wiOmlmKGYubGVuZ3RoPjApe2EuaWdub3JlZERlY29yYXRpb25zLnB1c2goZi5zdWJzdHJpbmcoMCxmLmluZGV4T2YoXCIgXCIpKSl9ZChcIkRlY29yYXRpb24gcmVkZWZpbml0aW9uIGlnbm9yZWRcIixNLDApO2JyZWFrO2Nhc2VcInRleHRcIjp2YXIgVz1iLnRyYW5zbGF0ZVN0cmluZyhmKTtjLmFkZFRleHQod2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLnBhcnNlRm9udENoYW5nZUxpbmUoVykpO2JyZWFrO2Nhc2VcImNlbnRlclwiOnZhciBlPWIudHJhbnNsYXRlU3RyaW5nKGYpO2MuYWRkQ2VudGVyZWQod2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLnBhcnNlRm9udENoYW5nZUxpbmUoZSkpO2JyZWFrO2Nhc2VcImZvbnRcIjpicmVhaztjYXNlXCJzZXRmb250XCI6dmFyIHk9Yi50b2tlbml6ZShmLDAsZi5sZW5ndGgpO3ZhciBHPWZhbHNlO2lmKHkubGVuZ3RoPj00KXtpZih5WzBdLnRva2VuPT09XCItXCImJnlbMV0udHlwZT09PVwibnVtYmVyXCIpe3ZhciBoPXBhcnNlSW50KHlbMV0udG9rZW4pO2lmKGg+PTEmJmg8PTQpe2lmKCFhLnNldGZvbnQpe2Euc2V0Zm9udD1bXX12YXIgRD15LnBvcCgpO2lmKEQudHlwZT09PVwibnVtYmVyXCIpe0Q9cGFyc2VJbnQoRC50b2tlbik7dmFyIHU9XCJcIjtmb3IodmFyIHc9Mjt3PHkubGVuZ3RoO3crKyl7dSs9eVt3XS50b2tlbn1hLnNldGZvbnRbaF09e2ZvbnQ6dSxzaXplOkR9O0c9dHJ1ZX19fX1pZighRyl7cmV0dXJuXCJCYWQgcGFyYW1ldGVyczogXCIrWn1icmVhaztjYXNlXCJnY2hvcmRmb250XCI6Y2FzZVwicGFydHNmb250XCI6Y2FzZVwidm9jYWxmb250XCI6Y2FzZVwidGV4dGZvbnRcIjpyZXR1cm4gayhaLEspO2Nhc2VcImJhcmxhYmVsZm9udFwiOmNhc2VcImJhcm51bWJlcmZvbnRcIjpjYXNlXCJjb21wb3NlcmZvbnRcIjpjYXNlXCJzdWJ0aXRsZWZvbnRcIjpjYXNlXCJ0ZW1wb2ZvbnRcIjpjYXNlXCJ0aXRsZWZvbnRcIjpjYXNlXCJ2b2ljZWZvbnRcIjpyZXR1cm4gcShaLEspO2Nhc2VcImJhcm51bWZvbnRcIjpyZXR1cm4gcShcImJhcm51bWJlcmZvbnRcIixLKTtjYXNlXCJzdGF2ZXNcIjpjYXNlXCJzY29yZVwiOmEuc2NvcmVfaXNfcHJlc2VudD10cnVlO3ZhciBhZT1mdW5jdGlvbihhaixhZyxhaSxhaCx0KXtpZihhZ3x8YS5zdGF2ZXMubGVuZ3RoPT09MCl7YS5zdGF2ZXMucHVzaCh7aW5kZXg6YS5zdGF2ZXMubGVuZ3RoLG51bVZvaWNlczowfSl9dmFyIHA9d2luZG93LkFCQ0pTLnBhcnNlLmxhc3QoYS5zdGF2ZXMpO2lmKGFpIT09dW5kZWZpbmVkKXtwLmJyYWNrZXQ9YWl9aWYoYWghPT11bmRlZmluZWQpe3AuYnJhY2U9YWh9aWYodCl7cC5jb25uZWN0QmFyTGluZXM9XCJlbmRcIn1pZihhLnZvaWNlc1thal09PT11bmRlZmluZWQpe2Eudm9pY2VzW2FqXT17c3RhZmZOdW06cC5pbmRleCxpbmRleDpwLm51bVZvaWNlc307cC5udW1Wb2ljZXMrK319O3ZhciBPPWZhbHNlO3ZhciBZPWZhbHNlO3ZhciBuPWZhbHNlO3ZhciBQPWZhbHNlO3ZhciBsPWZhbHNlO3ZhciBvPWZhbHNlO3ZhciBtPWZhbHNlO3ZhciBzO3ZhciBhZD1mdW5jdGlvbigpe209dHJ1ZTtpZihzKXt2YXIgcD1cInN0YXJ0XCI7aWYocy5zdGFmZk51bT4wKXtpZihhLnN0YXZlc1tzLnN0YWZmTnVtLTFdLmNvbm5lY3RCYXJMaW5lcz09PVwic3RhcnRcInx8YS5zdGF2ZXNbcy5zdGFmZk51bS0xXS5jb25uZWN0QmFyTGluZXM9PT1cImNvbnRpbnVlXCIpe3A9XCJjb250aW51ZVwifX1hLnN0YXZlc1tzLnN0YWZmTnVtXS5jb25uZWN0QmFyTGluZXM9cH19O3doaWxlKEsubGVuZ3RoKXt2YXIgVD1LLnNoaWZ0KCk7c3dpdGNoKFQudG9rZW4pe2Nhc2VcIihcIjppZihPKXtkKFwiQ2FuJ3QgbmVzdCBwYXJlbnRoZXNpcyBpbiAlJXNjb3JlXCIsTSxULnN0YXJ0KX1lbHNle089dHJ1ZTtQPXRydWV9YnJlYWs7Y2FzZVwiKVwiOmlmKCFPfHxQKXtkKFwiVW5leHBlY3RlZCBjbG9zZSBwYXJlbnRoZXNpcyBpbiAlJXNjb3JlXCIsTSxULnN0YXJ0KX1lbHNle089ZmFsc2V9YnJlYWs7Y2FzZVwiW1wiOmlmKFkpe2QoXCJDYW4ndCBuZXN0IGJyYWNrZXRzIGluICUlc2NvcmVcIixNLFQuc3RhcnQpfWVsc2V7WT10cnVlO2w9dHJ1ZX1icmVhaztjYXNlXCJdXCI6aWYoIVl8fGwpe2QoXCJVbmV4cGVjdGVkIGNsb3NlIGJyYWNrZXQgaW4gJSVzY29yZVwiLE0sVC5zdGFydCl9ZWxzZXtZPWZhbHNlO2Euc3RhdmVzW3Muc3RhZmZOdW1dLmJyYWNrZXQ9XCJlbmRcIn1icmVhaztjYXNlXCJ7XCI6aWYobil7ZChcIkNhbid0IG5lc3QgYnJhY2VzIGluICUlc2NvcmVcIixNLFQuc3RhcnQpfWVsc2V7bj10cnVlO289dHJ1ZX1icmVhaztjYXNlXCJ9XCI6aWYoIW58fG8pe2QoXCJVbmV4cGVjdGVkIGNsb3NlIGJyYWNlIGluICUlc2NvcmVcIixNLFQuc3RhcnQpfWVsc2V7bj1mYWxzZTthLnN0YXZlc1tzLnN0YWZmTnVtXS5icmFjZT1cImVuZFwifWJyZWFrO2Nhc2VcInxcIjphZCgpO2JyZWFrO2RlZmF1bHQ6dmFyIEM9XCJcIjt3aGlsZShULnR5cGU9PT1cImFscGhhXCJ8fFQudHlwZT09PVwibnVtYmVyXCIpe0MrPVQudG9rZW47aWYoVC5jb250aW51ZUlkKXtUPUsuc2hpZnQoKX1lbHNle2JyZWFrfX12YXIgST0hT3x8UDt2YXIgTD1sP1wic3RhcnRcIjpZP1wiY29udGludWVcIjp1bmRlZmluZWQ7dmFyIHo9bz9cInN0YXJ0XCI6bj9cImNvbnRpbnVlXCI6dW5kZWZpbmVkO2FlKEMsSSxMLHosbSk7UD1mYWxzZTtsPWZhbHNlO289ZmFsc2U7bT1mYWxzZTtzPWEudm9pY2VzW0NdO2lmKFo9PT1cInN0YXZlc1wiKXthZCgpfWJyZWFrfX1icmVhaztjYXNlXCJuZXdwYWdlXCI6dmFyIHY9Yi5nZXRJbnQoZik7Yy5hZGROZXdQYWdlKHYuZGlnaXRzPT09MD8tMTp2LnZhbHVlKTticmVhaztjYXNlXCJhYmMtY29weXJpZ2h0XCI6Y2FzZVwiYWJjLWNyZWF0b3JcIjpjYXNlXCJhYmMtdmVyc2lvblwiOmNhc2VcImFiYy1jaGFyc2V0XCI6Y2FzZVwiYWJjLWVkaXRlZC1ieVwiOmMuYWRkTWV0YVRleHQoWixmKTticmVhaztjYXNlXCJoZWFkZXJcIjpjYXNlXCJmb290ZXJcIjp2YXIgUz1iLmdldE1lYXQoZiwwLGYubGVuZ3RoKTtTPWYuc3Vic3RyaW5nKFMuc3RhcnQsUy5lbmQpO2lmKFMuY2hhckF0KDApPT09J1wiJyYmUy5jaGFyQXQoUy5sZW5ndGgtMSk9PT0nXCInKXtTPVMuc3Vic3RyaW5nKDEsUy5sZW5ndGgtMil9dmFyIEY9Uy5zcGxpdChcIlxcdFwiKTt2YXIgcj17fTtpZihGLmxlbmd0aD09PTEpe3I9e2xlZnQ6XCJcIixjZW50ZXI6RlswXSxyaWdodDpcIlwifX1lbHNle2lmKEYubGVuZ3RoPT09Mil7cj17bGVmdDpGWzBdLGNlbnRlcjpGWzFdLHJpZ2h0OlwiXCJ9fWVsc2V7cj17bGVmdDpGWzBdLGNlbnRlcjpGWzFdLHJpZ2h0OkZbMl19fX1pZihGLmxlbmd0aD4zKXtkKFwiVG9vIG1hbnkgdGFicyBpbiBcIitaK1wiOiBcIitGLmxlbmd0aCtcIiBmb3VuZC5cIixmLDApfWMuYWRkTWV0YVRleHRPYmooWixyKTticmVhaztjYXNlXCJtaWRpXCI6dmFyIFg9Yi50b2tlbml6ZShmLDAsZi5sZW5ndGgpO2lmKFgubGVuZ3RoPjAmJlhbMF0udG9rZW49PT1cIj1cIil7WC5zaGlmdCgpfWlmKFgubGVuZ3RoPT09MCl7ZChcIkV4cGVjdGVkIG1pZGkgY29tbWFuZFwiLGYsMCl9ZWxzZXt2YXIgeD1mdW5jdGlvbihhZyl7aWYoYWcubGVuZ3RoPjApe3ZhciBhaD1hZy5zaGlmdCgpO3ZhciBhaT1haC50b2tlbjtpZihhaC50eXBlPT09XCJudW1iZXJcIil7YWk9YWguaW50dH1yZXR1cm4gYWl9ZWxzZXtyZXR1cm4gbnVsbH19O2lmKGMuZm9ybWF0dGluZ1taXT09PXVuZGVmaW5lZCl7Yy5mb3JtYXR0aW5nW1pdPXt9fXZhciBIPVguc2hpZnQoKS50b2tlbjt2YXIgTj10cnVlO2lmKEg9PT1cInByb2dyYW1cIil7dmFyIGFiPXgoWCk7aWYoYWIpe3ZhciBhYT14KFgpO2lmKGFhKXtOPXtjaGFubmVsOmFiLHByb2dyYW06YWF9fWVsc2V7Tj17cHJvZ3JhbTphYn19fX1lbHNle3ZhciBVPXgoWCk7aWYoVSE9PW51bGwpe049VX19Yy5mb3JtYXR0aW5nW1pdW0hdPU59YnJlYWs7Y2FzZVwicGxheXRlbXBvXCI6Y2FzZVwiYXVxdWFsaXR5XCI6Y2FzZVwiY29udGludW91c1wiOmNhc2VcIm5vYmFyY2hlY2tcIjpjLmZvcm1hdHRpbmdbWl09ZjticmVhaztkZWZhdWx0OnJldHVyblwiVW5rbm93biBkaXJlY3RpdmU6IFwiK1p9cmV0dXJuIG51bGx9fSkoKTtpZighd2luZG93LkFCQ0pTKXt3aW5kb3cuQUJDSlM9e319aWYoIXdpbmRvdy5BQkNKUy5wYXJzZSl7d2luZG93LkFCQ0pTLnBhcnNlPXt9fXdpbmRvdy5BQkNKUy5wYXJzZS5QYXJzZUhlYWRlcj1mdW5jdGlvbihjLGUsYSxkKXt0aGlzLnJlc2V0PWZ1bmN0aW9uKGcsaSxmLGgpe3dpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmluaXRpYWxpemUoZyxpLGYsaCk7d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLmluaXRpYWxpemUoZyxpLGYsaCl9O3RoaXMucmVzZXQoYyxlLGEsZCk7dGhpcy5zZXRUaXRsZT1mdW5jdGlvbihmKXtpZihhLmhhc01haW5UaXRsZSl7ZC5hZGRTdWJ0aXRsZShjLnRyYW5zbGF0ZVN0cmluZyhjLnN0cmlwQ29tbWVudChmKSkpfWVsc2V7ZC5hZGRNZXRhVGV4dChcInRpdGxlXCIsYy50cmFuc2xhdGVTdHJpbmcoYy50aGVSZXZlcnNlcihjLnN0cmlwQ29tbWVudChmKSkpKTthLmhhc01haW5UaXRsZT10cnVlfX07dGhpcy5zZXRNZXRlcj1mdW5jdGlvbihuKXtuPWMuc3RyaXBDb21tZW50KG4pO2lmKG49PT1cIkNcIil7aWYoYS5oYXZlbnRfc2V0X2xlbmd0aD09PXRydWUpe2EuZGVmYXVsdF9sZW5ndGg9MC4xMjV9cmV0dXJue3R5cGU6XCJjb21tb25fdGltZVwifX1lbHNle2lmKG49PT1cIkN8XCIpe2lmKGEuaGF2ZW50X3NldF9sZW5ndGg9PT10cnVlKXthLmRlZmF1bHRfbGVuZ3RoPTAuMTI1fXJldHVybnt0eXBlOlwiY3V0X3RpbWVcIn19ZWxzZXtpZihuPT09XCJvXCIpe2lmKGEuaGF2ZW50X3NldF9sZW5ndGg9PT10cnVlKXthLmRlZmF1bHRfbGVuZ3RoPTAuMTI1fXJldHVybnt0eXBlOlwidGVtcHVzX3BlcmZlY3R1bVwifX1lbHNle2lmKG49PT1cImNcIil7aWYoYS5oYXZlbnRfc2V0X2xlbmd0aD09PXRydWUpe2EuZGVmYXVsdF9sZW5ndGg9MC4xMjV9cmV0dXJue3R5cGU6XCJ0ZW1wdXNfaW1wZXJmZWN0dW1cIn19ZWxzZXtpZihuPT09XCJvLlwiKXtpZihhLmhhdmVudF9zZXRfbGVuZ3RoPT09dHJ1ZSl7YS5kZWZhdWx0X2xlbmd0aD0wLjEyNX1yZXR1cm57dHlwZTpcInRlbXB1c19wZXJmZWN0dW1fcHJvbGF0aW9cIn19ZWxzZXtpZihuPT09XCJjLlwiKXtpZihhLmhhdmVudF9zZXRfbGVuZ3RoPT09dHJ1ZSl7YS5kZWZhdWx0X2xlbmd0aD0wLjEyNX1yZXR1cm57dHlwZTpcInRlbXB1c19pbXBlcmZlY3R1bV9wcm9sYXRpb1wifX1lbHNle2lmKG4ubGVuZ3RoPT09MHx8bi50b0xvd2VyQ2FzZSgpPT09XCJub25lXCIpe2lmKGEuaGF2ZW50X3NldF9sZW5ndGg9PT10cnVlKXthLmRlZmF1bHRfbGVuZ3RoPTAuMTI1fXJldHVybiBudWxsfWVsc2V7dmFyIGs9Yy50b2tlbml6ZShuLDAsbi5sZW5ndGgpO3RyeXt2YXIgaj1mdW5jdGlvbigpe3ZhciBwPXt2YWx1ZTowLG51bTpcIlwifTtcbnZhciBvPWsuc2hpZnQoKTtpZihvLnRva2VuPT09XCIoXCIpe289ay5zaGlmdCgpfXdoaWxlKDEpe2lmKG8udHlwZSE9PVwibnVtYmVyXCIpe3Rocm93XCJFeHBlY3RlZCB0b3AgbnVtYmVyIG9mIG1ldGVyXCJ9cC52YWx1ZSs9cGFyc2VJbnQoby50b2tlbik7cC5udW0rPW8udG9rZW47aWYoay5sZW5ndGg9PT0wfHxrWzBdLnRva2VuPT09XCIvXCIpe3JldHVybiBwfW89ay5zaGlmdCgpO2lmKG8udG9rZW49PT1cIilcIil7aWYoay5sZW5ndGg9PT0wfHxrWzBdLnRva2VuPT09XCIvXCIpe3JldHVybiBwfXRocm93XCJVbmV4cGVjdGVkIHBhcmVuIGluIG1ldGVyXCJ9aWYoby50b2tlbiE9PVwiLlwiJiZvLnRva2VuIT09XCIrXCIpe3Rocm93XCJFeHBlY3RlZCB0b3AgbnVtYmVyIG9mIG1ldGVyXCJ9cC5udW0rPW8udG9rZW47aWYoay5sZW5ndGg9PT0wKXt0aHJvd1wiRXhwZWN0ZWQgdG9wIG51bWJlciBvZiBtZXRlclwifW89ay5zaGlmdCgpfXJldHVybiBwfTt2YXIgZj1mdW5jdGlvbigpe3ZhciBwPWooKTtpZihrLmxlbmd0aD09PTApe3JldHVybiBwfXZhciBvPWsuc2hpZnQoKTtpZihvLnRva2VuIT09XCIvXCIpe3Rocm93XCJFeHBlY3RlZCBzbGFzaCBpbiBtZXRlclwifW89ay5zaGlmdCgpO2lmKG8udHlwZSE9PVwibnVtYmVyXCIpe3Rocm93XCJFeHBlY3RlZCBib3R0b20gbnVtYmVyIG9mIG1ldGVyXCJ9cC5kZW49by50b2tlbjtwLnZhbHVlPXAudmFsdWUvcGFyc2VJbnQocC5kZW4pO3JldHVybiBwfTtpZihrLmxlbmd0aD09PTApe3Rocm93XCJFeHBlY3RlZCBtZXRlciBkZWZpbml0aW9uIGluIE06IGxpbmVcIn12YXIgZz17dHlwZTpcInNwZWNpZmllZFwiLHZhbHVlOltdfTt2YXIgbD0wO3doaWxlKDEpe3ZhciBpPWYoKTtsKz1pLnZhbHVlO3ZhciBtPXtudW06aS5udW19O2lmKGkuZGVuIT09dW5kZWZpbmVkKXttLmRlbj1pLmRlbn1nLnZhbHVlLnB1c2gobSk7aWYoay5sZW5ndGg9PT0wKXticmVha319aWYoYS5oYXZlbnRfc2V0X2xlbmd0aD09PXRydWUpe2EuZGVmYXVsdF9sZW5ndGg9bDwwLjc1PzAuMDYyNTowLjEyNX1yZXR1cm4gZ31jYXRjaChoKXtlKGgsbiwwKX19fX19fX19cmV0dXJuIG51bGx9O3RoaXMuY2FsY1RlbXBvPWZ1bmN0aW9uKGYpe3ZhciBoPTEvNDtpZihhLm1ldGVyJiZhLm1ldGVyLnR5cGU9PT1cInNwZWNpZmllZFwiKXtoPTEvcGFyc2VJbnQoYS5tZXRlci52YWx1ZVswXS5kZW4pfWVsc2V7aWYoYS5vcmlnTWV0ZXImJmEub3JpZ01ldGVyLnR5cGU9PT1cInNwZWNpZmllZFwiKXtoPTEvcGFyc2VJbnQoYS5vcmlnTWV0ZXIudmFsdWVbMF0uZGVuKX19Zm9yKHZhciBnPTA7ZzxmLmR1cmF0aW9uO2crKyl7Zi5kdXJhdGlvbltnXT1oKmYuZHVyYXRpb25bZ119cmV0dXJuIGZ9O3RoaXMucmVzb2x2ZVRlbXBvPWZ1bmN0aW9uKCl7aWYoYS50ZW1wbyl7dGhpcy5jYWxjVGVtcG8oYS50ZW1wbyk7ZC5tZXRhVGV4dC50ZW1wbz1hLnRlbXBvO2RlbGV0ZSBhLnRlbXBvfX07dGhpcy5hZGRVc2VyRGVmaW5pdGlvbj1mdW5jdGlvbihnLGwsZil7dmFyIGg9Zy5pbmRleE9mKFwiPVwiLGwpO2lmKGg9PT0tMSl7ZShcIk5lZWQgYW4gPSBpbiBhIG1hY3JvIGRlZmluaXRpb25cIixnLGwpO3JldHVybn12YXIgaj13aW5kb3cuQUJDSlMucGFyc2Uuc3RyaXAoZy5zdWJzdHJpbmcobCxoKSk7dmFyIGs9d2luZG93LkFCQ0pTLnBhcnNlLnN0cmlwKGcuc3Vic3RyaW5nKGgrMSkpO2lmKGoubGVuZ3RoIT09MSl7ZShcIk1hY3JvIGRlZmluaXRpb25zIGNhbiBvbmx5IGJlIG9uZSBjaGFyYWN0ZXJcIixnLGwpO3JldHVybn12YXIgaT1cIkhJSktMTU5PUFFSU1RVVldYWWhpamtsbW5vcHFyc3R1dnd+XCI7aWYoaS5pbmRleE9mKGopPT09LTEpe2UoXCJNYWNybyBkZWZpbml0aW9ucyBtdXN0IGJlIEgtWSwgaC13LCBvciB0aWxkZVwiLGcsbCk7cmV0dXJufWlmKGsubGVuZ3RoPT09MCl7ZShcIk1pc3NpbmcgbWFjcm8gZGVmaW5pdGlvblwiLGcsbCk7cmV0dXJufWlmKGEubWFjcm9zPT09dW5kZWZpbmVkKXthLm1hY3Jvcz17fX1hLm1hY3Jvc1tqXT1rfTt0aGlzLnNldERlZmF1bHRMZW5ndGg9ZnVuY3Rpb24oaCxsLGcpe3ZhciBmPXdpbmRvdy5BQkNKUy5wYXJzZS5nc3ViKGguc3Vic3RyaW5nKGwsZyksXCIgXCIsXCJcIik7dmFyIGs9Zi5zcGxpdChcIi9cIik7aWYoay5sZW5ndGg9PT0yKXt2YXIgaj1wYXJzZUludChrWzBdKTt2YXIgaT1wYXJzZUludChrWzFdKTtpZihpPjApe2EuZGVmYXVsdF9sZW5ndGg9ai9pO2EuaGF2ZW50X3NldF9sZW5ndGg9ZmFsc2V9fX07dGhpcy5zZXRUZW1wbz1mdW5jdGlvbihvLGYsaSl7dHJ5e3ZhciBsPWMudG9rZW5pemUobyxmLGkpO2lmKGwubGVuZ3RoPT09MCl7dGhyb3dcIk1pc3NpbmcgcGFyYW1ldGVyIGluIFE6IGZpZWxkXCJ9dmFyIGo9e307dmFyIG49dHJ1ZTt2YXIgaD1sLnNoaWZ0KCk7aWYoaC50eXBlPT09XCJxdW90ZVwiKXtqLnByZVN0cmluZz1oLnRva2VuO2g9bC5zaGlmdCgpO2lmKGwubGVuZ3RoPT09MCl7cmV0dXJue3R5cGU6XCJpbW1lZGlhdGVcIix0ZW1wbzpqfX19aWYoaC50eXBlPT09XCJhbHBoYVwiJiZoLnRva2VuPT09XCJDXCIpe2lmKGwubGVuZ3RoPT09MCl7dGhyb3dcIk1pc3NpbmcgdGVtcG8gYWZ0ZXIgQyBpbiBROiBmaWVsZFwifWg9bC5zaGlmdCgpO2lmKGgudHlwZT09PVwicHVuY3RcIiYmaC50b2tlbj09PVwiPVwiKXtpZihsLmxlbmd0aD09PTApe3Rocm93XCJNaXNzaW5nIHRlbXBvIGFmdGVyID0gaW4gUTogZmllbGRcIn1oPWwuc2hpZnQoKTtpZihoLnR5cGUhPT1cIm51bWJlclwiKXt0aHJvd1wiRXhwZWN0ZWQgbnVtYmVyIGFmdGVyID0gaW4gUTogZmllbGRcIn1qLmR1cmF0aW9uPVsxXTtqLmJwbT1wYXJzZUludChoLnRva2VuKX1lbHNle2lmKGgudHlwZT09PVwibnVtYmVyXCIpe2ouZHVyYXRpb249W3BhcnNlSW50KGgudG9rZW4pXTtpZihsLmxlbmd0aD09PTApe3Rocm93XCJNaXNzaW5nID0gYWZ0ZXIgZHVyYXRpb24gaW4gUTogZmllbGRcIn1oPWwuc2hpZnQoKTtpZihoLnR5cGUhPT1cInB1bmN0XCJ8fGgudG9rZW4hPT1cIj1cIil7dGhyb3dcIkV4cGVjdGVkID0gYWZ0ZXIgZHVyYXRpb24gaW4gUTogZmllbGRcIn1pZihsLmxlbmd0aD09PTApe3Rocm93XCJNaXNzaW5nIHRlbXBvIGFmdGVyID0gaW4gUTogZmllbGRcIn1oPWwuc2hpZnQoKTtpZihoLnR5cGUhPT1cIm51bWJlclwiKXt0aHJvd1wiRXhwZWN0ZWQgbnVtYmVyIGFmdGVyID0gaW4gUTogZmllbGRcIn1qLmJwbT1wYXJzZUludChoLnRva2VuKX1lbHNle3Rocm93XCJFeHBlY3RlZCBudW1iZXIgb3IgZXF1YWwgYWZ0ZXIgQyBpbiBROiBmaWVsZFwifX19ZWxzZXtpZihoLnR5cGU9PT1cIm51bWJlclwiKXt2YXIgaz1wYXJzZUludChoLnRva2VuKTtpZihsLmxlbmd0aD09PTB8fGxbMF0udHlwZT09PVwicXVvdGVcIil7ai5kdXJhdGlvbj1bMV07ai5icG09a31lbHNle249ZmFsc2U7aD1sLnNoaWZ0KCk7aWYoaC50eXBlIT09XCJwdW5jdFwiJiZoLnRva2VuIT09XCIvXCIpe3Rocm93XCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwifWg9bC5zaGlmdCgpO2lmKGgudHlwZSE9PVwibnVtYmVyXCIpe3Rocm93XCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwifXZhciBtPXBhcnNlSW50KGgudG9rZW4pO2ouZHVyYXRpb249W2svbV07d2hpbGUobC5sZW5ndGg+MCYmbFswXS50b2tlbiE9PVwiPVwiJiZsWzBdLnR5cGUhPT1cInF1b3RlXCIpe2g9bC5zaGlmdCgpO2lmKGgudHlwZSE9PVwibnVtYmVyXCIpe3Rocm93XCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwifWs9cGFyc2VJbnQoaC50b2tlbik7aD1sLnNoaWZ0KCk7aWYoaC50eXBlIT09XCJwdW5jdFwiJiZoLnRva2VuIT09XCIvXCIpe3Rocm93XCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwifWg9bC5zaGlmdCgpO2lmKGgudHlwZSE9PVwibnVtYmVyXCIpe3Rocm93XCJFeHBlY3RlZCBmcmFjdGlvbiBpbiBROiBmaWVsZFwifW09cGFyc2VJbnQoaC50b2tlbik7ai5kdXJhdGlvbi5wdXNoKGsvbSl9aD1sLnNoaWZ0KCk7aWYoaC50eXBlIT09XCJwdW5jdFwiJiZoLnRva2VuIT09XCI9XCIpe3Rocm93XCJFeHBlY3RlZCA9IGluIFE6IGZpZWxkXCJ9aD1sLnNoaWZ0KCk7aWYoaC50eXBlIT09XCJudW1iZXJcIil7dGhyb3dcIkV4cGVjdGVkIHRlbXBvIGluIFE6IGZpZWxkXCJ9ai5icG09cGFyc2VJbnQoaC50b2tlbil9fWVsc2V7dGhyb3dcIlVua25vd24gdmFsdWUgaW4gUTogZmllbGRcIn19aWYobC5sZW5ndGghPT0wKXtoPWwuc2hpZnQoKTtpZihoLnR5cGU9PT1cInF1b3RlXCIpe2oucG9zdFN0cmluZz1oLnRva2VuO2g9bC5zaGlmdCgpfWlmKGwubGVuZ3RoIT09MCl7dGhyb3dcIlVuZXhwZWN0ZWQgc3RyaW5nIGF0IGVuZCBvZiBROiBmaWVsZFwifX1pZihhLnByaW50VGVtcG89PT1mYWxzZSl7ai5zdXBwcmVzcz10cnVlfXJldHVybnt0eXBlOm4/XCJkZWxheVNldFwiOlwiaW1tZWRpYXRlXCIsdGVtcG86an19Y2F0Y2goZyl7ZShnLG8sZik7cmV0dXJue3R5cGU6XCJub25lXCJ9fX07dGhpcy5sZXR0ZXJfdG9faW5saW5lX2hlYWRlcj1mdW5jdGlvbihoLGspe3ZhciBnPWMuZWF0V2hpdGVTcGFjZShoLGspO2srPWc7aWYoaC5sZW5ndGg+PWsrNSYmaC5jaGFyQXQoayk9PT1cIltcIiYmaC5jaGFyQXQoaysyKT09PVwiOlwiKXt2YXIgbj1oLmluZGV4T2YoXCJdXCIsayk7c3dpdGNoKGguc3Vic3RyaW5nKGssayszKSl7Y2FzZVwiW0k6XCI6dmFyIGw9d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLmFkZERpcmVjdGl2ZShoLnN1YnN0cmluZyhrKzMsbikpO2lmKGwpe2UobCxoLGspfXJldHVybltuLWsrMStnXTtjYXNlXCJbTTpcIjp2YXIgbT10aGlzLnNldE1ldGVyKGguc3Vic3RyaW5nKGsrMyxuKSk7aWYoZC5oYXNCZWdpbk11c2ljKCkmJm0pe2QuYXBwZW5kU3RhcnRpbmdFbGVtZW50KFwibWV0ZXJcIiwtMSwtMSxtKX1lbHNle2EubWV0ZXI9bX1yZXR1cm5bbi1rKzErZ107Y2FzZVwiW0s6XCI6dmFyIGY9d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UucGFyc2VLZXkoaC5zdWJzdHJpbmcoayszLG4pKTtpZihmLmZvdW5kQ2xlZiYmZC5oYXNCZWdpbk11c2ljKCkpe2QuYXBwZW5kU3RhcnRpbmdFbGVtZW50KFwiY2xlZlwiLC0xLC0xLGEuY2xlZil9aWYoZi5mb3VuZEtleSYmZC5oYXNCZWdpbk11c2ljKCkpe2QuYXBwZW5kU3RhcnRpbmdFbGVtZW50KFwia2V5XCIsLTEsLTEsd2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UuZml4S2V5KGEuY2xlZixhLmtleSkpfXJldHVybltuLWsrMStnXTtjYXNlXCJbUDpcIjpkLmFwcGVuZEVsZW1lbnQoXCJwYXJ0XCIsLTEsLTEse3RpdGxlOmguc3Vic3RyaW5nKGsrMyxuKX0pO3JldHVybltuLWsrMStnXTtjYXNlXCJbTDpcIjp0aGlzLnNldERlZmF1bHRMZW5ndGgoaCxrKzMsbik7cmV0dXJuW24taysxK2ddO2Nhc2VcIltROlwiOmlmKG4+MCl7dmFyIGo9dGhpcy5zZXRUZW1wbyhoLGsrMyxuKTtpZihqLnR5cGU9PT1cImRlbGF5U2V0XCIpe2QuYXBwZW5kRWxlbWVudChcInRlbXBvXCIsLTEsLTEsdGhpcy5jYWxjVGVtcG8oai50ZW1wbykpfWVsc2V7aWYoai50eXBlPT09XCJpbW1lZGlhdGVcIil7ZC5hcHBlbmRFbGVtZW50KFwidGVtcG9cIiwtMSwtMSxqLnRlbXBvKX19cmV0dXJuW24taysxK2csaC5jaGFyQXQoaysxKSxoLnN1YnN0cmluZyhrKzMsbildfWJyZWFrO2Nhc2VcIltWOlwiOmlmKG4+MCl7d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UucGFyc2VWb2ljZShoLGsrMyxuKTtyZXR1cm5bbi1rKzErZyxoLmNoYXJBdChrKzEpLGguc3Vic3RyaW5nKGsrMyxuKV19YnJlYWs7ZGVmYXVsdDp9fXJldHVyblswXX07dGhpcy5sZXR0ZXJfdG9fYm9keV9oZWFkZXI9ZnVuY3Rpb24oZyxqKXtpZihnLmxlbmd0aD49aiszKXtzd2l0Y2goZy5zdWJzdHJpbmcoaixqKzIpKXtjYXNlXCJJOlwiOnZhciBrPXdpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZURpcmVjdGl2ZS5hZGREaXJlY3RpdmUoZy5zdWJzdHJpbmcoaisyKSk7aWYoayl7ZShrLGcsail9cmV0dXJuW2cubGVuZ3RoXTtjYXNlXCJNOlwiOnZhciBsPXRoaXMuc2V0TWV0ZXIoZy5zdWJzdHJpbmcoaisyKSk7aWYoZC5oYXNCZWdpbk11c2ljKCkmJmwpe2QuYXBwZW5kU3RhcnRpbmdFbGVtZW50KFwibWV0ZXJcIiwtMSwtMSxsKX1yZXR1cm5bZy5sZW5ndGhdO2Nhc2VcIks6XCI6dmFyIGY9d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UucGFyc2VLZXkoZy5zdWJzdHJpbmcoaisyKSk7aWYoZi5mb3VuZENsZWYmJmQuaGFzQmVnaW5NdXNpYygpKXtkLmFwcGVuZFN0YXJ0aW5nRWxlbWVudChcImNsZWZcIiwtMSwtMSxhLmNsZWYpfWlmKGYuZm91bmRLZXkmJmQuaGFzQmVnaW5NdXNpYygpKXtkLmFwcGVuZFN0YXJ0aW5nRWxlbWVudChcImtleVwiLC0xLC0xLHdpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmZpeEtleShhLmNsZWYsYS5rZXkpKX1yZXR1cm5bZy5sZW5ndGhdO2Nhc2VcIlA6XCI6aWYoZC5oYXNCZWdpbk11c2ljKCkpe2QuYXBwZW5kRWxlbWVudChcInBhcnRcIiwtMSwtMSx7dGl0bGU6Zy5zdWJzdHJpbmcoaisyKX0pfXJldHVybltnLmxlbmd0aF07Y2FzZVwiTDpcIjp0aGlzLnNldERlZmF1bHRMZW5ndGgoZyxqKzIsZy5sZW5ndGgpO3JldHVybltnLmxlbmd0aF07Y2FzZVwiUTpcIjp2YXIgbT1nLmluZGV4T2YoXCJcXHgxMlwiLGorMik7aWYobT09PS0xKXttPWcubGVuZ3RofXZhciBoPXRoaXMuc2V0VGVtcG8oZyxqKzIsbSk7aWYoaC50eXBlPT09XCJkZWxheVNldFwiKXtkLmFwcGVuZEVsZW1lbnQoXCJ0ZW1wb1wiLC0xLC0xLHRoaXMuY2FsY1RlbXBvKGgudGVtcG8pKX1lbHNle2lmKGgudHlwZT09PVwiaW1tZWRpYXRlXCIpe2QuYXBwZW5kRWxlbWVudChcInRlbXBvXCIsLTEsLTEsaC50ZW1wbyl9fXJldHVyblttLGcuY2hhckF0KGopLHdpbmRvdy5BQkNKUy5wYXJzZS5zdHJpcChnLnN1YnN0cmluZyhqKzIpKV07Y2FzZVwiVjpcIjp3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VLZXlWb2ljZS5wYXJzZVZvaWNlKGcsMixnLmxlbmd0aCk7cmV0dXJuW2cubGVuZ3RoLGcuY2hhckF0KGopLHdpbmRvdy5BQkNKUy5wYXJzZShnLnN1YnN0cmluZyhqKzIpKV07ZGVmYXVsdDp9fXJldHVyblswXX07dmFyIGI9e0E6XCJhdXRob3JcIixCOlwiYm9va1wiLEM6XCJjb21wb3NlclwiLEQ6XCJkaXNjb2dyYXBoeVwiLEY6XCJ1cmxcIixHOlwiZ3JvdXBcIixJOlwiaW5zdHJ1Y3Rpb25cIixOOlwibm90ZXNcIixPOlwib3JpZ2luXCIsUjpcInJoeXRobVwiLFM6XCJzb3VyY2VcIixXOlwidW5hbGlnbmVkV29yZHNcIixaOlwidHJhbnNjcmlwdGlvblwifTtcbnRoaXMucGFyc2VIZWFkZXI9ZnVuY3Rpb24oZyl7aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgoZyxcIiUlXCIpKXt2YXIgaj13aW5kb3cuQUJDSlMucGFyc2UucGFyc2VEaXJlY3RpdmUuYWRkRGlyZWN0aXZlKGcuc3Vic3RyaW5nKDIpKTtpZihqKXtlKGosZywyKX1yZXR1cm57fX1nPWMuc3RyaXBDb21tZW50KGcpO2lmKGcubGVuZ3RoPT09MCl7cmV0dXJue319aWYoZy5sZW5ndGg+PTIpe2lmKGcuY2hhckF0KDEpPT09XCI6XCIpe3ZhciBpPVwiXCI7aWYoZy5pbmRleE9mKFwiXFx4MTJcIik+PTAmJmcuY2hhckF0KDApIT09XCJ3XCIpe2k9Zy5zdWJzdHJpbmcoZy5pbmRleE9mKFwiXFx4MTJcIikrMSk7Zz1nLnN1YnN0cmluZygwLGcuaW5kZXhPZihcIlxceDEyXCIpKX12YXIgaz1iW2cuY2hhckF0KDApXTtpZihrIT09dW5kZWZpbmVkKXtpZihrPT09XCJ1bmFsaWduZWRXb3Jkc1wiKXtkLmFkZE1ldGFUZXh0QXJyYXkoayx3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VEaXJlY3RpdmUucGFyc2VGb250Q2hhbmdlTGluZShjLnRyYW5zbGF0ZVN0cmluZyhjLnN0cmlwQ29tbWVudChnLnN1YnN0cmluZygyKSkpKSl9ZWxzZXtkLmFkZE1ldGFUZXh0KGssYy50cmFuc2xhdGVTdHJpbmcoYy5zdHJpcENvbW1lbnQoZy5zdWJzdHJpbmcoMikpKSl9cmV0dXJue319ZWxzZXtzd2l0Y2goZy5jaGFyQXQoMCkpe2Nhc2VcIkhcIjpkLmFkZE1ldGFUZXh0KFwiaGlzdG9yeVwiLGMudHJhbnNsYXRlU3RyaW5nKGMuc3RyaXBDb21tZW50KGcuc3Vic3RyaW5nKDIpKSkpO2EuaXNfaW5faGlzdG9yeT10cnVlO2JyZWFrO2Nhc2VcIktcIjp0aGlzLnJlc29sdmVUZW1wbygpO3ZhciBmPXdpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLnBhcnNlS2V5KGcuc3Vic3RyaW5nKDIpKTtpZighYS5pc19pbl9oZWFkZXImJmQuaGFzQmVnaW5NdXNpYygpKXtpZihmLmZvdW5kQ2xlZil7ZC5hcHBlbmRTdGFydGluZ0VsZW1lbnQoXCJjbGVmXCIsLTEsLTEsYS5jbGVmKX1pZihmLmZvdW5kS2V5KXtkLmFwcGVuZFN0YXJ0aW5nRWxlbWVudChcImtleVwiLC0xLC0xLHdpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmZpeEtleShhLmNsZWYsYS5rZXkpKX19YS5pc19pbl9oZWFkZXI9ZmFsc2U7YnJlYWs7Y2FzZVwiTFwiOnRoaXMuc2V0RGVmYXVsdExlbmd0aChnLDIsZy5sZW5ndGgpO2JyZWFrO2Nhc2VcIk1cIjphLm9yaWdNZXRlcj1hLm1ldGVyPXRoaXMuc2V0TWV0ZXIoZy5zdWJzdHJpbmcoMikpO2JyZWFrO2Nhc2VcIlBcIjppZihhLmlzX2luX2hlYWRlcil7ZC5hZGRNZXRhVGV4dChcInBhcnRPcmRlclwiLGMudHJhbnNsYXRlU3RyaW5nKGMuc3RyaXBDb21tZW50KGcuc3Vic3RyaW5nKDIpKSkpfWVsc2V7YS5wYXJ0Rm9yTmV4dExpbmU9Yy50cmFuc2xhdGVTdHJpbmcoYy5zdHJpcENvbW1lbnQoZy5zdWJzdHJpbmcoMikpKX1icmVhaztjYXNlXCJRXCI6dmFyIGg9dGhpcy5zZXRUZW1wbyhnLDIsZy5sZW5ndGgpO2lmKGgudHlwZT09PVwiZGVsYXlTZXRcIil7YS50ZW1wbz1oLnRlbXBvfWVsc2V7aWYoaC50eXBlPT09XCJpbW1lZGlhdGVcIil7ZC5tZXRhVGV4dC50ZW1wbz1oLnRlbXBvfX1icmVhaztjYXNlXCJUXCI6dGhpcy5zZXRUaXRsZShnLnN1YnN0cmluZygyKSk7YnJlYWs7Y2FzZVwiVVwiOnRoaXMuYWRkVXNlckRlZmluaXRpb24oZywyLGcubGVuZ3RoKTticmVhaztjYXNlXCJWXCI6d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UucGFyc2VWb2ljZShnLDIsZy5sZW5ndGgpO2lmKCFhLmlzX2luX2hlYWRlcil7cmV0dXJue25ld2xpbmU6dHJ1ZX19YnJlYWs7Y2FzZVwic1wiOnJldHVybntzeW1ib2xzOnRydWV9O2Nhc2VcIndcIjpyZXR1cm57d29yZHM6dHJ1ZX07Y2FzZVwiWFwiOmJyZWFrO2Nhc2VcIkVcIjpjYXNlXCJtXCI6ZShcIklnbm9yZWQgaGVhZGVyXCIsZywwKTticmVhaztkZWZhdWx0OmlmKGkubGVuZ3RoKXtpPVwiXFx4MTJcIitpfXJldHVybntyZWd1bGFyOnRydWUsc3RyOmcraX19fWlmKGkubGVuZ3RoPjApe3JldHVybntyZWN1cnNlOnRydWUsc3RyOml9fXJldHVybnt9fX1yZXR1cm57cmVndWxhcjp0cnVlLHN0cjpnfX19O2lmKCF3aW5kb3cuQUJDSlMpe3dpbmRvdy5BQkNKUz17fX1pZighd2luZG93LkFCQ0pTLnBhcnNlKXt3aW5kb3cuQUJDSlMucGFyc2U9e319d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2U9e307KGZ1bmN0aW9uKCl7dmFyIGk7dmFyIGY7dmFyIGI7dmFyIGU7d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UuaW5pdGlhbGl6ZT1mdW5jdGlvbihuLGwsbSxrKXtpPW47Zj1sO2I9bTtlPWt9O3dpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLnN0YW5kYXJkS2V5PWZ1bmN0aW9uKHgpe3ZhciBuPXthY2M6XCJzaGFycFwiLG5vdGU6XCJmXCJ9O3ZhciBzPXthY2M6XCJzaGFycFwiLG5vdGU6XCJjXCJ9O3ZhciB3PXthY2M6XCJzaGFycFwiLG5vdGU6XCJnXCJ9O3ZhciBsPXthY2M6XCJzaGFycFwiLG5vdGU6XCJkXCJ9O3ZhciBxPXthY2M6XCJzaGFycFwiLG5vdGU6XCJBXCJ9O3ZhciB2PXthY2M6XCJzaGFycFwiLG5vdGU6XCJlXCJ9O3ZhciB6PXthY2M6XCJzaGFycFwiLG5vdGU6XCJCXCJ9O3ZhciB1PXthY2M6XCJmbGF0XCIsbm90ZTpcIkJcIn07dmFyIHQ9e2FjYzpcImZsYXRcIixub3RlOlwiZVwifTt2YXIgcj17YWNjOlwiZmxhdFwiLG5vdGU6XCJBXCJ9O3ZhciBwPXthY2M6XCJmbGF0XCIsbm90ZTpcImRcIn07dmFyIG89e2FjYzpcImZsYXRcIixub3RlOlwiR1wifTt2YXIgbT17YWNjOlwiZmxhdFwiLG5vdGU6XCJjXCJ9O3ZhciBrPXthY2M6XCJmbGF0XCIsbm90ZTpcIkZcIn07dmFyIHk9e1wiQyNcIjpbbixzLHcsbCxxLHYsel0sXCJBI21cIjpbbixzLHcsbCxxLHYsel0sXCJHI01peFwiOltuLHMsdyxsLHEsdix6XSxcIkQjRG9yXCI6W24scyx3LGwscSx2LHpdLFwiRSNQaHJcIjpbbixzLHcsbCxxLHYsel0sXCJGI0x5ZFwiOltuLHMsdyxsLHEsdix6XSxcIkIjTG9jXCI6W24scyx3LGwscSx2LHpdLFwiRiNcIjpbbixzLHcsbCxxLHZdLFwiRCNtXCI6W24scyx3LGwscSx2XSxcIkMjTWl4XCI6W24scyx3LGwscSx2XSxcIkcjRG9yXCI6W24scyx3LGwscSx2XSxcIkEjUGhyXCI6W24scyx3LGwscSx2XSxCTHlkOltuLHMsdyxsLHEsdl0sXCJFI0xvY1wiOltuLHMsdyxsLHEsdl0sQjpbbixzLHcsbCxxXSxcIkcjbVwiOltuLHMsdyxsLHFdLFwiRiNNaXhcIjpbbixzLHcsbCxxXSxcIkMjRG9yXCI6W24scyx3LGwscV0sXCJEI1BoclwiOltuLHMsdyxsLHFdLEVMeWQ6W24scyx3LGwscV0sXCJBI0xvY1wiOltuLHMsdyxsLHFdLEU6W24scyx3LGxdLFwiQyNtXCI6W24scyx3LGxdLEJNaXg6W24scyx3LGxdLFwiRiNEb3JcIjpbbixzLHcsbF0sXCJHI1BoclwiOltuLHMsdyxsXSxBTHlkOltuLHMsdyxsXSxcIkQjTG9jXCI6W24scyx3LGxdLEE6W24scyx3XSxcIkYjbVwiOltuLHMsd10sRU1peDpbbixzLHddLEJEb3I6W24scyx3XSxcIkMjUGhyXCI6W24scyx3XSxETHlkOltuLHMsd10sXCJHI0xvY1wiOltuLHMsd10sRDpbbixzXSxCbTpbbixzXSxBTWl4OltuLHNdLEVEb3I6W24sc10sXCJGI1BoclwiOltuLHNdLEdMeWQ6W24sc10sXCJDI0xvY1wiOltuLHNdLEc6W25dLEVtOltuXSxETWl4OltuXSxBRG9yOltuXSxCUGhyOltuXSxDTHlkOltuXSxcIkYjTG9jXCI6W25dLEM6W10sQW06W10sR01peDpbXSxERG9yOltdLEVQaHI6W10sRkx5ZDpbXSxCTG9jOltdLEY6W3VdLERtOlt1XSxDTWl4Olt1XSxHRG9yOlt1XSxBUGhyOlt1XSxCYkx5ZDpbdV0sRUxvYzpbdV0sQmI6W3UsdF0sR206W3UsdF0sRk1peDpbdSx0XSxDRG9yOlt1LHRdLERQaHI6W3UsdF0sRWJMeWQ6W3UsdF0sQUxvYzpbdSx0XSxFYjpbdSx0LHJdLENtOlt1LHQscl0sQmJNaXg6W3UsdCxyXSxGRG9yOlt1LHQscl0sR1BocjpbdSx0LHJdLEFiTHlkOlt1LHQscl0sRExvYzpbdSx0LHJdLEFiOlt1LHQscixwXSxGbTpbdSx0LHIscF0sRWJNaXg6W3UsdCxyLHBdLEJiRG9yOlt1LHQscixwXSxDUGhyOlt1LHQscixwXSxEYkx5ZDpbdSx0LHIscF0sR0xvYzpbdSx0LHIscF0sRGI6W3UsdCxyLHAsb10sQmJtOlt1LHQscixwLG9dLEFiTWl4Olt1LHQscixwLG9dLEViRG9yOlt1LHQscixwLG9dLEZQaHI6W3UsdCxyLHAsb10sR2JMeWQ6W3UsdCxyLHAsb10sQ0xvYzpbdSx0LHIscCxvXSxHYjpbdSx0LHIscCxvLG1dLEVibTpbdSx0LHIscCxvLG1dLERiTWl4Olt1LHQscixwLG8sbV0sQWJEb3I6W3UsdCxyLHAsbyxtXSxCYlBocjpbdSx0LHIscCxvLG1dLENiTHlkOlt1LHQscixwLG8sbV0sRkxvYzpbdSx0LHIscCxvLG1dLENiOlt1LHQscixwLG8sbSxrXSxBYm06W3UsdCxyLHAsbyxtLGtdLEdiTWl4Olt1LHQscixwLG8sbSxrXSxEYkRvcjpbdSx0LHIscCxvLG0sa10sRWJQaHI6W3UsdCxyLHAsbyxtLGtdLEZiTHlkOlt1LHQscixwLG8sbSxrXSxCYkxvYzpbdSx0LHIscCxvLG0sa10sXCJBI1wiOlt1LHRdLFwiQiNcIjpbXSxcIkQjXCI6W3UsdCxyXSxcIkUjXCI6W3VdLFwiRyNcIjpbdSx0LHIscF0sR2JtOltuLHMsdyxsLHEsdix6XX07cmV0dXJuIHlbeF19O3ZhciBjPXt0cmVibGU6e2NsZWY6XCJ0cmVibGVcIixwaXRjaDo0LG1pZDowfSxcInRyZWJsZSs4XCI6e2NsZWY6XCJ0cmVibGUrOFwiLHBpdGNoOjQsbWlkOjB9LFwidHJlYmxlLThcIjp7Y2xlZjpcInRyZWJsZS04XCIscGl0Y2g6NCxtaWQ6MH0sdHJlYmxlMTp7Y2xlZjpcInRyZWJsZVwiLHBpdGNoOjIsbWlkOjJ9LHRyZWJsZTI6e2NsZWY6XCJ0cmVibGVcIixwaXRjaDo0LG1pZDowfSx0cmVibGUzOntjbGVmOlwidHJlYmxlXCIscGl0Y2g6NixtaWQ6LTJ9LHRyZWJsZTQ6e2NsZWY6XCJ0cmVibGVcIixwaXRjaDo4LG1pZDotNH0sdHJlYmxlNTp7Y2xlZjpcInRyZWJsZVwiLHBpdGNoOjEwLG1pZDotNn0scGVyYzp7Y2xlZjpcInBlcmNcIixwaXRjaDo2LG1pZDowfSxub25lOntjbGVmOlwibm9uZVwiLG1pZDowfSxiYXNzOntjbGVmOlwiYmFzc1wiLHBpdGNoOjgsbWlkOi0xMn0sXCJiYXNzKzhcIjp7Y2xlZjpcImJhc3MrOFwiLHBpdGNoOjgsbWlkOi0xMn0sXCJiYXNzLThcIjp7Y2xlZjpcImJhc3MtOFwiLHBpdGNoOjgsbWlkOi0xMn0sXCJiYXNzKzE2XCI6e2NsZWY6XCJiYXNzXCIscGl0Y2g6OCxtaWQ6LTEyfSxcImJhc3MtMTZcIjp7Y2xlZjpcImJhc3NcIixwaXRjaDo4LG1pZDotMTJ9LGJhc3MxOntjbGVmOlwiYmFzc1wiLHBpdGNoOjIsbWlkOi02fSxiYXNzMjp7Y2xlZjpcImJhc3NcIixwaXRjaDo0LG1pZDotOH0sYmFzczM6e2NsZWY6XCJiYXNzXCIscGl0Y2g6NixtaWQ6LTEwfSxiYXNzNDp7Y2xlZjpcImJhc3NcIixwaXRjaDo4LG1pZDotMTJ9LGJhc3M1OntjbGVmOlwiYmFzc1wiLHBpdGNoOjEwLG1pZDotMTR9LHRlbm9yOntjbGVmOlwiYWx0b1wiLHBpdGNoOjgsbWlkOi04fSx0ZW5vcjE6e2NsZWY6XCJhbHRvXCIscGl0Y2g6MixtaWQ6LTJ9LHRlbm9yMjp7Y2xlZjpcImFsdG9cIixwaXRjaDo0LG1pZDotNH0sdGVub3IzOntjbGVmOlwiYWx0b1wiLHBpdGNoOjYsbWlkOi02fSx0ZW5vcjQ6e2NsZWY6XCJhbHRvXCIscGl0Y2g6OCxtaWQ6LTh9LHRlbm9yNTp7Y2xlZjpcImFsdG9cIixwaXRjaDoxMCxtaWQ6LTEwfSxhbHRvOntjbGVmOlwiYWx0b1wiLHBpdGNoOjYsbWlkOi02fSxhbHRvMTp7Y2xlZjpcImFsdG9cIixwaXRjaDoyLG1pZDotMn0sYWx0bzI6e2NsZWY6XCJhbHRvXCIscGl0Y2g6NCxtaWQ6LTR9LGFsdG8zOntjbGVmOlwiYWx0b1wiLHBpdGNoOjYsbWlkOi02fSxhbHRvNDp7Y2xlZjpcImFsdG9cIixwaXRjaDo4LG1pZDotOH0sYWx0bzU6e2NsZWY6XCJhbHRvXCIscGl0Y2g6MTAsbWlkOi0xMH0sXCJhbHRvKzhcIjp7Y2xlZjpcImFsdG8rOFwiLHBpdGNoOjYsbWlkOi02fSxcImFsdG8tOFwiOntjbGVmOlwiYWx0by04XCIscGl0Y2g6NixtaWQ6LTZ9fTt2YXIgaj1mdW5jdGlvbihuLGspe3ZhciBtPWNbbl07dmFyIGw9bT9tLm1pZDowO3JldHVybiBsK2t9O3dpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmZpeENsZWY9ZnVuY3Rpb24obCl7dmFyIGs9Y1tsLnR5cGVdO2lmKGspe2wuY2xlZlBvcz1rLnBpdGNoO2wudHlwZT1rLmNsZWZ9fTt3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VLZXlWb2ljZS5kZWVwQ29weUtleT1mdW5jdGlvbihsKXt2YXIgaz17YWNjaWRlbnRhbHM6W10scm9vdDpsLnJvb3QsYWNjOmwuYWNjLG1vZGU6bC5tb2RlfTt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChsLmFjY2lkZW50YWxzLGZ1bmN0aW9uKG0pe2suYWNjaWRlbnRhbHMucHVzaCh3aW5kb3cuQUJDSlMucGFyc2UuY2xvbmUobSkpfSk7cmV0dXJuIGt9O3ZhciBkPXtBOjUsQjo2LEM6MCxEOjEsRToyLEY6MyxHOjQsYToxMixiOjEzLGM6NyxkOjgsZTo5LGY6MTAsZzoxMX07d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UuYWRkUG9zVG9LZXk9ZnVuY3Rpb24obSxsKXt2YXIgaz1tLnZlcnRpY2FsUG9zO3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKGwuYWNjaWRlbnRhbHMsZnVuY3Rpb24obil7dmFyIG89ZFtuLm5vdGVdO289by1rO24udmVydGljYWxQb3M9b30pO2lmKGwuaW1wbGllZE5hdHVyYWxzKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChsLmltcGxpZWROYXR1cmFscyxmdW5jdGlvbihuKXt2YXIgbz1kW24ubm90ZV07bz1vLWs7bi52ZXJ0aWNhbFBvcz1vfSl9aWYoazwtMTApe3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKGwuYWNjaWRlbnRhbHMsZnVuY3Rpb24obil7bi52ZXJ0aWNhbFBvcy09NztpZihuLnZlcnRpY2FsUG9zPj0xMXx8KG4udmVydGljYWxQb3M9PT0xMCYmbi5hY2M9PT1cImZsYXRcIikpe24udmVydGljYWxQb3MtPTd9aWYobi5ub3RlPT09XCJBXCImJm4uYWNjPT09XCJzaGFycFwiKXtuLnZlcnRpY2FsUG9zLT03fWlmKChuLm5vdGU9PT1cIkdcInx8bi5ub3RlPT09XCJGXCIpJiZuLmFjYz09PVwiZmxhdFwiKXtuLnZlcnRpY2FsUG9zLT03fX0pO2lmKGwuaW1wbGllZE5hdHVyYWxzKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChsLmltcGxpZWROYXR1cmFscyxmdW5jdGlvbihuKXtuLnZlcnRpY2FsUG9zLT03O2lmKG4udmVydGljYWxQb3M+PTExfHwobi52ZXJ0aWNhbFBvcz09PTEwJiZuLmFjYz09PVwiZmxhdFwiKSl7bi52ZXJ0aWNhbFBvcy09N31pZihuLm5vdGU9PT1cIkFcIiYmbi5hY2M9PT1cInNoYXJwXCIpe24udmVydGljYWxQb3MtPTd9aWYoKG4ubm90ZT09PVwiR1wifHxuLm5vdGU9PT1cIkZcIikmJm4uYWNjPT09XCJmbGF0XCIpe24udmVydGljYWxQb3MtPTd9fSl9fWVsc2V7aWYoazwtNCl7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2gobC5hY2NpZGVudGFscyxmdW5jdGlvbihuKXtuLnZlcnRpY2FsUG9zLT03O1xuaWYoaz09PS04JiYobi5ub3RlPT09XCJmXCJ8fG4ubm90ZT09PVwiZ1wiKSYmbi5hY2M9PT1cInNoYXJwXCIpe24udmVydGljYWxQb3MtPTd9fSk7aWYobC5pbXBsaWVkTmF0dXJhbHMpe3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKGwuaW1wbGllZE5hdHVyYWxzLGZ1bmN0aW9uKG4pe24udmVydGljYWxQb3MtPTc7aWYoaz09PS04JiYobi5ub3RlPT09XCJmXCJ8fG4ubm90ZT09PVwiZ1wiKSYmbi5hY2M9PT1cInNoYXJwXCIpe24udmVydGljYWxQb3MtPTd9fSl9fWVsc2V7aWYoaz49Nyl7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2gobC5hY2NpZGVudGFscyxmdW5jdGlvbihuKXtuLnZlcnRpY2FsUG9zKz03fSk7aWYobC5pbXBsaWVkTmF0dXJhbHMpe3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKGwuaW1wbGllZE5hdHVyYWxzLGZ1bmN0aW9uKG4pe24udmVydGljYWxQb3MrPTd9KX19fX19O3dpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmZpeEtleT1mdW5jdGlvbihtLGspe3ZhciBsPXdpbmRvdy5BQkNKUy5wYXJzZS5jbG9uZShrKTt3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VLZXlWb2ljZS5hZGRQb3NUb0tleShtLGwpO3JldHVybiBsfTt2YXIgYT1mdW5jdGlvbihtKXt2YXIgaz1kW20uY2hhckF0KDApXTtmb3IodmFyIGw9MTtsPG0ubGVuZ3RoO2wrKyl7aWYobS5jaGFyQXQobCk9PT1cIixcIil7ay09N31lbHNle2lmKG0uY2hhckF0KGwpPT09XCIsXCIpe2srPTd9ZWxzZXticmVha319fXJldHVybnttaWQ6ay02LHN0cjptLnN1YnN0cmluZyhsKX19O3ZhciBoPWZ1bmN0aW9uKGspe2Zvcih2YXIgbD0wO2w8ay5sZW5ndGg7bCsrKXtpZihrW2xdLm5vdGU9PT1cImJcIil7a1tsXS5ub3RlPVwiQlwifWVsc2V7aWYoa1tsXS5ub3RlPT09XCJhXCIpe2tbbF0ubm90ZT1cIkFcIn1lbHNle2lmKGtbbF0ubm90ZT09PVwiRlwiKXtrW2xdLm5vdGU9XCJmXCJ9ZWxzZXtpZihrW2xdLm5vdGU9PT1cIkVcIil7a1tsXS5ub3RlPVwiZVwifWVsc2V7aWYoa1tsXS5ub3RlPT09XCJEXCIpe2tbbF0ubm90ZT1cImRcIn1lbHNle2lmKGtbbF0ubm90ZT09PVwiQ1wiKXtrW2xdLm5vdGU9XCJjXCJ9ZWxzZXtpZihrW2xdLm5vdGU9PT1cIkdcIiYma1tsXS5hY2M9PT1cInNoYXJwXCIpe2tbbF0ubm90ZT1cImdcIn1lbHNle2lmKGtbbF0ubm90ZT09PVwiZ1wiJiZrW2xdLmFjYz09PVwiZmxhdFwiKXtrW2xdLm5vdGU9XCJHXCJ9fX19fX19fX19O3dpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLnBhcnNlS2V5PWZ1bmN0aW9uKHgpe2lmKHgubGVuZ3RoPT09MCl7eD1cIm5vbmVcIn12YXIgdz1pLnRva2VuaXplKHgsMCx4Lmxlbmd0aCk7dmFyIEQ9e307c3dpdGNoKHdbMF0udG9rZW4pe2Nhc2VcIkhQXCI6d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlRGlyZWN0aXZlLmFkZERpcmVjdGl2ZShcImJhZ3BpcGVzXCIpO2Iua2V5PXtyb290OlwiSFBcIixhY2NpZGVudGFsczpbXSxhY2M6XCJcIixtb2RlOlwiXCJ9O0QuZm91bmRLZXk9dHJ1ZTt3LnNoaWZ0KCk7YnJlYWs7Y2FzZVwiSHBcIjp3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VEaXJlY3RpdmUuYWRkRGlyZWN0aXZlKFwiYmFncGlwZXNcIik7Yi5rZXk9e3Jvb3Q6XCJIcFwiLGFjY2lkZW50YWxzOlt7YWNjOlwibmF0dXJhbFwiLG5vdGU6XCJnXCJ9LHthY2M6XCJzaGFycFwiLG5vdGU6XCJmXCJ9LHthY2M6XCJzaGFycFwiLG5vdGU6XCJjXCJ9XSxhY2M6XCJcIixtb2RlOlwiXCJ9O0QuZm91bmRLZXk9dHJ1ZTt3LnNoaWZ0KCk7YnJlYWs7Y2FzZVwibm9uZVwiOmIua2V5PXtyb290Olwibm9uZVwiLGFjY2lkZW50YWxzOltdLGFjYzpcIlwiLG1vZGU6XCJcIn07RC5mb3VuZEtleT10cnVlO3cuc2hpZnQoKTticmVhaztkZWZhdWx0OnZhciBwPWkuZ2V0S2V5UGl0Y2god1swXS50b2tlbik7aWYocC5sZW4+MCl7RC5mb3VuZEtleT10cnVlO3ZhciBuPVwiXCI7dmFyIHY9XCJcIjtpZih3WzBdLnRva2VuLmxlbmd0aD4xKXt3WzBdLnRva2VuPXdbMF0udG9rZW4uc3Vic3RyaW5nKDEpfWVsc2V7dy5zaGlmdCgpfXZhciBFPXAudG9rZW47aWYody5sZW5ndGg+MCl7dmFyIGw9aS5nZXRTaGFycEZsYXQod1swXS50b2tlbik7aWYobC5sZW4+MCl7aWYod1swXS50b2tlbi5sZW5ndGg+MSl7d1swXS50b2tlbj13WzBdLnRva2VuLnN1YnN0cmluZygxKX1lbHNle3cuc2hpZnQoKX1FKz1sLnRva2VuO249bC50b2tlbn1pZih3Lmxlbmd0aD4wKXt2YXIgQz1pLmdldE1vZGUod1swXS50b2tlbik7aWYoQy5sZW4+MCl7dy5zaGlmdCgpO0UrPUMudG9rZW47dj1DLnRva2VufX19dmFyIHM9d2luZG93LkFCQ0pTLnBhcnNlLnBhcnNlS2V5Vm9pY2UuZGVlcENvcHlLZXkoYi5rZXkpO2Iua2V5PXdpbmRvdy5BQkNKUy5wYXJzZS5wYXJzZUtleVZvaWNlLmRlZXBDb3B5S2V5KHthY2NpZGVudGFsczp3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VLZXlWb2ljZS5zdGFuZGFyZEtleShFKX0pO2Iua2V5LnJvb3Q9cC50b2tlbjtiLmtleS5hY2M9bjtiLmtleS5tb2RlPXY7aWYocyl7dmFyIG07Zm9yKHZhciB6PTA7ejxiLmtleS5hY2NpZGVudGFscy5sZW5ndGg7eisrKXtmb3IobT0wO208cy5hY2NpZGVudGFscy5sZW5ndGg7bSsrKXtpZihzLmFjY2lkZW50YWxzW21dLm5vdGUmJmIua2V5LmFjY2lkZW50YWxzW3pdLm5vdGUudG9Mb3dlckNhc2UoKT09PXMuYWNjaWRlbnRhbHNbbV0ubm90ZS50b0xvd2VyQ2FzZSgpKXtzLmFjY2lkZW50YWxzW21dLm5vdGU9bnVsbH19fWZvcihtPTA7bTxzLmFjY2lkZW50YWxzLmxlbmd0aDttKyspe2lmKHMuYWNjaWRlbnRhbHNbbV0ubm90ZSl7aWYoIWIua2V5LmltcGxpZWROYXR1cmFscyl7Yi5rZXkuaW1wbGllZE5hdHVyYWxzPVtdfWIua2V5LmltcGxpZWROYXR1cmFscy5wdXNoKHthY2M6XCJuYXR1cmFsXCIsbm90ZTpzLmFjY2lkZW50YWxzW21dLm5vdGV9KX19fX1icmVha31pZih3Lmxlbmd0aD09PTApe3JldHVybiBEfWlmKHdbMF0udG9rZW49PT1cImV4cFwiKXt3LnNoaWZ0KCl9aWYody5sZW5ndGg9PT0wKXtyZXR1cm4gRH1pZih3WzBdLnRva2VuPT09XCJvY3RcIil7dy5zaGlmdCgpfWlmKHcubGVuZ3RoPT09MCl7cmV0dXJuIER9dmFyIHQ9aS5nZXRLZXlBY2NpZGVudGFsczIodyk7aWYodC53YXJuKXtmKHQud2Fybix4LDApfWlmKHQuYWNjcyl7aWYoIUQuZm91bmRLZXkpe0QuZm91bmRLZXk9dHJ1ZTtiLmtleT17cm9vdDpcIm5vbmVcIixhY2M6XCJcIixtb2RlOlwiXCIsYWNjaWRlbnRhbHM6W119fWgodC5hY2NzKTtmb3IodmFyIEI9MDtCPHQuYWNjcy5sZW5ndGg7QisrKXt2YXIgdT1mYWxzZTtmb3IodmFyIEE9MDtBPGIua2V5LmFjY2lkZW50YWxzLmxlbmd0aCYmIXU7QSsrKXtpZihiLmtleS5hY2NpZGVudGFsc1tBXS5ub3RlPT09dC5hY2NzW0JdLm5vdGUpe3U9dHJ1ZTtiLmtleS5hY2NpZGVudGFsc1tBXS5hY2M9dC5hY2NzW0JdLmFjY319aWYoIXUpe2Iua2V5LmFjY2lkZW50YWxzLnB1c2godC5hY2NzW0JdKTtpZihiLmtleS5pbXBsaWVkTmF0dXJhbHMpe2Zvcih2YXIgcT0wO3E8Yi5rZXkuaW1wbGllZE5hdHVyYWxzLmxlbmd0aDtxKyspe2lmKGIua2V5LmltcGxpZWROYXR1cmFsc1txXS5ub3RlPT09dC5hY2NzW0JdLm5vdGUpe2Iua2V5LmltcGxpZWROYXR1cmFscy5zcGxpY2UocSwxKX19fX19fXZhciBvO3doaWxlKHcubGVuZ3RoPjApe3N3aXRjaCh3WzBdLnRva2VuKXtjYXNlXCJtXCI6Y2FzZVwibWlkZGxlXCI6dy5zaGlmdCgpO2lmKHcubGVuZ3RoPT09MCl7ZihcIkV4cGVjdGVkID0gYWZ0ZXIgbWlkZGxlXCIseCwwKTtyZXR1cm4gRH1vPXcuc2hpZnQoKTtpZihvLnRva2VuIT09XCI9XCIpe2YoXCJFeHBlY3RlZCA9IGFmdGVyIG1pZGRsZVwiLHgsby5zdGFydCk7YnJlYWt9aWYody5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgcGFyYW1ldGVyIGFmdGVyIG1pZGRsZT1cIix4LDApO3JldHVybiBEfXZhciByPWkuZ2V0UGl0Y2hGcm9tVG9rZW5zKHcpO2lmKHIud2Fybil7ZihyLndhcm4seCwwKX1pZihyLnBvc2l0aW9uKXtiLmNsZWYudmVydGljYWxQb3M9ci5wb3NpdGlvbi02fWJyZWFrO2Nhc2VcInRyYW5zcG9zZVwiOncuc2hpZnQoKTtpZih3Lmxlbmd0aD09PTApe2YoXCJFeHBlY3RlZCA9IGFmdGVyIHRyYW5zcG9zZVwiLHgsMCk7cmV0dXJuIER9bz13LnNoaWZ0KCk7aWYoby50b2tlbiE9PVwiPVwiKXtmKFwiRXhwZWN0ZWQgPSBhZnRlciB0cmFuc3Bvc2VcIix4LG8uc3RhcnQpO2JyZWFrfWlmKHcubGVuZ3RoPT09MCl7ZihcIkV4cGVjdGVkIHBhcmFtZXRlciBhZnRlciB0cmFuc3Bvc2U9XCIseCwwKTtyZXR1cm4gRH1pZih3WzBdLnR5cGUhPT1cIm51bWJlclwiKXtmKFwiRXhwZWN0ZWQgbnVtYmVyIGFmdGVyIHRyYW5zcG9zZVwiLHgsd1swXS5zdGFydCk7YnJlYWt9Yi5jbGVmLnRyYW5zcG9zZT13WzBdLmludHQ7dy5zaGlmdCgpO2JyZWFrO2Nhc2VcInN0YWZmbGluZXNcIjp3LnNoaWZ0KCk7aWYody5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgPSBhZnRlciBzdGFmZmxpbmVzXCIseCwwKTtyZXR1cm4gRH1vPXcuc2hpZnQoKTtpZihvLnRva2VuIT09XCI9XCIpe2YoXCJFeHBlY3RlZCA9IGFmdGVyIHN0YWZmbGluZXNcIix4LG8uc3RhcnQpO2JyZWFrfWlmKHcubGVuZ3RoPT09MCl7ZihcIkV4cGVjdGVkIHBhcmFtZXRlciBhZnRlciBzdGFmZmxpbmVzPVwiLHgsMCk7cmV0dXJuIER9aWYod1swXS50eXBlIT09XCJudW1iZXJcIil7ZihcIkV4cGVjdGVkIG51bWJlciBhZnRlciBzdGFmZmxpbmVzXCIseCx3WzBdLnN0YXJ0KTticmVha31iLmNsZWYuc3RhZmZsaW5lcz13WzBdLmludHQ7dy5zaGlmdCgpO2JyZWFrO2Nhc2VcInN0YWZmc2NhbGVcIjp3LnNoaWZ0KCk7aWYody5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgPSBhZnRlciBzdGFmZnNjYWxlXCIseCwwKTtyZXR1cm4gRH1vPXcuc2hpZnQoKTtpZihvLnRva2VuIT09XCI9XCIpe2YoXCJFeHBlY3RlZCA9IGFmdGVyIHN0YWZmc2NhbGVcIix4LG8uc3RhcnQpO2JyZWFrfWlmKHcubGVuZ3RoPT09MCl7ZihcIkV4cGVjdGVkIHBhcmFtZXRlciBhZnRlciBzdGFmZnNjYWxlPVwiLHgsMCk7cmV0dXJuIER9aWYod1swXS50eXBlIT09XCJudW1iZXJcIil7ZihcIkV4cGVjdGVkIG51bWJlciBhZnRlciBzdGFmZnNjYWxlXCIseCx3WzBdLnN0YXJ0KTticmVha31iLmNsZWYuc3RhZmZzY2FsZT13WzBdLmZsb2F0dDt3LnNoaWZ0KCk7YnJlYWs7Y2FzZVwic3R5bGVcIjp3LnNoaWZ0KCk7aWYody5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgPSBhZnRlciBzdHlsZVwiLHgsMCk7cmV0dXJuIER9bz13LnNoaWZ0KCk7aWYoby50b2tlbiE9PVwiPVwiKXtmKFwiRXhwZWN0ZWQgPSBhZnRlciBzdHlsZVwiLHgsby5zdGFydCk7YnJlYWt9aWYody5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgcGFyYW1ldGVyIGFmdGVyIHN0eWxlPVwiLHgsMCk7cmV0dXJuIER9c3dpdGNoKHdbMF0udG9rZW4pe2Nhc2VcIm5vcm1hbFwiOmNhc2VcImhhcm1vbmljXCI6Y2FzZVwicmh5dGhtXCI6Y2FzZVwieFwiOmIuc3R5bGU9d1swXS50b2tlbjt3LnNoaWZ0KCk7YnJlYWs7ZGVmYXVsdDpmKFwiZXJyb3IgcGFyc2luZyBzdHlsZSBlbGVtZW50OiBcIit3WzBdLnRva2VuLHgsd1swXS5zdGFydCk7YnJlYWt9YnJlYWs7Y2FzZVwiY2xlZlwiOncuc2hpZnQoKTtpZih3Lmxlbmd0aD09PTApe2YoXCJFeHBlY3RlZCA9IGFmdGVyIGNsZWZcIix4LDApO3JldHVybiBEfW89dy5zaGlmdCgpO2lmKG8udG9rZW4hPT1cIj1cIil7ZihcIkV4cGVjdGVkID0gYWZ0ZXIgY2xlZlwiLHgsby5zdGFydCk7YnJlYWt9aWYody5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgcGFyYW1ldGVyIGFmdGVyIGNsZWY9XCIseCwwKTtyZXR1cm4gRH1jYXNlXCJ0cmVibGVcIjpjYXNlXCJiYXNzXCI6Y2FzZVwiYWx0b1wiOmNhc2VcInRlbm9yXCI6Y2FzZVwicGVyY1wiOnZhciB5PXcuc2hpZnQoKTtzd2l0Y2goeS50b2tlbil7Y2FzZVwidHJlYmxlXCI6Y2FzZVwidGVub3JcIjpjYXNlXCJhbHRvXCI6Y2FzZVwiYmFzc1wiOmNhc2VcInBlcmNcIjpjYXNlXCJub25lXCI6YnJlYWs7Y2FzZVwiQ1wiOnkudG9rZW49XCJhbHRvXCI7YnJlYWs7Y2FzZVwiRlwiOnkudG9rZW49XCJiYXNzXCI7YnJlYWs7Y2FzZVwiR1wiOnkudG9rZW49XCJ0cmVibGVcIjticmVhaztjYXNlXCJjXCI6eS50b2tlbj1cImFsdG9cIjticmVhaztjYXNlXCJmXCI6eS50b2tlbj1cImJhc3NcIjticmVhaztjYXNlXCJnXCI6eS50b2tlbj1cInRyZWJsZVwiO2JyZWFrO2RlZmF1bHQ6ZihcIkV4cGVjdGVkIGNsZWYgbmFtZS4gRm91bmQgXCIreS50b2tlbix4LHkuc3RhcnQpO2JyZWFrfWlmKHcubGVuZ3RoPjAmJndbMF0udHlwZT09PVwibnVtYmVyXCIpe3kudG9rZW4rPXdbMF0udG9rZW47dy5zaGlmdCgpfWlmKHcubGVuZ3RoPjEmJih3WzBdLnRva2VuPT09XCItXCJ8fHdbMF0udG9rZW49PT1cIitcIikmJndbMV0udG9rZW49PT1cIjhcIil7eS50b2tlbis9d1swXS50b2tlbit3WzFdLnRva2VuO3cuc2hpZnQoKTt3LnNoaWZ0KCl9Yi5jbGVmPXt0eXBlOnkudG9rZW4sdmVydGljYWxQb3M6aih5LnRva2VuLDApfTtELmZvdW5kQ2xlZj10cnVlO2JyZWFrO2RlZmF1bHQ6ZihcIlVua25vd24gcGFyYW1ldGVyOiBcIit3WzBdLnRva2VuLHgsd1swXS5zdGFydCk7dy5zaGlmdCgpfX1yZXR1cm4gRH07dmFyIGc9ZnVuY3Rpb24oayl7Yi5jdXJyZW50Vm9pY2U9Yi52b2ljZXNba107ZS5zZXRDdXJyZW50Vm9pY2UoYi5jdXJyZW50Vm9pY2Uuc3RhZmZOdW0sYi5jdXJyZW50Vm9pY2UuaW5kZXgpfTt3aW5kb3cuQUJDSlMucGFyc2UucGFyc2VLZXlWb2ljZS5wYXJzZVZvaWNlPWZ1bmN0aW9uKG4seCx5KXt2YXIgQz1pLmdldE1lYXQobix4LHkpO3ZhciBsPUMuc3RhcnQ7dmFyIGs9Qy5lbmQ7dmFyIHI9aS5nZXRUb2tlbihuLGwsayk7aWYoci5sZW5ndGg9PT0wKXtmKFwiRXhwZWN0ZWQgYSB2b2ljZSBpZFwiLG4sbCk7cmV0dXJufXZhciBBPWZhbHNlO2lmKGIudm9pY2VzW3JdPT09dW5kZWZpbmVkKXtiLnZvaWNlc1tyXT17fTtBPXRydWU7aWYoYi5zY29yZV9pc19wcmVzZW50KXtmKFwiQ2FuJ3QgaGF2ZSBhbiB1bmtub3duIFY6IGlkIHdoZW4gdGhlICVzY29yZSBkaXJlY3RpdmUgaXMgcHJlc2VudFwiLG4sbCl9fWwrPXIubGVuZ3RoO2wrPWkuZWF0V2hpdGVTcGFjZShuLGwpO3ZhciBwPXtzdGFydFN0YWZmOkF9O3ZhciBEPWZ1bmN0aW9uKHYpe3ZhciBzPWkuZ2V0Vm9pY2VUb2tlbihuLGwsayk7aWYocy53YXJuIT09dW5kZWZpbmVkKXtmKFwiRXhwZWN0ZWQgdmFsdWUgZm9yIFwiK3YrXCIgaW4gdm9pY2U6IFwiK3Mud2FybixuLGwpfWVsc2V7aWYocy50b2tlbi5sZW5ndGg9PT0wJiZuLmNoYXJBdChsKSE9PSdcIicpe2YoXCJFeHBlY3RlZCB2YWx1ZSBmb3IgXCIrditcIiBpbiB2b2ljZVwiLG4sbClcbn1lbHNle3Bbdl09cy50b2tlbn19bCs9cy5sZW59O3ZhciB6PWZ1bmN0aW9uKEYsdixFKXt2YXIgcz1pLmdldFZvaWNlVG9rZW4obixsLGspO2lmKHMud2FybiE9PXVuZGVmaW5lZCl7ZihcIkV4cGVjdGVkIHZhbHVlIGZvciBcIit2K1wiIGluIHZvaWNlOiBcIitzLndhcm4sbixsKX1lbHNle2lmKHMudG9rZW4ubGVuZ3RoPT09MCYmbi5jaGFyQXQobCkhPT0nXCInKXtmKFwiRXhwZWN0ZWQgdmFsdWUgZm9yIFwiK3YrXCIgaW4gdm9pY2VcIixuLGwpfWVsc2V7aWYoRT09PVwibnVtYmVyXCIpe3MudG9rZW49cGFyc2VGbG9hdChzLnRva2VuKX1iLnZvaWNlc1tGXVt2XT1zLnRva2VufX1sKz1zLmxlbn07d2hpbGUobDxrKXt2YXIgbT1pLmdldFZvaWNlVG9rZW4obixsLGspO2wrPW0ubGVuO2lmKG0ud2Fybil7ZihcIkVycm9yIHBhcnNpbmcgdm9pY2U6IFwiK20ud2FybixuLGwpfWVsc2V7dmFyIHU9bnVsbDtzd2l0Y2gobS50b2tlbil7Y2FzZVwiY2xlZlwiOmNhc2VcImNsXCI6RChcImNsZWZcIik7dmFyIHQ9MDtpZihwLmNsZWYhPT11bmRlZmluZWQpe3AuY2xlZj1wLmNsZWYucmVwbGFjZSgvWycsXS9nLFwiXCIpO2lmKHAuY2xlZi5pbmRleE9mKFwiKzE2XCIpIT09LTEpe3QrPTE0O3AuY2xlZj1wLmNsZWYucmVwbGFjZShcIisxNlwiLFwiXCIpfXAudmVydGljYWxQb3M9aihwLmNsZWYsdCl9YnJlYWs7Y2FzZVwidHJlYmxlXCI6Y2FzZVwiYmFzc1wiOmNhc2VcInRlbm9yXCI6Y2FzZVwiYWx0b1wiOmNhc2VcIm5vbmVcIjpjYXNlXCJ0cmVibGUnXCI6Y2FzZVwiYmFzcydcIjpjYXNlXCJ0ZW5vcidcIjpjYXNlXCJhbHRvJ1wiOmNhc2VcIm5vbmUnXCI6Y2FzZVwidHJlYmxlJydcIjpjYXNlXCJiYXNzJydcIjpjYXNlXCJ0ZW5vcicnXCI6Y2FzZVwiYWx0bycnXCI6Y2FzZVwibm9uZScnXCI6Y2FzZVwidHJlYmxlLFwiOmNhc2VcImJhc3MsXCI6Y2FzZVwidGVub3IsXCI6Y2FzZVwiYWx0byxcIjpjYXNlXCJub25lLFwiOmNhc2VcInRyZWJsZSwsXCI6Y2FzZVwiYmFzcywsXCI6Y2FzZVwidGVub3IsLFwiOmNhc2VcImFsdG8sLFwiOmNhc2VcIm5vbmUsLFwiOnZhciB3PTA7cC5jbGVmPW0udG9rZW4ucmVwbGFjZSgvWycsXS9nLFwiXCIpO3AudmVydGljYWxQb3M9aihwLmNsZWYsdyk7YnJlYWs7Y2FzZVwic3RhdmVzXCI6Y2FzZVwic3RhdmVcIjpjYXNlXCJzdHZcIjpEKFwic3RhdmVzXCIpO2JyZWFrO2Nhc2VcImJyYWNlXCI6Y2FzZVwiYnJjXCI6RChcImJyYWNlXCIpO2JyZWFrO2Nhc2VcImJyYWNrZXRcIjpjYXNlXCJicmtcIjpEKFwiYnJhY2tldFwiKTticmVhaztjYXNlXCJuYW1lXCI6Y2FzZVwibm1cIjpEKFwibmFtZVwiKTticmVhaztjYXNlXCJzdWJuYW1lXCI6Y2FzZVwic25hbWVcIjpjYXNlXCJzbm1cIjpEKFwic3VibmFtZVwiKTticmVhaztjYXNlXCJtZXJnZVwiOnAuc3RhcnRTdGFmZj1mYWxzZTticmVhaztjYXNlXCJzdGVtc1wiOnU9aS5nZXRWb2ljZVRva2VuKG4sbCxrKTtpZih1Lndhcm4hPT11bmRlZmluZWQpe2YoXCJFeHBlY3RlZCB2YWx1ZSBmb3Igc3RlbXMgaW4gdm9pY2U6IFwiK3Uud2FybixuLGwpfWVsc2V7aWYodS50b2tlbj09PVwidXBcInx8dS50b2tlbj09PVwiZG93blwiKXtiLnZvaWNlc1tyXS5zdGVtPXUudG9rZW59ZWxzZXtmKFwiRXhwZWN0ZWQgdXAgb3IgZG93biBmb3Igdm9pY2Ugc3RlbVwiLG4sbCl9fWwrPXUubGVuO2JyZWFrO2Nhc2VcInVwXCI6Y2FzZVwiZG93blwiOmIudm9pY2VzW3JdLnN0ZW09bS50b2tlbjticmVhaztjYXNlXCJtaWRkbGVcIjpjYXNlXCJtXCI6RChcInZlcnRpY2FsUG9zXCIpO3AudmVydGljYWxQb3M9YShwLnZlcnRpY2FsUG9zKS5taWQ7YnJlYWs7Y2FzZVwiZ2Nob3Jkc1wiOmNhc2VcImdjaFwiOmIudm9pY2VzW3JdLnN1cHByZXNzQ2hvcmRzPXRydWU7YnJlYWs7Y2FzZVwic3BhY2VcIjpjYXNlXCJzcGNcIjpEKFwic3BhY2luZ1wiKTticmVhaztjYXNlXCJzY2FsZVwiOnoocixcInNjYWxlXCIsXCJudW1iZXJcIik7YnJlYWs7Y2FzZVwidHJhbnNwb3NlXCI6eihyLFwidHJhbnNwb3NlXCIsXCJudW1iZXJcIik7YnJlYWt9fWwrPWkuZWF0V2hpdGVTcGFjZShuLGwpfWlmKHAuc3RhcnRTdGFmZnx8Yi5zdGF2ZXMubGVuZ3RoPT09MCl7Yi5zdGF2ZXMucHVzaCh7aW5kZXg6Yi5zdGF2ZXMubGVuZ3RoLG1ldGVyOmIub3JpZ01ldGVyfSk7aWYoIWIuc2NvcmVfaXNfcHJlc2VudCl7Yi5zdGF2ZXNbYi5zdGF2ZXMubGVuZ3RoLTFdLm51bVZvaWNlcz0wfX1pZihiLnZvaWNlc1tyXS5zdGFmZk51bT09PXVuZGVmaW5lZCl7Yi52b2ljZXNbcl0uc3RhZmZOdW09Yi5zdGF2ZXMubGVuZ3RoLTE7dmFyIEI9MDtmb3IodmFyIG8gaW4gYi52b2ljZXMpe2lmKGIudm9pY2VzLmhhc093blByb3BlcnR5KG8pKXtpZihiLnZvaWNlc1tvXS5zdGFmZk51bT09PWIudm9pY2VzW3JdLnN0YWZmTnVtKXtCKyt9fX1iLnZvaWNlc1tyXS5pbmRleD1CLTF9dmFyIHE9Yi5zdGF2ZXNbYi52b2ljZXNbcl0uc3RhZmZOdW1dO2lmKCFiLnNjb3JlX2lzX3ByZXNlbnQpe3EubnVtVm9pY2VzKyt9aWYocC5jbGVmKXtxLmNsZWY9e3R5cGU6cC5jbGVmLHZlcnRpY2FsUG9zOnAudmVydGljYWxQb3N9fWlmKHAuc3BhY2luZyl7cS5zcGFjaW5nX2JlbG93X29mZnNldD1wLnNwYWNpbmd9aWYocC52ZXJ0aWNhbFBvcyl7cS52ZXJ0aWNhbFBvcz1wLnZlcnRpY2FsUG9zfWlmKHAubmFtZSl7aWYocS5uYW1lKXtxLm5hbWUucHVzaChwLm5hbWUpfWVsc2V7cS5uYW1lPVtwLm5hbWVdfX1pZihwLnN1Ym5hbWUpe2lmKHEuc3VibmFtZSl7cS5zdWJuYW1lLnB1c2gocC5zdWJuYW1lKX1lbHNle3Euc3VibmFtZT1bcC5zdWJuYW1lXX19ZyhyKX19KSgpO2lmKCF3aW5kb3cuQUJDSlMpe3dpbmRvdy5BQkNKUz17fX1pZighd2luZG93LkFCQ0pTLnBhcnNlKXt3aW5kb3cuQUJDSlMucGFyc2U9e319d2luZG93LkFCQ0pTLnBhcnNlLnRva2VuaXplcj1mdW5jdGlvbigpe3RoaXMuc2tpcFdoaXRlU3BhY2U9ZnVuY3Rpb24oail7Zm9yKHZhciBoPTA7aDxqLmxlbmd0aDtoKyspe2lmKCF0aGlzLmlzV2hpdGVTcGFjZShqLmNoYXJBdChoKSkpe3JldHVybiBofX1yZXR1cm4gai5sZW5ndGh9O3ZhciBnPWZ1bmN0aW9uKGosaCl7cmV0dXJuIGg+PWoubGVuZ3RofTt0aGlzLmVhdFdoaXRlU3BhY2U9ZnVuY3Rpb24oaCxqKXtmb3IodmFyIGs9ajtrPGgubGVuZ3RoO2srKyl7aWYoIXRoaXMuaXNXaGl0ZVNwYWNlKGguY2hhckF0KGspKSl7cmV0dXJuIGstan19cmV0dXJuIGstan07dGhpcy5nZXRLZXlQaXRjaD1mdW5jdGlvbihqKXt2YXIgaD10aGlzLnNraXBXaGl0ZVNwYWNlKGopO2lmKGcoaixoKSl7cmV0dXJue2xlbjowfX1zd2l0Y2goai5jaGFyQXQoaCkpe2Nhc2VcIkFcIjpyZXR1cm57bGVuOmgrMSx0b2tlbjpcIkFcIn07Y2FzZVwiQlwiOnJldHVybntsZW46aCsxLHRva2VuOlwiQlwifTtjYXNlXCJDXCI6cmV0dXJue2xlbjpoKzEsdG9rZW46XCJDXCJ9O2Nhc2VcIkRcIjpyZXR1cm57bGVuOmgrMSx0b2tlbjpcIkRcIn07Y2FzZVwiRVwiOnJldHVybntsZW46aCsxLHRva2VuOlwiRVwifTtjYXNlXCJGXCI6cmV0dXJue2xlbjpoKzEsdG9rZW46XCJGXCJ9O2Nhc2VcIkdcIjpyZXR1cm57bGVuOmgrMSx0b2tlbjpcIkdcIn19cmV0dXJue2xlbjowfX07dGhpcy5nZXRTaGFycEZsYXQ9ZnVuY3Rpb24oaCl7aWYoaD09PVwiYmFzc1wiKXtyZXR1cm57bGVuOjB9fXN3aXRjaChoLmNoYXJBdCgwKSl7Y2FzZVwiI1wiOnJldHVybntsZW46MSx0b2tlbjpcIiNcIn07Y2FzZVwiYlwiOnJldHVybntsZW46MSx0b2tlbjpcImJcIn19cmV0dXJue2xlbjowfX07dGhpcy5nZXRNb2RlPWZ1bmN0aW9uKGwpe3ZhciBrPWZ1bmN0aW9uKGksbSl7d2hpbGUobTxpLmxlbmd0aCYmKChpLmNoYXJBdChtKT49XCJhXCImJmkuY2hhckF0KG0pPD1cInpcIil8fChpLmNoYXJBdChtKT49XCJBXCImJmkuY2hhckF0KG0pPD1cIlpcIikpKXttKyt9cmV0dXJuIG19O3ZhciBqPXRoaXMuc2tpcFdoaXRlU3BhY2UobCk7aWYoZyhsLGopKXtyZXR1cm57bGVuOjB9fXZhciBoPWwuc3Vic3RyaW5nKGosaiszKS50b0xvd2VyQ2FzZSgpO2lmKGgubGVuZ3RoPjEmJmguY2hhckF0KDEpPT09XCIgXCJ8fGguY2hhckF0KDEpPT09XCJeXCJ8fGguY2hhckF0KDEpPT09XCJfXCJ8fGguY2hhckF0KDEpPT09XCI9XCIpe2g9aC5jaGFyQXQoMCl9c3dpdGNoKGgpe2Nhc2VcIm1peFwiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwiTWl4XCJ9O2Nhc2VcImRvclwiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwiRG9yXCJ9O2Nhc2VcInBoclwiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwiUGhyXCJ9O2Nhc2VcImx5ZFwiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwiTHlkXCJ9O2Nhc2VcImxvY1wiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwiTG9jXCJ9O2Nhc2VcImFlb1wiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwibVwifTtjYXNlXCJtYWpcIjpyZXR1cm57bGVuOmsobCxqKSx0b2tlbjpcIlwifTtjYXNlXCJpb25cIjpyZXR1cm57bGVuOmsobCxqKSx0b2tlbjpcIlwifTtjYXNlXCJtaW5cIjpyZXR1cm57bGVuOmsobCxqKSx0b2tlbjpcIm1cIn07Y2FzZVwibVwiOnJldHVybntsZW46ayhsLGopLHRva2VuOlwibVwifX1yZXR1cm57bGVuOjB9fTt0aGlzLmdldENsZWY9ZnVuY3Rpb24obyxuKXt2YXIgaD1vO3ZhciBtPXRoaXMuc2tpcFdoaXRlU3BhY2Uobyk7aWYoZyhvLG0pKXtyZXR1cm57bGVuOjB9fXZhciBxPWZhbHNlO3ZhciBwPW8uc3Vic3RyaW5nKG0pO2lmKHdpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKHAsXCJjbGVmPVwiKSl7cT10cnVlO3A9cC5zdWJzdHJpbmcoNSk7bSs9NX1pZihwLmxlbmd0aD09PTAmJnEpe3JldHVybntsZW46bSs1LHdhcm46XCJObyBjbGVmIHNwZWNpZmllZDogXCIraH19dmFyIGw9dGhpcy5za2lwV2hpdGVTcGFjZShwKTtpZihnKHAsbCkpe3JldHVybntsZW46MH19aWYobD4wKXttKz1sO3A9cC5zdWJzdHJpbmcobCl9dmFyIGs9bnVsbDtpZih3aW5kb3cuQUJDSlMucGFyc2Uuc3RhcnRzV2l0aChwLFwidHJlYmxlXCIpKXtrPVwidHJlYmxlXCJ9ZWxzZXtpZih3aW5kb3cuQUJDSlMucGFyc2Uuc3RhcnRzV2l0aChwLFwiYmFzczNcIikpe2s9XCJiYXNzM1wifWVsc2V7aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgocCxcImJhc3NcIikpe2s9XCJiYXNzXCJ9ZWxzZXtpZih3aW5kb3cuQUJDSlMucGFyc2Uuc3RhcnRzV2l0aChwLFwidGVub3JcIikpe2s9XCJ0ZW5vclwifWVsc2V7aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgocCxcImFsdG8yXCIpKXtrPVwiYWx0bzJcIn1lbHNle2lmKHdpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKHAsXCJhbHRvMVwiKSl7az1cImFsdG8xXCJ9ZWxzZXtpZih3aW5kb3cuQUJDSlMucGFyc2Uuc3RhcnRzV2l0aChwLFwiYWx0b1wiKSl7az1cImFsdG9cIn1lbHNle2lmKCFuJiYocSYmd2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgocCxcIm5vbmVcIikpKXtrPVwibm9uZVwifWVsc2V7aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgocCxcInBlcmNcIikpe2s9XCJwZXJjXCJ9ZWxzZXtpZighbiYmKHEmJndpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKHAsXCJDXCIpKSl7az1cInRlbm9yXCJ9ZWxzZXtpZighbiYmKHEmJndpbmRvdy5BQkNKUy5wYXJzZS5zdGFydHNXaXRoKHAsXCJGXCIpKSl7az1cImJhc3NcIn1lbHNle2lmKCFuJiYocSYmd2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgocCxcIkdcIikpKXtrPVwidHJlYmxlXCJ9ZWxzZXtyZXR1cm57bGVuOm0rNSx3YXJuOlwiVW5rbm93biBjbGVmIHNwZWNpZmllZDogXCIraH19fX19fX19fX19fX1wPXAuc3Vic3RyaW5nKGsubGVuZ3RoKTtsPXRoaXMuaXNNYXRjaChwLFwiKzhcIik7aWYobD4wKXtrKz1cIis4XCJ9ZWxzZXtsPXRoaXMuaXNNYXRjaChwLFwiLThcIik7aWYobD4wKXtrKz1cIi04XCJ9fXJldHVybntsZW46bStrLmxlbmd0aCx0b2tlbjprLGV4cGxpY2l0OnF9fTt0aGlzLmdldEJhckxpbmU9ZnVuY3Rpb24oaCxrKXtzd2l0Y2goaC5jaGFyQXQoaykpe2Nhc2VcIl1cIjorK2s7c3dpdGNoKGguY2hhckF0KGspKXtjYXNlXCJ8XCI6cmV0dXJue2xlbjoyLHRva2VuOlwiYmFyX3RoaWNrX3RoaW5cIn07Y2FzZVwiW1wiOisraztpZigoaC5jaGFyQXQoayk+PVwiMVwiJiZoLmNoYXJBdChrKTw9XCI5XCIpfHxoLmNoYXJBdChrKT09PSdcIicpe3JldHVybntsZW46Mix0b2tlbjpcImJhcl9pbnZpc2libGVcIn19cmV0dXJue2xlbjoxLHdhcm46XCJVbmtub3duIGJhciBzeW1ib2xcIn07ZGVmYXVsdDpyZXR1cm57bGVuOjEsdG9rZW46XCJiYXJfaW52aXNpYmxlXCJ9fWJyZWFrO2Nhc2VcIjpcIjorK2s7c3dpdGNoKGguY2hhckF0KGspKXtjYXNlXCI6XCI6cmV0dXJue2xlbjoyLHRva2VuOlwiYmFyX2RibF9yZXBlYXRcIn07Y2FzZVwifFwiOisraztzd2l0Y2goaC5jaGFyQXQoaykpe2Nhc2VcIl1cIjorK2s7c3dpdGNoKGguY2hhckF0KGspKXtjYXNlXCJ8XCI6KytrO2lmKGguY2hhckF0KGspPT09XCI6XCIpe3JldHVybntsZW46NSx0b2tlbjpcImJhcl9kYmxfcmVwZWF0XCJ9fXJldHVybntsZW46Myx0b2tlbjpcImJhcl9yaWdodF9yZXBlYXRcIn07ZGVmYXVsdDpyZXR1cm57bGVuOjMsdG9rZW46XCJiYXJfcmlnaHRfcmVwZWF0XCJ9fWJyZWFrO2Nhc2VcInxcIjorK2s7aWYoaC5jaGFyQXQoayk9PT1cIjpcIil7cmV0dXJue2xlbjo0LHRva2VuOlwiYmFyX2RibF9yZXBlYXRcIn19cmV0dXJue2xlbjozLHRva2VuOlwiYmFyX3JpZ2h0X3JlcGVhdFwifTtkZWZhdWx0OnJldHVybntsZW46Mix0b2tlbjpcImJhcl9yaWdodF9yZXBlYXRcIn19YnJlYWs7ZGVmYXVsdDpyZXR1cm57bGVuOjEsd2FybjpcIlVua25vd24gYmFyIHN5bWJvbFwifX1icmVhaztjYXNlXCJbXCI6KytrO2lmKGguY2hhckF0KGspPT09XCJ8XCIpeysraztzd2l0Y2goaC5jaGFyQXQoaykpe2Nhc2VcIjpcIjpyZXR1cm57bGVuOjMsdG9rZW46XCJiYXJfbGVmdF9yZXBlYXRcIn07Y2FzZVwiXVwiOnJldHVybntsZW46Myx0b2tlbjpcImJhcl9pbnZpc2libGVcIn07ZGVmYXVsdDpyZXR1cm57bGVuOjIsdG9rZW46XCJiYXJfdGhpY2tfdGhpblwifX19ZWxzZXtpZigoaC5jaGFyQXQoayk+PVwiMVwiJiZoLmNoYXJBdChrKTw9XCI5XCIpfHxoLmNoYXJBdChrKT09PSdcIicpe3JldHVybntsZW46MSx0b2tlbjpcImJhcl9pbnZpc2libGVcIn19cmV0dXJue2xlbjowfX1icmVhaztjYXNlXCJ8XCI6KytrO3N3aXRjaChoLmNoYXJBdChrKSl7Y2FzZVwiXVwiOnJldHVybntsZW46Mix0b2tlbjpcImJhcl90aGluX3RoaWNrXCJ9O2Nhc2VcInxcIjorK2s7aWYoaC5jaGFyQXQoayk9PT1cIjpcIil7cmV0dXJue2xlbjozLHRva2VuOlwiYmFyX2xlZnRfcmVwZWF0XCJ9fXJldHVybntsZW46Mix0b2tlbjpcImJhcl90aGluX3RoaW5cIn07XG5jYXNlXCI6XCI6dmFyIGo9MDt3aGlsZShoLmNoYXJBdChrK2opPT09XCI6XCIpe2orK31yZXR1cm57bGVuOjEraix0b2tlbjpcImJhcl9sZWZ0X3JlcGVhdFwifTtkZWZhdWx0OnJldHVybntsZW46MSx0b2tlbjpcImJhcl90aGluXCJ9fWJyZWFrfXJldHVybntsZW46MH19O3RoaXMuZ2V0VG9rZW5PZj1mdW5jdGlvbihrLGope2Zvcih2YXIgaD0wO2g8ay5sZW5ndGg7aCsrKXtpZihqLmluZGV4T2Yoay5jaGFyQXQoaCkpPDApe3JldHVybntsZW46aCx0b2tlbjprLnN1YnN0cmluZygwLGgpfX19cmV0dXJue2xlbjpoLHRva2VuOmt9fTt0aGlzLmdldFRva2VuPWZ1bmN0aW9uKGssbCxoKXt2YXIgaj1sO3doaWxlKGo8aCYmIXRoaXMuaXNXaGl0ZVNwYWNlKGsuY2hhckF0KGopKSl7aisrfXJldHVybiBrLnN1YnN0cmluZyhsLGopfTt0aGlzLmlzTWF0Y2g9ZnVuY3Rpb24oayxoKXt2YXIgaj10aGlzLnNraXBXaGl0ZVNwYWNlKGspO2lmKGcoayxqKSl7cmV0dXJuIDB9aWYod2luZG93LkFCQ0pTLnBhcnNlLnN0YXJ0c1dpdGgoay5zdWJzdHJpbmcoaiksaCkpe3JldHVybiBqK2gubGVuZ3RofXJldHVybiAwfTt0aGlzLmdldFBpdGNoRnJvbVRva2Vucz1mdW5jdGlvbihqKXt2YXIgaD17fTt2YXIgaT17QTo1LEI6NixDOjAsRDoxLEU6MixGOjMsRzo0LGE6MTIsYjoxMyxjOjcsZDo4LGU6OSxmOjEwLGc6MTF9O2gucG9zaXRpb249aVtqWzBdLnRva2VuXTtpZihoLnBvc2l0aW9uPT09dW5kZWZpbmVkKXtyZXR1cm57d2FybjpcIlBpdGNoIGV4cGVjdGVkLiBGb3VuZDogXCIralswXS50b2tlbn19ai5zaGlmdCgpO3doaWxlKGoubGVuZ3RoKXtzd2l0Y2goalswXS50b2tlbil7Y2FzZVwiLFwiOmgucG9zaXRpb24tPTc7ai5zaGlmdCgpO2JyZWFrO2Nhc2VcIidcIjpoLnBvc2l0aW9uKz03O2ouc2hpZnQoKTticmVhaztkZWZhdWx0OnJldHVybiBofX1yZXR1cm4gaH07dGhpcy5nZXRLZXlBY2NpZGVudGFsczI9ZnVuY3Rpb24oail7dmFyIGg7d2hpbGUoai5sZW5ndGg+MCl7dmFyIGk7aWYoalswXS50b2tlbj09PVwiXlwiKXtpPVwic2hhcnBcIjtqLnNoaWZ0KCk7aWYoai5sZW5ndGg9PT0wKXtyZXR1cm57YWNjczpoLHdhcm46XCJFeHBlY3RlZCBub3RlIG5hbWUgYWZ0ZXIgXCIraX19c3dpdGNoKGpbMF0udG9rZW4pe2Nhc2VcIl5cIjppPVwiZGJsc2hhcnBcIjtqLnNoaWZ0KCk7YnJlYWs7Y2FzZVwiL1wiOmk9XCJxdWFydGVyc2hhcnBcIjtqLnNoaWZ0KCk7YnJlYWt9fWVsc2V7aWYoalswXS50b2tlbj09PVwiPVwiKXtpPVwibmF0dXJhbFwiO2ouc2hpZnQoKX1lbHNle2lmKGpbMF0udG9rZW49PT1cIl9cIil7aT1cImZsYXRcIjtqLnNoaWZ0KCk7aWYoai5sZW5ndGg9PT0wKXtyZXR1cm57YWNjczpoLHdhcm46XCJFeHBlY3RlZCBub3RlIG5hbWUgYWZ0ZXIgXCIraX19c3dpdGNoKGpbMF0udG9rZW4pe2Nhc2VcIl9cIjppPVwiZGJsZmxhdFwiO2ouc2hpZnQoKTticmVhaztjYXNlXCIvXCI6aT1cInF1YXJ0ZXJmbGF0XCI7ai5zaGlmdCgpO2JyZWFrfX1lbHNle3JldHVybnthY2NzOmh9fX19aWYoai5sZW5ndGg9PT0wKXtyZXR1cm57YWNjczpoLHdhcm46XCJFeHBlY3RlZCBub3RlIG5hbWUgYWZ0ZXIgXCIraX19c3dpdGNoKGpbMF0udG9rZW4uY2hhckF0KDApKXtjYXNlXCJhXCI6Y2FzZVwiYlwiOmNhc2VcImNcIjpjYXNlXCJkXCI6Y2FzZVwiZVwiOmNhc2VcImZcIjpjYXNlXCJnXCI6Y2FzZVwiQVwiOmNhc2VcIkJcIjpjYXNlXCJDXCI6Y2FzZVwiRFwiOmNhc2VcIkVcIjpjYXNlXCJGXCI6Y2FzZVwiR1wiOmlmKGg9PT11bmRlZmluZWQpe2g9W119aC5wdXNoKHthY2M6aSxub3RlOmpbMF0udG9rZW4uY2hhckF0KDApfSk7aWYoalswXS50b2tlbi5sZW5ndGg9PT0xKXtqLnNoaWZ0KCl9ZWxzZXtqWzBdLnRva2VuPWpbMF0udG9rZW4uc3Vic3RyaW5nKDEpfWJyZWFrO2RlZmF1bHQ6cmV0dXJue2FjY3M6aCx3YXJuOlwiRXhwZWN0ZWQgbm90ZSBuYW1lIGFmdGVyIFwiK2krXCIgRm91bmQ6IFwiK2pbMF0udG9rZW59fX1yZXR1cm57YWNjczpofX07dGhpcy5nZXRLZXlBY2NpZGVudGFsPWZ1bmN0aW9uKGwpe3ZhciBrPXtcIl5cIjpcInNoYXJwXCIsXCJeXlwiOlwiZGJsc2hhcnBcIixcIj1cIjpcIm5hdHVyYWxcIixfOlwiZmxhdFwiLF9fOlwiZGJsZmxhdFwiLFwiXy9cIjpcInF1YXJ0ZXJmbGF0XCIsXCJeL1wiOlwicXVhcnRlcnNoYXJwXCJ9O3ZhciBoPXRoaXMuc2tpcFdoaXRlU3BhY2UobCk7aWYoZyhsLGgpKXtyZXR1cm57bGVuOjB9fXZhciBqPW51bGw7c3dpdGNoKGwuY2hhckF0KGgpKXtjYXNlXCJeXCI6Y2FzZVwiX1wiOmNhc2VcIj1cIjpqPWwuY2hhckF0KGgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJue2xlbjowfX1oKys7aWYoZyhsLGgpKXtyZXR1cm57bGVuOjEsd2FybjpcIkV4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciBhY2NpZGVudGFsXCJ9fXN3aXRjaChsLmNoYXJBdChoKSl7Y2FzZVwiYVwiOmNhc2VcImJcIjpjYXNlXCJjXCI6Y2FzZVwiZFwiOmNhc2VcImVcIjpjYXNlXCJmXCI6Y2FzZVwiZ1wiOmNhc2VcIkFcIjpjYXNlXCJCXCI6Y2FzZVwiQ1wiOmNhc2VcIkRcIjpjYXNlXCJFXCI6Y2FzZVwiRlwiOmNhc2VcIkdcIjpyZXR1cm57bGVuOmgrMSx0b2tlbjp7YWNjOmtbal0sbm90ZTpsLmNoYXJBdChoKX19O2Nhc2VcIl5cIjpjYXNlXCJfXCI6Y2FzZVwiL1wiOmorPWwuY2hhckF0KGgpO2grKztpZihnKGwsaCkpe3JldHVybntsZW46Mix3YXJuOlwiRXhwZWN0ZWQgbm90ZSBuYW1lIGFmdGVyIGFjY2lkZW50YWxcIn19c3dpdGNoKGwuY2hhckF0KGgpKXtjYXNlXCJhXCI6Y2FzZVwiYlwiOmNhc2VcImNcIjpjYXNlXCJkXCI6Y2FzZVwiZVwiOmNhc2VcImZcIjpjYXNlXCJnXCI6Y2FzZVwiQVwiOmNhc2VcIkJcIjpjYXNlXCJDXCI6Y2FzZVwiRFwiOmNhc2VcIkVcIjpjYXNlXCJGXCI6Y2FzZVwiR1wiOnJldHVybntsZW46aCsxLHRva2VuOnthY2M6a1tqXSxub3RlOmwuY2hhckF0KGgpfX07ZGVmYXVsdDpyZXR1cm57bGVuOjIsd2FybjpcIkV4cGVjdGVkIG5vdGUgbmFtZSBhZnRlciBhY2NpZGVudGFsXCJ9fWJyZWFrO2RlZmF1bHQ6cmV0dXJue2xlbjoxLHdhcm46XCJFeHBlY3RlZCBub3RlIG5hbWUgYWZ0ZXIgYWNjaWRlbnRhbFwifX19O3RoaXMuaXNXaGl0ZVNwYWNlPWZ1bmN0aW9uKGgpe3JldHVybiBoPT09XCIgXCJ8fGg9PT1cIlxcdFwifHxoPT09XCJcXHgxMlwifTt0aGlzLmdldE1lYXQ9ZnVuY3Rpb24oaSxrLGgpe3ZhciBqPWkuaW5kZXhPZihcIiVcIixrKTtpZihqPj0wJiZqPGgpe2g9an13aGlsZShrPGgmJihpLmNoYXJBdChrKT09PVwiIFwifHxpLmNoYXJBdChrKT09PVwiXFx0XCJ8fGkuY2hhckF0KGspPT09XCJcXHgxMlwiKSl7aysrfXdoaWxlKGs8aCYmKGkuY2hhckF0KGgtMSk9PT1cIiBcInx8aS5jaGFyQXQoaC0xKT09PVwiXFx0XCJ8fGkuY2hhckF0KGgtMSk9PT1cIlxceDEyXCIpKXtoLS19cmV0dXJue3N0YXJ0OmssZW5kOmh9fTt2YXIgZD1mdW5jdGlvbihoKXtyZXR1cm4oaD49XCJBXCImJmg8PVwiWlwiKXx8KGg+PVwiYVwiJiZoPD1cInpcIil9O3ZhciBjPWZ1bmN0aW9uKGgpe3JldHVybihoPj1cIjBcIiYmaDw9XCI5XCIpfTt0aGlzLnRva2VuaXplPWZ1bmN0aW9uKHIsaixrKXt2YXIgbj10aGlzLmdldE1lYXQocixqLGspO2o9bi5zdGFydDtrPW4uZW5kO3ZhciBwPVtdO3ZhciBsO3doaWxlKGo8ayl7aWYoci5jaGFyQXQoaik9PT0nXCInKXtsPWorMTt3aGlsZShsPGsmJnIuY2hhckF0KGwpIT09J1wiJyl7bCsrfXAucHVzaCh7dHlwZTpcInF1b3RlXCIsdG9rZW46ci5zdWJzdHJpbmcoaisxLGwpLHN0YXJ0OmorMSxlbmQ6bH0pO2wrK31lbHNle2lmKGQoci5jaGFyQXQoaikpKXtsPWorMTt3aGlsZShsPGsmJmQoci5jaGFyQXQobCkpKXtsKyt9cC5wdXNoKHt0eXBlOlwiYWxwaGFcIix0b2tlbjpyLnN1YnN0cmluZyhqLGwpLGNvbnRpbnVlSWQ6YyhyLmNoYXJBdChsKSksc3RhcnQ6aixlbmQ6bH0pO2o9bCsxfWVsc2V7aWYoci5jaGFyQXQoaik9PT1cIi5cIiYmYyhyLmNoYXJBdChsKzEpKSl7bD1qKzE7dmFyIHE9bnVsbDt2YXIgbT1udWxsO3doaWxlKGw8ayYmYyhyLmNoYXJBdChsKSkpe2wrK31tPXBhcnNlRmxvYXQoci5zdWJzdHJpbmcoaixsKSk7cC5wdXNoKHt0eXBlOlwibnVtYmVyXCIsdG9rZW46ci5zdWJzdHJpbmcoaixsKSxpbnR0OnEsZmxvYXR0Om0sY29udGludWVJZDpkKHIuY2hhckF0KGwpKSxzdGFydDpqLGVuZDpsfSk7aj1sKzF9ZWxzZXtpZihjKHIuY2hhckF0KGopKXx8KHIuY2hhckF0KGopPT09XCItXCImJmMoci5jaGFyQXQobCsxKSkpKXtsPWorMTt2YXIgaD1udWxsO3ZhciBvPW51bGw7d2hpbGUobDxrJiZjKHIuY2hhckF0KGwpKSl7bCsrfWlmKHIuY2hhckF0KGwpPT09XCIuXCImJmMoci5jaGFyQXQobCsxKSkpe2wrKzt3aGlsZShsPGsmJmMoci5jaGFyQXQobCkpKXtsKyt9fWVsc2V7aD1wYXJzZUludChyLnN1YnN0cmluZyhqLGwpKX1vPXBhcnNlRmxvYXQoci5zdWJzdHJpbmcoaixsKSk7cC5wdXNoKHt0eXBlOlwibnVtYmVyXCIsdG9rZW46ci5zdWJzdHJpbmcoaixsKSxpbnR0OmgsZmxvYXR0Om8sY29udGludWVJZDpkKHIuY2hhckF0KGwpKSxzdGFydDpqLGVuZDpsfSk7aj1sKzF9ZWxzZXtpZihyLmNoYXJBdChqKT09PVwiIFwifHxyLmNoYXJBdChqKT09PVwiXFx0XCIpe2w9aisxfWVsc2V7cC5wdXNoKHt0eXBlOlwicHVuY3RcIix0b2tlbjpyLmNoYXJBdChqKSxzdGFydDpqLGVuZDpqKzF9KTtsPWorMX19fX19aj1sfXJldHVybiBwfTt0aGlzLmdldFZvaWNlVG9rZW49ZnVuY3Rpb24oaixuLGgpe3ZhciBrPW47d2hpbGUoazxoJiZ0aGlzLmlzV2hpdGVTcGFjZShqLmNoYXJBdChrKSl8fGouY2hhckF0KGspPT09XCI9XCIpe2srK31pZihqLmNoYXJBdChrKT09PSdcIicpe3ZhciBtPWouaW5kZXhPZignXCInLGsrMSk7aWYobT09PS0xfHxtPj1oKXtyZXR1cm57bGVuOjEsZXJyOlwiTWlzc2luZyBjbG9zZSBxdW90ZVwifX1yZXR1cm57bGVuOm0tbisxLHRva2VuOnRoaXMudHJhbnNsYXRlU3RyaW5nKGouc3Vic3RyaW5nKGsrMSxtKSl9fWVsc2V7dmFyIGw9azt3aGlsZShsPGgmJiF0aGlzLmlzV2hpdGVTcGFjZShqLmNoYXJBdChsKSkmJmouY2hhckF0KGwpIT09XCI9XCIpe2wrK31yZXR1cm57bGVuOmwtbisxLHRva2VuOmouc3Vic3RyaW5nKGssbCl9fX07dmFyIGY9e1wiYGFcIjpcIsOgXCIsXCInYVwiOlwiw6FcIixcIl5hXCI6XCLDolwiLFwifmFcIjpcIsOjXCIsJ1wiYSc6XCLDpFwiLG9hOlwiw6VcIixcIj1hXCI6XCLEgVwiLHVhOlwixINcIixcIjthXCI6XCLEhVwiLFwiYGVcIjpcIsOoXCIsXCInZVwiOlwiw6lcIixcIl5lXCI6XCLDqlwiLCdcImUnOlwiw6tcIixcIj1lXCI6XCLEk1wiLHVlOlwixJVcIixcIjtlXCI6XCLEmVwiLFwiLmVcIjpcIsSXXCIsXCJgaVwiOlwiw6xcIixcIidpXCI6XCLDrVwiLFwiXmlcIjpcIsOuXCIsJ1wiaSc6XCLDr1wiLFwiPWlcIjpcIsSrXCIsdWk6XCLErVwiLFwiO2lcIjpcIsSvXCIsXCJgb1wiOlwiw7JcIixcIidvXCI6XCLDs1wiLFwiXm9cIjpcIsO0XCIsXCJ+b1wiOlwiw7VcIiwnXCJvJzpcIsO2XCIsXCI9b1wiOlwixY1cIix1bzpcIsWPXCIsXCIvb1wiOlwiw7hcIixcImB1XCI6XCLDuVwiLFwiJ3VcIjpcIsO6XCIsXCJedVwiOlwiw7tcIixcIn51XCI6XCLFqVwiLCdcInUnOlwiw7xcIixvdTpcIsWvXCIsXCI9dVwiOlwixatcIix1dTpcIsWtXCIsXCI7dVwiOlwixbNcIixcImBBXCI6XCLDgFwiLFwiJ0FcIjpcIsOBXCIsXCJeQVwiOlwiw4JcIixcIn5BXCI6XCLDg1wiLCdcIkEnOlwiw4RcIixvQTpcIsOFXCIsXCI9QVwiOlwixIBcIix1QTpcIsSCXCIsXCI7QVwiOlwixIRcIixcImBFXCI6XCLDiFwiLFwiJ0VcIjpcIsOJXCIsXCJeRVwiOlwiw4pcIiwnXCJFJzpcIsOLXCIsXCI9RVwiOlwixJJcIix1RTpcIsSUXCIsXCI7RVwiOlwixJhcIixcIi5FXCI6XCLEllwiLFwiYElcIjpcIsOMXCIsXCInSVwiOlwiw41cIixcIl5JXCI6XCLDjlwiLFwifklcIjpcIsSoXCIsJ1wiSSc6XCLDj1wiLFwiPUlcIjpcIsSqXCIsdUk6XCLErFwiLFwiO0lcIjpcIsSuXCIsXCIuSVwiOlwixLBcIixcImBPXCI6XCLDklwiLFwiJ09cIjpcIsOTXCIsXCJeT1wiOlwiw5RcIixcIn5PXCI6XCLDlVwiLCdcIk8nOlwiw5ZcIixcIj1PXCI6XCLFjFwiLHVPOlwixY5cIixcIi9PXCI6XCLDmFwiLFwiYFVcIjpcIsOZXCIsXCInVVwiOlwiw5pcIixcIl5VXCI6XCLDm1wiLFwiflVcIjpcIsWoXCIsJ1wiVSc6XCLDnFwiLG9VOlwixa5cIixcIj1VXCI6XCLFqlwiLHVVOlwixaxcIixcIjtVXCI6XCLFslwiLGFlOlwiw6ZcIixBRTpcIsOGXCIsb2U6XCLFk1wiLE9FOlwixZJcIixzczpcIsOfXCIsXCInY1wiOlwixIdcIixcIl5jXCI6XCLEiVwiLHVjOlwixI1cIixjYzpcIsOnXCIsXCIuY1wiOlwixItcIixjQzpcIsOHXCIsXCInQ1wiOlwixIZcIixcIl5DXCI6XCLEiFwiLHVDOlwixIxcIixcIi5DXCI6XCLEilwiLFwifm5cIjpcIsOxXCIsXCI9c1wiOlwixaFcIix2czpcIsWhXCIsdno6XCLFvlwifTt2YXIgZT17XCIjXCI6XCLima9cIixiOlwi4pmtXCIsXCI9XCI6XCLima5cIn07dmFyIGI9e1wiMjAxXCI6XCLima9cIixcIjIwMlwiOlwi4pmtXCIsXCIyMDNcIjpcIuKZrlwiLFwiMjQxXCI6XCLCoVwiLFwiMjQyXCI6XCLColwiLFwiMjUyXCI6XCJhXCIsXCIyNjJcIjpcIjJcIixcIjI3MlwiOlwib1wiLFwiMzAyXCI6XCLDglwiLFwiMzEyXCI6XCLDilwiLFwiMzIyXCI6XCLDklwiLFwiMzMyXCI6XCLDmlwiLFwiMzQyXCI6XCLDolwiLFwiMzUyXCI6XCLDqlwiLFwiMzYyXCI6XCLDslwiLFwiMzcyXCI6XCLDulwiLFwiMjQzXCI6XCLCo1wiLFwiMjUzXCI6XCLCq1wiLFwiMjYzXCI6XCIzXCIsXCIyNzNcIjpcIsK7XCIsXCIzMDNcIjpcIsODXCIsXCIzMTNcIjpcIsOLXCIsXCIzMjNcIjpcIsOTXCIsXCIzMzNcIjpcIsObXCIsXCIzNDNcIjpcIsOjXCIsXCIzNTNcIjpcIsOrXCIsXCIzNjNcIjpcIsOzXCIsXCIzNzNcIjpcIsO7XCIsXCIyNDRcIjpcIsKkXCIsXCIyNTRcIjpcIsKsXCIsXCIyNjRcIjpcIiAgzIFcIixcIjI3NFwiOlwiMeKBhDRcIixcIjMwNFwiOlwiw4RcIixcIjMxNFwiOlwiw4xcIixcIjMyNFwiOlwiw5RcIixcIjMzNFwiOlwiw5xcIixcIjM0NFwiOlwiw6RcIixcIjM1NFwiOlwiw6xcIixcIjM2NFwiOlwiw7RcIixcIjM3NFwiOlwiw7xcIixcIjI0NVwiOlwiwqVcIixcIjI1NVwiOlwiLVwiLFwiMjY1XCI6XCLOvFwiLFwiMjc1XCI6XCIx4oGEMlwiLFwiMzA1XCI6XCLDhVwiLFwiMzE1XCI6XCLDjVwiLFwiMzI1XCI6XCLDlVwiLFwiMzM1XCI6XCLDnVwiLFwiMzQ1XCI6XCLDpVwiLFwiMzU1XCI6XCLDrVwiLFwiMzY1XCI6XCLDtVwiLFwiMzc1XCI6XCLDvVwiLFwiMjQ2XCI6XCLCplwiLFwiMjU2XCI6XCLCrlwiLFwiMjY2XCI6XCLCtlwiLFwiMjc2XCI6XCIz4oGENFwiLFwiMzA2XCI6XCLDhlwiLFwiMzE2XCI6XCLDjlwiLFwiMzI2XCI6XCLDllwiLFwiMzM2XCI6XCLDnlwiLFwiMzQ2XCI6XCLDplwiLFwiMzU2XCI6XCLDrlwiLFwiMzY2XCI6XCLDtlwiLFwiMzc2XCI6XCLDvlwiLFwiMjQ3XCI6XCLCp1wiLFwiMjU3XCI6XCIgzIRcIixcIjI2N1wiOlwiwrdcIixcIjI3N1wiOlwiwr9cIixcIjMwN1wiOlwiw4dcIixcIjMxN1wiOlwiw49cIixcIjMyN1wiOlwiw5dcIixcIjMzN1wiOlwiw59cIixcIjM0N1wiOlwiw6dcIixcIjM1N1wiOlwiw69cIixcIjM2N1wiOlwiw7dcIixcIjM3N1wiOlwiw79cIixcIjI1MFwiOlwiIMyIXCIsXCIyNjBcIjpcIsKwXCIsXCIyNzBcIjpcIiDMp1wiLFwiMzAwXCI6XCLDgFwiLFwiMzEwXCI6XCLDiFwiLFwiMzIwXCI6XCLDkFwiLFwiMzMwXCI6XCLDmFwiLFwiMzQwXCI6XCLDoFwiLFwiMzUwXCI6XCLDqFwiLFwiMzYwXCI6XCLDsFwiLFwiMzcwXCI6XCLDuFwiLFwiMjUxXCI6XCLCqVwiLFwiMjYxXCI6XCLCsVwiLFwiMjcxXCI6XCIxXCIsXCIzMDFcIjpcIsOBXCIsXCIzMTFcIjpcIsOJXCIsXCIzMjFcIjpcIsORXCIsXCIzMzFcIjpcIsOZXCIsXCIzNDFcIjpcIsOhXCIsXCIzNTFcIjpcIsOpXCIsXCIzNjFcIjpcIsOxXCIsXCIzNzFcIjpcIsO5XCJ9O3RoaXMudHJhbnNsYXRlU3RyaW5nPWZ1bmN0aW9uKGope3ZhciBoPWouc3BsaXQoXCJcXFxcXCIpO1xuaWYoaC5sZW5ndGg9PT0xKXtyZXR1cm4gan12YXIgaT1udWxsO3dpbmRvdy5BQkNKUy5wYXJzZS5lYWNoKGgsZnVuY3Rpb24oayl7aWYoaT09PW51bGwpe2k9a31lbHNle3ZhciBsPWZbay5zdWJzdHJpbmcoMCwyKV07aWYobCE9PXVuZGVmaW5lZCl7aSs9bCtrLnN1YnN0cmluZygyKX1lbHNle2w9YltrLnN1YnN0cmluZygwLDMpXTtpZihsIT09dW5kZWZpbmVkKXtpKz1sK2suc3Vic3RyaW5nKDMpfWVsc2V7bD1lW2suc3Vic3RyaW5nKDAsMSldO2lmKGwhPT11bmRlZmluZWQpe2krPWwray5zdWJzdHJpbmcoMSl9ZWxzZXtpKz1cIlxcXFxcIitrfX19fX0pO3JldHVybiBpfTt0aGlzLmdldE51bWJlcj1mdW5jdGlvbihoLGope3ZhciBpPTA7d2hpbGUoajxoLmxlbmd0aCl7c3dpdGNoKGguY2hhckF0KGopKXtjYXNlXCIwXCI6aT1pKjEwO2orKzticmVhaztjYXNlXCIxXCI6aT1pKjEwKzE7aisrO2JyZWFrO2Nhc2VcIjJcIjppPWkqMTArMjtqKys7YnJlYWs7Y2FzZVwiM1wiOmk9aSoxMCszO2orKzticmVhaztjYXNlXCI0XCI6aT1pKjEwKzQ7aisrO2JyZWFrO2Nhc2VcIjVcIjppPWkqMTArNTtqKys7YnJlYWs7Y2FzZVwiNlwiOmk9aSoxMCs2O2orKzticmVhaztjYXNlXCI3XCI6aT1pKjEwKzc7aisrO2JyZWFrO2Nhc2VcIjhcIjppPWkqMTArODtqKys7YnJlYWs7Y2FzZVwiOVwiOmk9aSoxMCs5O2orKzticmVhaztkZWZhdWx0OnJldHVybntudW06aSxpbmRleDpqfX19cmV0dXJue251bTppLGluZGV4Omp9fTt0aGlzLmdldEZyYWN0aW9uPWZ1bmN0aW9uKGgsayl7dmFyIGo9MTt2YXIgbz0xO2lmKGguY2hhckF0KGspIT09XCIvXCIpe3ZhciBpPXRoaXMuZ2V0TnVtYmVyKGgsayk7aj1pLm51bTtrPWkuaW5kZXh9aWYoaC5jaGFyQXQoayk9PT1cIi9cIil7aysrO2lmKGguY2hhckF0KGspPT09XCIvXCIpe3ZhciBuPTAuNTt3aGlsZShoLmNoYXJBdChrKyspPT09XCIvXCIpe249bi8yfXJldHVybnt2YWx1ZTpqKm4saW5kZXg6ay0xfX1lbHNle3ZhciBsPWs7dmFyIG09dGhpcy5nZXROdW1iZXIoaCxrKTtpZihtLm51bT09PTAmJmw9PT1rKXttLm51bT0yfWlmKG0ubnVtIT09MCl7bz1tLm51bX1rPW0uaW5kZXh9fXJldHVybnt2YWx1ZTpqL28saW5kZXg6a319O3RoaXMudGhlUmV2ZXJzZXI9ZnVuY3Rpb24oaCl7aWYod2luZG93LkFCQ0pTLnBhcnNlLmVuZHNXaXRoKGgsXCIsIFRoZVwiKSl7cmV0dXJuXCJUaGUgXCIraC5zdWJzdHJpbmcoMCxoLmxlbmd0aC01KX1pZih3aW5kb3cuQUJDSlMucGFyc2UuZW5kc1dpdGgoaCxcIiwgQVwiKSl7cmV0dXJuXCJBIFwiK2guc3Vic3RyaW5nKDAsaC5sZW5ndGgtMyl9cmV0dXJuIGh9O3RoaXMuc3RyaXBDb21tZW50PWZ1bmN0aW9uKGope3ZhciBoPWouaW5kZXhPZihcIiVcIik7aWYoaD49MCl7cmV0dXJuIHdpbmRvdy5BQkNKUy5wYXJzZS5zdHJpcChqLnN1YnN0cmluZygwLGgpKX1yZXR1cm4gd2luZG93LkFCQ0pTLnBhcnNlLnN0cmlwKGopfTt0aGlzLmdldEludD1mdW5jdGlvbihsKXt2YXIgaD1wYXJzZUludChsKTtpZihpc05hTihoKSl7cmV0dXJue2RpZ2l0czowfX12YXIgaz1cIlwiK2g7dmFyIGo9bC5pbmRleE9mKGspO3JldHVybnt2YWx1ZTpoLGRpZ2l0czpqK2subGVuZ3RofX07dGhpcy5nZXRGbG9hdD1mdW5jdGlvbihsKXt2YXIgaD1wYXJzZUZsb2F0KGwpO2lmKGlzTmFOKGgpKXtyZXR1cm57ZGlnaXRzOjB9fXZhciBrPVwiXCIraDt2YXIgaj1sLmluZGV4T2Yoayk7cmV0dXJue3ZhbHVlOmgsZGlnaXRzOmoray5sZW5ndGh9fTt0aGlzLmdldE1lYXN1cmVtZW50PWZ1bmN0aW9uKGspe2lmKGsubGVuZ3RoPT09MCl7cmV0dXJue3VzZWQ6MH19dmFyIGo9MTt2YXIgaT1cIlwiO2lmKGtbMF0udG9rZW49PT1cIi1cIil7ay5zaGlmdCgpO2k9XCItXCI7aisrfWVsc2V7aWYoa1swXS50eXBlIT09XCJudW1iZXJcIil7cmV0dXJue3VzZWQ6MH19fWkrPWsuc2hpZnQoKS50b2tlbjtpZihrLmxlbmd0aD09PTApe3JldHVybnt1c2VkOjEsdmFsdWU6cGFyc2VJbnQoaSl9fXZhciBoPWsuc2hpZnQoKTtpZihoLnRva2VuPT09XCIuXCIpe2orKztpZihrLmxlbmd0aD09PTApe3JldHVybnt1c2VkOmosdmFsdWU6cGFyc2VJbnQoaSl9fWlmKGtbMF0udHlwZT09PVwibnVtYmVyXCIpe2g9ay5zaGlmdCgpO2k9aStcIi5cIitoLnRva2VuO2orKztpZihrLmxlbmd0aD09PTApe3JldHVybnt1c2VkOmosdmFsdWU6cGFyc2VGbG9hdChpKX19fWg9ay5zaGlmdCgpfXN3aXRjaChoLnRva2VuKXtjYXNlXCJwdFwiOnJldHVybnt1c2VkOmorMSx2YWx1ZTpwYXJzZUZsb2F0KGkpfTtjYXNlXCJjbVwiOnJldHVybnt1c2VkOmorMSx2YWx1ZTpwYXJzZUZsb2F0KGkpLzIuNTQqNzJ9O2Nhc2VcImluXCI6cmV0dXJue3VzZWQ6aisxLHZhbHVlOnBhcnNlRmxvYXQoaSkqNzJ9O2RlZmF1bHQ6ay51bnNoaWZ0KGgpO3JldHVybnt1c2VkOmosdmFsdWU6cGFyc2VGbG9hdChpKX19cmV0dXJue3VzZWQ6MH19O3ZhciBhPWZ1bmN0aW9uKGgpe3doaWxlKGguaW5kZXhPZihcIlxcXFxuXCIpIT09LTEpe2g9aC5yZXBsYWNlKFwiXFxcXG5cIixcIlxcblwiKX1yZXR1cm4gaH07dGhpcy5nZXRCcmFja2V0dGVkU3Vic3RyaW5nPWZ1bmN0aW9uKGgsaixuLGwpe3ZhciBrPWx8fGguY2hhckF0KGopO3ZhciBtPWorMTt3aGlsZSgobTxoLmxlbmd0aCkmJihoLmNoYXJBdChtKSE9PWspKXsrK219aWYoaC5jaGFyQXQobSk9PT1rKXtyZXR1cm5bbS1qKzEsYShoLnN1YnN0cmluZyhqKzEsbSkpLHRydWVdfWVsc2V7bT1qK247aWYobT5oLmxlbmd0aC0xKXttPWgubGVuZ3RoLTF9cmV0dXJuW20taisxLGEoaC5zdWJzdHJpbmcoaisxLG0pKSxmYWxzZV19fX07aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMud3JpdGUpe3dpbmRvdy5BQkNKUy53cml0ZT17fX1BQkNKUy53cml0ZS5HbHlwaHM9ZnVuY3Rpb24oKXt2YXIgYT17XCJyZXN0cy53aG9sZVwiOntkOltbXCJNXCIsMC4wNiwwLjAzXSxbXCJsXCIsMC4wOSwtMC4wNl0sW1wibFwiLDUuNDYsMF0sW1wibFwiLDUuNDksMF0sW1wibFwiLDAuMDksMC4wNl0sW1wibFwiLDAuMDYsMC4wOV0sW1wibFwiLDAsMi4xOV0sW1wibFwiLDAsMi4xOV0sW1wibFwiLC0wLjA2LDAuMDldLFtcImxcIiwtMC4wOSwwLjA2XSxbXCJsXCIsLTUuNDksMF0sW1wibFwiLC01LjQ2LDBdLFtcImxcIiwtMC4wOSwtMC4wNl0sW1wibFwiLC0wLjA2LC0wLjA5XSxbXCJsXCIsMCwtMi4xOV0sW1wibFwiLDAsLTIuMTldLFtcInpcIl1dLHc6MTEuMjUsaDo0LjY4fSxcInJlc3RzLmhhbGZcIjp7ZDpbW1wiTVwiLDAuMDYsLTQuNjJdLFtcImxcIiwwLjA5LC0wLjA2XSxbXCJsXCIsNS40NiwwXSxbXCJsXCIsNS40OSwwXSxbXCJsXCIsMC4wOSwwLjA2XSxbXCJsXCIsMC4wNiwwLjA5XSxbXCJsXCIsMCwyLjE5XSxbXCJsXCIsMCwyLjE5XSxbXCJsXCIsLTAuMDYsMC4wOV0sW1wibFwiLC0wLjA5LDAuMDZdLFtcImxcIiwtNS40OSwwXSxbXCJsXCIsLTUuNDYsMF0sW1wibFwiLC0wLjA5LC0wLjA2XSxbXCJsXCIsLTAuMDYsLTAuMDldLFtcImxcIiwwLC0yLjE5XSxbXCJsXCIsMCwtMi4xOV0sW1wielwiXV0sdzoxMS4yNSxoOjQuNjh9LFwicmVzdHMucXVhcnRlclwiOntkOltbXCJNXCIsMS44OSwtMTEuODJdLFtcImNcIiwwLjEyLC0wLjA2LDAuMjQsLTAuMDYsMC4zNiwtMC4wM10sW1wiY1wiLDAuMDksMC4wNiw0Ljc0LDUuNTgsNC44Niw1LjgyXSxbXCJjXCIsMC4yMSwwLjM5LDAuMTUsMC43OCwtMC4xNSwxLjI2XSxbXCJjXCIsLTAuMjQsMC4zMywtMC43MiwwLjgxLC0xLjYyLDEuNTZdLFtcImNcIiwtMC40NSwwLjM2LC0wLjg3LDAuNzUsLTAuOTYsMC44NF0sW1wiY1wiLC0wLjkzLDAuOTksLTEuMTQsMi40OSwtMC42LDMuNjNdLFtcImNcIiwwLjE4LDAuMzksMC4yNywwLjQ4LDEuMzIsMS42OF0sW1wiY1wiLDEuOTIsMi4yNSwxLjgzLDIuMTYsMS44MywyLjM0XSxbXCJjXCIsLTAsMC4xOCwtMC4xOCwwLjM2LC0wLjM2LDAuMzldLFtcImNcIiwtMC4xNSwtMCwtMC4yNywtMC4wNiwtMC40OCwtMC4yN10sW1wiY1wiLC0wLjc1LC0wLjc1LC0yLjQ2LC0xLjI5LC0zLjM5LC0xLjA4XSxbXCJjXCIsLTAuNDUsMC4wOSwtMC42OSwwLjI3LC0wLjksMC42OV0sW1wiY1wiLC0wLjEyLDAuMywtMC4yMSwwLjY2LC0wLjI0LDEuMTRdLFtcImNcIiwtMC4wMywwLjY2LDAuMDksMS4zNSwwLjMsMi4wMV0sW1wiY1wiLDAuMTUsMC40MiwwLjI0LDAuNjYsMC40NSwwLjk2XSxbXCJjXCIsMC4xOCwwLjI0LDAuMTgsMC4zMywwLjAzLDAuNDJdLFtcImNcIiwtMC4xMiwwLjA2LC0wLjE4LDAuMDMsLTAuNDUsLTAuM10sW1wiY1wiLC0xLjA4LC0xLjM4LC0yLjA3LC0zLjM2LC0yLjQsLTQuODNdLFtcImNcIiwtMC4yNywtMS4wNSwtMC4xNSwtMS43NywwLjI3LC0yLjA3XSxbXCJjXCIsMC4yMSwtMC4xMiwwLjQyLC0wLjE1LDAuODcsLTAuMTVdLFtcImNcIiwwLjg3LDAuMDYsMi4xLDAuMzksMy4zLDAuOV0sW1wibFwiLDAuMzksMC4xOF0sW1wibFwiLC0xLjY1LC0xLjk1XSxbXCJjXCIsLTIuNTIsLTIuOTcsLTIuNjEsLTMuMDksLTIuNywtMy4yN10sW1wiY1wiLC0wLjA5LC0wLjI0LC0wLjEyLC0wLjQ4LC0wLjAzLC0wLjc1XSxbXCJjXCIsMC4xNSwtMC40OCwwLjU3LC0wLjk2LDEuODMsLTIuMDFdLFtcImNcIiwwLjQ1LC0wLjM2LDAuODQsLTAuNzIsMC45MywtMC43OF0sW1wiY1wiLDAuNjksLTAuNzUsMS4wMiwtMS44LDAuOSwtMi43OV0sW1wiY1wiLC0wLjA2LC0wLjMzLC0wLjIxLC0wLjg0LC0wLjM5LC0xLjExXSxbXCJjXCIsLTAuMDksLTAuMTUsLTAuNDUsLTAuNiwtMC44MSwtMS4wNV0sW1wiY1wiLC0wLjM2LC0wLjQyLC0wLjY5LC0wLjgxLC0wLjcyLC0wLjg3XSxbXCJjXCIsLTAuMDksLTAuMTgsLTAsLTAuNDIsMC4yMSwtMC41MV0sW1wielwiXV0sdzo3Ljg4OCxoOjIxLjQzNX0sXCJyZXN0cy44dGhcIjp7ZDpbW1wiTVwiLDEuNjgsLTYuMTJdLFtcImNcIiwwLjY2LC0wLjA5LDEuMjMsMC4wOSwxLjY4LDAuNTFdLFtcImNcIiwwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2XSxbXCJjXCIsMC4wOSwwLjMzLDAuMTgsMC42NiwwLjIxLDAuNzJdLFtcImNcIiwwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNiwwLjQ4XSxbXCJjXCIsMC4xMiwwLDAuMTgsMCwwLjMzLC0wLjA5XSxbXCJjXCIsMC4zOSwtMC4xOCwxLjMyLC0xLjI5LDEuNjgsLTEuOThdLFtcImNcIiwwLjA5LC0wLjIxLDAuMjQsLTAuMywwLjM5LC0wLjNdLFtcImNcIiwwLjEyLDAsMC4yNywwLjA5LDAuMzMsMC4xOF0sW1wiY1wiLDAuMDMsMC4wNiwtMC4yNywxLjExLC0xLjg2LDYuNDJdLFtcImNcIiwtMS4wMiwzLjQ4LC0xLjg5LDYuMzksLTEuOTIsNi40Ml0sW1wiY1wiLDAsMC4wMywtMC4xMiwwLjEyLC0wLjI0LDAuMTVdLFtcImNcIiwtMC4xOCwwLjA5LC0wLjIxLDAuMDksLTAuNDUsMC4wOV0sW1wiY1wiLC0wLjI0LDAsLTAuMywwLC0wLjQ4LC0wLjA2XSxbXCJjXCIsLTAuMDksLTAuMDYsLTAuMjEsLTAuMTIsLTAuMjEsLTAuMTVdLFtcImNcIiwtMC4wNiwtMC4wMywwLjE1LC0wLjU3LDEuNjgsLTQuOTJdLFtcImNcIiwwLjk2LC0yLjY3LDEuNzQsLTQuODksMS43MSwtNC44OV0sW1wibFwiLC0wLjUxLDAuMTVdLFtcImNcIiwtMS4wOCwwLjM2LC0xLjc0LDAuNDgsLTIuNTUsMC40OF0sW1wiY1wiLC0wLjY2LDAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjddLFtcImNcIiwtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zXSxbXCJjXCIsMC4zMywtMC40NSwwLjg0LC0wLjgxLDEuMzgsLTAuOV0sW1wielwiXV0sdzo3LjUzNCxoOjEzLjg4M30sXCJyZXN0cy4xNnRoXCI6e2Q6W1tcIk1cIiwzLjMzLC02LjEyXSxbXCJjXCIsMC42NiwtMC4wOSwxLjIzLDAuMDksMS42OCwwLjUxXSxbXCJjXCIsMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNl0sW1wiY1wiLDAuMDksMC4zMywwLjE4LDAuNjYsMC4yMSwwLjcyXSxbXCJjXCIsMC4xNSwwLjM5LDAuNTcsMC41NywwLjg3LDAuNDJdLFtcImNcIiwwLjM5LC0wLjE4LDEuMiwtMS4yMywxLjYyLC0yLjA3XSxbXCJjXCIsMC4wNiwtMC4xNSwwLjI0LC0wLjI0LDAuMzYsLTAuMjRdLFtcImNcIiwwLjEyLDAsMC4yNywwLjA5LDAuMzMsMC4xOF0sW1wiY1wiLDAuMDMsMC4wNiwtMC40NSwxLjg2LC0yLjY3LDEwLjE3XSxbXCJjXCIsLTEuNSw1LjU1LC0yLjczLDEwLjE0LC0yLjc2LDEwLjE3XSxbXCJjXCIsLTAuMDMsMC4wMywtMC4xMiwwLjEyLC0wLjI0LDAuMTVdLFtcImNcIiwtMC4xOCwwLjA5LC0wLjIxLDAuMDksLTAuNDUsMC4wOV0sW1wiY1wiLC0wLjI0LDAsLTAuMywwLC0wLjQ4LC0wLjA2XSxbXCJjXCIsLTAuMDksLTAuMDYsLTAuMjEsLTAuMTIsLTAuMjEsLTAuMTVdLFtcImNcIiwtMC4wNiwtMC4wMywwLjEyLC0wLjU3LDEuNDQsLTQuOTJdLFtcImNcIiwwLjgxLC0yLjY3LDEuNDcsLTQuODYsMS40NywtNC44OV0sW1wiY1wiLC0wLjAzLDAsLTAuMjcsMC4wNiwtMC41NCwwLjE1XSxbXCJjXCIsLTEuMDgsMC4zNiwtMS43NywwLjQ4LC0yLjU4LDAuNDhdLFtcImNcIiwtMC42NiwwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3XSxbXCJjXCIsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM10sW1wiY1wiLDAuNzIsLTEuMDUsMi4yMiwtMS4yMywzLjA2LC0wLjQyXSxbXCJjXCIsMC4zLDAuMzMsMC40MiwwLjYsMC42LDEuMzhdLFtcImNcIiwwLjA5LDAuNDUsMC4yMSwwLjc4LDAuMzMsMC45XSxbXCJjXCIsMC4wOSwwLjA5LDAuMjcsMC4xOCwwLjQ1LDAuMjFdLFtcImNcIiwwLjEyLDAsMC4xOCwwLDAuMzMsLTAuMDldLFtcImNcIiwwLjMzLC0wLjE1LDEuMDIsLTAuOTMsMS40MSwtMS41OV0sW1wiY1wiLDAuMTIsLTAuMjEsMC4xOCwtMC4zOSwwLjM5LC0xLjA4XSxbXCJjXCIsMC42NiwtMi4xLDEuMTcsLTMuODQsMS4xNywtMy44N10sW1wiY1wiLDAsMCwtMC4yMSwwLjA2LC0wLjQyLDAuMTVdLFtcImNcIiwtMC41MSwwLjE1LC0xLjIsMC4zMywtMS42OCwwLjQyXSxbXCJjXCIsLTAuMzMsMC4wNiwtMC41MSwwLjA2LC0wLjk2LDAuMDZdLFtcImNcIiwtMC42NiwwLC0wLjg0LC0wLjAzLC0xLjMyLC0wLjI3XSxbXCJjXCIsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM10sW1wiY1wiLDAuMzMsLTAuNDUsMC44NCwtMC44MSwxLjM4LC0wLjldLFtcInpcIl1dLHc6OS43MjQsaDoyMS4zODN9LFwicmVzdHMuMzJuZFwiOntkOltbXCJNXCIsNC4yMywtMTMuNjJdLFtcImNcIiwwLjY2LC0wLjA5LDEuMjMsMC4wOSwxLjY4LDAuNTFdLFtcImNcIiwwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2XSxbXCJjXCIsMC4wOSwwLjMzLDAuMTgsMC42NiwwLjIxLDAuNzJdLFtcImNcIiwwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNiwwLjQ4XSxbXCJjXCIsMC4xMiwwLDAuMTgsMCwwLjI3LC0wLjA2XSxbXCJjXCIsMC4zMywtMC4yMSwwLjk5LC0xLjExLDEuNDQsLTEuOThdLFtcImNcIiwwLjA5LC0wLjI0LDAuMjEsLTAuMzMsMC4zOSwtMC4zM10sW1wiY1wiLDAuMTIsMCwwLjI3LDAuMDksMC4zMywwLjE4XSxbXCJjXCIsMC4wMywwLjA2LC0wLjU3LDIuNjcsLTMuMjEsMTMuODldLFtcImNcIiwtMS44LDcuNjIsLTMuMywxMy44OSwtMy4zLDEzLjkyXSxbXCJjXCIsLTAuMDMsMC4wNiwtMC4xMiwwLjEyLC0wLjI0LDAuMThdLFtcImNcIiwtMC4yMSwwLjA5LC0wLjI0LDAuMDksLTAuNDgsMC4wOV0sW1wiY1wiLC0wLjI0LC0wLC0wLjMsLTAsLTAuNDgsLTAuMDZdLFtcImNcIiwtMC4wOSwtMC4wNiwtMC4yMSwtMC4xMiwtMC4yMSwtMC4xNV0sW1wiY1wiLC0wLjA2LC0wLjAzLDAuMDksLTAuNTcsMS4yMywtNC45Ml0sW1wiY1wiLDAuNjksLTIuNjcsMS4yNiwtNC44NiwxLjI5LC00Ljg5XSxbXCJjXCIsMCwtMC4wMywtMC4xMiwtMC4wMywtMC40OCwwLjEyXSxbXCJjXCIsLTEuMTcsMC4zOSwtMi4yMiwwLjU3LC0zLDAuNTRdLFtcImNcIiwtMC40MiwtMC4wMywtMC43NSwtMC4xMiwtMS4xMSwtMC4zXSxbXCJjXCIsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM10sW1wiY1wiLDAuNzIsLTEuMDUsMi4yMiwtMS4yMywzLjA2LC0wLjQyXSxbXCJjXCIsMC4zLDAuMzMsMC40MiwwLjYsMC42LDEuMzhdLFtcImNcIiwwLjA5LDAuNDUsMC4yMSwwLjc4LDAuMzMsMC45XSxbXCJjXCIsMC4xMiwwLjA5LDAuMywwLjE4LDAuNDgsMC4yMV0sW1wiY1wiLDAuMTIsLTAsMC4xOCwtMCwwLjMsLTAuMDldLFtcImNcIiwwLjQyLC0wLjIxLDEuMjksLTEuMjksMS41NiwtMS44OV0sW1wiY1wiLDAuMDMsLTAuMTIsMS4yMywtNC41OSwxLjIzLC00LjY1XSxbXCJjXCIsMCwtMC4wMywtMC4xOCwwLjAzLC0wLjM5LDAuMTJdLFtcImNcIiwtMC42MywwLjE4LC0xLjIsMC4zNiwtMS43NCwwLjQ1XSxbXCJjXCIsLTAuMzksMC4wNiwtMC41NCwwLjA2LC0xLjAyLDAuMDZdLFtcImNcIiwtMC42NiwtMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sW1wiY1wiLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNdLFtcImNcIiwwLjcyLC0xLjA1LDIuMjIsLTEuMjMsMy4wNiwtMC40Ml0sW1wiY1wiLDAuMywwLjMzLDAuNDIsMC42LDAuNiwxLjM4XSxbXCJjXCIsMC4wOSwwLjQ1LDAuMjEsMC43OCwwLjMzLDAuOV0sW1wiY1wiLDAuMTgsMC4xOCwwLjUxLDAuMjcsMC43MiwwLjE1XSxbXCJjXCIsMC4zLC0wLjEyLDAuNjksLTAuNTcsMS4wOCwtMS4xN10sW1wiY1wiLDAuNDIsLTAuNiwwLjM5LC0wLjUxLDEuMDUsLTMuMDNdLFtcImNcIiwwLjMzLC0xLjI2LDAuNiwtMi4zMSwwLjYsLTIuMzRdLFtcImNcIiwwLC0wLC0wLjIxLDAuMDMsLTAuNDUsMC4xMl0sW1wiY1wiLC0wLjU3LDAuMTgsLTEuMTQsMC4zMywtMS42MiwwLjQyXSxbXCJjXCIsLTAuMzMsMC4wNiwtMC41MSwwLjA2LC0wLjk2LDAuMDZdLFtcImNcIiwtMC42NiwtMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sW1wiY1wiLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNdLFtcImNcIiwwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45XSxbXCJ6XCJdXSx3OjExLjM3MyxoOjI4Ljg4M30sXCJyZXN0cy42NHRoXCI6e2Q6W1tcIk1cIiw1LjEzLC0xMy42Ml0sW1wiY1wiLDAuNjYsLTAuMDksMS4yMywwLjA5LDEuNjgsMC41MV0sW1wiY1wiLDAuMjcsMC4zLDAuMzksMC41NCwwLjU3LDEuMjZdLFtcImNcIiwwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45Nl0sW1wiY1wiLDAuMTgsMC4yMSwwLjU0LDAuMywwLjc1LDAuMThdLFtcImNcIiwwLjI0LC0wLjEyLDAuNjMsLTAuNjYsMS4wOCwtMS41Nl0sW1wiY1wiLDAuMzMsLTAuNjYsMC4zOSwtMC43MiwwLjYsLTAuNzJdLFtcImNcIiwwLjEyLDAsMC4yNywwLjA5LDAuMzMsMC4xOF0sW1wiY1wiLDAuMDMsMC4wNiwtMC42OSwzLjY2LC0zLjU0LDE3LjY0XSxbXCJjXCIsLTEuOTUsOS42NiwtMy41NywxNy42MSwtMy41NywxNy42NF0sW1wiY1wiLC0wLjAzLDAuMDYsLTAuMTIsMC4xMiwtMC4yNCwwLjE4XSxbXCJjXCIsLTAuMjEsMC4wOSwtMC4yNCwwLjA5LC0wLjQ4LDAuMDldLFtcImNcIiwtMC4yNCwwLC0wLjMsMCwtMC40OCwtMC4wNl0sW1wiY1wiLC0wLjA5LC0wLjA2LC0wLjIxLC0wLjEyLC0wLjIxLC0wLjE1XSxbXCJjXCIsLTAuMDYsLTAuMDMsMC4wNiwtMC41NywxLjA1LC00Ljk1XSxbXCJjXCIsMC42LC0yLjcsMS4wOCwtNC44OSwxLjA4LC00LjkyXSxbXCJjXCIsMCwwLC0wLjI0LDAuMDYsLTAuNTEsMC4xNV0sW1wiY1wiLC0wLjY2LDAuMjQsLTEuMiwwLjM2LC0xLjc3LDAuNDhdLFtcImNcIiwtMC40MiwwLjA2LC0wLjU3LDAuMDYsLTEuMDUsMC4wNl0sW1wiY1wiLC0wLjY5LDAsLTAuODcsLTAuMDMsLTEuMzUsLTAuMjddLFtcImNcIiwtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zXSxbXCJjXCIsMC43MiwtMS4wNSwyLjIyLC0xLjIzLDMuMDYsLTAuNDJdLFtcImNcIiwwLjMsMC4zMywwLjQyLDAuNiwwLjYsMS4zOF0sW1wiY1wiLDAuMDksMC40NSwwLjIxLDAuNzgsMC4zMywwLjldLFtcImNcIiwwLjA5LDAuMDksMC4yNywwLjE4LDAuNDUsMC4yMV0sW1wiY1wiLDAuMjEsMC4wMywwLjM5LC0wLjA5LDAuNzIsLTAuNDJdLFtcImNcIiwwLjQ1LC0wLjQ1LDEuMDIsLTEuMjYsMS4xNywtMS42NV0sW1wiY1wiLDAuMDMsLTAuMDksMC4yNywtMS4xNCwwLjU0LC0yLjM0XSxbXCJjXCIsMC4yNywtMS4yLDAuNDgsLTIuMTksMC41MSwtMi4yMl0sW1wiY1wiLDAsLTAuMDMsLTAuMDksLTAuMDMsLTAuNDgsMC4xMl0sW1wiY1wiLC0xLjE3LDAuMzksLTIuMjIsMC41NywtMywwLjU0XSxbXCJjXCIsLTAuNDIsLTAuMDMsLTAuNzUsLTAuMTIsLTEuMTEsLTAuM10sW1wiY1wiLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNdLFtcImNcIiwwLjM2LC0wLjU0LDAuOTYsLTAuODcsMS42NSwtMC45M10sW1wiY1wiLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sW1wiY1wiLDAuMjcsMC4zLDAuMzksMC41NCwwLjU3LDEuMjZdLFtcImNcIiwwLjA5LDAuMzMsMC4xOCwwLjY2LDAuMjEsMC43Ml0sW1wiY1wiLDAuMTUsMC4zOSwwLjU3LDAuNTcsMC45LDAuNDJdLFtcImNcIiwwLjM2LC0wLjE4LDEuMiwtMS4yNiwxLjQ3LC0xLjg5XSxbXCJjXCIsMC4wMywtMC4wOSwwLjMsLTEuMiwwLjU3LC0yLjQzXSxbXCJsXCIsMC41MSwtMi4yOF0sW1wibFwiLC0wLjU0LDAuMThdLFtcImNcIiwtMS4xMSwwLjM2LC0xLjgsMC40OCwtMi42MSwwLjQ4XSxbXCJjXCIsLTAuNjYsMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sW1wiY1wiLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNdLFtcImNcIiwwLjM2LC0wLjU0LDAuOTYsLTAuODcsMS42NSwtMC45M10sW1wiY1wiLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sW1wiY1wiLDAuMjcsMC4zLDAuMzksMC41NCwwLjU3LDEuMjZdLFtcImNcIiwwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45Nl0sW1wiY1wiLDAuMjEsMC4yMSwwLjU0LDAuMywwLjc1LDAuMThdLFtcImNcIiwwLjM2LC0wLjE4LDAuOTMsLTAuOTMsMS4yOSwtMS42OF0sW1wiY1wiLDAuMTIsLTAuMjQsMC4xOCwtMC40OCwwLjYzLC0yLjU1XSxbXCJsXCIsMC41MSwtMi4zMV0sW1wiY1wiLDAsLTAuMDMsLTAuMTgsMC4wMywtMC4zOSwwLjEyXSxbXCJjXCIsLTEuMTQsMC4zNiwtMi4xLDAuNTQsLTIuODIsMC41MV0sW1wiY1wiLC0wLjQyLC0wLjAzLC0wLjc1LC0wLjEyLC0xLjExLC0wLjNdLFtcImNcIiwtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zXSxbXCJjXCIsMC4zMywtMC40NSwwLjg0LC0wLjgxLDEuMzgsLTAuOV0sW1wielwiXV0sdzoxMi40NTMsaDozNi4zODN9LFwicmVzdHMuMTI4dGhcIjp7ZDpbW1wiTVwiLDYuMDMsLTIxLjEyXSxbXCJjXCIsMC42NiwtMC4wOSwxLjIzLDAuMDksMS42OCwwLjUxXSxbXCJjXCIsMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNl0sW1wiY1wiLDAuMDksMC4zMywwLjE4LDAuNjYsMC4yMSwwLjcyXSxbXCJjXCIsMC4xMiwwLjI3LDAuMzMsMC40NSwwLjYsMC40OF0sW1wiY1wiLDAuMjEsMCwwLjMzLC0wLjA2LDAuNTQsLTAuMzZdLFtcImNcIiwwLjE1LC0wLjIxLDAuNTQsLTAuOTMsMC43OCwtMS40N10sW1wiY1wiLDAuMTUsLTAuMzMsMC4xOCwtMC4zOSwwLjMsLTAuNDhdLFtcImNcIiwwLjE4LC0wLjA5LDAuNDUsMCwwLjUxLDAuMTVdLFtcImNcIiwwLjAzLDAuMDksLTcuMTEsNDIuNzUsLTcuMTcsNDIuODRdLFtcImNcIiwtMC4wMywwLjAzLC0wLjE1LDAuMDksLTAuMjQsMC4xNV0sW1wiY1wiLC0wLjE4LDAuMDYsLTAuMjQsMC4wNiwtMC40NSwwLjA2XSxbXCJjXCIsLTAuMjQsLTAsLTAuMywtMCwtMC40OCwtMC4wNl0sW1wiY1wiLC0wLjA5LC0wLjA2LC0wLjIxLC0wLjEyLC0wLjIxLC0wLjE1XSxbXCJjXCIsLTAuMDYsLTAuMDMsMC4wMywtMC41NywwLjg0LC00Ljk4XSxbXCJjXCIsMC41MSwtMi43LDAuOTMsLTQuOTIsMC45LC00LjkyXSxbXCJjXCIsMCwtMCwtMC4xNSwwLjA2LC0wLjM2LDAuMTJdLFtcImNcIiwtMC43OCwwLjI3LC0xLjYyLDAuNDgsLTIuMzEsMC41N10sW1wiY1wiLC0wLjE1LDAuMDMsLTAuNTQsMC4wMywtMC44MSwwLjAzXSxbXCJjXCIsLTAuNjYsLTAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjddLFtcImNcIiwtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zXSxbXCJjXCIsMC4zNiwtMC41NCwwLjk2LC0wLjg3LDEuNjUsLTAuOTNdLFtcImNcIiwwLjU0LC0wLjAzLDEuMDIsMC4xNSwxLjQxLDAuNTRdLFtcImNcIiwwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2XSxbXCJjXCIsMC4wOSwwLjMzLDAuMTgsMC42NiwwLjIxLDAuNzJdLFtcImNcIiwwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNjMsMC40OF0sW1wiY1wiLDAuMTIsLTAsMC4xOCwtMCwwLjMsLTAuMDldLFtcImNcIiwwLjQyLC0wLjIxLDEuMTQsLTEuMTEsMS41LC0xLjgzXSxbXCJjXCIsMC4xMiwtMC4yNywwLjEyLC0wLjI3LDAuNTQsLTIuNTJdLFtcImNcIiwwLjI0LC0xLjIzLDAuNDIsLTIuMjUsMC4zOSwtMi4yNV0sW1wiY1wiLDAsLTAsLTAuMjQsMC4wNiwtMC41MSwwLjE4XSxbXCJjXCIsLTEuMjYsMC4zOSwtMi4yNSwwLjU3LC0zLjA2LDAuNTRdLFtcImNcIiwtMC40MiwtMC4wMywtMC43NSwtMC4xMiwtMS4xMSwtMC4zXSxbXCJjXCIsLTEuMzIsLTAuNjMsLTEuNzcsLTIuMTYsLTEuMDIsLTMuM10sW1wiY1wiLDAuMzYsLTAuNTQsMC45NiwtMC44NywxLjY1LC0wLjkzXSxbXCJjXCIsMC41NCwtMC4wMywxLjAyLDAuMTUsMS40MSwwLjU0XSxbXCJjXCIsMC4yNywwLjMsMC4zOSwwLjU0LDAuNTcsMS4yNl0sW1wiY1wiLDAuMTUsMC42MywwLjIxLDAuODEsMC4zMywwLjk2XSxbXCJjXCIsMC4xOCwwLjIxLDAuNTEsMC4zLDAuNzUsMC4xOF0sW1wiY1wiLDAuMzYsLTAuMTUsMS4wNSwtMC45OSwxLjQxLC0xLjc3XSxbXCJsXCIsMC4xNSwtMC4zXSxbXCJsXCIsMC40MiwtMi4yNV0sW1wiY1wiLDAuMjEsLTEuMjYsMC40MiwtMi4yOCwwLjM5LC0yLjI4XSxbXCJsXCIsLTAuNTEsMC4xNV0sW1wiY1wiLC0xLjExLDAuMzksLTEuODksMC41MSwtMi43LDAuNTFdLFtcImNcIiwtMC42NiwtMCwtMC44NCwtMC4wMywtMS4zMiwtMC4yN10sW1wiY1wiLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNdLFtcImNcIiwwLjM2LC0wLjU0LDAuOTYsLTAuODcsMS42NSwtMC45M10sW1wiY1wiLDAuNTQsLTAuMDMsMS4wMiwwLjE1LDEuNDEsMC41NF0sW1wiY1wiLDAuMjcsMC4zLDAuMzksMC41NCwwLjU3LDEuMjZdLFtcImNcIiwwLjE1LDAuNjMsMC4yMSwwLjgxLDAuMzMsMC45Nl0sW1wiY1wiLDAuMTgsMC4xOCwwLjQ4LDAuMjcsMC43MiwwLjIxXSxbXCJjXCIsMC4zMywtMC4xMiwxLjE0LC0xLjI2LDEuNDEsLTEuOTVdLFtcImNcIiwwLC0wLjA5LDAuMjEsLTEuMTEsMC40NSwtMi4zNF0sW1wiY1wiLDAuMjEsLTEuMiwwLjM5LC0yLjIyLDAuMzksLTIuMjhdLFtcImNcIiwwLjAzLC0wLjAzLDAsLTAuMDMsLTAuNDUsMC4xMl0sW1wiY1wiLC0wLjU3LDAuMTgsLTEuMiwwLjMzLC0xLjcxLDAuNDJdLFtcImNcIiwtMC4zLDAuMDYsLTAuNTEsMC4wNiwtMC45MywwLjA2XSxbXCJjXCIsLTAuNjYsLTAsLTAuODQsLTAuMDMsLTEuMzIsLTAuMjddLFtcImNcIiwtMS4zMiwtMC42MywtMS43NywtMi4xNiwtMS4wMiwtMy4zXSxbXCJjXCIsMC4zNiwtMC41NCwwLjk2LC0wLjg3LDEuNjUsLTAuOTNdLFtcImNcIiwwLjU0LC0wLjAzLDEuMDIsMC4xNSwxLjQxLDAuNTRdLFtcImNcIiwwLjI3LDAuMywwLjM5LDAuNTQsMC41NywxLjI2XSxbXCJjXCIsMC4wOSwwLjMzLDAuMTgsMC42NiwwLjIxLDAuNzJdLFtcImNcIiwwLjEyLDAuMjcsMC4zMywwLjQ1LDAuNiwwLjQ4XSxbXCJjXCIsMC4xOCwtMCwwLjM2LC0wLjA5LDAuNTcsLTAuMzNdLFtcImNcIiwwLjMzLC0wLjM2LDAuNzgsLTEuMTQsMC45MywtMS41Nl0sW1wiY1wiLDAuMDMsLTAuMTIsMC4yNCwtMS4yLDAuNDUsLTIuNF0sW1wiY1wiLDAuMjQsLTEuMiwwLjQyLC0yLjIyLDAuNDIsLTIuMjhdLFtcImNcIiwwLjAzLC0wLjAzLDAsLTAuMDMsLTAuMzksMC4wOV0sW1wiY1wiLC0xLjA1LDAuMzYsLTEuOCwwLjQ4LC0yLjU4LDAuNDhdLFtcImNcIiwtMC42MywtMCwtMC44NCwtMC4wMywtMS4yOSwtMC4yN10sW1wiY1wiLC0xLjMyLC0wLjYzLC0xLjc3LC0yLjE2LC0xLjAyLC0zLjNdLFtcImNcIiwwLjMzLC0wLjQ1LDAuODQsLTAuODEsMS4zOCwtMC45XSxbXCJ6XCJdXSx3OjEyLjk5MixoOjQzLjg4M30sXCJhY2NpZGVudGFscy5zaGFycFwiOntkOltbXCJNXCIsNS43MywtMTEuMTldLFtcImNcIiwwLjIxLC0wLjEyLDAuNTQsLTAuMDMsMC42NiwwLjI0XSxbXCJjXCIsMC4wNiwwLjEyLDAuMDYsMC4yMSwwLjA2LDIuMzFdLFtcImNcIiwwLDEuMjMsMCwyLjIyLDAuMDMsMi4yMl0sW1wiY1wiLDAsLTAsMC4yNywtMC4xMiwwLjYsLTAuMjRdLFtcImNcIiwwLjY5LC0wLjI3LDAuNzgsLTAuMywwLjk2LC0wLjE1XSxbXCJjXCIsMC4yMSwwLjE1LDAuMjEsMC4xOCwwLjIxLDEuMzhdLFtcImNcIiwwLDEuMDIsMCwxLjExLC0wLjA2LDEuMl0sW1wiY1wiLC0wLjAzLDAuMDYsLTAuMDksMC4xMiwtMC4xMiwwLjE1XSxbXCJjXCIsLTAuMDYsMC4wMywtMC40MiwwLjIxLC0wLjg0LDAuMzZdLFtcImxcIiwtMC43NSwwLjMzXSxbXCJsXCIsLTAuMDMsMi40M10sW1wiY1wiLDAsMS4zMiwwLDIuNDMsMC4wMywyLjQzXSxbXCJjXCIsMCwtMCwwLjI3LC0wLjEyLDAuNiwtMC4yNF0sW1wiY1wiLDAuNjksLTAuMjcsMC43OCwtMC4zLDAuOTYsLTAuMTVdLFtcImNcIiwwLjIxLDAuMTUsMC4yMSwwLjE4LDAuMjEsMS4zOF0sW1wiY1wiLDAsMS4wMiwwLDEuMTEsLTAuMDYsMS4yXSxbXCJjXCIsLTAuMDMsMC4wNiwtMC4wOSwwLjEyLC0wLjEyLDAuMTVdLFtcImNcIiwtMC4wNiwwLjAzLC0wLjQyLDAuMjEsLTAuODQsMC4zNl0sW1wibFwiLC0wLjc1LDAuMzNdLFtcImxcIiwtMC4wMywyLjUyXSxbXCJjXCIsMCwyLjI4LC0wLjAzLDIuNTUsLTAuMDYsMi42NF0sW1wiY1wiLC0wLjIxLDAuMzYsLTAuNzIsMC4zNiwtMC45MywtMF0sW1wiY1wiLC0wLjAzLC0wLjA5LC0wLjA2LC0wLjMzLC0wLjA2LC0yLjQzXSxbXCJsXCIsMCwtMi4zMV0sW1wibFwiLC0xLjI5LDAuNTFdLFtcImxcIiwtMS4yNiwwLjUxXSxbXCJsXCIsMCwyLjQzXSxbXCJjXCIsMCwyLjU4LDAsMi41MiwtMC4xNSwyLjY3XSxbXCJjXCIsLTAuMDYsMC4wOSwtMC4yNywwLjE4LC0wLjM2LDAuMThdLFtcImNcIiwtMC4xMiwtMCwtMC4zMywtMC4wOSwtMC4zOSwtMC4xOF0sW1wiY1wiLC0wLjE1LC0wLjE1LC0wLjE1LC0wLjA5LC0wLjE1LC0yLjQzXSxbXCJjXCIsMCwtMS4yMywwLC0yLjIyLC0wLjAzLC0yLjIyXSxbXCJjXCIsMCwtMCwtMC4yNywwLjEyLC0wLjYsMC4yNF0sW1wiY1wiLC0wLjY5LDAuMjcsLTAuNzgsMC4zLC0wLjk2LDAuMTVdLFtcImNcIiwtMC4yMSwtMC4xNSwtMC4yMSwtMC4xOCwtMC4yMSwtMS4zOF0sW1wiY1wiLDAsLTEuMDIsMCwtMS4xMSwwLjA2LC0xLjJdLFtcImNcIiwwLjAzLC0wLjA2LDAuMDksLTAuMTIsMC4xMiwtMC4xNV0sW1wiY1wiLDAuMDYsLTAuMDMsMC40MiwtMC4yMSwwLjg0LC0wLjM2XSxbXCJsXCIsMC43OCwtMC4zM10sW1wibFwiLDAsLTIuNDNdLFtcImNcIiwwLC0xLjMyLDAsLTIuNDMsLTAuMDMsLTIuNDNdLFtcImNcIiwwLC0wLC0wLjI3LDAuMTIsLTAuNiwwLjI0XSxbXCJjXCIsLTAuNjksMC4yNywtMC43OCwwLjMsLTAuOTYsMC4xNV0sW1wiY1wiLC0wLjIxLC0wLjE1LC0wLjIxLC0wLjE4LC0wLjIxLC0xLjM4XSxbXCJjXCIsMCwtMS4wMiwwLC0xLjExLDAuMDYsLTEuMl0sW1wiY1wiLDAuMDMsLTAuMDYsMC4wOSwtMC4xMiwwLjEyLC0wLjE1XSxbXCJjXCIsMC4wNiwtMC4wMywwLjQyLC0wLjIxLDAuODQsLTAuMzZdLFtcImxcIiwwLjc4LC0wLjMzXSxbXCJsXCIsMCwtMi41Ml0sW1wiY1wiLDAsLTIuMjgsMC4wMywtMi41NSwwLjA2LC0yLjY0XSxbXCJjXCIsMC4yMSwtMC4zNiwwLjcyLC0wLjM2LDAuOTMsMF0sW1wiY1wiLDAuMDMsMC4wOSwwLjA2LDAuMzMsMC4wNiwyLjQzXSxbXCJsXCIsMC4wMywyLjMxXSxbXCJsXCIsMS4yNiwtMC41MV0sW1wibFwiLDEuMjYsLTAuNTFdLFtcImxcIiwwLC0yLjQzXSxbXCJjXCIsMCwtMi4yOCwwLC0yLjQzLDAuMDYsLTIuNTVdLFtcImNcIiwwLjA2LC0wLjEyLDAuMTIsLTAuMTgsMC4yNywtMC4yNF0sW1wielwiXSxbXCJtXCIsLTAuMzMsMTAuNjVdLFtcImxcIiwwLC0yLjQzXSxbXCJsXCIsLTEuMjksMC41MV0sW1wibFwiLC0xLjI2LDAuNTFdLFtcImxcIiwwLDIuNDZdLFtcImxcIiwwLDIuNDNdLFtcImxcIiwwLjA5LC0wLjAzXSxbXCJjXCIsMC4wNiwtMC4wMywwLjYzLC0wLjI3LDEuMjksLTAuNTFdLFtcImxcIiwxLjE3LC0wLjQ4XSxbXCJsXCIsMCwtMi40Nl0sW1wielwiXV0sdzo4LjI1LGg6MjIuNDYyfSxcImFjY2lkZW50YWxzLmhhbGZzaGFycFwiOntkOltbXCJNXCIsMi40MywtMTAuMDVdLFtcImNcIiwwLjIxLC0wLjEyLDAuNTQsLTAuMDMsMC42NiwwLjI0XSxbXCJjXCIsMC4wNiwwLjEyLDAuMDYsMC4yMSwwLjA2LDIuMDFdLFtcImNcIiwwLDEuMDUsMCwxLjg5LDAuMDMsMS44OV0sW1wibFwiLDAuNzIsLTAuNDhdLFtcImNcIiwwLjY5LC0wLjQ4LDAuNjksLTAuNTEsMC44NywtMC41MV0sW1wiY1wiLDAuMTUsMCwwLjE4LDAuMDMsMC4yNywwLjA5XSxbXCJjXCIsMC4yMSwwLjE1LDAuMjEsMC4xOCwwLjIxLDEuNDFdLFtcImNcIiwwLDEuMTEsLTAuMDMsMS4xNCwtMC4wOSwxLjIzXSxbXCJjXCIsLTAuMDMsMC4wMywtMC40OCwwLjM5LC0xLjAyLDAuNzVdLFtcImxcIiwtMC45OSwwLjY2XSxbXCJsXCIsMCwyLjM3XSxbXCJjXCIsMCwxLjMyLDAsMi4zNywwLjAzLDIuMzddLFtcImxcIiwwLjcyLC0wLjQ4XSxbXCJjXCIsMC42OSwtMC40OCwwLjY5LC0wLjUxLDAuODcsLTAuNTFdLFtcImNcIiwwLjE1LDAsMC4xOCwwLjAzLDAuMjcsMC4wOV0sW1wiY1wiLDAuMjEsMC4xNSwwLjIxLDAuMTgsMC4yMSwxLjQxXSxbXCJjXCIsMCwxLjExLC0wLjAzLDEuMTQsLTAuMDksMS4yM10sW1wiY1wiLC0wLjAzLDAuMDMsLTAuNDgsMC4zOSwtMS4wMiwwLjc1XSxbXCJsXCIsLTAuOTksMC42Nl0sW1wibFwiLDAsMi4yNV0sW1wiY1wiLDAsMS45NSwwLDIuMjgsLTAuMDYsMi4zN10sW1wiY1wiLC0wLjA2LDAuMTIsLTAuMTIsMC4yMSwtMC4yNCwwLjI3XSxbXCJjXCIsLTAuMjcsMC4xMiwtMC41NCwwLjAzLC0wLjY5LC0wLjI0XSxbXCJjXCIsLTAuMDYsLTAuMTIsLTAuMDYsLTAuMjEsLTAuMDYsLTIuMDFdLFtcImNcIiwwLC0xLjA1LDAsLTEuODksLTAuMDMsLTEuODldLFtcImxcIiwtMC43MiwwLjQ4XSxbXCJjXCIsLTAuNjksMC40OCwtMC42OSwwLjQ4LC0wLjg3LDAuNDhdLFtcImNcIiwtMC4xNSwwLC0wLjE4LDAsLTAuMjcsLTAuMDZdLFtcImNcIiwtMC4yMSwtMC4xNSwtMC4yMSwtMC4xOCwtMC4yMSwtMS40MV0sW1wiY1wiLDAsLTEuMTEsMC4wMywtMS4xNCwwLjA5LC0xLjIzXSxbXCJjXCIsMC4wMywtMC4wMywwLjQ4LC0wLjM5LDEuMDIsLTAuNzVdLFtcImxcIiwwLjk5LC0wLjY2XSxbXCJsXCIsMCwtMi4zN10sW1wiY1wiLDAsLTEuMzIsMCwtMi4zNywtMC4wMywtMi4zN10sW1wibFwiLC0wLjcyLDAuNDhdLFtcImNcIiwtMC42OSwwLjQ4LC0wLjY5LDAuNDgsLTAuODcsMC40OF0sW1wiY1wiLC0wLjE1LDAsLTAuMTgsMCwtMC4yNywtMC4wNl0sW1wiY1wiLC0wLjIxLC0wLjE1LC0wLjIxLC0wLjE4LC0wLjIxLC0xLjQxXSxbXCJjXCIsMCwtMS4xMSwwLjAzLC0xLjE0LDAuMDksLTEuMjNdLFtcImNcIiwwLjAzLC0wLjAzLDAuNDgsLTAuMzksMS4wMiwtMC43NV0sW1wibFwiLDAuOTksLTAuNjZdLFtcImxcIiwwLC0yLjI1XSxbXCJjXCIsMCwtMi4xMywwLC0yLjI4LDAuMDYsLTIuNF0sW1wiY1wiLDAuMDYsLTAuMTIsMC4xMiwtMC4xOCwwLjI3LC0wLjI0XSxbXCJ6XCJdXSx3OjUuMjUsaDoyMC4xNzR9LFwiYWNjaWRlbnRhbHMubmF0XCI6e2Q6W1tcIk1cIiwwLjIwNCwtMTEuNF0sW1wiY1wiLDAuMjQsLTAuMDYsMC43OCwwLDAuOTksMC4xNV0sW1wiY1wiLDAuMDMsMC4wMywwLjAzLDAuNDgsMCwyLjYxXSxbXCJjXCIsLTAuMDMsMS40NCwtMC4wMywyLjYxLC0wLjAzLDIuNjFdLFtcImNcIiwwLDAuMDMsMC43NSwtMC4wOSwxLjY4LC0wLjI0XSxbXCJjXCIsMC45NiwtMC4xOCwxLjcxLC0wLjI3LDEuNzQsLTAuMjddLFtcImNcIiwwLjE1LDAuMDMsMC4yNywwLjE1LDAuMzYsMC4zXSxbXCJsXCIsMC4wNiwwLjEyXSxbXCJsXCIsMC4wOSw4LjY3XSxbXCJjXCIsMC4wOSw2Ljk2LDAuMTIsOC42NywwLjA5LDguNjddLFtcImNcIiwtMC4wMywwLjAzLC0wLjEyLDAuMDYsLTAuMjEsMC4wOV0sW1wiY1wiLC0wLjI0LDAuMDksLTAuNzIsMC4wOSwtMC45NiwwXSxbXCJjXCIsLTAuMDksLTAuMDMsLTAuMTgsLTAuMDYsLTAuMjEsLTAuMDldLFtcImNcIiwtMC4wMywtMC4wMywtMC4wMywtMC40OCwwLC0yLjYxXSxbXCJjXCIsMC4wMywtMS40NCwwLjAzLC0yLjYxLDAuMDMsLTIuNjFdLFtcImNcIiwwLC0wLjAzLC0wLjc1LDAuMDksLTEuNjgsMC4yNF0sW1wiY1wiLC0wLjk2LDAuMTgsLTEuNzEsMC4yNywtMS43NCwwLjI3XSxbXCJjXCIsLTAuMTUsLTAuMDMsLTAuMjcsLTAuMTUsLTAuMzYsLTAuM10sW1wibFwiLC0wLjA2LC0wLjE1XSxbXCJsXCIsLTAuMDksLTcuNTNdLFtcImNcIiwtMC4wNiwtNC4xNCwtMC4wOSwtOC4wNCwtMC4xMiwtOC42N10sW1wibFwiLDAsLTEuMTFdLFtcImxcIiwwLjE1LC0wLjA2XSxbXCJjXCIsMC4wOSwtMC4wMywwLjIxLC0wLjA2LDAuMjcsLTAuMDldLFtcInpcIl0sW1wibVwiLDMuNzUsOC40XSxbXCJjXCIsMCwtMC4zMywwLC0wLjQyLC0wLjAzLC0wLjQyXSxbXCJjXCIsLTAuMTIsMCwtMi43OSwwLjQ1LC0yLjc5LDAuNDhdLFtcImNcIiwtMC4wMywwLC0wLjA5LDYuMywtMC4wOSw2LjMzXSxbXCJjXCIsMC4wMywwLDIuNzksLTAuNDUsMi44MiwtMC40OF0sW1wiY1wiLDAsMCwwLjA5LC00LjUzLDAuMDksLTUuOTFdLFtcInpcIl1dLHc6NS40MTEsaDoyMi44fSxcImFjY2lkZW50YWxzLmZsYXRcIjp7ZDpbW1wiTVwiLC0wLjM2LC0xNC4wN10sW1wiY1wiLDAuMzMsLTAuMDYsMC44NywwLDEuMDgsMC4xNV0sW1wiY1wiLDAuMDYsMC4wMywwLjA2LDAuMzYsLTAuMDMsNS4yNV0sW1wiY1wiLC0wLjA2LDIuODUsLTAuMDksNS4xOSwtMC4wOSw1LjE5XSxbXCJjXCIsMCwwLjAzLDAuMTIsLTAuMDMsMC4yNCwtMC4xMl0sW1wiY1wiLDAuNjMsLTAuNDIsMS40MSwtMC42NiwyLjE5LC0wLjcyXSxbXCJjXCIsMC44MSwtMC4wMywxLjQ3LDAuMjEsMi4wNCwwLjc4XSxbXCJjXCIsMC41NywwLjU0LDAuODcsMS4yNiwwLjkzLDIuMDRdLFtcImNcIiwwLjAzLDAuNTcsLTAuMDksMS4wOCwtMC4zNiwxLjYyXSxbXCJjXCIsLTAuNDIsMC44MSwtMS4wMiwxLjM4LC0yLjgyLDIuNjFdLFtcImNcIiwtMS4xNCwwLjc4LC0xLjQ0LDEuMDIsLTEuOCwxLjQ0XSxbXCJjXCIsLTAuMTgsMC4xOCwtMC4zOSwwLjM5LC0wLjQ1LDAuNDJdLFtcImNcIiwtMC4yNywwLjE4LC0wLjU3LDAuMTUsLTAuODEsLTAuMDZdLFtcImNcIiwtMC4wNiwtMC4wOSwtMC4xMiwtMC4xOCwtMC4xNSwtMC4yN10sW1wiY1wiLC0wLjAzLC0wLjA2LC0wLjA5LC0zLjI3LC0wLjE4LC04LjM0XSxbXCJjXCIsLTAuMDksLTQuNTMsLTAuMTUsLTguNTgsLTAuMTgsLTkuMDNdLFtcImxcIiwwLC0wLjc4XSxbXCJsXCIsMC4xMiwtMC4wNl0sW1wiY1wiLDAuMDYsLTAuMDMsMC4xOCwtMC4wOSwwLjI3LC0wLjEyXSxbXCJ6XCJdLFtcIm1cIiwzLjE4LDExLjAxXSxbXCJjXCIsLTAuMjEsLTAuMTIsLTAuNTQsLTAuMTUsLTAuODEsLTAuMDZdLFtcImNcIiwtMC41NCwwLjE1LC0wLjk5LDAuNjMsLTEuMTcsMS4yNl0sW1wiY1wiLC0wLjA2LDAuMywtMC4xMiwyLjg4LC0wLjA2LDMuODddLFtcImNcIiwwLjAzLDAuNDIsMC4wMywwLjgxLDAuMDYsMC45XSxbXCJsXCIsMC4wMywwLjEyXSxbXCJsXCIsMC40NSwtMC4zOV0sW1wiY1wiLDAuNjMsLTAuNTQsMS4yNiwtMS4xNywxLjU2LC0xLjU5XSxbXCJjXCIsMC4zLC0wLjQyLDAuNiwtMC45OSwwLjcyLC0xLjQxXSxbXCJjXCIsMC4xOCwtMC42OSwwLjA5LC0xLjQ3LC0wLjE4LC0yLjA3XSxbXCJjXCIsLTAuMTUsLTAuMywtMC4zMywtMC41MSwtMC42LC0wLjYzXSxbXCJ6XCJdXSx3OjYuNzUsaDoxOC44MDF9LFwiYWNjaWRlbnRhbHMuaGFsZmZsYXRcIjp7ZDpbW1wiTVwiLDQuODMsLTE0LjA3XSxbXCJjXCIsMC4zMywtMC4wNiwwLjg3LDAsMS4wOCwwLjE1XSxbXCJjXCIsMC4wNiwwLjAzLDAuMDYsMC42LC0wLjEyLDkuMDZdLFtcImNcIiwtMC4wOSw1LjU1LC0wLjE1LDkuMDYsLTAuMTgsOS4xMl0sW1wiY1wiLC0wLjAzLDAuMDksLTAuMDksMC4xOCwtMC4xNSwwLjI3XSxbXCJjXCIsLTAuMjQsMC4yMSwtMC41NCwwLjI0LC0wLjgxLDAuMDZdLFtcImNcIiwtMC4wNiwtMC4wMywtMC4yNywtMC4yNCwtMC40NSwtMC40Ml0sW1wiY1wiLC0wLjM2LC0wLjQyLC0wLjY2LC0wLjY2LC0xLjgsLTEuNDRdLFtcImNcIiwtMS4yMywtMC44NCwtMS44MywtMS4zMiwtMi4yNSwtMS43N10sW1wiY1wiLC0wLjY2LC0wLjc4LC0wLjk2LC0xLjU2LC0wLjkzLC0yLjQ2XSxbXCJjXCIsMC4wOSwtMS40MSwxLjExLC0yLjU4LDIuNCwtMi43OV0sW1wiY1wiLDAuMywtMC4wNiwwLjg0LC0wLjAzLDEuMjMsMC4wNl0sW1wiY1wiLDAuNTQsMC4xMiwxLjA4LDAuMzMsMS41MywwLjYzXSxbXCJjXCIsMC4xMiwwLjA5LDAuMjQsMC4xNSwwLjI0LDAuMTJdLFtcImNcIiwwLDAsLTAuMTIsLTguMzcsLTAuMTgsLTkuNzVdLFtcImxcIiwwLC0wLjY2XSxbXCJsXCIsMC4xMiwtMC4wNl0sW1wiY1wiLDAuMDYsLTAuMDMsMC4xOCwtMC4wOSwwLjI3LC0wLjEyXSxbXCJ6XCJdLFtcIm1cIiwtMS42NSwxMC45NV0sW1wiY1wiLC0wLjYsLTAuMTgsLTEuMDgsMC4wOSwtMS4zOCwwLjY5XSxbXCJjXCIsLTAuMjcsMC42LC0wLjM2LDEuMzgsLTAuMTgsMi4wN10sW1wiY1wiLDAuMTIsMC40MiwwLjQyLDAuOTksMC43MiwxLjQxXSxbXCJjXCIsMC4zLDAuNDIsMC45MywxLjA1LDEuNTYsMS41OV0sW1wibFwiLDAuNDgsMC4zOV0sW1wibFwiLDAsLTAuMTJdLFtcImNcIiwwLjAzLC0wLjA5LDAuMDMsLTAuNDgsMC4wNiwtMC45XSxbXCJjXCIsMC4wMywtMC41NywwLjAzLC0xLjA4LDAsLTIuMjJdLFtcImNcIiwtMC4wMywtMS42MiwtMC4wMywtMS42MiwtMC4yNCwtMi4wN10sW1wiY1wiLC0wLjIxLC0wLjQyLC0wLjYsLTAuNzUsLTEuMDIsLTAuODRdLFtcInpcIl1dLHc6Ni43MjgsaDoxOC44MDF9LFwiYWNjaWRlbnRhbHMuZGJsZmxhdFwiOntkOltbXCJNXCIsLTAuMzYsLTE0LjA3XSxbXCJjXCIsMC4zMywtMC4wNiwwLjg3LDAsMS4wOCwwLjE1XSxbXCJjXCIsMC4wNiwwLjAzLDAuMDYsMC4zMywtMC4wMyw0Ljg5XSxbXCJjXCIsLTAuMDYsMi42NywtMC4wOSw1LjAxLC0wLjA5LDUuMjJdLFtcImxcIiwwLDAuMzZdLFtcImxcIiwwLjE1LC0wLjE1XSxbXCJjXCIsMC4zNiwtMC4zLDAuNzUsLTAuNTEsMS4yLC0wLjYzXSxbXCJjXCIsMC4zMywtMC4wOSwwLjk2LC0wLjA5LDEuMjYsLTAuMDNdLFtcImNcIiwwLjI3LDAuMDksMC42MywwLjI3LDAuODcsMC40NV0sW1wibFwiLDAuMjEsMC4xNV0sW1wibFwiLDAsLTAuMjddLFtcImNcIiwwLC0wLjE1LC0wLjAzLC0yLjQzLC0wLjA5LC01LjFdLFtcImNcIiwtMC4wOSwtNC41NiwtMC4wOSwtNC44NiwtMC4wMywtNC44OV0sW1wiY1wiLDAuMTUsLTAuMTIsMC4zOSwtMC4xNSwwLjcyLC0wLjE1XSxbXCJjXCIsMC4zLDAsMC41NCwwLjAzLDAuNjksMC4xNV0sW1wiY1wiLDAuMDYsMC4wMywwLjA2LDAuMzMsLTAuMDMsNC45NV0sW1wiY1wiLC0wLjA2LDIuNywtMC4wOSw1LjA0LC0wLjA5LDUuMjJdLFtcImxcIiwwLjAzLDAuM10sW1wibFwiLDAuMjEsLTAuMTVdLFtcImNcIiwwLjY5LC0wLjQ4LDEuNDQsLTAuNjksMi4yOCwtMC42OV0sW1wiY1wiLDAuNTEsMCwwLjc4LDAuMDMsMS4yLDAuMjFdLFtcImNcIiwxLjMyLDAuNjMsMi4wMSwyLjI4LDEuNTMsMy42OV0sW1wiY1wiLC0wLjIxLDAuNTcsLTAuNTEsMS4wMiwtMS4wNSwxLjU2XSxbXCJjXCIsLTAuNDIsMC40MiwtMC44MSwwLjcyLC0xLjkyLDEuNV0sW1wiY1wiLC0xLjI2LDAuODcsLTEuNSwxLjA4LC0xLjg2LDEuNV0sW1wiY1wiLC0wLjM5LDAuNDUsLTAuNTQsMC41NCwtMC44MSwwLjUxXSxbXCJjXCIsLTAuMTgsMCwtMC4yMSwwLC0wLjMzLC0wLjA2XSxbXCJsXCIsLTAuMjEsLTAuMjFdLFtcImxcIiwtMC4wNiwtMC4xMl0sW1wibFwiLC0wLjAzLC0wLjk5XSxbXCJjXCIsLTAuMDMsLTAuNTQsLTAuMDMsLTEuMjksLTAuMDYsLTEuNjhdLFtcImxcIiwwLC0wLjY5XSxbXCJsXCIsLTAuMjEsMC4yNF0sW1wiY1wiLC0wLjM2LDAuNDIsLTAuNzUsMC43NSwtMS44LDEuNjJdLFtcImNcIiwtMS4wMiwwLjg0LC0xLjIsMC45OSwtMS40NCwxLjM4XSxbXCJjXCIsLTAuMzYsMC41MSwtMC41NCwwLjYsLTAuOSwwLjUxXSxbXCJjXCIsLTAuMTUsLTAuMDMsLTAuMzksLTAuMjcsLTAuNDIsLTAuNDJdLFtcImNcIiwtMC4wMywtMC4wNiwtMC4wOSwtMy4yNywtMC4xOCwtOC4zNF0sW1wiY1wiLC0wLjA5LC00LjUzLC0wLjE1LC04LjU4LC0wLjE4LC05LjAzXSxbXCJsXCIsMCwtMC43OF0sW1wibFwiLDAuMTIsLTAuMDZdLFtcImNcIiwwLjA2LC0wLjAzLDAuMTgsLTAuMDksMC4yNywtMC4xMl0sW1wielwiXSxbXCJtXCIsMi41MiwxMC45OF0sW1wiY1wiLC0wLjE4LC0wLjA5LC0wLjQ4LC0wLjEyLC0wLjY2LC0wLjA2XSxbXCJjXCIsLTAuMzksMC4xNSwtMC42OSwwLjU0LC0wLjg0LDEuMTRdLFtcImNcIiwtMC4wNiwwLjI0LC0wLjA2LDAuMzksLTAuMDksMS43NF0sW1wiY1wiLC0wLjAzLDEuNDQsMCwyLjczLDAuMDYsMy4xOF0sW1wibFwiLDAuMDMsMC4xNV0sW1wibFwiLDAuMjcsLTAuMjddLFtcImNcIiwwLjkzLC0wLjk2LDEuNSwtMS45NSwxLjc0LC0zLjA2XSxbXCJjXCIsMC4wNiwtMC4yNywwLjA2LC0wLjM5LDAuMDYsLTAuOTZdLFtcImNcIiwwLC0wLjU0LDAsLTAuNjksLTAuMDYsLTAuOTNdLFtcImNcIiwtMC4wOSwtMC41MSwtMC4yNywtMC44MSwtMC41MSwtMC45M10sW1wielwiXSxbXCJtXCIsNS40MywwXSxbXCJjXCIsLTAuMTgsLTAuMDksLTAuNTEsLTAuMTIsLTAuNzIsLTAuMDZdLFtcImNcIiwtMC41NCwwLjEyLC0wLjk2LDAuNjMsLTEuMTcsMS4yNl0sW1wiY1wiLC0wLjA2LDAuMywtMC4xMiwyLjg4LC0wLjA2LDMuOV0sW1wiY1wiLDAuMDMsMC40MiwwLjAzLDAuODEsMC4wNiwwLjldLFtcImxcIiwwLjAzLDAuMTJdLFtcImxcIiwwLjM2LC0wLjNdLFtcImNcIiwwLjQyLC0wLjM2LDEuMDIsLTAuOTYsMS4yOSwtMS4yOV0sW1wiY1wiLDAuMzYsLTAuNDUsMC42NiwtMC45OSwwLjgxLC0xLjQxXSxbXCJjXCIsMC40MiwtMS4yMywwLjE1LC0yLjc2LC0wLjYsLTMuMTJdLFtcInpcIl1dLHc6MTEuNjEzLGg6MTguODA0fSxcImFjY2lkZW50YWxzLmRibHNoYXJwXCI6e2Q6W1tcIk1cIiwtMC4xODYsLTMuOTZdLFtcImNcIiwwLjA2LC0wLjAzLDAuMTIsLTAuMDYsMC4xNSwtMC4wNl0sW1wiY1wiLDAuMDksMCwyLjc2LDAuMjcsMi43OSwwLjNdLFtcImNcIiwwLjEyLDAuMDMsMC4xNSwwLjEyLDAuMTUsMC41MV0sW1wiY1wiLDAuMDYsMC45NiwwLjI0LDEuNTksMC41NywyLjFdLFtcImNcIiwwLjA2LDAuMDksMC4xNSwwLjIxLDAuMTgsMC4yNF0sW1wibFwiLDAuMDksMC4wNl0sW1wibFwiLDAuMDksLTAuMDZdLFtcImNcIiwwLjAzLC0wLjAzLDAuMTIsLTAuMTUsMC4xOCwtMC4yNF0sW1wiY1wiLDAuMzMsLTAuNTEsMC41MSwtMS4xNCwwLjU3LC0yLjFdLFtcImNcIiwwLC0wLjM5LDAuMDMsLTAuNDUsMC4xMiwtMC41MV0sW1wiY1wiLDAuMDMsMCwwLjY2LC0wLjA5LDEuNDQsLTAuMTVdLFtcImNcIiwxLjQ3LC0wLjE1LDEuNSwtMC4xNSwxLjU2LC0wLjAzXSxbXCJjXCIsMC4wMywwLjA2LDAsMC40MiwtMC4wOSwxLjQ0XSxbXCJjXCIsLTAuMDksMC43MiwtMC4xNSwxLjM1LC0wLjE1LDEuMzhdLFtcImNcIiwwLDAuMDMsLTAuMDMsMC4wOSwtMC4wNiwwLjEyXSxbXCJjXCIsLTAuMDYsMC4wNiwtMC4xMiwwLjA5LC0wLjUxLDAuMDldLFtcImNcIiwtMS4wOCwwLjA2LC0xLjgsMC4zLC0yLjI4LDAuNzVdLFtcImxcIiwtMC4xMiwwLjA5XSxbXCJsXCIsMC4wOSwwLjA5XSxbXCJjXCIsMC4xMiwwLjE1LDAuMzksMC4zMywwLjYzLDAuNDVdLFtcImNcIiwwLjQyLDAuMTgsMC45NiwwLjI3LDEuNjgsMC4zM10sW1wiY1wiLDAuMzksLTAsMC40NSwwLjAzLDAuNTEsMC4wOV0sW1wiY1wiLDAuMDMsMC4wMywwLjA2LDAuMDksMC4wNiwwLjEyXSxbXCJjXCIsMCwwLjAzLDAuMDYsMC42NiwwLjE1LDEuMzhdLFtcImNcIiwwLjA5LDEuMDIsMC4xMiwxLjM4LDAuMDksMS40NF0sW1wiY1wiLC0wLjA2LDAuMTIsLTAuMDksMC4xMiwtMS41NiwtMC4wM10sW1wiY1wiLC0wLjc4LC0wLjA2LC0xLjQxLC0wLjE1LC0xLjQ0LC0wLjE1XSxbXCJjXCIsLTAuMDksLTAuMDYsLTAuMTIsLTAuMTIsLTAuMTIsLTAuNTRdLFtcImNcIiwtMC4wNiwtMC45MywtMC4yNCwtMS41NiwtMC41NywtMi4wN10sW1wiY1wiLC0wLjA2LC0wLjA5LC0wLjE1LC0wLjIxLC0wLjE4LC0wLjI0XSxbXCJsXCIsLTAuMDksLTAuMDZdLFtcImxcIiwtMC4wOSwwLjA2XSxbXCJjXCIsLTAuMDMsMC4wMywtMC4xMiwwLjE1LC0wLjE4LDAuMjRdLFtcImNcIiwtMC4zMywwLjUxLC0wLjUxLDEuMTQsLTAuNTcsMi4wN10sW1wiY1wiLDAsMC40MiwtMC4wMywwLjQ4LC0wLjEyLDAuNTRdLFtcImNcIiwtMC4wMywwLC0wLjY2LDAuMDksLTEuNDQsMC4xNV0sW1wiY1wiLC0xLjQ3LDAuMTUsLTEuNSwwLjE1LC0xLjU2LDAuMDNdLFtcImNcIiwtMC4wMywtMC4wNiwwLC0wLjQyLDAuMDksLTEuNDRdLFtcImNcIiwwLjA5LC0wLjcyLDAuMTUsLTEuMzUsMC4xNSwtMS4zOF0sW1wiY1wiLDAsLTAuMDMsMC4wMywtMC4wOSwwLjA2LC0wLjEyXSxbXCJjXCIsMC4wNiwtMC4wNiwwLjEyLC0wLjA5LDAuNTEsLTAuMDldLFtcImNcIiwwLjcyLC0wLjA2LDEuMjYsLTAuMTUsMS42OCwtMC4zM10sW1wiY1wiLDAuMjQsLTAuMTIsMC41MSwtMC4zLDAuNjMsLTAuNDVdLFtcImxcIiwwLjA5LC0wLjA5XSxbXCJsXCIsLTAuMTIsLTAuMDldLFtcImNcIiwtMC40OCwtMC40NSwtMS4yLC0wLjY5LC0yLjI4LC0wLjc1XSxbXCJjXCIsLTAuMzksMCwtMC40NSwtMC4wMywtMC41MSwtMC4wOV0sW1wiY1wiLC0wLjAzLC0wLjAzLC0wLjA2LC0wLjA5LC0wLjA2LC0wLjEyXSxbXCJjXCIsMCwtMC4wMywtMC4wNiwtMC42MywtMC4xMiwtMS4zOF0sW1wiY1wiLC0wLjA5LC0wLjcyLC0wLjE1LC0xLjM1LC0wLjE1LC0xLjM4XSxbXCJ6XCJdXSx3OjcuOTYxLGg6Ny45Nzd9LFwiZG90cy5kb3RcIjp7ZDpbW1wiTVwiLDEuMzIsLTEuNjhdLFtcImNcIiwwLjA5LC0wLjAzLDAuMjcsLTAuMDYsMC4zOSwtMC4wNl0sW1wiY1wiLDAuOTYsMCwxLjc0LDAuNzgsMS43NCwxLjcxXSxbXCJjXCIsMCwwLjk2LC0wLjc4LDEuNzQsLTEuNzEsMS43NF0sW1wiY1wiLC0wLjk2LDAsLTEuNzQsLTAuNzgsLTEuNzQsLTEuNzFdLFtcImNcIiwwLC0wLjc4LDAuNTQsLTEuNSwxLjMyLC0xLjY4XSxbXCJ6XCJdXSx3OjMuNDUsaDozLjQ1fSxcIm5vdGVoZWFkcy5kYmxcIjp7ZDpbW1wiTVwiLC0wLjY5LC00LjAyXSxbXCJjXCIsMC4xOCwtMC4wOSwwLjM2LC0wLjA5LDAuNTQsMF0sW1wiY1wiLDAuMTgsMC4wOSwwLjI0LDAuMTUsMC4zMywwLjNdLFtcImNcIiwwLjA2LDAuMTUsMC4wNiwwLjE4LDAuMDYsMS40MV0sW1wibFwiLC0wLDEuMjNdLFtcImxcIiwwLjEyLC0wLjE4XSxbXCJjXCIsMC43MiwtMS4yNiwyLjY0LC0yLjMxLDQuODYsLTIuNjRdLFtcImNcIiwwLjgxLC0wLjE1LDEuMTEsLTAuMTUsMi4xMywtMC4xNV0sW1wiY1wiLDAuOTksMCwxLjI5LDAsMi4xLDAuMTVdLFtcImNcIiwwLjc1LDAuMTIsMS4zOCwwLjI3LDIuMDQsMC41NF0sW1wiY1wiLDEuMzUsMC41MSwyLjM0LDEuMjYsMi44MiwyLjFdLFtcImxcIiwwLjEyLDAuMThdLFtcImxcIiwwLC0xLjIzXSxbXCJjXCIsMCwtMS4yLDAsLTEuMjYsMC4wNiwtMS4zOF0sW1wiY1wiLDAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzXSxbXCJjXCIsMC4xOCwtMC4wOSwwLjM2LC0wLjA5LDAuNTQsMF0sW1wiY1wiLDAuMTgsMC4wOSwwLjI0LDAuMTUsMC4zMywwLjNdLFtcImxcIiwwLjA2LDAuMTVdLFtcImxcIiwwLDMuNTRdLFtcImxcIiwwLDMuNTRdLFtcImxcIiwtMC4wNiwwLjE1XSxbXCJjXCIsLTAuMDksMC4xOCwtMC4xNSwwLjI0LC0wLjMzLDAuMzNdLFtcImNcIiwtMC4xOCwwLjA5LC0wLjM2LDAuMDksLTAuNTQsMF0sW1wiY1wiLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbXCJjXCIsLTAuMDYsLTAuMTIsLTAuMDYsLTAuMTgsLTAuMDYsLTEuMzhdLFtcImxcIiwwLC0xLjIzXSxbXCJsXCIsLTAuMTIsMC4xOF0sW1wiY1wiLC0wLjQ4LDAuODQsLTEuNDcsMS41OSwtMi44MiwyLjFdLFtcImNcIiwtMC44NCwwLjMzLC0xLjcxLDAuNTQsLTIuODUsMC42Nl0sW1wiY1wiLC0wLjQ1LDAuMDYsLTIuMTYsMC4wNiwtMi42MSwwXSxbXCJjXCIsLTEuMTQsLTAuMTIsLTIuMDEsLTAuMzMsLTIuODUsLTAuNjZdLFtcImNcIiwtMS4zNSwtMC41MSwtMi4zNCwtMS4yNiwtMi44MiwtMi4xXSxbXCJsXCIsLTAuMTIsLTAuMThdLFtcImxcIiwwLDEuMjNdLFtcImNcIiwwLDEuMjMsMCwxLjI2LC0wLjA2LDEuMzhdLFtcImNcIiwtMC4wOSwwLjE4LC0wLjE1LDAuMjQsLTAuMzMsMC4zM10sW1wiY1wiLC0wLjE4LDAuMDksLTAuMzYsMC4wOSwtMC41NCwwXSxbXCJjXCIsLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNdLFtcImxcIiwtMC4wNiwtMC4xNV0sW1wibFwiLDAsLTMuNTRdLFtcImNcIiwwLC0zLjQ4LDAsLTMuNTQsMC4wNiwtMy42Nl0sW1wiY1wiLDAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzXSxbXCJ6XCJdLFtcIm1cIiw3LjcxLDAuNjNdLFtcImNcIiwtMC4zNiwtMC4wNiwtMC45LC0wLjA2LC0xLjE0LDBdLFtcImNcIiwtMC4zLDAuMDMsLTAuNjYsMC4yNCwtMC44NywwLjQyXSxbXCJjXCIsLTAuNiwwLjU0LC0wLjksMS42MiwtMC43NSwyLjgyXSxbXCJjXCIsMC4xMiwwLjkzLDAuNTEsMS42OCwxLjExLDIuMzFdLFtcImNcIiwwLjc1LDAuNzIsMS44MywxLjIsMi44NSwxLjI2XSxbXCJjXCIsMS4wNSwwLjA2LDEuODMsLTAuNTQsMi4xLC0xLjY1XSxbXCJjXCIsMC4yMSwtMC45LDAuMTIsLTEuOTUsLTAuMjQsLTIuODJdLFtcImNcIiwtMC4zNiwtMC44MSwtMS4wOCwtMS41MywtMS45NSwtMS45NV0sW1wiY1wiLC0wLjMsLTAuMTUsLTAuNzgsLTAuMywtMS4xMSwtMC4zOV0sW1wielwiXV0sdzoxNi44MyxoOjguMTQ1fSxcIm5vdGVoZWFkcy53aG9sZVwiOntkOltbXCJNXCIsNi41MSwtNC4wNV0sW1wiY1wiLDAuNTEsLTAuMDMsMi4wMSwwLDIuNTIsMC4wM10sW1wiY1wiLDEuNDEsMC4xOCwyLjY0LDAuNTEsMy43MiwxLjA4XSxbXCJjXCIsMS4yLDAuNjMsMS45NSwxLjQxLDIuMTksMi4zMV0sW1wiY1wiLDAuMDksMC4zMywwLjA5LDAuOSwtMCwxLjIzXSxbXCJjXCIsLTAuMjQsMC45LC0wLjk5LDEuNjgsLTIuMTksMi4zMV0sW1wiY1wiLC0xLjA4LDAuNTcsLTIuMjgsMC45LC0zLjc1LDEuMDhdLFtcImNcIiwtMC42NiwwLjA2LC0yLjMxLDAuMDYsLTIuOTcsMF0sW1wiY1wiLC0xLjQ3LC0wLjE4LC0yLjY3LC0wLjUxLC0zLjc1LC0xLjA4XSxbXCJjXCIsLTEuMiwtMC42MywtMS45NSwtMS40MSwtMi4xOSwtMi4zMV0sW1wiY1wiLC0wLjA5LC0wLjMzLC0wLjA5LC0wLjksLTAsLTEuMjNdLFtcImNcIiwwLjI0LC0wLjksMC45OSwtMS42OCwyLjE5LC0yLjMxXSxbXCJjXCIsMS4yLC0wLjYzLDIuNjEsLTAuOTksNC4yMywtMS4xMV0sW1wielwiXSxbXCJtXCIsMC41NywwLjY2XSxbXCJjXCIsLTAuODcsLTAuMTUsLTEuNTMsMCwtMi4wNCwwLjUxXSxbXCJjXCIsLTAuMTUsMC4xNSwtMC4yNCwwLjI3LC0wLjMzLDAuNDhdLFtcImNcIiwtMC4yNCwwLjUxLC0wLjM2LDEuMDgsLTAuMzMsMS43N10sW1wiY1wiLDAuMDMsMC42OSwwLjE4LDEuMjYsMC40MiwxLjc3XSxbXCJjXCIsMC42LDEuMTcsMS43NCwxLjk4LDMuMTgsMi4yMl0sW1wiY1wiLDEuMTEsMC4yMSwxLjk1LC0wLjE1LDIuMzQsLTAuOTldLFtcImNcIiwwLjI0LC0wLjUxLDAuMzYsLTEuMDgsMC4zMywtMS44XSxbXCJjXCIsLTAuMDYsLTEuMTEsLTAuNDUsLTIuMDQsLTEuMTcsLTIuNzZdLFtcImNcIiwtMC42MywtMC42MywtMS40NywtMS4wNSwtMi40LC0xLjJdLFtcInpcIl1dLHc6MTQuOTg1LGg6OC4wOTd9LFwibm90ZWhlYWRzLmhhbGZcIjp7ZDpbW1wiTVwiLDcuNDQsLTQuMDVdLFtcImNcIiwwLjA2LC0wLjAzLDAuMjcsLTAuMDMsMC40OCwtMC4wM10sW1wiY1wiLDEuMDUsMCwxLjcxLDAuMjQsMi4xLDAuODFdLFtcImNcIiwwLjQyLDAuNiwwLjQ1LDEuMzUsMC4xOCwyLjRdLFtcImNcIiwtMC40MiwxLjU5LC0xLjE0LDIuNzMsLTIuMTYsMy4zOV0sW1wiY1wiLC0xLjQxLDAuOTMsLTMuMTgsMS40NCwtNS40LDEuNTNdLFtcImNcIiwtMS4xNywwLjAzLC0xLjg5LC0wLjIxLC0yLjI4LC0wLjgxXSxbXCJjXCIsLTAuNDIsLTAuNiwtMC40NSwtMS4zNSwtMC4xOCwtMi40XSxbXCJjXCIsMC40MiwtMS41OSwxLjE0LC0yLjczLDIuMTYsLTMuMzldLFtcImNcIiwwLjYzLC0wLjQyLDEuMjMsLTAuNzIsMS45OCwtMC45Nl0sW1wiY1wiLDAuOSwtMC4zLDEuNjUsLTAuNDIsMy4xMiwtMC41NF0sW1wielwiXSxbXCJtXCIsMS4yOSwwLjg3XSxbXCJjXCIsLTAuMjcsLTAuMDksLTAuNjMsLTAuMTIsLTAuOSwtMC4wM10sW1wiY1wiLC0wLjcyLDAuMjQsLTEuNTMsMC42OSwtMy4yNywxLjhdLFtcImNcIiwtMi4zNCwxLjUsLTMuMywyLjI1LC0zLjU3LDIuNzldLFtcImNcIiwtMC4zNiwwLjcyLC0wLjA2LDEuNSwwLjY2LDEuNzddLFtcImNcIiwwLjI0LDAuMTIsMC42OSwwLjA5LDAuOTksMF0sW1wiY1wiLDAuODQsLTAuMywxLjkyLC0wLjkzLDQuMTQsLTIuMzddLFtcImNcIiwxLjYyLC0xLjA4LDIuMzcsLTEuNzEsMi42MSwtMi4xOV0sW1wiY1wiLDAuMzYsLTAuNzIsMC4wNiwtMS41LC0wLjY2LC0xLjc3XSxbXCJ6XCJdXSx3OjEwLjM3LGg6OC4xMzJ9LFwibm90ZWhlYWRzLnF1YXJ0ZXJcIjp7ZDpbW1wiTVwiLDYuMDksLTQuMDVdLFtcImNcIiwwLjM2LC0wLjAzLDEuMiwwLDEuNTMsMC4wNl0sW1wiY1wiLDEuMTcsMC4yNCwxLjg5LDAuODQsMi4xNiwxLjgzXSxbXCJjXCIsMC4wNiwwLjE4LDAuMDYsMC4zLDAuMDYsMC42Nl0sW1wiY1wiLDAsMC40NSwwLDAuNjMsLTAuMTUsMS4wOF0sW1wiY1wiLC0wLjY2LDIuMDQsLTMuMDYsMy45MywtNS41Miw0LjM4XSxbXCJjXCIsLTAuNTQsMC4wOSwtMS40NCwwLjA5LC0xLjgzLDAuMDNdLFtcImNcIiwtMS4yMywtMC4yNywtMS45OCwtMC44NywtMi4yNSwtMS44Nl0sW1wiY1wiLC0wLjA2LC0wLjE4LC0wLjA2LC0wLjMsLTAuMDYsLTAuNjZdLFtcImNcIiwwLC0wLjQ1LDAsLTAuNjMsMC4xNSwtMS4wOF0sW1wiY1wiLDAuMjQsLTAuNzgsMC43NSwtMS41MywxLjQ0LC0yLjIyXSxbXCJjXCIsMS4yLC0xLjIsMi44NSwtMi4wMSw0LjQ3LC0yLjIyXSxbXCJ6XCJdXSx3OjkuODEsaDo4LjA5NH0sXCJzY3JpcHRzLnVmZXJtYXRhXCI6e2Q6W1tcIk1cIiwtMC43NSwtMTAuNzddLFtcImNcIiwwLjEyLDAsMC40NSwtMC4wMywwLjY5LC0wLjAzXSxbXCJjXCIsMi45MSwtMC4wMyw1LjU1LDEuNTMsNy40MSw0LjM1XSxbXCJjXCIsMS4xNywxLjcxLDEuOTUsMy43MiwyLjQzLDYuMDNdLFtcImNcIiwwLjEyLDAuNTEsMC4xMiwwLjU3LDAuMDMsMC42OV0sW1wiY1wiLC0wLjEyLDAuMjEsLTAuNDgsMC4yNywtMC42OSwwLjEyXSxbXCJjXCIsLTAuMTIsLTAuMDksLTAuMTgsLTAuMjQsLTAuMjcsLTAuNjldLFtcImNcIiwtMC43OCwtMy42MywtMy40MiwtNi41NCwtNi43OCwtNy4zOF0sW1wiY1wiLC0wLjc4LC0wLjIxLC0xLjIsLTAuMjQsLTIuMDcsLTAuMjRdLFtcImNcIiwtMC42MywtMCwtMC44NCwtMCwtMS4yLDAuMDZdLFtcImNcIiwtMS44MywwLjI3LC0zLjQyLDEuMDgsLTQuOCwyLjM3XSxbXCJjXCIsLTEuNDEsMS4zNSwtMi40LDMuMjEsLTIuODUsNS4xOV0sW1wiY1wiLC0wLjA5LDAuNDUsLTAuMTUsMC42LC0wLjI3LDAuNjldLFtcImNcIiwtMC4yMSwwLjE1LC0wLjU3LDAuMDksLTAuNjksLTAuMTJdLFtcImNcIiwtMC4wOSwtMC4xMiwtMC4wOSwtMC4xOCwwLjAzLC0wLjY5XSxbXCJjXCIsMC4zMywtMS42MiwwLjc4LC0zLDEuNDcsLTQuMzhdLFtcImNcIiwxLjc3LC0zLjU0LDQuNDQsLTUuNjcsNy41NiwtNS45N10sW1wielwiXSxbXCJtXCIsMC4zMyw3LjQ3XSxbXCJjXCIsMS4zOCwtMC4zLDIuNTgsMC45LDIuMzEsMi4yNV0sW1wiY1wiLC0wLjE1LDAuNzIsLTAuNzgsMS4zNSwtMS40NywxLjVdLFtcImNcIiwtMS4zOCwwLjI3LC0yLjU4LC0wLjkzLC0yLjMxLC0yLjMxXSxbXCJjXCIsMC4xNSwtMC42OSwwLjc4LC0xLjI5LDEuNDcsLTEuNDRdLFtcInpcIl1dLHc6MTkuNzQ4LGg6MTEuMjg5fSxcInNjcmlwdHMuZGZlcm1hdGFcIjp7ZDpbW1wiTVwiLC05LjYzLC0wLjQyXSxbXCJjXCIsMC4xNSwtMC4wOSwwLjM2LC0wLjA2LDAuNTEsMC4wM10sW1wiY1wiLDAuMTIsMC4wOSwwLjE4LDAuMjQsMC4yNywwLjY2XSxbXCJjXCIsMC43OCwzLjY2LDMuNDIsNi41Nyw2Ljc4LDcuNDFdLFtcImNcIiwwLjc4LDAuMjEsMS4yLDAuMjQsMi4wNywwLjI0XSxbXCJjXCIsMC42MywtMCwwLjg0LC0wLDEuMiwtMC4wNl0sW1wiY1wiLDEuODMsLTAuMjcsMy40MiwtMS4wOCw0LjgsLTIuMzddLFtcImNcIiwxLjQxLC0xLjM1LDIuNCwtMy4yMSwyLjg1LC01LjIyXSxbXCJjXCIsMC4wOSwtMC40MiwwLjE1LC0wLjU3LDAuMjcsLTAuNjZdLFtcImNcIiwwLjIxLC0wLjE1LDAuNTcsLTAuMDksMC42OSwwLjEyXSxbXCJjXCIsMC4wOSwwLjEyLDAuMDksMC4xOCwtMC4wMywwLjY5XSxbXCJjXCIsLTAuMzMsMS42MiwtMC43OCwzLC0xLjQ3LDQuMzhdLFtcImNcIiwtMS45MiwzLjg0LC00Ljg5LDYsLTguMzEsNl0sW1wiY1wiLC0zLjQyLDAsLTYuMzksLTIuMTYsLTguMzEsLTZdLFtcImNcIiwtMC40OCwtMC45NiwtMC44NCwtMS45MiwtMS4xNCwtMi45N10sW1wiY1wiLC0wLjE4LC0wLjY5LC0wLjQyLC0xLjc0LC0wLjQyLC0xLjkyXSxbXCJjXCIsMCwtMC4xMiwwLjA5LC0wLjI3LDAuMjQsLTAuMzNdLFtcInpcIl0sW1wibVwiLDkuMjEsMF0sW1wiY1wiLDEuMiwtMC4yNywyLjM0LDAuNjMsMi4zNCwxLjg2XSxbXCJjXCIsLTAsMC45LC0wLjY2LDEuNjgsLTEuNSwxLjg5XSxbXCJjXCIsLTEuMzgsMC4yNywtMi41OCwtMC45MywtMi4zMSwtMi4zMV0sW1wiY1wiLDAuMTUsLTAuNjksMC43OCwtMS4yOSwxLjQ3LC0xLjQ0XSxbXCJ6XCJdXSx3OjE5Ljc0NCxoOjExLjI3NH0sXCJzY3JpcHRzLnNmb3J6YXRvXCI6e2Q6W1tcIk1cIiwtNi40NSwtMy42OV0sW1wiY1wiLDAuMDYsLTAuMDMsMC4xNSwtMC4wNiwwLjE4LC0wLjA2XSxbXCJjXCIsMC4wNiwwLDIuODUsMC43Miw2LjI0LDEuNTldLFtcImxcIiw2LjMzLDEuNjVdLFtcImNcIiwwLjMzLDAuMDYsMC40NSwwLjIxLDAuNDUsMC41MV0sW1wiY1wiLDAsMC4zLC0wLjEyLDAuNDUsLTAuNDUsMC41MV0sW1wibFwiLC02LjMzLDEuNjVdLFtcImNcIiwtMy4zOSwwLjg3LC02LjE4LDEuNTksLTYuMjEsMS41OV0sW1wiY1wiLC0wLjIxLC0wLC0wLjQ4LC0wLjI0LC0wLjUxLC0wLjQ1XSxbXCJjXCIsMCwtMC4xNSwwLjA2LC0wLjM2LDAuMTgsLTAuNDVdLFtcImNcIiwwLjA5LC0wLjA2LDAuODcsLTAuMjcsMy44NCwtMS4wNV0sW1wiY1wiLDIuMDQsLTAuNTQsMy44NCwtMC45OSw0LjAyLC0xLjAyXSxbXCJjXCIsMC4xNSwtMC4wNiwxLjE0LC0wLjI0LDIuMjIsLTAuNDJdLFtcImNcIiwxLjA1LC0wLjE4LDEuOTIsLTAuMzYsMS45MiwtMC4zNl0sW1wiY1wiLDAsLTAsLTAuODcsLTAuMTgsLTEuOTIsLTAuMzZdLFtcImNcIiwtMS4wOCwtMC4xOCwtMi4wNywtMC4zNiwtMi4yMiwtMC40Ml0sW1wiY1wiLC0wLjE4LC0wLjAzLC0xLjk4LC0wLjQ4LC00LjAyLC0xLjAyXSxbXCJjXCIsLTIuOTcsLTAuNzgsLTMuNzUsLTAuOTksLTMuODQsLTEuMDVdLFtcImNcIiwtMC4xMiwtMC4wOSwtMC4xOCwtMC4zLC0wLjE4LC0wLjQ1XSxbXCJjXCIsMC4wMywtMC4xNSwwLjE1LC0wLjMsMC4zLC0wLjM5XSxbXCJ6XCJdXSx3OjEzLjUsaDo3LjV9LFwic2NyaXB0cy5zdGFjY2F0b1wiOntkOltbXCJNXCIsLTAuMzYsLTEuNDddLFtcImNcIiwwLjkzLC0wLjIxLDEuODYsMC41MSwxLjg2LDEuNDddLFtcImNcIiwtMCwwLjkzLC0wLjg3LDEuNjUsLTEuOCwxLjQ3XSxbXCJjXCIsLTAuNTQsLTAuMTIsLTEuMDIsLTAuNTcsLTEuMTQsLTEuMDhdLFtcImNcIiwtMC4yMSwtMC44MSwwLjI3LC0xLjY1LDEuMDgsLTEuODZdLFtcInpcIl1dLHc6Mi45ODksaDozLjAwNH0sXCJzY3JpcHRzLnRlbnV0b1wiOntkOltbXCJNXCIsLTQuMiwtMC40OF0sW1wibFwiLDAuMTIsLTAuMDZdLFtcImxcIiw0LjA4LDBdLFtcImxcIiw0LjA4LDBdLFtcImxcIiwwLjEyLDAuMDZdLFtcImNcIiwwLjM5LDAuMjEsMC4zOSwwLjc1LDAsMC45Nl0sW1wibFwiLC0wLjEyLDAuMDZdLFtcImxcIiwtNC4wOCwwXSxbXCJsXCIsLTQuMDgsMF0sW1wibFwiLC0wLjEyLC0wLjA2XSxbXCJjXCIsLTAuMzksLTAuMjEsLTAuMzksLTAuNzUsMCwtMC45Nl0sW1wielwiXV0sdzo4Ljk4NSxoOjEuMDh9LFwic2NyaXB0cy51bWFyY2F0b1wiOntkOltbXCJNXCIsLTAuMTUsLTguMTldLFtcImNcIiwwLjE1LC0wLjEyLDAuMzYsLTAuMDMsMC40NSwwLjE1XSxbXCJjXCIsMC4yMSwwLjQyLDMuNDUsNy42NSwzLjQ1LDcuNzFdLFtcImNcIiwtMCwwLjEyLC0wLjEyLDAuMjcsLTAuMjEsMC4zXSxbXCJjXCIsLTAuMDMsMC4wMywtMC41MSwwLjAzLC0xLjE0LDAuMDNdLFtcImNcIiwtMS4wNSwwLC0xLjA4LDAsLTEuMTcsLTAuMDZdLFtcImNcIiwtMC4wOSwtMC4wNiwtMC4yNCwtMC4zNiwtMS4xNywtMi40XSxbXCJjXCIsLTAuNTcsLTEuMjksLTEuMDUsLTIuMzQsLTEuMDgsLTIuMzRdLFtcImNcIiwtMCwtMC4wMywtMC41MSwxLjAyLC0xLjA4LDIuMzRdLFtcImNcIiwtMC45MywyLjA3LC0xLjA4LDIuMzQsLTEuMTQsMi40XSxbXCJjXCIsLTAuMDYsMC4wMywtMC4xNSwwLjA2LC0wLjE4LDAuMDZdLFtcImNcIiwtMC4xNSwwLC0wLjMzLC0wLjE4LC0wLjMzLC0wLjMzXSxbXCJjXCIsLTAsLTAuMDYsMy4yNCwtNy4zMiwzLjQ1LC03LjcxXSxbXCJjXCIsMC4wMywtMC4wNiwwLjA5LC0wLjE1LDAuMTUsLTAuMTVdLFtcInpcIl1dLHc6Ny41LGg6OC4yNDV9LFwic2NyaXB0cy5kbWFyY2F0b1wiOntkOltbXCJNXCIsLTMuNTcsMC4wM10sW1wiY1wiLDAuMDMsMCwwLjU3LC0wLjAzLDEuMTcsLTAuMDNdLFtcImNcIiwxLjA1LDAsMS4wOCwwLDEuMTcsMC4wNl0sW1wiY1wiLDAuMDksMC4wNiwwLjI0LDAuMzYsMS4xNywyLjRdLFtcImNcIiwwLjU3LDEuMjksMS4wNSwyLjM0LDEuMDgsMi4zNF0sW1wiY1wiLDAsMC4wMywwLjUxLC0xLjAyLDEuMDgsLTIuMzRdLFtcImNcIiwwLjkzLC0yLjA3LDEuMDgsLTIuMzQsMS4xNCwtMi40XSxbXCJjXCIsMC4wNiwtMC4wMywwLjE1LC0wLjA2LDAuMTgsLTAuMDZdLFtcImNcIiwwLjE1LDAsMC4zMywwLjE4LDAuMzMsMC4zM10sW1wiY1wiLDAsMC4wOSwtMy40NSw3Ljc0LC0zLjU0LDcuODNdLFtcImNcIiwtMC4xMiwwLjEyLC0wLjMsMC4xMiwtMC40MiwwXSxbXCJjXCIsLTAuMDksLTAuMDksLTMuNTQsLTcuNzQsLTMuNTQsLTcuODNdLFtcImNcIiwwLC0wLjA5LDAuMTIsLTAuMjcsMC4xOCwtMC4zXSxbXCJ6XCJdXSx3OjcuNSxoOjguMjV9LFwic2NyaXB0cy5zdG9wcGVkXCI6e2Q6W1tcIk1cIiwtMC4yNywtNC4wOF0sW1wiY1wiLDAuMTgsLTAuMDksMC4zNiwtMC4wOSwwLjU0LDBdLFtcImNcIiwwLjE4LDAuMDksMC4yNCwwLjE1LDAuMzMsMC4zXSxbXCJsXCIsMC4wNiwwLjE1XSxbXCJsXCIsLTAsMS41XSxbXCJsXCIsLTAsMS40N10sW1wibFwiLDEuNDcsMF0sW1wibFwiLDEuNSwwXSxbXCJsXCIsMC4xNSwwLjA2XSxbXCJjXCIsMC4xNSwwLjA5LDAuMjEsMC4xNSwwLjMsMC4zM10sW1wiY1wiLDAuMDksMC4xOCwwLjA5LDAuMzYsLTAsMC41NF0sW1wiY1wiLC0wLjA5LDAuMTgsLTAuMTUsMC4yNCwtMC4zMywwLjMzXSxbXCJjXCIsLTAuMTIsMC4wNiwtMC4xOCwwLjA2LC0xLjYyLDAuMDZdLFtcImxcIiwtMS40NywwXSxbXCJsXCIsLTAsMS40N10sW1wibFwiLC0wLDEuNDddLFtcImxcIiwtMC4wNiwwLjE1XSxbXCJjXCIsLTAuMDksMC4xOCwtMC4xNSwwLjI0LC0wLjMzLDAuMzNdLFtcImNcIiwtMC4xOCwwLjA5LC0wLjM2LDAuMDksLTAuNTQsMF0sW1wiY1wiLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbXCJsXCIsLTAuMDYsLTAuMTVdLFtcImxcIiwtMCwtMS40N10sW1wibFwiLC0wLC0xLjQ3XSxbXCJsXCIsLTEuNDcsMF0sW1wiY1wiLC0xLjQ0LDAsLTEuNSwwLC0xLjYyLC0wLjA2XSxbXCJjXCIsLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNdLFtcImNcIiwtMC4wOSwtMC4xOCwtMC4wOSwtMC4zNiwtMCwtMC41NF0sW1wiY1wiLDAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzXSxbXCJsXCIsMC4xNSwtMC4wNl0sW1wibFwiLDEuNDcsMF0sW1wibFwiLDEuNDcsMF0sW1wibFwiLC0wLC0xLjQ3XSxbXCJjXCIsLTAsLTEuNDQsLTAsLTEuNSwwLjA2LC0xLjYyXSxbXCJjXCIsMC4wOSwtMC4xOCwwLjE1LC0wLjI0LDAuMzMsLTAuMzNdLFtcInpcIl1dLHc6OC4yOTUsaDo4LjI5NX0sXCJzY3JpcHRzLnVwYm93XCI6e2Q6W1tcIk1cIiwtNC42NSwtMTUuNTRdLFtcImNcIiwwLjEyLC0wLjA5LDAuMzYsLTAuMDYsMC40OCwwLjAzXSxbXCJjXCIsMC4wMywwLjAzLDAuMDksMC4wOSwwLjEyLDAuMTVdLFtcImNcIiwwLjAzLDAuMDYsMC42NiwyLjEzLDEuNDEsNC42Ml0sW1wiY1wiLDEuMzUsNC40MSwxLjM4LDQuNTYsMi4wMSw2Ljk2XSxbXCJsXCIsMC42MywyLjQ2XSxbXCJsXCIsMC42MywtMi40Nl0sW1wiY1wiLDAuNjMsLTIuNCwwLjY2LC0yLjU1LDIuMDEsLTYuOTZdLFtcImNcIiwwLjc1LC0yLjQ5LDEuMzgsLTQuNTYsMS40MSwtNC42Ml0sW1wiY1wiLDAuMDYsLTAuMTUsMC4xOCwtMC4yMSwwLjM2LC0wLjI0XSxbXCJjXCIsMC4xNSwwLDAuMywwLjA2LDAuMzksMC4xOF0sW1wiY1wiLDAuMTUsMC4yMSwwLjI0LC0wLjE4LC0yLjEsNy41Nl0sW1wiY1wiLC0xLjIsMy45NiwtMi4yMiw3LjMyLC0yLjI1LDcuNDFdLFtcImNcIiwwLDAuMTIsLTAuMDYsMC4yNywtMC4wOSwwLjNdLFtcImNcIiwtMC4xMiwwLjIxLC0wLjYsMC4yMSwtMC43MiwwXSxbXCJjXCIsLTAuMDMsLTAuMDMsLTAuMDksLTAuMTgsLTAuMDksLTAuM10sW1wiY1wiLC0wLjAzLC0wLjA5LC0xLjA1LC0zLjQ1LC0yLjI1LC03LjQxXSxbXCJjXCIsLTIuMzQsLTcuNzQsLTIuMjUsLTcuMzUsLTIuMSwtNy41Nl0sW1wiY1wiLDAuMDMsLTAuMDMsMC4wOSwtMC4wOSwwLjE1LC0wLjEyXSxbXCJ6XCJdXSx3OjkuNzMsaDoxNS42MDh9LFwic2NyaXB0cy5kb3duYm93XCI6e2Q6W1tcIk1cIiwtNS41NSwtOS45M10sW1wibFwiLDAuMDksLTAuMDZdLFtcImxcIiw1LjQ2LDBdLFtcImxcIiw1LjQ2LDBdLFtcImxcIiwwLjA5LDAuMDZdLFtcImxcIiwwLjA2LDAuMDldLFtcImxcIiwwLDQuNzddLFtcImNcIiwwLDUuMjgsMCw0Ljg5LC0wLjE4LDUuMDFdLFtcImNcIiwtMC4xOCwwLjEyLC0wLjQyLDAuMDYsLTAuNTQsLTAuMTJdLFtcImNcIiwtMC4wNiwtMC4wOSwtMC4wNiwtMC4xOCwtMC4wNiwtMi45N10sW1wibFwiLDAsLTIuODVdLFtcImxcIiwtNC44MywwXSxbXCJsXCIsLTQuODMsMF0sW1wibFwiLDAsMi44NV0sW1wiY1wiLDAsMi43OSwwLDIuODgsLTAuMDYsMi45N10sW1wiY1wiLC0wLjE1LDAuMjQsLTAuNTEsMC4yNCwtMC42NiwwXSxbXCJjXCIsLTAuMDYsLTAuMDksLTAuMDYsLTAuMjEsLTAuMDYsLTQuODldLFtcImxcIiwwLC00Ljc3XSxbXCJ6XCJdXSx3OjExLjIyLGg6OS45OTJ9LFwic2NyaXB0cy50dXJuXCI6e2Q6W1tcIk1cIiwtNC43NywtMy45XSxbXCJjXCIsMC4zNiwtMC4wNiwxLjA1LC0wLjA2LDEuNDQsMC4wM10sW1wiY1wiLDAuNzgsMC4xNSwxLjUsMC41MSwyLjM0LDEuMTRdLFtcImNcIiwwLjYsMC40NSwxLjA1LDAuODcsMi4yMiwyLjAxXSxbXCJjXCIsMS4xMSwxLjA4LDEuNjIsMS41LDIuMjIsMS44Nl0sW1wiY1wiLDAuNiwwLjM2LDEuMzIsMC41NywxLjkyLDAuNTddLFtcImNcIiwwLjksLTAsMS43MSwtMC41NywxLjg5LC0xLjM1XSxbXCJjXCIsMC4yNCwtMC45MywtMC4zOSwtMS44OSwtMS4zNSwtMi4xXSxbXCJsXCIsLTAuMTUsLTAuMDZdLFtcImxcIiwtMC4wOSwwLjE1XSxbXCJjXCIsLTAuMDMsMC4wOSwtMC4xNSwwLjI0LC0wLjI0LDAuMzNdLFtcImNcIiwtMC43MiwwLjcyLC0yLjA0LDAuNTQsLTIuNDksLTAuMzZdLFtcImNcIiwtMC40OCwtMC45MywwLjAzLC0xLjg2LDEuMTcsLTIuMTldLFtcImNcIiwwLjMsLTAuMDksMS4wMiwtMC4wOSwxLjM1LC0wXSxbXCJjXCIsMC45OSwwLjI3LDEuNzQsMC44NywyLjI1LDEuODNdLFtcImNcIiwwLjY5LDEuNDEsMC42MywzLC0wLjIxLDQuMjZdLFtcImNcIiwtMC4yMSwwLjMsLTAuNjksMC44MSwtMC45OSwxLjAyXSxbXCJjXCIsLTAuMywwLjIxLC0wLjg0LDAuNDUsLTEuMTcsMC41NF0sW1wiY1wiLC0xLjIzLDAuMzYsLTIuNDksMC4xNSwtMy43MiwtMC42XSxbXCJjXCIsLTAuNzUsLTAuNDgsLTEuNDEsLTEuMDIsLTIuODUsLTIuNDZdLFtcImNcIiwtMS4xMSwtMS4wOCwtMS42MiwtMS41LC0yLjIyLC0xLjg2XSxbXCJjXCIsLTAuNiwtMC4zNiwtMS4zMiwtMC41NywtMS45MiwtMC41N10sW1wiY1wiLC0wLjksMCwtMS43MSwwLjU3LC0xLjg5LDEuMzVdLFtcImNcIiwtMC4yNCwwLjkzLDAuMzksMS44OSwxLjM1LDIuMV0sW1wibFwiLDAuMTUsMC4wNl0sW1wibFwiLDAuMDksLTAuMTVdLFtcImNcIiwwLjAzLC0wLjA5LDAuMTUsLTAuMjQsMC4yNCwtMC4zM10sW1wiY1wiLDAuNzIsLTAuNzIsMi4wNCwtMC41NCwyLjQ5LDAuMzZdLFtcImNcIiwwLjQ4LDAuOTMsLTAuMDMsMS44NiwtMS4xNywyLjE5XSxbXCJjXCIsLTAuMywwLjA5LC0xLjAyLDAuMDksLTEuMzUsMF0sW1wiY1wiLC0wLjk5LC0wLjI3LC0xLjc0LC0wLjg3LC0yLjI1LC0xLjgzXSxbXCJjXCIsLTAuNjksLTEuNDEsLTAuNjMsLTMsMC4yMSwtNC4yNl0sW1wiY1wiLDAuMjEsLTAuMywwLjY5LC0wLjgxLDAuOTksLTEuMDJdLFtcImNcIiwwLjQ4LC0wLjMzLDEuMTEsLTAuNTcsMS43NCwtMC42Nl0sW1wielwiXV0sdzoxNi4zNjYsaDo3Ljg5M30sXCJzY3JpcHRzLnRyaWxsXCI6e2Q6W1tcIk1cIiwtMC41MSwtMTYuMDJdLFtcImNcIiwwLjEyLC0wLjA5LDAuMjEsLTAuMTgsMC4yMSwtMC4xOF0sW1wibFwiLC0wLjgxLDQuMDJdLFtcImxcIiwtMC44MSw0LjAyXSxbXCJjXCIsMC4wMywwLDAuNTEsLTAuMjcsMS4wOCwtMC42XSxbXCJjXCIsMC42LC0wLjMsMS4xNCwtMC42MywxLjI2LC0wLjY2XSxbXCJjXCIsMS4xNCwtMC41NCwyLjMxLC0wLjYsMy4wOSwtMC4xOF0sW1wiY1wiLDAuMjcsMC4xNSwwLjU0LDAuMzYsMC42LDAuNTFdLFtcImxcIiwwLjA2LDAuMTJdLFtcImxcIiwwLjIxLC0wLjIxXSxbXCJjXCIsMC45LC0wLjgxLDIuMjIsLTAuOTksMy4xMiwtMC40Ml0sW1wiY1wiLDAuNiwwLjQyLDAuOSwxLjE0LDAuNzgsMi4wN10sW1wiY1wiLC0wLjE1LDEuMjksLTEuMDUsMi4zMSwtMS45NSwyLjI1XSxbXCJjXCIsLTAuNDgsLTAuMDMsLTAuNzgsLTAuMywtMC45NiwtMC44MV0sW1wiY1wiLC0wLjA5LC0wLjI3LC0wLjA5LC0wLjksLTAuMDMsLTEuMl0sW1wiY1wiLDAuMjEsLTAuNzUsMC44MSwtMS4yMywxLjU5LC0xLjMyXSxbXCJsXCIsMC4yNCwtMC4wM10sW1wibFwiLC0wLjA5LC0wLjEyXSxbXCJjXCIsLTAuNTEsLTAuNjYsLTEuNjIsLTAuNjMsLTIuMzEsMC4wM10sW1wiY1wiLC0wLjM5LDAuNDIsLTAuMywwLjA5LC0xLjIzLDQuNzddLFtcImxcIiwtMC44MSw0LjE0XSxbXCJjXCIsLTAuMDMsMCwtMC4xMiwtMC4wMywtMC4yMSwtMC4wOV0sW1wiY1wiLC0wLjMzLC0wLjE1LC0wLjU0LC0wLjE4LC0wLjk5LC0wLjE4XSxbXCJjXCIsLTAuNDIsMCwtMC42NiwwLjAzLC0xLjA1LDAuMThdLFtcImNcIiwtMC4xMiwwLjA2LC0wLjIxLDAuMDksLTAuMjEsMC4wOV0sW1wiY1wiLDAsLTAuMDMsMC4zNiwtMS44NiwwLjgxLC00LjExXSxbXCJjXCIsMC45LC00LjQ3LDAuODcsLTQuMjYsMC42OSwtNC41M10sW1wiY1wiLC0wLjIxLC0wLjM2LC0wLjY2LC0wLjUxLC0xLjE3LC0wLjM2XSxbXCJjXCIsLTAuMTUsMC4wNiwtMi4yMiwxLjE0LC0yLjU4LDEuMzhdLFtcImNcIiwtMC4xMiwwLjA5LC0wLjEyLDAuMDksLTAuMjEsMC42XSxbXCJsXCIsLTAuMDksMC41MV0sW1wibFwiLDAuMjEsMC4yNF0sW1wiY1wiLDAuNjMsMC43NSwxLjAyLDEuNDcsMS4yLDIuMTldLFtcImNcIiwwLjA2LDAuMjcsMC4wNiwwLjM2LDAuMDYsMC44MV0sW1wiY1wiLDAsMC40MiwwLDAuNTQsLTAuMDYsMC43OF0sW1wiY1wiLC0wLjE1LDAuNTQsLTAuMzMsMC45MywtMC42MywxLjM1XSxbXCJjXCIsLTAuMTgsMC4yNCwtMC41NywwLjYzLC0wLjgxLDAuNzhdLFtcImNcIiwtMC4yNCwwLjE1LC0wLjYzLDAuMzYsLTAuODQsMC40Ml0sW1wiY1wiLC0wLjI3LDAuMDYsLTAuNjYsMC4wNiwtMC44NywwLjAzXSxbXCJjXCIsLTAuODEsLTAuMTgsLTEuMzIsLTEuMDUsLTEuMzgsLTIuNDZdLFtcImNcIiwtMC4wMywtMC42LDAuMDMsLTAuOTksMC4zMywtMi40Nl0sW1wiY1wiLDAuMjEsLTEuMDgsMC4yNCwtMS4zMiwwLjIxLC0xLjI5XSxbXCJjXCIsLTEuMiwwLjQ4LC0yLjQsMC43NSwtMy4yMSwwLjcyXSxbXCJjXCIsLTAuNjksLTAuMDYsLTEuMTcsLTAuMywtMS40MSwtMC43Ml0sW1wiY1wiLC0wLjM5LC0wLjc1LC0wLjEyLC0xLjgsMC42NiwtMi40Nl0sW1wiY1wiLDAuMjQsLTAuMTgsMC42OSwtMC40MiwxLjAyLC0wLjUxXSxbXCJjXCIsMC42OSwtMC4xOCwxLjUzLC0wLjE1LDIuMzEsMC4wOV0sW1wiY1wiLDAuMywwLjA5LDAuNzUsMC4zLDAuOTksMC40NV0sW1wiY1wiLDAuMTIsMC4wOSwwLjE1LDAuMDksMC4xNSwwLjAzXSxbXCJjXCIsMC4wMywtMC4wMywwLjMzLC0xLjU5LDAuNzIsLTMuNDVdLFtcImNcIiwwLjM2LC0xLjg2LDAuNjYsLTMuNDIsMC42OSwtMy40NV0sW1wiY1wiLDAsLTAuMDMsMC4wMywtMC4wMywwLjIxLDAuMDNdLFtcImNcIiwwLjIxLDAuMDYsMC4yNywwLjA2LDAuNDgsMC4wNl0sW1wiY1wiLDAuNDIsLTAuMDMsMC43OCwtMC4xOCwxLjI2LC0wLjQ4XSxbXCJjXCIsMC4xNSwtMC4xMiwwLjM2LC0wLjI3LDAuNDgsLTAuMzldLFtcInpcIl0sW1wibVwiLC01LjczLDcuNjhdLFtcImNcIiwtMC4yNywtMC4wMywtMC45NiwtMC4wNiwtMS4yLC0wLjAzXSxbXCJjXCIsLTAuODEsMC4xMiwtMS4zNSwwLjU3LC0xLjUsMS4yXSxbXCJjXCIsLTAuMTgsMC42NiwwLjEyLDEuMTQsMC43NSwxLjI5XSxbXCJjXCIsMC42NiwwLjEyLDEuOTIsLTAuMTIsMy4xOCwtMC42Nl0sW1wibFwiLDAuMzMsLTAuMTVdLFtcImxcIiwwLjA5LC0wLjM5XSxbXCJjXCIsMC4wNiwtMC4yMSwwLjA5LC0wLjQyLDAuMDksLTAuNDVdLFtcImNcIiwwLC0wLjAzLC0wLjQ1LC0wLjMsLTAuNzUsLTAuNDVdLFtcImNcIiwtMC4yNywtMC4xNSwtMC42NiwtMC4yNywtMC45OSwtMC4zNl0sW1wielwiXSxbXCJtXCIsNC4yOSwzLjYzXSxbXCJjXCIsLTAuMjQsLTAuMzksLTAuNTEsLTAuNzUsLTAuNTEsLTAuNjldLFtcImNcIiwtMC4wNiwwLjEyLC0wLjM5LDEuOTIsLTAuNDUsMi4yOF0sW1wiY1wiLC0wLjA5LDAuNTQsLTAuMTIsMS4xNCwtMC4wNiwxLjM4XSxbXCJjXCIsMC4wNiwwLjQyLDAuMjEsMC42LDAuNTEsMC41N10sW1wiY1wiLDAuMzksLTAuMDYsMC43NSwtMC40OCwwLjkzLC0xLjE0XSxbXCJjXCIsMC4wOSwtMC4zMywwLjA5LC0xLjA1LC0wLC0xLjM4XSxbXCJjXCIsLTAuMDksLTAuMzksLTAuMjQsLTAuNjksLTAuNDIsLTEuMDJdLFtcInpcIl1dLHc6MTcuOTYzLGg6MTYuNDl9LFwic2NyaXB0cy5zZWdub1wiOntkOltbXCJNXCIsLTMuNzIsLTExLjIyXSxbXCJjXCIsMC43OCwtMC4wOSwxLjU5LDAuMDMsMi4zMSwwLjQyXSxbXCJjXCIsMS4yLDAuNiwyLjAxLDEuNzEsMi4zMSwzLjA5XSxbXCJjXCIsMC4wOSwwLjQyLDAuMDksMS4yLDAuMDMsMS41XSxbXCJjXCIsLTAuMTUsMC40NSwtMC4zOSwwLjgxLC0wLjY2LDAuOTNdLFtcImNcIiwtMC4zMywwLjE4LC0wLjg0LDAuMjEsLTEuMjMsMC4xNV0sW1wiY1wiLC0wLjgxLC0wLjE4LC0xLjMyLC0wLjkzLC0xLjI2LC0xLjg5XSxbXCJjXCIsMC4wMywtMC4zNiwwLjA5LC0wLjU3LDAuMjQsLTAuOV0sW1wiY1wiLDAuMTUsLTAuMzMsMC40NSwtMC42LDAuNzIsLTAuNzVdLFtcImNcIiwwLjEyLC0wLjA2LDAuMTgsLTAuMDksMC4xOCwtMC4xMl0sW1wiY1wiLDAsLTAuMDMsLTAuMDMsLTAuMTUsLTAuMDksLTAuMjRdLFtcImNcIiwtMC4xOCwtMC40NSwtMC41NCwtMC44NywtMC45NiwtMS4wOF0sW1wiY1wiLC0xLjExLC0wLjU3LC0yLjM0LC0wLjE4LC0yLjg4LDAuOV0sW1wiY1wiLC0wLjI0LDAuNTEsLTAuMzMsMS4xMSwtMC4yNCwxLjgzXSxbXCJjXCIsMC4yNywxLjkyLDEuNSwzLjU0LDMuOTMsNS4xM10sW1wiY1wiLDAuNDgsMC4zMywxLjI2LDAuNzgsMS4yOSwwLjc4XSxbXCJjXCIsMC4wMywwLDEuMzUsLTIuMTksMi45NCwtNC44OV0sW1wibFwiLDIuODgsLTQuODldLFtcImxcIiwwLjg0LDBdLFtcImxcIiwwLjg3LDBdLFtcImxcIiwtMC4wMywwLjA2XSxbXCJjXCIsLTAuMTUsMC4yMSwtNi4xNSwxMC40MSwtNi4xNSwxMC40NF0sW1wiY1wiLDAsMCwwLjIxLDAuMTUsMC40OCwwLjI3XSxbXCJjXCIsMi42MSwxLjQ3LDQuMzUsMy4wMyw1LjEzLDQuNjVdLFtcImNcIiwxLjE0LDIuMzQsMC41MSw1LjA3LC0xLjQ0LDYuMzldLFtcImNcIiwtMC42NiwwLjQyLC0xLjMyLDAuNjMsLTIuMTMsMC42OV0sW1wiY1wiLC0yLjAxLDAuMDksLTMuODEsLTEuNDEsLTQuMjYsLTMuNTRdLFtcImNcIiwtMC4wOSwtMC40MiwtMC4wOSwtMS4yLC0wLjAzLC0xLjVdLFtcImNcIiwwLjE1LC0wLjQ1LDAuMzksLTAuODEsMC42NiwtMC45M10sW1wiY1wiLDAuMzMsLTAuMTgsMC44NCwtMC4yMSwxLjIzLC0wLjE1XSxbXCJjXCIsMC44MSwwLjE4LDEuMzIsMC45MywxLjI2LDEuODldLFtcImNcIiwtMC4wMywwLjM2LC0wLjA5LDAuNTcsLTAuMjQsMC45XSxbXCJjXCIsLTAuMTUsMC4zMywtMC40NSwwLjYsLTAuNzIsMC43NV0sW1wiY1wiLC0wLjEyLDAuMDYsLTAuMTgsMC4wOSwtMC4xOCwwLjEyXSxbXCJjXCIsMCwwLjAzLDAuMDMsMC4xNSwwLjA5LDAuMjRdLFtcImNcIiwwLjE4LDAuNDUsMC41NCwwLjg3LDAuOTYsMS4wOF0sW1wiY1wiLDEuMTEsMC41NywyLjM0LDAuMTgsMi44OCwtMC45XSxbXCJjXCIsMC4yNCwtMC41MSwwLjMzLC0xLjExLDAuMjQsLTEuODNdLFtcImNcIiwtMC4yNywtMS45MiwtMS41LC0zLjU0LC0zLjkzLC01LjEzXSxbXCJjXCIsLTAuNDgsLTAuMzMsLTEuMjYsLTAuNzgsLTEuMjksLTAuNzhdLFtcImNcIiwtMC4wMywwLC0xLjM1LDIuMTksLTIuOTEsNC44OV0sW1wibFwiLC0yLjg4LDQuODldLFtcImxcIiwtMC44NywwXSxbXCJsXCIsLTAuODcsMF0sW1wibFwiLDAuMDMsLTAuMDZdLFtcImNcIiwwLjE1LC0wLjIxLDYuMTUsLTEwLjQxLDYuMTUsLTEwLjQ0XSxbXCJjXCIsMCwwLC0wLjIxLC0wLjE1LC0wLjQ4LC0wLjNdLFtcImNcIiwtMi42MSwtMS40NCwtNC4zNSwtMywtNS4xMywtNC42Ml0sW1wiY1wiLC0wLjksLTEuODksLTAuNzIsLTQuMDIsMC40OCwtNS41Ml0sW1wiY1wiLDAuNjksLTAuODQsMS42OCwtMS40MSwyLjczLC0xLjUzXSxbXCJ6XCJdLFtcIm1cIiw4Ljc2LDkuMDldLFtcImNcIiwwLjAzLC0wLjAzLDAuMTUsLTAuMDMsMC4yNywtMC4wM10sW1wiY1wiLDAuMzMsMC4wMywwLjU3LDAuMTgsMC43MiwwLjQ4XSxbXCJjXCIsMC4wOSwwLjE4LDAuMDksMC41NywwLDAuNzVdLFtcImNcIiwtMC4wOSwwLjE4LC0wLjIxLDAuMywtMC4zNiwwLjM5XSxbXCJjXCIsLTAuMTUsMC4wNiwtMC4yMSwwLjA2LC0wLjM5LDAuMDZdLFtcImNcIiwtMC4yMSwwLC0wLjI3LDAsLTAuMzksLTAuMDZdLFtcImNcIiwtMC4zLC0wLjE1LC0wLjQ4LC0wLjQ1LC0wLjQ4LC0wLjc1XSxbXCJjXCIsMCwtMC4zOSwwLjI0LC0wLjcyLDAuNjMsLTAuODRdLFtcInpcIl0sW1wibVwiLC0xMC41MywyLjYxXSxbXCJjXCIsMC4wMywtMC4wMywwLjE1LC0wLjAzLDAuMjcsLTAuMDNdLFtcImNcIiwwLjMzLDAuMDMsMC41NywwLjE4LDAuNzIsMC40OF0sW1wiY1wiLDAuMDksMC4xOCwwLjA5LDAuNTcsMCwwLjc1XSxbXCJjXCIsLTAuMDksMC4xOCwtMC4yMSwwLjMsLTAuMzYsMC4zOV0sW1wiY1wiLC0wLjE1LDAuMDYsLTAuMjEsMC4wNiwtMC4zOSwwLjA2XSxbXCJjXCIsLTAuMjEsMCwtMC4yNywwLC0wLjM5LC0wLjA2XSxbXCJjXCIsLTAuMywtMC4xNSwtMC40OCwtMC40NSwtMC40OCwtMC43NV0sW1wiY1wiLDAsLTAuMzksMC4yNCwtMC43MiwwLjYzLC0wLjg0XSxbXCJ6XCJdXSx3OjE1LGg6MjIuNTA0fSxcInNjcmlwdHMuY29kYVwiOntkOltbXCJNXCIsLTAuMjEsLTEwLjQ3XSxbXCJjXCIsMC4xOCwtMC4xMiwwLjQyLC0wLjA2LDAuNTQsMC4xMl0sW1wiY1wiLDAuMDYsMC4wOSwwLjA2LDAuMTgsMC4wNiwxLjVdLFtcImxcIiwwLDEuMzhdLFtcImxcIiwwLjE4LDBdLFtcImNcIiwwLjM5LDAuMDYsMC45NiwwLjI0LDEuMzgsMC40OF0sW1wiY1wiLDEuNjgsMC45MywyLjgyLDMuMjQsMy4wMyw2LjEyXSxbXCJjXCIsMC4wMywwLjI0LDAuMDMsMC40NSwwLjAzLDAuNDVdLFtcImNcIiwwLDAuMDMsMC42LDAuMDMsMS4zNSwwLjAzXSxbXCJjXCIsMS41LDAsMS40NywwLDEuNTksMC4xOF0sW1wiY1wiLDAuMDksMC4xMiwwLjA5LDAuMywtMCwwLjQyXSxbXCJjXCIsLTAuMTIsMC4xOCwtMC4wOSwwLjE4LC0xLjU5LDAuMThdLFtcImNcIiwtMC43NSwwLC0xLjM1LDAsLTEuMzUsMC4wM10sW1wiY1wiLC0wLDAsLTAsMC4yMSwtMC4wMywwLjQyXSxbXCJjXCIsLTAuMjQsMy4xNSwtMS41Myw1LjU4LC0zLjQ1LDYuMzZdLFtcImNcIiwtMC4yNywwLjEyLC0wLjcyLDAuMjQsLTAuOTYsMC4yN10sW1wibFwiLC0wLjE4LC0wXSxbXCJsXCIsLTAsMS4zOF0sW1wiY1wiLC0wLDEuMzIsLTAsMS40MSwtMC4wNiwxLjVdLFtcImNcIiwtMC4xNSwwLjI0LC0wLjUxLDAuMjQsLTAuNjYsLTBdLFtcImNcIiwtMC4wNiwtMC4wOSwtMC4wNiwtMC4xOCwtMC4wNiwtMS41XSxbXCJsXCIsLTAsLTEuMzhdLFtcImxcIiwtMC4xOCwtMF0sW1wiY1wiLC0wLjM5LC0wLjA2LC0wLjk2LC0wLjI0LC0xLjM4LC0wLjQ4XSxbXCJjXCIsLTEuNjgsLTAuOTMsLTIuODIsLTMuMjQsLTMuMDMsLTYuMTVdLFtcImNcIiwtMC4wMywtMC4yMSwtMC4wMywtMC40MiwtMC4wMywtMC40Ml0sW1wiY1wiLDAsLTAuMDMsLTAuNiwtMC4wMywtMS4zNSwtMC4wM10sW1wiY1wiLC0xLjUsLTAsLTEuNDcsLTAsLTEuNTksLTAuMThdLFtcImNcIiwtMC4wOSwtMC4xMiwtMC4wOSwtMC4zLDAsLTAuNDJdLFtcImNcIiwwLjEyLC0wLjE4LDAuMDksLTAuMTgsMS41OSwtMC4xOF0sW1wiY1wiLDAuNzUsLTAsMS4zNSwtMCwxLjM1LC0wLjAzXSxbXCJjXCIsMCwtMCwwLC0wLjIxLDAuMDMsLTAuNDVdLFtcImNcIiwwLjI0LC0zLjEyLDEuNTMsLTUuNTUsMy40NSwtNi4zM10sW1wiY1wiLDAuMjcsLTAuMTIsMC43MiwtMC4yNCwwLjk2LC0wLjI3XSxbXCJsXCIsMC4xOCwtMF0sW1wibFwiLDAsLTEuMzhdLFtcImNcIiwwLC0xLjUzLDAsLTEuNSwwLjE4LC0xLjYyXSxbXCJ6XCJdLFtcIm1cIiwtMC4xOCw2LjkzXSxbXCJjXCIsMCwtMi45NywwLC0zLjE1LC0wLjA2LC0zLjE1XSxbXCJjXCIsLTAuMDksMCwtMC41MSwwLjE1LC0wLjY2LDAuMjFdLFtcImNcIiwtMC44NywwLjUxLC0xLjM4LDEuNjIsLTEuNTYsMy41MV0sW1wiY1wiLC0wLjA2LDAuNTQsLTAuMTIsMS41OSwtMC4xMiwyLjE2XSxbXCJsXCIsMCwwLjQyXSxbXCJsXCIsMS4yLDBdLFtcImxcIiwxLjIsMF0sW1wibFwiLDAsLTMuMTVdLFtcInpcIl0sW1wibVwiLDEuMTcsLTMuMDZdLFtcImNcIiwtMC4wOSwtMC4wMywtMC4yMSwtMC4wNiwtMC4yNywtMC4wOV0sW1wibFwiLC0wLjEyLDBdLFtcImxcIiwwLDMuMTVdLFtcImxcIiwwLDMuMTVdLFtcImxcIiwxLjIsMF0sW1wibFwiLDEuMiwwXSxbXCJsXCIsMCwtMC44MV0sW1wiY1wiLC0wLjA2LC0yLjQsLTAuMzMsLTMuNjksLTAuOTMsLTQuNTldLFtcImNcIiwtMC4yNywtMC4zOSwtMC42NiwtMC42OSwtMS4wOCwtMC44MV0sW1wielwiXSxbXCJtXCIsLTEuMTcsMTAuMTRdLFtcImxcIiwwLC0zLjE1XSxbXCJsXCIsLTEuMiwtMF0sW1wibFwiLC0xLjIsLTBdLFtcImxcIiwwLDAuODFdLFtcImNcIiwwLjAzLDAuOTYsMC4wNiwxLjQ3LDAuMTUsMi4xM10sW1wiY1wiLDAuMjQsMi4wNCwwLjk2LDMuMTIsMi4xMywzLjM2XSxbXCJsXCIsMC4xMiwtMF0sW1wibFwiLDAsLTMuMTVdLFtcInpcIl0sW1wibVwiLDMuMTgsLTIuMzRdLFtcImxcIiwwLC0wLjgxXSxbXCJsXCIsLTEuMiwwXSxbXCJsXCIsLTEuMiwwXSxbXCJsXCIsMCwzLjE1XSxbXCJsXCIsMCwzLjE1XSxbXCJsXCIsMC4xMiwwXSxbXCJjXCIsMS4xNywtMC4yNCwxLjg5LC0xLjMyLDIuMTMsLTMuMzZdLFtcImNcIiwwLjA5LC0wLjY2LDAuMTIsLTEuMTcsMC4xNSwtMi4xM10sW1wielwiXV0sdzoxNi4wMzUsaDoyMS4wNjJ9LFwic2NyaXB0cy5jb21tYVwiOntkOltbXCJNXCIsMS4xNCwtNC42Ml0sW1wiY1wiLDAuMywtMC4xMiwwLjY5LC0wLjAzLDAuOTMsMC4xNV0sW1wiY1wiLDAuMTIsMC4xMiwwLjM2LDAuNDUsMC41MSwwLjc4XSxbXCJjXCIsMC45LDEuNzcsMC41NCw0LjA1LC0xLjA4LDYuNzVdLFtcImNcIiwtMC4zNiwwLjYzLC0wLjg3LDEuMzgsLTAuOTYsMS40NF0sW1wiY1wiLC0wLjE4LDAuMTIsLTAuNDIsMC4wNiwtMC41NCwtMC4xMl0sW1wiY1wiLC0wLjA5LC0wLjE4LC0wLjA5LC0wLjMsMC4xMiwtMC42XSxbXCJjXCIsMC45NiwtMS40NCwxLjQ0LC0yLjk3LDEuMzgsLTQuMzVdLFtcImNcIiwtMC4wNiwtMC45MywtMC4zLC0xLjY4LC0wLjc4LC0yLjQ2XSxbXCJjXCIsLTAuMjcsLTAuMzksLTAuMzMsLTAuNjMsLTAuMjQsLTAuOTZdLFtcImNcIiwwLjA5LC0wLjI3LDAuMzYsLTAuNTQsMC42NiwtMC42M10sW1wielwiXV0sdzozLjA0MixoOjkuMjM3fSxcInNjcmlwdHMucm9sbFwiOntkOltbXCJNXCIsMS45NSwtNl0sW1wiY1wiLDAuMjEsLTAuMDksMC4zNiwtMC4wOSwwLjU3LDBdLFtcImNcIiwwLjM5LDAuMTUsMC42MywwLjM5LDEuNDcsMS4zNV0sW1wiY1wiLDAuNjYsMC43NSwwLjc4LDAuODcsMS4wOCwxLjA1XSxbXCJjXCIsMC43NSwwLjQ1LDEuNjUsMC40MiwyLjQsLTAuMDZdLFtcImNcIiwwLjEyLC0wLjA5LDAuMjcsLTAuMjcsMC41NCwtMC42XSxbXCJjXCIsMC40MiwtMC41NCwwLjUxLC0wLjYzLDAuNjksLTAuNjNdLFtcImNcIiwwLjA5LDAsMC4zLDAuMTIsMC4zNiwwLjIxXSxbXCJjXCIsMC4wOSwwLjEyLDAuMTIsMC4zLDAuMDMsMC40Ml0sW1wiY1wiLC0wLjA2LDAuMTIsLTMuMTUsMy45LC0zLjMsNC4wOF0sW1wiY1wiLC0wLjA2LDAuMDYsLTAuMTgsMC4xMiwtMC4yNywwLjE4XSxbXCJjXCIsLTAuMjcsMC4xMiwtMC42LDAuMDYsLTAuOTksLTAuMjddLFtcImNcIiwtMC4yNywtMC4yMSwtMC40MiwtMC4zOSwtMS4wOCwtMS4xNF0sW1wiY1wiLC0wLjYzLC0wLjcyLC0wLjgxLC0wLjksLTEuMTcsLTEuMDhdLFtcImNcIiwtMC4zNiwtMC4xOCwtMC41NywtMC4yMSwtMC45OSwtMC4yMV0sW1wiY1wiLC0wLjM5LDAsLTAuNjMsMC4wMywtMC45MywwLjE4XSxbXCJjXCIsLTAuMzYsMC4xNSwtMC41MSwwLjI3LC0wLjksMC44MV0sW1wiY1wiLC0wLjI0LDAuMjcsLTAuNDUsMC41MSwtMC40OCwwLjU0XSxbXCJjXCIsLTAuMTIsMC4wOSwtMC4yNywwLjA2LC0wLjM5LDBdLFtcImNcIiwtMC4yNCwtMC4xNSwtMC4zMywtMC4zOSwtMC4yMSwtMC42XSxbXCJjXCIsMC4wOSwtMC4xMiwzLjE4LC0zLjg3LDMuMzMsLTQuMDJdLFtcImNcIiwwLjA2LC0wLjA2LDAuMTgsLTAuMTUsMC4yNCwtMC4yMV0sW1wielwiXV0sdzoxMC44MTcsaDo2LjEyNX0sXCJzY3JpcHRzLnByYWxsXCI6e2Q6W1tcIk1cIiwtNC4zOCwtMy42OV0sW1wiY1wiLDAuMDYsLTAuMDMsMC4xOCwtMC4wNiwwLjI0LC0wLjA2XSxbXCJjXCIsMC4zLDAsMC4yNywtMC4wMywxLjg5LDEuOTVdLFtcImxcIiwxLjUzLDEuODNdLFtcImNcIiwwLjAzLC0wLDAuNTcsLTAuODQsMS4yMywtMS44M10sW1wiY1wiLDEuMTQsLTEuNjgsMS4yMywtMS44MywxLjM1LC0xLjg5XSxbXCJjXCIsMC4wNiwtMC4wMywwLjE4LC0wLjA2LDAuMjQsLTAuMDZdLFtcImNcIiwwLjMsMCwwLjI3LC0wLjAzLDEuODksMS45NV0sW1wibFwiLDEuNTMsMS44M10sW1wibFwiLDAuNDgsLTAuNjldLFtcImNcIiwwLjUxLC0wLjc4LDAuNTQsLTAuODQsMC42OSwtMC45XSxbXCJjXCIsMC40MiwtMC4xOCwwLjg3LDAuMTUsMC44MSwwLjZdLFtcImNcIiwtMC4wMywwLjEyLC0wLjMsMC41MSwtMS41LDIuMzddLFtcImNcIiwtMS4zOCwyLjA3LC0xLjUsMi4yMiwtMS42MiwyLjI4XSxbXCJjXCIsLTAuMDYsMC4wMywtMC4xOCwwLjA2LC0wLjI0LDAuMDZdLFtcImNcIiwtMC4zLDAsLTAuMjcsMC4wMywtMS44OSwtMS45NV0sW1wibFwiLC0xLjUzLC0xLjgzXSxbXCJjXCIsLTAuMDMsMCwtMC41NywwLjg0LC0xLjIzLDEuODNdLFtcImNcIiwtMS4xNCwxLjY4LC0xLjIzLDEuODMsLTEuMzUsMS44OV0sW1wiY1wiLC0wLjA2LDAuMDMsLTAuMTgsMC4wNiwtMC4yNCwwLjA2XSxbXCJjXCIsLTAuMywwLC0wLjI3LDAuMDMsLTEuODksLTEuOTVdLFtcImxcIiwtMS41MywtMS44M10sW1wibFwiLC0wLjQ4LDAuNjldLFtcImNcIiwtMC41MSwwLjc4LC0wLjU0LDAuODQsLTAuNjksMC45XSxbXCJjXCIsLTAuNDIsMC4xOCwtMC44NywtMC4xNSwtMC44MSwtMC42XSxbXCJjXCIsMC4wMywtMC4xMiwwLjMsLTAuNTEsMS41LC0yLjM3XSxbXCJjXCIsMS4zOCwtMi4wNywxLjUsLTIuMjIsMS42MiwtMi4yOF0sW1wielwiXV0sdzoxNS4wMTEsaDo3LjV9LFwic2NyaXB0cy5tb3JkZW50XCI6e2Q6W1tcIk1cIiwtMC4yMSwtNC45NV0sW1wiY1wiLDAuMjcsLTAuMTUsMC42MywwLDAuNzUsMC4yN10sW1wiY1wiLDAuMDYsMC4xMiwwLjA2LDAuMjQsMC4wNiwxLjQ0XSxbXCJsXCIsMCwxLjI5XSxbXCJsXCIsMC41NywtMC44NF0sW1wiY1wiLDAuNTEsLTAuNzUsMC41NywtMC44NCwwLjY5LC0wLjldLFtcImNcIiwwLjA2LC0wLjAzLDAuMTgsLTAuMDYsMC4yNCwtMC4wNl0sW1wiY1wiLDAuMywwLDAuMjcsLTAuMDMsMS44OSwxLjk1XSxbXCJsXCIsMS41MywxLjgzXSxbXCJsXCIsMC40OCwtMC42OV0sW1wiY1wiLDAuNTEsLTAuNzgsMC41NCwtMC44NCwwLjY5LC0wLjldLFtcImNcIiwwLjQyLC0wLjE4LDAuODcsMC4xNSwwLjgxLDAuNl0sW1wiY1wiLC0wLjAzLDAuMTIsLTAuMywwLjUxLC0xLjUsMi4zN10sW1wiY1wiLC0xLjM4LDIuMDcsLTEuNSwyLjIyLC0xLjYyLDIuMjhdLFtcImNcIiwtMC4wNiwwLjAzLC0wLjE4LDAuMDYsLTAuMjQsMC4wNl0sW1wiY1wiLC0wLjMsMCwtMC4yNywwLjAzLC0xLjgzLC0xLjg5XSxbXCJjXCIsLTAuODEsLTAuOTksLTEuNSwtMS44LC0xLjUzLC0xLjg2XSxbXCJjXCIsLTAuMDYsLTAuMDMsLTAuMDYsLTAuMDMsLTAuMTIsMC4wM10sW1wiY1wiLC0wLjA2LDAuMDYsLTAuMDYsMC4xNSwtMC4wNiwyLjI4XSxbXCJjXCIsLTAsMS45NSwtMCwyLjI1LC0wLjA2LDIuMzRdLFtcImNcIiwtMC4xOCwwLjQ1LC0wLjgxLDAuNDgsLTEuMDUsMC4wM10sW1wiY1wiLC0wLjAzLC0wLjA2LC0wLjA2LC0wLjI0LC0wLjA2LC0xLjQxXSxbXCJsXCIsLTAsLTEuMzVdLFtcImxcIiwtMC41NywwLjg0XSxbXCJjXCIsLTAuNTQsMC43OCwtMC42LDAuODcsLTAuNzIsMC45M10sW1wiY1wiLC0wLjA2LDAuMDMsLTAuMTgsMC4wNiwtMC4yNCwwLjA2XSxbXCJjXCIsLTAuMywwLC0wLjI3LDAuMDMsLTEuODksLTEuOTVdLFtcImxcIiwtMS41MywtMS44M10sW1wibFwiLC0wLjQ4LDAuNjldLFtcImNcIiwtMC41MSwwLjc4LC0wLjU0LDAuODQsLTAuNjksMC45XSxbXCJjXCIsLTAuNDIsMC4xOCwtMC44NywtMC4xNSwtMC44MSwtMC42XSxbXCJjXCIsMC4wMywtMC4xMiwwLjMsLTAuNTEsMS41LC0yLjM3XSxbXCJjXCIsMS4zOCwtMi4wNywxLjUsLTIuMjIsMS42MiwtMi4yOF0sW1wiY1wiLDAuMDYsLTAuMDMsMC4xOCwtMC4wNiwwLjI0LC0wLjA2XSxbXCJjXCIsMC4zLDAsMC4yNywtMC4wMywxLjg5LDEuOTVdLFtcImxcIiwxLjUzLDEuODNdLFtcImNcIiwwLjAzLC0wLDAuMDYsLTAuMDYsMC4wOSwtMC4wOV0sW1wiY1wiLDAuMDYsLTAuMTIsMC4wNiwtMC4xNSwwLjA2LC0yLjI4XSxbXCJjXCIsLTAsLTEuOTIsLTAsLTIuMjIsMC4wNiwtMi4zMV0sW1wiY1wiLDAuMDYsLTAuMTUsMC4xNSwtMC4yNCwwLjMsLTAuM10sW1wielwiXV0sdzoxNS4wMTEsaDoxMC4wMTJ9LFwiZmxhZ3MudTh0aFwiOntkOltbXCJNXCIsLTAuNDIsMy43NV0sW1wibFwiLDAsLTMuNzVdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLDAuMThdLFtcImNcIiwwLDAuMywwLjA2LDAuODQsMC4xMiwxLjIzXSxbXCJjXCIsMC4yNCwxLjUzLDAuOSwzLjEyLDIuMTMsNS4xNl0sW1wibFwiLDAuOTksMS41OV0sW1wiY1wiLDAuODcsMS40NCwxLjM4LDIuMzQsMS43NywzLjA5XSxbXCJjXCIsMC44MSwxLjY4LDEuMiwzLjA2LDEuMjYsNC41M10sW1wiY1wiLDAuMDMsMS41MywtMC4yMSwzLjI3LC0wLjc1LDUuMDFdLFtcImNcIiwtMC4yMSwwLjY5LC0wLjUxLDEuNSwtMC42LDEuNTldLFtcImNcIiwtMC4wOSwwLjEyLC0wLjI3LDAuMjEsLTAuNDIsMC4yMV0sW1wiY1wiLC0wLjE1LDAsLTAuNDIsLTAuMTIsLTAuNTEsLTAuMjFdLFtcImNcIiwtMC4xNSwtMC4xOCwtMC4xOCwtMC40MiwtMC4wOSwtMC42Nl0sW1wiY1wiLDAuMTUsLTAuMzMsMC40NSwtMS4yLDAuNTcsLTEuNjJdLFtcImNcIiwwLjQyLC0xLjM4LDAuNiwtMi41OCwwLjYsLTMuOV0sW1wiY1wiLDAsLTAuNjYsMCwtMC44MSwtMC4wNiwtMS4xMV0sW1wiY1wiLC0wLjM5LC0yLjA3LC0xLjgsLTQuMjYsLTQuNTksLTcuMTRdLFtcImxcIiwtMC40MiwtMC40NV0sW1wibFwiLC0wLjIxLDBdLFtcImxcIiwtMC4yMSwwXSxbXCJsXCIsMCwtMy43NV0sW1wielwiXV0sdzo2LjY5MixoOjIyLjU5fSxcImZsYWdzLnUxNnRoXCI6e2Q6W1tcIk1cIiwtMC40Miw3LjVdLFtcImxcIiwwLC03LjVdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLDAuMzldLFtcImNcIiwwLjA2LDEuMDgsMC4zOSwyLjE5LDAuOTksMy4zOV0sW1wiY1wiLDAuNDUsMC45LDAuODcsMS41OSwxLjk1LDMuMTJdLFtcImNcIiwxLjI5LDEuODYsMS43NywyLjY0LDIuMjIsMy41N10sW1wiY1wiLDAuNDUsMC45MywwLjcyLDEuOCwwLjg3LDIuNjRdLFtcImNcIiwwLjA2LDAuNTEsMC4wNiwxLjUsMCwxLjkyXSxbXCJjXCIsLTAuMTIsMC42LC0wLjMsMS4yLC0wLjU0LDEuNzFdLFtcImxcIiwtMC4wOSwwLjI0XSxbXCJsXCIsMC4xOCwwLjQ1XSxbXCJjXCIsMC41MSwxLjIsMC43MiwyLjIyLDAuNjksMy40Ml0sW1wiY1wiLC0wLjA2LDEuNTMsLTAuMzksMy4wMywtMC45OSw0LjUzXSxbXCJjXCIsLTAuMywwLjc1LC0wLjM2LDAuODEsLTAuNTcsMC45XSxbXCJjXCIsLTAuMTUsMC4wOSwtMC4zMywwLjA2LC0wLjQ4LC0wXSxbXCJjXCIsLTAuMTgsLTAuMDksLTAuMjcsLTAuMTgsLTAuMzMsLTAuMzNdLFtcImNcIiwtMC4wOSwtMC4xOCwtMC4wNiwtMC4zLDAuMTIsLTAuNzVdLFtcImNcIiwwLjY2LC0xLjQxLDEuMDIsLTIuODgsMS4wOCwtNC4zMl0sW1wiY1wiLDAsLTAuNiwtMC4wMywtMS4wNSwtMC4xOCwtMS41OV0sW1wiY1wiLC0wLjMsLTEuMiwtMC45OSwtMi40LC0yLjI1LC0zLjg3XSxbXCJjXCIsLTAuNDIsLTAuNDgsLTEuNTMsLTEuNjIsLTIuMTksLTIuMjJdLFtcImxcIiwtMC40NSwtMC40Ml0sW1wibFwiLC0wLjAzLDEuMTFdLFtcImxcIiwwLDEuMTFdLFtcImxcIiwtMC4yMSwtMF0sW1wibFwiLC0wLjIxLC0wXSxbXCJsXCIsMCwtNy41XSxbXCJ6XCJdLFtcIm1cIiwxLjY1LDAuMDldLFtcImNcIiwtMC4zLC0wLjMsLTAuNjksLTAuNzIsLTAuOSwtMC44N10sW1wibFwiLC0wLjMzLC0wLjMzXSxbXCJsXCIsMCwwLjE1XSxbXCJjXCIsMCwwLjMsMC4wNiwwLjgxLDAuMTUsMS4yNl0sW1wiY1wiLDAuMjcsMS4yOSwwLjg3LDIuNjEsMi4wNCw0LjI5XSxbXCJjXCIsMC4xNSwwLjI0LDAuNiwwLjg3LDAuOTYsMS4zOF0sW1wibFwiLDEuMDgsMS41M10sW1wibFwiLDAuNDIsMC42M10sW1wiY1wiLDAuMDMsMCwwLjEyLC0wLjM2LDAuMjEsLTAuNzJdLFtcImNcIiwwLjA2LC0wLjMzLDAuMDYsLTEuMiwwLC0xLjYyXSxbXCJjXCIsLTAuMzMsLTEuNzEsLTEuNDQsLTMuNDgsLTMuNjMsLTUuN10sW1wielwiXV0sdzo2LjY5MyxoOjI2LjMzN30sXCJmbGFncy51MzJuZFwiOntkOltbXCJNXCIsLTAuNDIsMTEuMjQ3XSxbXCJsXCIsMCwtMTEuMjVdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLDAuMzZdLFtcImNcIiwwLjA5LDEuNjgsMC42OSwzLjI3LDIuMDcsNS40Nl0sW1wibFwiLDAuODcsMS4zNV0sW1wiY1wiLDEuMDIsMS42MiwxLjQ3LDIuMzcsMS44NiwzLjE4XSxbXCJjXCIsMC40OCwxLjAyLDAuNzgsMS45MiwwLjkzLDIuODhdLFtcImNcIiwwLjA2LDAuNDgsMC4wNiwxLjUsMCwxLjg5XSxbXCJjXCIsLTAuMDksMC40MiwtMC4yMSwwLjg3LC0wLjM2LDEuMjZdLFtcImxcIiwtMC4xMiwwLjNdLFtcImxcIiwwLjE1LDAuMzldLFtcImNcIiwwLjY5LDEuNTYsMC44NCwyLjg4LDAuNTQsNC4zOF0sW1wiY1wiLC0wLjA5LDAuNDUsLTAuMjcsMS4wOCwtMC40NSwxLjQ3XSxbXCJsXCIsLTAuMTIsMC4yNF0sW1wibFwiLDAuMTgsMC4zNl0sW1wiY1wiLDAuMzMsMC43MiwwLjU3LDEuNTYsMC42OSwyLjM0XSxbXCJjXCIsMC4xMiwxLjAyLC0wLjA2LDIuNTIsLTAuNDIsMy44NF0sW1wiY1wiLC0wLjI3LDAuOTMsLTAuNzUsMi4xMywtMC45MywyLjMxXSxbXCJjXCIsLTAuMTgsMC4xNSwtMC40NSwwLjE4LC0wLjY2LDAuMDldLFtcImNcIiwtMC4xOCwtMC4wOSwtMC4yNywtMC4xOCwtMC4zMywtMC4zM10sW1wiY1wiLC0wLjA5LC0wLjE4LC0wLjA2LC0wLjMsMC4wNiwtMC42XSxbXCJjXCIsMC4yMSwtMC4zNiwwLjQyLC0wLjksMC41NywtMS4zOF0sW1wiY1wiLDAuNTEsLTEuNDEsMC42OSwtMy4wNiwwLjQ4LC00LjA4XSxbXCJjXCIsLTAuMTUsLTAuODEsLTAuNTcsLTEuNjgsLTEuMiwtMi41NV0sW1wiY1wiLC0wLjcyLC0wLjk5LC0xLjgzLC0yLjEzLC0zLjMsLTMuMzNdLFtcImxcIiwtMC40OCwtMC40Ml0sW1wibFwiLC0wLjAzLDEuNTNdLFtcImxcIiwwLDEuNTZdLFtcImxcIiwtMC4yMSwwXSxbXCJsXCIsLTAuMjEsMF0sW1wibFwiLDAsLTExLjI1XSxbXCJ6XCJdLFtcIm1cIiwxLjI2LC0zLjk2XSxbXCJjXCIsLTAuMjcsLTAuMywtMC41NCwtMC42LC0wLjY2LC0wLjcyXSxbXCJsXCIsLTAuMTgsLTAuMjFdLFtcImxcIiwwLDAuNDJdLFtcImNcIiwwLjA2LDAuODcsMC4yNCwxLjc0LDAuNjYsMi42N10sW1wiY1wiLDAuMzYsMC44NywwLjk2LDEuODYsMS45MiwzLjE4XSxbXCJjXCIsMC4yMSwwLjMzLDAuNjMsMC44NywwLjg3LDEuMjNdLFtcImNcIiwwLjI3LDAuMzksMC42LDAuODQsMC43NSwxLjA4XSxbXCJsXCIsMC4yNywwLjM5XSxbXCJsXCIsMC4wMywtMC4xMl0sW1wiY1wiLDAuMTIsLTAuNDUsMC4xNSwtMS4wNSwwLjA5LC0xLjU5XSxbXCJjXCIsLTAuMjcsLTEuODYsLTEuMzgsLTMuNzgsLTMuNzUsLTYuMzNdLFtcInpcIl0sW1wibVwiLC0wLjI3LDYuMDldLFtcImNcIiwtMC4yNywtMC4yMSwtMC40OCwtMC40MiwtMC41MSwtMC40NV0sW1wiY1wiLC0wLjA2LC0wLjAzLC0wLjA2LC0wLjAzLC0wLjA2LDAuMjFdLFtcImNcIiwwLDAuOSwwLjMsMi4wNCwwLjgxLDMuMDldLFtcImNcIiwwLjQ4LDEuMDIsMC45NiwxLjc3LDIuMzcsMy42M10sW1wiY1wiLDAuNiwwLjc4LDEuMDUsMS40NCwxLjI5LDEuNzddLFtcImNcIiwwLjA2LDAuMTIsMC4xNSwwLjIxLDAuMTUsMC4xOF0sW1wiY1wiLDAuMDMsLTAuMDMsMC4xOCwtMC41NywwLjI0LC0wLjg3XSxbXCJjXCIsMC4wNiwtMC40NSwwLjA2LC0xLjMyLC0wLjAzLC0xLjc0XSxbXCJjXCIsLTAuMDksLTAuNDgsLTAuMjQsLTAuOSwtMC41MSwtMS40NF0sW1wiY1wiLC0wLjY2LC0xLjM1LC0xLjgzLC0yLjcsLTMuNzUsLTQuMzhdLFtcInpcIl1dLHc6Ni42OTcsaDozMi4xNDV9LFwiZmxhZ3MudTY0dGhcIjp7ZDpbW1wiTVwiLC0wLjQyLDE1XSxbXCJsXCIsMCwtMTVdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLDAuMzZdLFtcImNcIiwwLjA2LDEuMiwwLjM5LDIuMzcsMS4wMiwzLjY2XSxbXCJjXCIsMC4zOSwwLjgxLDAuODQsMS41NiwxLjgsMy4wOV0sW1wiY1wiLDAuODEsMS4yNiwxLjA1LDEuNjgsMS4zNSwyLjIyXSxbXCJjXCIsMC44NywxLjUsMS4zNSwyLjc5LDEuNTYsNC4wOF0sW1wiY1wiLDAuMDYsMC41NCwwLjA2LDEuNTYsLTAuMDMsMi4wNF0sW1wiY1wiLC0wLjA5LDAuNDgsLTAuMjEsMC45OSwtMC4zNiwxLjM1XSxbXCJsXCIsLTAuMTIsMC4yN10sW1wibFwiLDAuMTIsMC4yN10sW1wiY1wiLDAuMDksMC4xNSwwLjIxLDAuNDUsMC4yNywwLjY2XSxbXCJjXCIsMC42OSwxLjg5LDAuNjMsMy42NiwtMC4xOCw1LjQ2XSxbXCJsXCIsLTAuMTgsMC4zOV0sW1wibFwiLDAuMTUsMC4zM10sW1wiY1wiLDAuMywwLjY2LDAuNTEsMS40NCwwLjYzLDIuMV0sW1wiY1wiLDAuMDYsMC40OCwwLjA2LDEuMzUsMCwxLjcxXSxbXCJjXCIsLTAuMTUsMC41NywtMC40MiwxLjIsLTAuNzgsMS42OF0sW1wibFwiLC0wLjIxLDAuMjddLFtcImxcIiwwLjE4LDAuMzNdLFtcImNcIiwwLjU3LDEuMDUsMC45MywyLjEzLDEuMDIsMy4xOF0sW1wiY1wiLDAuMDYsMC43MiwwLDEuODMsLTAuMjEsMi43OV0sW1wiY1wiLC0wLjE4LDEuMDIsLTAuNjMsMi4zNCwtMS4wMiwzLjA5XSxbXCJjXCIsLTAuMTUsMC4zMywtMC40OCwwLjQ1LC0wLjc4LDAuM10sW1wiY1wiLC0wLjE4LC0wLjA5LC0wLjI3LC0wLjE4LC0wLjMzLC0wLjMzXSxbXCJjXCIsLTAuMDksLTAuMTgsLTAuMDYsLTAuMywwLjAzLC0wLjU0XSxbXCJjXCIsMC43NSwtMS41LDEuMjMsLTMuNDUsMS4xNywtNC44OV0sW1wiY1wiLC0wLjA2LC0xLjAyLC0wLjQyLC0yLjAxLC0xLjE3LC0zLjE1XSxbXCJjXCIsLTAuNDgsLTAuNzIsLTEuMDIsLTEuMzUsLTEuODksLTIuMjJdLFtcImNcIiwtMC41NywtMC41NywtMS41NiwtMS41LC0xLjkyLC0xLjc3XSxbXCJsXCIsLTAuMTIsLTAuMDldLFtcImxcIiwwLDEuNjhdLFtcImxcIiwwLDEuNjhdLFtcImxcIiwtMC4yMSwwXSxbXCJsXCIsLTAuMjEsMF0sW1wibFwiLDAsLTE1XSxbXCJ6XCJdLFtcIm1cIiwwLjkzLC04LjA3XSxbXCJjXCIsLTAuMjcsLTAuMywtMC40OCwtMC41NCwtMC41MSwtMC41NF0sW1wiY1wiLC0wLDAsLTAsMC42OSwwLjAzLDEuMDJdLFtcImNcIiwwLjE1LDEuNDcsMC43NSwyLjk0LDIuMDQsNC44M10sW1wibFwiLDEuMDgsMS41M10sW1wiY1wiLDAuMzksMC41NywwLjg0LDEuMiwwLjk5LDEuNDRdLFtcImNcIiwwLjE1LDAuMjQsMC4zLDAuNDUsMC4zLDAuNDVdLFtcImNcIiwtMCwwLDAuMDMsLTAuMDksMC4wNiwtMC4yMV0sW1wiY1wiLDAuMzYsLTEuNTksLTAuMTUsLTMuMzMsLTEuNDcsLTUuNF0sW1wiY1wiLC0wLjYzLC0wLjkzLC0xLjM1LC0xLjgzLC0yLjUyLC0zLjEyXSxbXCJ6XCJdLFtcIm1cIiwwLjA2LDYuNzJdLFtcImNcIiwtMC4yNCwtMC4yMSwtMC40OCwtMC40MiwtMC41MSwtMC40NV0sW1wibFwiLC0wLjA2LC0wLjA2XSxbXCJsXCIsMCwwLjMzXSxbXCJjXCIsMCwxLjIsMC4zLDIuMzQsMC45MywzLjZdLFtcImNcIiwwLjQ1LDAuOSwwLjk2LDEuNjgsMi4yNSwzLjUxXSxbXCJjXCIsMC4zOSwwLjU0LDAuODQsMS4xNywxLjAyLDEuNDRdLFtcImNcIiwwLjIxLDAuMzMsMC4zMywwLjUxLDAuMzMsMC40OF0sW1wiY1wiLDAuMDYsLTAuMDksMC4yMSwtMC42MywwLjMsLTAuOTldLFtcImNcIiwwLjA2LC0wLjMzLDAuMDYsLTAuNDUsMC4wNiwtMC45Nl0sW1wiY1wiLC0wLC0wLjYsLTAuMDMsLTAuODQsLTAuMTgsLTEuMzVdLFtcImNcIiwtMC4zLC0xLjA4LC0xLjAyLC0yLjI4LC0yLjEzLC0zLjU3XSxbXCJjXCIsLTAuMzksLTAuNDUsLTEuNDQsLTEuNDcsLTIuMDEsLTEuOThdLFtcInpcIl0sW1wibVwiLDAsNi43Ml0sW1wiY1wiLC0wLjI0LC0wLjIxLC0wLjQ4LC0wLjM5LC0wLjUxLC0wLjQyXSxbXCJsXCIsLTAuMDYsLTAuMDZdLFtcImxcIiwwLDAuMzNdLFtcImNcIiwwLDEuNDEsMC40NSwyLjgyLDEuMzgsNC4zNV0sW1wiY1wiLDAuNDIsMC43MiwwLjcyLDEuMTQsMS44NiwyLjczXSxbXCJjXCIsMC4zNiwwLjQ1LDAuNzUsMC45OSwwLjg3LDEuMl0sW1wiY1wiLDAuMTUsMC4yMSwwLjMsMC4zNiwwLjMsMC4zNl0sW1wiY1wiLDAuMDYsMCwwLjMsLTAuNDgsMC4zOSwtMC43NV0sW1wiY1wiLDAuMDksLTAuMzYsMC4xMiwtMC42MywwLjEyLC0xLjA1XSxbXCJjXCIsLTAuMDYsLTEuMDUsLTAuNDUsLTIuMDQsLTEuMiwtMy4xOF0sW1wiY1wiLC0wLjU3LC0wLjg3LC0xLjExLC0xLjUzLC0yLjA3LC0yLjQ5XSxbXCJjXCIsLTAuMzYsLTAuMzMsLTAuODQsLTAuNzgsLTEuMDgsLTEuMDJdLFtcInpcIl1dLHc6Ni42ODIsaDozOS42OTR9LFwiZmxhZ3MuZDh0aFwiOntkOltbXCJNXCIsNS42NywtMjEuNjNdLFtcImNcIiwwLjI0LC0wLjEyLDAuNTQsLTAuMDYsMC42OSwwLjE1XSxbXCJjXCIsMC4wNiwwLjA2LDAuMjEsMC4zNiwwLjM5LDAuNjZdLFtcImNcIiwwLjg0LDEuNzcsMS4yNiwzLjM2LDEuMzIsNS4xXSxbXCJjXCIsMC4wMywxLjI5LC0wLjIxLDIuMzcsLTAuODEsMy42M10sW1wiY1wiLC0wLjYsMS4yMywtMS4yNiwyLjEzLC0zLjIxLDQuMzhdLFtcImNcIiwtMS4zNSwxLjUzLC0xLjg2LDIuMTksLTIuNCwyLjk3XSxbXCJjXCIsLTAuNjMsMC45MywtMS4xMSwxLjkyLC0xLjM4LDIuNzldLFtcImNcIiwtMC4xNSwwLjU0LC0wLjI3LDEuMzUsLTAuMjcsMS44XSxbXCJsXCIsMCwwLjE1XSxbXCJsXCIsLTAuMjEsLTBdLFtcImxcIiwtMC4yMSwtMF0sW1wibFwiLDAsLTMuNzVdLFtcImxcIiwwLC0zLjc1XSxbXCJsXCIsMC4yMSwwXSxbXCJsXCIsMC4yMSwwXSxbXCJsXCIsMC40OCwtMC4zXSxbXCJjXCIsMS44MywtMS4xMSwzLjEyLC0yLjEsNC4xNywtMy4xMl0sW1wiY1wiLDAuNzgsLTAuODEsMS4zMiwtMS41MywxLjcxLC0yLjMxXSxbXCJjXCIsMC40NSwtMC45MywwLjYsLTEuNzQsMC41MSwtMi44OF0sW1wiY1wiLC0wLjEyLC0xLjU2LC0wLjYzLC0zLjE4LC0xLjQ3LC00LjY4XSxbXCJjXCIsLTAuMTIsLTAuMjEsLTAuMTUsLTAuMzMsLTAuMDYsLTAuNTFdLFtcImNcIiwwLjA2LC0wLjE1LDAuMTUsLTAuMjQsMC4zMywtMC4zM10sW1wielwiXV0sdzo4LjQ5MixoOjIxLjY5MX0sXCJmbGFncy51Z3JhY2VcIjp7ZDpbW1wiTVwiLDYuMDMsNi45M10sW1wiY1wiLDAuMTUsLTAuMDksMC4zMywtMC4wNiwwLjUxLDBdLFtcImNcIiwwLjE1LDAuMDksMC4yMSwwLjE1LDAuMywwLjMzXSxbXCJjXCIsMC4wOSwwLjE4LDAuMDYsMC4zOSwtMC4wMywwLjU0XSxbXCJjXCIsLTAuMDYsMC4xNSwtMTAuODksOC44OCwtMTEuMDcsOC45N10sW1wiY1wiLC0wLjE1LDAuMDksLTAuMzMsMC4wNiwtMC40OCwwXSxbXCJjXCIsLTAuMTgsLTAuMDksLTAuMjQsLTAuMTUsLTAuMzMsLTAuMzNdLFtcImNcIiwtMC4wOSwtMC4xOCwtMC4wNiwtMC4zOSwwLjAzLC0wLjU0XSxbXCJjXCIsMC4wNiwtMC4xNSwxMC44OSwtOC44OCwxMS4wNywtOC45N10sW1wielwiXV0sdzoxMi4wMTksaDo5Ljk1NH0sXCJmbGFncy5kZ3JhY2VcIjp7ZDpbW1wiTVwiLC02LjA2LC0xNS45M10sW1wiY1wiLDAuMTgsLTAuMDksMC4zMywtMC4xMiwwLjQ4LC0wLjA2XSxbXCJjXCIsMC4xOCwwLjA5LDE0LjAxLDguMDQsMTQuMSw4LjFdLFtcImNcIiwwLjEyLDAuMTIsMC4xOCwwLjMzLDAuMTgsMC41MV0sW1wiY1wiLC0wLjAzLDAuMjEsLTAuMTUsMC4zOSwtMC4zNiwwLjQ4XSxbXCJjXCIsLTAuMTgsMC4wOSwtMC4zMywwLjEyLC0wLjQ4LDAuMDZdLFtcImNcIiwtMC4xOCwtMC4wOSwtMTQuMDEsLTguMDQsLTE0LjEsLTguMV0sW1wiY1wiLC0wLjEyLC0wLjEyLC0wLjE4LC0wLjMzLC0wLjE4LC0wLjUxXSxbXCJjXCIsMC4wMywtMC4yMSwwLjE1LC0wLjM5LDAuMzYsLTAuNDhdLFtcInpcIl1dLHc6MTUuMTIsaDo5LjIxMn0sXCJmbGFncy5kMTZ0aFwiOntkOltbXCJNXCIsNi44NCwtMjIuNTNdLFtcImNcIiwwLjI3LC0wLjEyLDAuNTcsLTAuMDYsMC43MiwwLjE1XSxbXCJjXCIsMC4xNSwwLjE1LDAuMzMsMC44NywwLjQ1LDEuNTZdLFtcImNcIiwwLjA2LDAuMzMsMC4wNiwxLjM1LDAsMS42NV0sW1wiY1wiLC0wLjA2LDAuMzMsLTAuMTUsMC43OCwtMC4yNywxLjExXSxbXCJjXCIsLTAuMTIsMC4zMywtMC40NSwwLjk2LC0wLjY2LDEuMzJdLFtcImxcIiwtMC4xOCwwLjI3XSxbXCJsXCIsMC4wOSwwLjE4XSxbXCJjXCIsMC40OCwxLjAyLDAuNzIsMi4yNSwwLjY5LDMuM10sW1wiY1wiLC0wLjA2LDEuMjMsLTAuNDIsMi4yOCwtMS4yNiwzLjQ1XSxbXCJjXCIsLTAuNTcsMC44NywtMC45OSwxLjMyLC0zLDMuMzldLFtcImNcIiwtMS41NiwxLjU2LC0yLjIyLDIuNCwtMi43NiwzLjQ1XSxbXCJjXCIsLTAuNDIsMC44NCwtMC42NiwxLjgsLTAuNjYsMi41NV0sW1wibFwiLDAsMC4xNV0sW1wibFwiLC0wLjIxLC0wXSxbXCJsXCIsLTAuMjEsLTBdLFtcImxcIiwwLC03LjVdLFtcImxcIiwwLC03LjVdLFtcImxcIiwwLjIxLC0wXSxbXCJsXCIsMC4yMSwtMF0sW1wibFwiLDAsMS4xNF0sW1wibFwiLDAsMS4xMV0sW1wibFwiLDAuMjcsLTAuMTVdLFtcImNcIiwxLjExLC0wLjU3LDEuNzcsLTAuOTksMi41MiwtMS40N10sW1wiY1wiLDIuMzcsLTEuNTYsMy42OSwtMy4xNSw0LjA1LC00LjgzXSxbXCJjXCIsMC4wMywtMC4xOCwwLjAzLC0wLjM5LDAuMDMsLTAuNzhdLFtcImNcIiwwLC0wLjYsLTAuMDMsLTAuOTMsLTAuMjQsLTEuNV0sW1wiY1wiLC0wLjA2LC0wLjE4LC0wLjEyLC0wLjM5LC0wLjE1LC0wLjQ1XSxbXCJjXCIsLTAuMDMsLTAuMjQsMC4xMiwtMC40OCwwLjM2LC0wLjZdLFtcInpcIl0sW1wibVwiLC0wLjYzLDcuNV0sW1wiY1wiLC0wLjA2LC0wLjE4LC0wLjE1LC0wLjM2LC0wLjE1LC0wLjM2XSxbXCJjXCIsLTAuMDMsMCwtMC4wMywwLjAzLC0wLjA2LDAuMDZdLFtcImNcIiwtMC4wNiwwLjEyLC0wLjk2LDEuMDIsLTEuOTUsMS45OF0sW1wiY1wiLC0wLjYzLDAuNTcsLTEuMjYsMS4xNywtMS40NCwxLjM1XSxbXCJjXCIsLTEuNTMsMS42MiwtMi4yOCwyLjg1LC0yLjU1LDQuMzJdLFtcImNcIiwtMC4wMywwLjE4LC0wLjAzLDAuNTQsLTAuMDYsMC45OV0sW1wibFwiLDAsMC42OV0sW1wibFwiLDAuMTgsLTAuMDldLFtcImNcIiwwLjkzLC0wLjU0LDIuMSwtMS4yOSwyLjgyLC0xLjgzXSxbXCJjXCIsMC42OSwtMC41MSwxLjAyLC0wLjgxLDEuNTMsLTEuMjldLFtcImNcIiwxLjg2LC0xLjg5LDIuMzcsLTMuNjYsMS42OCwtNS44Ml0sW1wielwiXV0sdzo4LjQ3NSxoOjIyLjU5MX0sXCJmbGFncy5kMzJuZFwiOntkOltbXCJNXCIsNi43OTQsLTI5LjEzXSxbXCJjXCIsMC4yNywtMC4xMiwwLjU3LC0wLjA2LDAuNzIsMC4xNV0sW1wiY1wiLDAuMTIsMC4xMiwwLjI3LDAuNjMsMC4zNiwxLjExXSxbXCJjXCIsMC4zMywxLjU5LDAuMDYsMy4wNiwtMC44MSw0LjQ3XSxbXCJsXCIsLTAuMTgsMC4yN10sW1wibFwiLDAuMDksMC4xNV0sW1wiY1wiLDAuMTIsMC4yNCwwLjMzLDAuNjksMC40NSwxLjA1XSxbXCJjXCIsMC42MywxLjgzLDAuNDUsMy41NywtMC41Nyw1LjIyXSxbXCJsXCIsLTAuMTgsMC4zXSxbXCJsXCIsMC4xNSwwLjI3XSxbXCJjXCIsMC40MiwwLjg3LDAuNiwxLjcxLDAuNTcsMi42MV0sW1wiY1wiLC0wLjA2LDEuMjksLTAuNDgsMi40NiwtMS4zNSwzLjc4XSxbXCJjXCIsLTAuNTQsMC44MSwtMC45MywxLjI5LC0yLjQ2LDNdLFtcImNcIiwtMC41MSwwLjU0LC0xLjA1LDEuMTcsLTEuMjYsMS40MV0sW1wiY1wiLC0xLjU2LDEuODYsLTIuMjUsMy4zNiwtMi4zNyw1LjAxXSxbXCJsXCIsMCwwLjMzXSxbXCJsXCIsLTAuMjEsLTBdLFtcImxcIiwtMC4yMSwtMF0sW1wibFwiLDAsLTExLjI1XSxbXCJsXCIsMCwtMTEuMjVdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLjIxLDBdLFtcImxcIiwwLDEuMzVdLFtcImxcIiwwLjAzLDEuMzVdLFtcImxcIiwwLjc4LC0wLjM5XSxbXCJjXCIsMS4zOCwtMC42OSwyLjM0LC0xLjI2LDMuMjQsLTEuOTJdLFtcImNcIiwxLjM4LC0xLjAyLDIuMjgsLTIuMTMsMi42NCwtMy4yMV0sW1wiY1wiLDAuMTUsLTAuNDgsMC4xOCwtMC43MiwwLjE4LC0xLjI5XSxbXCJjXCIsMCwtMC41NywtMC4wNiwtMC45LC0wLjI0LC0xLjQ3XSxbXCJjXCIsLTAuMDYsLTAuMTgsLTAuMTIsLTAuMzksLTAuMTUsLTAuNDVdLFtcImNcIiwtMC4wMywtMC4yNCwwLjEyLC0wLjQ4LDAuMzYsLTAuNl0sW1wielwiXSxbXCJtXCIsLTAuNjMsNy4yXSxbXCJjXCIsLTAuMDksLTAuMTgsLTAuMTIsLTAuMjEsLTAuMTIsLTAuMTVdLFtcImNcIiwtMC4wMywwLjA5LC0xLjAyLDEuMDgsLTIuMDQsMi4wNF0sW1wiY1wiLC0xLjE3LDEuMDgsLTEuNjUsMS41NiwtMi4wNywyLjA0XSxbXCJjXCIsLTAuODQsMC45NiwtMS4zOCwxLjg2LC0xLjY4LDIuNzZdLFtcImNcIiwtMC4yMSwwLjU3LC0wLjI3LDAuOTksLTAuMywxLjY1XSxbXCJsXCIsMCwwLjU0XSxbXCJsXCIsMC42NiwtMC4zM10sW1wiY1wiLDMuNTcsLTEuODYsNS40OSwtMy42OSw1Ljk0LC01LjddLFtcImNcIiwwLjA2LC0wLjM5LDAuMDYsLTEuMiwtMC4wMywtMS42NV0sW1wiY1wiLC0wLjA2LC0wLjM5LC0wLjI0LC0wLjksLTAuMzYsLTEuMl0sW1wielwiXSxbXCJtXCIsLTAuMDYsNy4yXSxbXCJjXCIsLTAuMDYsLTAuMTUsLTAuMTIsLTAuMzMsLTAuMTUsLTAuNDVdLFtcImxcIiwtMC4wNiwtMC4xOF0sW1wibFwiLC0wLjE4LDAuMjFdLFtcImxcIiwtMS44MywxLjgzXSxbXCJjXCIsLTAuODcsMC45LC0xLjc3LDEuOCwtMS45NSwyLjAxXSxbXCJjXCIsLTEuMDgsMS4yOSwtMS42MiwyLjMxLC0xLjg5LDMuNTFdLFtcImNcIiwtMC4wNiwwLjMsLTAuMDYsMC41MSwtMC4wOSwwLjkzXSxbXCJsXCIsMCwwLjU3XSxbXCJsXCIsMC4wOSwtMC4wNl0sW1wiY1wiLDAuNzUsLTAuNDUsMS44OSwtMS4yNiwyLjUyLC0xLjc0XSxbXCJjXCIsMC44MSwtMC42NiwxLjc0LC0xLjUzLDIuMjIsLTIuMTZdLFtcImNcIiwxLjI2LC0xLjUzLDEuNjgsLTMuMDYsMS4zMiwtNC40N10sW1wielwiXV0sdzo4LjQ3NSxoOjI5LjE5MX0sXCJmbGFncy5kNjR0aFwiOntkOltbXCJNXCIsNy4wOCwtMzIuODhdLFtcImNcIiwwLjMsLTAuMTIsMC42NiwtMC4wMywwLjc4LDAuMjRdLFtcImNcIiwwLjE4LDAuMzMsMC4yNywyLjEsMC4xNSwyLjY0XSxbXCJjXCIsLTAuMDksMC4zOSwtMC4yMSwwLjc4LC0wLjM5LDEuMDhdLFtcImxcIiwtMC4xNSwwLjNdLFtcImxcIiwwLjA5LDAuMjddLFtcImNcIiwwLjAzLDAuMTIsMC4wOSwwLjQ1LDAuMTIsMC42OV0sW1wiY1wiLDAuMjcsMS40NCwwLjE4LDIuNTUsLTAuMywzLjZdLFtcImxcIiwtMC4xMiwwLjMzXSxbXCJsXCIsMC4wNiwwLjQyXSxbXCJjXCIsMC4yNywxLjM1LDAuMzMsMi44MiwwLjIxLDMuNjNdLFtcImNcIiwtMC4xMiwwLjYsLTAuMywxLjIzLC0wLjU3LDEuOF0sW1wibFwiLC0wLjE1LDAuMjddLFtcImxcIiwwLjAzLDAuNDJdLFtcImNcIiwwLjA2LDEuMDIsMC4wNiwyLjcsMC4wMywzLjA2XSxbXCJjXCIsLTAuMTUsMS40NywtMC42NiwyLjc2LC0xLjc0LDQuNDFdLFtcImNcIiwtMC40NSwwLjY5LC0wLjc1LDEuMTEsLTEuNzQsMi4zN10sW1wiY1wiLC0xLjA1LDEuMzgsLTEuNSwxLjk4LC0xLjk1LDIuNzNdLFtcImNcIiwtMC45MywxLjUsLTEuMzgsMi44MiwtMS40NCw0LjJdLFtcImxcIiwwLDAuNDJdLFtcImxcIiwtMC4yMSwtMF0sW1wibFwiLC0wLjIxLC0wXSxbXCJsXCIsMCwtMTVdLFtcImxcIiwwLC0xNV0sW1wibFwiLDAuMjEsLTBdLFtcImxcIiwwLjIxLC0wXSxbXCJsXCIsMCwxLjg2XSxbXCJsXCIsMCwxLjg5XSxbXCJjXCIsMCwtMCwwLjIxLC0wLjAzLDAuNDUsLTAuMDldLFtcImNcIiwyLjIyLC0wLjM5LDQuMDgsLTEuMTEsNS4xOSwtMi4wMV0sW1wiY1wiLDAuNjMsLTAuNTQsMS4wMiwtMS4xNCwxLjIsLTEuOF0sW1wiY1wiLDAuMDYsLTAuMywwLjA2LC0xLjE0LC0wLjAzLC0xLjY1XSxbXCJjXCIsLTAuMDMsLTAuMTgsLTAuMDYsLTAuMzksLTAuMDksLTAuNDhdLFtcImNcIiwtMC4wMywtMC4yNCwwLjEyLC0wLjQ4LDAuMzYsLTAuNl0sW1wielwiXSxbXCJtXCIsLTAuNDUsNi4xNV0sW1wiY1wiLC0wLjAzLC0wLjE4LC0wLjA2LC0wLjQyLC0wLjA2LC0wLjU0XSxbXCJsXCIsLTAuMDMsLTAuMThdLFtcImxcIiwtMC4zMywwLjNdLFtcImNcIiwtMC40MiwwLjM2LC0wLjg3LDAuNzIsLTEuNjgsMS4yOV0sW1wiY1wiLC0xLjk4LDEuMzgsLTIuMjUsMS41OSwtMi44NSwyLjE2XSxbXCJjXCIsLTAuNzUsMC42OSwtMS4yMywxLjQ0LC0xLjQ3LDIuMTldLFtcImNcIiwtMC4xNSwwLjQ1LC0wLjE4LDAuNjMsLTAuMjEsMS4zNV0sW1wibFwiLDAsMC42Nl0sW1wibFwiLDAuMzksLTAuMThdLFtcImNcIiwxLjgzLC0wLjksMy40NSwtMS45NSw0LjQ3LC0yLjkxXSxbXCJjXCIsMC45MywtMC45LDEuNTMsLTEuODMsMS43NCwtMi44Ml0sW1wiY1wiLDAuMDYsLTAuMzMsMC4wNiwtMC44NywwLjAzLC0xLjMyXSxbXCJ6XCJdLFtcIm1cIiwtMC4yNyw0Ljg2XSxbXCJjXCIsLTAuMDMsLTAuMjEsLTAuMDYsLTAuMzYsLTAuMDYsLTAuMzZdLFtcImNcIiwwLC0wLjAzLC0wLjEyLDAuMDksLTAuMjQsMC4yNF0sW1wiY1wiLC0wLjM5LDAuNDgsLTAuOTksMS4wOCwtMi4xNiwyLjE5XSxbXCJjXCIsLTEuNDcsMS4zOCwtMS45MiwxLjgzLC0yLjQ2LDIuNDldLFtcImNcIiwtMC42NiwwLjg3LC0xLjA4LDEuNzQsLTEuMjksMi41OF0sW1wiY1wiLC0wLjA5LDAuNDIsLTAuMTUsMC44NywtMC4xNSwxLjQ0XSxbXCJsXCIsMCwwLjU0XSxbXCJsXCIsMC40OCwtMC4zM10sW1wiY1wiLDEuNSwtMS4wMiwyLjU4LC0xLjg5LDMuNTEsLTIuODJdLFtcImNcIiwxLjQ3LC0xLjQ3LDIuMjUsLTIuODUsMi40LC00LjI2XSxbXCJjXCIsMC4wMywtMC4zOSwwLjAzLC0xLjE3LC0wLjAzLC0xLjcxXSxbXCJ6XCJdLFtcIm1cIiwtMC42Niw3LjY4XSxbXCJjXCIsMC4wMywtMC4xNSwwLjAzLC0wLjYsMC4wMywtMC45OV0sW1wibFwiLDAsLTAuNzJdLFtcImxcIiwtMC4yNywwLjMzXSxbXCJsXCIsLTEuNzQsMS45OF0sW1wiY1wiLC0xLjc3LDEuOTIsLTIuNDMsMi43NiwtMi45NywzLjldLFtcImNcIiwtMC41MSwxLjAyLC0wLjcyLDEuNzcsLTAuNzUsMi45MV0sW1wiY1wiLDAsMC42MywwLDAuNjMsMC4wNiwwLjZdLFtcImNcIiwwLjAzLC0wLjAzLDAuMywtMC4yNywwLjYzLC0wLjU0XSxbXCJjXCIsMC42NiwtMC42LDEuODYsLTEuOCwyLjMxLC0yLjMxXSxbXCJjXCIsMS42NSwtMS44OSwyLjUyLC0zLjU0LDIuNywtNS4xNl0sW1wielwiXV0sdzo4LjQ4NSxoOjMyLjkzMn0sXCJjbGVmcy5DXCI6e2Q6W1tcIk1cIiwwLjA2LC0xNC45NF0sW1wibFwiLDAuMDksLTAuMDZdLFtcImxcIiwxLjkyLDBdLFtcImxcIiwxLjkyLDBdLFtcImxcIiwwLjA5LDAuMDZdLFtcImxcIiwwLjA2LDAuMDldLFtcImxcIiwwLDE0Ljg1XSxbXCJsXCIsMCwxNC44Ml0sW1wibFwiLC0wLjA2LDAuMDldLFtcImxcIiwtMC4wOSwwLjA2XSxbXCJsXCIsLTEuOTIsMF0sW1wibFwiLC0xLjkyLDBdLFtcImxcIiwtMC4wOSwtMC4wNl0sW1wibFwiLC0wLjA2LC0wLjA5XSxbXCJsXCIsMCwtMTQuODJdLFtcImxcIiwwLC0xNC44NV0sW1wielwiXSxbXCJtXCIsNS4zNywwXSxbXCJjXCIsMC4wOSwtMC4wNiwwLjA5LC0wLjA2LDAuNTcsLTAuMDZdLFtcImNcIiwwLjQ1LDAsMC40NSwwLDAuNTQsMC4wNl0sW1wibFwiLDAuMDYsMC4wOV0sW1wibFwiLDAsNy4xNF0sW1wibFwiLDAsNy4xMV0sW1wibFwiLDAuMDksLTAuMDZdLFtcImNcIiwwLjE4LC0wLjE4LDAuNzIsLTAuODQsMC45NiwtMS4yXSxbXCJjXCIsMC4zLC0wLjQ1LDAuNjYsLTEuMTcsMC44NCwtMS42NV0sW1wiY1wiLDAuMzYsLTAuOSwwLjU3LC0xLjgzLDAuNiwtMi43OV0sW1wiY1wiLDAuMDMsLTAuNDgsMC4wMywtMC41NCwwLjA5LC0wLjYzXSxbXCJjXCIsMC4xMiwtMC4xOCwwLjM2LC0wLjIxLDAuNTQsLTAuMTJdLFtcImNcIiwwLjE4LDAuMDksMC4yMSwwLjE1LDAuMjQsMC42Nl0sW1wiY1wiLDAuMDYsMC44NywwLjIxLDEuNTYsMC41NywyLjIyXSxbXCJjXCIsMC41MSwxLjAyLDEuMjYsMS42OCwyLjIyLDEuOTJdLFtcImNcIiwwLjIxLDAuMDYsMC4zMywwLjA2LDAuNzgsMC4wNl0sW1wiY1wiLDAuNDUsLTAsMC41NywtMCwwLjg0LC0wLjA2XSxbXCJjXCIsMC40NSwtMC4xMiwwLjgxLC0wLjMzLDEuMDgsLTAuNl0sW1wiY1wiLDAuNTcsLTAuNTcsMC44NywtMS40MSwwLjk5LC0yLjg4XSxbXCJjXCIsMC4wNiwtMC41NCwwLjA2LC0zLDAsLTMuNTddLFtcImNcIiwtMC4yMSwtMi41OCwtMC44NCwtMy44NywtMi4xNiwtNC41XSxbXCJjXCIsLTAuNDgsLTAuMjEsLTEuMTcsLTAuMzYsLTEuNzcsLTAuMzZdLFtcImNcIiwtMC42OSwwLC0xLjI5LDAuMjcsLTEuNSwwLjcyXSxbXCJjXCIsLTAuMDYsMC4xNSwtMC4wNiwwLjIxLC0wLjA2LDAuNDJdLFtcImNcIiwwLDAuMjQsMCwwLjMsMC4wNiwwLjQ1XSxbXCJjXCIsMC4xMiwwLjI0LDAuMjQsMC4zOSwwLjYzLDAuNjZdLFtcImNcIiwwLjQyLDAuMywwLjU3LDAuNDgsMC42OSwwLjcyXSxbXCJjXCIsMC4wNiwwLjE1LDAuMDYsMC4yMSwwLjA2LDAuNDhdLFtcImNcIiwwLDAuMzksLTAuMDMsMC42MywtMC4yMSwwLjk2XSxbXCJjXCIsLTAuMywwLjYsLTAuODcsMS4wOCwtMS41LDEuMjZdLFtcImNcIiwtMC4yNywwLjA2LC0wLjg3LDAuMDYsLTEuMTQsMF0sW1wiY1wiLC0wLjc4LC0wLjI0LC0xLjQ0LC0wLjg3LC0xLjY1LC0xLjY4XSxbXCJjXCIsLTAuMTIsLTAuNDIsLTAuMDksLTEuMTcsMC4wOSwtMS43MV0sW1wiY1wiLDAuNTEsLTEuNjUsMS45OCwtMi44MiwzLjgxLC0zLjA5XSxbXCJjXCIsMC44NCwtMC4wOSwyLjQ2LDAuMDMsMy41MSwwLjI3XSxbXCJjXCIsMi4yMiwwLjU3LDMuNjksMS44LDQuNDQsMy43NV0sW1wiY1wiLDAuMzYsMC45MywwLjU3LDIuMTMsMC41NywzLjM2XSxbXCJjXCIsLTAsMS40NCwtMC40OCwyLjczLC0xLjM4LDMuODFdLFtcImNcIiwtMS4yNiwxLjUsLTMuMjcsMi40MywtNS4yOCwyLjQzXSxbXCJjXCIsLTAuNDgsLTAsLTAuNTEsLTAsLTAuNzUsLTAuMDldLFtcImNcIiwtMC4xNSwtMC4wMywtMC40OCwtMC4yMSwtMC43OCwtMC4zNl0sW1wiY1wiLC0wLjY5LC0wLjM2LC0wLjg3LC0wLjQyLC0xLjI2LC0wLjQyXSxbXCJjXCIsLTAuMjcsLTAsLTAuMywtMCwtMC41MSwwLjA5XSxbXCJjXCIsLTAuNTcsMC4zLC0wLjgxLDAuOSwtMC44MSwyLjFdLFtcImNcIiwtMCwxLjIzLDAuMjQsMS44MywwLjgxLDIuMTNdLFtcImNcIiwwLjIxLDAuMDksMC4yNCwwLjA5LDAuNTEsMC4wOV0sW1wiY1wiLDAuMzksLTAsMC41NywtMC4wNiwxLjI2LC0wLjQyXSxbXCJjXCIsMC4zLC0wLjE1LDAuNjMsLTAuMzMsMC43OCwtMC4zNl0sW1wiY1wiLDAuMjQsLTAuMDksMC4yNywtMC4wOSwwLjc1LC0wLjA5XSxbXCJjXCIsMi4wMSwtMCw0LjAyLDAuOTMsNS4yOCwyLjRdLFtcImNcIiwwLjksMS4xMSwxLjM4LDIuNCwxLjM4LDMuODRdLFtcImNcIiwtMCwxLjUsLTAuMywyLjg4LC0wLjg0LDMuOTZdLFtcImNcIiwtMC43OCwxLjU5LC0yLjE5LDIuNjQsLTQuMTcsMy4xNV0sW1wiY1wiLC0xLjA1LDAuMjQsLTIuNjcsMC4zNiwtMy41MSwwLjI3XSxbXCJjXCIsLTEuODMsLTAuMjcsLTMuMywtMS40NCwtMy44MSwtMy4wOV0sW1wiY1wiLC0wLjE4LC0wLjU0LC0wLjIxLC0xLjI5LC0wLjA5LC0xLjc0XSxbXCJjXCIsMC4xNSwtMC42LDAuNjMsLTEuMiwxLjIzLC0xLjQ3XSxbXCJjXCIsMC4zNiwtMC4xOCwwLjU3LC0wLjIxLDAuOTksLTAuMjFdLFtcImNcIiwwLjQyLDAsMC42MywwLjAzLDEuMDIsMC4yMV0sW1wiY1wiLDAuNDIsMC4yMSwwLjg0LDAuNjMsMS4wNSwxLjA1XSxbXCJjXCIsMC4xOCwwLjM2LDAuMjEsMC42LDAuMjEsMC45Nl0sW1wiY1wiLC0wLDAuMywtMCwwLjM2LC0wLjA2LDAuNTFdLFtcImNcIiwtMC4xMiwwLjI0LC0wLjI3LDAuNDIsLTAuNjksMC43Ml0sW1wiY1wiLC0wLjU3LDAuNDIsLTAuNjksMC42MywtMC42OSwxLjA4XSxbXCJjXCIsLTAsMC4yNCwtMCwwLjMsMC4wNiwwLjQ1XSxbXCJjXCIsMC4xMiwwLjIxLDAuMywwLjM5LDAuNTcsMC41NF0sW1wiY1wiLDAuNDIsMC4xOCwwLjg3LDAuMjEsMS41MywwLjE1XSxbXCJjXCIsMS4wOCwtMC4xNSwxLjgsLTAuNTcsMi4zNCwtMS4zMl0sW1wiY1wiLDAuNTQsLTAuNzUsMC44NCwtMS44MywwLjk5LC0zLjUxXSxbXCJjXCIsMC4wNiwtMC41NywwLjA2LC0zLjAzLC0wLC0zLjU3XSxbXCJjXCIsLTAuMTIsLTEuNDcsLTAuNDIsLTIuMzEsLTAuOTksLTIuODhdLFtcImNcIiwtMC4yNywtMC4yNywtMC42MywtMC40OCwtMS4wOCwtMC42XSxbXCJjXCIsLTAuMjcsLTAuMDYsLTAuMzksLTAuMDYsLTAuODQsLTAuMDZdLFtcImNcIiwtMC40NSwwLC0wLjU3LDAsLTAuNzgsMC4wNl0sW1wiY1wiLC0xLjE0LDAuMjcsLTIuMDEsMS4xNywtMi40NiwyLjQ5XSxbXCJjXCIsLTAuMjEsMC41NywtMC4zLDAuOTksLTAuMzMsMS42NV0sW1wiY1wiLC0wLjAzLDAuNTEsLTAuMDYsMC41NywtMC4yNCwwLjY2XSxbXCJjXCIsLTAuMTIsMC4wNiwtMC4yNywwLjA2LC0wLjM5LDBdLFtcImNcIiwtMC4yMSwtMC4wOSwtMC4yMSwtMC4xNSwtMC4yNCwtMC43NV0sW1wiY1wiLC0wLjA5LC0xLjkyLC0wLjc4LC0zLjcyLC0yLjAxLC01LjE5XSxbXCJjXCIsLTAuMTgsLTAuMjEsLTAuMzYsLTAuNDIsLTAuMzksLTAuNDVdLFtcImxcIiwtMC4wOSwtMC4wNl0sW1wibFwiLC0wLDcuMTFdLFtcImxcIiwtMCw3LjE0XSxbXCJsXCIsLTAuMDYsMC4wOV0sW1wiY1wiLC0wLjA5LDAuMDYsLTAuMDksMC4wNiwtMC41NCwwLjA2XSxbXCJjXCIsLTAuNDgsMCwtMC40OCwwLC0wLjU3LC0wLjA2XSxbXCJsXCIsLTAuMDYsLTAuMDldLFtcImxcIiwtMCwtMTQuODJdLFtcImxcIiwtMCwtMTQuODVdLFtcInpcIl1dLHc6MjAuMzEsaDoyOS45N30sXCJjbGVmcy5GXCI6e2Q6W1tcIk1cIiw2LjMsLTcuOF0sW1wiY1wiLDAuMzYsLTAuMDMsMS42NSwwLDIuMTMsMC4wM10sW1wiY1wiLDMuNiwwLjQyLDYuMDMsMi4xLDYuOTMsNC44Nl0sW1wiY1wiLDAuMjcsMC44NCwwLjM2LDEuNSwwLjM2LDIuNThdLFtcImNcIiwwLDAuOSwtMC4wMywxLjM1LC0wLjE4LDIuMTZdLFtcImNcIiwtMC43OCwzLjc4LC0zLjU0LDcuMDgsLTguMzcsOS45Nl0sW1wiY1wiLC0xLjc0LDEuMDUsLTMuODcsMi4xMywtNi4xOCwzLjEyXSxbXCJjXCIsLTAuMzksMC4xOCwtMC43NSwwLjMzLC0wLjgxLDAuMzZdLFtcImNcIiwtMC4wNiwwLjAzLC0wLjE1LDAuMDYsLTAuMTgsMC4wNl0sW1wiY1wiLC0wLjE1LDAsLTAuMzMsLTAuMTgsLTAuMzMsLTAuMzNdLFtcImNcIiwwLC0wLjE1LDAuMDYsLTAuMjEsMC41MSwtMC40OF0sW1wiY1wiLDMsLTEuNzcsNS4xMywtMy4yMSw2Ljg0LC00Ljc0XSxbXCJjXCIsMC41MSwtMC40NSwxLjU5LC0xLjUsMS45NSwtMS45NV0sW1wiY1wiLDEuODksLTIuMTksMi44OCwtNC4zMiwzLjE1LC02Ljc4XSxbXCJjXCIsMC4wNiwtMC40MiwwLjA2LC0xLjc3LDAsLTIuMTldLFtcImNcIiwtMC4yNCwtMi4wMSwtMC45MywtMy42MywtMi4wNCwtNC43MV0sW1wiY1wiLC0wLjYzLC0wLjYzLC0xLjI5LC0xLjAyLC0yLjA3LC0xLjJdLFtcImNcIiwtMS42MiwtMC4zOSwtMy4zNiwwLjE1LC00LjU2LDEuNDRdLFtcImNcIiwtMC41NCwwLjYsLTEuMDUsMS40NywtMS4zMiwyLjIyXSxbXCJsXCIsLTAuMDksMC4yMV0sW1wibFwiLDAuMjQsLTAuMTJdLFtcImNcIiwwLjM5LC0wLjIxLDAuNjMsLTAuMjQsMS4xMSwtMC4yNF0sW1wiY1wiLDAuMywwLDAuNDUsMCwwLjY2LDAuMDZdLFtcImNcIiwxLjkyLDAuNDgsMi44NSwyLjU1LDEuOTUsNC4zOF0sW1wiY1wiLC0wLjQ1LDAuOTksLTEuNDEsMS42MiwtMi40NiwxLjcxXSxbXCJjXCIsLTEuNDcsMC4wOSwtMi45MSwtMC44NywtMy4zOSwtMi4yNV0sW1wiY1wiLC0wLjE4LC0wLjU3LC0wLjIxLC0xLjMyLC0wLjAzLC0yLjI4XSxbXCJjXCIsMC4zOSwtMi4yNSwxLjgzLC00LjIsMy44MSwtNS4xOV0sW1wiY1wiLDAuNjksLTAuMzYsMS41OSwtMC42LDIuMzcsLTAuNjldLFtcInpcIl0sW1wibVwiLDExLjU4LDIuNTJdLFtcImNcIiwwLjg0LC0wLjIxLDEuNzEsMC4zLDEuODksMS4xNF0sW1wiY1wiLDAuMywxLjE3LC0wLjcyLDIuMTksLTEuODksMS44OV0sW1wiY1wiLC0wLjk5LC0wLjIxLC0xLjUsLTEuMzIsLTEuMDIsLTIuMjVdLFtcImNcIiwwLjE4LC0wLjM5LDAuNiwtMC42OSwxLjAyLC0wLjc4XSxbXCJ6XCJdLFtcIm1cIiwwLDcuNV0sW1wiY1wiLDAuODQsLTAuMjEsMS43MSwwLjMsMS44OSwxLjE0XSxbXCJjXCIsMC4yMSwwLjg3LC0wLjMsMS43MSwtMS4xNCwxLjg5XSxbXCJjXCIsLTAuODcsMC4yMSwtMS43MSwtMC4zLC0xLjg5LC0xLjE0XSxbXCJjXCIsLTAuMjEsLTAuODQsMC4zLC0xLjcxLDEuMTQsLTEuODldLFtcInpcIl1dLHc6MjAuMTUzLGg6MjMuMTQyfSxcImNsZWZzLkdcIjp7ZDpbW1wiTVwiLDkuNjksLTM3LjQxXSxbXCJjXCIsMC4wOSwtMC4wOSwwLjI0LC0wLjA2LDAuMzYsMF0sW1wiY1wiLDAuMTIsMC4wOSwwLjU3LDAuNiwwLjk2LDEuMTFdLFtcImNcIiwxLjc3LDIuMzQsMy4yMSw1Ljg1LDMuNTcsOC43M10sW1wiY1wiLDAuMjEsMS41NiwwLjAzLDMuMjcsLTAuNDUsNC44Nl0sW1wiY1wiLC0wLjY5LDIuMzEsLTEuOTIsNC40NywtNC4yMyw3LjQ0XSxbXCJjXCIsLTAuMywwLjM5LC0wLjU3LDAuNzIsLTAuNiwwLjc1XSxbXCJjXCIsLTAuMDMsMC4wNiwwLDAuMTUsMC4xOCwwLjc4XSxbXCJjXCIsMC41NCwxLjY4LDEuMzgsNC40NCwxLjY4LDUuNDldLFtcImxcIiwwLjA5LDAuNDJdLFtcImxcIiwwLjM5LC0wXSxbXCJjXCIsMS40NywwLjA5LDIuNzYsMC41MSwzLjk2LDEuMjldLFtcImNcIiwxLjgzLDEuMjMsMy4wNiwzLjIxLDMuMzksNS41Ml0sW1wiY1wiLDAuMDksMC40NSwwLjEyLDEuMjksMC4wNiwxLjc0XSxbXCJjXCIsLTAuMDksMS4wMiwtMC4zMywxLjgzLC0wLjc1LDIuNzNdLFtcImNcIiwtMC44NCwxLjcxLC0yLjI4LDMuMDYsLTQuMDIsMy43Ml0sW1wibFwiLC0wLjMzLDAuMTJdLFtcImxcIiwwLjAzLDEuMjZdLFtcImNcIiwwLDEuNzQsLTAuMDYsMy42MywtMC4yMSw0LjYyXSxbXCJjXCIsLTAuNDUsMy4wNiwtMi4xOSw1LjQ5LC00LjQ3LDYuMjFdLFtcImNcIiwtMC41NywwLjE4LC0wLjksMC4yMSwtMS41OSwwLjIxXSxbXCJjXCIsLTAuNjksLTAsLTEuMDIsLTAuMDMsLTEuNjUsLTAuMjFdLFtcImNcIiwtMS4xNCwtMC4yNywtMi4xMywtMC44NCwtMi45NCwtMS42NV0sW1wiY1wiLC0wLjk5LC0wLjk5LC0xLjU2LC0yLjE2LC0xLjcxLC0zLjU0XSxbXCJjXCIsLTAuMDksLTAuODEsMC4wNiwtMS41MywwLjQ1LC0yLjEzXSxbXCJjXCIsMC42MywtMC45OSwxLjgzLC0xLjU2LDMsLTEuNTNdLFtcImNcIiwxLjUsMC4wOSwyLjY0LDEuMzIsMi43MywyLjk0XSxbXCJjXCIsMC4wNiwxLjQ3LC0wLjkzLDIuNywtMi4zNywyLjk3XSxbXCJjXCIsLTAuNDUsMC4wNiwtMC44NCwwLjAzLC0xLjI5LC0wLjA5XSxbXCJsXCIsLTAuMjEsLTAuMDldLFtcImxcIiwwLjA5LDAuMTJdLFtcImNcIiwwLjM5LDAuNTQsMC43OCwwLjkzLDEuMzIsMS4yNl0sW1wiY1wiLDEuMzUsMC44NywzLjA2LDEuMDIsNC4zNSwwLjM2XSxbXCJjXCIsMS40NCwtMC43MiwyLjUyLC0yLjI4LDIuOTcsLTQuMzVdLFtcImNcIiwwLjE1LC0wLjY2LDAuMjQsLTEuNSwwLjMsLTMuMDNdLFtcImNcIiwwLjAzLC0wLjg0LDAuMDMsLTIuOTQsLTAsLTNdLFtcImNcIiwtMC4wMywtMCwtMC4xOCwtMCwtMC4zNiwwLjAzXSxbXCJjXCIsLTAuNjYsMC4xMiwtMC45OSwwLjEyLC0xLjgzLDAuMTJdLFtcImNcIiwtMS4wNSwtMCwtMS43MSwtMC4wNiwtMi42MSwtMC4zXSxbXCJjXCIsLTQuMDIsLTAuOTksLTcuMTEsLTQuMzUsLTcuOCwtOC40Nl0sW1wiY1wiLC0wLjEyLC0wLjY2LC0wLjEyLC0wLjk5LC0wLjEyLC0xLjgzXSxbXCJjXCIsLTAsLTAuODQsLTAsLTEuMTQsMC4xNSwtMS45Ml0sW1wiY1wiLDAuMzYsLTIuMjgsMS40MSwtNC42MiwzLjMsLTcuMjldLFtcImxcIiwyLjc5LC0zLjZdLFtcImNcIiwwLjU0LC0wLjY2LDAuOTYsLTEuMiwwLjk2LC0xLjIzXSxbXCJjXCIsLTAsLTAuMDMsLTAuMDksLTAuMzMsLTAuMTgsLTAuNjldLFtcImNcIiwtMC45NiwtMy4yMSwtMS40MSwtNS4yOCwtMS41OSwtNy42OF0sW1wiY1wiLC0wLjEyLC0xLjM4LC0wLjE1LC0zLjA5LC0wLjA2LC0zLjk2XSxbXCJjXCIsMC4zMywtMi42NywxLjM4LC01LjA3LDMuMTIsLTcuMDhdLFtcImNcIiwwLjM2LC0wLjQyLDAuOTksLTEuMDUsMS4xNywtMS4xNF0sW1wielwiXSxbXCJtXCIsMi4wMSw0LjcxXSxbXCJjXCIsLTAuMTUsLTAuMywtMC4zLC0wLjU0LC0wLjMsLTAuNTRdLFtcImNcIiwtMC4wMywwLC0wLjE4LDAuMDksLTAuMywwLjIxXSxbXCJjXCIsLTIuNCwxLjc0LC0zLjg3LDQuMiwtNC4yNiw3LjExXSxbXCJjXCIsLTAuMDYsMC41NCwtMC4wNiwxLjQxLC0wLjAzLDEuODldLFtcImNcIiwwLjA5LDEuMjksMC40OCwzLjEyLDEuMDgsNS4yMl0sW1wiY1wiLDAuMTUsMC40MiwwLjI0LDAuNzgsMC4yNCwwLjgxXSxbXCJjXCIsMCwwLjAzLDAuODQsLTEuMTEsMS4yMywtMS42OF0sW1wiY1wiLDEuODksLTIuNzMsMi44OCwtNS4wNywzLjE1LC03LjUzXSxbXCJjXCIsMC4wOSwtMC41NywwLjEyLC0xLjc0LDAuMDYsLTIuMzddLFtcImNcIiwtMC4wOSwtMS4yMywtMC4yNywtMS45MiwtMC44NywtMy4xMl0sW1wielwiXSxbXCJtXCIsLTIuOTQsMjAuN10sW1wiY1wiLC0wLjIxLC0wLjcyLC0wLjM5LC0xLjMyLC0wLjQyLC0xLjMyXSxbXCJjXCIsMCwwLC0xLjIsMS40NywtMS44NiwyLjM3XSxbXCJjXCIsLTIuNzksMy42MywtNC4wMiw2LjMsLTQuMzUsOS4zXSxbXCJjXCIsLTAuMDMsMC4yMSwtMC4wMywwLjY5LC0wLjAzLDEuMDhdLFtcImNcIiwwLDAuNjksMCwwLjc1LDAuMDYsMS4xMV0sW1wiY1wiLDAuMTIsMC41NCwwLjI3LDAuOTksMC41MSwxLjQ3XSxbXCJjXCIsMC42OSwxLjM4LDEuODMsMi41NSwzLjQyLDMuNDJdLFtcImNcIiwwLjk2LDAuNTQsMi4wNywwLjksMy4yMSwxLjA4XSxbXCJjXCIsMC43OCwwLjEyLDIuMDQsMC4xMiwyLjk0LC0wLjAzXSxbXCJjXCIsMC41MSwtMC4wNiwwLjQ1LC0wLjAzLDAuNDIsLTAuM10sW1wiY1wiLC0wLjI0LC0zLjMzLC0wLjcyLC02LjMzLC0xLjYyLC0xMC4wOF0sW1wiY1wiLC0wLjA5LC0wLjM5LC0wLjE4LC0wLjc1LC0wLjE4LC0wLjc4XSxbXCJjXCIsLTAuMDMsLTAuMDMsLTAuNDIsLTAsLTAuODEsMC4wOV0sW1wiY1wiLC0wLjksMC4xOCwtMS42NSwwLjU3LC0yLjIyLDEuMTRdLFtcImNcIiwtMC43MiwwLjcyLC0xLjA4LDEuNjUsLTEuMDUsMi42NF0sW1wiY1wiLDAuMDYsMC45NiwwLjQ4LDEuODMsMS4yMywyLjU4XSxbXCJjXCIsMC4zNiwwLjM2LDAuNzIsMC42MywxLjE3LDAuOV0sW1wiY1wiLDAuMzMsMC4xOCwwLjM2LDAuMjEsMC40MiwwLjMzXSxbXCJjXCIsMC4xOCwwLjQyLC0wLjE4LDAuOSwtMC42LDAuODddLFtcImNcIiwtMC4xOCwtMC4wMywtMC44NCwtMC4zNiwtMS4yNiwtMC42M10sW1wiY1wiLC0wLjc4LC0wLjUxLC0xLjM4LC0xLjExLC0xLjg2LC0xLjgzXSxbXCJjXCIsLTEuNzcsLTIuNywtMC45OSwtNi40MiwxLjcxLC04LjE5XSxbXCJjXCIsMC4zLC0wLjIxLDAuODEsLTAuNDgsMS4xNywtMC42M10sW1wiY1wiLDAuMywtMC4wOSwxLjAyLC0wLjMsMS4xNCwtMC4zXSxbXCJjXCIsMC4wNiwtMCwwLjA5LC0wLDAuMDksLTAuMDNdLFtcImNcIiwwLjAzLC0wLjAzLC0wLjUxLC0xLjkyLC0xLjIzLC00LjI2XSxbXCJ6XCJdLFtcIm1cIiwzLjc4LDcuNDFdLFtcImNcIiwtMC4xOCwtMC4wMywtMC4zNiwtMC4wNiwtMC4zOSwtMC4wNl0sW1wiY1wiLC0wLjAzLDAsMCwwLjIxLDAuMTgsMS4wMl0sW1wiY1wiLDAuNzUsMy4xOCwxLjI2LDYuMywxLjUsOS4wOV0sW1wiY1wiLDAuMDYsMC43MiwwLDAuNjksMC41MSwwLjQyXSxbXCJjXCIsMC43OCwtMC4zNiwxLjQ0LC0wLjk2LDEuOTgsLTEuNzddLFtcImNcIiwxLjA4LC0xLjYyLDEuMiwtMy42OSwwLjMsLTUuNTVdLFtcImNcIiwtMC44MSwtMS42MiwtMi4zMSwtMi43OSwtNC4wOCwtMy4xNV0sW1wielwiXV0sdzoxOS4wNTEsaDo1Ny4wNTd9LFwiY2xlZnMucGVyY1wiOntkOltbXCJNXCIsNS4wNywtNy40NF0sW1wibFwiLDAuMDksLTAuMDZdLFtcImxcIiwxLjUzLDBdLFtcImxcIiwxLjUzLDBdLFtcImxcIiwwLjA5LDAuMDZdLFtcImxcIiwwLjA2LDAuMDldLFtcImxcIiwwLDcuMzVdLFtcImxcIiwwLDcuMzJdLFtcImxcIiwtMC4wNiwwLjA5XSxbXCJsXCIsLTAuMDksMC4wNl0sW1wibFwiLC0xLjUzLC0wXSxbXCJsXCIsLTEuNTMsLTBdLFtcImxcIiwtMC4wOSwtMC4wNl0sW1wibFwiLC0wLjA2LC0wLjA5XSxbXCJsXCIsMCwtNy4zMl0sW1wibFwiLDAsLTcuMzVdLFtcInpcIl0sW1wibVwiLDYuNjMsMF0sW1wibFwiLDAuMDksLTAuMDZdLFtcImxcIiwxLjUzLDBdLFtcImxcIiwxLjUzLDBdLFtcImxcIiwwLjA5LDAuMDZdLFtcImxcIiwwLjA2LDAuMDldLFtcImxcIiwwLDcuMzVdLFtcImxcIiwwLDcuMzJdLFtcImxcIiwtMC4wNiwwLjA5XSxbXCJsXCIsLTAuMDksMC4wNl0sW1wibFwiLC0xLjUzLC0wXSxbXCJsXCIsLTEuNTMsLTBdLFtcImxcIiwtMC4wOSwtMC4wNl0sW1wibFwiLC0wLjA2LC0wLjA5XSxbXCJsXCIsMCwtNy4zMl0sW1wibFwiLDAsLTcuMzVdLFtcInpcIl1dLHc6OS45OSxoOjE0Ljk3fSxcInRpbWVzaWcuY29tbW9uXCI6e2Q6W1tcIk1cIiw2LjY2LC03LjgyNl0sW1wiY1wiLDAuNzIsLTAuMDYsMS40MSwtMC4wMywxLjk4LDAuMDldLFtcImNcIiwxLjIsMC4yNywyLjM0LDAuOTYsMy4wOSwxLjkyXSxbXCJjXCIsMC42MywwLjgxLDEuMDgsMS44NiwxLjE0LDIuNzNdLFtcImNcIiwwLjA2LDEuMDIsLTAuNTEsMS45MiwtMS40NCwyLjIyXSxbXCJjXCIsLTAuMjQsMC4wOSwtMC4zLDAuMDksLTAuNjMsMC4wOV0sW1wiY1wiLC0wLjMzLC0wLC0wLjQyLC0wLC0wLjYzLC0wLjA2XSxbXCJjXCIsLTAuNjYsLTAuMjQsLTEuMTQsLTAuNjMsLTEuNDEsLTEuMl0sW1wiY1wiLC0wLjE1LC0wLjMsLTAuMjEsLTAuNTEsLTAuMjQsLTAuOV0sW1wiY1wiLC0wLjA2LC0xLjA4LDAuNTcsLTIuMDQsMS41NiwtMi4zN10sW1wiY1wiLDAuMTgsLTAuMDYsMC4yNywtMC4wNiwwLjYzLC0wLjA2XSxbXCJsXCIsMC40NSwwXSxbXCJjXCIsMC4wNiwwLjAzLDAuMDksMC4wMywwLjA5LDBdLFtcImNcIiwwLDAsLTAuMDksLTAuMTIsLTAuMjQsLTAuMjddLFtcImNcIiwtMS4wMiwtMS4xMSwtMi41NSwtMS42OCwtNC4wOCwtMS41XSxbXCJjXCIsLTEuMjksMC4xNSwtMi4wNCwwLjY5LC0yLjQsMS43NF0sW1wiY1wiLC0wLjM2LDAuOTMsLTAuNDIsMS44OSwtMC40Miw1LjM3XSxbXCJjXCIsMCwyLjk3LDAuMDYsMy45NiwwLjI0LDQuNzddLFtcImNcIiwwLjI0LDEuMDgsMC42MywxLjY4LDEuNDEsMi4wN10sW1wiY1wiLDAuODEsMC4zOSwyLjE2LDAuNDUsMy4xOCwwLjA5XSxbXCJjXCIsMS4yOSwtMC40NSwyLjM3LC0xLjUzLDMuMDMsLTIuOTddLFtcImNcIiwwLjE1LC0wLjMzLDAuMzMsLTAuODcsMC4zOSwtMS4xN10sW1wiY1wiLDAuMDksLTAuMjQsMC4xNSwtMC4zNiwwLjMsLTAuMzldLFtcImNcIiwwLjIxLC0wLjAzLDAuNDIsMC4xNSwwLjM5LDAuMzZdLFtcImNcIiwtMC4wNiwwLjM5LC0wLjQyLDEuMzgsLTAuNjksMS44OV0sW1wiY1wiLC0wLjk2LDEuOCwtMi40OSwyLjk0LC00LjIzLDMuMThdLFtcImNcIiwtMC45OSwwLjEyLC0yLjU4LC0wLjA2LC0zLjYzLC0wLjQ1XSxbXCJjXCIsLTAuOTYsLTAuMzYsLTEuNzEsLTAuODQsLTIuNCwtMS41XSxbXCJjXCIsLTEuMTEsLTEuMTEsLTEuOCwtMi42MSwtMi4wNCwtNC41Nl0sW1wiY1wiLC0wLjA2LC0wLjYsLTAuMDYsLTIuMDEsMCwtMi42MV0sW1wiY1wiLDAuMjQsLTEuOTUsMC45LC0zLjQ1LDIuMDEsLTQuNTZdLFtcImNcIiwwLjY5LC0wLjY2LDEuNDQsLTEuMTEsMi4zNywtMS40N10sW1wiY1wiLDAuNjMsLTAuMjQsMS40NywtMC40MiwyLjIyLC0wLjQ4XSxbXCJ6XCJdXSx3OjEzLjAzOCxoOjE1LjY5N30sXCJ0aW1lc2lnLmN1dFwiOntkOltbXCJNXCIsNi4yNCwtMTAuNDRdLFtcImNcIiwwLjA5LC0wLjA2LDAuMDksLTAuMDYsMC40OCwtMC4wNl0sW1wiY1wiLDAuMzYsMCwwLjM2LDAsMC40NSwwLjA2XSxbXCJsXCIsMC4wNiwwLjA5XSxbXCJsXCIsMCwxLjIzXSxbXCJsXCIsMCwxLjI2XSxbXCJsXCIsMC4yNywwXSxbXCJjXCIsMS4yNiwwLDIuNDksMC40NSwzLjQ4LDEuMjldLFtcImNcIiwxLjA1LDAuODcsMS44LDIuMjgsMS44OSwzLjQ4XSxbXCJjXCIsMC4wNiwxLjAyLC0wLjUxLDEuOTIsLTEuNDQsMi4yMl0sW1wiY1wiLC0wLjI0LDAuMDksLTAuMywwLjA5LC0wLjYzLDAuMDldLFtcImNcIiwtMC4zMywtMCwtMC40MiwtMCwtMC42MywtMC4wNl0sW1wiY1wiLC0wLjY2LC0wLjI0LC0xLjE0LC0wLjYzLC0xLjQxLC0xLjJdLFtcImNcIiwtMC4xNSwtMC4zLC0wLjIxLC0wLjUxLC0wLjI0LC0wLjldLFtcImNcIiwtMC4wNiwtMS4wOCwwLjU3LC0yLjA0LDEuNTYsLTIuMzddLFtcImNcIiwwLjE4LC0wLjA2LDAuMjcsLTAuMDYsMC42MywtMC4wNl0sW1wibFwiLDAuNDUsLTBdLFtcImNcIiwwLjA2LDAuMDMsMC4wOSwwLjAzLDAuMDksLTBdLFtcImNcIiwwLC0wLjAzLC0wLjQ1LC0wLjUxLC0wLjY2LC0wLjY5XSxbXCJjXCIsLTAuODcsLTAuNjksLTEuODMsLTEuMDUsLTIuOTQsLTEuMTFdLFtcImxcIiwtMC40MiwwXSxbXCJsXCIsMCw3LjE3XSxbXCJsXCIsMCw3LjE0XSxbXCJsXCIsMC40MiwwXSxbXCJjXCIsMC42OSwtMC4wMywxLjIzLC0wLjE4LDEuODYsLTAuNTFdLFtcImNcIiwxLjA1LC0wLjUxLDEuODksLTEuNDcsMi40NiwtMi43XSxbXCJjXCIsMC4xNSwtMC4zMywwLjMzLC0wLjg3LDAuMzksLTEuMTddLFtcImNcIiwwLjA5LC0wLjI0LDAuMTUsLTAuMzYsMC4zLC0wLjM5XSxbXCJjXCIsMC4yMSwtMC4wMywwLjQyLDAuMTUsMC4zOSwwLjM2XSxbXCJjXCIsLTAuMDMsMC4yNCwtMC4yMSwwLjc4LC0wLjM5LDEuMl0sW1wiY1wiLC0wLjk2LDIuMzcsLTIuOTQsMy45LC01LjEzLDMuOV0sW1wibFwiLC0wLjMsMF0sW1wibFwiLDAsMS4yNl0sW1wibFwiLDAsMS4yM10sW1wibFwiLC0wLjA2LDAuMDldLFtcImNcIiwtMC4wOSwwLjA2LC0wLjA5LDAuMDYsLTAuNDUsMC4wNl0sW1wiY1wiLC0wLjM5LDAsLTAuMzksMCwtMC40OCwtMC4wNl0sW1wibFwiLC0wLjA2LC0wLjA5XSxbXCJsXCIsMCwtMS4yOV0sW1wibFwiLDAsLTEuMjldLFtcImxcIiwtMC4yMSwtMC4wM10sW1wiY1wiLC0xLjIzLC0wLjIxLC0yLjMxLC0wLjYzLC0zLjIxLC0xLjI5XSxbXCJjXCIsLTAuMTUsLTAuMDksLTAuNDUsLTAuMzYsLTAuNjYsLTAuNTddLFtcImNcIiwtMS4xMSwtMS4xMSwtMS44LC0yLjYxLC0yLjA0LC00LjU2XSxbXCJjXCIsLTAuMDYsLTAuNiwtMC4wNiwtMi4wMSwwLC0yLjYxXSxbXCJjXCIsMC4yNCwtMS45NSwwLjkzLC0zLjQ1LDIuMDQsLTQuNTldLFtcImNcIiwwLjQyLC0wLjM5LDAuNzgsLTAuNjYsMS4yNiwtMC45M10sW1wiY1wiLDAuNzUsLTAuNDUsMS42NSwtMC43NSwyLjYxLC0wLjldLFtcImxcIiwwLjIxLC0wLjAzXSxbXCJsXCIsMCwtMS4yOV0sW1wibFwiLDAsLTEuMjldLFtcInpcIl0sW1wibVwiLC0wLjA2LDEwLjQ0XSxbXCJjXCIsMCwtNS41OCwwLC02Ljk5LC0wLjAzLC02Ljk5XSxbXCJjXCIsLTAuMTUsMCwtMC42MywwLjI3LC0wLjg3LDAuNDVdLFtcImNcIiwtMC40NSwwLjM2LC0wLjc1LDAuOTMsLTAuOTMsMS43N10sW1wiY1wiLC0wLjE4LDAuODEsLTAuMjQsMS44LC0wLjI0LDQuNzRdLFtcImNcIiwwLDIuOTcsMC4wNiwzLjk2LDAuMjQsNC43N10sW1wiY1wiLDAuMjQsMS4wOCwwLjY2LDEuNjgsMS40MSwyLjA3XSxbXCJjXCIsMC4xMiwwLjA2LDAuMywwLjEyLDAuMzMsMC4xNV0sW1wibFwiLDAuMDksMF0sW1wibFwiLDAsLTYuOTZdLFtcInpcIl1dLHc6MTMuMDM4LGg6MjAuOTd9LFwiMFwiOntkOltbXCJNXCIsNC44MywtMTQuOTddLFtcImNcIiwwLjMzLC0wLjAzLDEuMTEsMCwxLjQ3LDAuMDZdLFtcImNcIiwxLjY4LDAuMzYsMi45NywxLjU5LDMuNzgsMy42XSxbXCJjXCIsMS4yLDIuOTcsMC44MSw2Ljk2LC0wLjksOS4yN10sW1wiY1wiLC0wLjc4LDEuMDgsLTEuNzEsMS43MSwtMi45MSwxLjk1XSxbXCJjXCIsLTAuNDUsMC4wOSwtMS4zMiwwLjA5LC0xLjc3LDBdLFtcImNcIiwtMC44MSwtMC4xOCwtMS40NywtMC41MSwtMi4wNywtMS4wMl0sW1wiY1wiLC0yLjM0LC0yLjA3LC0zLjE1LC02LjcyLC0xLjc0LC0xMC4yXSxbXCJjXCIsMC44NywtMi4xNiwyLjI4LC0zLjQyLDQuMTQsLTMuNjZdLFtcInpcIl0sW1wibVwiLDEuMTEsMC44N10sW1wiY1wiLC0wLjIxLC0wLjA2LC0wLjY5LC0wLjA5LC0wLjg3LC0wLjA2XSxbXCJjXCIsLTAuNTQsMC4xMiwtMC44NywwLjQyLC0xLjE3LDAuOTldLFtcImNcIiwtMC4zNiwwLjY2LC0wLjUxLDEuNTYsLTAuNiwzXSxbXCJjXCIsLTAuMDMsMC43NSwtMC4wMyw0LjU5LC0wLDUuMzFdLFtcImNcIiwwLjA5LDEuNSwwLjI3LDIuNCwwLjYsMy4wNl0sW1wiY1wiLDAuMjQsMC40OCwwLjU3LDAuNzgsMC45NiwwLjldLFtcImNcIiwwLjI3LDAuMDksMC43OCwwLjA5LDEuMDUsLTBdLFtcImNcIiwwLjM5LC0wLjEyLDAuNzIsLTAuNDIsMC45NiwtMC45XSxbXCJjXCIsMC4zMywtMC42NiwwLjUxLC0xLjU2LDAuNiwtMy4wNl0sW1wiY1wiLDAuMDMsLTAuNzIsMC4wMywtNC41NiwtMCwtNS4zMV0sW1wiY1wiLC0wLjA5LC0xLjQ3LC0wLjI3LC0yLjM3LC0wLjYsLTMuMDNdLFtcImNcIiwtMC4yNCwtMC40OCwtMC41NCwtMC43OCwtMC45MywtMC45XSxbXCJ6XCJdXSx3OjEwLjc4LGg6MTQuOTU5fSxcIjFcIjp7ZDpbW1wiTVwiLDMuMywtMTUuMDZdLFtcImNcIiwwLjA2LC0wLjA2LDAuMjEsLTAuMDMsMC42NiwwLjE1XSxbXCJjXCIsMC44MSwwLjM5LDEuMDgsMC4zOSwxLjgzLDAuMDNdLFtcImNcIiwwLjIxLC0wLjA5LDAuMzksLTAuMTUsMC40MiwtMC4xNV0sW1wiY1wiLDAuMTIsMCwwLjIxLDAuMDksMC4yNywwLjIxXSxbXCJjXCIsMC4wNiwwLjEyLDAuMDYsMC4zMywwLjA2LDUuOTRdLFtcImNcIiwwLDMuOTMsMCw1Ljg1LDAuMDMsNi4wM10sW1wiY1wiLDAuMDYsMC4zNiwwLjE1LDAuNjksMC4yNywwLjk2XSxbXCJjXCIsMC4zNiwwLjc1LDAuOTMsMS4xNywxLjY4LDEuMjZdLFtcImNcIiwwLjMsMC4wMywwLjM5LDAuMDksMC4zOSwwLjNdLFtcImNcIiwwLDAuMTUsLTAuMDMsMC4xOCwtMC4wOSwwLjI0XSxbXCJjXCIsLTAuMDYsMC4wNiwtMC4wOSwwLjA2LC0wLjQ4LDAuMDZdLFtcImNcIiwtMC40MiwtMCwtMC42OSwtMC4wMywtMi4xLC0wLjI0XSxbXCJjXCIsLTAuOSwtMC4xNSwtMS43NywtMC4xNSwtMi42NywtMF0sW1wiY1wiLC0xLjQxLDAuMjEsLTEuNjgsMC4yNCwtMi4xLDAuMjRdLFtcImNcIiwtMC4zOSwtMCwtMC40MiwtMCwtMC40OCwtMC4wNl0sW1wiY1wiLC0wLjA2LC0wLjA2LC0wLjA2LC0wLjA5LC0wLjA2LC0wLjI0XSxbXCJjXCIsMCwtMC4yMSwwLjA2LC0wLjI3LDAuMzYsLTAuM10sW1wiY1wiLDAuNzUsLTAuMDksMS4zMiwtMC41MSwxLjY4LC0xLjI2XSxbXCJjXCIsMC4xMiwtMC4yNywwLjIxLC0wLjYsMC4yNywtMC45Nl0sW1wiY1wiLDAuMDMsLTAuMTgsMC4wMywtMS41OSwwLjAzLC00LjI5XSxbXCJjXCIsMCwtMy44NywwLC00LjA1LC0wLjA2LC00LjE0XSxbXCJjXCIsLTAuMDksLTAuMTUsLTAuMTgsLTAuMjQsLTAuMzksLTAuMjRdLFtcImNcIiwtMC4xMiwtMCwtMC4xNSwwLjAzLC0wLjIxLDAuMDZdLFtcImNcIiwtMC4wMywwLjA2LC0wLjQ1LDAuOTksLTAuOTYsMi4xM10sW1wiY1wiLC0wLjQ4LDEuMTQsLTAuOSwyLjEsLTAuOTMsMi4xNl0sW1wiY1wiLC0wLjA2LDAuMTUsLTAuMjEsMC4yNCwtMC4zMywwLjI0XSxbXCJjXCIsLTAuMjQsMCwtMC40MiwtMC4xOCwtMC40MiwtMC4zOV0sW1wiY1wiLDAsLTAuMDYsMy4yNywtNy42MiwzLjMzLC03Ljc0XSxbXCJ6XCJdXSx3OjguOTQsaDoxNS4wNTh9LFwiMlwiOntkOltbXCJNXCIsNC4yMywtMTQuOTddLFtcImNcIiwwLjU3LC0wLjA2LDEuNjgsMCwyLjM0LDAuMThdLFtcImNcIiwwLjY5LDAuMTgsMS41LDAuNTQsMi4wMSwwLjldLFtcImNcIiwxLjM1LDAuOTYsMS45NSwyLjI1LDEuNzcsMy44MV0sW1wiY1wiLC0wLjE1LDEuMzUsLTAuNjYsMi4zNCwtMS42OCwzLjE1XSxbXCJjXCIsLTAuNiwwLjQ4LC0xLjQ0LDAuOTMsLTMuMTIsMS42NV0sW1wiY1wiLC0xLjMyLDAuNTcsLTEuOCwwLjgxLC0yLjM3LDEuMTRdLFtcImNcIiwtMC41NywwLjMzLC0wLjU3LDAuMzMsLTAuMjQsMC4yN10sW1wiY1wiLDAuMzksLTAuMDksMS4yNiwtMC4wOSwxLjY4LDBdLFtcImNcIiwwLjcyLDAuMTUsMS40MSwwLjQ1LDIuMSwwLjldLFtcImNcIiwwLjk5LDAuNjMsMS44NiwwLjg3LDIuNTUsMC43NV0sW1wiY1wiLDAuMjQsLTAuMDYsMC40MiwtMC4xNSwwLjU3LC0wLjNdLFtcImNcIiwwLjEyLC0wLjA5LDAuMywtMC40MiwwLjMsLTAuNTFdLFtcImNcIiwwLC0wLjA5LDAuMTIsLTAuMjEsMC4yNCwtMC4yNF0sW1wiY1wiLDAuMTgsLTAuMDMsMC4zOSwwLjEyLDAuMzksMC4zXSxbXCJjXCIsMCwwLjEyLC0wLjE1LDAuNTcsLTAuMywwLjg3XSxbXCJjXCIsLTAuNTQsMS4wMiwtMS41NiwxLjc0LC0yLjc5LDIuMDFdLFtcImNcIiwtMC40MiwwLjA5LC0xLjIzLDAuMDksLTEuNjIsMC4wM10sW1wiY1wiLC0wLjgxLC0wLjE4LC0xLjMyLC0wLjQ1LC0yLjAxLC0xLjExXSxbXCJjXCIsLTAuNDUsLTAuNDUsLTAuNjMsLTAuNTcsLTAuOTYsLTAuNjldLFtcImNcIiwtMC44NCwtMC4yNywtMS44OSwwLjEyLC0yLjI1LDAuOV0sW1wiY1wiLC0wLjEyLDAuMjEsLTAuMjEsMC41NCwtMC4yMSwwLjcyXSxbXCJjXCIsMCwwLjEyLC0wLjEyLDAuMjEsLTAuMjcsMC4yNF0sW1wiY1wiLC0wLjE1LDAsLTAuMjcsLTAuMDMsLTAuMzMsLTAuMTVdLFtcImNcIiwtMC4wOSwtMC4yMSwwLjA5LC0xLjA4LDAuMzMsLTEuNzFdLFtcImNcIiwwLjI0LC0wLjY2LDAuNjYsLTEuMjYsMS4yOSwtMS44OV0sW1wiY1wiLDAuNDUsLTAuNDUsMC45LC0wLjgxLDEuOTIsLTEuNTZdLFtcImNcIiwxLjI5LC0wLjkzLDEuODksLTEuNDQsMi4zNCwtMS45OF0sW1wiY1wiLDAuODcsLTEuMDUsMS4yNiwtMi4xOSwxLjIsLTMuNjNdLFtcImNcIiwtMC4wNiwtMS4yOSwtMC4zOSwtMi4zMSwtMC45NiwtMi45MV0sW1wiY1wiLC0wLjM2LC0wLjMzLC0wLjcyLC0wLjUxLC0xLjE3LC0wLjU0XSxbXCJjXCIsLTAuODQsLTAuMDMsLTEuNTMsMC40MiwtMS41OSwxLjA1XSxbXCJjXCIsLTAuMDMsMC4zMywwLjEyLDAuNiwwLjU3LDEuMTRdLFtcImNcIiwwLjQ1LDAuNTQsMC41NCwwLjg3LDAuNDIsMS40MV0sW1wiY1wiLC0wLjE1LDAuNjMsLTAuNTQsMS4xMSwtMS4wOCwxLjM4XSxbXCJjXCIsLTAuNjMsMC4zMywtMS4yLDAuMzMsLTEuODMsMF0sW1wiY1wiLC0wLjI0LC0wLjEyLC0wLjMzLC0wLjE4LC0wLjU0LC0wLjM5XSxbXCJjXCIsLTAuMTgsLTAuMTgsLTAuMjcsLTAuMywtMC4zNiwtMC41MV0sW1wiY1wiLC0wLjI0LC0wLjQ1LC0wLjI3LC0wLjg0LC0wLjIxLC0xLjM4XSxbXCJjXCIsMC4xMiwtMC43NSwwLjQ1LC0xLjQxLDEuMDIsLTEuOThdLFtcImNcIiwwLjcyLC0wLjcyLDEuNzQsLTEuMTcsMi44NSwtMS4zMl0sW1wielwiXV0sdzoxMC43NjQsaDoxNC45OTN9LFwiM1wiOntkOltbXCJNXCIsMy43OCwtMTQuOTddLFtcImNcIiwwLjMsLTAuMDMsMS40MSwwLDEuODMsMC4wNl0sW1wiY1wiLDIuMjIsMC4zLDMuNTEsMS4zMiwzLjcyLDIuOTFdLFtcImNcIiwwLjAzLDAuMzMsMC4wMywxLjI2LC0wLjAzLDEuNjVdLFtcImNcIiwtMC4xMiwwLjg0LC0wLjQ4LDEuNDcsLTEuMDUsMS43N10sW1wiY1wiLC0wLjI3LDAuMTUsLTAuMzYsMC4yNCwtMC40NSwwLjM5XSxbXCJjXCIsLTAuMDksMC4yMSwtMC4wOSwwLjM2LDAsMC41N10sW1wiY1wiLDAuMDksMC4xNSwwLjE4LDAuMjQsMC41MSwwLjM5XSxbXCJjXCIsMC43NSwwLjQyLDEuMjMsMS4xNCwxLjQxLDIuMTNdLFtcImNcIiwwLjA2LDAuNDIsMC4wNiwxLjM1LDAsMS43MV0sW1wiY1wiLC0wLjE4LDAuODEsLTAuNDgsMS4zOCwtMS4wMiwxLjk1XSxbXCJjXCIsLTAuNzUsMC43MiwtMS44LDEuMiwtMy4xOCwxLjM4XSxbXCJjXCIsLTAuNDIsMC4wNiwtMS41NiwwLjA2LC0xLjk1LDBdLFtcImNcIiwtMS44OSwtMC4zMywtMy4xOCwtMS4yOSwtMy41MSwtMi42NF0sW1wiY1wiLC0wLjAzLC0wLjEyLC0wLjAzLC0wLjMzLC0wLjAzLC0wLjZdLFtcImNcIiwwLC0wLjM2LDAsLTAuNDIsMC4wNiwtMC42M10sW1wiY1wiLDAuMTIsLTAuMywwLjI3LC0wLjUxLDAuNTEsLTAuNzVdLFtcImNcIiwwLjI0LC0wLjI0LDAuNDUsLTAuMzksMC43NSwtMC41MV0sW1wiY1wiLDAuMjEsLTAuMDYsMC4yNywtMC4wNiwwLjYsLTAuMDZdLFtcImNcIiwwLjMzLDAsMC4zOSwwLDAuNiwwLjA2XSxbXCJjXCIsMC4zLDAuMTIsMC41MSwwLjI3LDAuNzUsMC41MV0sW1wiY1wiLDAuMzYsMC4zMywwLjU3LDAuNzUsMC42LDEuMl0sW1wiY1wiLDAsMC4yMSwwLDAuMjcsLTAuMDYsMC40Ml0sW1wiY1wiLC0wLjA5LDAuMTgsLTAuMTIsMC4yNCwtMC41NCwwLjU0XSxbXCJjXCIsLTAuNTEsMC4zNiwtMC42MywwLjU0LC0wLjYsMC44N10sW1wiY1wiLDAuMDYsMC41NCwwLjU0LDAuOSwxLjM4LDAuOTldLFtcImNcIiwwLjM2LDAuMDYsMC43MiwwLjAzLDAuOTYsLTAuMDZdLFtcImNcIiwwLjgxLC0wLjI3LDEuMjksLTEuMjMsMS40NCwtMi43OV0sW1wiY1wiLDAuMDMsLTAuNDUsMC4wMywtMS45NSwtMC4wMywtMi4zN10sW1wiY1wiLC0wLjA5LC0wLjc1LC0wLjMzLC0xLjIzLC0wLjc1LC0xLjQ0XSxbXCJjXCIsLTAuMzMsLTAuMTgsLTAuNDUsLTAuMTgsLTEuOTgsLTAuMThdLFtcImNcIiwtMS4zNSwwLC0xLjQxLDAsLTEuNSwtMC4wNl0sW1wiY1wiLC0wLjE4LC0wLjEyLC0wLjI0LC0wLjM5LC0wLjEyLC0wLjZdLFtcImNcIiwwLjEyLC0wLjE1LDAuMTUsLTAuMTUsMS42OCwtMC4xNV0sW1wiY1wiLDEuNSwwLDEuNjIsMCwxLjg5LC0wLjE1XSxbXCJjXCIsMC4xOCwtMC4wOSwwLjQyLC0wLjM2LDAuNTQsLTAuNTddLFtcImNcIiwwLjE4LC0wLjQyLDAuMjcsLTAuOSwwLjMsLTEuOTVdLFtcImNcIiwwLjAzLC0xLjIsLTAuMDYsLTEuOCwtMC4zNiwtMi4zN10sW1wiY1wiLC0wLjI0LC0wLjQ4LC0wLjYzLC0wLjgxLC0xLjE0LC0wLjk2XSxbXCJjXCIsLTAuMywtMC4wNiwtMS4wOCwtMC4wNiwtMS4zOCwwLjAzXSxbXCJjXCIsLTAuNiwwLjE1LC0wLjksMC40MiwtMC45NiwwLjg0XSxbXCJjXCIsLTAuMDMsMC4zLDAuMDYsMC40NSwwLjYzLDAuODRdLFtcImNcIiwwLjMzLDAuMjQsMC40MiwwLjM5LDAuNDUsMC42M10sW1wiY1wiLDAuMDMsMC43MiwtMC41NywxLjUsLTEuMzIsMS42NV0sW1wiY1wiLC0xLjA1LDAuMjcsLTIuMSwtMC41NywtMi4xLC0xLjY1XSxbXCJjXCIsMCwtMC40NSwwLjE1LC0wLjk2LDAuMzksLTEuMzhdLFtcImNcIiwwLjEyLC0wLjIxLDAuNTQsLTAuNjMsMC44MSwtMC44MV0sW1wiY1wiLDAuNTcsLTAuNDIsMS4zOCwtMC42OSwyLjI1LC0wLjgxXSxbXCJ6XCJdXSx3OjkuNzM1LGg6MTQuOTY3fSxcIjRcIjp7ZDpbW1wiTVwiLDguNjQsLTE0Ljk0XSxbXCJjXCIsMC4yNywtMC4wOSwwLjQyLC0wLjEyLDAuNTQsLTAuMDNdLFtcImNcIiwwLjA5LDAuMDYsMC4xNSwwLjIxLDAuMTUsMC4zXSxbXCJjXCIsLTAuMDMsMC4wNiwtMS45MiwyLjMxLC00LjIzLDUuMDRdLFtcImNcIiwtMi4zMSwyLjczLC00LjIzLDQuOTgsLTQuMjYsNS4wMV0sW1wiY1wiLC0wLjAzLDAuMDYsMC4xMiwwLjA2LDIuNTUsMC4wNl0sW1wibFwiLDIuNjEsMF0sW1wibFwiLDAsLTIuMzddLFtcImNcIiwwLC0yLjE5LDAuMDMsLTIuMzcsMC4wNiwtMi40Nl0sW1wiY1wiLDAuMDMsLTAuMDYsMC4yMSwtMC4xOCwwLjU3LC0wLjQyXSxbXCJjXCIsMS4wOCwtMC43MiwxLjM4LC0xLjA4LDEuODYsLTIuMTZdLFtcImNcIiwwLjEyLC0wLjMsMC4yNCwtMC41NCwwLjI3LC0wLjU3XSxbXCJjXCIsMC4xMiwtMC4xMiwwLjM5LC0wLjA2LDAuNDUsMC4xMl0sW1wiY1wiLDAuMDYsMC4wOSwwLjA2LDAuNTcsMC4wNiwzLjk2XSxbXCJsXCIsMCwzLjldLFtcImxcIiwxLjA4LDBdLFtcImNcIiwxLjA1LDAsMS4xMSwwLDEuMiwwLjA2XSxbXCJjXCIsMC4yNCwwLjE1LDAuMjQsMC41NCwwLDAuNjldLFtcImNcIiwtMC4wOSwwLjA2LC0wLjE1LDAuMDYsLTEuMiwwLjA2XSxbXCJsXCIsLTEuMDgsMF0sW1wibFwiLDAsMC4zM10sW1wiY1wiLDAsMC41NywwLjA5LDEuMTEsMC4zLDEuNTNdLFtcImNcIiwwLjM2LDAuNzUsMC45MywxLjE3LDEuNjgsMS4yNl0sW1wiY1wiLDAuMywwLjAzLDAuMzksMC4wOSwwLjM5LDAuM10sW1wiY1wiLDAsMC4xNSwtMC4wMywwLjE4LC0wLjA5LDAuMjRdLFtcImNcIiwtMC4wNiwwLjA2LC0wLjA5LDAuMDYsLTAuNDgsMC4wNl0sW1wiY1wiLC0wLjQyLDAsLTAuNjksLTAuMDMsLTIuMSwtMC4yNF0sW1wiY1wiLC0wLjksLTAuMTUsLTEuNzcsLTAuMTUsLTIuNjcsMF0sW1wiY1wiLC0xLjQxLDAuMjEsLTEuNjgsMC4yNCwtMi4xLDAuMjRdLFtcImNcIiwtMC4zOSwwLC0wLjQyLDAsLTAuNDgsLTAuMDZdLFtcImNcIiwtMC4wNiwtMC4wNiwtMC4wNiwtMC4wOSwtMC4wNiwtMC4yNF0sW1wiY1wiLDAsLTAuMjEsMC4wNiwtMC4yNywwLjM2LC0wLjNdLFtcImNcIiwwLjc1LC0wLjA5LDEuMzIsLTAuNTEsMS42OCwtMS4yNl0sW1wiY1wiLDAuMjEsLTAuNDIsMC4zLC0wLjk2LDAuMywtMS41M10sW1wibFwiLDAsLTAuMzNdLFtcImxcIiwtMi43LDBdLFtcImNcIiwtMi45MSwwLC0yLjg1LDAsLTMuMDksLTAuMTVdLFtcImNcIiwtMC4xOCwtMC4xMiwtMC4zLC0wLjM5LC0wLjI3LC0wLjU0XSxbXCJjXCIsMC4wMywtMC4wNiwwLjE4LC0wLjI0LDAuMzMsLTAuNDVdLFtcImNcIiwwLjc1LC0wLjksMS41OSwtMi4wNywyLjEzLC0zLjAzXSxbXCJjXCIsMC4zMywtMC41NCwwLjg0LC0xLjYyLDEuMDUsLTIuMTZdLFtcImNcIiwwLjU3LC0xLjQxLDAuODQsLTIuNjQsMC45LC00LjA1XSxbXCJjXCIsMC4wMywtMC42MywwLjA2LC0wLjcyLDAuMjQsLTAuODFdLFtcImxcIiwwLjEyLC0wLjA2XSxbXCJsXCIsMC40NSwwLjEyXSxbXCJjXCIsMC42NiwwLjE4LDEuMDIsMC4yNCwxLjQ3LDAuMjddLFtcImNcIiwwLjYsMC4wMywxLjIzLC0wLjA5LDIuMDEsLTAuMzNdLFtcInpcIl1dLHc6MTEuNzk1LGg6MTQuOTk0fSxcIjVcIjp7ZDpbW1wiTVwiLDEuMDIsLTE0Ljk0XSxbXCJjXCIsMC4xMiwtMC4wOSwwLjAzLC0wLjA5LDEuMDgsMC4wNl0sW1wiY1wiLDIuNDksMC4zNiw0LjM1LDAuMzYsNi45NiwtMC4wNl0sW1wiY1wiLDAuNTcsLTAuMDksMC42NiwtMC4wNiwwLjgxLDAuMDZdLFtcImNcIiwwLjE1LDAuMTgsMC4xMiwwLjI0LC0wLjE1LDAuNTFdLFtcImNcIiwtMS4yOSwxLjI2LC0zLjI0LDIuMDQsLTUuNTgsMi4zMV0sW1wiY1wiLC0wLjYsMC4wOSwtMS4yLDAuMTIsLTEuNzEsMC4xMl0sW1wiY1wiLC0wLjM5LDAsLTAuNDUsMCwtMC41NywwLjA2XSxbXCJjXCIsLTAuMDksMC4wNiwtMC4xNSwwLjEyLC0wLjIxLDAuMjFdLFtcImxcIiwtMC4wNiwwLjEyXSxbXCJsXCIsMCwxLjY1XSxbXCJsXCIsMCwxLjY1XSxbXCJsXCIsMC4yMSwtMC4yMV0sW1wiY1wiLDAuNjYsLTAuNTcsMS40MSwtMC45NiwyLjE5LC0xLjE0XSxbXCJjXCIsMC4zMywtMC4wNiwxLjQxLC0wLjA2LDEuOTUsMF0sW1wiY1wiLDIuNjEsMC4zNiw0LjAyLDEuNzQsNC4yNiw0LjE0XSxbXCJjXCIsMC4wMywwLjQ1LDAuMDMsMS4wOCwtMC4wMywxLjQ0XSxbXCJjXCIsLTAuMTgsMS4wMiwtMC43OCwyLjAxLC0xLjU5LDIuN10sW1wiY1wiLC0wLjcyLDAuNTcsLTEuNjIsMS4wMiwtMi40OSwxLjJdLFtcImNcIiwtMS4zOCwwLjI3LC0zLjAzLDAuMDYsLTQuMiwtMC41NF0sW1wiY1wiLC0xLjA4LC0wLjU0LC0xLjcxLC0xLjMyLC0xLjg2LC0yLjI4XSxbXCJjXCIsLTAuMDksLTAuNjksMC4wOSwtMS4yOSwwLjU3LC0xLjc0XSxbXCJjXCIsMC4yNCwtMC4yNCwwLjQ1LC0wLjM5LDAuNzUsLTAuNTFdLFtcImNcIiwwLjIxLC0wLjA2LDAuMjcsLTAuMDYsMC42LC0wLjA2XSxbXCJjXCIsMC4zMywwLDAuMzksMCwwLjYsMC4wNl0sW1wiY1wiLDAuMywwLjEyLDAuNTEsMC4yNywwLjc1LDAuNTFdLFtcImNcIiwwLjM2LDAuMzMsMC41NywwLjc1LDAuNiwxLjJdLFtcImNcIiwwLDAuMjEsMCwwLjI3LC0wLjA2LDAuNDJdLFtcImNcIiwtMC4wOSwwLjE4LC0wLjEyLDAuMjQsLTAuNTQsMC41NF0sW1wiY1wiLC0wLjE4LDAuMTIsLTAuMzYsMC4zLC0wLjQyLDAuMzNdLFtcImNcIiwtMC4zNiwwLjQyLC0wLjE4LDAuOTksMC4zNiwxLjI2XSxbXCJjXCIsMC41MSwwLjI3LDEuNDcsMC4zNiwyLjAxLDAuMjddLFtcImNcIiwwLjkzLC0wLjIxLDEuNDcsLTEuMTcsMS42NSwtMi45MV0sW1wiY1wiLDAuMDYsLTAuNDUsMC4wNiwtMS44OSwwLC0yLjMxXSxbXCJjXCIsLTAuMTUsLTEuMiwtMC41MSwtMi4xLC0xLjA1LC0yLjU1XSxbXCJjXCIsLTAuMjEsLTAuMTgsLTAuNTQsLTAuMzYsLTAuODEsLTAuMzldLFtcImNcIiwtMC4zLC0wLjA2LC0wLjg0LC0wLjAzLC0xLjI2LDAuMDZdLFtcImNcIiwtMC45MywwLjE4LC0xLjY1LDAuNiwtMi4xNiwxLjJdLFtcImNcIiwtMC4xNSwwLjIxLC0wLjI3LDAuMywtMC4zOSwwLjNdLFtcImNcIiwtMC4xNSwwLC0wLjMsLTAuMDksLTAuMzYsLTAuMThdLFtcImNcIiwtMC4wNiwtMC4wOSwtMC4wNiwtMC4xNSwtMC4wNiwtMy42Nl0sW1wiY1wiLDAsLTMuMzksMCwtMy41NywwLjA2LC0zLjY2XSxbXCJjXCIsMC4wMywtMC4wNiwwLjA5LC0wLjE1LDAuMTUsLTAuMThdLFtcInpcIl1dLHc6MTAuMjEyLGg6MTQuOTk3fSxcIjZcIjp7ZDpbW1wiTVwiLDQuOTgsLTE0Ljk3XSxbXCJjXCIsMC4zNiwtMC4wMywxLjIsMCwxLjU5LDAuMDZdLFtcImNcIiwwLjksMC4xNSwxLjY4LDAuNTEsMi4yNSwxLjA1XSxbXCJjXCIsMC41NywwLjUxLDAuODcsMS4yMywwLjg0LDEuOThdLFtcImNcIiwtMC4wMywwLjUxLC0wLjIxLDAuOSwtMC42LDEuMjZdLFtcImNcIiwtMC4yNCwwLjI0LC0wLjQ1LDAuMzksLTAuNzUsMC41MV0sW1wiY1wiLC0wLjIxLDAuMDYsLTAuMjcsMC4wNiwtMC42LDAuMDZdLFtcImNcIiwtMC4zMywwLC0wLjM5LDAsLTAuNiwtMC4wNl0sW1wiY1wiLC0wLjMsLTAuMTIsLTAuNTEsLTAuMjcsLTAuNzUsLTAuNTFdLFtcImNcIiwtMC4zOSwtMC4zNiwtMC41NywtMC43OCwtMC41NywtMS4yNl0sW1wiY1wiLDAsLTAuMjcsMCwtMC4zLDAuMDksLTAuNDJdLFtcImNcIiwwLjAzLC0wLjA5LDAuMTgsLTAuMjEsMC4zLC0wLjNdLFtcImNcIiwwLjEyLC0wLjA5LDAuMywtMC4yMSwwLjM5LC0wLjI3XSxbXCJjXCIsMC4wOSwtMC4wNiwwLjIxLC0wLjE4LDAuMjcsLTAuMjRdLFtcImNcIiwwLjA2LC0wLjEyLDAuMDksLTAuMTUsMC4wOSwtMC4zM10sW1wiY1wiLDAsLTAuMTgsLTAuMDMsLTAuMjQsLTAuMDksLTAuMzZdLFtcImNcIiwtMC4yNCwtMC4zOSwtMC43NSwtMC42LC0xLjM4LC0wLjU3XSxbXCJjXCIsLTAuNTQsMC4wMywtMC45LDAuMTgsLTEuMjMsMC40OF0sW1wiY1wiLC0wLjgxLDAuNzIsLTEuMDgsMi4xNiwtMC45Niw1LjM3XSxbXCJsXCIsMCwwLjYzXSxbXCJsXCIsMC4zLC0wLjEyXSxbXCJjXCIsMC43OCwtMC4yNywxLjI5LC0wLjMzLDIuMSwtMC4yN10sW1wiY1wiLDEuNDcsMC4xMiwyLjQ5LDAuNTQsMy4yNywxLjI5XSxbXCJjXCIsMC40OCwwLjUxLDAuODEsMS4xMSwwLjk2LDEuODldLFtcImNcIiwwLjA2LDAuMjcsMC4wNiwwLjQyLDAuMDYsMC45M10sW1wiY1wiLDAsMC41NCwwLDAuNjksLTAuMDYsMC45Nl0sW1wiY1wiLC0wLjE1LDAuNzgsLTAuNDgsMS4zOCwtMC45NiwxLjg5XSxbXCJjXCIsLTAuNTQsMC41MSwtMS4xNywwLjg3LC0xLjk4LDEuMDhdLFtcImNcIiwtMS4xNCwwLjMsLTIuNCwwLjMzLC0zLjI0LDAuMDNdLFtcImNcIiwtMS41LC0wLjQ4LC0yLjY0LC0xLjg5LC0zLjI3LC00LjAyXSxbXCJjXCIsLTAuMzYsLTEuMjMsLTAuNTEsLTIuODIsLTAuNDIsLTQuMDhdLFtcImNcIiwwLjMsLTMuNjYsMi4yOCwtNi4zLDQuOTUsLTYuNjZdLFtcInpcIl0sW1wibVwiLDAuNjYsNy40MV0sW1wiY1wiLC0wLjI3LC0wLjA5LC0wLjgxLC0wLjEyLC0xLjA4LC0wLjA2XSxbXCJjXCIsLTAuNzIsMC4xOCwtMS4wOCwwLjY5LC0xLjIzLDEuNzFdLFtcImNcIiwtMC4wNiwwLjU0LC0wLjA2LDMsMCwzLjU0XSxbXCJjXCIsMC4xOCwxLjI2LDAuNzIsMS43NywxLjgsMS43NF0sW1wiY1wiLDAuMzksLTAuMDMsMC42MywtMC4wOSwwLjksLTAuMjddLFtcImNcIiwwLjY2LC0wLjQyLDAuOSwtMS4zMiwwLjksLTMuMjRdLFtcImNcIiwwLC0yLjIyLC0wLjM2LC0zLjEyLC0xLjI5LC0zLjQyXSxbXCJ6XCJdXSx3OjkuOTU2LGg6MTQuOTgyfSxcIjdcIjp7ZDpbW1wiTVwiLDAuMjEsLTE0Ljk3XSxbXCJjXCIsMC4yMSwtMC4wNiwwLjQ1LDAsMC41NCwwLjE1XSxbXCJjXCIsMC4wNiwwLjA5LDAuMDYsMC4xNSwwLjA2LDAuMzldLFtcImNcIiwwLDAuMjQsMCwwLjMzLDAuMDYsMC40Ml0sW1wiY1wiLDAuMDYsMC4xMiwwLjIxLDAuMjQsMC4yNywwLjI0XSxbXCJjXCIsMC4wMywwLDAuMTIsLTAuMTIsMC4yNCwtMC4yMV0sW1wiY1wiLDAuOTYsLTEuMiwyLjU4LC0xLjM1LDMuOTksLTAuNDJdLFtcImNcIiwwLjE1LDAuMTIsMC40MiwwLjMsMC41NCwwLjQ1XSxbXCJjXCIsMC40OCwwLjM5LDAuODEsMC41NywxLjI5LDAuNl0sW1wiY1wiLDAuNjksMC4wMywxLjUsLTAuMywyLjEzLC0wLjg3XSxbXCJjXCIsMC4wOSwtMC4wOSwwLjI3LC0wLjMsMC4zOSwtMC40NV0sW1wiY1wiLDAuMTIsLTAuMTUsMC4yNCwtMC4yNywwLjMsLTAuM10sW1wiY1wiLDAuMTgsLTAuMDYsMC4zOSwwLjAzLDAuNTEsMC4yMV0sW1wiY1wiLDAuMDYsMC4xOCwwLjA2LDAuMjQsLTAuMjcsMC43Ml0sW1wiY1wiLC0wLjE4LDAuMjQsLTAuNTQsMC43OCwtMC43OCwxLjE3XSxbXCJjXCIsLTIuMzcsMy41NCwtMy41NCw2LjI3LC0zLjg3LDldLFtcImNcIiwtMC4wMywwLjMzLC0wLjAzLDAuNjYsLTAuMDMsMS4yNl0sW1wiY1wiLDAsMC45LDAsMS4wOCwwLjE1LDEuODldLFtcImNcIiwwLjA2LDAuNDUsMC4wNiwwLjQ4LDAuMDMsMC42XSxbXCJjXCIsLTAuMDYsMC4wOSwtMC4yMSwwLjIxLC0wLjMsMC4yMV0sW1wiY1wiLC0wLjAzLDAsLTAuMjcsLTAuMDYsLTAuNTQsLTAuMTVdLFtcImNcIiwtMC44NCwtMC4yNywtMS4xMSwtMC4zLC0xLjY1LC0wLjNdLFtcImNcIiwtMC41NywwLC0wLjg0LDAuMDMsLTEuNTYsMC4yN10sW1wiY1wiLC0wLjYsMC4xOCwtMC42OSwwLjIxLC0wLjgxLDAuMTVdLFtcImNcIiwtMC4xMiwtMC4wNiwtMC4yMSwtMC4xOCwtMC4yMSwtMC4zXSxbXCJjXCIsMCwtMC4xNSwwLjYsLTEuNDQsMS4yLC0yLjYxXSxbXCJjXCIsMS4xNCwtMi4yMiwyLjczLC00LjY4LDUuMSwtOC4wMV0sW1wiY1wiLDAuMjEsLTAuMjcsMC4zNiwtMC40OCwwLjMzLC0wLjQ4XSxbXCJjXCIsMCwwLC0wLjEyLDAuMDYsLTAuMjcsMC4xMl0sW1wiY1wiLC0wLjU0LDAuMywtMC45OSwwLjM5LC0xLjU2LDAuMzldLFtcImNcIiwtMC43NSwwLjAzLC0xLjIsLTAuMTgsLTEuODMsLTAuNzVdLFtcImNcIiwtMC45OSwtMC45LC0xLjgzLC0xLjE3LC0yLjMxLC0wLjcyXSxbXCJjXCIsLTAuMTgsMC4xNSwtMC4zNiwwLjUxLC0wLjQ1LDAuODRdLFtcImNcIiwtMC4wNiwwLjI0LC0wLjA2LDAuMzMsLTAuMDksMS45OF0sW1wiY1wiLDAsMS42MiwtMC4wMywxLjc0LC0wLjA2LDEuOF0sW1wiY1wiLC0wLjE1LDAuMjQsLTAuNTQsMC4yNCwtMC42OSwwXSxbXCJjXCIsLTAuMDYsLTAuMDksLTAuMDYsLTAuMTUsLTAuMDYsLTMuNTddLFtcImNcIiwwLC0zLjQyLDAsLTMuNDgsMC4wNiwtMy41N10sW1wiY1wiLDAuMDMsLTAuMDYsMC4wOSwtMC4xMiwwLjE1LC0wLjE1XSxbXCJ6XCJdXSx3OjEwLjU2MSxoOjE1LjA5M30sXCI4XCI6e2Q6W1tcIk1cIiw0Ljk4LC0xNC45N10sW1wiY1wiLDAuMzMsLTAuMDMsMS4wMiwtMC4wMywxLjMyLDBdLFtcImNcIiwxLjMyLDAuMTIsMi40OSwwLjYsMy4yMSwxLjMyXSxbXCJjXCIsMC4zOSwwLjM5LDAuNjYsMC44MSwwLjc4LDEuMjldLFtcImNcIiwwLjA5LDAuMzYsMC4wOSwxLjA4LDAsMS40NF0sW1wiY1wiLC0wLjIxLDAuODQsLTAuNjYsMS41OSwtMS41OSwyLjU1XSxbXCJsXCIsLTAuMywwLjNdLFtcImxcIiwwLjI3LDAuMThdLFtcImNcIiwxLjQ3LDAuOTMsMi4zMSwyLjMxLDIuMjUsMy43NV0sW1wiY1wiLC0wLjAzLDAuNzUsLTAuMjQsMS4zNSwtMC42MywxLjk1XSxbXCJjXCIsLTAuNDUsMC42NiwtMS4wMiwxLjE0LC0xLjgzLDEuNTNdLFtcImNcIiwtMS44LDAuODcsLTQuMiwwLjg3LC02LDAuMDNdLFtcImNcIiwtMS42MiwtMC43OCwtMi41MiwtMi4xNiwtMi40NiwtMy42Nl0sW1wiY1wiLDAuMDYsLTAuOTksMC41NCwtMS43NywxLjgsLTIuOTddLFtcImNcIiwwLjU0LC0wLjUxLDAuNTQsLTAuNTQsMC40OCwtMC41N10sW1wiY1wiLC0wLjM5LC0wLjI3LC0wLjk2LC0wLjc4LC0xLjIsLTEuMTRdLFtcImNcIiwtMC43NSwtMS4xMSwtMC44NywtMi40LC0wLjMsLTMuNl0sW1wiY1wiLDAuNjksLTEuMzUsMi4yNSwtMi4yNSw0LjIsLTIuNF0sW1wielwiXSxbXCJtXCIsMS41MywwLjY5XSxbXCJjXCIsLTAuNDIsLTAuMDksLTEuMTEsLTAuMTIsLTEuMzgsLTAuMDZdLFtcImNcIiwtMC4zLDAuMDYsLTAuNiwwLjE4LC0wLjgxLDAuM10sW1wiY1wiLC0wLjIxLDAuMTIsLTAuNiwwLjUxLC0wLjcyLDAuNzJdLFtcImNcIiwtMC41MSwwLjg3LC0wLjQyLDEuODksMC4yMSwyLjUyXSxbXCJjXCIsMC4yMSwwLjIxLDAuMzYsMC4zLDEuOTUsMS4yM10sW1wiY1wiLDAuOTYsMC41NCwxLjc0LDAuOTksMS43NywxLjAyXSxbXCJjXCIsMC4wOSwwLDAuNjMsLTAuNiwwLjk5LC0xLjExXSxbXCJjXCIsMC4yMSwtMC4zNiwwLjQ4LC0wLjg3LDAuNTcsLTEuMjNdLFtcImNcIiwwLjA2LC0wLjI0LDAuMDYsLTAuMzYsMC4wNiwtMC43Ml0sW1wiY1wiLDAsLTAuNDUsLTAuMDMsLTAuNjYsLTAuMTUsLTAuOTldLFtcImNcIiwtMC4zOSwtMC44MSwtMS4yOSwtMS40NCwtMi40OSwtMS42OF0sW1wielwiXSxbXCJtXCIsLTEuNDQsOC4wN10sW1wibFwiLC0xLjg5LC0xLjA4XSxbXCJjXCIsLTAuMDMsMCwtMC4xOCwwLjE1LC0wLjM5LDAuMzNdLFtcImNcIiwtMS4yLDEuMDgsLTEuNjUsMS45NSwtMS41OSwzXSxbXCJjXCIsMC4wOSwxLjU5LDEuMzUsMi44NSwzLjIxLDMuMjRdLFtcImNcIiwwLjMzLDAuMDYsMC40NSwwLjA2LDAuOTMsMC4wNl0sW1wiY1wiLDAuNjMsLTAsMC44MSwtMC4wMywxLjI5LC0wLjI3XSxbXCJjXCIsMC45LC0wLjQyLDEuNDcsLTEuNDEsMS40MSwtMi40XSxbXCJjXCIsLTAuMDYsLTAuNjYsLTAuMzksLTEuMjksLTAuOSwtMS42NV0sW1wiY1wiLC0wLjEyLC0wLjA5LC0xLjA1LC0wLjYzLC0yLjA3LC0xLjIzXSxbXCJ6XCJdXSx3OjEwLjkyNixoOjE0Ljk4OX0sXCI5XCI6e2Q6W1tcIk1cIiw0LjIzLC0xNC45N10sW1wiY1wiLDAuNDIsLTAuMDMsMS4yOSwwLDEuNjIsMC4wNl0sW1wiY1wiLDAuNTEsMC4xMiwwLjkzLDAuMywxLjM4LDAuNTddLFtcImNcIiwxLjUzLDEuMDIsMi41MiwzLjI0LDIuNzMsNS45NF0sW1wiY1wiLDAuMTgsMi41NSwtMC40OCw0Ljk4LC0xLjgzLDYuNTddLFtcImNcIiwtMS4wNSwxLjI2LC0yLjQsMS44OSwtMy45MywxLjgzXSxbXCJjXCIsLTEuMjMsLTAuMDYsLTIuMzEsLTAuNDUsLTMuMDMsLTEuMTRdLFtcImNcIiwtMC41NywtMC41MSwtMC44NywtMS4yMywtMC44NCwtMS45OF0sW1wiY1wiLDAuMDMsLTAuNTEsMC4yMSwtMC45LDAuNiwtMS4yNl0sW1wiY1wiLDAuMjQsLTAuMjQsMC40NSwtMC4zOSwwLjc1LC0wLjUxXSxbXCJjXCIsMC4yMSwtMC4wNiwwLjI3LC0wLjA2LDAuNiwtMC4wNl0sW1wiY1wiLDAuMzMsLTAsMC4zOSwtMCwwLjYsMC4wNl0sW1wiY1wiLDAuMywwLjEyLDAuNTEsMC4yNywwLjc1LDAuNTFdLFtcImNcIiwwLjM5LDAuMzYsMC41NywwLjc4LDAuNTcsMS4yNl0sW1wiY1wiLDAsMC4yNywwLDAuMywtMC4wOSwwLjQyXSxbXCJjXCIsLTAuMDMsMC4wOSwtMC4xOCwwLjIxLC0wLjMsMC4zXSxbXCJjXCIsLTAuMTIsMC4wOSwtMC4zLDAuMjEsLTAuMzksMC4yN10sW1wiY1wiLC0wLjA5LDAuMDYsLTAuMjEsMC4xOCwtMC4yNywwLjI0XSxbXCJjXCIsLTAuMDYsMC4xMiwtMC4wNiwwLjE1LC0wLjA2LDAuMzNdLFtcImNcIiwwLDAuMTgsMCwwLjI0LDAuMDYsMC4zNl0sW1wiY1wiLDAuMjQsMC4zOSwwLjc1LDAuNiwxLjM4LDAuNTddLFtcImNcIiwwLjU0LC0wLjAzLDAuOSwtMC4xOCwxLjIzLC0wLjQ4XSxbXCJjXCIsMC44MSwtMC43MiwxLjA4LC0yLjE2LDAuOTYsLTUuMzddLFtcImxcIiwwLC0wLjYzXSxbXCJsXCIsLTAuMywwLjEyXSxbXCJjXCIsLTAuNzgsMC4yNywtMS4yOSwwLjMzLC0yLjEsMC4yN10sW1wiY1wiLC0xLjQ3LC0wLjEyLC0yLjQ5LC0wLjU0LC0zLjI3LC0xLjI5XSxbXCJjXCIsLTAuNDgsLTAuNTEsLTAuODEsLTEuMTEsLTAuOTYsLTEuODldLFtcImNcIiwtMC4wNiwtMC4yNywtMC4wNiwtMC40MiwtMC4wNiwtMC45Nl0sW1wiY1wiLDAsLTAuNTEsMCwtMC42NiwwLjA2LC0wLjkzXSxbXCJjXCIsMC4xNSwtMC43OCwwLjQ4LC0xLjM4LDAuOTYsLTEuODldLFtcImNcIiwwLjE1LC0wLjEyLDAuMzMsLTAuMjcsMC40MiwtMC4zNl0sW1wiY1wiLDAuNjksLTAuNTEsMS42MiwtMC44MSwyLjc2LC0wLjkzXSxbXCJ6XCJdLFtcIm1cIiwxLjE3LDAuNjZdLFtcImNcIiwtMC4yMSwtMC4wNiwtMC41NywtMC4wNiwtMC44MSwtMC4wM10sW1wiY1wiLC0wLjc4LDAuMTIsLTEuMjYsMC42OSwtMS40MSwxLjc0XSxbXCJjXCIsLTAuMTIsMC42MywtMC4xNSwxLjk1LC0wLjA5LDIuNzldLFtcImNcIiwwLjEyLDEuNzEsMC42MywyLjQsMS43NywyLjQ2XSxbXCJjXCIsMS4wOCwwLjAzLDEuNjIsLTAuNDgsMS44LC0xLjc0XSxbXCJjXCIsMC4wNiwtMC41NCwwLjA2LC0zLDAsLTMuNTRdLFtcImNcIiwtMC4xNSwtMS4wNSwtMC41MSwtMS41MywtMS4yNiwtMS42OF0sW1wielwiXV0sdzo5Ljk1OSxoOjE0Ljk4Nn0sZjp7ZDpbW1wiTVwiLDkuOTMsLTE0LjI4XSxbXCJjXCIsMS41MywtMC4xOCwyLjg4LDAuNDUsMy4xMiwxLjVdLFtcImNcIiwwLjEyLDAuNTEsMCwxLjMyLC0wLjI3LDEuODZdLFtcImNcIiwtMC4xNSwwLjMsLTAuNDIsMC41NywtMC42MywwLjY5XSxbXCJjXCIsLTAuNjksMC4zNiwtMS41NiwwLjAzLC0xLjgzLC0wLjY5XSxbXCJjXCIsLTAuMDksLTAuMjQsLTAuMDksLTAuNjksMCwtMC44N10sW1wiY1wiLDAuMDYsLTAuMTIsMC4yMSwtMC4yNCwwLjQ1LC0wLjQyXSxbXCJjXCIsMC40MiwtMC4yNCwwLjU3LC0wLjQ1LDAuNiwtMC43Ml0sW1wiY1wiLDAuMDMsLTAuMzMsLTAuMDksLTAuMzksLTAuNjMsLTAuNDJdLFtcImNcIiwtMC4zLDAsLTAuNDUsMCwtMC42LDAuMDNdLFtcImNcIiwtMC44MSwwLjIxLC0xLjM1LDAuOTMsLTEuNzQsMi40Nl0sW1wiY1wiLC0wLjA2LDAuMjcsLTAuNDgsMi4yNSwtMC40OCwyLjMxXSxbXCJjXCIsMCwwLjAzLDAuMzksMC4wMywwLjksMC4wM10sW1wiY1wiLDAuNzIsMCwwLjksMCwwLjk5LDAuMDZdLFtcImNcIiwwLjQyLDAuMTUsMC40NSwwLjcyLDAuMDMsMC45XSxbXCJjXCIsLTAuMTIsMC4wNiwtMC4yNCwwLjA2LC0xLjE3LDAuMDZdLFtcImxcIiwtMS4wNSwwXSxbXCJsXCIsLTAuNzgsMi41NV0sW1wiY1wiLC0wLjQ1LDEuNDEsLTAuODcsMi43OSwtMC45NiwzLjA2XSxbXCJjXCIsLTAuODcsMi4zNywtMi4zNyw0Ljc0LC0zLjc4LDUuOTFdLFtcImNcIiwtMS4wNSwwLjksLTIuMDQsMS4yMywtMy4wOSwxLjA4XSxbXCJjXCIsLTEuMTEsLTAuMTgsLTEuODksLTAuNzgsLTIuMDQsLTEuNTldLFtcImNcIiwtMC4xMiwtMC42NiwwLjE1LC0xLjcxLDAuNTQsLTIuMTldLFtcImNcIiwwLjY5LC0wLjc1LDEuODYsLTAuNTQsMi4yMiwwLjM5XSxbXCJjXCIsMC4wNiwwLjE1LDAuMDksMC4yNywwLjA5LDAuNDhdLFtcImNcIiwtMCwwLjI0LC0wLjAzLDAuMjcsLTAuMTIsMC40Ml0sW1wiY1wiLC0wLjAzLDAuMDksLTAuMTUsMC4xOCwtMC4yNywwLjI3XSxbXCJjXCIsLTAuMDksMC4wNiwtMC4yNywwLjIxLC0wLjM2LDAuMjddLFtcImNcIiwtMC4yNCwwLjE4LC0wLjM2LDAuMzYsLTAuMzksMC42XSxbXCJjXCIsLTAuMDMsMC4zMywwLjA5LDAuMzksMC42MywwLjQyXSxbXCJjXCIsMC40MiwwLDAuNjMsLTAuMDMsMC45LC0wLjE1XSxbXCJjXCIsMC42LC0wLjMsMC45NiwtMC45NiwxLjM4LC0yLjY0XSxbXCJjXCIsMC4wOSwtMC40MiwwLjYzLC0yLjU1LDEuMTcsLTQuNzddLFtcImxcIiwxLjAyLC00LjA4XSxbXCJjXCIsLTAsLTAuMDMsLTAuMzYsLTAuMDMsLTAuODEsLTAuMDNdLFtcImNcIiwtMC43MiwwLC0wLjgxLDAsLTAuOTMsLTAuMDZdLFtcImNcIiwtMC40MiwtMC4xOCwtMC4zOSwtMC43NSwwLjAzLC0wLjldLFtcImNcIiwwLjA5LC0wLjA2LDAuMjcsLTAuMDYsMS4wNSwtMC4wNl0sW1wibFwiLDAuOTYsMF0sW1wibFwiLDAsLTAuMDldLFtcImNcIiwwLjA2LC0wLjE4LDAuMywtMC43MiwwLjUxLC0xLjE3XSxbXCJjXCIsMS4yLC0yLjQ2LDMuMywtNC4yMyw1LjM0LC00LjVdLFtcInpcIl1dLHc6MTYuMTU1LGg6MTkuNDQ1fSxtOntkOltbXCJNXCIsMi43OSwtOC45MV0sW1wiY1wiLDAuMDksMCwwLjMsLTAuMDMsMC40NSwtMC4wM10sW1wiY1wiLDAuMjQsMC4wMywwLjMsMC4wMywwLjQ1LDAuMTJdLFtcImNcIiwwLjM2LDAuMTUsMC42MywwLjU0LDAuNzUsMS4wMl0sW1wibFwiLDAuMDMsMC4yMV0sW1wibFwiLDAuMzMsLTAuM10sW1wiY1wiLDAuNjksLTAuNjksMS4zOCwtMS4wMiwyLjA3LC0xLjAyXSxbXCJjXCIsMC4yNywwLDAuMzMsMCwwLjQ4LDAuMDZdLFtcImNcIiwwLjIxLDAuMDksMC40OCwwLjM2LDAuNjMsMC42XSxbXCJjXCIsMC4wMywwLjA5LDAuMTIsMC4yNywwLjE4LDAuNDJdLFtcImNcIiwwLjAzLDAuMTUsMC4wOSwwLjI3LDAuMTIsMC4yN10sW1wiY1wiLDAsMCwwLjA5LC0wLjA5LDAuMTgsLTAuMjFdLFtcImNcIiwwLjMzLC0wLjM5LDAuODcsLTAuODEsMS4yOSwtMC45OV0sW1wiY1wiLDAuNzgsLTAuMzMsMS40NywtMC4yMSwyLjAxLDAuMzNdLFtcImNcIiwwLjMsMC4zMywwLjQ4LDAuNjksMC42LDEuMTRdLFtcImNcIiwwLjA5LDAuNDIsMC4wNiwwLjU0LC0wLjU0LDMuMDZdLFtcImNcIiwtMC4zMywxLjI5LC0wLjU3LDIuNCwtMC41NywyLjQzXSxbXCJjXCIsMCwwLjEyLDAuMDksMC4yMSwwLjIxLDAuMjFdLFtcImNcIiwwLjI0LC0wLDAuNzUsLTAuMywxLjIsLTAuNzJdLFtcImNcIiwwLjQ1LC0wLjM5LDAuNiwtMC40NSwwLjc4LC0wLjI3XSxbXCJjXCIsMC4xOCwwLjE4LDAuMDksMC4zNiwtMC40NSwwLjg3XSxbXCJjXCIsLTEuMDUsMC45NiwtMS44MywxLjQ3LC0yLjU4LDEuNzFdLFtcImNcIiwtMC45MywwLjMzLC0xLjUzLDAuMjEsLTEuOCwtMC4zM10sW1wiY1wiLC0wLjA2LC0wLjE1LC0wLjA2LC0wLjIxLC0wLjA2LC0wLjQ1XSxbXCJjXCIsMCwtMC4yNCwwLjAzLC0wLjQ4LDAuNiwtMi44Ml0sW1wiY1wiLDAuNDIsLTEuNzEsMC42LC0yLjY0LDAuNjMsLTIuNzldLFtcImNcIiwwLjAzLC0wLjU3LC0wLjMsLTAuNzUsLTAuODQsLTAuNDhdLFtcImNcIiwtMC4yNCwwLjEyLC0wLjU0LDAuMzksLTAuNjYsMC42M10sW1wiY1wiLC0wLjAzLDAuMDksLTAuNDIsMS4zOCwtMC45LDNdLFtcImNcIiwtMC45LDMuMTUsLTAuODQsMywtMS4xNCwzLjE1XSxbXCJsXCIsLTAuMTUsMC4wOV0sW1wibFwiLC0wLjc4LDBdLFtcImNcIiwtMC42LDAsLTAuNzgsMCwtMC44NCwtMC4wNl0sW1wiY1wiLC0wLjA5LC0wLjAzLC0wLjE4LC0wLjE4LC0wLjE4LC0wLjI3XSxbXCJjXCIsMCwtMC4wMywwLjM2LC0xLjM4LDAuODQsLTIuOTddLFtcImNcIiwwLjU3LC0yLjA0LDAuODEsLTIuOTcsMC44NCwtMy4xMl0sW1wiY1wiLDAuMDMsLTAuNTQsLTAuMywtMC43MiwtMC44NCwtMC40NV0sW1wiY1wiLC0wLjI0LDAuMTIsLTAuNTcsMC40MiwtMC42NiwwLjYzXSxbXCJjXCIsLTAuMDYsMC4wOSwtMC41MSwxLjQ0LC0xLjA1LDIuOTddLFtcImNcIiwtMC41MSwxLjU2LC0wLjk5LDIuODUsLTAuOTksMi45MV0sW1wiY1wiLC0wLjA2LDAuMTIsLTAuMjEsMC4yNCwtMC4zNiwwLjNdLFtcImNcIiwtMC4xMiwwLjA2LC0wLjIxLDAuMDYsLTAuOSwwLjA2XSxbXCJjXCIsLTAuNiwwLC0wLjc4LDAsLTAuODQsLTAuMDZdLFtcImNcIiwtMC4wOSwtMC4wMywtMC4xOCwtMC4xOCwtMC4xOCwtMC4yN10sW1wiY1wiLDAsLTAuMDMsMC40NSwtMS4zOCwwLjk5LC0yLjk3XSxbXCJjXCIsMS4wNSwtMy4xOCwxLjA1LC0zLjE4LDAuOTMsLTMuNDVdLFtcImNcIiwtMC4xMiwtMC4yNywtMC4zOSwtMC4zLC0wLjcyLC0wLjE1XSxbXCJjXCIsLTAuNTQsMC4yNywtMS4xNCwxLjE3LC0xLjU2LDIuNF0sW1wiY1wiLC0wLjA2LDAuMTUsLTAuMTUsMC4zLC0wLjE4LDAuMzZdLFtcImNcIiwtMC4yMSwwLjIxLC0wLjU3LDAuMjcsLTAuNzIsMC4wOV0sW1wiY1wiLC0wLjA5LC0wLjA5LC0wLjA2LC0wLjIxLDAuMDYsLTAuNjNdLFtcImNcIiwwLjQ4LC0xLjI2LDEuMjYsLTIuNDYsMi4wMSwtMy4yMV0sW1wiY1wiLDAuNTcsLTAuNTQsMS4yLC0wLjg3LDEuODMsLTEuMDJdLFtcInpcIl1dLHc6MTQuNjg3LGg6OS4xMjZ9LHA6e2Q6W1tcIk1cIiwxLjkyLC04LjddLFtcImNcIiwwLjI3LC0wLjA5LDAuODEsLTAuMDYsMS4xMSwwLjAzXSxbXCJjXCIsMC41NCwwLjE4LDAuOTMsMC41MSwxLjE3LDAuOTldLFtcImNcIiwwLjA5LDAuMTUsMC4xNSwwLjMzLDAuMTgsMC4zNl0sW1wibFwiLC0wLDAuMTJdLFtcImxcIiwwLjMsLTAuMjddLFtcImNcIiwwLjY2LC0wLjYsMS4zNSwtMS4wMiwyLjEzLC0xLjJdLFtcImNcIiwwLjIxLC0wLjA2LDAuMzMsLTAuMDYsMC43OCwtMC4wNl0sW1wiY1wiLDAuNDUsMCwwLjUxLDAsMC44NCwwLjA5XSxbXCJjXCIsMS4yOSwwLjMzLDIuMDcsMS4zMiwyLjI1LDIuNzldLFtcImNcIiwwLjA5LDAuODEsLTAuMDksMi4wMSwtMC40NSwyLjc5XSxbXCJjXCIsLTAuNTQsMS4yNiwtMS44NiwyLjU1LC0zLjE4LDMuMDNdLFtcImNcIiwtMC40NSwwLjE4LC0wLjgxLDAuMjQsLTEuMjksMC4yNF0sW1wiY1wiLC0wLjY5LC0wLjAzLC0xLjM1LC0wLjE4LC0xLjg2LC0wLjQ1XSxbXCJjXCIsLTAuMywtMC4xNSwtMC41MSwtMC4xOCwtMC42OSwtMC4wOV0sW1wiY1wiLC0wLjA5LDAuMDMsLTAuMTgsMC4wOSwtMC4xOCwwLjEyXSxbXCJjXCIsLTAuMDksMC4xMiwtMS4wNSwyLjk0LC0xLjA1LDMuMDZdLFtcImNcIiwwLDAuMjQsMC4xOCwwLjQ4LDAuNTEsMC42M10sW1wiY1wiLDAuMTgsMC4wNiwwLjU0LDAuMTUsMC43NSwwLjE1XSxbXCJjXCIsMC4yMSwwLDAuMzYsMC4wNiwwLjQyLDAuMThdLFtcImNcIiwwLjEyLDAuMTgsMC4wNiwwLjQyLC0wLjEyLDAuNTRdLFtcImNcIiwtMC4wOSwwLjAzLC0wLjE1LDAuMDMsLTAuNzgsMF0sW1wiY1wiLC0xLjk4LC0wLjE1LC0zLjgxLC0wLjE1LC01Ljc5LDBdLFtcImNcIiwtMC42MywwLjAzLC0wLjY5LDAuMDMsLTAuNzgsMF0sW1wiY1wiLC0wLjI0LC0wLjE1LC0wLjI0LC0wLjU3LDAuMDMsLTAuNjZdLFtcImNcIiwwLjA2LC0wLjAzLDAuNDgsLTAuMDksMC45OSwtMC4xMl0sW1wiY1wiLDAuODcsLTAuMDYsMS4xMSwtMC4wOSwxLjM1LC0wLjIxXSxbXCJjXCIsMC4xOCwtMC4wNiwwLjMzLC0wLjE4LDAuMzksLTAuM10sW1wiY1wiLDAuMDYsLTAuMTIsMy4yNCwtOS40MiwzLjI3LC05LjZdLFtcImNcIiwwLjA2LC0wLjMzLDAuMDMsLTAuNTcsLTAuMTUsLTAuNjldLFtcImNcIiwtMC4wOSwtMC4wNiwtMC4xMiwtMC4wNiwtMC4zLC0wLjA2XSxbXCJjXCIsLTAuNjksMC4wNiwtMS41MywxLjAyLC0yLjI4LDIuNjFdLFtcImNcIiwtMC4wOSwwLjIxLC0wLjIxLDAuNDUsLTAuMjcsMC41MV0sW1wiY1wiLC0wLjA5LDAuMTIsLTAuMzMsMC4yNCwtMC40OCwwLjI0XSxbXCJjXCIsLTAuMTgsMCwtMC4zNiwtMC4xNSwtMC4zNiwtMC4zXSxbXCJjXCIsMCwtMC4yNCwwLjc4LC0xLjgzLDEuMjYsLTIuNTVdLFtcImNcIiwwLjcyLC0xLjExLDEuNDcsLTEuNzQsMi4yOCwtMS45Ml0sW1wielwiXSxbXCJtXCIsNS4zNywxLjQ3XSxbXCJjXCIsLTAuMjcsLTAuMTIsLTAuNzUsLTAuMDMsLTEuMTQsMC4yMV0sW1wiY1wiLC0wLjc1LDAuNDgsLTEuNDcsMS42OCwtMS44OSwzLjE1XSxbXCJjXCIsLTAuNDUsMS40NywtMC40MiwyLjM0LDAsMi43XSxbXCJjXCIsMC40NSwwLjM5LDEuMjYsMC4yMSwxLjgzLC0wLjM2XSxbXCJjXCIsMC41MSwtMC41MSwwLjk5LC0xLjY4LDEuMzgsLTMuMjddLFtcImNcIiwwLjMsLTEuMTcsMC4zMywtMS43NCwwLjE1LC0yLjEzXSxbXCJjXCIsLTAuMDksLTAuMTUsLTAuMTUsLTAuMjEsLTAuMzMsLTAuM10sW1wielwiXV0sdzoxNC42ODksaDoxMy4xMjd9LHI6e2Q6W1tcIk1cIiw2LjMzLC05LjEyXSxbXCJjXCIsMC4yNywtMC4wMywwLjkzLDAsMS4yLDAuMDZdLFtcImNcIiwwLjg0LDAuMjEsMS4yMywwLjgxLDEuMDIsMS41M10sW1wiY1wiLC0wLjI0LDAuNzUsLTAuOSwxLjE3LC0xLjU2LDAuOTZdLFtcImNcIiwtMC4zMywtMC4wOSwtMC41MSwtMC4zLC0wLjY2LC0wLjc1XSxbXCJjXCIsLTAuMDMsLTAuMTIsLTAuMDksLTAuMjQsLTAuMTIsLTAuM10sW1wiY1wiLC0wLjA5LC0wLjE1LC0wLjMsLTAuMjQsLTAuNDgsLTAuMjRdLFtcImNcIiwtMC41NywwLC0xLjM4LDAuNTQsLTEuNjUsMS4wOF0sW1wiY1wiLC0wLjA2LDAuMTUsLTAuMzMsMS4xNywtMC45LDMuMjddLFtcImNcIiwtMC41NywyLjMxLC0wLjgxLDMuMTIsLTAuODcsMy4yMV0sW1wiY1wiLC0wLjAzLDAuMDYsLTAuMTIsMC4xNSwtMC4xOCwwLjIxXSxbXCJsXCIsLTAuMTIsMC4wNl0sW1wibFwiLC0wLjgxLDAuMDNdLFtcImNcIiwtMC42OSwwLC0wLjgxLDAsLTAuOSwtMC4wM10sW1wiY1wiLC0wLjA5LC0wLjA2LC0wLjE4LC0wLjIxLC0wLjE4LC0wLjNdLFtcImNcIiwwLC0wLjA2LDAuMzksLTEuNjIsMC45LC0zLjUxXSxbXCJjXCIsMC44NCwtMy4yNCwwLjg3LC0zLjQ1LDAuODcsLTMuNzJdLFtcImNcIiwwLC0wLjIxLDAsLTAuMjcsLTAuMDMsLTAuMzZdLFtcImNcIiwtMC4xMiwtMC4xNSwtMC4yMSwtMC4yNCwtMC40MiwtMC4yNF0sW1wiY1wiLC0wLjI0LDAsLTAuNDUsMC4xNSwtMC43OCwwLjQyXSxbXCJjXCIsLTAuMzMsMC4zNiwtMC40NSwwLjU0LC0wLjcyLDEuMTRdLFtcImNcIiwtMC4wMywwLjEyLC0wLjIxLDAuMjQsLTAuMzYsMC4yN10sW1wiY1wiLC0wLjEyLDAsLTAuMTUsMCwtMC4yNCwtMC4wNl0sW1wiY1wiLC0wLjE4LC0wLjEyLC0wLjE4LC0wLjIxLC0wLjA2LC0wLjU0XSxbXCJjXCIsMC4yMSwtMC41NywwLjQyLC0wLjkzLDAuNzgsLTEuMzJdLFtcImNcIiwwLjU0LC0wLjUxLDEuMiwtMC44MSwxLjk1LC0wLjg3XSxbXCJjXCIsMC44MSwtMC4wMywxLjUzLDAuMywxLjkyLDAuODddLFtcImxcIiwwLjEyLDAuMThdLFtcImxcIiwwLjA5LC0wLjA5XSxbXCJjXCIsMC41NywtMC40NSwxLjQxLC0wLjg0LDIuMTksLTAuOTZdLFtcInpcIl1dLHc6OS40MSxoOjkuMTMyfSxzOntkOltbXCJNXCIsNC40NywtOC43M10sW1wiY1wiLDAuMDksMCwwLjM2LC0wLjAzLDAuNTcsLTAuMDNdLFtcImNcIiwwLjc1LDAuMDMsMS4yOSwwLjI0LDEuNzEsMC42M10sW1wiY1wiLDAuNTEsMC41NCwwLjY2LDEuMjYsMC4zNiwxLjgzXSxbXCJjXCIsLTAuMjQsMC40MiwtMC42MywwLjU3LC0xLjExLDAuNDJdLFtcImNcIiwtMC4zMywtMC4wOSwtMC42LC0wLjM2LC0wLjYsLTAuNTddLFtcImNcIiwwLC0wLjAzLDAuMDYsLTAuMjEsMC4xNSwtMC4zOV0sW1wiY1wiLDAuMTIsLTAuMjEsMC4xNSwtMC4zMywwLjE4LC0wLjQ4XSxbXCJjXCIsMCwtMC4yNCwtMC4wNiwtMC40OCwtMC4xNSwtMC42XSxbXCJjXCIsLTAuMTUsLTAuMjEsLTAuNDIsLTAuMjQsLTAuNzUsLTAuMTVdLFtcImNcIiwtMC4yNywwLjA2LC0wLjQ4LDAuMTgsLTAuNjksMC4zNl0sW1wiY1wiLC0wLjM5LDAuMzksLTAuNTEsMC45NiwtMC4zMywxLjM4XSxbXCJjXCIsMC4wOSwwLjIxLDAuNDIsMC41MSwwLjc4LDAuNzJdLFtcImNcIiwxLjExLDAuNjksMS41OSwxLjExLDEuODksMS42OF0sW1wiY1wiLDAuMjEsMC4zOSwwLjI0LDAuNzgsMC4xNSwxLjI5XSxbXCJjXCIsLTAuMTgsMS4yLC0xLjE3LDIuMTYsLTIuNTIsMi41Ml0sW1wiY1wiLC0xLjAyLDAuMjQsLTEuOTUsMC4xMiwtMi43LC0wLjQyXSxbXCJjXCIsLTAuNzIsLTAuNTEsLTAuOTksLTEuNDcsLTAuNiwtMi4xOV0sW1wiY1wiLDAuMjQsLTAuNDgsMC43MiwtMC42MywxLjE3LC0wLjQyXSxbXCJjXCIsMC4zMywwLjE4LDAuNTQsMC40NSwwLjU3LDAuODFdLFtcImNcIiwwLDAuMjEsLTAuMDMsMC4zLC0wLjMzLDAuNTFdLFtcImNcIiwtMC4zMywwLjI0LC0wLjM5LDAuNDIsLTAuMjcsMC42OV0sW1wiY1wiLDAuMDYsMC4xNSwwLjIxLDAuMjcsMC40NSwwLjMzXSxbXCJjXCIsMC4zLDAuMDksMC44NywwLjA5LDEuMiwtMF0sW1wiY1wiLDAuNzUsLTAuMjEsMS4yMywtMC43MiwxLjI5LC0xLjM1XSxbXCJjXCIsMC4wMywtMC40MiwtMC4xNSwtMC44MSwtMC41NCwtMS4yXSxbXCJjXCIsLTAuMjQsLTAuMjQsLTAuNDgsLTAuNDIsLTEuNDEsLTEuMDJdLFtcImNcIiwtMC42OSwtMC40MiwtMS4wNSwtMC45MywtMS4wNSwtMS40N10sW1wiY1wiLDAsLTAuMzksMC4xMiwtMC44NywwLjMsLTEuMjNdLFtcImNcIiwwLjI3LC0wLjU3LDAuNzgsLTEuMDUsMS4zOCwtMS4zNV0sW1wiY1wiLDAuMjQsLTAuMTIsMC42MywtMC4yNywwLjksLTAuM10sW1wielwiXV0sdzo2LjYzMixoOjguNzU4fSx6OntkOltbXCJNXCIsMi42NCwtNy45NV0sW1wiY1wiLDAuMzYsLTAuMDksMC44MSwtMC4wMywxLjcxLDAuMjddLFtcImNcIiwwLjc4LDAuMjEsMC45NiwwLjI3LDEuNzQsMC4zXSxbXCJjXCIsMC44NywwLjA2LDEuMDIsMC4wMywxLjM4LC0wLjIxXSxbXCJjXCIsMC4yMSwtMC4xNSwwLjMzLC0wLjE1LDAuNDgsLTAuMDZdLFtcImNcIiwwLjE1LDAuMDksMC4yMSwwLjMsMC4xNSwwLjQ1XSxbXCJjXCIsLTAuMDMsMC4wNiwtMS4yNiwxLjI2LC0yLjc2LDIuNjddLFtcImxcIiwtMi43MywyLjU1XSxbXCJsXCIsMC41NCwwLjAzXSxbXCJjXCIsMC41NCwwLjAzLDAuNzIsMC4wMywyLjAxLDAuMTVdLFtcImNcIiwwLjM2LDAuMDMsMC45LDAuMDYsMS4yLDAuMDldLFtcImNcIiwwLjY2LDAsMC44MSwtMC4wMywxLjAyLC0wLjI0XSxbXCJjXCIsMC4zLC0wLjMsMC4zOSwtMC43MiwwLjI3LC0xLjIzXSxbXCJjXCIsLTAuMDYsLTAuMjcsLTAuMDYsLTAuMjcsLTAuMDMsLTAuMzldLFtcImNcIiwwLjE1LC0wLjMsMC41NCwtMC4yNywwLjY5LDAuMDNdLFtcImNcIiwwLjE1LDAuMzMsMC4yNywxLjAyLDAuMjcsMS41XSxbXCJjXCIsMCwxLjQ3LC0xLjExLDIuNywtMi41MiwyLjc5XSxbXCJjXCIsLTAuNTcsMC4wMywtMS4wMiwtMC4wOSwtMi4wMSwtMC41MV0sW1wiY1wiLC0xLjAyLC0wLjQyLC0xLjIzLC0wLjQ4LC0yLjEzLC0wLjU0XSxbXCJjXCIsLTAuODEsLTAuMDYsLTAuOTYsLTAuMDMsLTEuMjYsMC4xOF0sW1wiY1wiLC0wLjEyLDAuMDYsLTAuMjQsMC4xMiwtMC4yNywwLjEyXSxbXCJjXCIsLTAuMjcsMCwtMC40NSwtMC4zLC0wLjM2LC0wLjUxXSxbXCJjXCIsMC4wMywtMC4wNiwxLjMyLC0xLjMyLDIuOTEsLTIuNzldLFtcImxcIiwyLjg4LC0yLjczXSxbXCJjXCIsLTAuMDMsMCwtMC4yMSwwLjAzLC0wLjQyLDAuMDZdLFtcImNcIiwtMC4yMSwwLjAzLC0wLjc4LDAuMDksLTEuMjMsMC4xMl0sW1wiY1wiLC0xLjExLDAuMTIsLTEuMjMsMC4xNSwtMS45NSwwLjI3XSxbXCJjXCIsLTAuNzIsMC4xNSwtMS4xNywwLjE4LC0xLjI5LDAuMDldLFtcImNcIiwtMC4yNywtMC4xOCwtMC4yMSwtMC43NSwwLjEyLC0xLjI2XSxbXCJjXCIsMC4zOSwtMC42LDAuOTMsLTEuMDIsMS41OSwtMS4yXSxbXCJ6XCJdXSx3OjguNTczLGg6OC43NDN9LFwiK1wiOntkOltbXCJNXCIsMy40OCwtMTEuMTldLFtcImNcIiwwLjE4LC0wLjA5LDAuMzYsLTAuMDksMC41NCwwXSxbXCJjXCIsMC4xOCwwLjA5LDAuMjQsMC4xNSwwLjMzLDAuM10sW1wibFwiLDAuMDYsMC4xNV0sW1wibFwiLDAsMS4yOV0sW1wibFwiLDAsMS4yOV0sW1wibFwiLDEuMjksMF0sW1wiY1wiLDEuMjMsMCwxLjI5LDAsMS40MSwwLjA2XSxbXCJjXCIsMC4wNiwwLjAzLDAuMTUsMC4wOSwwLjE4LDAuMTJdLFtcImNcIiwwLjEyLDAuMDksMC4yMSwwLjMzLDAuMjEsMC40OF0sW1wiY1wiLDAsMC4xNSwtMC4wOSwwLjM5LC0wLjIxLDAuNDhdLFtcImNcIiwtMC4wMywwLjAzLC0wLjEyLDAuMDksLTAuMTgsMC4xMl0sW1wiY1wiLC0wLjEyLDAuMDYsLTAuMTgsMC4wNiwtMS40MSwwLjA2XSxbXCJsXCIsLTEuMjksMF0sW1wibFwiLDAsMS4yOV0sW1wiY1wiLDAsMS4yMywwLDEuMjksLTAuMDYsMS40MV0sW1wiY1wiLC0wLjA5LDAuMTgsLTAuMTUsMC4yNCwtMC4zLDAuMzNdLFtcImNcIiwtMC4yMSwwLjA5LC0wLjM5LDAuMDksLTAuNTcsMF0sW1wiY1wiLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbXCJjXCIsLTAuMDYsLTAuMTIsLTAuMDYsLTAuMTgsLTAuMDYsLTEuNDFdLFtcImxcIiwwLC0xLjI5XSxbXCJsXCIsLTEuMjksMF0sW1wiY1wiLC0xLjIzLDAsLTEuMjksMCwtMS40MSwtMC4wNl0sW1wiY1wiLC0wLjE4LC0wLjA5LC0wLjI0LC0wLjE1LC0wLjMzLC0wLjMzXSxbXCJjXCIsLTAuMDksLTAuMTgsLTAuMDksLTAuMzYsMCwtMC41NF0sW1wiY1wiLDAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzXSxbXCJsXCIsMC4xNSwtMC4wNl0sW1wibFwiLDEuMjYsMF0sW1wibFwiLDEuMjksMF0sW1wibFwiLDAsLTEuMjldLFtcImNcIiwwLC0xLjIzLDAsLTEuMjksMC4wNiwtMS40MV0sW1wiY1wiLDAuMDksLTAuMTgsMC4xNSwtMC4yNCwwLjMzLC0wLjMzXSxbXCJ6XCJdXSx3OjcuNTA3LGg6Ny41MTV9LFwiLFwiOntkOltbXCJNXCIsMS4zMiwtMy4zNl0sW1wiY1wiLDAuNTcsLTAuMTUsMS4xNywwLjAzLDEuNTksMC40NV0sW1wiY1wiLDAuNDUsMC40NSwwLjYsMC45NiwwLjUxLDEuODldLFtcImNcIiwtMC4wOSwxLjIzLC0wLjQyLDIuNDYsLTAuOTksMy45M10sW1wiY1wiLC0wLjMsMC43MiwtMC43MiwxLjYyLC0wLjc4LDEuNjhdLFtcImNcIiwtMC4xOCwwLjIxLC0wLjUxLDAuMTgsLTAuNjYsLTAuMDZdLFtcImNcIiwtMC4wMywtMC4wNiwtMC4wNiwtMC4xNSwtMC4wNiwtMC4xOF0sW1wiY1wiLDAsLTAuMDYsMC4xMiwtMC4zMywwLjI0LC0wLjYzXSxbXCJjXCIsMC44NCwtMS44LDEuMDIsLTIuNjEsMC42OSwtMy4yNF0sW1wiY1wiLC0wLjEyLC0wLjI0LC0wLjI3LC0wLjM2LC0wLjc1LC0wLjZdLFtcImNcIiwtMC4zNiwtMC4xNSwtMC40MiwtMC4yMSwtMC42LC0wLjM5XSxbXCJjXCIsLTAuNjksLTAuNjksLTAuNjksLTEuNzEsMCwtMi40XSxbXCJjXCIsMC4yMSwtMC4yMSwwLjUxLC0wLjM5LDAuODEsLTAuNDVdLFtcInpcIl1dLHc6My40NTIsaDo4LjE0M30sXCItXCI6e2Q6W1tcIk1cIiwwLjE4LC01LjM0XSxbXCJjXCIsMC4wOSwtMC4wNiwwLjE1LC0wLjA2LDIuMzEsLTAuMDZdLFtcImNcIiwyLjQ2LDAsMi4zNywwLDIuNDYsMC4yMV0sW1wiY1wiLDAuMTIsMC4yMSwwLjAzLDAuNDIsLTAuMTUsMC41NF0sW1wiY1wiLC0wLjA5LDAuMDYsLTAuMTUsMC4wNiwtMi4yOCwwLjA2XSxbXCJjXCIsLTIuMTYsMCwtMi4yMiwwLC0yLjMxLC0wLjA2XSxbXCJjXCIsLTAuMjcsLTAuMTUsLTAuMjcsLTAuNTQsLTAuMDMsLTAuNjldLFtcInpcIl1dLHc6NS4wMDEsaDowLjgxfSxcIi5cIjp7ZDpbW1wiTVwiLDEuMzIsLTMuMzZdLFtcImNcIiwxLjA1LC0wLjI3LDIuMSwwLjU3LDIuMSwxLjY1XSxbXCJjXCIsMCwxLjA4LC0xLjA1LDEuOTIsLTIuMSwxLjY1XSxbXCJjXCIsLTAuOSwtMC4yMSwtMS41LC0xLjE0LC0xLjI2LC0yLjA0XSxbXCJjXCIsMC4xMiwtMC42MywwLjYzLC0xLjExLDEuMjYsLTEuMjZdLFtcInpcIl1dLHc6My40MTMsaDozLjQwMn19O1xudGhpcy5wcmludFN5bWJvbD1mdW5jdGlvbihiLGcsYyxmKXtpZighYVtjXSl7cmV0dXJuIG51bGx9dmFyIGQ9dGhpcy5wYXRoQ2xvbmUoYVtjXS5kKTtkWzBdWzFdKz1iO2RbMF1bMl0rPWc7dmFyIGU9Zi5wYXRoKCkuYXR0cih7cGF0aDpkLHN0cm9rZTpcIm5vbmVcIixmaWxsOlwiIzAwMDAwMFwifSk7cmV0dXJuIGV9O3RoaXMuZ2V0UGF0aEZvclN5bWJvbD1mdW5jdGlvbihiLGcsZSxkLGMpe2Q9ZHx8MTtjPWN8fDE7aWYoIWFbZV0pe3JldHVybiBudWxsfXZhciBmPXRoaXMucGF0aENsb25lKGFbZV0uZCk7aWYoZCE9PTF8fGMhPT0xKXt0aGlzLnBhdGhTY2FsZShmLGQsYyl9ZlswXVsxXSs9YjtmWzBdWzJdKz1nO3JldHVybiBmfTt0aGlzLmdldFN5bWJvbFdpZHRoPWZ1bmN0aW9uKGIpe2lmKGFbYl0pe3JldHVybiBhW2JdLnd9cmV0dXJuIDB9O3RoaXMuZ2V0U3ltYm9sSGVpZ2h0PWZ1bmN0aW9uKGIpe2lmKGFbYl0pe3JldHVybiBhW2JdLmh9cmV0dXJuIDB9O3RoaXMuZ2V0U3ltYm9sQWxpZ249ZnVuY3Rpb24oYil7aWYoYi5zdWJzdHJpbmcoMCw3KT09PVwic2NyaXB0c1wiJiZiIT09XCJzY3JpcHRzLnJvbGxcIil7cmV0dXJuXCJjZW50ZXJcIn1yZXR1cm5cImxlZnRcIn07dGhpcy5wYXRoQ2xvbmU9ZnVuY3Rpb24oZyl7dmFyIGQ9W107Zm9yKHZhciBjPTAsZT1nLmxlbmd0aDtjPGU7YysrKXtkW2NdPVtdO2Zvcih2YXIgYj0wLGY9Z1tjXS5sZW5ndGg7YjxmO2IrKyl7ZFtjXVtiXT1nW2NdW2JdfX1yZXR1cm4gZH07dGhpcy5wYXRoU2NhbGU9ZnVuY3Rpb24oaCxmLGQpe2Zvcih2YXIgYz0wLGU9aC5sZW5ndGg7YzxlO2MrKyl7dmFyIGs9aFtjXTt2YXIgYixnO2ZvcihiPTEsZz1rLmxlbmd0aDtiPGc7YisrKXtrW2JdKj0oYiUyKT9mOmR9fX07dGhpcy5nZXRZQ29ycj1mdW5jdGlvbihiKXtzd2l0Y2goYil7Y2FzZVwiMFwiOmNhc2VcIjFcIjpjYXNlXCIyXCI6Y2FzZVwiM1wiOmNhc2VcIjRcIjpjYXNlXCI1XCI6Y2FzZVwiNlwiOmNhc2VcIjdcIjpjYXNlXCI4XCI6Y2FzZVwiOVwiOmNhc2VcIitcIjpyZXR1cm4gLTM7Y2FzZVwidGltZXNpZy5jb21tb25cIjpjYXNlXCJ0aW1lc2lnLmN1dFwiOnJldHVybiAtMTtjYXNlXCJmbGFncy5kMzJuZFwiOnJldHVybiAtMTtjYXNlXCJmbGFncy5kNjR0aFwiOnJldHVybiAtMjtjYXNlXCJmbGFncy51MzJuZFwiOnJldHVybiAxO2Nhc2VcImZsYWdzLnU2NHRoXCI6cmV0dXJuIDM7Y2FzZVwicmVzdHMud2hvbGVcIjpyZXR1cm4gMTtjYXNlXCJyZXN0cy5oYWxmXCI6cmV0dXJuIC0xO2Nhc2VcInJlc3RzLjh0aFwiOnJldHVybiAtMTtjYXNlXCJyZXN0cy5xdWFydGVyXCI6cmV0dXJuIC0yO2Nhc2VcInJlc3RzLjE2dGhcIjpyZXR1cm4gLTE7Y2FzZVwicmVzdHMuMzJuZFwiOnJldHVybiAtMTtjYXNlXCJyZXN0cy42NHRoXCI6cmV0dXJuIC0xO2RlZmF1bHQ6cmV0dXJuIDB9fX07aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMud3JpdGUpe3dpbmRvdy5BQkNKUy53cml0ZT17fX1BQkNKUy53cml0ZS5TdGFmZkdyb3VwRWxlbWVudD1mdW5jdGlvbigpe3RoaXMudm9pY2VzPVtdO3RoaXMuc3RhZmZzPVtdO3RoaXMuc3RhZmZsaW5lcz1bXX07QUJDSlMud3JpdGUuU3RhZmZHcm91cEVsZW1lbnQucHJvdG90eXBlLmFkZFZvaWNlPWZ1bmN0aW9uKGMsYixhKXt0aGlzLnZvaWNlc1t0aGlzLnZvaWNlcy5sZW5ndGhdPWM7aWYoIXRoaXMuc3RhZmZzW2JdKXt0aGlzLnN0YWZmc1t0aGlzLnN0YWZmcy5sZW5ndGhdPXt0b3A6MCxoaWdoZXN0OjcsbG93ZXN0Ojd9O3RoaXMuc3RhZmZsaW5lc1t0aGlzLnN0YWZmbGluZXMubGVuZ3RoXT1hfWMuc3RhZmY9dGhpcy5zdGFmZnNbYl19O0FCQ0pTLndyaXRlLlN0YWZmR3JvdXBFbGVtZW50LnByb3RvdHlwZS5maW5pc2hlZD1mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy52b2ljZXMubGVuZ3RoO2ErKyl7aWYoIXRoaXMudm9pY2VzW2FdLmxheW91dEVuZGVkKCkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O0FCQ0pTLndyaXRlLlN0YWZmR3JvdXBFbGVtZW50LnByb3RvdHlwZS5sYXlvdXQ9ZnVuY3Rpb24oZyxvLGEpe3RoaXMuc3BhY2luZ3VuaXRzPTA7dGhpcy5taW5zcGFjZT0xMDAwO3ZhciBsPW8ucGFkZGluZ2xlZnQqby5zY2FsZTt2YXIgYj0wO2Zvcih2YXIgZT0wO2U8dGhpcy52b2ljZXMubGVuZ3RoO2UrKyl7aWYodGhpcy52b2ljZXNbZV0uaGVhZGVyKXt2YXIgcD1vLnBhcGVyLnRleHQoMTAwKm8uc2NhbGUsLTEwKm8uc2NhbGUsdGhpcy52b2ljZXNbZV0uaGVhZGVyKS5hdHRyKHtcImZvbnQtc2l6ZVwiOjEyKm8uc2NhbGUsXCJmb250LWZhbWlseVwiOlwic2VyaWZcIixcImZvbnQtd2VpZ2h0XCI6XCJib2xkXCJ9KTtiPU1hdGgubWF4KGIscC5nZXRCQm94KCkud2lkdGgpO3AucmVtb3ZlKCl9fWw9bCtiKigxL28uc2NhbGUpKjEuMTt0aGlzLnN0YXJ0eD1sO3ZhciBkPTA7aWYoYSl7Y29uc29sZS5sb2coXCJpbml0IGxheW91dFwiKX1mb3IoZT0wO2U8dGhpcy52b2ljZXMubGVuZ3RoO2UrKyl7dGhpcy52b2ljZXNbZV0uYmVnaW5MYXlvdXQobCl9d2hpbGUoIXRoaXMuZmluaXNoZWQoKSl7ZD1udWxsO2ZvcihlPTA7ZTx0aGlzLnZvaWNlcy5sZW5ndGg7ZSsrKXtpZighdGhpcy52b2ljZXNbZV0ubGF5b3V0RW5kZWQoKSYmKCFkfHx0aGlzLnZvaWNlc1tlXS5nZXREdXJhdGlvbkluZGV4KCk8ZCkpe2Q9dGhpcy52b2ljZXNbZV0uZ2V0RHVyYXRpb25JbmRleCgpfX1pZihhKXtjb25zb2xlLmxvZyhcImN1cnJlbnRkdXJhdGlvbjogXCIsZCl9dmFyIG49W107dmFyIG09W107Zm9yKGU9MDtlPHRoaXMudm9pY2VzLmxlbmd0aDtlKyspe2lmKHRoaXMudm9pY2VzW2VdLmdldER1cmF0aW9uSW5kZXgoKSE9PWQpe20ucHVzaCh0aGlzLnZvaWNlc1tlXSl9ZWxzZXtuLnB1c2godGhpcy52b2ljZXNbZV0pO2lmKGEpe2NvbnNvbGUubG9nKFwiaW46IHZvaWNlIFwiLGUpfX19dmFyIGs9MDtmb3IoZT0wO2U8bi5sZW5ndGg7ZSsrKXtpZihuW2VdLm5leHR4Pmwpe2w9bltlXS5uZXh0eDtrPW5bZV0uc3BhY2luZ3VuaXRzfX10aGlzLnNwYWNpbmd1bml0cys9azt0aGlzLm1pbnNwYWNlPU1hdGgubWluKHRoaXMubWluc3BhY2Usayk7Zm9yKGU9MDtlPG0ubGVuZ3RoO2UrKyl7aWYobVtlXS5zcGFjaW5ndW5pdHMtPWspe319Zm9yKGU9MDtlPG4ubGVuZ3RoO2UrKyl7dmFyIGY9bltlXS5sYXlvdXRPbmVJdGVtKGwsZyk7dmFyIHE9Zi1sO2lmKHE+MCl7bD1mO2Zvcih2YXIgYz0wO2M8ZTtjKyspe25bY10uc2hpZnRSaWdodChxKX19fWZvcihlPTA7ZTxuLmxlbmd0aDtlKyspe3ZhciBoPW5bZV07aC51cGRhdGVJbmRpY2VzKCl9fWZvcihlPTA7ZTx0aGlzLnZvaWNlcy5sZW5ndGg7ZSsrKXtpZih0aGlzLnZvaWNlc1tlXS5uZXh0eD5sKXtsPXRoaXMudm9pY2VzW2VdLm5leHR4O2s9dGhpcy52b2ljZXNbZV0uc3BhY2luZ3VuaXRzfX10aGlzLnNwYWNpbmd1bml0cys9azt0aGlzLnc9bDtmb3IoZT0wO2U8dGhpcy52b2ljZXMubGVuZ3RoO2UrKyl7dGhpcy52b2ljZXNbZV0udz10aGlzLnd9fTtBQkNKUy53cml0ZS5TdGFmZkdyb3VwRWxlbWVudC5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihlLGgpe3RoaXMueT1oO2Zvcih2YXIgZD0wO2Q8dGhpcy5zdGFmZnMubGVuZ3RoO2QrKyl7dmFyIGM9dGhpcy5zdGFmZnNbZF0uaGlnaGVzdC0oKGQ9PT0wKT8yMDoxNSk7dmFyIGI9dGhpcy5zdGFmZnNbZF0ubG93ZXN0LSgoZD09PXRoaXMuc3RhZmZzLmxlbmd0aC0xKT8wOjApO3RoaXMuc3RhZmZzW2RdLnRvcD1oO2lmKGM+MCl7aCs9YypBQkNKUy53cml0ZS5zcGFjaW5nLlNURVB9dGhpcy5zdGFmZnNbZF0ueT1oO2grPUFCQ0pTLndyaXRlLnNwYWNpbmcuU1RBVkVIRUlHSFQqMC45O2lmKGI8MCl7aC09YipBQkNKUy53cml0ZS5zcGFjaW5nLlNURVB9dGhpcy5zdGFmZnNbZF0uYm90dG9tPWh9dGhpcy5oZWlnaHQ9aC10aGlzLnk7dmFyIGc9MDtmb3IoZD0wO2Q8dGhpcy52b2ljZXMubGVuZ3RoO2QrKyl7dGhpcy52b2ljZXNbZF0uZHJhdyhlLGcpO2c9dGhpcy52b2ljZXNbZF0uYmFyYm90dG9tfWlmKHRoaXMuc3RhZmZzLmxlbmd0aD4xKXtlLnk9dGhpcy5zdGFmZnNbMF0ueTt2YXIgZj1lLmNhbGNZKDEwKTtlLnk9dGhpcy5zdGFmZnNbdGhpcy5zdGFmZnMubGVuZ3RoLTFdLnk7dmFyIGE9ZS5jYWxjWSgyKTtlLnByaW50U3RlbSh0aGlzLnN0YXJ0eCwwLjYsZixhKX1mb3IoZD0wO2Q8dGhpcy5zdGFmZnMubGVuZ3RoO2QrKyl7aWYodGhpcy5zdGFmZmxpbmVzW2RdPT09MCl7Y29udGludWV9ZS55PXRoaXMuc3RhZmZzW2RdLnk7aWYodGhpcy5zdGFmZmxpbmVzW2RdPT09dW5kZWZpbmVkKXt0aGlzLnN0YWZmbGluZXNbZF09NX1lLnByaW50U3RhdmUodGhpcy5zdGFydHgsdGhpcy53LHRoaXMuc3RhZmZsaW5lc1tkXSl9fTtBQkNKUy53cml0ZS5Wb2ljZUVsZW1lbnQ9ZnVuY3Rpb24oYixhKXt0aGlzLmNoaWxkcmVuPVtdO3RoaXMuYmVhbXM9W107dGhpcy5vdGhlcmNoaWxkcmVuPVtdO3RoaXMudz0wO3RoaXMuZHVwbGljYXRlPWZhbHNlO3RoaXMudm9pY2VudW1iZXI9Yjt0aGlzLnZvaWNldG90YWw9YX07QUJDSlMud3JpdGUuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5hZGRDaGlsZD1mdW5jdGlvbihhKXt0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoXT1hfTtBQkNKUy53cml0ZS5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLmFkZE90aGVyPWZ1bmN0aW9uKGEpe2lmKGEgaW5zdGFuY2VvZiBBQkNKUy53cml0ZS5CZWFtRWxlbSl7dGhpcy5iZWFtcy5wdXNoKGEpfWVsc2V7dGhpcy5vdGhlcmNoaWxkcmVuLnB1c2goYSl9fTtBQkNKUy53cml0ZS5Wb2ljZUVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZUluZGljZXM9ZnVuY3Rpb24oKXtpZighdGhpcy5sYXlvdXRFbmRlZCgpKXt0aGlzLmR1cmF0aW9uaW5kZXgrPXRoaXMuY2hpbGRyZW5bdGhpcy5pXS5kdXJhdGlvbjtpZih0aGlzLmNoaWxkcmVuW3RoaXMuaV0uZHVyYXRpb249PT0wKXt0aGlzLmR1cmF0aW9uaW5kZXg9TWF0aC5yb3VuZCh0aGlzLmR1cmF0aW9uaW5kZXgqNjQpLzY0fXRoaXMuaSsrO3RoaXMubWlueD10aGlzLm5leHRtaW54fX07QUJDSlMud3JpdGUuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5sYXlvdXRFbmRlZD1mdW5jdGlvbigpe3JldHVybih0aGlzLmk+PXRoaXMuY2hpbGRyZW4ubGVuZ3RoKX07QUJDSlMud3JpdGUuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5nZXREdXJhdGlvbkluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHVyYXRpb25pbmRleC0odGhpcy5jaGlsZHJlblt0aGlzLmldJiYodGhpcy5jaGlsZHJlblt0aGlzLmldLmR1cmF0aW9uPjApPzA6NWUtNyl9O0FCQ0pTLndyaXRlLlZvaWNlRWxlbWVudC5wcm90b3R5cGUuYmVnaW5MYXlvdXQ9ZnVuY3Rpb24oYSl7dGhpcy5pPTA7dGhpcy5kdXJhdGlvbmluZGV4PTA7dGhpcy5paT10aGlzLmNoaWxkcmVuLmxlbmd0aDt0aGlzLnN0YXJ0eD1hO3RoaXMubWlueD1hO3RoaXMubmV4dG1pbng9YTt0aGlzLm5leHR4PWE7dGhpcy5zcGFjaW5ndW5pdHM9MH07QUJDSlMud3JpdGUuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5sYXlvdXRPbmVJdGVtPWZ1bmN0aW9uKGEsZCl7dmFyIGM9dGhpcy5jaGlsZHJlblt0aGlzLmldO2lmKCFjKXtyZXR1cm4gMH12YXIgYj1hLXRoaXMubWlueDtpZihiPGMuZ2V0RXh0cmFXaWR0aCgpKXthKz1jLmdldEV4dHJhV2lkdGgoKS1ifWMueD1hO2ErPShkKk1hdGguc3FydChjLmR1cmF0aW9uKjgpKTt0aGlzLm5leHRtaW54PWMueCtjLmdldE1pbldpZHRoKCk7aWYodGhpcy5pIT09dGhpcy5paS0xKXt0aGlzLm5leHRtaW54Kz1jLm1pbnNwYWNpbmd9aWYodGhpcy5uZXh0bWlueD5hKXthPXRoaXMubmV4dG1pbng7dGhpcy5zcGFjaW5ndW5pdHM9MH1lbHNle3RoaXMuc3BhY2luZ3VuaXRzPU1hdGguc3FydChjLmR1cmF0aW9uKjgpfXRoaXMubmV4dHg9YTt0aGlzLnN0YWZmLmhpZ2hlc3Q9TWF0aC5tYXgoYy50b3AsdGhpcy5zdGFmZi5oaWdoZXN0KTt0aGlzLnN0YWZmLmxvd2VzdD1NYXRoLm1pbihjLmJvdHRvbSx0aGlzLnN0YWZmLmxvd2VzdCk7cmV0dXJuIGMueH07QUJDSlMud3JpdGUuVm9pY2VFbGVtZW50LnByb3RvdHlwZS5zaGlmdFJpZ2h0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hpbGRyZW5bdGhpcy5pXTtpZighYil7cmV0dXJufWIueCs9YTt0aGlzLm5leHRtaW54Kz1hO3RoaXMubmV4dHgrPWF9O0FCQ0pTLndyaXRlLlZvaWNlRWxlbWVudC5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihmLGcpe3ZhciBkPXRoaXMudy0xO2YueT10aGlzLnN0YWZmLnk7Zi5zdGFmZmJvdHRvbT10aGlzLnN0YWZmLmJvdHRvbTt0aGlzLmJhcmJvdHRvbT1mLmNhbGNZKDIpO2lmKHRoaXMuaGVhZGVyKXt2YXIgZT0xMi0odGhpcy52b2ljZW51bWJlcisxKSooMTIvKHRoaXMudm9pY2V0b3RhbCsxKSk7dmFyIGE9KHRoaXMuc3RhcnR4LWYucGFkZGluZ2xlZnQpLzIrZi5wYWRkaW5nbGVmdDthPWEqZi5zY2FsZTtmLnBhcGVyLnRleHQoYSxmLmNhbGNZKGUpKmYuc2NhbGUsdGhpcy5oZWFkZXIpLmF0dHIoe1wiZm9udC1zaXplXCI6MTIqZi5zY2FsZSxcImZvbnQtZmFtaWx5XCI6XCJzZXJpZlwiLFwiZm9udC13ZWlnaHRcIjpcImJvbGRcIn0pfWZvcih2YXIgYj0wLGM9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YjxjO2IrKyl7dGhpcy5jaGlsZHJlbltiXS5kcmF3KGYsKHRoaXMuYmFydG98fGI9PT1jLTEpP2c6MCl9d2luZG93LkFCQ0pTLnBhcnNlLmVhY2godGhpcy5iZWFtcyxmdW5jdGlvbihoKXtoLmRyYXcoZil9KTt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaCh0aGlzLm90aGVyY2hpbGRyZW4sZnVuY3Rpb24oaCl7aC5kcmF3KGYsdGhpcy5zdGFydHgrMTAsZCl9KX07QUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50PWZ1bmN0aW9uKGMsYixhKXt0aGlzLmFiY2VsZW09Yzt0aGlzLmR1cmF0aW9uPWI7dGhpcy5taW5zcGFjaW5nPWF8fDA7dGhpcy54PTA7dGhpcy5jaGlsZHJlbj1bXTt0aGlzLmhlYWRzPVtdO3RoaXMuZXh0cmE9W107dGhpcy5leHRyYXc9MDt0aGlzLmRlY3M9W107dGhpcy53PTA7dGhpcy5yaWdodD1bXTt0aGlzLmludmlzaWJsZT1mYWxzZTt0aGlzLmJvdHRvbT03O3RoaXMudG9wPTd9O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuZ2V0TWluV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53XG59O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuZ2V0RXh0cmFXaWR0aD1mdW5jdGlvbigpe3JldHVybiAtdGhpcy5leHRyYXd9O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuYWRkRXh0cmE9ZnVuY3Rpb24oYSl7aWYoYS5keDx0aGlzLmV4dHJhdyl7dGhpcy5leHRyYXc9YS5keH10aGlzLmV4dHJhW3RoaXMuZXh0cmEubGVuZ3RoXT1hO3RoaXMuYWRkQ2hpbGQoYSl9O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuYWRkSGVhZD1mdW5jdGlvbihhKXtpZihhLmR4PHRoaXMuZXh0cmF3KXt0aGlzLmV4dHJhdz1hLmR4fXRoaXMuaGVhZHNbdGhpcy5oZWFkcy5sZW5ndGhdPWE7dGhpcy5hZGRSaWdodChhKX07QUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5hZGRSaWdodD1mdW5jdGlvbihhKXtpZihhLmR4K2Eudz50aGlzLncpe3RoaXMudz1hLmR4K2Eud310aGlzLnJpZ2h0W3RoaXMucmlnaHQubGVuZ3RoXT1hO3RoaXMuYWRkQ2hpbGQoYSl9O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuYWRkQ2hpbGQ9ZnVuY3Rpb24oYSl7YS5wYXJlbnQ9dGhpczt0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoXT1hO3RoaXMucHVzaFRvcChhLnRvcCk7dGhpcy5wdXNoQm90dG9tKGEuYm90dG9tKX07QUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5wdXNoVG9wPWZ1bmN0aW9uKGEpe3RoaXMudG9wPU1hdGgubWF4KGEsdGhpcy50b3ApfTtBQkNKUy53cml0ZS5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLnB1c2hCb3R0b209ZnVuY3Rpb24oYSl7dGhpcy5ib3R0b209TWF0aC5taW4oYSx0aGlzLmJvdHRvbSl9O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihlLGYpe3RoaXMuZWxlbXNldD1lLnBhcGVyLnNldCgpO2lmKHRoaXMuaW52aXNpYmxlKXtyZXR1cm59ZS5iZWdpbkdyb3VwKCk7Zm9yKHZhciBkPTA7ZDx0aGlzLmNoaWxkcmVuLmxlbmd0aDtkKyspe3RoaXMuZWxlbXNldC5wdXNoKHRoaXMuY2hpbGRyZW5bZF0uZHJhdyhlLHRoaXMueCxmKSl9dGhpcy5lbGVtc2V0LnB1c2goZS5lbmRHcm91cCgpKTtpZih0aGlzLmtsYXNzKXt0aGlzLnNldENsYXNzKFwibWFya1wiLFwiXCIsXCIjMDBmZjAwXCIpfXZhciBjPXRoaXM7dGhpcy5lbGVtc2V0Lm1vdXNldXAoZnVuY3Rpb24oaSl7ZS5ub3RpZnlTZWxlY3QoYyl9KTt0aGlzLmFiY2VsZW0uYWJzZWxlbT10aGlzO3ZhciBoPUFCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUCplLnNjYWxlO3ZhciBnPWZ1bmN0aW9uKCl7dGhpcy5keT0wfSxiPWZ1bmN0aW9uKGosaSl7aT1NYXRoLnJvdW5kKGkvaCkqaDt0aGlzLnRyYW5zbGF0ZSgwLC10aGlzLmR5KTt0aGlzLmR5PWk7dGhpcy50cmFuc2xhdGUoMCx0aGlzLmR5KX0sYT1mdW5jdGlvbigpe3ZhciBpPS1NYXRoLnJvdW5kKHRoaXMuZHkvaCk7Yy5hYmNlbGVtLnBpdGNoZXNbMF0ucGl0Y2grPWk7Yy5hYmNlbGVtLnBpdGNoZXNbMF0udmVydGljYWxQb3MrPWk7ZS5ub3RpZnlDaGFuZ2UoKX07aWYodGhpcy5hYmNlbGVtLmVsX3R5cGU9PT1cIm5vdGVcIiYmZS5lZGl0YWJsZSl7dGhpcy5lbGVtc2V0LmRyYWcoYixnLGEpfX07QUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS5pc0lFPVxuLypAY2Nfb24hQCovXG5mYWxzZTtBQkNKUy53cml0ZS5BYnNvbHV0ZUVsZW1lbnQucHJvdG90eXBlLnNldENsYXNzPWZ1bmN0aW9uKGQsZSxiKXt0aGlzLmVsZW1zZXQuYXR0cih7ZmlsbDpifSk7aWYoIXRoaXMuaXNJRSl7Zm9yKHZhciBjPTA7Yzx0aGlzLmVsZW1zZXQubGVuZ3RoO2MrKyl7aWYodGhpcy5lbGVtc2V0W2NdWzBdLnNldEF0dHJpYnV0ZSl7dmFyIGE9dGhpcy5lbGVtc2V0W2NdWzBdLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO2lmKCFhKXthPVwiXCJ9YT1hLnJlcGxhY2UoZSxcIlwiKTthPWEucmVwbGFjZShkLFwiXCIpO2lmKGQubGVuZ3RoPjApe2lmKGEubGVuZ3RoPjAmJmEuY2hhckF0KGEubGVuZ3RoLTEpIT09XCIgXCIpe2ErPVwiIFwifWErPWR9dGhpcy5lbGVtc2V0W2NdWzBdLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYSl9fX19O0FCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudC5wcm90b3R5cGUuaGlnaGxpZ2h0PWZ1bmN0aW9uKCl7dGhpcy5zZXRDbGFzcyhcIm5vdGVfc2VsZWN0ZWRcIixcIlwiLFwiI2ZmMDAwMFwiKX07QUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50LnByb3RvdHlwZS51bmhpZ2hsaWdodD1mdW5jdGlvbigpe3RoaXMuc2V0Q2xhc3MoXCJcIixcIm5vdGVfc2VsZWN0ZWRcIixcIiMwMDAwMDBcIil9O0FCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudD1mdW5jdGlvbihmLGIsYSxlLGQpe2Q9ZHx8e307dGhpcy54PTA7dGhpcy5jPWY7dGhpcy5keD1iO3RoaXMudz1hO3RoaXMucGl0Y2g9ZTt0aGlzLnNjYWxleD1kLnNjYWxleHx8MTt0aGlzLnNjYWxleT1kLnNjYWxleXx8MTt0aGlzLnR5cGU9ZC50eXBlfHxcInN5bWJvbFwiO3RoaXMucGl0Y2gyPWQucGl0Y2gyO3RoaXMubGluZXdpZHRoPWQubGluZXdpZHRoO3RoaXMuYXR0cmlidXRlcz1kLmF0dHJpYnV0ZXM7dGhpcy50b3A9ZSsoKGQuZXh0cmVtZT09PVwiYWJvdmVcIik/NzowKTt0aGlzLmJvdHRvbT1lLSgoZC5leHRyZW1lPT09XCJiZWxvd1wiKT83OjApfTtBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQucHJvdG90eXBlLmRyYXc9ZnVuY3Rpb24oYixhLGMpe3RoaXMueD1hK3RoaXMuZHg7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZVwic3ltYm9sXCI6aWYodGhpcy5jPT09bnVsbCl7cmV0dXJuIG51bGx9dGhpcy5ncmFwaGVsZW09Yi5wcmludFN5bWJvbCh0aGlzLngsdGhpcy5waXRjaCx0aGlzLmMsdGhpcy5zY2FsZXgsdGhpcy5zY2FsZXkpO2JyZWFrO2Nhc2VcImRlYnVnXCI6dGhpcy5ncmFwaGVsZW09Yi5kZWJ1Z01zZyh0aGlzLngsdGhpcy5jKTticmVhaztjYXNlXCJkZWJ1Z0xvd1wiOnRoaXMuZ3JhcGhlbGVtPWIucHJpbnRMeXJpY3ModGhpcy54LHRoaXMuYyk7YnJlYWs7Y2FzZVwidGV4dFwiOnRoaXMuZ3JhcGhlbGVtPWIucHJpbnRUZXh0KHRoaXMueCx0aGlzLnBpdGNoLHRoaXMuYyk7YnJlYWs7Y2FzZVwiYmFyXCI6dGhpcy5ncmFwaGVsZW09Yi5wcmludFN0ZW0odGhpcy54LHRoaXMubGluZXdpZHRoLGIuY2FsY1kodGhpcy5waXRjaCksKGMpP2M6Yi5jYWxjWSh0aGlzLnBpdGNoMikpO2JyZWFrO2Nhc2VcInN0ZW1cIjp0aGlzLmdyYXBoZWxlbT1iLnByaW50U3RlbSh0aGlzLngsdGhpcy5saW5ld2lkdGgsYi5jYWxjWSh0aGlzLnBpdGNoKSxiLmNhbGNZKHRoaXMucGl0Y2gyKSk7YnJlYWs7Y2FzZVwibGVkZ2VyXCI6dGhpcy5ncmFwaGVsZW09Yi5wcmludFN0YXZlTGluZSh0aGlzLngsdGhpcy54K3RoaXMudyx0aGlzLnBpdGNoKTticmVha31pZih0aGlzLnNjYWxleCE9PTEmJnRoaXMuZ3JhcGhlbGVtKXt0aGlzLmdyYXBoZWxlbS5zY2FsZSh0aGlzLnNjYWxleCx0aGlzLnNjYWxleSx0aGlzLngsYi5jYWxjWSh0aGlzLnBpdGNoKSl9aWYodGhpcy5hdHRyaWJ1dGVzKXt0aGlzLmdyYXBoZWxlbS5hdHRyKHRoaXMuYXR0cmlidXRlcyl9cmV0dXJuIHRoaXMuZ3JhcGhlbGVtfTtBQkNKUy53cml0ZS5FbmRpbmdFbGVtPWZ1bmN0aW9uKGMsYixhKXt0aGlzLnRleHQ9Yzt0aGlzLmFuY2hvcjE9Yjt0aGlzLmFuY2hvcjI9YX07QUJDSlMud3JpdGUuRW5kaW5nRWxlbS5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihjLGQsYil7dmFyIGE7aWYodGhpcy5hbmNob3IxKXtkPXRoaXMuYW5jaG9yMS54K3RoaXMuYW5jaG9yMS53O2E9QUJDSlMud3JpdGUuc3ByaW50ZihcIk0gJWYgJWYgTCAlZiAlZlwiLGQsYy55LGQsYy55KzEwKTtjLnByaW50UGF0aCh7cGF0aDphLHN0cm9rZTpcIiMwMDAwMDBcIixmaWxsOlwiIzAwMDAwMFwifSk7Yy5wcmludFRleHQoZCs1KmMuc2NhbGUsMTguNSx0aGlzLnRleHQpLmF0dHIoe1wiZm9udC1zaXplXCI6XCJcIisxMCpjLnNjYWxlK1wicHhcIn0pfWlmKHRoaXMuYW5jaG9yMil7Yj10aGlzLmFuY2hvcjIueDthPUFCQ0pTLndyaXRlLnNwcmludGYoXCJNICVmICVmIEwgJWYgJWZcIixiLGMueSxiLGMueSsxMCk7Yy5wcmludFBhdGgoe3BhdGg6YSxzdHJva2U6XCIjMDAwMDAwXCIsZmlsbDpcIiMwMDAwMDBcIn0pfWE9QUJDSlMud3JpdGUuc3ByaW50ZihcIk0gJWYgJWYgTCAlZiAlZlwiLGQsYy55LGIsYy55KTtjLnByaW50UGF0aCh7cGF0aDphLHN0cm9rZTpcIiMwMDAwMDBcIixmaWxsOlwiIzAwMDAwMFwifSl9O0FCQ0pTLndyaXRlLlRpZUVsZW09ZnVuY3Rpb24oZCxiLGEsYyl7dGhpcy5hbmNob3IxPWQ7dGhpcy5hbmNob3IyPWI7dGhpcy5hYm92ZT1hO3RoaXMuZm9yY2U9Y307QUJDSlMud3JpdGUuVGllRWxlbS5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihjLGUsYSl7dmFyIGQ7dmFyIGI7aWYodGhpcy5zdGFydGxpbWl0ZWxlbSl7ZT10aGlzLnN0YXJ0bGltaXRlbGVtLngrdGhpcy5zdGFydGxpbWl0ZWxlbS53fWlmKHRoaXMuZW5kbGltaXRlbGVtKXthPXRoaXMuZW5kbGltaXRlbGVtLnh9aWYoIXRoaXMuZm9yY2UmJnRoaXMuYW5jaG9yMiYmdGhpcy5hbmNob3IyLnBpdGNoPT09dGhpcy5hbmNob3IyLnRvcCl7dGhpcy5hYm92ZT10cnVlfWlmKHRoaXMuYW5jaG9yMSl7ZT10aGlzLmFuY2hvcjEueDtkPXRoaXMuYWJvdmU/dGhpcy5hbmNob3IxLmhpZ2hlc3RWZXJ0OnRoaXMuYW5jaG9yMS5waXRjaDtpZighdGhpcy5hbmNob3IyKXtiPXRoaXMuYWJvdmU/dGhpcy5hbmNob3IxLmhpZ2hlc3RWZXJ0OnRoaXMuYW5jaG9yMS5waXRjaH19aWYodGhpcy5hbmNob3IyKXthPXRoaXMuYW5jaG9yMi54O2I9dGhpcy5hYm92ZT90aGlzLmFuY2hvcjIuaGlnaGVzdFZlcnQ6dGhpcy5hbmNob3IyLnBpdGNoO2lmKCF0aGlzLmFuY2hvcjEpe2Q9dGhpcy5hYm92ZT90aGlzLmFuY2hvcjIuaGlnaGVzdFZlcnQ6dGhpcy5hbmNob3IyLnBpdGNofX1jLmRyYXdBcmMoZSxhLGQsYix0aGlzLmFib3ZlKX07QUJDSlMud3JpdGUuRHluYW1pY0RlY29yYXRpb249ZnVuY3Rpb24oYSxiKXt0aGlzLmFuY2hvcj1hO3RoaXMuZGVjPWJ9O0FCQ0pTLndyaXRlLkR5bmFtaWNEZWNvcmF0aW9uLnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKGQsZixhKXt2YXIgZT1kLmxheW91dGVyLm1pblktNzt2YXIgYz0xO3ZhciBiPTE7ZC5wcmludFN5bWJvbCh0aGlzLmFuY2hvci54LGUsdGhpcy5kZWMsYyxiKX07QUJDSlMud3JpdGUuQ3Jlc2NlbmRvRWxlbT1mdW5jdGlvbihjLGIsYSl7dGhpcy5hbmNob3IxPWM7dGhpcy5hbmNob3IyPWI7dGhpcy5kaXI9YX07QUJDSlMud3JpdGUuQ3Jlc2NlbmRvRWxlbS5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihiLGMsYSl7aWYodGhpcy5kaXI9PT1cIjxcIil7dGhpcy5kcmF3TGluZShiLDAsLTQpO3RoaXMuZHJhd0xpbmUoYiwwLDQpfWVsc2V7dGhpcy5kcmF3TGluZShiLC00LDApO3RoaXMuZHJhd0xpbmUoYiw0LDApfX07QUJDSlMud3JpdGUuQ3Jlc2NlbmRvRWxlbS5wcm90b3R5cGUuZHJhd0xpbmU9ZnVuY3Rpb24oZCxjLGIpe3ZhciBlPWQubGF5b3V0ZXIubWluWS03O3ZhciBhPUFCQ0pTLndyaXRlLnNwcmludGYoXCJNICVmICVmIEwgJWYgJWZcIix0aGlzLmFuY2hvcjEueCxkLmNhbGNZKGUpK2MtNCx0aGlzLmFuY2hvcjIueCxkLmNhbGNZKGUpK2ItNCk7ZC5wcmludFBhdGgoe3BhdGg6YSxzdHJva2U6XCIjMDAwMDAwXCJ9KX07QUJDSlMud3JpdGUuVHJpcGxldEVsZW09ZnVuY3Rpb24oZCxjLGIsYSl7dGhpcy5hbmNob3IxPWM7dGhpcy5hbmNob3IyPWI7dGhpcy5hYm92ZT1hO3RoaXMubnVtYmVyPWR9O0FCQ0pTLndyaXRlLlRyaXBsZXRFbGVtLnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKGQsZyxjKXtpZih0aGlzLmFuY2hvcjEmJnRoaXMuYW5jaG9yMil7dmFyIGY9dGhpcy5hYm92ZT8xNjotMTtpZih0aGlzLmFuY2hvcjEucGFyZW50LmJlYW0mJnRoaXMuYW5jaG9yMS5wYXJlbnQuYmVhbT09PXRoaXMuYW5jaG9yMi5wYXJlbnQuYmVhbSl7dmFyIGI9dGhpcy5hbmNob3IxLnBhcmVudC5iZWFtO3RoaXMuYWJvdmU9Yi5hc2M7Zj1iLnBvc31lbHNle3RoaXMuZHJhd0xpbmUoZCxkLmNhbGNZKGYpKX12YXIgZT10aGlzLmFuY2hvcjEueCt0aGlzLmFuY2hvcjIueDt2YXIgYT0wO2lmKGIpe2lmKHRoaXMuYWJvdmUpe2UrPSh0aGlzLmFuY2hvcjIudyt0aGlzLmFuY2hvcjEudyk7YT00fWVsc2V7YT0tNH19ZWxzZXtlKz10aGlzLmFuY2hvcjIud31kLnByaW50VGV4dChlLzIsZithLHRoaXMubnVtYmVyLFwibWlkZGxlXCIpLmF0dHIoe1wiZm9udC1zaXplXCI6XCIxMHB4XCIsXCJmb250LXN0eWxlXCI6XCJpdGFsaWNcIn0pfX07QUJDSlMud3JpdGUuVHJpcGxldEVsZW0ucHJvdG90eXBlLmRyYXdMaW5lPWZ1bmN0aW9uKGMsZSl7dmFyIGI7dmFyIGQ9dGhpcy5hbmNob3IxLng7Yj1BQkNKUy53cml0ZS5zcHJpbnRmKFwiTSAlZiAlZiBMICVmICVmXCIsZCxlLGQsZSs1KTtjLnByaW50UGF0aCh7cGF0aDpiLHN0cm9rZTpcIiMwMDAwMDBcIn0pO3ZhciBhPXRoaXMuYW5jaG9yMi54K3RoaXMuYW5jaG9yMi53O2I9QUJDSlMud3JpdGUuc3ByaW50ZihcIk0gJWYgJWYgTCAlZiAlZlwiLGEsZSxhLGUrNSk7Yy5wcmludFBhdGgoe3BhdGg6YixzdHJva2U6XCIjMDAwMDAwXCJ9KTtiPUFCQ0pTLndyaXRlLnNwcmludGYoXCJNICVmICVmIEwgJWYgJWZcIixkLGUsKGQrYSkvMi01LGUpO2MucHJpbnRQYXRoKHtwYXRoOmIsc3Ryb2tlOlwiIzAwMDAwMFwifSk7Yj1BQkNKUy53cml0ZS5zcHJpbnRmKFwiTSAlZiAlZiBMICVmICVmXCIsKGQrYSkvMis1LGUsYSxlKTtjLnByaW50UGF0aCh7cGF0aDpiLHN0cm9rZTpcIiMwMDAwMDBcIn0pfTtBQkNKUy53cml0ZS5CZWFtRWxlbT1mdW5jdGlvbihhLGIpe3RoaXMuaXNmbGF0PShiKTt0aGlzLmlzZ3JhY2U9KGEmJmE9PT1cImdyYWNlXCIpO3RoaXMuZm9yY2V1cD0oYSYmYT09PVwidXBcIik7dGhpcy5mb3JjZWRvd249KGEmJmE9PT1cImRvd25cIik7dGhpcy5lbGVtcz1bXTt0aGlzLnRvdGFsPTA7dGhpcy5keT0odGhpcy5hc2MpP0FCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUCoxLjI6LUFCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUCoxLjI7aWYodGhpcy5pc2dyYWNlKXt0aGlzLmR5PXRoaXMuZHkqMC40fXRoaXMuYWxscmVzdHM9dHJ1ZX07QUJDSlMud3JpdGUuQmVhbUVsZW0ucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXt2YXIgYj1hLmFiY2VsZW0uYXZlcmFnZXBpdGNoO1xuaWYoYj09PXVuZGVmaW5lZCl7cmV0dXJufXRoaXMuYWxscmVzdHM9dGhpcy5hbGxyZXN0cyYmYS5hYmNlbGVtLnJlc3Q7YS5iZWFtPXRoaXM7dGhpcy5lbGVtcy5wdXNoKGEpO3RoaXMudG90YWwrPWI7aWYoIXRoaXMubWlufHxhLmFiY2VsZW0ubWlucGl0Y2g8dGhpcy5taW4pe3RoaXMubWluPWEuYWJjZWxlbS5taW5waXRjaH1pZighdGhpcy5tYXh8fGEuYWJjZWxlbS5tYXhwaXRjaD50aGlzLm1heCl7dGhpcy5tYXg9YS5hYmNlbGVtLm1heHBpdGNofX07QUJDSlMud3JpdGUuQmVhbUVsZW0ucHJvdG90eXBlLmF2ZXJhZ2U9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHRoaXMudG90YWwvdGhpcy5lbGVtcy5sZW5ndGh9Y2F0Y2goYSl7cmV0dXJuIDB9fTtBQkNKUy53cml0ZS5CZWFtRWxlbS5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihhKXtpZih0aGlzLmVsZW1zLmxlbmd0aD09PTB8fHRoaXMuYWxscmVzdHMpe3JldHVybn10aGlzLmRyYXdCZWFtKGEpO3RoaXMuZHJhd1N0ZW1zKGEpfTtBQkNKUy53cml0ZS5CZWFtRWxlbS5wcm90b3R5cGUuY2FsY0Rpcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYXZlcmFnZSgpO3RoaXMuYXNjPSh0aGlzLmZvcmNldXB8fHRoaXMuaXNncmFjZXx8YTw2KSYmKCF0aGlzLmZvcmNlZG93bik7cmV0dXJuIHRoaXMuYXNjfTtBQkNKUy53cml0ZS5CZWFtRWxlbS5wcm90b3R5cGUuZHJhd0JlYW09ZnVuY3Rpb24oaSl7dmFyIGI9dGhpcy5hdmVyYWdlKCk7dmFyIGg9KHRoaXMuaXNncmFjZSk/NTo3O3RoaXMuY2FsY0RpcigpO3ZhciBhPXRoaXMuYXNjPzU6ODt0aGlzLnBvcz1NYXRoLnJvdW5kKHRoaXMuYXNjP01hdGgubWF4KGIraCx0aGlzLm1heCthKTpNYXRoLm1pbihiLWgsdGhpcy5taW4tYSkpO3ZhciBmPXRoaXMuZWxlbXNbMF0uYWJjZWxlbS5hdmVyYWdlcGl0Y2gtdGhpcy5lbGVtc1t0aGlzLmVsZW1zLmxlbmd0aC0xXS5hYmNlbGVtLmF2ZXJhZ2VwaXRjaDtpZih0aGlzLmlzZmxhdCl7Zj0wfXZhciBlPXRoaXMuZWxlbXMubGVuZ3RoLzI7aWYoZj5lKXtmPWV9aWYoZjwtZSl7Zj0tZX10aGlzLnN0YXJ0eT1pLmNhbGNZKHRoaXMucG9zK01hdGguZmxvb3IoZi8yKSk7dGhpcy5lbmR5PWkuY2FsY1kodGhpcy5wb3MrTWF0aC5mbG9vcigtZi8yKSk7dmFyIGQ9dGhpcy5lbGVtc1swXS5oZWFkc1sodGhpcy5hc2MpPzA6dGhpcy5lbGVtc1swXS5oZWFkcy5sZW5ndGgtMV07dmFyIGc9dGhpcy5lbGVtc1t0aGlzLmVsZW1zLmxlbmd0aC0xXS5oZWFkc1sodGhpcy5hc2MpPzA6dGhpcy5lbGVtc1t0aGlzLmVsZW1zLmxlbmd0aC0xXS5oZWFkcy5sZW5ndGgtMV07dGhpcy5zdGFydHg9ZC54O2lmKHRoaXMuYXNjKXt0aGlzLnN0YXJ0eCs9ZC53LTAuNn10aGlzLmVuZHg9Zy54O2lmKHRoaXMuYXNjKXt0aGlzLmVuZHgrPWcud31pZih0aGlzLmFzYyYmdGhpcy5wb3M8Nil7dGhpcy5zdGFydHk9aS5jYWxjWSg2KTt0aGlzLmVuZHk9aS5jYWxjWSg2KX1lbHNle2lmKCF0aGlzLmFzYyYmdGhpcy5wb3M+Nil7dGhpcy5zdGFydHk9aS5jYWxjWSg2KTt0aGlzLmVuZHk9aS5jYWxjWSg2KX19dmFyIGM9XCJNXCIrdGhpcy5zdGFydHgrXCIgXCIrdGhpcy5zdGFydHkrXCIgTFwiK3RoaXMuZW5keCtcIiBcIit0aGlzLmVuZHkrXCJMXCIrdGhpcy5lbmR4K1wiIFwiKyh0aGlzLmVuZHkrdGhpcy5keSkrXCIgTFwiK3RoaXMuc3RhcnR4K1wiIFwiKyh0aGlzLnN0YXJ0eSt0aGlzLmR5KStcInpcIjtpLnByaW50UGF0aCh7cGF0aDpjLHN0cm9rZTpcIm5vbmVcIixmaWxsOlwiIzAwMDAwMFwifSl9O0FCQ0pTLndyaXRlLkJlYW1FbGVtLnByb3RvdHlwZS5kcmF3U3RlbXM9ZnVuY3Rpb24ocil7dmFyIGE9W107ci5iZWdpbkdyb3VwKCk7Zm9yKHZhciBnPTAscT10aGlzLmVsZW1zLmxlbmd0aDtnPHE7ZysrKXtpZih0aGlzLmVsZW1zW2ddLmFiY2VsZW0ucmVzdCl7Y29udGludWV9dmFyIG09dGhpcy5lbGVtc1tnXS5oZWFkc1sodGhpcy5hc2MpPzA6dGhpcy5lbGVtc1tnXS5oZWFkcy5sZW5ndGgtMV07dmFyIGU9KHRoaXMuaXNncmFjZSk/MS8zOjEvNTt2YXIgYj1tLnBpdGNoKygodGhpcy5hc2MpP2U6LWUpO3ZhciBvPXIuY2FsY1koYik7dmFyIHA9bS54KygodGhpcy5hc2MpP20udzowKTt2YXIgbD10aGlzLmdldEJhcllBdChwKTt2YXIgcz0odGhpcy5hc2MpPy0wLjY6MC42O3IucHJpbnRTdGVtKHAscyxvLGwpO3ZhciBuPSh0aGlzLmFzYyk/MS41KkFCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUDotMS41KkFCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUDtpZih0aGlzLmlzZ3JhY2Upe249bioyLzN9Zm9yKHZhciBjPUFCQ0pTLndyaXRlLmdldER1cmxvZyh0aGlzLmVsZW1zW2ddLmFiY2VsZW0uZHVyYXRpb24pO2M8LTM7YysrKXtpZihhWy00LWNdKXthWy00LWNdLnNpbmdsZT1mYWxzZX1lbHNle2FbLTQtY109e3g6cCsoKHRoaXMuYXNjKT8tMC42OjApLHk6bCtuKigtNC1jKzEpLGR1cmxvZzpjLHNpbmdsZTp0cnVlfX19Zm9yKHZhciBmPWEubGVuZ3RoLTE7Zj49MDtmLS0pe2lmKGc9PT1xLTF8fEFCQ0pTLndyaXRlLmdldER1cmxvZyh0aGlzLmVsZW1zW2crMV0uYWJjZWxlbS5kdXJhdGlvbik+KC1mLTQpKXt2YXIgaz1wO3ZhciBoPWwrbiooZisxKTtpZihhW2ZdLnNpbmdsZSl7az0oZz09PTApP3ArNTpwLTU7aD10aGlzLmdldEJhcllBdChrKStuKihmKzEpfXZhciBkPVwiTVwiK2FbZl0ueCtcIiBcIithW2ZdLnkrXCIgTFwiK2srXCIgXCIraCtcIkxcIitrK1wiIFwiKyhoK3RoaXMuZHkpK1wiIExcIithW2ZdLngrXCIgXCIrKGFbZl0ueSt0aGlzLmR5KStcInpcIjtyLnByaW50UGF0aCh7cGF0aDpkLHN0cm9rZTpcIm5vbmVcIixmaWxsOlwiIzAwMDAwMFwifSk7YT1hLnNsaWNlKDAsZil9fX1yLmVuZEdyb3VwKCl9O0FCQ0pTLndyaXRlLkJlYW1FbGVtLnByb3RvdHlwZS5nZXRCYXJZQXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuc3RhcnR5Kyh0aGlzLmVuZHktdGhpcy5zdGFydHkpLyh0aGlzLmVuZHgtdGhpcy5zdGFydHgpKihhLXRoaXMuc3RhcnR4KX07aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMud3JpdGUpe3dpbmRvdy5BQkNKUy53cml0ZT17fX1BQkNKUy53cml0ZS5nZXREdXJhdGlvbj1mdW5jdGlvbihhKXt2YXIgYj0wO2lmKGEuZHVyYXRpb24pe2I9YS5kdXJhdGlvbn1yZXR1cm4gYn07QUJDSlMud3JpdGUuZ2V0RHVybG9nPWZ1bmN0aW9uKGEpe2lmKGE9PT11bmRlZmluZWQpe3JldHVybiAwfXJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGgubG9nKDIpKX07QUJDSlMud3JpdGUuTGF5b3V0PWZ1bmN0aW9uKGIsYSl7dGhpcy5nbHlwaHM9Yjt0aGlzLmlzQmFncGlwZXM9YTt0aGlzLmNoYXJ0YWJsZT17cmVzdDp7MDpcInJlc3RzLndob2xlXCIsMTpcInJlc3RzLmhhbGZcIiwyOlwicmVzdHMucXVhcnRlclwiLDM6XCJyZXN0cy44dGhcIiw0OlwicmVzdHMuMTZ0aFwiLDU6XCJyZXN0cy4zMm5kXCIsNjpcInJlc3RzLjY0dGhcIiw3OlwicmVzdHMuMTI4dGhcIn0sbm90ZTp7XCItMVwiOlwibm90ZWhlYWRzLmRibFwiLDA6XCJub3RlaGVhZHMud2hvbGVcIiwxOlwibm90ZWhlYWRzLmhhbGZcIiwyOlwibm90ZWhlYWRzLnF1YXJ0ZXJcIiwzOlwibm90ZWhlYWRzLnF1YXJ0ZXJcIiw0Olwibm90ZWhlYWRzLnF1YXJ0ZXJcIiw1Olwibm90ZWhlYWRzLnF1YXJ0ZXJcIiw2Olwibm90ZWhlYWRzLnF1YXJ0ZXJcIn0sdWZsYWdzOnszOlwiZmxhZ3MudTh0aFwiLDQ6XCJmbGFncy51MTZ0aFwiLDU6XCJmbGFncy51MzJuZFwiLDY6XCJmbGFncy51NjR0aFwifSxkZmxhZ3M6ezM6XCJmbGFncy5kOHRoXCIsNDpcImZsYWdzLmQxNnRoXCIsNTpcImZsYWdzLmQzMm5kXCIsNjpcImZsYWdzLmQ2NHRoXCJ9fTt0aGlzLnNsdXJzPXt9O3RoaXMudGllcz1bXTt0aGlzLnNsdXJzYnl2b2ljZT17fTt0aGlzLnRpZXNieXZvaWNlPXt9O3RoaXMuZW5kaW5nc2J5dm9pY2U9e307dGhpcy5zPTA7dGhpcy52PTA7dGhpcy5zdGFmZmxpbmVzPTU7dGhpcy50cmlwbGV0bXVsdGlwbGllcj0xfTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLmdldEN1cnJlbnRWb2ljZUlkPWZ1bmN0aW9uKCl7cmV0dXJuXCJzXCIrdGhpcy5zK1widlwiK3RoaXMudn07QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5wdXNoQ3Jvc3NMaW5lRWxlbXM9ZnVuY3Rpb24oKXt0aGlzLnNsdXJzYnl2b2ljZVt0aGlzLmdldEN1cnJlbnRWb2ljZUlkKCldPXRoaXMuc2x1cnM7dGhpcy50aWVzYnl2b2ljZVt0aGlzLmdldEN1cnJlbnRWb2ljZUlkKCldPXRoaXMudGllczt0aGlzLmVuZGluZ3NieXZvaWNlW3RoaXMuZ2V0Q3VycmVudFZvaWNlSWQoKV09dGhpcy5wYXJ0c3RhcnRlbGVtfTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLnBvcENyb3NzTGluZUVsZW1zPWZ1bmN0aW9uKCl7dGhpcy5zbHVycz10aGlzLnNsdXJzYnl2b2ljZVt0aGlzLmdldEN1cnJlbnRWb2ljZUlkKCldfHx7fTt0aGlzLnRpZXM9dGhpcy50aWVzYnl2b2ljZVt0aGlzLmdldEN1cnJlbnRWb2ljZUlkKCldfHxbXTt0aGlzLnBhcnRzdGFydGVsZW09dGhpcy5lbmRpbmdzYnl2b2ljZVt0aGlzLmdldEN1cnJlbnRWb2ljZUlkKCldfTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLmdldEVsZW09ZnVuY3Rpb24oKXtpZih0aGlzLmFiY2xpbmUubGVuZ3RoPD10aGlzLnBvcyl7cmV0dXJuIG51bGx9cmV0dXJuIHRoaXMuYWJjbGluZVt0aGlzLnBvc119O0FCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUuZ2V0TmV4dEVsZW09ZnVuY3Rpb24oKXtpZih0aGlzLmFiY2xpbmUubGVuZ3RoPD10aGlzLnBvcysxKXtyZXR1cm4gbnVsbH1yZXR1cm4gdGhpcy5hYmNsaW5lW3RoaXMucG9zKzFdfTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLnByaW50QUJDTGluZT1mdW5jdGlvbihhKXt0aGlzLm1pblk9Mjt0aGlzLnN0YWZmZ3JvdXA9bmV3IEFCQ0pTLndyaXRlLlN0YWZmR3JvdXBFbGVtZW50KCk7Zm9yKHRoaXMucz0wO3RoaXMuczxhLmxlbmd0aDt0aGlzLnMrKyl7dGhpcy5wcmludEFCQ1N0YWZmKGFbdGhpcy5zXSl9cmV0dXJuIHRoaXMuc3RhZmZncm91cH07QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5wcmludEFCQ1N0YWZmPWZ1bmN0aW9uKGEpe3ZhciBiPVwiXCI7aWYoYS5icmFja2V0KXtiKz1cImJyYWNrZXQgXCIrYS5icmFja2V0K1wiIFwifWlmKGEuYnJhY2Upe2IrPVwiYnJhY2UgXCIrYS5icmFjZStcIiBcIn1mb3IodGhpcy52PTA7dGhpcy52PGEudm9pY2VzLmxlbmd0aDt0aGlzLnYrKyl7dGhpcy52b2ljZT1uZXcgQUJDSlMud3JpdGUuVm9pY2VFbGVtZW50KHRoaXMudixhLnZvaWNlcy5sZW5ndGgpO2lmKHRoaXMudj09PTApe3RoaXMudm9pY2UuYmFyZnJvbT0oYS5jb25uZWN0QmFyTGluZXM9PT1cInN0YXJ0XCJ8fGEuY29ubmVjdEJhckxpbmVzPT09XCJjb250aW51ZVwiKTt0aGlzLnZvaWNlLmJhcnRvPShhLmNvbm5lY3RCYXJMaW5lcz09PVwiY29udGludWVcInx8YS5jb25uZWN0QmFyTGluZXM9PT1cImVuZFwiKX1lbHNle3RoaXMudm9pY2UuZHVwbGljYXRlPXRydWV9aWYoYS50aXRsZSYmYS50aXRsZVt0aGlzLnZdKXt0aGlzLnZvaWNlLmhlYWRlcj1hLnRpdGxlW3RoaXMudl19dGhpcy52b2ljZS5hZGRDaGlsZCh0aGlzLnByaW50Q2xlZihhLmNsZWYpKTt0aGlzLnZvaWNlLmFkZENoaWxkKHRoaXMucHJpbnRLZXlTaWduYXR1cmUoYS5rZXkpKTtpZihhLm1ldGVyKXt0aGlzLnZvaWNlLmFkZENoaWxkKHRoaXMucHJpbnRUaW1lU2lnbmF0dXJlKGEubWV0ZXIpKX10aGlzLnByaW50QUJDVm9pY2UoYS52b2ljZXNbdGhpcy52XSk7dGhpcy5zdGFmZmdyb3VwLmFkZFZvaWNlKHRoaXMudm9pY2UsdGhpcy5zLHRoaXMuc3RhZmZsaW5lcyl9fTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLnByaW50QUJDVm9pY2U9ZnVuY3Rpb24oYil7dGhpcy5wb3BDcm9zc0xpbmVFbGVtcygpO3RoaXMuc3RlbWRpcj0odGhpcy5pc0JhZ3BpcGVzKT9cImRvd25cIjpudWxsO3RoaXMuYWJjbGluZT1iO2lmKHRoaXMucGFydHN0YXJ0ZWxlbSl7dGhpcy5wYXJ0c3RhcnRlbGVtPW5ldyBBQkNKUy53cml0ZS5FbmRpbmdFbGVtKFwiXCIsbnVsbCxudWxsKTt0aGlzLnZvaWNlLmFkZE90aGVyKHRoaXMucGFydHN0YXJ0ZWxlbSl9Zm9yKHZhciBhIGluIHRoaXMuc2x1cnMpe2lmKHRoaXMuc2x1cnMuaGFzT3duUHJvcGVydHkoYSkpe3RoaXMuc2x1cnNbYV09bmV3IEFCQ0pTLndyaXRlLlRpZUVsZW0obnVsbCxudWxsLHRoaXMuc2x1cnNbYV0uYWJvdmUsdGhpcy5zbHVyc1thXS5mb3JjZSk7dGhpcy52b2ljZS5hZGRPdGhlcih0aGlzLnNsdXJzW2FdKX19Zm9yKHZhciBjPTA7Yzx0aGlzLnRpZXMubGVuZ3RoO2MrKyl7dGhpcy50aWVzW2NdPW5ldyBBQkNKUy53cml0ZS5UaWVFbGVtKG51bGwsbnVsbCx0aGlzLnRpZXNbY10uYWJvdmUsdGhpcy50aWVzW2NdLmZvcmNlKTt0aGlzLnZvaWNlLmFkZE90aGVyKHRoaXMudGllc1tjXSl9Zm9yKHRoaXMucG9zPTA7dGhpcy5wb3M8dGhpcy5hYmNsaW5lLmxlbmd0aDt0aGlzLnBvcysrKXt2YXIgZD10aGlzLnByaW50QUJDRWxlbWVudCgpO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspe3RoaXMudm9pY2UuYWRkQ2hpbGQoZFtjXSl9fXRoaXMucHVzaENyb3NzTGluZUVsZW1zKCl9O0FCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUucHJpbnRBQkNFbGVtZW50PWZ1bmN0aW9uKCl7dmFyIGQ9W107dmFyIGI9dGhpcy5nZXRFbGVtKCk7c3dpdGNoKGIuZWxfdHlwZSl7Y2FzZVwibm90ZVwiOmQ9dGhpcy5wcmludEJlYW0oKTticmVhaztjYXNlXCJiYXJcIjpkWzBdPXRoaXMucHJpbnRCYXJMaW5lKGIpO2lmKHRoaXMudm9pY2UuZHVwbGljYXRlKXtkWzBdLmludmlzaWJsZT10cnVlfWJyZWFrO2Nhc2VcIm1ldGVyXCI6ZFswXT10aGlzLnByaW50VGltZVNpZ25hdHVyZShiKTtpZih0aGlzLnZvaWNlLmR1cGxpY2F0ZSl7ZFswXS5pbnZpc2libGU9dHJ1ZX1icmVhaztjYXNlXCJjbGVmXCI6ZFswXT10aGlzLnByaW50Q2xlZihiKTtpZih0aGlzLnZvaWNlLmR1cGxpY2F0ZSl7ZFswXS5pbnZpc2libGU9dHJ1ZX1icmVhaztjYXNlXCJrZXlcIjpkWzBdPXRoaXMucHJpbnRLZXlTaWduYXR1cmUoYik7aWYodGhpcy52b2ljZS5kdXBsaWNhdGUpe2RbMF0uaW52aXNpYmxlPXRydWV9YnJlYWs7Y2FzZVwic3RlbVwiOnRoaXMuc3RlbWRpcj1iLmRpcmVjdGlvbjticmVhaztcbmNhc2VcInBhcnRcIjp2YXIgYT1uZXcgQUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50KGIsMCwwKTthLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoYi50aXRsZSwwLDAsMTgse3R5cGU6XCJ0ZXh0XCIsYXR0cmlidXRlczp7XCJmb250LXdlaWdodFwiOlwiYm9sZFwiLFwiZm9udC1zaXplXCI6XCJcIisxNip0aGlzLnByaW50ZXIuc2NhbGUrXCJweFwiLFwiZm9udC1mYW1pbHlcIjpcInNlcmlmXCJ9fSkpO2RbMF09YTticmVhaztkZWZhdWx0OnZhciBjPW5ldyBBQkNKUy53cml0ZS5BYnNvbHV0ZUVsZW1lbnQoYiwwLDApO2MuYWRkQ2hpbGQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChcImVsZW1lbnQgdHlwZSBcIitiLmVsX3R5cGUsMCwwLDAse3R5cGU6XCJkZWJ1Z1wifSkpO2RbMF09Y31yZXR1cm4gZH07QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5wcmludEJlYW09ZnVuY3Rpb24oKXt2YXIgZT1bXTtpZih0aGlzLmdldEVsZW0oKS5zdGFydEJlYW0mJiF0aGlzLmdldEVsZW0oKS5lbmRCZWFtKXt2YXIgZj1uZXcgQUJDSlMud3JpdGUuQmVhbUVsZW0odGhpcy5zdGVtZGlyKTt2YXIgYj10aGlzLnBvczt2YXIgYzt3aGlsZSh0aGlzLmdldEVsZW0oKSl7Yz10aGlzLnByaW50Tm90ZSh0aGlzLmdldEVsZW0oKSx0cnVlLHRydWUpO2YuYWRkKGMpO2lmKHRoaXMuZ2V0RWxlbSgpLmVuZEJlYW0pe2JyZWFrfXRoaXMucG9zKyt9dmFyIGE9Zi5jYWxjRGlyKCk7dGhpcy5wb3M9YjtmPW5ldyBBQkNKUy53cml0ZS5CZWFtRWxlbShhP1widXBcIjpcImRvd25cIik7dmFyIGQ9dGhpcy5zdGVtZGlyO3RoaXMuc3RlbWRpcj1hP1widXBcIjpcImRvd25cIjt3aGlsZSh0aGlzLmdldEVsZW0oKSl7Yz10aGlzLnByaW50Tm90ZSh0aGlzLmdldEVsZW0oKSx0cnVlKTtlLnB1c2goYyk7Zi5hZGQoYyk7aWYodGhpcy5nZXRFbGVtKCkuZW5kQmVhbSl7YnJlYWt9dGhpcy5wb3MrK310aGlzLnN0ZW1kaXI9ZDt0aGlzLnZvaWNlLmFkZE90aGVyKGYpfWVsc2V7ZVswXT10aGlzLnByaW50Tm90ZSh0aGlzLmdldEVsZW0oKSl9cmV0dXJuIGV9O0FCQ0pTLndyaXRlLnNvcnRQaXRjaD1mdW5jdGlvbihjKXt2YXIgYTtkb3thPXRydWU7Zm9yKHZhciBkPTA7ZDxjLnBpdGNoZXMubGVuZ3RoLTE7ZCsrKXtpZihjLnBpdGNoZXNbZF0ucGl0Y2g+Yy5waXRjaGVzW2QrMV0ucGl0Y2gpe2E9ZmFsc2U7dmFyIGI9Yy5waXRjaGVzW2RdO2MucGl0Y2hlc1tkXT1jLnBpdGNoZXNbZCsxXTtjLnBpdGNoZXNbZCsxXT1ifX19d2hpbGUoIWEpfTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLnByaW50Tm90ZT1mdW5jdGlvbihMLGQsUyl7dmFyIG89bnVsbDt2YXIgYT1udWxsO3RoaXMucm9vbXRha2VuPTA7dGhpcy5yb29tdGFrZW5yaWdodD0wO3ZhciBEPTA7dmFyIFU9XCJcIjt2YXIgQj1udWxsO3ZhciBxPVtdO3ZhciBJLE8sbDt2YXIgYixSLFEsZTt2YXIgcj1BQkNKUy53cml0ZS5nZXREdXJhdGlvbihMKTtpZihyPT09MCl7cj0wLjI1O2Q9dHJ1ZX12YXIgdj1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGgubG9nKDIpKTt2YXIgVz0wO2Zvcih2YXIgZj1NYXRoLnBvdygyLHYpLFA9Zi8yO2Y8cjtXKyssZis9UCxQLz0yKXt9aWYoTC5zdGFydFRyaXBsZXQpe2lmKEwuc3RhcnRUcmlwbGV0PT09Mil7dGhpcy50cmlwbGV0bXVsdGlwbGllcj0zLzJ9ZWxzZXt0aGlzLnRyaXBsZXRtdWx0aXBsaWVyPShMLnN0YXJ0VHJpcGxldC0xKS9MLnN0YXJ0VHJpcGxldH19dmFyIGc9bmV3IEFCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudChMLHIqdGhpcy50cmlwbGV0bXVsdGlwbGllciwxKTtpZihMLnJlc3Qpe3ZhciBrPTc7aWYodGhpcy5zdGVtZGlyPT09XCJkb3duXCIpe2s9M31pZih0aGlzLnN0ZW1kaXI9PT1cInVwXCIpe2s9MTF9c3dpdGNoKEwucmVzdC50eXBlKXtjYXNlXCJyZXN0XCI6VT10aGlzLmNoYXJ0YWJsZS5yZXN0Wy12XTtMLmF2ZXJhZ2VwaXRjaD1rO0wubWlucGl0Y2g9aztMLm1heHBpdGNoPWs7YnJlYWs7Y2FzZVwiaW52aXNpYmxlXCI6Y2FzZVwic3BhY2VyXCI6VT1cIlwifWlmKCFTKXtvPXRoaXMucHJpbnROb3RlSGVhZChnLFUse3ZlcnRpY2FsUG9zOmt9LG51bGwsMCwtdGhpcy5yb29tdGFrZW4sbnVsbCxXLDAsMSl9aWYobyl7Zy5hZGRIZWFkKG8pfXRoaXMucm9vbXRha2VuKz10aGlzLmFjY2lkZW50YWxzaGlmdHg7dGhpcy5yb29tdGFrZW5yaWdodD1NYXRoLm1heCh0aGlzLnJvb210YWtlbnJpZ2h0LHRoaXMuZG90c2hpZnR4KX1lbHNle0FCQ0pTLndyaXRlLnNvcnRQaXRjaChMKTt2YXIgbj0wO2ZvcihJPTAsbD1MLnBpdGNoZXMubGVuZ3RoO0k8bDtJKyspe24rPUwucGl0Y2hlc1tJXS52ZXJ0aWNhbFBvc31MLmF2ZXJhZ2VwaXRjaD1uL0wucGl0Y2hlcy5sZW5ndGg7TC5taW5waXRjaD1MLnBpdGNoZXNbMF0udmVydGljYWxQb3M7dGhpcy5taW5ZPU1hdGgubWluKEwubWlucGl0Y2gsdGhpcy5taW5ZKTtMLm1heHBpdGNoPUwucGl0Y2hlc1tMLnBpdGNoZXMubGVuZ3RoLTFdLnZlcnRpY2FsUG9zO3ZhciBWPShMLmF2ZXJhZ2VwaXRjaD49Nik/XCJkb3duXCI6XCJ1cFwiO2lmKHRoaXMuc3RlbWRpcil7Vj10aGlzLnN0ZW1kaXJ9Zm9yKEk9KFY9PT1cImRvd25cIik/TC5waXRjaGVzLmxlbmd0aC0yOjE7KFY9PT1cImRvd25cIik/ST49MDpJPEwucGl0Y2hlcy5sZW5ndGg7ST0oVj09PVwiZG93blwiKT9JLTE6SSsxKXt2YXIgdz1MLnBpdGNoZXNbKFY9PT1cImRvd25cIik/SSsxOkktMV07dmFyIEU9TC5waXRjaGVzW0ldO3ZhciBGPShWPT09XCJkb3duXCIpP3cucGl0Y2gtRS5waXRjaDpFLnBpdGNoLXcucGl0Y2g7aWYoRjw9MSYmIXcucHJpbnRlcl9zaGlmdCl7RS5wcmludGVyX3NoaWZ0PShGKT9cImRpZmZlcmVudFwiOlwic2FtZVwiO2lmKEUudmVydGljYWxQb3M+MTF8fEUudmVydGljYWxQb3M8MSl7cS5wdXNoKEUudmVydGljYWxQb3MtKEUudmVydGljYWxQb3MlMikpfWlmKFY9PT1cImRvd25cIil7dGhpcy5yb29tdGFrZW49dGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgodGhpcy5jaGFydGFibGUubm90ZVstdl0pKzJ9ZWxzZXtEPXRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHRoaXMuY2hhcnRhYmxlLm5vdGVbLXZdKSsyfX19dGhpcy5hY2NpZGVudGFsU2xvdD1bXTtmb3IoST0wO0k8TC5waXRjaGVzLmxlbmd0aDtJKyspe2lmKCFkKXtpZigoVj09PVwiZG93blwiJiZJIT09MCl8fChWPT09XCJ1cFwiJiZJIT09bC0xKSl7Qj1udWxsfWVsc2V7Qj10aGlzLmNoYXJ0YWJsZVsoVj09PVwiZG93blwiKT9cImRmbGFnc1wiOlwidWZsYWdzXCJdWy12XX1VPXRoaXMuY2hhcnRhYmxlLm5vdGVbLXZdfWVsc2V7VT1cIm5vdGVoZWFkcy5xdWFydGVyXCJ9TC5waXRjaGVzW0ldLmhpZ2hlc3RWZXJ0PUwucGl0Y2hlc1tJXS52ZXJ0aWNhbFBvczt2YXIgaj0odGhpcy5zdGVtZGlyPT09XCJ1cFwifHxWPT09XCJ1cFwiKSYmST09PTA7dmFyIEo9KHRoaXMuc3RlbWRpcj09PVwiZG93blwifHxWPT09XCJkb3duXCIpJiZJPT09bC0xO2lmKCFTJiYoanx8Sikpe2lmKEwuc3RhcnRTbHVyfHxsPT09MSl7TC5waXRjaGVzW0ldLmhpZ2hlc3RWZXJ0PUwucGl0Y2hlc1tsLTFdLnZlcnRpY2FsUG9zO2lmKHRoaXMuc3RlbWRpcj09PVwidXBcInx8Vj09PVwidXBcIil7TC5waXRjaGVzW0ldLmhpZ2hlc3RWZXJ0Kz02fX1pZihMLnN0YXJ0U2x1cil7aWYoIUwucGl0Y2hlc1tJXS5zdGFydFNsdXIpe0wucGl0Y2hlc1tJXS5zdGFydFNsdXI9W119Zm9yKE89MDtPPEwuc3RhcnRTbHVyLmxlbmd0aDtPKyspe0wucGl0Y2hlc1tJXS5zdGFydFNsdXIucHVzaChMLnN0YXJ0U2x1cltPXSl9fWlmKCFTJiZMLmVuZFNsdXIpe0wucGl0Y2hlc1tJXS5oaWdoZXN0VmVydD1MLnBpdGNoZXNbbC0xXS52ZXJ0aWNhbFBvcztpZih0aGlzLnN0ZW1kaXI9PT1cInVwXCJ8fFY9PT1cInVwXCIpe0wucGl0Y2hlc1tJXS5oaWdoZXN0VmVydCs9Nn1pZighTC5waXRjaGVzW0ldLmVuZFNsdXIpe0wucGl0Y2hlc1tJXS5lbmRTbHVyPVtdfWZvcihPPTA7TzxMLmVuZFNsdXIubGVuZ3RoO08rKyl7TC5waXRjaGVzW0ldLmVuZFNsdXIucHVzaChMLmVuZFNsdXJbT10pfX19aWYoIVMpe289dGhpcy5wcmludE5vdGVIZWFkKGcsVSxMLnBpdGNoZXNbSV0sViwwLC10aGlzLnJvb210YWtlbixCLFcsRCwxKX1pZihvKXtnLmFkZEhlYWQobyl9dGhpcy5yb29tdGFrZW4rPXRoaXMuYWNjaWRlbnRhbHNoaWZ0eDt0aGlzLnJvb210YWtlbnJpZ2h0PU1hdGgubWF4KHRoaXMucm9vbXRha2VucmlnaHQsdGhpcy5kb3RzaGlmdHgpfWlmKCFkJiZ2PD0tMSl7Uj0oVj09PVwiZG93blwiKT9MLm1pbnBpdGNoLTc6TC5taW5waXRjaCsxLzM7aWYoUj42JiYhdGhpcy5zdGVtZGlyKXtSPTZ9UT0oVj09PVwiZG93blwiKT9MLm1heHBpdGNoLTEvMzpMLm1heHBpdGNoKzc7aWYoUTw2JiYhdGhpcy5zdGVtZGlyKXtRPTZ9ZT0oVj09PVwiZG93blwifHxnLmhlYWRzLmxlbmd0aD09PTApPzA6Zy5oZWFkc1swXS53O2I9KFY9PT1cImRvd25cIik/MTotMTtnLmFkZEV4dHJhKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQobnVsbCxlLDAsUix7dHlwZTpcInN0ZW1cIixwaXRjaDI6USxsaW5ld2lkdGg6Yn0pKTt0aGlzLm1pblk9TWF0aC5taW4oUix0aGlzLm1pblkpO3RoaXMubWluWT1NYXRoLm1pbihRLHRoaXMubWluWSl9fWlmKEwubHlyaWMhPT11bmRlZmluZWQpe3ZhciBLPVwiXCI7d2luZG93LkFCQ0pTLnBhcnNlLmVhY2goTC5seXJpYyxmdW5jdGlvbihjKXtLKz1jLnN5bGxhYmxlK2MuZGl2aWRlcitcIlxcblwifSk7Zy5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KEssMCxLLmxlbmd0aCo1LDAse3R5cGU6XCJkZWJ1Z0xvd1wifSkpfWlmKCFTJiZMLmdyYWNlbm90ZXMhPT11bmRlZmluZWQpe3ZhciB1PTMvNTt2YXIgaD1udWxsO2lmKEwuZ3JhY2Vub3Rlcy5sZW5ndGg+MSl7aD1uZXcgQUJDSlMud3JpdGUuQmVhbUVsZW0oXCJncmFjZVwiLHRoaXMuaXNCYWdwaXBlcyl9dmFyIFQ9W107Zm9yKE89TC5ncmFjZW5vdGVzLmxlbmd0aC0xO08+PTA7Ty0tKXt0aGlzLnJvb210YWtlbis9MTA7VFtPXT10aGlzLnJvb210YWtlbjtpZihMLmdyYWNlbm90ZXNbT10uYWNjaWRlbnRhbCl7dGhpcy5yb29tdGFrZW4rPTd9fWZvcihPPTA7TzxMLmdyYWNlbm90ZXMubGVuZ3RoO08rKyl7dmFyIHQ9TC5ncmFjZW5vdGVzW09dLnZlcnRpY2FsUG9zO0I9KGgpP251bGw6dGhpcy5jaGFydGFibGUudWZsYWdzWyh0aGlzLmlzQmFncGlwZXMpPzU6M107YT10aGlzLnByaW50Tm90ZUhlYWQoZyxcIm5vdGVoZWFkcy5xdWFydGVyXCIsTC5ncmFjZW5vdGVzW09dLFwidXBcIiwtVFtPXSwtVFtPXSxCLDAsMCx1KTtnLmFkZEV4dHJhKGEpO2lmKEwuZ3JhY2Vub3Rlc1tPXS5hY2NpYWNjYXR1cmEpe3ZhciB6PUwuZ3JhY2Vub3Rlc1tPXS52ZXJ0aWNhbFBvcys3KnU7dmFyIE49aD81OjY7Zy5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KFwiZmxhZ3MudWdyYWNlXCIsLVRbT10rTiwwLHose3NjYWxleDp1LHNjYWxleTp1fSkpfWlmKGgpe3ZhciBtPXtoZWFkczpbYV0sYWJjZWxlbTp7YXZlcmFnZXBpdGNoOnQsbWlucGl0Y2g6dCxtYXhwaXRjaDp0fSxkdXJhdGlvbjoodGhpcy5pc0JhZ3BpcGVzKT8xLzMyOjEvMTZ9O2guYWRkKG0pfWVsc2V7Uj10KzEvMyp1O1E9dCs3KnU7ZT1hLmR4K2EudztiPS0wLjY7Zy5hZGRFeHRyYShuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KG51bGwsZSwwLFIse3R5cGU6XCJzdGVtXCIscGl0Y2gyOlEsbGluZXdpZHRoOmJ9KSl9aWYoTz09PTAmJiF0aGlzLmlzQmFncGlwZXMmJiEoTC5yZXN0JiYoTC5yZXN0LnR5cGU9PT1cInNwYWNlclwifHxMLnJlc3QudHlwZT09PVwiaW52aXNpYmxlXCIpKSl7dGhpcy52b2ljZS5hZGRPdGhlcihuZXcgQUJDSlMud3JpdGUuVGllRWxlbShhLG8sZmFsc2UsdHJ1ZSkpfX1pZihoKXt0aGlzLnZvaWNlLmFkZE90aGVyKGgpfX1pZighUyYmTC5kZWNvcmF0aW9uKXt2YXIgcz10aGlzLnByaW50RGVjb3JhdGlvbihMLmRlY29yYXRpb24sTC5tYXhwaXRjaCwobyk/by53OjAsZyx0aGlzLnJvb210YWtlbixWLEwubWlucGl0Y2gpO2lmKHMpe2cua2xhc3M9XCJtYXJrXCJ9fWlmKEwuYmFyTnVtYmVyKXtnLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoTC5iYXJOdW1iZXIsLTEwLDAsMCx7dHlwZTpcImRlYnVnXCJ9KSl9Zm9yKE89TC5tYXhwaXRjaDtPPjExO08tLSl7aWYoTyUyPT09MCYmIUwucmVzdCl7Zy5hZGRDaGlsZChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KG51bGwsLTIsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoVSkrNCxPLHt0eXBlOlwibGVkZ2VyXCJ9KSl9fWZvcihPPUwubWlucGl0Y2g7TzwxO08rKyl7aWYoTyUyPT09MCYmIUwucmVzdCl7Zy5hZGRDaGlsZChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KG51bGwsLTIsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoVSkrNCxPLHt0eXBlOlwibGVkZ2VyXCJ9KSl9fWZvcihPPTA7TzxxLmxlbmd0aDtPKyspe3ZhciBDPXRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFUpO2lmKFY9PT1cImRvd25cIil7Qz0tQ31nLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQobnVsbCxDLTIsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoVSkrNCxxW09dLHt0eXBlOlwibGVkZ2VyXCJ9KSl9aWYoTC5jaG9yZCE9PXVuZGVmaW5lZCl7Zm9yKE89MDtPPEwuY2hvcmQubGVuZ3RoO08rKyl7dmFyIEg9MDt2YXIgRz0xNjtzd2l0Y2goTC5jaG9yZFtPXS5wb3NpdGlvbil7Y2FzZVwibGVmdFwiOnRoaXMucm9vbXRha2VuKz03O0g9LXRoaXMucm9vbXRha2VuO0c9TC5hdmVyYWdlcGl0Y2g7Zy5hZGRFeHRyYShuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KEwuY2hvcmRbT10ubmFtZSxILHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKEwuY2hvcmRbT10ubmFtZVswXSkrNCxHLHt0eXBlOlwidGV4dFwifSkpO2JyZWFrO2Nhc2VcInJpZ2h0XCI6dGhpcy5yb29tdGFrZW5yaWdodCs9NDtIPXRoaXMucm9vbXRha2VucmlnaHQ7Rz1MLmF2ZXJhZ2VwaXRjaDtnLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoTC5jaG9yZFtPXS5uYW1lLEgsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoTC5jaG9yZFtPXS5uYW1lWzBdKSs0LEcse3R5cGU6XCJ0ZXh0XCJ9KSk7XG5icmVhaztjYXNlXCJiZWxvd1wiOkc9TC5taW5waXRjaC00O2lmKEc+LTMpe0c9LTN9dmFyIE09TC5jaG9yZFtPXS5uYW1lLnNwbGl0KFwiXFxuXCIpO2Zvcih2YXIgQT0wO0E8TS5sZW5ndGg7QSsrKXtnLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoTVtBXSxILDAsRyx7dHlwZTpcInRleHRcIn0pKTtHLT0zfWJyZWFrO2RlZmF1bHQ6aWYoTC5jaG9yZFtPXS5yZWxfcG9zaXRpb24pe2cuYWRkQ2hpbGQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChMLmNob3JkW09dLm5hbWUsSCtMLmNob3JkW09dLnJlbF9wb3NpdGlvbi54LDAsTC5taW5waXRjaCtMLmNob3JkW09dLnJlbF9wb3NpdGlvbi55L0FCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUCx7dHlwZTpcInRleHRcIn0pKX1lbHNle2cuYWRkQ2hpbGQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChMLmNob3JkW09dLm5hbWUsSCwwLEcse3R5cGU6XCJ0ZXh0XCJ9KSl9fX19aWYoTC5zdGFydFRyaXBsZXQpe3RoaXMudHJpcGxldD1uZXcgQUJDSlMud3JpdGUuVHJpcGxldEVsZW0oTC5zdGFydFRyaXBsZXQsbyxudWxsLHRydWUpO2lmKCFTKXt0aGlzLnZvaWNlLmFkZE90aGVyKHRoaXMudHJpcGxldCl9fWlmKEwuZW5kVHJpcGxldCYmdGhpcy50cmlwbGV0KXt0aGlzLnRyaXBsZXQuYW5jaG9yMj1vO3RoaXMudHJpcGxldD1udWxsO3RoaXMudHJpcGxldG11bHRpcGxpZXI9MX1yZXR1cm4gZ307QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5wcmludE5vdGVIZWFkPWZ1bmN0aW9uKG0seixBLG8saCxlLHUscCx4LEIpe3ZhciBrPUEudmVydGljYWxQb3M7dmFyIGQ7dmFyIHY7dGhpcy5hY2NpZGVudGFsc2hpZnR4PTA7dGhpcy5kb3RzaGlmdHg9MDtpZih6PT09dW5kZWZpbmVkKXttLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoXCJwaXRjaCBpcyB1bmRlZmluZWRcIiwwLDAsMCx7dHlwZTpcImRlYnVnXCJ9KSl9ZWxzZXtpZih6PT09XCJcIil7ZD1uZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KG51bGwsMCwwLGspfWVsc2V7dmFyIG49aDtpZihBLnByaW50ZXJfc2hpZnQpe3ZhciByPShBLnByaW50ZXJfc2hpZnQ9PT1cInNhbWVcIik/MTowO249KG89PT1cImRvd25cIik/LXRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHopKkIrcjp0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aCh6KSpCLXJ9ZD1uZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KHosbix0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aCh6KSpCLGsse3NjYWxleDpCLHNjYWxleTpCLGV4dHJlbWU6KChvPT09XCJkb3duXCIpP1wiYmVsb3dcIjpcImFib3ZlXCIpfSk7aWYodSl7dmFyIGc9aysoKG89PT1cImRvd25cIik/LTc6NykqQjtpZihCPT09MSYmKG89PT1cImRvd25cIik/KGc+Nik6KGc8Nikpe2c9Nn12YXIgcT0obz09PVwiZG93blwiKT9oOmgrZC53LTAuNjttLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQodSxxLHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHUpKkIsZyx7c2NhbGV4OkIsc2NhbGV5OkJ9KSl9dGhpcy5kb3RzaGlmdHg9ZC53K3gtMis1KnA7Zm9yKDtwPjA7cC0tKXt2YXIgYT0oMS1NYXRoLmFicyhrKSUyKTttLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoXCJkb3RzLmRvdFwiLGQudyt4LTIrNSpwLHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwiZG90cy5kb3RcIiksaythKSl9fX1pZihkKXtkLmhpZ2hlc3RWZXJ0PUEuaGlnaGVzdFZlcnR9aWYoQS5hY2NpZGVudGFsKXt2YXIgYjtzd2l0Y2goQS5hY2NpZGVudGFsKXtjYXNlXCJxdWFydGVyc2hhcnBcIjpiPVwiYWNjaWRlbnRhbHMuaGFsZnNoYXJwXCI7YnJlYWs7Y2FzZVwiZGJsc2hhcnBcIjpiPVwiYWNjaWRlbnRhbHMuZGJsc2hhcnBcIjticmVhaztjYXNlXCJzaGFycFwiOmI9XCJhY2NpZGVudGFscy5zaGFycFwiO2JyZWFrO2Nhc2VcInF1YXJ0ZXJmbGF0XCI6Yj1cImFjY2lkZW50YWxzLmhhbGZmbGF0XCI7YnJlYWs7Y2FzZVwiZmxhdFwiOmI9XCJhY2NpZGVudGFscy5mbGF0XCI7YnJlYWs7Y2FzZVwiZGJsZmxhdFwiOmI9XCJhY2NpZGVudGFscy5kYmxmbGF0XCI7YnJlYWs7Y2FzZVwibmF0dXJhbFwiOmI9XCJhY2NpZGVudGFscy5uYXRcIn12YXIgbD1mYWxzZTt2YXIgdz1lO2Zvcih2YXIgcz0wO3M8dGhpcy5hY2NpZGVudGFsU2xvdC5sZW5ndGg7cysrKXtpZihrLXRoaXMuYWNjaWRlbnRhbFNsb3Rbc11bMF0+PTYpe3RoaXMuYWNjaWRlbnRhbFNsb3Rbc11bMF09azt3PXRoaXMuYWNjaWRlbnRhbFNsb3Rbc11bMV07bD10cnVlO2JyZWFrfX1pZihsPT09ZmFsc2Upe3ctPSh0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aChiKSpCKzIpO3RoaXMuYWNjaWRlbnRhbFNsb3QucHVzaChbayx3XSk7dGhpcy5hY2NpZGVudGFsc2hpZnR4PSh0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aChiKSpCKzIpfW0uYWRkRXh0cmEobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChiLHcsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoYiksayx7c2NhbGV4OkIsc2NhbGV5OkJ9KSl9aWYoQS5lbmRUaWUpe2lmKHRoaXMudGllc1swXSl7dGhpcy50aWVzWzBdLmFuY2hvcjI9ZDt0aGlzLnRpZXM9dGhpcy50aWVzLnNsaWNlKDEsdGhpcy50aWVzLmxlbmd0aCl9fWlmKEEuc3RhcnRUaWUpe3ZhciB0PW5ldyBBQkNKUy53cml0ZS5UaWVFbGVtKGQsbnVsbCwodGhpcy5zdGVtZGlyPT09XCJkb3duXCJ8fG89PT1cImRvd25cIikmJnRoaXMuc3RlbWRpciE9PVwidXBcIiwodGhpcy5zdGVtZGlyPT09XCJkb3duXCJ8fHRoaXMuc3RlbWRpcj09PVwidXBcIikpO3RoaXMudGllc1t0aGlzLnRpZXMubGVuZ3RoXT10O3RoaXMudm9pY2UuYWRkT3RoZXIodCl9aWYoQS5lbmRTbHVyKXtmb3Iodj0wO3Y8QS5lbmRTbHVyLmxlbmd0aDt2Kyspe3ZhciB5PUEuZW5kU2x1clt2XTt2YXIgZjtpZih0aGlzLnNsdXJzW3ldKXtmPXRoaXMuc2x1cnNbeV0uYW5jaG9yMj1kO2RlbGV0ZSB0aGlzLnNsdXJzW3ldfWVsc2V7Zj1uZXcgQUJDSlMud3JpdGUuVGllRWxlbShudWxsLGQsbz09PVwiZG93blwiLCh0aGlzLnN0ZW1kaXI9PT1cInVwXCJ8fG89PT1cImRvd25cIikmJnRoaXMuc3RlbWRpciE9PVwiZG93blwiLHRoaXMuc3RlbWRpcik7dGhpcy52b2ljZS5hZGRPdGhlcihmKX1pZih0aGlzLnN0YXJ0bGltaXRlbGVtKXtmLnN0YXJ0bGltaXRlbGVtPXRoaXMuc3RhcnRsaW1pdGVsZW19fX1pZihBLnN0YXJ0U2x1cil7Zm9yKHY9MDt2PEEuc3RhcnRTbHVyLmxlbmd0aDt2Kyspe3ZhciB5PUEuc3RhcnRTbHVyW3ZdLmxhYmVsO3ZhciBmPW5ldyBBQkNKUy53cml0ZS5UaWVFbGVtKGQsbnVsbCwodGhpcy5zdGVtZGlyPT09XCJkb3duXCJ8fG89PT1cImRvd25cIikmJnRoaXMuc3RlbWRpciE9PVwidXBcIixmYWxzZSk7dGhpcy5zbHVyc1t5XT1mO3RoaXMudm9pY2UuYWRkT3RoZXIoZil9fXJldHVybiBkfTtBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLnByaW50RGVjb3JhdGlvbj1mdW5jdGlvbihsLGssdCxuLGEscixmKXt2YXIgcTt2YXIgdjt2YXIgajt2YXIgeTt2YXIgcz1bXTt2YXIgej0oaz45KT9rKzM6MTI7dmFyIGg7dmFyIG89ZmFsc2U7dmFyIG09dGhpcy5taW5ZLTQ7dmFyIHg7YT1hfHwwO2lmKGs9PT01KXt6PTE0fXZhciBnPWZhbHNlO2Zvcih4PTA7eDxsLmxlbmd0aDt4Kyspe2lmKGxbeF09PT1cInN0YWNjYXRvXCJ8fGxbeF09PT1cInRlbnV0b1wiKXt2YXIgdT1cInNjcmlwdHMuXCIrbFt4XTtoPShyPT09XCJkb3duXCIpP2srMjpmLTI7c3dpdGNoKGgpe2Nhc2UgMjpjYXNlIDQ6Y2FzZSA2OmNhc2UgODpjYXNlIDEwOmlmKHI9PT1cInVwXCIpe2gtLX1lbHNle2grK31icmVha31pZihrPjkpe3orK312YXIgYz10LzI7aWYodGhpcy5nbHlwaHMuZ2V0U3ltYm9sQWxpZ24odSkhPT1cImNlbnRlclwiKXtjLT0odGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgocSkvMil9bi5hZGRDaGlsZChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KHUsYyx0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aCh1KSxoKSl9aWYobFt4XT09PVwic2xpZGVcIiYmbi5oZWFkc1swXSl7aD1uLmhlYWRzWzBdLnBpdGNoO3ZhciBkPW5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoXCJcIiwtYS0xNSwwLGgtMSk7dmFyIGI9bmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChcIlwiLC1hLTUsMCxoKzEpO24uYWRkQ2hpbGQoZCk7bi5hZGRDaGlsZChiKTt0aGlzLnZvaWNlLmFkZE90aGVyKG5ldyBBQkNKUy53cml0ZS5UaWVFbGVtKGQsYixmYWxzZSkpfX1mb3IoeD0wO3g8bC5sZW5ndGg7eCsrKXtvPWZhbHNlO3N3aXRjaChsW3hdKXtjYXNlXCJ0cmlsbFwiOnE9XCJzY3JpcHRzLnRyaWxsXCI7YnJlYWs7Y2FzZVwicm9sbFwiOnE9XCJzY3JpcHRzLnJvbGxcIjticmVhaztjYXNlXCJpcmlzaHJvbGxcIjpxPVwic2NyaXB0cy5yb2xsXCI7YnJlYWs7Y2FzZVwibWFyY2F0b1wiOnE9XCJzY3JpcHRzLnVtYXJjYXRvXCI7YnJlYWs7Y2FzZVwibWFyY2F0bzJcIjpxPVwic2NyaW9wdHMuZG1hcmNhdG9cIjticmVhaztjYXNlXCJ0dXJuXCI6cT1cInNjcmlwdHMudHVyblwiO2JyZWFrO2Nhc2VcInVwcGVybW9yZGVudFwiOnE9XCJzY3JpcHRzLnByYWxsXCI7YnJlYWs7Y2FzZVwibW9yZGVudFwiOmNhc2VcImxvd2VybW9yZGVudFwiOnE9XCJzY3JpcHRzLm1vcmRlbnRcIjticmVhaztjYXNlXCJzdGFjY2F0b1wiOmNhc2VcInRlbnV0b1wiOmNhc2VcInNsaWRlXCI6Y29udGludWU7Y2FzZVwiZG93bmJvd1wiOnE9XCJzY3JpcHRzLmRvd25ib3dcIjticmVhaztjYXNlXCJ1cGJvd1wiOnE9XCJzY3JpcHRzLnVwYm93XCI7YnJlYWs7Y2FzZVwiZmVybWF0YVwiOnE9XCJzY3JpcHRzLnVmZXJtYXRhXCI7YnJlYWs7Y2FzZVwiaW52ZXJ0ZWRmZXJtYXRhXCI6bz10cnVlO3E9XCJzY3JpcHRzLmRmZXJtYXRhXCI7YnJlYWs7Y2FzZVwiYnJlYXRoXCI6cT1cIixcIjticmVhaztjYXNlXCJhY2NlbnRcIjpxPVwic2NyaXB0cy5zZm9yemF0b1wiO2JyZWFrO2Nhc2VcInVtYXJjYXRvXCI6cT1cInNjcmlwdHMudW1hcmNhdG9cIjticmVhaztjYXNlXCJjb2RhXCI6cT1cInNjcmlwdHMuY29kYVwiO2JyZWFrO2Nhc2VcInNlZ25vXCI6cT1cInNjcmlwdHMuc2Vnbm9cIjticmVhaztjYXNlXCIvXCI6dj1bXCJmbGFncy51Z3JhY2VcIiwxXTtjb250aW51ZTtjYXNlXCIvL1wiOnY9W1wiZmxhZ3MudWdyYWNlXCIsMl07Y29udGludWU7Y2FzZVwiLy8vXCI6dj1bXCJmbGFncy51Z3JhY2VcIiwzXTtjb250aW51ZTtjYXNlXCIvLy8vXCI6dj1bXCJmbGFncy51Z3JhY2VcIiw0XTtjb250aW51ZTtjYXNlXCJwXCI6Y2FzZVwibXBcIjpjYXNlXCJwcFwiOmNhc2VcInBwcFwiOmNhc2VcInBwcHBcIjpjYXNlXCJmXCI6Y2FzZVwiZmZcIjpjYXNlXCJmZmZcIjpjYXNlXCJmZmZmXCI6Y2FzZVwic2Z6XCI6Y2FzZVwibWZcIjp2YXIgdz1uZXcgQUJDSlMud3JpdGUuRHluYW1pY0RlY29yYXRpb24obixsW3hdKTt0aGlzLnZvaWNlLmFkZE90aGVyKHcpO2NvbnRpbnVlO2Nhc2VcIm1hcmtcIjpnPXRydWU7Y29udGludWU7Y2FzZVwiZGltaW51ZW5kbyhcIjpBQkNKUy53cml0ZS5MYXlvdXQucHJvdG90eXBlLnN0YXJ0RGltaW51ZW5kb1g9bjtqPXVuZGVmaW5lZDtjb250aW51ZTtjYXNlXCJkaW1pbnVlbmRvKVwiOmo9e3N0YXJ0OkFCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUuc3RhcnREaW1pbnVlbmRvWCxzdG9wOm59O0FCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUuc3RhcnREaW1pbnVlbmRvWD11bmRlZmluZWQ7Y29udGludWU7Y2FzZVwiY3Jlc2NlbmRvKFwiOkFCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUuc3RhcnRDcmVzY2VuZG9YPW47eT11bmRlZmluZWQ7Y29udGludWU7Y2FzZVwiY3Jlc2NlbmRvKVwiOnk9e3N0YXJ0OkFCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUuc3RhcnRDcmVzY2VuZG9YLHN0b3A6bn07QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5zdGFydENyZXNjZW5kb1g9dW5kZWZpbmVkO2NvbnRpbnVlO2RlZmF1bHQ6c1tzLmxlbmd0aF09bFt4XTtjb250aW51ZX1pZihvKXtoPW07bS09NH1lbHNle2g9ejt6Kz0zfXZhciBjPXQvMjtpZih0aGlzLmdseXBocy5nZXRTeW1ib2xBbGlnbihxKSE9PVwiY2VudGVyXCIpe2MtPSh0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aChxKS8yKX1uLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQocSxjLHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKHEpLGgpKX1pZih2KXtoPShyPT09XCJkb3duXCIpP2srMTprKzk7Yz10LzI7Yys9KHI9PT1cImRvd25cIik/LTU6Mztmb3IodmFyIGU9MDtlPHZbMV07ZSsrKXtoLT0xO24uYWRkQ2hpbGQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudCh2WzBdLGMsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgodlswXSksaCkpfX1pZihqKXt2YXIgcD1uZXcgQUJDSlMud3JpdGUuQ3Jlc2NlbmRvRWxlbShqLnN0YXJ0LGouc3RvcCxcIj5cIik7dGhpcy52b2ljZS5hZGRPdGhlcihwKX1pZih5KXt2YXIgQT1uZXcgQUJDSlMud3JpdGUuQ3Jlc2NlbmRvRWxlbSh5LnN0YXJ0LHkuc3RvcCxcIjxcIik7dGhpcy52b2ljZS5hZGRPdGhlcihBKX1pZihzLmxlbmd0aD4wKXtuLmFkZENoaWxkKG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQocy5qb2luKFwiLFwiKSwwLDAsMCx7dHlwZTpcImRlYnVnXCJ9KSl9cmV0dXJuIGd9O0FCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUucHJpbnRCYXJMaW5lPWZ1bmN0aW9uKGMpe3ZhciBpPW5ldyBBQkNKUy53cml0ZS5BYnNvbHV0ZUVsZW1lbnQoYywwLDEwKTt2YXIgZD1udWxsO3ZhciBqPTA7dmFyIGE9KGMudHlwZT09PVwiYmFyX3JpZ2h0X3JlcGVhdFwifHxjLnR5cGU9PT1cImJhcl9kYmxfcmVwZWF0XCIpO3ZhciBlPShjLnR5cGUhPT1cImJhcl9sZWZ0X3JlcGVhdFwiJiZjLnR5cGUhPT1cImJhcl90aGlja190aGluXCImJmMudHlwZSE9PVwiYmFyX2ludmlzaWJsZVwiKTt2YXIgZj0oYy50eXBlPT09XCJiYXJfcmlnaHRfcmVwZWF0XCJ8fGMudHlwZT09PVwiYmFyX2RibF9yZXBlYXRcInx8Yy50eXBlPT09XCJiYXJfbGVmdF9yZXBlYXRcInx8Yy50eXBlPT09XCJiYXJfdGhpbl90aGlja1wifHxjLnR5cGU9PT1cImJhcl90aGlja190aGluXCIpO3ZhciBnPShjLnR5cGU9PT1cImJhcl9sZWZ0X3JlcGVhdFwifHxjLnR5cGU9PT1cImJhcl90aGlja190aGluXCJ8fGMudHlwZT09PVwiYmFyX3RoaW5fdGhpblwifHxjLnR5cGU9PT1cImJhcl9kYmxfcmVwZWF0XCIpO1xudmFyIGI9KGMudHlwZT09PVwiYmFyX2xlZnRfcmVwZWF0XCJ8fGMudHlwZT09PVwiYmFyX2RibF9yZXBlYXRcIik7aWYoYXx8Yil7Zm9yKHZhciBoIGluIHRoaXMuc2x1cnMpe2lmKHRoaXMuc2x1cnMuaGFzT3duUHJvcGVydHkoaCkpe3RoaXMuc2x1cnNbaF0uZW5kbGltaXRlbGVtPWl9fXRoaXMuc3RhcnRsaW1pdGVsZW09aX1pZihhKXtpLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoXCJkb3RzLmRvdFwiLGosMSw3KSk7aS5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KFwiZG90cy5kb3RcIixqLDEsNSkpO2orPTZ9aWYoZSl7ZD1uZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KG51bGwsaiwxLDIse3R5cGU6XCJiYXJcIixwaXRjaDI6MTAsbGluZXdpZHRoOjAuNn0pO2kuYWRkUmlnaHQoZCl9aWYoYy50eXBlPT09XCJiYXJfaW52aXNpYmxlXCIpe2Q9bmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChudWxsLGosMSwyLHt0eXBlOlwibm9uZVwiLHBpdGNoMjoxMCxsaW5ld2lkdGg6MC42fSk7aS5hZGRSaWdodChkKX1pZihjLmRlY29yYXRpb24pe3RoaXMucHJpbnREZWNvcmF0aW9uKGMuZGVjb3JhdGlvbiwxMiwoZik/MzoxLGksMCxcImRvd25cIiwyKX1pZihmKXtqKz00O2Q9bmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChudWxsLGosNCwyLHt0eXBlOlwiYmFyXCIscGl0Y2gyOjEwLGxpbmV3aWR0aDo0fSk7aS5hZGRSaWdodChkKTtqKz01fWlmKHRoaXMucGFydHN0YXJ0ZWxlbSYmYy5lbmRFbmRpbmcpe3RoaXMucGFydHN0YXJ0ZWxlbS5hbmNob3IyPWQ7dGhpcy5wYXJ0c3RhcnRlbGVtPW51bGx9aWYoZyl7ais9MztkPW5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQobnVsbCxqLDEsMix7dHlwZTpcImJhclwiLHBpdGNoMjoxMCxsaW5ld2lkdGg6MC42fSk7aS5hZGRSaWdodChkKX1pZihiKXtqKz0zO2kuYWRkUmlnaHQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChcImRvdHMuZG90XCIsaiwxLDcpKTtpLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoXCJkb3RzLmRvdFwiLGosMSw1KSl9aWYoYy5zdGFydEVuZGluZyl7dGhpcy5wYXJ0c3RhcnRlbGVtPW5ldyBBQkNKUy53cml0ZS5FbmRpbmdFbGVtKGMuc3RhcnRFbmRpbmcsZCxudWxsKTt0aGlzLnZvaWNlLmFkZE90aGVyKHRoaXMucGFydHN0YXJ0ZWxlbSl9cmV0dXJuIGl9O0FCQ0pTLndyaXRlLkxheW91dC5wcm90b3R5cGUucHJpbnRDbGVmPWZ1bmN0aW9uKGUpe3ZhciBmPVwiY2xlZnMuR1wiO3ZhciBjPTA7dmFyIGQ9bmV3IEFCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudChlLDAsMTApO3N3aXRjaChlLnR5cGUpe2Nhc2VcInRyZWJsZVwiOmJyZWFrO2Nhc2VcInRlbm9yXCI6Zj1cImNsZWZzLkNcIjticmVhaztjYXNlXCJhbHRvXCI6Zj1cImNsZWZzLkNcIjticmVhaztjYXNlXCJiYXNzXCI6Zj1cImNsZWZzLkZcIjticmVhaztjYXNlXCJ0cmVibGUrOFwiOmM9MTticmVhaztjYXNlXCJ0ZW5vcis4XCI6Zj1cImNsZWZzLkNcIjtjPTE7YnJlYWs7Y2FzZVwiYmFzcys4XCI6Zj1cImNsZWZzLkZcIjtjPTE7YnJlYWs7Y2FzZVwiYWx0bys4XCI6Zj1cImNsZWZzLkNcIjtjPTE7YnJlYWs7Y2FzZVwidHJlYmxlLThcIjpjPS0xO2JyZWFrO2Nhc2VcInRlbm9yLThcIjpmPVwiY2xlZnMuQ1wiO2M9LTE7YnJlYWs7Y2FzZVwiYmFzcy04XCI6Zj1cImNsZWZzLkZcIjtjPS0xO2JyZWFrO2Nhc2VcImFsdG8tOFwiOmY9XCJjbGVmcy5DXCI7Yz0tMTticmVhaztjYXNlXCJub25lXCI6Zj1cIlwiO2JyZWFrO2Nhc2VcInBlcmNcIjpmPVwiY2xlZnMucGVyY1wiO2JyZWFrO2RlZmF1bHQ6ZC5hZGRDaGlsZChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KFwiY2xlZj1cIitlLnR5cGUsMCwwLDAse3R5cGU6XCJkZWJ1Z1wifSkpfXZhciBiPTEwO2lmKGYhPT1cIlwiKXtkLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoZixiLHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGYpLGUuY2xlZlBvcykpfWlmKGMhPT0wKXt2YXIgZz0yLzM7dmFyIGE9KHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGYpLXRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwiOFwiKSpnKS8yO2QuYWRkUmlnaHQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChcIjhcIixiK2EsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoXCI4XCIpKmcsKGM+MCk/MTY6LTIse3NjYWxleDpnLHNjYWxleTpnfSkpfWlmKGUuc3RhZmZsaW5lcz09PTApe3RoaXMuc3RhZmZsaW5lcz0wfWVsc2V7dGhpcy5zdGFmZmxpbmVzPWUuc3RhZmZsaW5lc31yZXR1cm4gZH07QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5wcmludEtleVNpZ25hdHVyZT1mdW5jdGlvbihjKXt2YXIgYj1uZXcgQUJDSlMud3JpdGUuQWJzb2x1dGVFbGVtZW50KGMsMCwxMCk7dmFyIGE9MDtpZihjLmFjY2lkZW50YWxzKXt3aW5kb3cuQUJDSlMucGFyc2UuZWFjaChjLmFjY2lkZW50YWxzLGZ1bmN0aW9uKGUpe3ZhciBkPShlLmFjYz09PVwic2hhcnBcIik/XCJhY2NpZGVudGFscy5zaGFycFwiOihlLmFjYz09PVwibmF0dXJhbFwiKT9cImFjY2lkZW50YWxzLm5hdFwiOlwiYWNjaWRlbnRhbHMuZmxhdFwiO2IuYWRkUmlnaHQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChkLGEsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoZCksZS52ZXJ0aWNhbFBvcykpO2ErPXRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGQpKzJ9LHRoaXMpfXRoaXMuc3RhcnRsaW1pdGVsZW09YjtyZXR1cm4gYn07QUJDSlMud3JpdGUuTGF5b3V0LnByb3RvdHlwZS5wcmludFRpbWVTaWduYXR1cmU9ZnVuY3Rpb24oYyl7dmFyIGI9bmV3IEFCQ0pTLndyaXRlLkFic29sdXRlRWxlbWVudChjLDAsMjApO2lmKGMudHlwZT09PVwic3BlY2lmaWVkXCIpe2Zvcih2YXIgYT0wO2E8Yy52YWx1ZS5sZW5ndGg7YSsrKXtpZihhIT09MCl7Yi5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KFwiK1wiLGEqMjAtOSx0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aChcIitcIiksNykpfWlmKGMudmFsdWVbYV0uZGVuKXtiLmFkZFJpZ2h0KG5ldyBBQkNKUy53cml0ZS5SZWxhdGl2ZUVsZW1lbnQoYy52YWx1ZVthXS5udW0sYSoyMCx0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aChjLnZhbHVlW2FdLm51bS5jaGFyQXQoMCkpKmMudmFsdWVbYV0ubnVtLmxlbmd0aCw5KSk7Yi5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KGMudmFsdWVbYV0uZGVuLGEqMjAsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoYy52YWx1ZVthXS5kZW4uY2hhckF0KDApKSpjLnZhbHVlW2FdLmRlbi5sZW5ndGgsNSkpfWVsc2V7Yi5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KGMudmFsdWVbYV0ubnVtLGEqMjAsdGhpcy5nbHlwaHMuZ2V0U3ltYm9sV2lkdGgoYy52YWx1ZVthXS5udW0uY2hhckF0KDApKSpjLnZhbHVlW2FdLm51bS5sZW5ndGgsNykpfX19ZWxzZXtpZihjLnR5cGU9PT1cImNvbW1vbl90aW1lXCIpe2IuYWRkUmlnaHQobmV3IEFCQ0pTLndyaXRlLlJlbGF0aXZlRWxlbWVudChcInRpbWVzaWcuY29tbW9uXCIsMCx0aGlzLmdseXBocy5nZXRTeW1ib2xXaWR0aChcInRpbWVzaWcuY29tbW9uXCIpLDcpKX1lbHNle2lmKGMudHlwZT09PVwiY3V0X3RpbWVcIil7Yi5hZGRSaWdodChuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KFwidGltZXNpZy5jdXRcIiwwLHRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKFwidGltZXNpZy5jdXRcIiksNykpfX19dGhpcy5zdGFydGxpbWl0ZWxlbT1iO3JldHVybiBifTtpZighd2luZG93LkFCQ0pTKXt3aW5kb3cuQUJDSlM9e319aWYoIXdpbmRvdy5BQkNKUy53cml0ZSl7d2luZG93LkFCQ0pTLndyaXRlPXt9fUFCQ0pTLndyaXRlLnNwYWNpbmc9ZnVuY3Rpb24oKXt9O0FCQ0pTLndyaXRlLnNwYWNpbmcuRk9OVEVNPTM2MDtBQkNKUy53cml0ZS5zcGFjaW5nLkZPTlRTSVpFPTMwO0FCQ0pTLndyaXRlLnNwYWNpbmcuU1RFUD1BQkNKUy53cml0ZS5zcGFjaW5nLkZPTlRTSVpFKjkzLzcyMDtBQkNKUy53cml0ZS5zcGFjaW5nLlNQQUNFPTEwO0FCQ0pTLndyaXRlLnNwYWNpbmcuVE9QTk9URT0yMDtBQkNKUy53cml0ZS5zcGFjaW5nLlNUQVZFSEVJR0hUPTEwMDtBQkNKUy53cml0ZS5QcmludGVyPWZ1bmN0aW9uKGIsYSl7YT1hfHx7fTt0aGlzLnk9MDt0aGlzLnBhcGVyPWI7dGhpcy5zcGFjZT0zKkFCQ0pTLndyaXRlLnNwYWNpbmcuU1BBQ0U7dGhpcy5nbHlwaHM9bmV3IEFCQ0pTLndyaXRlLkdseXBocygpO3RoaXMubGlzdGVuZXJzPVtdO3RoaXMuc2VsZWN0ZWQ9W107dGhpcy5pbmdyb3VwPWZhbHNlO3RoaXMuc2NhbGU9YS5zY2FsZXx8MTt0aGlzLnN0YWZmd2lkdGg9YS5zdGFmZndpZHRofHw3NDA7dGhpcy5wYWRkaW5ndG9wPWEucGFkZGluZ3RvcHx8MTU7dGhpcy5wYWRkaW5nYm90dG9tPWEucGFkZGluZ2JvdHRvbXx8MzA7dGhpcy5wYWRkaW5ncmlnaHQ9YS5wYWRkaW5ncmlnaHR8fDUwO3RoaXMucGFkZGluZ2xlZnQ9YS5wYWRkaW5nbGVmdHx8MTU7dGhpcy5lZGl0YWJsZT1hLmVkaXRhYmxlfHxmYWxzZX07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUubm90aWZ5U2VsZWN0PWZ1bmN0aW9uKGIpe3RoaXMuY2xlYXJTZWxlY3Rpb24oKTt0aGlzLnNlbGVjdGVkPVtiXTtiLmhpZ2hsaWdodCgpO2Zvcih2YXIgYT0wO2E8dGhpcy5saXN0ZW5lcnMubGVuZ3RoO2ErKyl7dGhpcy5saXN0ZW5lcnNbYV0uaGlnaGxpZ2h0KGIuYWJjZWxlbSl9fTtBQkNKUy53cml0ZS5QcmludGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2U9ZnVuY3Rpb24oYil7Zm9yKHZhciBhPTA7YTx0aGlzLmxpc3RlbmVycy5sZW5ndGg7YSsrKXt0aGlzLmxpc3RlbmVyc1thXS5tb2RlbENoYW5nZWQoKX19O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLmNsZWFyU2VsZWN0aW9uPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTx0aGlzLnNlbGVjdGVkLmxlbmd0aDthKyspe3RoaXMuc2VsZWN0ZWRbYV0udW5oaWdobGlnaHQoKX10aGlzLnNlbGVjdGVkPVtdfTtBQkNKUy53cml0ZS5QcmludGVyLnByb3RvdHlwZS5hZGRTZWxlY3RMaXN0ZW5lcj1mdW5jdGlvbihhKXt0aGlzLmxpc3RlbmVyc1t0aGlzLmxpc3RlbmVycy5sZW5ndGhdPWF9O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLnJhbmdlSGlnaGxpZ2h0PWZ1bmN0aW9uKGIsZCl7dGhpcy5jbGVhclNlbGVjdGlvbigpO2Zvcih2YXIgaT0wO2k8dGhpcy5zdGFmZmdyb3Vwcy5sZW5ndGg7aSsrKXt2YXIgZj10aGlzLnN0YWZmZ3JvdXBzW2ldLnZvaWNlcztmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGE9ZltnXS5jaGlsZHJlbjtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGg9YVtjXS5hYmNlbGVtLnN0YXJ0Q2hhcjt2YXIgZT1hW2NdLmFiY2VsZW0uZW5kQ2hhcjtpZigoZD5oJiZiPGUpfHwoKGQ9PT1iKSYmZD09PWUpKXt0aGlzLnNlbGVjdGVkW3RoaXMuc2VsZWN0ZWQubGVuZ3RoXT1hW2NdO2FbY10uaGlnaGxpZ2h0KCl9fX19fTtBQkNKUy53cml0ZS5QcmludGVyLnByb3RvdHlwZS5iZWdpbkdyb3VwPWZ1bmN0aW9uKCl7dGhpcy5wYXRoPVtdO3RoaXMubGFzdE09WzAsMF07dGhpcy5pbmdyb3VwPXRydWV9O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLmFkZFBhdGg9ZnVuY3Rpb24oYyl7Yz1jfHxbXTtpZihjLmxlbmd0aD09PTApe3JldHVybn1jWzBdWzBdPVwibVwiO2NbMF1bMV0tPXRoaXMubGFzdE1bMF07Y1swXVsyXS09dGhpcy5sYXN0TVsxXTt0aGlzLmxhc3RNWzBdKz1jWzBdWzFdO3RoaXMubGFzdE1bMV0rPWNbMF1bMl07dGhpcy5wYXRoLnB1c2goY1swXSk7Zm9yKHZhciBhPTEsYj1jLmxlbmd0aDthPGI7YSsrKXtpZihjW2FdWzBdPT09XCJtXCIpe3RoaXMubGFzdE1bMF0rPWNbYV1bMV07dGhpcy5sYXN0TVsxXSs9Y1thXVsyXX10aGlzLnBhdGgucHVzaChjW2FdKX19O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLmVuZEdyb3VwPWZ1bmN0aW9uKCl7dGhpcy5pbmdyb3VwPWZhbHNlO2lmKHRoaXMucGF0aC5sZW5ndGg9PT0wKXtyZXR1cm4gbnVsbH12YXIgYT10aGlzLnBhcGVyLnBhdGgoKS5hdHRyKHtwYXRoOnRoaXMucGF0aCxzdHJva2U6XCJub25lXCIsZmlsbDpcIiMwMDAwMDBcIn0pO2lmKHRoaXMuc2NhbGUhPT0xKXthLnNjYWxlKHRoaXMuc2NhbGUsdGhpcy5zY2FsZSwwLDApfXJldHVybiBhfTtBQkNKUy53cml0ZS5QcmludGVyLnByb3RvdHlwZS5wcmludFN0YXZlTGluZT1mdW5jdGlvbih4MSx4MixwaXRjaCl7dmFyIGlzSUU9XG4vKkBjY19vbiFAKi9cbmZhbHNlO3ZhciBkeT0wLjM1O3ZhciBmaWxsPVwiIzAwMDAwMFwiO2lmKGlzSUUpe2R5PTE7ZmlsbD1cIiM2NjY2NjZcIn12YXIgeT10aGlzLmNhbGNZKHBpdGNoKTt2YXIgcGF0aFN0cmluZz1BQkNKUy53cml0ZS5zcHJpbnRmKFwiTSAlZiAlZiBMICVmICVmIEwgJWYgJWYgTCAlZiAlZiB6XCIseDEseS1keSx4Mix5LWR5LHgyLHkrZHkseDEseStkeSk7dmFyIHJldD10aGlzLnBhcGVyLnBhdGgoKS5hdHRyKHtwYXRoOnBhdGhTdHJpbmcsc3Ryb2tlOlwibm9uZVwiLGZpbGw6ZmlsbH0pLnRvQmFjaygpO2lmKHRoaXMuc2NhbGUhPT0xKXtyZXQuc2NhbGUodGhpcy5zY2FsZSx0aGlzLnNjYWxlLDAsMCl9cmV0dXJuIHJldH07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUucHJpbnRTdGVtPWZ1bmN0aW9uKHgsZHgseTEseTIpe2lmKGR4PDApe3ZhciB0bXA9eTI7eTI9eTE7eTE9dG1wfXZhciBpc0lFPVxuLypAY2Nfb24hQCovXG5mYWxzZTt2YXIgZmlsbD1cIiMwMDAwMDBcIjtpZihpc0lFJiZkeDwxKXtkeD0xO2ZpbGw9XCIjNjY2NjY2XCJ9aWYofn54PT09eCl7eCs9MC4wNX12YXIgcGF0aEFycmF5PVtbXCJNXCIseCx5MV0sW1wiTFwiLHgseTJdLFtcIkxcIix4K2R4LHkyXSxbXCJMXCIseCtkeCx5MV0sW1wielwiXV07aWYoIWlzSUUmJnRoaXMuaW5ncm91cCl7dGhpcy5hZGRQYXRoKHBhdGhBcnJheSl9ZWxzZXt2YXIgcmV0PXRoaXMucGFwZXIucGF0aCgpLmF0dHIoe3BhdGg6cGF0aEFycmF5LHN0cm9rZTpcIm5vbmVcIixmaWxsOmZpbGx9KS50b0JhY2soKTtpZih0aGlzLnNjYWxlIT09MSl7cmV0LnNjYWxlKHRoaXMuc2NhbGUsdGhpcy5zY2FsZSwwLDApXG59cmV0dXJuIHJldH19O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLnByaW50VGV4dD1mdW5jdGlvbihhLGUsZCxjKXtjPWN8fFwic3RhcnRcIjt2YXIgYj10aGlzLnBhcGVyLnRleHQoYSp0aGlzLnNjYWxlLHRoaXMuY2FsY1koZSkqdGhpcy5zY2FsZSxkKS5hdHRyKHtcInRleHQtYW5jaG9yXCI6YyxcImZvbnQtc2l6ZVwiOjEyKnRoaXMuc2NhbGV9KTtyZXR1cm4gYn07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUucHJpbnRTeW1ib2w9ZnVuY3Rpb24oaixkLGMsZyxmKXt2YXIgYjtpZighYyl7cmV0dXJuIG51bGx9aWYoYy5sZW5ndGg+MCYmYy5pbmRleE9mKFwiLlwiKTwwKXt2YXIgaD10aGlzLnBhcGVyLnNldCgpO3ZhciBrPTA7Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBhPXRoaXMuZ2x5cGhzLmdldFlDb3JyKGMuY2hhckF0KGUpKTtiPXRoaXMuZ2x5cGhzLnByaW50U3ltYm9sKGorayx0aGlzLmNhbGNZKGQrYSksYy5jaGFyQXQoZSksdGhpcy5wYXBlcik7aWYoYil7aC5wdXNoKGIpO2srPXRoaXMuZ2x5cGhzLmdldFN5bWJvbFdpZHRoKGMuY2hhckF0KGUpKX1lbHNle3RoaXMuZGVidWdNc2coaixcIm5vIHN5bWJvbDpcIitjKX19aWYodGhpcy5zY2FsZSE9PTEpe2guc2NhbGUodGhpcy5zY2FsZSx0aGlzLnNjYWxlLDAsMCl9cmV0dXJuIGh9ZWxzZXt2YXIgYT10aGlzLmdseXBocy5nZXRZQ29ycihjKTtpZih0aGlzLmluZ3JvdXApe3RoaXMuYWRkUGF0aCh0aGlzLmdseXBocy5nZXRQYXRoRm9yU3ltYm9sKGosdGhpcy5jYWxjWShkK2EpLGMsZyxmKSl9ZWxzZXtiPXRoaXMuZ2x5cGhzLnByaW50U3ltYm9sKGosdGhpcy5jYWxjWShkK2EpLGMsdGhpcy5wYXBlcik7aWYoYil7aWYodGhpcy5zY2FsZSE9PTEpe2Iuc2NhbGUodGhpcy5zY2FsZSx0aGlzLnNjYWxlLDAsMCl9cmV0dXJuIGJ9ZWxzZXt0aGlzLmRlYnVnTXNnKGosXCJubyBzeW1ib2w6XCIrYyl9fXJldHVybiBudWxsfX07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUucHJpbnRQYXRoPWZ1bmN0aW9uKGIpe3ZhciBhPXRoaXMucGFwZXIucGF0aCgpLmF0dHIoYik7aWYodGhpcy5zY2FsZSE9PTEpe2Euc2NhbGUodGhpcy5zY2FsZSx0aGlzLnNjYWxlLDAsMCl9cmV0dXJuIGF9O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLmRyYXdBcmM9ZnVuY3Rpb24obixtLHEscCxvKXtuPW4rNjttPW0rNDtxPXErKChvKT8xLjU6LTEuNSk7cD1wKygobyk/MS41Oi0xLjUpO3ZhciBjPXRoaXMuY2FsY1kocSk7dmFyIGI9dGhpcy5jYWxjWShwKTt2YXIgaD1tLW47dmFyIGc9Yi1jO3ZhciBmPU1hdGguc3FydChoKmgrZypnKTt2YXIgZT1oL2Y7dmFyIGQ9Zy9mO3ZhciB1PWYvMy41O3ZhciBpPSgobyk/LTE6MSkqTWF0aC5taW4oMjUsTWF0aC5tYXgoNCx1KSk7dmFyIGw9bit1KmUtaSpkO3ZhciB0PWMrdSpkK2kqZTt2YXIgaj1tLXUqZS1pKmQ7dmFyIHI9Yi11KmQraSplO3ZhciBhPTI7dmFyIGs9QUJDSlMud3JpdGUuc3ByaW50ZihcIk0gJWYgJWYgQyAlZiAlZiAlZiAlZiAlZiAlZiBDICVmICVmICVmICVmICVmICVmIHpcIixuLGMsbCx0LGoscixtLGIsai1hKmQscithKmUsbC1hKmQsdCthKmUsbixjKTt2YXIgcz10aGlzLnBhcGVyLnBhdGgoKS5hdHRyKHtwYXRoOmssc3Ryb2tlOlwibm9uZVwiLGZpbGw6XCIjMDAwMDAwXCJ9KTtpZih0aGlzLnNjYWxlIT09MSl7cy5zY2FsZSh0aGlzLnNjYWxlLHRoaXMuc2NhbGUsMCwwKX1yZXR1cm4gc307QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUuZGVidWdNc2c9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wYXBlci50ZXh0KGEsdGhpcy55LGIpLnNjYWxlKHRoaXMuc2NhbGUsdGhpcy5zY2FsZSwwLDApfTtBQkNKUy53cml0ZS5QcmludGVyLnByb3RvdHlwZS5kZWJ1Z01zZ0xvdz1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnBhcGVyLnRleHQoYSx0aGlzLmNhbGNZKHRoaXMubGF5b3V0ZXIubWluWS03KSxiKS5hdHRyKHtcImZvbnQtZmFtaWx5XCI6XCJzZXJpZlwiLFwiZm9udC1zaXplXCI6MTIsXCJ0ZXh0LWFuY2hvclwiOlwiYmVnaW5cIn0pLnNjYWxlKHRoaXMuc2NhbGUsdGhpcy5zY2FsZSwwLDApfTtBQkNKUy53cml0ZS5QcmludGVyLnByb3RvdHlwZS5wcmludEx5cmljcz1mdW5jdGlvbihhLGMpe3ZhciBiPXRoaXMucGFwZXIudGV4dChhLHRoaXMuY2FsY1kodGhpcy5sYXlvdXRlci5taW5ZLTcpLGMpLmF0dHIoe1wiZm9udC1mYW1pbHlcIjpcIlRpbWVzIE5ldyBSb21hblwiLFwiZm9udC13ZWlnaHRcIjpcImJvbGRcIixcImZvbnQtc2l6ZVwiOjE0LFwidGV4dC1hbmNob3JcIjpcImJlZ2luXCJ9KS5zY2FsZSh0aGlzLnNjYWxlLHRoaXMuc2NhbGUsMCwwKTtiWzBdLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJhYmMtbHlyaWNcIik7cmV0dXJuIGJ9O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLmNhbGNZPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnkrKChBQkNKUy53cml0ZS5zcGFjaW5nLlRPUE5PVEUtYSkqQUJDSlMud3JpdGUuc3BhY2luZy5TVEVQKX07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUucHJpbnRTdGF2ZT1mdW5jdGlvbihhLGQsYil7aWYoYj09PTEpe3RoaXMucHJpbnRTdGF2ZUxpbmUoYSxkLDYpO3JldHVybn1mb3IodmFyIGM9MDtjPGI7YysrKXt0aGlzLnByaW50U3RhdmVMaW5lKGEsZCwoYysxKSoyKX19O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLnByaW50QUJDPWZ1bmN0aW9uKGEpe2lmKGFbMF09PT11bmRlZmluZWQpe2E9W2FdfXRoaXMueT0wO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt0aGlzLnByaW50VHVuZShhW2JdKX19O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLnByaW50VGVtcG89ZnVuY3Rpb24odCxrLHEsaCxlLGope3ZhciBmPXtcInRleHQtYW5jaG9yXCI6XCJzdGFydFwiLFwiZm9udC1zaXplXCI6MTIqZS5zY2FsZSxcImZvbnQtd2VpZ2h0XCI6XCJib2xkXCJ9O2lmKHQucHJlU3RyaW5nKXt2YXIgbz1rLnRleHQoaiplLnNjYWxlLGgqZS5zY2FsZSsyMCplLnNjYWxlLHQucHJlU3RyaW5nKS5hdHRyKGYpO2orPShvLmdldEJCb3goKS53aWR0aCsyMCplLnNjYWxlKX1pZih0LmR1cmF0aW9uKXt2YXIgZz0wLjc1KmUuc2NhbGU7dmFyIHc9MTQuNTt2YXIgYT10LmR1cmF0aW9uWzBdO3ZhciBuPW5ldyBBQkNKUy53cml0ZS5BYnNvbHV0ZUVsZW1lbnQodCxhLDEpO3ZhciB1PU1hdGguZmxvb3IoTWF0aC5sb2coYSkvTWF0aC5sb2coMikpO3ZhciByPTA7Zm9yKHZhciBtPU1hdGgucG93KDIsdSksaT1tLzI7bTxhO3IrKyxtKz1pLGkvPTIpe312YXIgej1xLmNoYXJ0YWJsZS5ub3RlWy11XTt2YXIgdj1xLmNoYXJ0YWJsZS51ZmxhZ3NbLXVdO3ZhciBwPXEucHJpbnROb3RlSGVhZChuLHose3ZlcnRpY2FsUG9zOnd9LFwidXBcIiwwLDAsdixyLDAsZyk7bi5hZGRIZWFkKHApO2lmKGE8MSl7dmFyIGQ9dysxLzMqZzt2YXIgYj13KzcqZzt2YXIgbD1wLmR4K3Audzt2YXIgcz0tMC42KmUuc2NhbGU7bi5hZGRFeHRyYShuZXcgQUJDSlMud3JpdGUuUmVsYXRpdmVFbGVtZW50KG51bGwsbCwwLGQse3R5cGU6XCJzdGVtXCIscGl0Y2gyOmIsbGluZXdpZHRoOnN9KSl9bi54PWoqKDEvZS5zY2FsZSk7bi5kcmF3KGUsbnVsbCk7ais9KG4udys1KmUuc2NhbGUpO289ay50ZXh0KGosaCplLnNjYWxlKzIwKmUuc2NhbGUsXCI9IFwiK3QuYnBtKS5hdHRyKGYpO2orPW8uZ2V0QkJveCgpLndpZHRoKzEwKmUuc2NhbGV9aWYodC5wb3N0U3RyaW5nKXtrLnRleHQoaixoKmUuc2NhbGUrMjAqZS5zY2FsZSx0LnBvc3RTdHJpbmcpLmF0dHIoZil9aCs9MTUqZS5zY2FsZTtyZXR1cm4gaH07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUucHJpbnRUdW5lPWZ1bmN0aW9uKGFiY3R1bmUpe3RoaXMubGF5b3V0ZXI9bmV3IEFCQ0pTLndyaXRlLkxheW91dCh0aGlzLmdseXBocyxhYmN0dW5lLmZvcm1hdHRpbmcuYmFncGlwZXMpO3RoaXMubGF5b3V0ZXIucHJpbnRlcj10aGlzO2lmKGFiY3R1bmUubWVkaWE9PT1cInByaW50XCIpe3ZhciBtPWFiY3R1bmUuZm9ybWF0dGluZy50b3BtYXJnaW49PT11bmRlZmluZWQ/NTQ6YWJjdHVuZS5mb3JtYXR0aW5nLnRvcG1hcmdpbjt0aGlzLnkrPW19ZWxzZXt0aGlzLnkrPXRoaXMucGFkZGluZ3RvcH1pZihhYmN0dW5lLmZvcm1hdHRpbmcuc3RhZmZ3aWR0aCl7dGhpcy53aWR0aD1hYmN0dW5lLmZvcm1hdHRpbmcuc3RhZmZ3aWR0aH1lbHNle3RoaXMud2lkdGg9dGhpcy5zdGFmZndpZHRofXRoaXMud2lkdGgrPXRoaXMucGFkZGluZ2xlZnQ7aWYoYWJjdHVuZS5mb3JtYXR0aW5nLnNjYWxlKXt0aGlzLnNjYWxlPWFiY3R1bmUuZm9ybWF0dGluZy5zY2FsZX1pZihhYmN0dW5lLm1ldGFUZXh0LnRpdGxlKXt0aGlzLnBhcGVyLnRleHQodGhpcy53aWR0aCp0aGlzLnNjYWxlLzIsdGhpcy55LGFiY3R1bmUubWV0YVRleHQudGl0bGUpLmF0dHIoe1wiZm9udC1zaXplXCI6MjAqdGhpcy5zY2FsZSxcImZvbnQtZmFtaWx5XCI6XCJzZXJpZlwifSl9dGhpcy55Kz0yMCp0aGlzLnNjYWxlO2lmKGFiY3R1bmUubGluZXNbMF0mJmFiY3R1bmUubGluZXNbMF0uc3VidGl0bGUpe3RoaXMucHJpbnRTdWJ0aXRsZUxpbmUoYWJjdHVuZS5saW5lc1swXSk7dGhpcy55Kz0yMCp0aGlzLnNjYWxlfWlmKGFiY3R1bmUubWV0YVRleHQucmh5dGhtKXt0aGlzLnBhcGVyLnRleHQodGhpcy5wYWRkaW5nbGVmdCx0aGlzLnksYWJjdHVuZS5tZXRhVGV4dC5yaHl0aG0pLmF0dHIoe1widGV4dC1hbmNob3JcIjpcInN0YXJ0XCIsXCJmb250LXN0eWxlXCI6XCJpdGFsaWNcIixcImZvbnQtZmFtaWx5XCI6XCJzZXJpZlwiLFwiZm9udC1zaXplXCI6MTIqdGhpcy5zY2FsZX0pOyEoYWJjdHVuZS5tZXRhVGV4dC5hdXRob3J8fGFiY3R1bmUubWV0YVRleHQub3JpZ2lufHxhYmN0dW5lLm1ldGFUZXh0LmNvbXBvc2VyKSYmKHRoaXMueSs9MTUqdGhpcy5zY2FsZSl9dmFyIGNvbXBvc2VyTGluZT1cIlwiO2lmKGFiY3R1bmUubWV0YVRleHQuY29tcG9zZXIpe2NvbXBvc2VyTGluZSs9YWJjdHVuZS5tZXRhVGV4dC5jb21wb3Nlcn1pZihhYmN0dW5lLm1ldGFUZXh0Lm9yaWdpbil7Y29tcG9zZXJMaW5lKz1cIiAoXCIrYWJjdHVuZS5tZXRhVGV4dC5vcmlnaW4rXCIpXCJ9aWYoY29tcG9zZXJMaW5lLmxlbmd0aD4wKXt0aGlzLnBhcGVyLnRleHQodGhpcy53aWR0aCp0aGlzLnNjYWxlLHRoaXMueSxjb21wb3NlckxpbmUpLmF0dHIoe1widGV4dC1hbmNob3JcIjpcImVuZFwiLFwiZm9udC1zdHlsZVwiOlwiaXRhbGljXCIsXCJmb250LWZhbWlseVwiOlwic2VyaWZcIixcImZvbnQtc2l6ZVwiOjEyKnRoaXMuc2NhbGV9KTt0aGlzLnkrPTE1fWlmKGFiY3R1bmUubWV0YVRleHQuYXV0aG9yKXt0aGlzLnBhcGVyLnRleHQodGhpcy53aWR0aCp0aGlzLnNjYWxlLHRoaXMueSxhYmN0dW5lLm1ldGFUZXh0LmF1dGhvcikuYXR0cih7XCJ0ZXh0LWFuY2hvclwiOlwiZW5kXCIsXCJmb250LXN0eWxlXCI6XCJpdGFsaWNcIixcImZvbnQtZmFtaWx5XCI6XCJzZXJpZlwiLFwiZm9udC1zaXplXCI6MTIqdGhpcy5zY2FsZX0pO3RoaXMueSs9MTV9aWYoYWJjdHVuZS5tZXRhVGV4dC50ZW1wbyYmIWFiY3R1bmUubWV0YVRleHQudGVtcG8uc3VwcHJlc3Mpe3RoaXMueT10aGlzLnByaW50VGVtcG8oYWJjdHVuZS5tZXRhVGV4dC50ZW1wbyx0aGlzLnBhcGVyLHRoaXMubGF5b3V0ZXIsdGhpcy55LHRoaXMsNTApO3RoaXMueSs9MjAqdGhpcy5zY2FsZX10aGlzLnN0YWZmZ3JvdXBzPVtdO3ZhciBtYXh3aWR0aD10aGlzLndpZHRoO2Zvcih2YXIgbGluZT0wO2xpbmU8YWJjdHVuZS5saW5lcy5sZW5ndGg7bGluZSsrKXt2YXIgYWJjbGluZT1hYmN0dW5lLmxpbmVzW2xpbmVdO2lmKGFiY2xpbmUuc3RhZmYpe3N0YWZmZ3JvdXA9dGhpcy5wcmludFN0YWZmTGluZShhYmN0dW5lLGFiY2xpbmUsbGluZSk7aWYoc3RhZmZncm91cC53Pm1heHdpZHRoKXttYXh3aWR0aD1zdGFmZmdyb3VwLnd9fWVsc2V7aWYoYWJjbGluZS5zdWJ0aXRsZSYmbGluZSE9PTApe3RoaXMucHJpbnRTdWJ0aXRsZUxpbmUoYWJjbGluZSk7dGhpcy55Kz0yMCp0aGlzLnNjYWxlfWVsc2V7aWYoYWJjbGluZS50ZXh0KXtpZih0eXBlb2YgYWJjbGluZS50ZXh0PT09XCJzdHJpbmdcIil7dGhpcy5wYXBlci50ZXh0KDEwMCx0aGlzLnksXCJURVhUOiBcIithYmNsaW5lLnRleHQpfWVsc2V7dmFyIHN0cj1cIlwiO2Zvcih2YXIgaT0wO2k8YWJjbGluZS50ZXh0Lmxlbmd0aDtpKyspe3N0cis9XCIgRk9OVCBcIithYmNsaW5lLnRleHRbaV0udGV4dH10aGlzLnBhcGVyLnRleHQoMTAwLHRoaXMueSxcIlRFWFQ6IFwiK3N0cil9dGhpcy55Kz0yMCp0aGlzLnNjYWxlfX19fXZhciBleHRyYVRleHQ9XCJcIjt2YXIgdGV4dDI7dmFyIGhlaWdodDtpZihhYmN0dW5lLm1ldGFUZXh0LnBhcnRPcmRlcil7ZXh0cmFUZXh0Kz1cIlBhcnQgT3JkZXI6IFwiK2FiY3R1bmUubWV0YVRleHQucGFydE9yZGVyK1wiXFxuXCJ9aWYoYWJjdHVuZS5tZXRhVGV4dC51bmFsaWduZWRXb3Jkcyl7Zm9yKHZhciBqPTA7ajxhYmN0dW5lLm1ldGFUZXh0LnVuYWxpZ25lZFdvcmRzLmxlbmd0aDtqKyspe2lmKHR5cGVvZiBhYmN0dW5lLm1ldGFUZXh0LnVuYWxpZ25lZFdvcmRzW2pdPT09XCJzdHJpbmdcIil7ZXh0cmFUZXh0Kz1hYmN0dW5lLm1ldGFUZXh0LnVuYWxpZ25lZFdvcmRzW2pdK1wiXFxuXCJ9ZWxzZXtmb3IodmFyIGs9MDtrPGFiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHNbal0ubGVuZ3RoO2srKyl7ZXh0cmFUZXh0Kz1cIiBGT05UIFwiK2FiY3R1bmUubWV0YVRleHQudW5hbGlnbmVkV29yZHNbal1ba10udGV4dH1leHRyYVRleHQrPVwiXFxuXCJ9fXRleHQyPXRoaXMucGFwZXIudGV4dCh0aGlzLnBhZGRpbmdsZWZ0KnRoaXMuc2NhbGUrNTAqdGhpcy5zY2FsZSx0aGlzLnkqdGhpcy5zY2FsZSsyNSp0aGlzLnNjYWxlLGV4dHJhVGV4dCkuYXR0cih7XCJ0ZXh0LWFuY2hvclwiOlwic3RhcnRcIixcImZvbnQtZmFtaWx5XCI6XCJzZXJpZlwiLFwiZm9udC1zaXplXCI6MTcqdGhpcy5zY2FsZX0pO2hlaWdodD10ZXh0Mi5nZXRCQm94KCkuaGVpZ2h0KzE3KnRoaXMuc2NhbGU7dGV4dDIudHJhbnNsYXRlKDAsaGVpZ2h0LzIpO3RoaXMueSs9aGVpZ2h0O2V4dHJhVGV4dD1cIlwifWlmKGFiY3R1bmUubWV0YVRleHQuYm9vayl7ZXh0cmFUZXh0Kz1cIkJvb2s6IFwiK2FiY3R1bmUubWV0YVRleHQuYm9vaytcIlxcblwifWlmKGFiY3R1bmUubWV0YVRleHQuc291cmNlKXtleHRyYVRleHQrPVwiU291cmNlOiBcIithYmN0dW5lLm1ldGFUZXh0LnNvdXJjZStcIlxcblwiXG59aWYoYWJjdHVuZS5tZXRhVGV4dC5kaXNjb2dyYXBoeSl7ZXh0cmFUZXh0Kz1cIkRpc2NvZ3JhcGh5OiBcIithYmN0dW5lLm1ldGFUZXh0LmRpc2NvZ3JhcGh5K1wiXFxuXCJ9aWYoYWJjdHVuZS5tZXRhVGV4dC5ub3Rlcyl7ZXh0cmFUZXh0Kz1cIk5vdGVzOiBcIithYmN0dW5lLm1ldGFUZXh0Lm5vdGVzK1wiXFxuXCJ9aWYoYWJjdHVuZS5tZXRhVGV4dC50cmFuc2NyaXB0aW9uKXtleHRyYVRleHQrPVwiVHJhbnNjcmlwdGlvbjogXCIrYWJjdHVuZS5tZXRhVGV4dC50cmFuc2NyaXB0aW9uK1wiXFxuXCJ9aWYoYWJjdHVuZS5tZXRhVGV4dC5oaXN0b3J5KXtleHRyYVRleHQrPVwiSGlzdG9yeTogXCIrYWJjdHVuZS5tZXRhVGV4dC5oaXN0b3J5K1wiXFxuXCJ9dGV4dDI9dGhpcy5wYXBlci50ZXh0KHRoaXMucGFkZGluZ2xlZnQsdGhpcy55KnRoaXMuc2NhbGUrMjUqdGhpcy5zY2FsZSxleHRyYVRleHQpLmF0dHIoe1widGV4dC1hbmNob3JcIjpcInN0YXJ0XCIsXCJmb250LWZhbWlseVwiOlwic2VyaWZcIixcImZvbnQtc2l6ZVwiOjE3KnRoaXMuc2NhbGV9KTtoZWlnaHQ9dGV4dDIuZ2V0QkJveCgpLmhlaWdodDtpZighaGVpZ2h0KXtoZWlnaHQ9MjUqdGhpcy5zY2FsZX10ZXh0Mi50cmFuc2xhdGUoMCxoZWlnaHQvMik7dGhpcy55Kz0yNSp0aGlzLnNjYWxlK2hlaWdodCp0aGlzLnNjYWxlO3ZhciBzaXpldG9zZXQ9e3c6KG1heHdpZHRoK3RoaXMucGFkZGluZ3JpZ2h0KSp0aGlzLnNjYWxlLGg6KHRoaXMueSt0aGlzLnBhZGRpbmdib3R0b20pKnRoaXMuc2NhbGV9O3RoaXMucGFwZXIuc2V0U2l6ZShzaXpldG9zZXQudyxzaXpldG9zZXQuaCk7dmFyIGlzSUU9XG4vKkBjY19vbiFAKi9cbmZhbHNlO2lmKGlzSUUpe3RoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUuc3R5bGUud2lkdGg9c2l6ZXRvc2V0LncrXCJweFwiO3RoaXMucGFwZXIuY2FudmFzLnBhcmVudE5vZGUuc3R5bGUuaGVpZ2h0PVwiXCIrc2l6ZXRvc2V0LmgrXCJweFwifWVsc2V7dGhpcy5wYXBlci5jYW52YXMucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwid2lkdGg6XCIrc2l6ZXRvc2V0LncrXCJweFwiKX19O0FCQ0pTLndyaXRlLlByaW50ZXIucHJvdG90eXBlLnByaW50U3VidGl0bGVMaW5lPWZ1bmN0aW9uKGEpe3RoaXMucGFwZXIudGV4dCh0aGlzLndpZHRoLzIsdGhpcy55LGEuc3VidGl0bGUpLmF0dHIoe1wiZm9udC1zaXplXCI6MTZ9KS5zY2FsZSh0aGlzLnNjYWxlLHRoaXMuc2NhbGUsMCwwKX07QUJDSlMud3JpdGUuUHJpbnRlci5wcm90b3R5cGUucHJpbnRTdGFmZkxpbmU9ZnVuY3Rpb24oZyxkLGIpe3ZhciBoPXRoaXMubGF5b3V0ZXIucHJpbnRBQkNMaW5lKGQuc3RhZmYpO3ZhciBjPXRoaXMuc3BhY2U7Zm9yKHZhciBmPTA7ZjwzO2YrKyl7aC5sYXlvdXQoYyx0aGlzLGZhbHNlKTtpZihiJiZiPT09Zy5saW5lcy5sZW5ndGgtMSYmaC53L3RoaXMud2lkdGg8MC42NiYmIWcuZm9ybWF0dGluZy5zdHJldGNobGFzdCl7YnJlYWt9dmFyIGE9aC5zcGFjaW5ndW5pdHMqYzt2YXIgZT1oLnctYTtpZihoLnNwYWNpbmd1bml0cz4wKXtjPSh0aGlzLndpZHRoLWUpL2guc3BhY2luZ3VuaXRzO2lmKGMqaC5taW5zcGFjZT41MCl7Yz01MC9oLm1pbnNwYWNlfX19aC5kcmF3KHRoaXMsdGhpcy55KTt0aGlzLnN0YWZmZ3JvdXBzW3RoaXMuc3RhZmZncm91cHMubGVuZ3RoXT1oO3RoaXMueT1oLnkraC5oZWlnaHQ7dGhpcy55Kz1BQkNKUy53cml0ZS5zcGFjaW5nLlNUQVZFSEVJR0hUKjAuMjtyZXR1cm4gaH07aWYoIXdpbmRvdy5BQkNKUyl7d2luZG93LkFCQ0pTPXt9fWlmKCF3aW5kb3cuQUJDSlMud3JpdGUpe3dpbmRvdy5BQkNKUy53cml0ZT17fX1BQkNKUy53cml0ZS5zcHJpbnRmPWZ1bmN0aW9uKCl7dmFyIGc9MCxlLGg9YXJndW1lbnRzW2crK10saz1bXSxkLGosbCxiO3doaWxlKGgpe2lmKGQ9L15bXlxceDI1XSsvLmV4ZWMoaCkpe2sucHVzaChkWzBdKX1lbHNle2lmKGQ9L15cXHgyNXsyfS8uZXhlYyhoKSl7ay5wdXNoKFwiJVwiKX1lbHNle2lmKGQ9L15cXHgyNSg/OihcXGQrKVxcJCk/KFxcKyk/KDB8J1teJF0pPygtKT8oXFxkKyk/KD86XFwuKFxcZCspKT8oW2ItZm9zdXhYXSkvLmV4ZWMoaCkpe2lmKCgoZT1hcmd1bWVudHNbZFsxXXx8ZysrXSk9PW51bGwpfHwoZT09dW5kZWZpbmVkKSl7dGhyb3cgKFwiVG9vIGZldyBhcmd1bWVudHMuXCIpfWlmKC9bXnNdLy50ZXN0KGRbN10pJiYodHlwZW9mKGUpIT1cIm51bWJlclwiKSl7dGhyb3cgKFwiRXhwZWN0aW5nIG51bWJlciBidXQgZm91bmQgXCIrdHlwZW9mKGUpKX1zd2l0Y2goZFs3XSl7Y2FzZVwiYlwiOmU9ZS50b1N0cmluZygyKTticmVhaztjYXNlXCJjXCI6ZT1TdHJpbmcuZnJvbUNoYXJDb2RlKGUpO2JyZWFrO2Nhc2VcImRcIjplPXBhcnNlSW50KGUpO2JyZWFrO2Nhc2VcImVcIjplPWRbNl0/ZS50b0V4cG9uZW50aWFsKGRbNl0pOmUudG9FeHBvbmVudGlhbCgpO2JyZWFrO2Nhc2VcImZcIjplPWRbNl0/cGFyc2VGbG9hdChlKS50b0ZpeGVkKGRbNl0pOnBhcnNlRmxvYXQoZSk7YnJlYWs7Y2FzZVwib1wiOmU9ZS50b1N0cmluZyg4KTticmVhaztjYXNlXCJzXCI6ZT0oKGU9U3RyaW5nKGUpKSYmZFs2XT9lLnN1YnN0cmluZygwLGRbNl0pOmUpO2JyZWFrO2Nhc2VcInVcIjplPU1hdGguYWJzKGUpO2JyZWFrO2Nhc2VcInhcIjplPWUudG9TdHJpbmcoMTYpO2JyZWFrO2Nhc2VcIlhcIjplPWUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7YnJlYWt9ZT0oL1tkZWZdLy50ZXN0KGRbN10pJiZkWzJdJiZlPjA/XCIrXCIrZTplKTtsPWRbM10/ZFszXT09XCIwXCI/XCIwXCI6ZFszXS5jaGFyQXQoMSk6XCIgXCI7Yj1kWzVdLVN0cmluZyhlKS5sZW5ndGg7aj1kWzVdP3N0cl9yZXBlYXQobCxiKTpcIlwiO2sucHVzaChkWzRdP2UrajpqK2UpfWVsc2V7dGhyb3cgKFwiSHVoID8hXCIpfX19aD1oLnN1YnN0cmluZyhkWzBdLmxlbmd0aCl9cmV0dXJuIGsuam9pbihcIlwiKX07XG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBBQkNKUyAhPSBcInVuZGVmaW5lZFwiID8gQUJDSlMgOiB3aW5kb3cuQUJDSlMpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuIiwidmFyIGdsb2JhbD10eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge307KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZGVmaW5lKSB7XG5cbjsgcmVxdWlyZShcIi9Vc2Vycy93aGVyZXNyaHlzL1NpdGVzL2ppZ3NucmVlbHMvYm93ZXJfY29tcG9uZW50cy9hbmd1bGFyL2FuZ3VsYXIuanNcIik7XG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS4yLjZcbiAqIChjKSAyMDEwLTIwMTQgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgdW5kZWZpbmVkKSB7J3VzZSBzdHJpY3QnO1xuXG4vKiBqc2hpbnQgbWF4bGVuOiBmYWxzZSAqL1xuXG4vKipcbiAqIEBuZ2RvYyBvdmVydmlld1xuICogQG5hbWUgbmdBbmltYXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiAjIG5nQW5pbWF0ZVxuICpcbiAqIFRoZSBgbmdBbmltYXRlYCBtb2R1bGUgcHJvdmlkZXMgc3VwcG9ydCBmb3IgSmF2YVNjcmlwdCwgQ1NTMyB0cmFuc2l0aW9uIGFuZCBDU1MzIGtleWZyYW1lIGFuaW1hdGlvbiBob29rcyB3aXRoaW4gZXhpc3RpbmcgY29yZSBhbmQgY3VzdG9tIGRpcmVjdGl2ZXMuXG4gKlxuICoge0BpbnN0YWxsTW9kdWxlIGFuaW1hdGV9XG4gKlxuICogPGRpdiBkb2MtbW9kdWxlLWNvbXBvbmVudHM9XCJuZ0FuaW1hdGVcIj48L2Rpdj5cbiAqXG4gKiAjIFVzYWdlXG4gKlxuICogVG8gc2VlIGFuaW1hdGlvbnMgaW4gYWN0aW9uLCBhbGwgdGhhdCBpcyByZXF1aXJlZCBpcyB0byBkZWZpbmUgdGhlIGFwcHJvcHJpYXRlIENTUyBjbGFzc2VzXG4gKiBvciB0byByZWdpc3RlciBhIEphdmFTY3JpcHQgYW5pbWF0aW9uIHZpYSB0aGUgbXlNb2R1bGUuYW5pbWF0aW9uKCkgZnVuY3Rpb24uIFRoZSBkaXJlY3RpdmVzIHRoYXQgc3VwcG9ydCBhbmltYXRpb24gYXV0b21hdGljYWxseSBhcmU6XG4gKiBgbmdSZXBlYXRgLCBgbmdJbmNsdWRlYCwgYG5nSWZgLCBgbmdTd2l0Y2hgLCBgbmdTaG93YCwgYG5nSGlkZWAsIGBuZ1ZpZXdgIGFuZCBgbmdDbGFzc2AuIEN1c3RvbSBkaXJlY3RpdmVzIGNhbiB0YWtlIGFkdmFudGFnZSBvZiBhbmltYXRpb25cbiAqIGJ5IHVzaW5nIHRoZSBgJGFuaW1hdGVgIHNlcnZpY2UuXG4gKlxuICogQmVsb3cgaXMgYSBtb3JlIGRldGFpbGVkIGJyZWFrZG93biBvZiB0aGUgc3VwcG9ydGVkIGFuaW1hdGlvbiBldmVudHMgcHJvdmlkZWQgYnkgcHJlLWV4aXN0aW5nIG5nIGRpcmVjdGl2ZXM6XG4gKlxuICogfCBEaXJlY3RpdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBTdXBwb3J0ZWQgQW5pbWF0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCN1c2FnZV9hbmltYXRpb25zIG5nUmVwZWF0fSAgICAgICAgIHwgZW50ZXIsIGxlYXZlIGFuZCBtb3ZlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3I3VzYWdlX2FuaW1hdGlvbnMgbmdWaWV3fSAgICAgICAgfCBlbnRlciBhbmQgbGVhdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlI3VzYWdlX2FuaW1hdGlvbnMgbmdJbmNsdWRlfSAgICAgICB8IGVudGVyIGFuZCBsZWF2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1N3aXRjaCN1c2FnZV9hbmltYXRpb25zIG5nU3dpdGNofSAgICAgICAgIHwgZW50ZXIgYW5kIGxlYXZlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nSWYjdXNhZ2VfYW5pbWF0aW9ucyBuZ0lmfSAgICAgICAgICAgICAgICAgfCBlbnRlciBhbmQgbGVhdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGFzcyN1c2FnZV9hbmltYXRpb25zIG5nQ2xhc3N9ICAgICAgICAgICB8IGFkZCBhbmQgcmVtb3ZlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1Nob3cjdXNhZ2VfYW5pbWF0aW9ucyBuZ1Nob3cgJiBuZ0hpZGV9ICAgIHwgYWRkIGFuZCByZW1vdmUgKHRoZSBuZy1oaWRlIGNsYXNzIHZhbHVlKSAgICAgICAgICAgfFxuICpcbiAqIFlvdSBjYW4gZmluZCBvdXQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBhbmltYXRpb25zIHVwb24gdmlzaXRpbmcgZWFjaCBkaXJlY3RpdmUgcGFnZS5cbiAqXG4gKiBCZWxvdyBpcyBhbiBleGFtcGxlIG9mIGhvdyB0byBhcHBseSBhbmltYXRpb25zIHRvIGEgZGlyZWN0aXZlIHRoYXQgc3VwcG9ydHMgYW5pbWF0aW9uIGhvb2tzOlxuICpcbiAqIDxwcmU+XG4gKiA8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+XG4gKiAuc2xpZGUubmctZW50ZXIsIC5zbGlkZS5uZy1sZWF2ZSB7XG4gKiAgIC13ZWJraXQtdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xuICogfVxuICpcbiAqIC5zbGlkZS5uZy1lbnRlciB7IH0gICAgICAgIC8mIzQyOyBzdGFydGluZyBhbmltYXRpb25zIGZvciBlbnRlciAmIzQyOy9cbiAqIC5zbGlkZS5uZy1lbnRlci1hY3RpdmUgeyB9IC8mIzQyOyB0ZXJtaW5hbCBhbmltYXRpb25zIGZvciBlbnRlciAmIzQyOy9cbiAqIC5zbGlkZS5uZy1sZWF2ZSB7IH0gICAgICAgIC8mIzQyOyBzdGFydGluZyBhbmltYXRpb25zIGZvciBsZWF2ZSAmIzQyOy9cbiAqIC5zbGlkZS5uZy1sZWF2ZS1hY3RpdmUgeyB9IC8mIzQyOyB0ZXJtaW5hbCBhbmltYXRpb25zIGZvciBsZWF2ZSAmIzQyOy9cbiAqIDwvc3R5bGU+XG4gKlxuICogPCEtLVxuICogdGhlIGFuaW1hdGUgc2VydmljZSB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIC5uZy1lbnRlciBhbmQgLm5nLWxlYXZlIHRvIHRoZSBlbGVtZW50XG4gKiB0byB0cmlnZ2VyIHRoZSBDU1MgdHJhbnNpdGlvbi9hbmltYXRpb25zXG4gKiAtLT5cbiAqIDxBTlkgY2xhc3M9XCJzbGlkZVwiIG5nLWluY2x1ZGU9XCIuLi5cIj48L0FOWT5cbiAqIDwvcHJlPlxuICpcbiAqIEtlZXAgaW4gbWluZCB0aGF0IGlmIGFuIGFuaW1hdGlvbiBpcyBydW5uaW5nLCBhbnkgY2hpbGQgZWxlbWVudHMgY2Fubm90IGJlIGFuaW1hdGVkIHVudGlsIHRoZSBwYXJlbnQgZWxlbWVudCdzXG4gKiBhbmltYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAqXG4gKiA8aDI+Q1NTLWRlZmluZWQgQW5pbWF0aW9uczwvaDI+XG4gKiBUaGUgYW5pbWF0ZSBzZXJ2aWNlIHdpbGwgYXV0b21hdGljYWxseSBhcHBseSB0d28gQ1NTIGNsYXNzZXMgdG8gdGhlIGFuaW1hdGVkIGVsZW1lbnQgYW5kIHRoZXNlIHR3byBDU1MgY2xhc3Nlc1xuICogYXJlIGRlc2lnbmVkIHRvIGNvbnRhaW4gdGhlIHN0YXJ0IGFuZCBlbmQgQ1NTIHN0eWxpbmcuIEJvdGggQ1NTIHRyYW5zaXRpb25zIGFuZCBrZXlmcmFtZSBhbmltYXRpb25zIGFyZSBzdXBwb3J0ZWRcbiAqIGFuZCBjYW4gYmUgdXNlZCB0byBwbGF5IGFsb25nIHdpdGggdGhpcyBuYW1pbmcgc3RydWN0dXJlLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgY29kZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIHBlcmZvcm0gYW5pbWF0aW9ucyB1c2luZyAqKkNTUyB0cmFuc2l0aW9ucyoqIHdpdGggQW5ndWxhcjpcbiAqXG4gKiA8cHJlPlxuICogPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlxuICogLyYjNDI7XG4gKiAgVGhlIGFuaW1hdGUgY2xhc3MgaXMgYXBhcnQgb2YgdGhlIGVsZW1lbnQgYW5kIHRoZSBuZy1lbnRlciBjbGFzc1xuICogIGlzIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IG9uY2UgdGhlIGVudGVyIGFuaW1hdGlvbiBldmVudCBpcyB0cmlnZ2VyZWRcbiAqICYjNDI7L1xuICogLnJldmVhbC1hbmltYXRpb24ubmctZW50ZXIge1xuICogIC13ZWJraXQtdHJhbnNpdGlvbjogMXMgbGluZWFyIGFsbDsgLyYjNDI7IFNhZmFyaS9DaHJvbWUgJiM0MjsvXG4gKiAgdHJhbnNpdGlvbjogMXMgbGluZWFyIGFsbDsgLyYjNDI7IEFsbCBvdGhlciBtb2Rlcm4gYnJvd3NlcnMgYW5kIElFMTArICYjNDI7L1xuICpcbiAqICAvJiM0MjsgVGhlIGFuaW1hdGlvbiBwcmVwYXJhdGlvbiBjb2RlICYjNDI7L1xuICogIG9wYWNpdHk6IDA7XG4gKiB9XG4gKlxuICogLyYjNDI7XG4gKiAgS2VlcCBpbiBtaW5kIHRoYXQgeW91IHdhbnQgdG8gY29tYmluZSBib3RoIENTU1xuICogIGNsYXNzZXMgdG9nZXRoZXIgdG8gYXZvaWQgYW55IENTUy1zcGVjaWZpY2l0eVxuICogIGNvbmZsaWN0c1xuICogJiM0MjsvXG4gKiAucmV2ZWFsLWFuaW1hdGlvbi5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xuICogIC8mIzQyOyBUaGUgYW5pbWF0aW9uIGNvZGUgaXRzZWxmICYjNDI7L1xuICogIG9wYWNpdHk6IDE7XG4gKiB9XG4gKiA8L3N0eWxlPlxuICpcbiAqIDxkaXYgY2xhc3M9XCJ2aWV3LWNvbnRhaW5lclwiPlxuICogICA8ZGl2IG5nLXZpZXcgY2xhc3M9XCJyZXZlYWwtYW5pbWF0aW9uXCI+PC9kaXY+XG4gKiA8L2Rpdj5cbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgY29kZSBiZWxvdyBkZW1vbnN0cmF0ZXMgaG93IHRvIHBlcmZvcm0gYW5pbWF0aW9ucyB1c2luZyAqKkNTUyBhbmltYXRpb25zKiogd2l0aCBBbmd1bGFyOlxuICpcbiAqIDxwcmU+XG4gKiA8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+XG4gKiAucmV2ZWFsLWFuaW1hdGlvbi5uZy1lbnRlciB7XG4gKiAgIC13ZWJraXQtYW5pbWF0aW9uOiBlbnRlcl9zZXF1ZW5jZSAxcyBsaW5lYXI7IC8mIzQyOyBTYWZhcmkvQ2hyb21lICYjNDI7L1xuICogICBhbmltYXRpb246IGVudGVyX3NlcXVlbmNlIDFzIGxpbmVhcjsgLyYjNDI7IElFMTArIGFuZCBGdXR1cmUgQnJvd3NlcnMgJiM0MjsvXG4gKiB9XG4gKiAmIzY0LXdlYmtpdC1rZXlmcmFtZXMgZW50ZXJfc2VxdWVuY2Uge1xuICogICBmcm9tIHsgb3BhY2l0eTowOyB9XG4gKiAgIHRvIHsgb3BhY2l0eToxOyB9XG4gKiB9XG4gKiAmIzY0a2V5ZnJhbWVzIGVudGVyX3NlcXVlbmNlIHtcbiAqICAgZnJvbSB7IG9wYWNpdHk6MDsgfVxuICogICB0byB7IG9wYWNpdHk6MTsgfVxuICogfVxuICogPC9zdHlsZT5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwidmlldy1jb250YWluZXJcIj5cbiAqICAgPGRpdiBuZy12aWV3IGNsYXNzPVwicmV2ZWFsLWFuaW1hdGlvblwiPjwvZGl2PlxuICogPC9kaXY+XG4gKiA8L3ByZT5cbiAqXG4gKiBCb3RoIENTUzMgYW5pbWF0aW9ucyBhbmQgdHJhbnNpdGlvbnMgY2FuIGJlIHVzZWQgdG9nZXRoZXIgYW5kIHRoZSBhbmltYXRlIHNlcnZpY2Ugd2lsbCBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGR1cmF0aW9uIGFuZCBkZWxheSB0aW1pbmcuXG4gKlxuICogVXBvbiBET00gbXV0YXRpb24sIHRoZSBldmVudCBjbGFzcyBpcyBhZGRlZCBmaXJzdCAoc29tZXRoaW5nIGxpa2UgYG5nLWVudGVyYCksIHRoZW4gdGhlIGJyb3dzZXIgcHJlcGFyZXMgaXRzZWxmIHRvIGFkZFxuICogdGhlIGFjdGl2ZSBjbGFzcyAoaW4gdGhpcyBjYXNlIGBuZy1lbnRlci1hY3RpdmVgKSB3aGljaCB0aGVuIHRyaWdnZXJzIHRoZSBhbmltYXRpb24uIFRoZSBhbmltYXRpb24gbW9kdWxlIHdpbGwgYXV0b21hdGljYWxseVxuICogZGV0ZWN0IHRoZSBDU1MgY29kZSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMuIE9uY2UgdGhlIGFuaW1hdGlvbiBpcyBvdmVyIHRoZW4gYm90aCBDU1MgY2xhc3NlcyB3aWxsIGJlXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTS4gSWYgYSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgQ1NTIHRyYW5zaXRpb25zIG9yIENTUyBhbmltYXRpb25zIHRoZW4gdGhlIGFuaW1hdGlvbiB3aWxsIHN0YXJ0IGFuZCBlbmRcbiAqIGltbWVkaWF0ZWx5IHJlc3VsdGluZyBpbiBhIERPTSBlbGVtZW50IHRoYXQgaXMgYXQgaXRzIGZpbmFsIHN0YXRlLiBUaGlzIGZpbmFsIHN0YXRlIGlzIHdoZW4gdGhlIERPTSBlbGVtZW50XG4gKiBoYXMgbm8gQ1NTIHRyYW5zaXRpb24vYW5pbWF0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBpdC5cbiAqXG4gKiA8aDM+Q1NTIFN0YWdnZXJpbmcgQW5pbWF0aW9uczwvaDM+XG4gKiBBIFN0YWdnZXJpbmcgYW5pbWF0aW9uIGlzIGEgY29sbGVjdGlvbiBvZiBhbmltYXRpb25zIHRoYXQgYXJlIGlzc3VlZCB3aXRoIGEgc2xpZ2h0IGRlbGF5IGluIGJldHdlZW4gZWFjaCBzdWNjZXNzaXZlIG9wZXJhdGlvbiByZXN1bHRpbmcgaW4gYVxuICogY3VydGFpbi1saWtlIGVmZmVjdC4gVGhlIG5nQW5pbWF0ZSBtb2R1bGUsIGFzIG9mIDEuMi4wLCBzdXBwb3J0cyBzdGFnZ2VyaW5nIGFuaW1hdGlvbnMgYW5kIHRoZSBzdGFnZ2VyIGVmZmVjdCBjYW4gYmVcbiAqIHBlcmZvcm1lZCBieSBjcmVhdGluZyBhICoqbmctRVZFTlQtc3RhZ2dlcioqIENTUyBjbGFzcyBhbmQgYXR0YWNoaW5nIHRoYXQgY2xhc3MgdG8gdGhlIGJhc2UgQ1NTIGNsYXNzIHVzZWQgZm9yXG4gKiB0aGUgYW5pbWF0aW9uLiBUaGUgc3R5bGUgcHJvcGVydHkgZXhwZWN0ZWQgd2l0aGluIHRoZSBzdGFnZ2VyIGNsYXNzIGNhbiBlaXRoZXIgYmUgYSAqKnRyYW5zaXRpb24tZGVsYXkqKiBvciBhblxuICogKiphbmltYXRpb24tZGVsYXkqKiBwcm9wZXJ0eSAob3IgYm90aCBpZiB5b3VyIGFuaW1hdGlvbiBjb250YWlucyBib3RoIHRyYW5zaXRpb25zIGFuZCBrZXlmcmFtZSBhbmltYXRpb25zKS5cbiAqXG4gKiA8cHJlPlxuICogLm15LWFuaW1hdGlvbi5uZy1lbnRlciB7XG4gKiAgIC8mIzQyOyBzdGFuZGFyZCB0cmFuc2l0aW9uIGNvZGUgJiM0MjsvXG4gKiAgIC13ZWJraXQtdHJhbnNpdGlvbjogMXMgbGluZWFyIGFsbDtcbiAqICAgdHJhbnNpdGlvbjogMXMgbGluZWFyIGFsbDtcbiAqICAgb3BhY2l0eTowO1xuICogfVxuICogLm15LWFuaW1hdGlvbi5uZy1lbnRlci1zdGFnZ2VyIHtcbiAqICAgLyYjNDI7IHRoaXMgd2lsbCBoYXZlIGEgMTAwbXMgZGVsYXkgYmV0d2VlbiBlYWNoIHN1Y2Nlc3NpdmUgbGVhdmUgYW5pbWF0aW9uICYjNDI7L1xuICogICAtd2Via2l0LXRyYW5zaXRpb24tZGVsYXk6IDAuMXM7XG4gKiAgIHRyYW5zaXRpb24tZGVsYXk6IDAuMXM7XG4gKlxuICogICAvJiM0MjsgaW4gY2FzZSB0aGUgc3RhZ2dlciBkb2Vzbid0IHdvcmsgdGhlbiB0aGVzZSB0d28gdmFsdWVzXG4gKiAgICBtdXN0IGJlIHNldCB0byAwIHRvIGF2b2lkIGFuIGFjY2lkZW50YWwgQ1NTIGluaGVyaXRhbmNlICYjNDI7L1xuICogICAtd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb246IDBzO1xuICogICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAwcztcbiAqIH1cbiAqIC5teS1hbmltYXRpb24ubmctZW50ZXIubmctZW50ZXItYWN0aXZlIHtcbiAqICAgLyYjNDI7IHN0YW5kYXJkIHRyYW5zaXRpb24gc3R5bGVzICYjNDI7L1xuICogICBvcGFjaXR5OjE7XG4gKiB9XG4gKiA8L3ByZT5cbiAqXG4gKiBTdGFnZ2VyaW5nIGFuaW1hdGlvbnMgd29yayBieSBkZWZhdWx0IGluIG5nUmVwZWF0IChzbyBsb25nIGFzIHRoZSBDU1MgY2xhc3MgaXMgZGVmaW5lZCkuIE91dHNpZGUgb2YgbmdSZXBlYXQsIHRvIHVzZSBzdGFnZ2VyaW5nIGFuaW1hdGlvbnNcbiAqIG9uIHlvdXIgb3duLCB0aGV5IGNhbiBiZSB0cmlnZ2VyZWQgYnkgZmlyaW5nIG11bHRpcGxlIGNhbGxzIHRvIHRoZSBzYW1lIGV2ZW50IG9uICRhbmltYXRlLiBIb3dldmVyLCB0aGUgcmVzdHJpY3Rpb25zIHN1cnJvdW5kaW5nIHRoaXNcbiAqIGFyZSB0aGF0IGVhY2ggb2YgdGhlIGVsZW1lbnRzIG11c3QgaGF2ZSB0aGUgc2FtZSBDU1MgY2xhc3NOYW1lIHZhbHVlIGFzIHdlbGwgYXMgdGhlIHNhbWUgcGFyZW50IGVsZW1lbnQuIEEgc3RhZ2dlciBvcGVyYXRpb25cbiAqIHdpbGwgYWxzbyBiZSByZXNldCBpZiBtb3JlIHRoYW4gMTBtcyBoYXMgcGFzc2VkIGFmdGVyIHRoZSBsYXN0IGFuaW1hdGlvbiBoYXMgYmVlbiBmaXJlZC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGNvZGUgd2lsbCBpc3N1ZSB0aGUgKipuZy1sZWF2ZS1zdGFnZ2VyKiogZXZlbnQgb24gdGhlIGVsZW1lbnQgcHJvdmlkZWQ6XG4gKlxuICogPHByZT5cbiAqIHZhciBraWRzID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gKlxuICogJGFuaW1hdGUubGVhdmUoa2lkc1swXSk7IC8vc3RhZ2dlciBpbmRleD0wXG4gKiAkYW5pbWF0ZS5sZWF2ZShraWRzWzFdKTsgLy9zdGFnZ2VyIGluZGV4PTFcbiAqICRhbmltYXRlLmxlYXZlKGtpZHNbMl0pOyAvL3N0YWdnZXIgaW5kZXg9MlxuICogJGFuaW1hdGUubGVhdmUoa2lkc1szXSk7IC8vc3RhZ2dlciBpbmRleD0zXG4gKiAkYW5pbWF0ZS5sZWF2ZShraWRzWzRdKTsgLy9zdGFnZ2VyIGluZGV4PTRcbiAqXG4gKiAkdGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgLy9zdGFnZ2VyIGhhcyByZXNldCBpdHNlbGZcbiAqICAgJGFuaW1hdGUubGVhdmUoa2lkc1s1XSk7IC8vc3RhZ2dlciBpbmRleD0wXG4gKiAgICRhbmltYXRlLmxlYXZlKGtpZHNbNl0pOyAvL3N0YWdnZXIgaW5kZXg9MVxuICogfSwgMTAwLCBmYWxzZSk7XG4gKiA8L3ByZT5cbiAqXG4gKiBTdGFnZ2VyIGFuaW1hdGlvbnMgYXJlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCB3aXRoaW4gQ1NTLWRlZmluZWQgYW5pbWF0aW9ucy5cbiAqXG4gKiA8aDI+SmF2YVNjcmlwdC1kZWZpbmVkIEFuaW1hdGlvbnM8L2gyPlxuICogSW4gdGhlIGV2ZW50IHRoYXQgeW91IGRvIG5vdCB3YW50IHRvIHVzZSBDU1MzIHRyYW5zaXRpb25zIG9yIENTUzMgYW5pbWF0aW9ucyBvciBpZiB5b3Ugd2lzaCB0byBvZmZlciBhbmltYXRpb25zIG9uIGJyb3dzZXJzIHRoYXQgZG8gbm90XG4gKiB5ZXQgc3VwcG9ydCBDU1MgdHJhbnNpdGlvbnMvYW5pbWF0aW9ucywgdGhlbiB5b3UgY2FuIG1ha2UgdXNlIG9mIEphdmFTY3JpcHQgYW5pbWF0aW9ucyBkZWZpbmVkIGluc2lkZSBvZiB5b3VyIEFuZ3VsYXJKUyBtb2R1bGUuXG4gKlxuICogPHByZT5cbiAqIC8vIWFubm90YXRlPVwiWW91ckFwcFwiIFlvdXIgQW5ndWxhckpTIE1vZHVsZXxSZXBsYWNlIHRoaXMgb3IgbmdNb2R1bGUgd2l0aCB0aGUgbW9kdWxlIHRoYXQgeW91IHVzZWQgdG8gZGVmaW5lIHlvdXIgYXBwbGljYXRpb24uXG4gKiB2YXIgbmdNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnWW91ckFwcCcsIFsnbmdBbmltYXRlJ10pO1xuICogbmdNb2R1bGUuYW5pbWF0aW9uKCcubXktY3JhenktYW5pbWF0aW9uJywgZnVuY3Rpb24oKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgZW50ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHtcbiAqICAgICAgIC8vcnVuIHRoZSBhbmltYXRpb24gaGVyZSBhbmQgY2FsbCBkb25lIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbmNlbGxlZCkge1xuICogICAgICAgICAvL3RoaXMgKG9wdGlvbmFsKSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhbmltYXRpb25cbiAqICAgICAgICAgLy9jb21wbGV0ZXMgb3Igd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNhbmNlbGxlZCAodGhlIGNhbmNlbGxlZFxuICogICAgICAgICAvL2ZsYWcgd2lsbCBiZSBzZXQgdG8gdHJ1ZSBpZiBjYW5jZWxsZWQpLlxuICogICAgICAgfTtcbiAqICAgICB9LFxuICogICAgIGxlYXZlOiBmdW5jdGlvbihlbGVtZW50LCBkb25lKSB7IH0sXG4gKiAgICAgbW92ZTogZnVuY3Rpb24oZWxlbWVudCwgZG9uZSkgeyB9LFxuICpcbiAqICAgICAvL2FuaW1hdGlvbiB0aGF0IGNhbiBiZSB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBjbGFzcyBpcyBhZGRlZFxuICogICAgIGJlZm9yZUFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHsgfSxcbiAqXG4gKiAgICAgLy9hbmltYXRpb24gdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIGFmdGVyIHRoZSBjbGFzcyBpcyBhZGRlZFxuICogICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHsgfSxcbiAqXG4gKiAgICAgLy9hbmltYXRpb24gdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgY2xhc3MgaXMgcmVtb3ZlZFxuICogICAgIGJlZm9yZVJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHsgfSxcbiAqXG4gKiAgICAgLy9hbmltYXRpb24gdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIGFmdGVyIHRoZSBjbGFzcyBpcyByZW1vdmVkXG4gKiAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZSkgeyB9XG4gKiAgIH07XG4gKiB9KTtcbiAqIDwvcHJlPlxuICpcbiAqIEphdmFTY3JpcHQtZGVmaW5lZCBhbmltYXRpb25zIGFyZSBjcmVhdGVkIHdpdGggYSBDU1MtbGlrZSBjbGFzcyBzZWxlY3RvciBhbmQgYSBjb2xsZWN0aW9uIG9mIGV2ZW50cyB3aGljaCBhcmUgc2V0IHRvIHJ1blxuICogYSBqYXZhc2NyaXB0IGNhbGxiYWNrIGZ1bmN0aW9uLiBXaGVuIGFuIGFuaW1hdGlvbiBpcyB0cmlnZ2VyZWQsICRhbmltYXRlIHdpbGwgbG9vayBmb3IgYSBtYXRjaGluZyBhbmltYXRpb24gd2hpY2ggZml0c1xuICogdGhlIGVsZW1lbnQncyBDU1MgY2xhc3MgYXR0cmlidXRlIHZhbHVlIGFuZCB0aGVuIHJ1biB0aGUgbWF0Y2hpbmcgYW5pbWF0aW9uIGV2ZW50IGZ1bmN0aW9uIChpZiBmb3VuZCkuXG4gKiBJbiBvdGhlciB3b3JkcywgaWYgdGhlIENTUyBjbGFzc2VzIHByZXNlbnQgb24gdGhlIGFuaW1hdGVkIGVsZW1lbnQgbWF0Y2ggYW55IG9mIHRoZSBKYXZhU2NyaXB0IGFuaW1hdGlvbnMgdGhlbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbFxuICogYmUgZXhlY3V0ZWQuIEl0IHNob3VsZCBiZSBhbHNvIG5vdGVkIHRoYXQgb25seSBzaW1wbGUsIHNpbmdsZSBjbGFzcyBzZWxlY3RvcnMgYXJlIGFsbG93ZWQgKGNvbXBvdW5kIGNsYXNzIHNlbGVjdG9ycyBhcmUgbm90IHN1cHBvcnRlZCkuXG4gKlxuICogV2l0aGluIGEgSmF2YVNjcmlwdCBhbmltYXRpb24sIGFuIG9iamVjdCBjb250YWluaW5nIHZhcmlvdXMgZXZlbnQgY2FsbGJhY2sgYW5pbWF0aW9uIGZ1bmN0aW9ucyBpcyBleHBlY3RlZCB0byBiZSByZXR1cm5lZC5cbiAqIEFzIGV4cGxhaW5lZCBhYm92ZSwgdGhlc2UgY2FsbGJhY2tzIGFyZSB0cmlnZ2VyZWQgYmFzZWQgb24gdGhlIGFuaW1hdGlvbiBldmVudC4gVGhlcmVmb3JlIGlmIGFuIGVudGVyIGFuaW1hdGlvbiBpcyBydW4sXG4gKiBhbmQgdGhlIEphdmFTY3JpcHQgYW5pbWF0aW9uIGlzIGZvdW5kLCB0aGVuIHRoZSBlbnRlciBjYWxsYmFjayB3aWxsIGhhbmRsZSB0aGF0IGFuaW1hdGlvbiAoaW4gYWRkaXRpb24gdG8gdGhlIENTUyBrZXlmcmFtZSBhbmltYXRpb25cbiAqIG9yIHRyYW5zaXRpb24gY29kZSB0aGF0IGlzIGRlZmluZWQgdmlhIGEgc3R5bGVzaGVldCkuXG4gKlxuICovXG5cbmFuZ3VsYXIubW9kdWxlKCduZ0FuaW1hdGUnLCBbJ25nJ10pXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgbmdBbmltYXRlLiRhbmltYXRlUHJvdmlkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIFRoZSBgJGFuaW1hdGVQcm92aWRlcmAgYWxsb3dzIGRldmVsb3BlcnMgdG8gcmVnaXN0ZXIgSmF2YVNjcmlwdCBhbmltYXRpb24gZXZlbnQgaGFuZGxlcnMgZGlyZWN0bHkgaW5zaWRlIG9mIGEgbW9kdWxlLlxuICAgKiBXaGVuIGFuIGFuaW1hdGlvbiBpcyB0cmlnZ2VyZWQsIHRoZSAkYW5pbWF0ZSBzZXJ2aWNlIHdpbGwgcXVlcnkgdGhlICRhbmltYXRlIHNlcnZpY2UgdG8gZmluZCBhbnkgYW5pbWF0aW9ucyB0aGF0IG1hdGNoXG4gICAqIHRoZSBwcm92aWRlZCBuYW1lIHZhbHVlLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nQW5pbWF0ZSBgbmdBbmltYXRlYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAgICpcbiAgICogUGxlYXNlIHZpc2l0IHRoZSB7QGxpbmsgbmdBbmltYXRlIGBuZ0FuaW1hdGVgfSBtb2R1bGUgb3ZlcnZpZXcgcGFnZSBsZWFybiBtb3JlIGFib3V0IGhvdyB0byB1c2UgYW5pbWF0aW9ucyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKi9cbiAgLmNvbmZpZyhbJyRwcm92aWRlJywgJyRhbmltYXRlUHJvdmlkZXInLCBmdW5jdGlvbigkcHJvdmlkZSwgJGFuaW1hdGVQcm92aWRlcikge1xuICAgIHZhciBub29wID0gYW5ndWxhci5ub29wO1xuICAgIHZhciBmb3JFYWNoID0gYW5ndWxhci5mb3JFYWNoO1xuICAgIHZhciBzZWxlY3RvcnMgPSAkYW5pbWF0ZVByb3ZpZGVyLiQkc2VsZWN0b3JzO1xuXG4gICAgdmFyIEVMRU1FTlRfTk9ERSA9IDE7XG4gICAgdmFyIE5HX0FOSU1BVEVfU1RBVEUgPSAnJCRuZ0FuaW1hdGVTdGF0ZSc7XG4gICAgdmFyIE5HX0FOSU1BVEVfQ0xBU1NfTkFNRSA9ICduZy1hbmltYXRlJztcbiAgICB2YXIgcm9vdEFuaW1hdGVTdGF0ZSA9IHtydW5uaW5nOiB0cnVlfTtcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxtID0gZWxlbWVudFtpXTtcbiAgICAgICAgaWYoZWxtLm5vZGVUeXBlID09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybiBlbG07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01hdGNoaW5nRWxlbWVudChlbG0xLCBlbG0yKSB7XG4gICAgICByZXR1cm4gZXh0cmFjdEVsZW1lbnROb2RlKGVsbTEpID09IGV4dHJhY3RFbGVtZW50Tm9kZShlbG0yKTtcbiAgICB9XG5cbiAgICAkcHJvdmlkZS5kZWNvcmF0b3IoJyRhbmltYXRlJywgWyckZGVsZWdhdGUnLCAnJGluamVjdG9yJywgJyRzbmlmZmVyJywgJyRyb290RWxlbWVudCcsICckdGltZW91dCcsICckcm9vdFNjb3BlJywgJyRkb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJGRlbGVnYXRlLCAgICRpbmplY3RvciwgICAkc25pZmZlciwgICAkcm9vdEVsZW1lbnQsICAgJHRpbWVvdXQsICAgJHJvb3RTY29wZSwgICAkZG9jdW1lbnQpIHtcblxuICAgICAgJHJvb3RFbGVtZW50LmRhdGEoTkdfQU5JTUFURV9TVEFURSwgcm9vdEFuaW1hdGVTdGF0ZSk7XG5cbiAgICAgIC8vIGRpc2FibGUgYW5pbWF0aW9ucyBkdXJpbmcgYm9vdHN0cmFwLCBidXQgb25jZSB3ZSBib290c3RyYXBwZWQsIHdhaXQgYWdhaW5cbiAgICAgIC8vIGZvciBhbm90aGVyIGRpZ2VzdCB1bnRpbCBlbmFibGluZyBhbmltYXRpb25zLiBUaGUgcmVhc29uIHdoeSB3ZSBkaWdlc3QgdHdpY2VcbiAgICAgIC8vIGlzIGJlY2F1c2UgYWxsIHN0cnVjdHVyYWwgYW5pbWF0aW9ucyAoZW50ZXIsIGxlYXZlIGFuZCBtb3ZlKSBhbGwgcGVyZm9ybSBhXG4gICAgICAvLyBwb3N0IGRpZ2VzdCBvcGVyYXRpb24gYmVmb3JlIGFuaW1hdGluZy4gSWYgd2Ugb25seSB3YWl0IGZvciBhIHNpbmdsZSBkaWdlc3RcbiAgICAgIC8vIHRvIHBhc3MgdGhlbiB0aGUgc3RydWN0dXJhbCBhbmltYXRpb24gd291bGQgcmVuZGVyIGl0cyBhbmltYXRpb24gb24gcGFnZSBsb2FkLlxuICAgICAgLy8gKHdoaWNoIGlzIHdoYXQgd2UncmUgdHJ5aW5nIHRvIGF2b2lkIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGZpcnN0IGJvb3RzIHVwLilcbiAgICAgICRyb290U2NvcGUuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICByb290QW5pbWF0ZVN0YXRlLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNsYXNzTmFtZUZpbHRlciA9ICRhbmltYXRlUHJvdmlkZXIuY2xhc3NOYW1lRmlsdGVyKCk7XG4gICAgICB2YXIgaXNBbmltYXRhYmxlQ2xhc3NOYW1lID0gIWNsYXNzTmFtZUZpbHRlclxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWVGaWx0ZXIudGVzdChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBsb29rdXAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gW10sXG4gICAgICAgICAgICAgIGZsYWdNYXAgPSB7fSxcbiAgICAgICAgICAgICAgY2xhc3NlcyA9IG5hbWUuc3Vic3RyKDEpLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICAvL3RoZSBlbXB0eSBzdHJpbmcgdmFsdWUgaXMgdGhlIGRlZmF1bHQgYW5pbWF0aW9uXG4gICAgICAgICAgLy9vcGVyYXRpb24gd2hpY2ggcGVyZm9ybXMgQ1NTIHRyYW5zaXRpb24gYW5kIGtleWZyYW1lXG4gICAgICAgICAgLy9hbmltYXRpb25zIHNuaWZmaW5nLiBUaGlzIGlzIGFsd2F5cyBpbmNsdWRlZCBmb3IgZWFjaFxuICAgICAgICAgIC8vZWxlbWVudCBhbmltYXRpb24gcHJvY2VkdXJlIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzXG4gICAgICAgICAgLy90cmFuc2l0aW9ucyBhbmQvb3Iga2V5ZnJhbWUgYW5pbWF0aW9uc1xuICAgICAgICAgIGlmICgkc25pZmZlci50cmFuc2l0aW9ucyB8fCAkc25pZmZlci5hbmltYXRpb25zKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcih2YXIgaT0wOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtsYXNzID0gY2xhc3Nlc1tpXSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvckZhY3RvcnlOYW1lID0gc2VsZWN0b3JzW2tsYXNzXTtcbiAgICAgICAgICAgIGlmKHNlbGVjdG9yRmFjdG9yeU5hbWUgJiYgIWZsYWdNYXBba2xhc3NdKSB7XG4gICAgICAgICAgICAgIG1hdGNoZXMucHVzaCgkaW5qZWN0b3IuZ2V0KHNlbGVjdG9yRmFjdG9yeU5hbWUpKTtcbiAgICAgICAgICAgICAgZmxhZ01hcFtrbGFzc10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBvYmplY3RcbiAgICAgICAqIEBuYW1lIG5nQW5pbWF0ZS4kYW5pbWF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBUaGUgYCRhbmltYXRlYCBzZXJ2aWNlIHByb3ZpZGVzIGFuaW1hdGlvbiBkZXRlY3Rpb24gc3VwcG9ydCB3aGlsZSBwZXJmb3JtaW5nIERPTSBvcGVyYXRpb25zIChlbnRlciwgbGVhdmUgYW5kIG1vdmUpIGFzIHdlbGwgYXMgZHVyaW5nIGFkZENsYXNzIGFuZCByZW1vdmVDbGFzcyBvcGVyYXRpb25zLlxuICAgICAgICogV2hlbiBhbnkgb2YgdGhlc2Ugb3BlcmF0aW9ucyBhcmUgcnVuLCB0aGUgJGFuaW1hdGUgc2VydmljZVxuICAgICAgICogd2lsbCBleGFtaW5lIGFueSBKYXZhU2NyaXB0LWRlZmluZWQgYW5pbWF0aW9ucyAod2hpY2ggYXJlIGRlZmluZWQgYnkgdXNpbmcgdGhlICRhbmltYXRlUHJvdmlkZXIgcHJvdmlkZXIgb2JqZWN0KVxuICAgICAgICogYXMgd2VsbCBhcyBhbnkgQ1NTLWRlZmluZWQgYW5pbWF0aW9ucyBhZ2FpbnN0IHRoZSBDU1MgY2xhc3NlcyBwcmVzZW50IG9uIHRoZSBlbGVtZW50IG9uY2UgdGhlIERPTSBvcGVyYXRpb24gaXMgcnVuLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBgJGFuaW1hdGVgIHNlcnZpY2UgaXMgdXNlZCBiZWhpbmQgdGhlIHNjZW5lcyB3aXRoIHByZS1leGlzdGluZyBkaXJlY3RpdmVzIGFuZCBhbmltYXRpb24gd2l0aCB0aGVzZSBkaXJlY3RpdmVzXG4gICAgICAgKiB3aWxsIHdvcmsgb3V0IG9mIHRoZSBib3ggd2l0aG91dCBhbnkgZXh0cmEgY29uZmlndXJhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nQW5pbWF0ZSBgbmdBbmltYXRlYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAgICAgICAqXG4gICAgICAgKiBQbGVhc2UgdmlzaXQgdGhlIHtAbGluayBuZ0FuaW1hdGUgYG5nQW5pbWF0ZWB9IG1vZHVsZSBvdmVydmlldyBwYWdlIGxlYXJuIG1vcmUgYWJvdXQgaG93IHRvIHVzZSBhbmltYXRpb25zIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIG5nQW5pbWF0ZS4kYW5pbWF0ZSNlbnRlclxuICAgICAgICAgKiBAbWV0aG9kT2YgbmdBbmltYXRlLiRhbmltYXRlXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogQXBwZW5kcyB0aGUgZWxlbWVudCB0byB0aGUgcGFyZW50RWxlbWVudCBlbGVtZW50IHRoYXQgcmVzaWRlcyBpbiB0aGUgZG9jdW1lbnQgYW5kIHRoZW4gcnVucyB0aGUgZW50ZXIgYW5pbWF0aW9uLiBPbmNlXG4gICAgICAgICAqIHRoZSBhbmltYXRpb24gaXMgc3RhcnRlZCwgdGhlIGZvbGxvd2luZyBDU1MgY2xhc3NlcyB3aWxsIGJlIHByZXNlbnQgb24gdGhlIGVsZW1lbnQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uOlxuICAgICAgICAgKlxuICAgICAgICAgKiBCZWxvdyBpcyBhIGJyZWFrZG93biBvZiBlYWNoIHN0ZXAgdGhhdCBvY2N1cnMgZHVyaW5nIGVudGVyIGFuaW1hdGlvbjpcbiAgICAgICAgICpcbiAgICAgICAgICogfCBBbmltYXRpb24gU3RlcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFdoYXQgdGhlIGVsZW1lbnQgY2xhc3MgYXR0cmlidXRlIGxvb2tzIGxpa2UgfFxuICAgICAgICAgKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAqIHwgMS4gJGFuaW1hdGUuZW50ZXIoLi4uKSBpcyBjYWxsZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDIuIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgcGFyZW50RWxlbWVudCBlbGVtZW50IG9yIGJlc2lkZSB0aGUgYWZ0ZXJFbGVtZW50IGVsZW1lbnQgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb25cIiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogfCAzLiAkYW5pbWF0ZSBydW5zIGFueSBKYXZhU2NyaXB0LWRlZmluZWQgYW5pbWF0aW9ucyBvbiB0aGUgZWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGVcIiAgICAgICAgICAgICB8XG4gICAgICAgICAqIHwgNC4gdGhlIC5uZy1lbnRlciBjbGFzcyBpcyBhZGRlZCB0byB0aGUgZWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLWVudGVyXCIgICAgfFxuICAgICAgICAgKiB8IDUuICRhbmltYXRlIHNjYW5zIHRoZSBlbGVtZW50IHN0eWxlcyB0byBnZXQgdGhlIENTUyB0cmFuc2l0aW9uL2FuaW1hdGlvbiBkdXJhdGlvbiBhbmQgZGVsYXkgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBuZy1lbnRlclwiICAgIHxcbiAgICAgICAgICogfCA2LiAkYW5pbWF0ZSB3YWl0cyBmb3IgMTBtcyAodGhpcyBwZXJmb3JtcyBhIHJlZmxvdykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGUgbmctZW50ZXJcIiAgICB8XG4gICAgICAgICAqIHwgNy4gdGhlIC5uZy1lbnRlci1hY3RpdmUgYW5kIC5uZy1hbmltYXRlLWFjdGl2ZSBjbGFzc2VzIGFyZSBhZGRlZCAodGhpcyB0cmlnZ2VycyB0aGUgQ1NTIHRyYW5zaXRpb24vYW5pbWF0aW9uKSB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGUgbmctYW5pbWF0ZS1hY3RpdmUgbmctZW50ZXIgbmctZW50ZXItYWN0aXZlXCIgfFxuICAgICAgICAgKiB8IDguICRhbmltYXRlIHdhaXRzIGZvciBYIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGFuaW1hdGlvbiB0byBjb21wbGV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBuZy1hbmltYXRlLWFjdGl2ZSBuZy1lbnRlciBuZy1lbnRlci1hY3RpdmVcIiB8XG4gICAgICAgICAqIHwgOS4gVGhlIGFuaW1hdGlvbiBlbmRzIGFuZCBhbGwgZ2VuZXJhdGVkIENTUyBjbGFzc2VzIGFyZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDEwLiBUaGUgZG9uZUNhbGxiYWNrKCkgY2FsbGJhY2sgaXMgZmlyZWQgKGlmIHByb3ZpZGVkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb25cIiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHRoZSBmb2N1cyBvZiB0aGUgZW50ZXIgYW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBwYXJlbnRFbGVtZW50IHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdGhlIGZvY3VzIG9mIHRoZSBlbnRlciBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGFmdGVyRWxlbWVudCB0aGUgc2libGluZyBlbGVtZW50ICh3aGljaCBpcyB0aGUgcHJldmlvdXMgZWxlbWVudCkgb2YgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHRoZSBmb2N1cyBvZiB0aGUgZW50ZXIgYW5pbWF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IGRvbmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgKi9cbiAgICAgICAgZW50ZXIgOiBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnRFbGVtZW50LCBhZnRlckVsZW1lbnQsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuZW5hYmxlZChmYWxzZSwgZWxlbWVudCk7XG4gICAgICAgICAgJGRlbGVnYXRlLmVudGVyKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQsIGFmdGVyRWxlbWVudCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwZXJmb3JtQW5pbWF0aW9uKCdlbnRlcicsICduZy1lbnRlcicsIGVsZW1lbnQsIHBhcmVudEVsZW1lbnQsIGFmdGVyRWxlbWVudCwgbm9vcCwgZG9uZUNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgICAqIEBuYW1lIG5nQW5pbWF0ZS4kYW5pbWF0ZSNsZWF2ZVxuICAgICAgICAgKiBAbWV0aG9kT2YgbmdBbmltYXRlLiRhbmltYXRlXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogUnVucyB0aGUgbGVhdmUgYW5pbWF0aW9uIG9wZXJhdGlvbiBhbmQsIHVwb24gY29tcGxldGlvbiwgcmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uIE9uY2VcbiAgICAgICAgICogdGhlIGFuaW1hdGlvbiBpcyBzdGFydGVkLCB0aGUgZm9sbG93aW5nIENTUyBjbGFzc2VzIHdpbGwgYmUgYWRkZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uOlxuICAgICAgICAgKlxuICAgICAgICAgKiBCZWxvdyBpcyBhIGJyZWFrZG93biBvZiBlYWNoIHN0ZXAgdGhhdCBvY2N1cnMgZHVyaW5nIGxlYXZlIGFuaW1hdGlvbjpcbiAgICAgICAgICpcbiAgICAgICAgICogfCBBbmltYXRpb24gU3RlcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFdoYXQgdGhlIGVsZW1lbnQgY2xhc3MgYXR0cmlidXRlIGxvb2tzIGxpa2UgfFxuICAgICAgICAgKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAqIHwgMS4gJGFuaW1hdGUubGVhdmUoLi4uKSBpcyBjYWxsZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDIuICRhbmltYXRlIHJ1bnMgYW55IEphdmFTY3JpcHQtZGVmaW5lZCBhbmltYXRpb25zIG9uIHRoZSBlbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZVwiICAgICAgICAgICAgIHxcbiAgICAgICAgICogfCAzLiB0aGUgLm5nLWxlYXZlIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBlbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGUgbmctbGVhdmVcIiAgICB8XG4gICAgICAgICAqIHwgNC4gJGFuaW1hdGUgc2NhbnMgdGhlIGVsZW1lbnQgc3R5bGVzIHRvIGdldCB0aGUgQ1NTIHRyYW5zaXRpb24vYW5pbWF0aW9uIGR1cmF0aW9uIGFuZCBkZWxheSAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLWxlYXZlXCIgICAgfFxuICAgICAgICAgKiB8IDUuICRhbmltYXRlIHdhaXRzIGZvciAxMG1zICh0aGlzIHBlcmZvcm1zIGEgcmVmbG93KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBuZy1sZWF2ZVwiICAgIHxcbiAgICAgICAgICogfCA2LiB0aGUgLm5nLWxlYXZlLWFjdGl2ZSBhbmQgLm5nLWFuaW1hdGUtYWN0aXZlIGNsYXNzZXMgaXMgYWRkZWQgKHRoaXMgdHJpZ2dlcnMgdGhlIENTUyB0cmFuc2l0aW9uL2FuaW1hdGlvbikgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLWFuaW1hdGUtYWN0aXZlIG5nLWxlYXZlIG5nLWxlYXZlLWFjdGl2ZVwiIHxcbiAgICAgICAgICogfCA3LiAkYW5pbWF0ZSB3YWl0cyBmb3IgWCBtaWxsaXNlY29uZHMgZm9yIHRoZSBhbmltYXRpb24gdG8gY29tcGxldGUgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGUgbmctYW5pbWF0ZS1hY3RpdmUgbmctbGVhdmUgbmctbGVhdmUtYWN0aXZlXCIgfFxuICAgICAgICAgKiB8IDguIFRoZSBhbmltYXRpb24gZW5kcyBhbmQgYWxsIGdlbmVyYXRlZCBDU1MgY2xhc3NlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50ICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb25cIiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogfCA5LiBUaGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDEwLiBUaGUgZG9uZUNhbGxiYWNrKCkgY2FsbGJhY2sgaXMgZmlyZWQgKGlmIHByb3ZpZGVkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB0aGUgZm9jdXMgb2YgdGhlIGxlYXZlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBkb25lQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICovXG4gICAgICAgIGxlYXZlIDogZnVuY3Rpb24oZWxlbWVudCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FuY2VsQ2hpbGRBbmltYXRpb25zKGVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZW5hYmxlZChmYWxzZSwgZWxlbWVudCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwZXJmb3JtQW5pbWF0aW9uKCdsZWF2ZScsICduZy1sZWF2ZScsIGVsZW1lbnQsIG51bGwsIG51bGwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAkZGVsZWdhdGUubGVhdmUoZWxlbWVudCk7XG4gICAgICAgICAgICB9LCBkb25lQ2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgbmdBbmltYXRlLiRhbmltYXRlI21vdmVcbiAgICAgICAgICogQG1ldGhvZE9mIG5nQW5pbWF0ZS4kYW5pbWF0ZVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEZpcmVzIHRoZSBtb3ZlIERPTSBvcGVyYXRpb24uIEp1c3QgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLCB0aGUgYW5pbWF0ZSBzZXJ2aWNlIHdpbGwgZWl0aGVyIGFwcGVuZCBpdCBpbnRvIHRoZSBwYXJlbnRFbGVtZW50IGNvbnRhaW5lciBvclxuICAgICAgICAgKiBhZGQgdGhlIGVsZW1lbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGFmdGVyRWxlbWVudCBlbGVtZW50IGlmIHByZXNlbnQuIFRoZW4gdGhlIG1vdmUgYW5pbWF0aW9uIHdpbGwgYmUgcnVuLiBPbmNlXG4gICAgICAgICAqIHRoZSBhbmltYXRpb24gaXMgc3RhcnRlZCwgdGhlIGZvbGxvd2luZyBDU1MgY2xhc3NlcyB3aWxsIGJlIGFkZGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbjpcbiAgICAgICAgICpcbiAgICAgICAgICogQmVsb3cgaXMgYSBicmVha2Rvd24gb2YgZWFjaCBzdGVwIHRoYXQgb2NjdXJzIGR1cmluZyBtb3ZlIGFuaW1hdGlvbjpcbiAgICAgICAgICpcbiAgICAgICAgICogfCBBbmltYXRpb24gU3RlcCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFdoYXQgdGhlIGVsZW1lbnQgY2xhc3MgYXR0cmlidXRlIGxvb2tzIGxpa2UgfFxuICAgICAgICAgKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAqIHwgMS4gJGFuaW1hdGUubW92ZSguLi4pIGlzIGNhbGxlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDIuIGVsZW1lbnQgaXMgbW92ZWQgaW50byB0aGUgcGFyZW50RWxlbWVudCBlbGVtZW50IG9yIGJlc2lkZSB0aGUgYWZ0ZXJFbGVtZW50IGVsZW1lbnQgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb25cIiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogfCAzLiAkYW5pbWF0ZSBydW5zIGFueSBKYXZhU2NyaXB0LWRlZmluZWQgYW5pbWF0aW9ucyBvbiB0aGUgZWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGVcIiAgICAgICAgICAgICB8XG4gICAgICAgICAqIHwgNC4gdGhlIC5uZy1tb3ZlIGNsYXNzIGlzIGFkZGVkIHRvIHRoZSBlbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLW1vdmVcIiAgICAgfFxuICAgICAgICAgKiB8IDUuICRhbmltYXRlIHNjYW5zIHRoZSBlbGVtZW50IHN0eWxlcyB0byBnZXQgdGhlIENTUyB0cmFuc2l0aW9uL2FuaW1hdGlvbiBkdXJhdGlvbiBhbmQgZGVsYXkgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBuZy1tb3ZlXCIgICAgIHxcbiAgICAgICAgICogfCA2LiAkYW5pbWF0ZSB3YWl0cyBmb3IgMTBtcyAodGhpcyBwZXJmb3JtcyBhIHJlZmxvdykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGUgbmctbW92ZVwiICAgICB8XG4gICAgICAgICAqIHwgNy4gdGhlIC5uZy1tb3ZlLWFjdGl2ZSBhbmQgLm5nLWFuaW1hdGUtYWN0aXZlIGNsYXNzZXMgaXMgYWRkZWQgKHRoaXMgdHJpZ2dlcnMgdGhlIENTUyB0cmFuc2l0aW9uL2FuaW1hdGlvbikgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLWFuaW1hdGUtYWN0aXZlIG5nLW1vdmUgbmctbW92ZS1hY3RpdmVcIiB8XG4gICAgICAgICAqIHwgOC4gJGFuaW1hdGUgd2FpdHMgZm9yIFggbWlsbGlzZWNvbmRzIGZvciB0aGUgYW5pbWF0aW9uIHRvIGNvbXBsZXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLWFuaW1hdGUtYWN0aXZlIG5nLW1vdmUgbmctbW92ZS1hY3RpdmVcIiB8XG4gICAgICAgICAqIHwgOS4gVGhlIGFuaW1hdGlvbiBlbmRzIGFuZCBhbGwgZ2VuZXJhdGVkIENTUyBjbGFzc2VzIGFyZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDEwLiBUaGUgZG9uZUNhbGxiYWNrKCkgY2FsbGJhY2sgaXMgZmlyZWQgKGlmIHByb3ZpZGVkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb25cIiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHRoZSBmb2N1cyBvZiB0aGUgbW92ZSBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IHBhcmVudEVsZW1lbnQgdGhlIHBhcmVudEVsZW1lbnQgZWxlbWVudCBvZiB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdGhlIGZvY3VzIG9mIHRoZSBtb3ZlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gYWZ0ZXJFbGVtZW50IHRoZSBzaWJsaW5nIGVsZW1lbnQgKHdoaWNoIGlzIHRoZSBwcmV2aW91cyBlbGVtZW50KSBvZiB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgdGhlIGZvY3VzIG9mIHRoZSBtb3ZlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBkb25lQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICovXG4gICAgICAgIG1vdmUgOiBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnRFbGVtZW50LCBhZnRlckVsZW1lbnQsIGRvbmVDYWxsYmFjaykge1xuICAgICAgICAgIGNhbmNlbENoaWxkQW5pbWF0aW9ucyhlbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmVuYWJsZWQoZmFsc2UsIGVsZW1lbnQpO1xuICAgICAgICAgICRkZWxlZ2F0ZS5tb3ZlKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQsIGFmdGVyRWxlbWVudCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwZXJmb3JtQW5pbWF0aW9uKCdtb3ZlJywgJ25nLW1vdmUnLCBlbGVtZW50LCBwYXJlbnRFbGVtZW50LCBhZnRlckVsZW1lbnQsIG5vb3AsIGRvbmVDYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBuZ0FuaW1hdGUuJGFuaW1hdGUjYWRkQ2xhc3NcbiAgICAgICAgICogQG1ldGhvZE9mIG5nQW5pbWF0ZS4kYW5pbWF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogVHJpZ2dlcnMgYSBjdXN0b20gYW5pbWF0aW9uIGV2ZW50IGJhc2VkIG9mZiB0aGUgY2xhc3NOYW1lIHZhcmlhYmxlIGFuZCB0aGVuIGF0dGFjaGVzIHRoZSBjbGFzc05hbWUgdmFsdWUgdG8gdGhlIGVsZW1lbnQgYXMgYSBDU1MgY2xhc3MuXG4gICAgICAgICAqIFVubGlrZSB0aGUgb3RoZXIgYW5pbWF0aW9uIG1ldGhvZHMsIHRoZSBhbmltYXRlIHNlcnZpY2Ugd2lsbCBzdWZmaXggdGhlIGNsYXNzTmFtZSB2YWx1ZSB3aXRoIHtAdHlwZSAtYWRkfSBpbiBvcmRlciB0byBwcm92aWRlXG4gICAgICAgICAqIHRoZSBhbmltYXRlIHNlcnZpY2UgdGhlIHNldHVwIGFuZCBhY3RpdmUgQ1NTIGNsYXNzZXMgaW4gb3JkZXIgdG8gdHJpZ2dlciB0aGUgYW5pbWF0aW9uICh0aGlzIHdpbGwgYmUgc2tpcHBlZCBpZiBubyBDU1MgdHJhbnNpdGlvbnNcbiAgICAgICAgICogb3Iga2V5ZnJhbWVzIGFyZSBkZWZpbmVkIG9uIHRoZSAtYWRkIG9yIGJhc2UgQ1NTIGNsYXNzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQmVsb3cgaXMgYSBicmVha2Rvd24gb2YgZWFjaCBzdGVwIHRoYXQgb2NjdXJzIGR1cmluZyBhZGRDbGFzcyBhbmltYXRpb246XG4gICAgICAgICAqXG4gICAgICAgICAqIHwgQW5pbWF0aW9uIFN0ZXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFdoYXQgdGhlIGVsZW1lbnQgY2xhc3MgYXR0cmlidXRlIGxvb2tzIGxpa2UgfFxuICAgICAgICAgKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgICAgICogfCAxLiAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCAnc3VwZXInKSBpcyBjYWxsZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb25cIiAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICogfCAyLiAkYW5pbWF0ZSBydW5zIGFueSBKYXZhU2NyaXB0LWRlZmluZWQgYW5pbWF0aW9ucyBvbiB0aGUgZWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZVwiICAgICAgICAgICAgIHxcbiAgICAgICAgICogfCAzLiB0aGUgLnN1cGVyLWFkZCBjbGFzcyBhcmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBzdXBlci1hZGRcIiAgIHxcbiAgICAgICAgICogfCA0LiAkYW5pbWF0ZSBzY2FucyB0aGUgZWxlbWVudCBzdHlsZXMgdG8gZ2V0IHRoZSBDU1MgdHJhbnNpdGlvbi9hbmltYXRpb24gZHVyYXRpb24gYW5kIGRlbGF5ICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBzdXBlci1hZGRcIiAgIHxcbiAgICAgICAgICogfCA1LiAkYW5pbWF0ZSB3YWl0cyBmb3IgMTBtcyAodGhpcyBwZXJmb3JtcyBhIHJlZmxvdykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBzdXBlci1hZGRcIiAgIHxcbiAgICAgICAgICogfCA2LiB0aGUgLnN1cGVyLCAuc3VwZXItYWRkLWFjdGl2ZSBhbmQgLm5nLWFuaW1hdGUtYWN0aXZlIGNsYXNzZXMgYXJlIGFkZGVkICh0aGlzIHRyaWdnZXJzIHRoZSBDU1MgdHJhbnNpdGlvbi9hbmltYXRpb24pIHwgY2xhc3M9XCJteS1hbmltYXRpb24gbmctYW5pbWF0ZSBuZy1hbmltYXRlLWFjdGl2ZSBzdXBlciBzdXBlci1hZGQgc3VwZXItYWRkLWFjdGl2ZVwiICAgICAgICAgIHxcbiAgICAgICAgICogfCA3LiAkYW5pbWF0ZSB3YWl0cyBmb3IgWCBtaWxsaXNlY29uZHMgZm9yIHRoZSBhbmltYXRpb24gdG8gY29tcGxldGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gc3VwZXItYWRkIHN1cGVyLWFkZC1hY3RpdmVcIiAgfFxuICAgICAgICAgKiB8IDguIFRoZSBhbmltYXRpb24gZW5kcyBhbmQgYWxsIGdlbmVyYXRlZCBDU1MgY2xhc3NlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50ICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBzdXBlclwiICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDkuIFRoZSBzdXBlciBjbGFzcyBpcyBrZXB0IG9uIHRoZSBlbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBzdXBlclwiICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDEwLiBUaGUgZG9uZUNhbGxiYWNrKCkgY2FsbGJhY2sgaXMgZmlyZWQgKGlmIHByb3ZpZGVkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBzdXBlclwiICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgYW5pbWF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZWxlbWVudCBhbmQgdGhlbiBhbmltYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBkb25lQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICovXG4gICAgICAgIGFkZENsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgICBwZXJmb3JtQW5pbWF0aW9uKCdhZGRDbGFzcycsIGNsYXNzTmFtZSwgZWxlbWVudCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkZGVsZWdhdGUuYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICB9LCBkb25lQ2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgbmdBbmltYXRlLiRhbmltYXRlI3JlbW92ZUNsYXNzXG4gICAgICAgICAqIEBtZXRob2RPZiBuZ0FuaW1hdGUuJGFuaW1hdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRyaWdnZXJzIGEgY3VzdG9tIGFuaW1hdGlvbiBldmVudCBiYXNlZCBvZmYgdGhlIGNsYXNzTmFtZSB2YXJpYWJsZSBhbmQgdGhlbiByZW1vdmVzIHRoZSBDU1MgY2xhc3MgcHJvdmlkZWQgYnkgdGhlIGNsYXNzTmFtZSB2YWx1ZVxuICAgICAgICAgKiBmcm9tIHRoZSBlbGVtZW50LiBVbmxpa2UgdGhlIG90aGVyIGFuaW1hdGlvbiBtZXRob2RzLCB0aGUgYW5pbWF0ZSBzZXJ2aWNlIHdpbGwgc3VmZml4IHRoZSBjbGFzc05hbWUgdmFsdWUgd2l0aCB7QHR5cGUgLXJlbW92ZX0gaW5cbiAgICAgICAgICogb3JkZXIgdG8gcHJvdmlkZSB0aGUgYW5pbWF0ZSBzZXJ2aWNlIHRoZSBzZXR1cCBhbmQgYWN0aXZlIENTUyBjbGFzc2VzIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIGFuaW1hdGlvbiAodGhpcyB3aWxsIGJlIHNraXBwZWQgaWZcbiAgICAgICAgICogbm8gQ1NTIHRyYW5zaXRpb25zIG9yIGtleWZyYW1lcyBhcmUgZGVmaW5lZCBvbiB0aGUgLXJlbW92ZSBvciBiYXNlIENTUyBjbGFzc2VzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQmVsb3cgaXMgYSBicmVha2Rvd24gb2YgZWFjaCBzdGVwIHRoYXQgb2NjdXJzIGR1cmluZyByZW1vdmVDbGFzcyBhbmltYXRpb246XG4gICAgICAgICAqXG4gICAgICAgICAqIHwgQW5pbWF0aW9uIFN0ZXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgV2hhdCB0aGUgZWxlbWVudCBjbGFzcyBhdHRyaWJ1dGUgbG9va3MgbGlrZSAgICAgfFxuICAgICAgICAgKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgICAgICAgKiB8IDEuICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdzdXBlcicpIGlzIGNhbGxlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIHN1cGVyXCIgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqIHwgMi4gJGFuaW1hdGUgcnVucyBhbnkgSmF2YVNjcmlwdC1kZWZpbmVkIGFuaW1hdGlvbnMgb24gdGhlIGVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gc3VwZXIgbmctYW5pbWF0ZVwiICAgICAgIHxcbiAgICAgICAgICogfCAzLiB0aGUgLnN1cGVyLXJlbW92ZSBjbGFzcyBhcmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBzdXBlciBuZy1hbmltYXRlIHN1cGVyLXJlbW92ZVwifFxuICAgICAgICAgKiB8IDQuICRhbmltYXRlIHNjYW5zIHRoZSBlbGVtZW50IHN0eWxlcyB0byBnZXQgdGhlIENTUyB0cmFuc2l0aW9uL2FuaW1hdGlvbiBkdXJhdGlvbiBhbmQgZGVsYXkgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIHN1cGVyIG5nLWFuaW1hdGUgc3VwZXItcmVtb3ZlXCIgICB8XG4gICAgICAgICAqIHwgNS4gJGFuaW1hdGUgd2FpdHMgZm9yIDEwbXMgKHRoaXMgcGVyZm9ybXMgYSByZWZsb3cpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgY2xhc3M9XCJteS1hbmltYXRpb24gc3VwZXIgbmctYW5pbWF0ZSBzdXBlci1yZW1vdmVcIiAgIHxcbiAgICAgICAgICogfCA2LiB0aGUgLnN1cGVyLXJlbW92ZS1hY3RpdmUgYW5kIC5uZy1hbmltYXRlLWFjdGl2ZSBjbGFzc2VzIGFyZSBhZGRlZCBhbmQgLnN1cGVyIGlzIHJlbW92ZWQgKHRoaXMgdHJpZ2dlcnMgdGhlIENTUyB0cmFuc2l0aW9uL2FuaW1hdGlvbikgfCBjbGFzcz1cIm15LWFuaW1hdGlvbiBuZy1hbmltYXRlIG5nLWFuaW1hdGUtYWN0aXZlIHN1cGVyLXJlbW92ZSBzdXBlci1yZW1vdmUtYWN0aXZlXCIgICAgICAgICAgfFxuICAgICAgICAgKiB8IDcuICRhbmltYXRlIHdhaXRzIGZvciBYIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGFuaW1hdGlvbiB0byBjb21wbGV0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uIG5nLWFuaW1hdGUgbmctYW5pbWF0ZS1hY3RpdmUgc3VwZXItcmVtb3ZlIHN1cGVyLXJlbW92ZS1hY3RpdmVcIiAgIHxcbiAgICAgICAgICogfCA4LiBUaGUgYW5pbWF0aW9uIGVuZHMgYW5kIGFsbCBnZW5lcmF0ZWQgQ1NTIGNsYXNzZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCAgICAgICAgICAgICAgfCBjbGFzcz1cIm15LWFuaW1hdGlvblwiICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiB8IDkuIFRoZSBkb25lQ2FsbGJhY2soKSBjYWxsYmFjayBpcyBmaXJlZCAoaWYgcHJvdmlkZWQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGNsYXNzPVwibXktYW5pbWF0aW9uXCIgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBhbmltYXRlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3MgdGhhdCB3aWxsIGJlIGFuaW1hdGVkIGFuZCB0aGVuIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBkb25lQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXG4gICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgICBwZXJmb3JtQW5pbWF0aW9uKCdyZW1vdmVDbGFzcycsIGNsYXNzTmFtZSwgZWxlbWVudCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkZGVsZWdhdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICB9LCBkb25lQ2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAgICogQG5hbWUgbmdBbmltYXRlLiRhbmltYXRlI2VuYWJsZWRcbiAgICAgICAgICogQG1ldGhvZE9mIG5nQW5pbWF0ZS4kYW5pbWF0ZVxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdmFsdWUgSWYgcHJvdmlkZWQgdGhlbiBzZXQgdGhlIGFuaW1hdGlvbiBvbiBvciBvZmYuXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50PX0gZWxlbWVudCBJZiBwcm92aWRlZCB0aGVuIHRoZSBlbGVtZW50IHdpbGwgYmUgdXNlZCB0byByZXByZXNlbnQgdGhlIGVuYWJsZS9kaXNhYmxlIG9wZXJhdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDdXJyZW50IGFuaW1hdGlvbiBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEdsb2JhbGx5IGVuYWJsZXMvZGlzYWJsZXMgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlZCA6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfU1RBVEUpIHx8IHt9O1xuICAgICAgICAgICAgICAgIGRhdGEuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YShOR19BTklNQVRFX1NUQVRFLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcm9vdEFuaW1hdGVTdGF0ZS5kaXNhYmxlZCA9ICF2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB2YWx1ZSA9ICFyb290QW5pbWF0ZVN0YXRlLmRpc2FibGVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLypcbiAgICAgICAgYWxsIGFuaW1hdGlvbnMgY2FsbCB0aGlzIHNoYXJlZCBhbmltYXRpb24gdHJpZ2dlcmluZyBmdW5jdGlvbiBpbnRlcm5hbGx5LlxuICAgICAgICBUaGUgYW5pbWF0aW9uRXZlbnQgdmFyaWFibGUgcmVmZXJzIHRvIHRoZSBKYXZhU2NyaXB0IGFuaW1hdGlvbiBldmVudCB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkXG4gICAgICAgIGFuZCB0aGUgY2xhc3NOYW1lIHZhbHVlIGlzIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2l0aGluIHRoZVxuICAgICAgICBDU1MgY29kZS4gRWxlbWVudCwgcGFyZW50RWxlbWVudCBhbmQgYWZ0ZXJFbGVtZW50IGFyZSBwcm92aWRlZCBET00gZWxlbWVudHMgZm9yIHRoZSBhbmltYXRpb25cbiAgICAgICAgYW5kIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgb25jZSB0aGUgYW5pbWF0aW9uIGlzIGZ1bGx5IGNvbXBsZXRlLlxuICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHBlcmZvcm1BbmltYXRpb24oYW5pbWF0aW9uRXZlbnQsIGNsYXNzTmFtZSwgZWxlbWVudCwgcGFyZW50RWxlbWVudCwgYWZ0ZXJFbGVtZW50LCBkb21PcGVyYXRpb24sIGRvbmVDYWxsYmFjaykge1xuICAgICAgICB2YXIgY3VycmVudENsYXNzTmFtZSwgY2xhc3Nlcywgbm9kZSA9IGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYobm9kZSkge1xuICAgICAgICAgIGN1cnJlbnRDbGFzc05hbWUgPSBub2RlLmNsYXNzTmFtZTtcbiAgICAgICAgICBjbGFzc2VzID0gY3VycmVudENsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdHJhbnNjbHVkZWQgZGlyZWN0aXZlcyBtYXkgc29tZXRpbWVzIGZpcmUgYW4gYW5pbWF0aW9uIHVzaW5nIG9ubHkgY29tbWVudCBub2Rlc1xuICAgICAgICAvL2Jlc3QgdG8gY2F0Y2ggdGhpcyBlYXJseSBvbiB0byBwcmV2ZW50IGFueSBhbmltYXRpb24gb3BlcmF0aW9ucyBmcm9tIG9jY3VycmluZ1xuICAgICAgICBpZighbm9kZSB8fCAhaXNBbmltYXRhYmxlQ2xhc3NOYW1lKGNsYXNzZXMpKSB7XG4gICAgICAgICAgZmlyZURPTU9wZXJhdGlvbigpO1xuICAgICAgICAgIGNsb3NlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkxvb2t1cCA9ICgnICcgKyBjbGFzc2VzKS5yZXBsYWNlKC9cXHMrL2csJy4nKTtcbiAgICAgICAgaWYgKCFwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgcGFyZW50RWxlbWVudCA9IGFmdGVyRWxlbWVudCA/IGFmdGVyRWxlbWVudC5wYXJlbnQoKSA6IGVsZW1lbnQucGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGxvb2t1cChhbmltYXRpb25Mb29rdXApO1xuICAgICAgICB2YXIgaXNDbGFzc0Jhc2VkID0gYW5pbWF0aW9uRXZlbnQgPT0gJ2FkZENsYXNzJyB8fCBhbmltYXRpb25FdmVudCA9PSAncmVtb3ZlQ2xhc3MnO1xuICAgICAgICB2YXIgbmdBbmltYXRlU3RhdGUgPSBlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9TVEFURSkgfHwge307XG5cbiAgICAgICAgLy9za2lwIHRoZSBhbmltYXRpb24gaWYgYW5pbWF0aW9ucyBhcmUgZGlzYWJsZWQsIGEgcGFyZW50IGlzIGFscmVhZHkgYmVpbmcgYW5pbWF0ZWQsXG4gICAgICAgIC8vdGhlIGVsZW1lbnQgaXMgbm90IGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQgYm9keSBvciB0aGVuIGNvbXBsZXRlbHkgY2xvc2VcbiAgICAgICAgLy90aGUgYW5pbWF0aW9uIGlmIGFueSBtYXRjaGluZyBhbmltYXRpb25zIGFyZSBub3QgZm91bmQgYXQgYWxsLlxuICAgICAgICAvL05PVEU6IElFOCArIElFOSBzaG91bGQgY2xvc2UgcHJvcGVybHkgKHJ1biBjbG9zZUFuaW1hdGlvbigpKSBpbiBjYXNlIGEgTk8gYW5pbWF0aW9uIGlzIG5vdCBmb3VuZC5cbiAgICAgICAgaWYgKGFuaW1hdGlvbnNEaXNhYmxlZChlbGVtZW50LCBwYXJlbnRFbGVtZW50KSB8fCBtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGZpcmVET01PcGVyYXRpb24oKTtcbiAgICAgICAgICBjbG9zZUFuaW1hdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgICAgIC8vb25seSBhZGQgYW5pbWF0aW9ucyBpZiB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9uIGlzIG5vdCBzdHJ1Y3R1cmFsXG4gICAgICAgIC8vb3IgaWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIHJ1bm5pbmcgYXQgYWxsXG4gICAgICAgIGlmKCFuZ0FuaW1hdGVTdGF0ZS5ydW5uaW5nIHx8ICEoaXNDbGFzc0Jhc2VkICYmIG5nQW5pbWF0ZVN0YXRlLnN0cnVjdHVyYWwpKSB7XG4gICAgICAgICAgZm9yRWFjaChtYXRjaGVzLCBmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICAgIC8vYWRkIHRoZSBhbmltYXRpb24gdG8gdGhlIHF1ZXVlIHRvIGlmIGl0IGlzIGFsbG93ZWQgdG8gYmUgY2FuY2VsbGVkXG4gICAgICAgICAgICBpZighYW5pbWF0aW9uLmFsbG93Q2FuY2VsIHx8IGFuaW1hdGlvbi5hbGxvd0NhbmNlbChlbGVtZW50LCBhbmltYXRpb25FdmVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICB2YXIgYmVmb3JlRm4sIGFmdGVyRm4gPSBhbmltYXRpb25bYW5pbWF0aW9uRXZlbnRdO1xuXG4gICAgICAgICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBhIGxlYXZlIGFuaW1hdGlvbiBzaW5jZSB0aGVyZSBpcyBubyBwb2ludCBpbiBwZXJmb3JtaW5nIGFuXG4gICAgICAgICAgICAgIC8vYW5pbWF0aW9uIG9uIGEgZWxlbWVudCBub2RlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgICAgICAgICAgICBpZihhbmltYXRpb25FdmVudCA9PSAnbGVhdmUnKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRm4gPSBhZnRlckZuO1xuICAgICAgICAgICAgICAgIGFmdGVyRm4gPSBudWxsOyAvL3RoaXMgbXVzdCBiZSBmYWxzeSBzbyB0aGF0IHRoZSBhbmltYXRpb24gaXMgc2tpcHBlZCBmb3IgbGVhdmVcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVGbiA9IGFuaW1hdGlvblsnYmVmb3JlJyArIGFuaW1hdGlvbkV2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgYW5pbWF0aW9uRXZlbnQuc3Vic3RyKDEpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGJlZm9yZSA6IGJlZm9yZUZuLFxuICAgICAgICAgICAgICAgIGFmdGVyIDogYWZ0ZXJGblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcyB3b3VsZCBtZWFuIHRoYXQgYW4gYW5pbWF0aW9uIHdhcyBub3QgYWxsb3dlZCBzbyBsZXQgdGhlIGV4aXN0aW5nXG4gICAgICAgIC8vYW5pbWF0aW9uIGRvIGl0J3MgdGhpbmcgYW5kIGNsb3NlIHRoaXMgb25lIGVhcmx5XG4gICAgICAgIGlmKGFuaW1hdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmlyZURPTU9wZXJhdGlvbigpO1xuICAgICAgICAgIGZpcmVEb25lQ2FsbGJhY2tBc3luYygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcyB2YWx1ZSB3aWxsIGJlIHNlYXJjaGVkIGZvciBjbGFzcy1iYXNlZCBDU1MgY2xhc3NOYW1lIGxvb2t1cC4gVGhlcmVmb3JlLFxuICAgICAgICAvL3dlIHByZWZpeCBhbmQgc3VmZml4IHRoZSBjdXJyZW50IGNsYXNzTmFtZSB2YWx1ZSB3aXRoIHNwYWNlcyB0byBhdm9pZCBzdWJzdHJpbmdcbiAgICAgICAgLy9sb29rdXBzIG9mIGNsYXNzTmFtZSB0b2tlbnNcbiAgICAgICAgdmFyIGZ1dHVyZUNsYXNzTmFtZSA9ICcgJyArIGN1cnJlbnRDbGFzc05hbWUgKyAnICc7XG4gICAgICAgIGlmKG5nQW5pbWF0ZVN0YXRlLnJ1bm5pbmcpIHtcbiAgICAgICAgICAvL2lmIGFuIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZyBvbiB0aGUgZWxlbWVudCB0aGVuIGxldHMgdGFrZSB0aGUgc3RlcHNcbiAgICAgICAgICAvL3RvIGNhbmNlbCB0aGF0IGFuaW1hdGlvbiBhbmQgZmlyZSBhbnkgcmVxdWlyZWQgY2FsbGJhY2tzXG4gICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKG5nQW5pbWF0ZVN0YXRlLmNsb3NlQW5pbWF0aW9uVGltZW91dCk7XG4gICAgICAgICAgY2xlYW51cChlbGVtZW50KTtcbiAgICAgICAgICBjYW5jZWxBbmltYXRpb25zKG5nQW5pbWF0ZVN0YXRlLmFuaW1hdGlvbnMpO1xuXG4gICAgICAgICAgLy9pZiB0aGUgY2xhc3MgaXMgcmVtb3ZlZCBkdXJpbmcgdGhlIHJlZmxvdyB0aGVuIGl0IHdpbGwgcmV2ZXJ0IHRoZSBzdHlsZXMgdGVtcG9yYXJpbHlcbiAgICAgICAgICAvL2JhY2sgdG8gdGhlIGJhc2UgY2xhc3MgQ1NTIHN0eWxpbmcgY2F1c2luZyBhIGp1bXAtbGlrZSBlZmZlY3QgdG8gb2NjdXIuIFRoaXMgY2hlY2tcbiAgICAgICAgICAvL2hlcmUgZW5zdXJlcyB0aGF0IHRoZSBkb21PcGVyYXRpb24gaXMgb25seSBwZXJmb3JtZWQgYWZ0ZXIgdGhlIHJlZmxvdyBoYXMgY29tbWVuY2VkXG4gICAgICAgICAgaWYobmdBbmltYXRlU3RhdGUuYmVmb3JlQ29tcGxldGUpIHtcbiAgICAgICAgICAgIChuZ0FuaW1hdGVTdGF0ZS5kb25lIHx8IG5vb3ApKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZihpc0NsYXNzQmFzZWQgJiYgIW5nQW5pbWF0ZVN0YXRlLnN0cnVjdHVyYWwpIHtcbiAgICAgICAgICAgIC8vY2xhc3MtYmFzZWQgYW5pbWF0aW9ucyB3aWxsIGNvbXBhcmUgZWxlbWVudCBjbGFzc05hbWUgdmFsdWVzIGFmdGVyIGNhbmNlbGxpbmcgdGhlXG4gICAgICAgICAgICAvL3ByZXZpb3VzIGFuaW1hdGlvbiB0byBzZWUgaWYgdGhlIGVsZW1lbnQgcHJvcGVydGllcyBhbHJlYWR5IGNvbnRhaW4gdGhlIGZpbmFsIENTU1xuICAgICAgICAgICAgLy9jbGFzcyBhbmQgaWYgc28gdGhlbiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgc2tpcHBlZC4gU2luY2UgdGhlIGRvbU9wZXJhdGlvbiB3aWxsXG4gICAgICAgICAgICAvL2JlIHBlcmZvcm1lZCBvbmx5IGFmdGVyIHRoZSByZWZsb3cgaXMgY29tcGxldGUgdGhlbiBvdXIgZWxlbWVudCdzIGNsYXNzTmFtZSB2YWx1ZVxuICAgICAgICAgICAgLy93aWxsIGJlIGludmFsaWQuIFRoZXJlZm9yZSB0aGUgc2FtZSBzdHJpbmcgbWFuaXB1bGF0aW9uIHRoYXQgd291bGQgb2NjdXIgd2l0aGluIHRoZVxuICAgICAgICAgICAgLy9ET00gb3BlcmF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIGJlbG93IHNvIHRoYXQgdGhlIGNsYXNzIGNvbXBhcmlzb24gaXMgdmFsaWQuLi5cbiAgICAgICAgICAgIGZ1dHVyZUNsYXNzTmFtZSA9IG5nQW5pbWF0ZVN0YXRlLmV2ZW50ID09ICdyZW1vdmVDbGFzcycgP1xuICAgICAgICAgICAgICBmdXR1cmVDbGFzc05hbWUucmVwbGFjZShuZ0FuaW1hdGVTdGF0ZS5jbGFzc05hbWUsICcnKSA6XG4gICAgICAgICAgICAgIGZ1dHVyZUNsYXNzTmFtZSArIG5nQW5pbWF0ZVN0YXRlLmNsYXNzTmFtZSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL1RoZXJlIGlzIG5vIHBvaW50IGluIHBlcmZvcm0gYSBjbGFzcy1iYXNlZCBhbmltYXRpb24gaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBjb250YWluc1xuICAgICAgICAvLyhvbiBhZGRDbGFzcykgb3IgZG9lc24ndCBjb250YWluIChvbiByZW1vdmVDbGFzcykgdGhlIGNsYXNzTmFtZSBiZWluZyBhbmltYXRlZC5cbiAgICAgICAgLy9UaGUgcmVhc29uIHdoeSB0aGlzIGlzIGJlaW5nIGNhbGxlZCBhZnRlciB0aGUgcHJldmlvdXMgYW5pbWF0aW9ucyBhcmUgY2FuY2VsbGVkXG4gICAgICAgIC8vaXMgc28gdGhhdCB0aGUgQ1NTIGNsYXNzZXMgcHJlc2VudCBvbiB0aGUgZWxlbWVudCBjYW4gYmUgcHJvcGVybHkgZXhhbWluZWQuXG4gICAgICAgIHZhciBjbGFzc05hbWVUb2tlbiA9ICcgJyArIGNsYXNzTmFtZSArICcgJztcbiAgICAgICAgaWYoKGFuaW1hdGlvbkV2ZW50ID09ICdhZGRDbGFzcycgICAgJiYgZnV0dXJlQ2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lVG9rZW4pID49IDApIHx8XG4gICAgICAgICAgIChhbmltYXRpb25FdmVudCA9PSAncmVtb3ZlQ2xhc3MnICYmIGZ1dHVyZUNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZVRva2VuKSA9PSAtMSkpIHtcbiAgICAgICAgICBmaXJlRE9NT3BlcmF0aW9uKCk7XG4gICAgICAgICAgZmlyZURvbmVDYWxsYmFja0FzeW5jKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGUgbmctYW5pbWF0ZSBjbGFzcyBkb2VzIG5vdGhpbmcsIGJ1dCBpdCdzIGhlcmUgdG8gYWxsb3cgZm9yXG4gICAgICAgIC8vcGFyZW50IGFuaW1hdGlvbnMgdG8gZmluZCBhbmQgY2FuY2VsIGNoaWxkIGFuaW1hdGlvbnMgd2hlbiBuZWVkZWRcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhOR19BTklNQVRFX0NMQVNTX05BTUUpO1xuXG4gICAgICAgIGVsZW1lbnQuZGF0YShOR19BTklNQVRFX1NUQVRFLCB7XG4gICAgICAgICAgcnVubmluZzp0cnVlLFxuICAgICAgICAgIGV2ZW50OmFuaW1hdGlvbkV2ZW50LFxuICAgICAgICAgIGNsYXNzTmFtZTpjbGFzc05hbWUsXG4gICAgICAgICAgc3RydWN0dXJhbDohaXNDbGFzc0Jhc2VkLFxuICAgICAgICAgIGFuaW1hdGlvbnM6YW5pbWF0aW9ucyxcbiAgICAgICAgICBkb25lOm9uQmVmb3JlQW5pbWF0aW9uc0NvbXBsZXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vZmlyc3Qgd2UgcnVuIHRoZSBiZWZvcmUgYW5pbWF0aW9ucyBhbmQgd2hlbiBhbGwgb2YgdGhvc2UgYXJlIGNvbXBsZXRlXG4gICAgICAgIC8vdGhlbiB3ZSBwZXJmb3JtIHRoZSBET00gb3BlcmF0aW9uIGFuZCBydW4gdGhlIG5leHQgc2V0IG9mIGFuaW1hdGlvbnNcbiAgICAgICAgaW52b2tlUmVnaXN0ZXJlZEFuaW1hdGlvbkZucyhhbmltYXRpb25zLCAnYmVmb3JlJywgb25CZWZvcmVBbmltYXRpb25zQ29tcGxldGUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uQmVmb3JlQW5pbWF0aW9uc0NvbXBsZXRlKGNhbmNlbGxlZCkge1xuICAgICAgICAgIGZpcmVET01PcGVyYXRpb24oKTtcbiAgICAgICAgICBpZihjYW5jZWxsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNsb3NlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9zZXQgdGhlIGRvbmUgZnVuY3Rpb24gdG8gdGhlIGZpbmFsIGRvbmUgZnVuY3Rpb25cbiAgICAgICAgICAvL3NvIHRoYXQgdGhlIERPTSBldmVudCB3b24ndCBiZSBleGVjdXRlZCB0d2ljZSBieSBhY2NpZGVudFxuICAgICAgICAgIC8vaWYgdGhlIGFmdGVyIGFuaW1hdGlvbiBpcyBjYW5jZWxsZWQgYXMgd2VsbFxuICAgICAgICAgIHZhciBkYXRhID0gZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfU1RBVEUpO1xuICAgICAgICAgIGlmKGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEuZG9uZSA9IGNsb3NlQW5pbWF0aW9uO1xuICAgICAgICAgICAgZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfU1RBVEUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnZva2VSZWdpc3RlcmVkQW5pbWF0aW9uRm5zKGFuaW1hdGlvbnMsICdhZnRlcicsIGNsb3NlQW5pbWF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGludm9rZVJlZ2lzdGVyZWRBbmltYXRpb25GbnMoYW5pbWF0aW9ucywgcGhhc2UsIGFsbEFuaW1hdGlvbkZuc0NvbXBsZXRlKSB7XG4gICAgICAgICAgdmFyIGVuZEZuTmFtZSA9IHBoYXNlICsgJ0VuZCc7XG4gICAgICAgICAgZm9yRWFjaChhbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uUGhhc2VDb21wbGV0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MoaW5kZXgsIHBoYXNlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vdGhlcmUgYXJlIG5vIGJlZm9yZSBmdW5jdGlvbnMgZm9yIGVudGVyICsgbW92ZSBzaW5jZSB0aGUgRE9NXG4gICAgICAgICAgICAvL29wZXJhdGlvbnMgaGFwcGVuIGJlZm9yZSB0aGUgcGVyZm9ybUFuaW1hdGlvbiBtZXRob2QgZmlyZXNcbiAgICAgICAgICAgIGlmKHBoYXNlID09ICdiZWZvcmUnICYmIChhbmltYXRpb25FdmVudCA9PSAnZW50ZXInIHx8IGFuaW1hdGlvbkV2ZW50ID09ICdtb3ZlJykpIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUGhhc2VDb21wbGV0ZWQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihhbmltYXRpb25bcGhhc2VdKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbltlbmRGbk5hbWVdID0gaXNDbGFzc0Jhc2VkID9cbiAgICAgICAgICAgICAgICBhbmltYXRpb25bcGhhc2VdKGVsZW1lbnQsIGNsYXNzTmFtZSwgYW5pbWF0aW9uUGhhc2VDb21wbGV0ZWQpIDpcbiAgICAgICAgICAgICAgICBhbmltYXRpb25bcGhhc2VdKGVsZW1lbnQsIGFuaW1hdGlvblBoYXNlQ29tcGxldGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblBoYXNlQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBwcm9ncmVzcyhpbmRleCwgcGhhc2UpIHtcbiAgICAgICAgICAgIHZhciBwaGFzZUNvbXBsZXRpb25GbGFnID0gcGhhc2UgKyAnQ29tcGxldGUnO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGN1cnJlbnRBbmltYXRpb25bcGhhc2VDb21wbGV0aW9uRmxhZ10gPSB0cnVlO1xuICAgICAgICAgICAgKGN1cnJlbnRBbmltYXRpb25bZW5kRm5OYW1lXSB8fCBub29wKSgpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGk9MDtpPGFuaW1hdGlvbnMubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICBpZighYW5pbWF0aW9uc1tpXVtwaGFzZUNvbXBsZXRpb25GbGFnXSkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGxBbmltYXRpb25GbnNDb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVEb25lQ2FsbGJhY2tBc3luYygpIHtcbiAgICAgICAgICBkb25lQ2FsbGJhY2sgJiYgJHRpbWVvdXQoZG9uZUNhbGxiYWNrLCAwLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2l0IGlzIGxlc3MgY29tcGxpY2F0ZWQgdG8gdXNlIGEgZmxhZyB0aGFuIG1hbmFnaW5nIGFuZCBjYW5jZWxsaW5nXG4gICAgICAgIC8vdGltZW91dHMgY29udGFpbmluZyBtdWx0aXBsZSBjYWxsYmFja3MuXG4gICAgICAgIGZ1bmN0aW9uIGZpcmVET01PcGVyYXRpb24oKSB7XG4gICAgICAgICAgaWYoIWZpcmVET01PcGVyYXRpb24uaGFzQmVlblJ1bikge1xuICAgICAgICAgICAgZmlyZURPTU9wZXJhdGlvbi5oYXNCZWVuUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGRvbU9wZXJhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlQW5pbWF0aW9uKCkge1xuICAgICAgICAgIGlmKCFjbG9zZUFuaW1hdGlvbi5oYXNCZWVuUnVuKSB7XG4gICAgICAgICAgICBjbG9zZUFuaW1hdGlvbi5oYXNCZWVuUnVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfU1RBVEUpO1xuICAgICAgICAgICAgaWYoZGF0YSkge1xuICAgICAgICAgICAgICAvKiBvbmx5IHN0cnVjdHVyYWwgYW5pbWF0aW9ucyB3YWl0IGZvciByZWZsb3cgYmVmb3JlIHJlbW92aW5nIGFuXG4gICAgICAgICAgICAgICAgIGFuaW1hdGlvbiwgYnV0IGNsYXNzLWJhc2VkIGFuaW1hdGlvbnMgZG9uJ3QuIEFuIGV4YW1wbGUgb2YgdGhpc1xuICAgICAgICAgICAgICAgICBmYWlsaW5nIHdvdWxkIGJlIHdoZW4gYSBwYXJlbnQgSFRNTCB0YWcgaGFzIGEgbmctY2xhc3MgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgIGNhdXNpbmcgQUxMIGRpcmVjdGl2ZXMgYmVsb3cgdG8gc2tpcCBhbmltYXRpb25zIGR1cmluZyB0aGUgZGlnZXN0ICovXG4gICAgICAgICAgICAgIGlmKGlzQ2xhc3NCYXNlZCkge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoZWxlbWVudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jbG9zZUFuaW1hdGlvblRpbWVvdXQgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFudXAoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZGF0YShOR19BTklNQVRFX1NUQVRFLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyZURvbmVDYWxsYmFja0FzeW5jKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbENoaWxkQW5pbWF0aW9ucyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBub2RlID0gZXh0cmFjdEVsZW1lbnROb2RlKGVsZW1lbnQpO1xuICAgICAgICBmb3JFYWNoKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnLicgKyBOR19BTklNQVRFX0NMQVNTX05BTUUpLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGVsZW1lbnQuZGF0YShOR19BTklNQVRFX1NUQVRFKTtcbiAgICAgICAgICBpZihkYXRhKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25zKGRhdGEuYW5pbWF0aW9ucyk7XG4gICAgICAgICAgICBjbGVhbnVwKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbnMoYW5pbWF0aW9ucykge1xuICAgICAgICB2YXIgaXNDYW5jZWxsZWRGbGFnID0gdHJ1ZTtcbiAgICAgICAgZm9yRWFjaChhbmltYXRpb25zLCBmdW5jdGlvbihhbmltYXRpb24pIHtcbiAgICAgICAgICBpZighYW5pbWF0aW9ucy5iZWZvcmVDb21wbGV0ZSkge1xuICAgICAgICAgICAgKGFuaW1hdGlvbi5iZWZvcmVFbmQgfHwgbm9vcCkoaXNDYW5jZWxsZWRGbGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIWFuaW1hdGlvbnMuYWZ0ZXJDb21wbGV0ZSkge1xuICAgICAgICAgICAgKGFuaW1hdGlvbi5hZnRlckVuZCB8fCBub29wKShpc0NhbmNlbGxlZEZsYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFudXAoZWxlbWVudCkge1xuICAgICAgICBpZihpc01hdGNoaW5nRWxlbWVudChlbGVtZW50LCAkcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgICAgaWYoIXJvb3RBbmltYXRlU3RhdGUuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJvb3RBbmltYXRlU3RhdGUucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcm9vdEFuaW1hdGVTdGF0ZS5zdHJ1Y3R1cmFsID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoTkdfQU5JTUFURV9DTEFTU19OQU1FKTtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoTkdfQU5JTUFURV9TVEFURSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYW5pbWF0aW9uc0Rpc2FibGVkKGVsZW1lbnQsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHJvb3RBbmltYXRlU3RhdGUuZGlzYWJsZWQpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGlmKGlzTWF0Y2hpbmdFbGVtZW50KGVsZW1lbnQsICRyb290RWxlbWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gcm9vdEFuaW1hdGVTdGF0ZS5kaXNhYmxlZCB8fCByb290QW5pbWF0ZVN0YXRlLnJ1bm5pbmc7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgLy90aGUgZWxlbWVudCBkaWQgbm90IHJlYWNoIHRoZSByb290IGVsZW1lbnQgd2hpY2ggbWVhbnMgdGhhdCBpdFxuICAgICAgICAgIC8vaXMgbm90IGFwYXJ0IG9mIHRoZSBET00uIFRoZXJlZm9yZSB0aGVyZSBpcyBubyByZWFzb24gdG8gZG9cbiAgICAgICAgICAvL2FueSBhbmltYXRpb25zIG9uIGl0XG4gICAgICAgICAgaWYocGFyZW50RWxlbWVudC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgICAgdmFyIGlzUm9vdCA9IGlzTWF0Y2hpbmdFbGVtZW50KHBhcmVudEVsZW1lbnQsICRyb290RWxlbWVudCk7XG4gICAgICAgICAgdmFyIHN0YXRlID0gaXNSb290ID8gcm9vdEFuaW1hdGVTdGF0ZSA6IHBhcmVudEVsZW1lbnQuZGF0YShOR19BTklNQVRFX1NUQVRFKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gc3RhdGUgJiYgKCEhc3RhdGUuZGlzYWJsZWQgfHwgISFzdGF0ZS5ydW5uaW5nKTtcbiAgICAgICAgICBpZihpc1Jvb3QgfHwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKGlzUm9vdCkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUocGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQucGFyZW50KCkpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgICRhbmltYXRlUHJvdmlkZXIucmVnaXN0ZXIoJycsIFsnJHdpbmRvdycsICckc25pZmZlcicsICckdGltZW91dCcsIGZ1bmN0aW9uKCR3aW5kb3csICRzbmlmZmVyLCAkdGltZW91dCkge1xuICAgICAgLy8gRGV0ZWN0IHByb3BlciB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBldmVudCBuYW1lcy5cbiAgICAgIHZhciBDU1NfUFJFRklYID0gJycsIFRSQU5TSVRJT05fUFJPUCwgVFJBTlNJVElPTkVORF9FVkVOVCwgQU5JTUFUSU9OX1BST1AsIEFOSU1BVElPTkVORF9FVkVOVDtcblxuICAgICAgLy8gSWYgdW5wcmVmaXhlZCBldmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgYnV0IHdlYmtpdC1wcmVmaXhlZCBhcmUsIHVzZSB0aGUgbGF0dGVyLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHVzZSBXM0MgbmFtZXMsIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIHRoZW0gYXQgYWxsIHdpbGwganVzdCBpZ25vcmUgdGhlbS5cbiAgICAgIC8vIE5vdGU6IENocm9tZSBpbXBsZW1lbnRzIGB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmRgIGFuZCBkb2Vzbid0IGltcGxlbWVudCBgd2luZG93Lm9uYW5pbWF0aW9uZW5kYFxuICAgICAgLy8gYnV0IGF0IHRoZSBzYW1lIHRpbWUgZGlzcGF0Y2hlcyB0aGUgYGFuaW1hdGlvbmVuZGAgZXZlbnQgYW5kIG5vdCBgd2Via2l0QW5pbWF0aW9uRW5kYC5cbiAgICAgIC8vIFJlZ2lzdGVyIGJvdGggZXZlbnRzIGluIGNhc2UgYHdpbmRvdy5vbmFuaW1hdGlvbmVuZGAgaXMgbm90IHN1cHBvcnRlZCBiZWNhdXNlIG9mIHRoYXQsXG4gICAgICAvLyBkbyB0aGUgc2FtZSBmb3IgYHRyYW5zaXRpb25lbmRgIGFzIFNhZmFyaSBpcyBsaWtlbHkgdG8gZXhoaWJpdCBzaW1pbGFyIGJlaGF2aW9yLlxuICAgICAgLy8gQWxzbywgdGhlIG9ubHkgbW9kZXJuIGJyb3dzZXIgdGhhdCB1c2VzIHZlbmRvciBwcmVmaXhlcyBmb3IgdHJhbnNpdGlvbnMva2V5ZnJhbWVzIGlzIHdlYmtpdFxuICAgICAgLy8gdGhlcmVmb3JlIHRoZXJlIGlzIG5vIHJlYXNvbiB0byB0ZXN0IGFueW1vcmUgZm9yIG90aGVyIHZlbmRvciBwcmVmaXhlczogaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9dHJhbnNpdGlvblxuICAgICAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJiB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQ1NTX1BSRUZJWCA9ICctd2Via2l0LSc7XG4gICAgICAgIFRSQU5TSVRJT05fUFJPUCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICAgICAgVFJBTlNJVElPTkVORF9FVkVOVCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kIHRyYW5zaXRpb25lbmQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVFJBTlNJVElPTl9QUk9QID0gJ3RyYW5zaXRpb24nO1xuICAgICAgICBUUkFOU0lUSU9ORU5EX0VWRU5UID0gJ3RyYW5zaXRpb25lbmQnO1xuICAgICAgfVxuXG4gICAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiYgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgQ1NTX1BSRUZJWCA9ICctd2Via2l0LSc7XG4gICAgICAgIEFOSU1BVElPTl9QUk9QID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICAgIEFOSU1BVElPTkVORF9FVkVOVCA9ICd3ZWJraXRBbmltYXRpb25FbmQgYW5pbWF0aW9uZW5kJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFOSU1BVElPTl9QUk9QID0gJ2FuaW1hdGlvbic7XG4gICAgICAgIEFOSU1BVElPTkVORF9FVkVOVCA9ICdhbmltYXRpb25lbmQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgRFVSQVRJT05fS0VZID0gJ0R1cmF0aW9uJztcbiAgICAgIHZhciBQUk9QRVJUWV9LRVkgPSAnUHJvcGVydHknO1xuICAgICAgdmFyIERFTEFZX0tFWSA9ICdEZWxheSc7XG4gICAgICB2YXIgQU5JTUFUSU9OX0lURVJBVElPTl9DT1VOVF9LRVkgPSAnSXRlcmF0aW9uQ291bnQnO1xuICAgICAgdmFyIE5HX0FOSU1BVEVfUEFSRU5UX0tFWSA9ICckJG5nQW5pbWF0ZUtleSc7XG4gICAgICB2YXIgTkdfQU5JTUFURV9DU1NfREFUQV9LRVkgPSAnJCRuZ0FuaW1hdGVDU1MzRGF0YSc7XG4gICAgICB2YXIgRUxBUFNFRF9USU1FX01BWF9ERUNJTUFMX1BMQUNFUyA9IDM7XG4gICAgICB2YXIgQ0xPU0lOR19USU1FX0JVRkZFUiA9IDEuNTtcbiAgICAgIHZhciBPTkVfU0VDT05EID0gMTAwMDtcblxuICAgICAgdmFyIGFuaW1hdGlvbkNvdW50ZXIgPSAwO1xuICAgICAgdmFyIGxvb2t1cENhY2hlID0ge307XG4gICAgICB2YXIgcGFyZW50Q291bnRlciA9IDA7XG4gICAgICB2YXIgYW5pbWF0aW9uUmVmbG93UXVldWUgPSBbXTtcbiAgICAgIHZhciBhbmltYXRpb25FbGVtZW50UXVldWUgPSBbXTtcbiAgICAgIHZhciBhbmltYXRpb25UaW1lcjtcbiAgICAgIHZhciBjbG9zaW5nQW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICB2YXIgdGltZU91dCA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gYWZ0ZXJSZWZsb3coZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgJHRpbWVvdXQuY2FuY2VsKGFuaW1hdGlvblRpbWVyKTtcblxuICAgICAgICBhbmltYXRpb25SZWZsb3dRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgICB2YXIgbm9kZSA9IGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudCA9IGFuZ3VsYXIuZWxlbWVudChub2RlKTtcbiAgICAgICAgYW5pbWF0aW9uRWxlbWVudFF1ZXVlLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgdmFyIGVsZW1lbnREYXRhID0gZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfQ1NTX0RBVEFfS0VZKTtcbiAgICAgICAgY2xvc2luZ0FuaW1hdGlvblRpbWUgPSBNYXRoLm1heChjbG9zaW5nQW5pbWF0aW9uVGltZSxcbiAgICAgICAgICAoZWxlbWVudERhdGEubWF4RGVsYXkgKyBlbGVtZW50RGF0YS5tYXhEdXJhdGlvbikgKiBDTE9TSU5HX1RJTUVfQlVGRkVSICogT05FX1NFQ09ORCk7XG5cbiAgICAgICAgLy9ieSBwbGFjaW5nIGEgY291bnRlciB3ZSBjYW4gYXZvaWQgYW4gYWNjaWRlbnRhbFxuICAgICAgICAvL3JhY2UgY29uZGl0aW9uIHdoaWNoIG1heSBjbG9zZSBhbiBhbmltYXRpb24gd2hlblxuICAgICAgICAvL2EgZm9sbG93LXVwIGFuaW1hdGlvbiBpcyBtaWR3YXkgaW4gaXRzIGFuaW1hdGlvblxuICAgICAgICBlbGVtZW50RGF0YS5hbmltYXRpb25Db3VudCA9IGFuaW1hdGlvbkNvdW50ZXI7XG5cbiAgICAgICAgYW5pbWF0aW9uVGltZXIgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3JFYWNoKGFuaW1hdGlvblJlZmxvd1F1ZXVlLCBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vY29weSB0aGUgbGlzdCBvZiBlbGVtZW50cyBzbyB0aGF0IHN1Y2Nlc3NpdmVcbiAgICAgICAgICAvL2FuaW1hdGlvbnMgd29uJ3QgY29uZmxpY3QgaWYgdGhleSdyZSBhZGRlZCBiZWZvcmVcbiAgICAgICAgICAvL3RoZSBjbG9zaW5nIGFuaW1hdGlvbiB0aW1lb3V0IGhhcyBydW5cbiAgICAgICAgICB2YXIgZWxlbWVudFF1ZXVlU25hcHNob3QgPSBbXTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uQ291bnRlclNuYXBzaG90ID0gYW5pbWF0aW9uQ291bnRlcjtcbiAgICAgICAgICBmb3JFYWNoKGFuaW1hdGlvbkVsZW1lbnRRdWV1ZSwgZnVuY3Rpb24oZWxtKSB7XG4gICAgICAgICAgICBlbGVtZW50UXVldWVTbmFwc2hvdC5wdXNoKGVsbSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsb3NlQWxsQW5pbWF0aW9ucyhlbGVtZW50UXVldWVTbmFwc2hvdCwgYW5pbWF0aW9uQ291bnRlclNuYXBzaG90KTtcbiAgICAgICAgICAgIGVsZW1lbnRRdWV1ZVNuYXBzaG90ID0gbnVsbDtcbiAgICAgICAgICB9LCBjbG9zaW5nQW5pbWF0aW9uVGltZSwgZmFsc2UpO1xuXG4gICAgICAgICAgYW5pbWF0aW9uUmVmbG93UXVldWUgPSBbXTtcbiAgICAgICAgICBhbmltYXRpb25FbGVtZW50UXVldWUgPSBbXTtcbiAgICAgICAgICBhbmltYXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgICAgbG9va3VwQ2FjaGUgPSB7fTtcbiAgICAgICAgICBjbG9zaW5nQW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgYW5pbWF0aW9uQ291bnRlcisrO1xuICAgICAgICB9LCAxMCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9zZUFsbEFuaW1hdGlvbnMoZWxlbWVudHMsIGNvdW50KSB7XG4gICAgICAgIGZvckVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgZWxlbWVudERhdGEgPSBlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9DU1NfREFUQV9LRVkpO1xuICAgICAgICAgIGlmKGVsZW1lbnREYXRhICYmIGVsZW1lbnREYXRhLmFuaW1hdGlvbkNvdW50ID09IGNvdW50KSB7XG4gICAgICAgICAgICAoZWxlbWVudERhdGEuY2xvc2VBbmltYXRpb25GbiB8fCBub29wKSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRBbmltYXRpb25EZXRhaWxzKGVsZW1lbnQsIGNhY2hlS2V5KSB7XG4gICAgICAgIHZhciBkYXRhID0gY2FjaGVLZXkgPyBsb29rdXBDYWNoZVtjYWNoZUtleV0gOiBudWxsO1xuICAgICAgICBpZighZGF0YSkge1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uRGVsYXkgPSAwO1xuICAgICAgICAgIHZhciBhbmltYXRpb25EdXJhdGlvbiA9IDA7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbkRlbGF5ID0gMDtcbiAgICAgICAgICB2YXIgdHJhbnNpdGlvbkRlbGF5U3R5bGU7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbkRlbGF5U3R5bGU7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvblN0eWxlO1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uUHJvcGVydHlTdHlsZTtcblxuICAgICAgICAgIC8vd2Ugd2FudCBhbGwgdGhlIHN0eWxlcyBkZWZpbmVkIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAgICAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudFN0eWxlcyA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB8fCB7fTtcblxuICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb25TdHlsZSA9IGVsZW1lbnRTdHlsZXNbVFJBTlNJVElPTl9QUk9QICsgRFVSQVRJT05fS0VZXTtcblxuICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBNYXRoLm1heChwYXJzZU1heFRpbWUodHJhbnNpdGlvbkR1cmF0aW9uU3R5bGUpLCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eVN0eWxlID0gZWxlbWVudFN0eWxlc1tUUkFOU0lUSU9OX1BST1AgKyBQUk9QRVJUWV9LRVldO1xuXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25EZWxheVN0eWxlID0gZWxlbWVudFN0eWxlc1tUUkFOU0lUSU9OX1BST1AgKyBERUxBWV9LRVldO1xuXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25EZWxheSAgPSBNYXRoLm1heChwYXJzZU1heFRpbWUodHJhbnNpdGlvbkRlbGF5U3R5bGUpLCB0cmFuc2l0aW9uRGVsYXkpO1xuXG4gICAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5U3R5bGUgPSBlbGVtZW50U3R5bGVzW0FOSU1BVElPTl9QUk9QICsgREVMQVlfS0VZXTtcblxuICAgICAgICAgICAgICBhbmltYXRpb25EZWxheSAgID0gTWF0aC5tYXgocGFyc2VNYXhUaW1lKGFuaW1hdGlvbkRlbGF5U3R5bGUpLCBhbmltYXRpb25EZWxheSk7XG5cbiAgICAgICAgICAgICAgdmFyIGFEdXJhdGlvbiAgPSBwYXJzZU1heFRpbWUoZWxlbWVudFN0eWxlc1tBTklNQVRJT05fUFJPUCArIERVUkFUSU9OX0tFWV0pO1xuXG4gICAgICAgICAgICAgIGlmKGFEdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBhRHVyYXRpb24gKj0gcGFyc2VJbnQoZWxlbWVudFN0eWxlc1tBTklNQVRJT05fUFJPUCArIEFOSU1BVElPTl9JVEVSQVRJT05fQ09VTlRfS0VZXSwgMTApIHx8IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbiA9IE1hdGgubWF4KGFEdXJhdGlvbiwgYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICB0b3RhbCA6IDAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHlTdHlsZTogdHJhbnNpdGlvblByb3BlcnR5U3R5bGUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb25TdHlsZTogdHJhbnNpdGlvbkR1cmF0aW9uU3R5bGUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRGVsYXlTdHlsZTogdHJhbnNpdGlvbkRlbGF5U3R5bGUsXG4gICAgICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IHRyYW5zaXRpb25EZWxheSxcbiAgICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXlTdHlsZTogYW5pbWF0aW9uRGVsYXlTdHlsZSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5OiBhbmltYXRpb25EZWxheSxcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvblxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIGxvb2t1cENhY2hlW2NhY2hlS2V5XSA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZU1heFRpbWUoc3RyKSB7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IDA7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBhbmd1bGFyLmlzU3RyaW5nKHN0cikgP1xuICAgICAgICAgIHN0ci5zcGxpdCgvXFxzKixcXHMqLykgOlxuICAgICAgICAgIFtdO1xuICAgICAgICBmb3JFYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsIG1heFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXhWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoZWxlbWVudCkge1xuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IGVsZW1lbnQucGFyZW50KCk7XG4gICAgICAgIHZhciBwYXJlbnRJRCA9IHBhcmVudEVsZW1lbnQuZGF0YShOR19BTklNQVRFX1BBUkVOVF9LRVkpO1xuICAgICAgICBpZighcGFyZW50SUQpIHtcbiAgICAgICAgICBwYXJlbnRFbGVtZW50LmRhdGEoTkdfQU5JTUFURV9QQVJFTlRfS0VZLCArK3BhcmVudENvdW50ZXIpO1xuICAgICAgICAgIHBhcmVudElEID0gcGFyZW50Q291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50SUQgKyAnLScgKyBleHRyYWN0RWxlbWVudE5vZGUoZWxlbWVudCkuY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbmltYXRlU2V0dXAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IGdldENhY2hlS2V5KGVsZW1lbnQpO1xuICAgICAgICB2YXIgZXZlbnRDYWNoZUtleSA9IGNhY2hlS2V5ICsgJyAnICsgY2xhc3NOYW1lO1xuICAgICAgICB2YXIgc3RhZ2dlciA9IHt9O1xuICAgICAgICB2YXIgaWkgPSBsb29rdXBDYWNoZVtldmVudENhY2hlS2V5XSA/ICsrbG9va3VwQ2FjaGVbZXZlbnRDYWNoZUtleV0udG90YWwgOiAwO1xuXG4gICAgICAgIGlmKGlpID4gMCkge1xuICAgICAgICAgIHZhciBzdGFnZ2VyQ2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJy1zdGFnZ2VyJztcbiAgICAgICAgICB2YXIgc3RhZ2dlckNhY2hlS2V5ID0gY2FjaGVLZXkgKyAnICcgKyBzdGFnZ2VyQ2xhc3NOYW1lO1xuICAgICAgICAgIHZhciBhcHBseUNsYXNzZXMgPSAhbG9va3VwQ2FjaGVbc3RhZ2dlckNhY2hlS2V5XTtcblxuICAgICAgICAgIGFwcGx5Q2xhc3NlcyAmJiBlbGVtZW50LmFkZENsYXNzKHN0YWdnZXJDbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3RhZ2dlciA9IGdldEVsZW1lbnRBbmltYXRpb25EZXRhaWxzKGVsZW1lbnQsIHN0YWdnZXJDYWNoZUtleSk7XG5cbiAgICAgICAgICBhcHBseUNsYXNzZXMgJiYgZWxlbWVudC5yZW1vdmVDbGFzcyhzdGFnZ2VyQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblxuICAgICAgICB2YXIgdGltaW5ncyA9IGdldEVsZW1lbnRBbmltYXRpb25EZXRhaWxzKGVsZW1lbnQsIGV2ZW50Q2FjaGVLZXkpO1xuXG4gICAgICAgIC8qIHRoZXJlIGlzIG5vIHBvaW50IGluIHBlcmZvcm1pbmcgYSByZWZsb3cgaWYgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICB0aW1lb3V0IGlzIGVtcHR5ICh0aGlzIHdvdWxkIGNhdXNlIGEgZmxpY2tlciBidWcgbm9ybWFsbHlcbiAgICAgICAgICAgaW4gdGhlIHBhZ2UuIFRoZXJlIGlzIGFsc28gbm8gcG9pbnQgaW4gcGVyZm9ybWluZyBhbiBhbmltYXRpb25cbiAgICAgICAgICAgdGhhdCBvbmx5IGhhcyBhIGRlbGF5IGFuZCBubyBkdXJhdGlvbiAqL1xuICAgICAgICB2YXIgbWF4RGVsYXkgPSBNYXRoLm1heCh0aW1pbmdzLnRyYW5zaXRpb25EZWxheSwgdGltaW5ncy5hbmltYXRpb25EZWxheSk7XG4gICAgICAgIHZhciBtYXhEdXJhdGlvbiA9IE1hdGgubWF4KHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uLCB0aW1pbmdzLmFuaW1hdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgaWYobWF4RHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90ZW1wb3JhcmlseSBkaXNhYmxlIHRoZSB0cmFuc2l0aW9uIHNvIHRoYXQgdGhlIGVudGVyIHN0eWxlc1xuICAgICAgICAvL2Rvbid0IGFuaW1hdGUgdHdpY2UgKHRoaXMgaXMgaGVyZSB0byBhdm9pZCBhIGJ1ZyBpbiBDaHJvbWUvRkYpLlxuICAgICAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gJyc7XG4gICAgICAgIHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uID4gMCA/XG4gICAgICAgICAgYmxvY2tUcmFuc2l0aW9ucyhlbGVtZW50KSA6XG4gICAgICAgICAgYmxvY2tLZXlmcmFtZUFuaW1hdGlvbnMoZWxlbWVudCk7XG5cbiAgICAgICAgZm9yRWFjaChjbGFzc05hbWUuc3BsaXQoJyAnKSwgZnVuY3Rpb24oa2xhc3MsIGkpIHtcbiAgICAgICAgICBhY3RpdmVDbGFzc05hbWUgKz0gKGkgPiAwID8gJyAnIDogJycpICsga2xhc3MgKyAnLWFjdGl2ZSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsZW1lbnQuZGF0YShOR19BTklNQVRFX0NTU19EQVRBX0tFWSwge1xuICAgICAgICAgIGNsYXNzTmFtZSA6IGNsYXNzTmFtZSxcbiAgICAgICAgICBhY3RpdmVDbGFzc05hbWUgOiBhY3RpdmVDbGFzc05hbWUsXG4gICAgICAgICAgbWF4RHVyYXRpb24gOiBtYXhEdXJhdGlvbixcbiAgICAgICAgICBtYXhEZWxheSA6IG1heERlbGF5LFxuICAgICAgICAgIGNsYXNzZXMgOiBjbGFzc05hbWUgKyAnICcgKyBhY3RpdmVDbGFzc05hbWUsXG4gICAgICAgICAgdGltaW5ncyA6IHRpbWluZ3MsXG4gICAgICAgICAgc3RhZ2dlciA6IHN0YWdnZXIsXG4gICAgICAgICAgaWkgOiBpaVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYmxvY2tUcmFuc2l0aW9ucyhlbGVtZW50KSB7XG4gICAgICAgIGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KS5zdHlsZVtUUkFOU0lUSU9OX1BST1AgKyBQUk9QRVJUWV9LRVldID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBibG9ja0tleWZyYW1lQW5pbWF0aW9ucyhlbGVtZW50KSB7XG4gICAgICAgIGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KS5zdHlsZVtBTklNQVRJT05fUFJPUF0gPSAnbm9uZSAwcyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVuYmxvY2tUcmFuc2l0aW9ucyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBwcm9wID0gVFJBTlNJVElPTl9QUk9QICsgUFJPUEVSVFlfS0VZO1xuICAgICAgICB2YXIgbm9kZSA9IGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgaWYobm9kZS5zdHlsZVtwcm9wXSAmJiBub2RlLnN0eWxlW3Byb3BdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBub2RlLnN0eWxlW3Byb3BdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdW5ibG9ja0tleWZyYW1lQW5pbWF0aW9ucyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBwcm9wID0gQU5JTUFUSU9OX1BST1A7XG4gICAgICAgIHZhciBub2RlID0gZXh0cmFjdEVsZW1lbnROb2RlKGVsZW1lbnQpO1xuICAgICAgICBpZihub2RlLnN0eWxlW3Byb3BdICYmIG5vZGUuc3R5bGVbcHJvcF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5vZGUuc3R5bGVbcHJvcF0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhbmltYXRlUnVuKGVsZW1lbnQsIGNsYXNzTmFtZSwgYWN0aXZlQW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnREYXRhID0gZWxlbWVudC5kYXRhKE5HX0FOSU1BVEVfQ1NTX0RBVEFfS0VZKTtcbiAgICAgICAgdmFyIG5vZGUgPSBleHRyYWN0RWxlbWVudE5vZGUoZWxlbWVudCk7XG4gICAgICAgIGlmKG5vZGUuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSB8fCAhZWxlbWVudERhdGEpIHtcbiAgICAgICAgICBhY3RpdmVBbmltYXRpb25Db21wbGV0ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aW1pbmdzID0gZWxlbWVudERhdGEudGltaW5ncztcbiAgICAgICAgdmFyIHN0YWdnZXIgPSBlbGVtZW50RGF0YS5zdGFnZ2VyO1xuICAgICAgICB2YXIgbWF4RHVyYXRpb24gPSBlbGVtZW50RGF0YS5tYXhEdXJhdGlvbjtcbiAgICAgICAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IGVsZW1lbnREYXRhLmFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgdmFyIG1heERlbGF5VGltZSA9IE1hdGgubWF4KHRpbWluZ3MudHJhbnNpdGlvbkRlbGF5LCB0aW1pbmdzLmFuaW1hdGlvbkRlbGF5KSAqIE9ORV9TRUNPTkQ7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY3NzM0FuaW1hdGlvbkV2ZW50cyA9IEFOSU1BVElPTkVORF9FVkVOVCArICcgJyArIFRSQU5TSVRJT05FTkRfRVZFTlQ7XG4gICAgICAgIHZhciBpaSA9IGVsZW1lbnREYXRhLmlpO1xuXG4gICAgICAgIHZhciBzdHlsZSA9ICcnLCBhcHBsaWVkU3R5bGVzID0gW107XG4gICAgICAgIGlmKHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uID4gMCkge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eVN0eWxlID0gdGltaW5ncy50cmFuc2l0aW9uUHJvcGVydHlTdHlsZTtcbiAgICAgICAgICBpZihwcm9wZXJ0eVN0eWxlLmluZGV4T2YoJ2FsbCcpID09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZSArPSBDU1NfUFJFRklYICsgJ3RyYW5zaXRpb24tcHJvcGVydHk6ICcgKyBwcm9wZXJ0eVN0eWxlICsgJzsnO1xuICAgICAgICAgICAgc3R5bGUgKz0gQ1NTX1BSRUZJWCArICd0cmFuc2l0aW9uLWR1cmF0aW9uOiAnICsgdGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb25TdHlsZSArICdzOyc7XG4gICAgICAgICAgICBhcHBsaWVkU3R5bGVzLnB1c2goQ1NTX1BSRUZJWCArICd0cmFuc2l0aW9uLXByb3BlcnR5Jyk7XG4gICAgICAgICAgICBhcHBsaWVkU3R5bGVzLnB1c2goQ1NTX1BSRUZJWCArICd0cmFuc2l0aW9uLWR1cmF0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoaWkgPiAwKSB7XG4gICAgICAgICAgaWYoc3RhZ2dlci50cmFuc2l0aW9uRGVsYXkgPiAwICYmIHN0YWdnZXIudHJhbnNpdGlvbkR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsYXlTdHlsZSA9IHRpbWluZ3MudHJhbnNpdGlvbkRlbGF5U3R5bGU7XG4gICAgICAgICAgICBzdHlsZSArPSBDU1NfUFJFRklYICsgJ3RyYW5zaXRpb24tZGVsYXk6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZVN0YWdnZXJEZWxheShkZWxheVN0eWxlLCBzdGFnZ2VyLnRyYW5zaXRpb25EZWxheSwgaWkpICsgJzsgJztcbiAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMucHVzaChDU1NfUFJFRklYICsgJ3RyYW5zaXRpb24tZGVsYXknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihzdGFnZ2VyLmFuaW1hdGlvbkRlbGF5ID4gMCAmJiBzdGFnZ2VyLmFuaW1hdGlvbkR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICBzdHlsZSArPSBDU1NfUFJFRklYICsgJ2FuaW1hdGlvbi1kZWxheTogJyArXG4gICAgICAgICAgICAgICAgICAgICBwcmVwYXJlU3RhZ2dlckRlbGF5KHRpbWluZ3MuYW5pbWF0aW9uRGVsYXlTdHlsZSwgc3RhZ2dlci5hbmltYXRpb25EZWxheSwgaWkpICsgJzsgJztcbiAgICAgICAgICAgIGFwcGxpZWRTdHlsZXMucHVzaChDU1NfUFJFRklYICsgJ2FuaW1hdGlvbi1kZWxheScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGFwcGxpZWRTdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vdGhlIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQgbWF5IHNvbWV0aW1lcyBjb250YWluIGNvbW1lbnQgbm9kZXMgaW5cbiAgICAgICAgICAvL3RoZSBqcUxpdGUgb2JqZWN0LCBzbyB3ZSdyZSBzYWZlIHRvIHVzZSBhIHNpbmdsZSB2YXJpYWJsZSB0byBob3VzZVxuICAgICAgICAgIC8vdGhlIHN0eWxlcyBzaW5jZSB0aGVyZSBpcyBhbHdheXMgb25seSBvbmUgZWxlbWVudCBiZWluZyBhbmltYXRlZFxuICAgICAgICAgIHZhciBvbGRTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnO1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIG9sZFN0eWxlICsgJyAnICsgc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5vbihjc3MzQW5pbWF0aW9uRXZlbnRzLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhY3RpdmVDbGFzc05hbWUpO1xuICAgICAgICBlbGVtZW50RGF0YS5jbG9zZUFuaW1hdGlvbkZuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb25FbmQoKTtcbiAgICAgICAgICBhY3RpdmVBbmltYXRpb25Db21wbGV0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb25FbmQ7XG5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkIGJ5ICRhbmltYXRlIHNvXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0YWNoIHRoaXMgaW50ZXJuYWxseSB0byB0aGVcbiAgICAgICAgLy8gdGltZW91dCBkb25lIG1ldGhvZC5cbiAgICAgICAgZnVuY3Rpb24gb25FbmQoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgZWxlbWVudC5vZmYoY3NzM0FuaW1hdGlvbkV2ZW50cywgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhhY3RpdmVDbGFzc05hbWUpO1xuICAgICAgICAgIGFuaW1hdGVDbG9zZShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgIHZhciBub2RlID0gZXh0cmFjdEVsZW1lbnROb2RlKGVsZW1lbnQpO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gYXBwbGllZFN0eWxlcykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShhcHBsaWVkU3R5bGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgdmFyIGV2ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcbiAgICAgICAgICB2YXIgdGltZVN0YW1wID0gZXYuJG1hbnVhbFRpbWVTdGFtcCB8fCBldi50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvKiBGaXJlZm94IChvciBwb3NzaWJseSBqdXN0IEdlY2tvKSBsaWtlcyB0byBub3Qgcm91bmQgdmFsdWVzIHVwXG4gICAgICAgICAgICogd2hlbiBhIG1zIG1lYXN1cmVtZW50IGlzIHVzZWQgZm9yIHRoZSBhbmltYXRpb24gKi9cbiAgICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwYXJzZUZsb2F0KGV2LmVsYXBzZWRUaW1lLnRvRml4ZWQoRUxBUFNFRF9USU1FX01BWF9ERUNJTUFMX1BMQUNFUykpO1xuXG4gICAgICAgICAgLyogJG1hbnVhbFRpbWVTdGFtcCBpcyBhIG1vY2tlZCB0aW1lU3RhbXAgdmFsdWUgd2hpY2ggaXMgc2V0XG4gICAgICAgICAgICogd2l0aGluIGJyb3dzZXJUcmlnZ2VyKCkuIFRoaXMgaXMgb25seSBoZXJlIHNvIHRoYXQgdGVzdHMgY2FuXG4gICAgICAgICAgICogbW9jayBhbmltYXRpb25zIHByb3Blcmx5LiBSZWFsIGV2ZW50cyBmYWxsYmFjayB0byBldmVudC50aW1lU3RhbXAsXG4gICAgICAgICAgICogb3IsIGlmIHRoZXkgZG9uJ3QsIHRoZW4gYSB0aW1lU3RhbXAgaXMgYXV0b21hdGljYWxseSBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAgICAgICAqIFdlJ3JlIGNoZWNraW5nIHRvIHNlZSBpZiB0aGUgdGltZVN0YW1wIHN1cnBhc3NlcyB0aGUgZXhwZWN0ZWQgZGVsYXksXG4gICAgICAgICAgICogYnV0IHdlJ3JlIHVzaW5nIGVsYXBzZWRUaW1lIGluc3RlYWQgb2YgdGhlIHRpbWVTdGFtcCBvbiB0aGUgMm5kXG4gICAgICAgICAgICogcHJlLWNvbmRpdGlvbiBzaW5jZSBhbmltYXRpb25zIHNvbWV0aW1lcyBjbG9zZSBvZmYgZWFybHkgKi9cbiAgICAgICAgICBpZihNYXRoLm1heCh0aW1lU3RhbXAgLSBzdGFydFRpbWUsIDApID49IG1heERlbGF5VGltZSAmJiBlbGFwc2VkVGltZSA+PSBtYXhEdXJhdGlvbikge1xuICAgICAgICAgICAgYWN0aXZlQW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHJlcGFyZVN0YWdnZXJEZWxheShkZWxheVN0eWxlLCBzdGFnZ2VyRGVsYXksIGluZGV4KSB7XG4gICAgICAgIHZhciBzdHlsZSA9ICcnO1xuICAgICAgICBmb3JFYWNoKGRlbGF5U3R5bGUuc3BsaXQoJywnKSwgZnVuY3Rpb24odmFsLCBpKSB7XG4gICAgICAgICAgc3R5bGUgKz0gKGkgPiAwID8gJywnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAoaW5kZXggKiBzdGFnZ2VyRGVsYXkgKyBwYXJzZUludCh2YWwsIDEwKSkgKyAncyc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFuaW1hdGVCZWZvcmUoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmKGFuaW1hdGVTZXR1cChlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2FuY2VsbGVkICYmIGFuaW1hdGVDbG9zZShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYW5pbWF0ZUFmdGVyKGVsZW1lbnQsIGNsYXNzTmFtZSwgYWZ0ZXJBbmltYXRpb25Db21wbGV0ZSkge1xuICAgICAgICBpZihlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9DU1NfREFUQV9LRVkpKSB7XG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGVSdW4oZWxlbWVudCwgY2xhc3NOYW1lLCBhZnRlckFuaW1hdGlvbkNvbXBsZXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRlQ2xvc2UoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICBhZnRlckFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYW5pbWF0ZShlbGVtZW50LCBjbGFzc05hbWUsIGFuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgIC8vSWYgdGhlIGFuaW1hdGVTZXR1cCBmdW5jdGlvbiBkb2Vzbid0IGJvdGhlciByZXR1cm5pbmcgYVxuICAgICAgICAvL2NhbmNlbGxhdGlvbiBmdW5jdGlvbiB0aGVuIGl0IG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gYW5pbWF0aW9uXG4gICAgICAgIC8vdG8gcGVyZm9ybSBhdCBhbGxcbiAgICAgICAgdmFyIHByZVJlZmxvd0NhbmNlbGxhdGlvbiA9IGFuaW1hdGVCZWZvcmUoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgaWYoIXByZVJlZmxvd0NhbmNlbGxhdGlvbikge1xuICAgICAgICAgIGFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGVyZSBhcmUgdHdvIGNhbmNlbGxhdGlvbiBmdW5jdGlvbnM6IG9uZSBpcyBiZWZvcmUgdGhlIGZpcnN0XG4gICAgICAgIC8vcmVmbG93IGFuaW1hdGlvbiBhbmQgdGhlIHNlY29uZCBpcyBkdXJpbmcgdGhlIGFjdGl2ZSBzdGF0ZVxuICAgICAgICAvL2FuaW1hdGlvbi4gVGhlIGZpcnN0IGZ1bmN0aW9uIHdpbGwgdGFrZSBjYXJlIG9mIHJlbW92aW5nIHRoZVxuICAgICAgICAvL2RhdGEgZnJvbSB0aGUgZWxlbWVudCB3aGljaCB3aWxsIG5vdCBtYWtlIHRoZSAybmQgYW5pbWF0aW9uXG4gICAgICAgIC8vaGFwcGVuIGluIHRoZSBmaXJzdCBwbGFjZVxuICAgICAgICB2YXIgY2FuY2VsID0gcHJlUmVmbG93Q2FuY2VsbGF0aW9uO1xuICAgICAgICBhZnRlclJlZmxvdyhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB1bmJsb2NrVHJhbnNpdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgdW5ibG9ja0tleWZyYW1lQW5pbWF0aW9ucyhlbGVtZW50KTtcbiAgICAgICAgICAvL29uY2UgdGhlIHJlZmxvdyBpcyBjb21wbGV0ZSB0aGVuIHdlIHBvaW50IGNhbmNlbCB0b1xuICAgICAgICAgIC8vdGhlIG5ldyBjYW5jZWxsYXRpb24gZnVuY3Rpb24gd2hpY2ggd2lsbCByZW1vdmUgYWxsIG9mIHRoZVxuICAgICAgICAgIC8vYW5pbWF0aW9uIHByb3BlcnRpZXMgZnJvbSB0aGUgYWN0aXZlIGFuaW1hdGlvblxuICAgICAgICAgIGNhbmNlbCA9IGFuaW1hdGVBZnRlcihlbGVtZW50LCBjbGFzc05hbWUsIGFuaW1hdGlvbkNvbXBsZXRlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbmNlbGxlZCkge1xuICAgICAgICAgIChjYW5jZWwgfHwgbm9vcCkoY2FuY2VsbGVkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYW5pbWF0ZUNsb3NlKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRGF0YShOR19BTklNQVRFX0NTU19EQVRBX0tFWSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFsbG93Q2FuY2VsIDogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uRXZlbnQsIGNsYXNzTmFtZSkge1xuICAgICAgICAgIC8vYWx3YXlzIGNhbmNlbCB0aGUgY3VycmVudCBhbmltYXRpb24gaWYgaXQgaXMgYVxuICAgICAgICAgIC8vc3RydWN0dXJhbCBhbmltYXRpb25cbiAgICAgICAgICB2YXIgb2xkQ2xhc3NlcyA9IChlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9DU1NfREFUQV9LRVkpIHx8IHt9KS5jbGFzc2VzO1xuICAgICAgICAgIGlmKCFvbGRDbGFzc2VzIHx8IFsnZW50ZXInLCdsZWF2ZScsJ21vdmUnXS5pbmRleE9mKGFuaW1hdGlvbkV2ZW50KSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IGVsZW1lbnQucGFyZW50KCk7XG4gICAgICAgICAgdmFyIGNsb25lID0gYW5ndWxhci5lbGVtZW50KGV4dHJhY3RFbGVtZW50Tm9kZShlbGVtZW50KS5jbG9uZU5vZGUoKSk7XG5cbiAgICAgICAgICAvL21ha2UgdGhlIGVsZW1lbnQgc3VwZXIgaGlkZGVuIGFuZCBvdmVycmlkZSBhbnkgQ1NTIHN0eWxlIHZhbHVlc1xuICAgICAgICAgIGNsb25lLmF0dHIoJ3N0eWxlJywncG9zaXRpb246YWJzb2x1dGU7IHRvcDotOTk5OXB4OyBsZWZ0Oi05OTk5cHgnKTtcbiAgICAgICAgICBjbG9uZS5yZW1vdmVBdHRyKCdpZCcpO1xuICAgICAgICAgIGNsb25lLmVtcHR5KCk7XG5cbiAgICAgICAgICBmb3JFYWNoKG9sZENsYXNzZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24oa2xhc3MpIHtcbiAgICAgICAgICAgIGNsb25lLnJlbW92ZUNsYXNzKGtsYXNzKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBzdWZmaXggPSBhbmltYXRpb25FdmVudCA9PSAnYWRkQ2xhc3MnID8gJy1hZGQnIDogJy1yZW1vdmUnO1xuICAgICAgICAgIGNsb25lLmFkZENsYXNzKHN1ZmZpeENsYXNzZXMoY2xhc3NOYW1lLCBzdWZmaXgpKTtcbiAgICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChjbG9uZSk7XG5cbiAgICAgICAgICB2YXIgdGltaW5ncyA9IGdldEVsZW1lbnRBbmltYXRpb25EZXRhaWxzKGNsb25lKTtcbiAgICAgICAgICBjbG9uZS5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aW1pbmdzLnRyYW5zaXRpb25EdXJhdGlvbiwgdGltaW5ncy5hbmltYXRpb25EdXJhdGlvbikgPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVudGVyIDogZnVuY3Rpb24oZWxlbWVudCwgYW5pbWF0aW9uQ29tcGxldGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGUoZWxlbWVudCwgJ25nLWVudGVyJywgYW5pbWF0aW9uQ29tcGxldGVkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsZWF2ZSA6IGZ1bmN0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbkNvbXBsZXRlZCkge1xuICAgICAgICAgIHJldHVybiBhbmltYXRlKGVsZW1lbnQsICduZy1sZWF2ZScsIGFuaW1hdGlvbkNvbXBsZXRlZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW92ZSA6IGZ1bmN0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbkNvbXBsZXRlZCkge1xuICAgICAgICAgIHJldHVybiBhbmltYXRlKGVsZW1lbnQsICduZy1tb3ZlJywgYW5pbWF0aW9uQ29tcGxldGVkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVBZGRDbGFzcyA6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgYW5pbWF0aW9uQ29tcGxldGVkKSB7XG4gICAgICAgICAgdmFyIGNhbmNlbGxhdGlvbk1ldGhvZCA9IGFuaW1hdGVCZWZvcmUoZWxlbWVudCwgc3VmZml4Q2xhc3NlcyhjbGFzc05hbWUsICctYWRkJykpO1xuICAgICAgICAgIGlmKGNhbmNlbGxhdGlvbk1ldGhvZCkge1xuICAgICAgICAgICAgYWZ0ZXJSZWZsb3coZWxlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHVuYmxvY2tUcmFuc2l0aW9ucyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgdW5ibG9ja0tleWZyYW1lQW5pbWF0aW9ucyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uQ29tcGxldGVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxsYXRpb25NZXRob2Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFuaW1hdGlvbkNvbXBsZXRlZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZENsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBhbmltYXRpb25Db21wbGV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gYW5pbWF0ZUFmdGVyKGVsZW1lbnQsIHN1ZmZpeENsYXNzZXMoY2xhc3NOYW1lLCAnLWFkZCcpLCBhbmltYXRpb25Db21wbGV0ZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJlZm9yZVJlbW92ZUNsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBhbmltYXRpb25Db21wbGV0ZWQpIHtcbiAgICAgICAgICB2YXIgY2FuY2VsbGF0aW9uTWV0aG9kID0gYW5pbWF0ZUJlZm9yZShlbGVtZW50LCBzdWZmaXhDbGFzc2VzKGNsYXNzTmFtZSwgJy1yZW1vdmUnKSk7XG4gICAgICAgICAgaWYoY2FuY2VsbGF0aW9uTWV0aG9kKSB7XG4gICAgICAgICAgICBhZnRlclJlZmxvdyhlbGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdW5ibG9ja1RyYW5zaXRpb25zKGVsZW1lbnQpO1xuICAgICAgICAgICAgICB1bmJsb2NrS2V5ZnJhbWVBbmltYXRpb25zKGVsZW1lbnQpO1xuICAgICAgICAgICAgICBhbmltYXRpb25Db21wbGV0ZWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbGxhdGlvbk1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5pbWF0aW9uQ29tcGxldGVkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2xhc3MgOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGFuaW1hdGlvbkNvbXBsZXRlZCkge1xuICAgICAgICAgIHJldHVybiBhbmltYXRlQWZ0ZXIoZWxlbWVudCwgc3VmZml4Q2xhc3NlcyhjbGFzc05hbWUsICctcmVtb3ZlJyksIGFuaW1hdGlvbkNvbXBsZXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHN1ZmZpeENsYXNzZXMoY2xhc3Nlcywgc3VmZml4KSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnJztcbiAgICAgICAgY2xhc3NlcyA9IGFuZ3VsYXIuaXNBcnJheShjbGFzc2VzKSA/IGNsYXNzZXMgOiBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvckVhY2goY2xhc3NlcywgZnVuY3Rpb24oa2xhc3MsIGkpIHtcbiAgICAgICAgICBpZihrbGFzcyAmJiBrbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgKz0gKGkgPiAwID8gJyAnIDogJycpICsga2xhc3MgKyBzdWZmaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxufSkuY2FsbChnbG9iYWwsIG1vZHVsZSwgdW5kZWZpbmVkKTtcbiIsInZhciBnbG9iYWw9dHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9OyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGRlZmluZSkge1xuXG47IHJlcXVpcmUoXCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci9hbmd1bGFyLmpzXCIpO1xuYW5ndWxhci5tb2R1bGUoXCJ1aS5ib290c3RyYXBcIiwgW1widWkuYm9vdHN0cmFwLnRwbHNcIiwgXCJ1aS5ib290c3RyYXAudHJhbnNpdGlvblwiLFwidWkuYm9vdHN0cmFwLmNvbGxhcHNlXCIsXCJ1aS5ib290c3RyYXAuYWNjb3JkaW9uXCIsXCJ1aS5ib290c3RyYXAuYWxlcnRcIixcInVpLmJvb3RzdHJhcC5iaW5kSHRtbFwiLFwidWkuYm9vdHN0cmFwLmJ1dHRvbnNcIixcInVpLmJvb3RzdHJhcC5jYXJvdXNlbFwiLFwidWkuYm9vdHN0cmFwLnBvc2l0aW9uXCIsXCJ1aS5ib290c3RyYXAuZGF0ZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLmRyb3Bkb3duVG9nZ2xlXCIsXCJ1aS5ib290c3RyYXAubW9kYWxcIixcInVpLmJvb3RzdHJhcC5wYWdpbmF0aW9uXCIsXCJ1aS5ib290c3RyYXAudG9vbHRpcFwiLFwidWkuYm9vdHN0cmFwLnBvcG92ZXJcIixcInVpLmJvb3RzdHJhcC5wcm9ncmVzc2JhclwiLFwidWkuYm9vdHN0cmFwLnJhdGluZ1wiLFwidWkuYm9vdHN0cmFwLnRhYnNcIixcInVpLmJvb3RzdHJhcC50aW1lcGlja2VyXCIsXCJ1aS5ib290c3RyYXAudHlwZWFoZWFkXCJdKTtcbmFuZ3VsYXIubW9kdWxlKFwidWkuYm9vdHN0cmFwLnRwbHNcIiwgW1widGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sXCIsXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIixcInRlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWxcIixcInRlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWxcIixcInRlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIixcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIixcInRlbXBsYXRlL21vZGFsL3dpbmRvdy5odG1sXCIsXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIixcInRlbXBsYXRlL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5odG1sXCIsXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbFwiLFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIixcInRlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFwidGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sXCIsXCJ0ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC10aXRsZXMuaHRtbFwiLFwidGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbFwiLFwidGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFwidGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1wb3B1cC5odG1sXCJdKTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAudHJhbnNpdGlvbicsIFtdKVxuXG4vKipcbiAqICR0cmFuc2l0aW9uIHNlcnZpY2UgcHJvdmlkZXMgYSBjb25zaXN0ZW50IGludGVyZmFjZSB0byB0cmlnZ2VyIENTUyAzIHRyYW5zaXRpb25zIGFuZCB0byBiZSBpbmZvcm1lZCB3aGVuIHRoZXkgY29tcGxldGUuXG4gKiBAcGFyYW0gIHtET01FbGVtZW50fSBlbGVtZW50ICBUaGUgRE9NRWxlbWVudCB0aGF0IHdpbGwgYmUgYW5pbWF0ZWQuXG4gKiBAcGFyYW0gIHtzdHJpbmd8b2JqZWN0fGZ1bmN0aW9ufSB0cmlnZ2VyICBUaGUgdGhpbmcgdGhhdCB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHN0YXJ0OlxuICogICAtIEFzIGEgc3RyaW5nLCBpdCByZXByZXNlbnRzIHRoZSBjc3MgY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQuXG4gKiAgIC0gQXMgYW4gb2JqZWN0LCBpdCByZXByZXNlbnRzIGEgaGFzaCBvZiBzdHlsZSBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gKiAgIC0gQXMgYSBmdW5jdGlvbiwgaXQgcmVwcmVzZW50cyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB0aGF0IHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gb2NjdXIuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAgQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlcy5cbiAqL1xuLmZhY3RvcnkoJyR0cmFuc2l0aW9uJywgWyckcScsICckdGltZW91dCcsICckcm9vdFNjb3BlJywgZnVuY3Rpb24oJHEsICR0aW1lb3V0LCAkcm9vdFNjb3BlKSB7XG5cbiAgdmFyICR0cmFuc2l0aW9uID0gZnVuY3Rpb24oZWxlbWVudCwgdHJpZ2dlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgdmFyIGVuZEV2ZW50TmFtZSA9ICR0cmFuc2l0aW9uW29wdGlvbnMuYW5pbWF0aW9uID8gXCJhbmltYXRpb25FbmRFdmVudE5hbWVcIiA6IFwidHJhbnNpdGlvbkVuZEV2ZW50TmFtZVwiXTtcblxuICAgIHZhciB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAkcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgZWxlbWVudC51bmJpbmQoZW5kRXZlbnROYW1lLCB0cmFuc2l0aW9uRW5kSGFuZGxlcik7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGVuZEV2ZW50TmFtZSkge1xuICAgICAgZWxlbWVudC5iaW5kKGVuZEV2ZW50TmFtZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8vIFdyYXAgaW4gYSB0aW1lb3V0IHRvIGFsbG93IHRoZSBicm93c2VyIHRpbWUgdG8gdXBkYXRlIHRoZSBET00gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGlzIHRvIG9jY3VyXG4gICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIGFuZ3VsYXIuaXNTdHJpbmcodHJpZ2dlcikgKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3ModHJpZ2dlcik7XG4gICAgICB9IGVsc2UgaWYgKCBhbmd1bGFyLmlzRnVuY3Rpb24odHJpZ2dlcikgKSB7XG4gICAgICAgIHRyaWdnZXIoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCBhbmd1bGFyLmlzT2JqZWN0KHRyaWdnZXIpICkge1xuICAgICAgICBlbGVtZW50LmNzcyh0cmlnZ2VyKTtcbiAgICAgIH1cbiAgICAgIC8vSWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRyYW5zaXRpb25zLCBpbnN0YW50bHkgcmVzb2x2ZVxuICAgICAgaWYgKCAhZW5kRXZlbnROYW1lICkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQWRkIG91ciBjdXN0b20gY2FuY2VsIGZ1bmN0aW9uIHRvIHRoZSBwcm9taXNlIHRoYXQgaXMgcmV0dXJuZWRcbiAgICAvLyBXZSBjYW4gY2FsbCB0aGlzIGlmIHdlIGFyZSBhYm91dCB0byBydW4gYSBuZXcgdHJhbnNpdGlvbiwgd2hpY2ggd2Uga25vdyB3aWxsIHByZXZlbnQgdGhpcyB0cmFuc2l0aW9uIGZyb20gZW5kaW5nLFxuICAgIC8vIGkuZS4gaXQgd2lsbCB0aGVyZWZvcmUgbmV2ZXIgcmFpc2UgYSB0cmFuc2l0aW9uRW5kIGV2ZW50IGZvciB0aGF0IHRyYW5zaXRpb25cbiAgICBkZWZlcnJlZC5wcm9taXNlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCBlbmRFdmVudE5hbWUgKSB7XG4gICAgICAgIGVsZW1lbnQudW5iaW5kKGVuZEV2ZW50TmFtZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVqZWN0KCdUcmFuc2l0aW9uIGNhbmNlbGxlZCcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfTtcblxuICAvLyBXb3JrIG91dCB0aGUgbmFtZSBvZiB0aGUgdHJhbnNpdGlvbkVuZCBldmVudFxuICB2YXIgdHJhbnNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHJhbnMnKTtcbiAgdmFyIHRyYW5zaXRpb25FbmRFdmVudE5hbWVzID0ge1xuICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICdPVHJhbnNpdGlvbic6ICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCdcbiAgfTtcbiAgdmFyIGFuaW1hdGlvbkVuZEV2ZW50TmFtZXMgPSB7XG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICdhbmltYXRpb25lbmQnLFxuICAgICdPVHJhbnNpdGlvbic6ICdvQW5pbWF0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbic6ICdhbmltYXRpb25lbmQnXG4gIH07XG4gIGZ1bmN0aW9uIGZpbmRFbmRFdmVudE5hbWUoZW5kRXZlbnROYW1lcykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gZW5kRXZlbnROYW1lcyl7XG4gICAgICBpZiAodHJhbnNFbGVtZW50LnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVuZEV2ZW50TmFtZXNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICR0cmFuc2l0aW9uLnRyYW5zaXRpb25FbmRFdmVudE5hbWUgPSBmaW5kRW5kRXZlbnROYW1lKHRyYW5zaXRpb25FbmRFdmVudE5hbWVzKTtcbiAgJHRyYW5zaXRpb24uYW5pbWF0aW9uRW5kRXZlbnROYW1lID0gZmluZEVuZEV2ZW50TmFtZShhbmltYXRpb25FbmRFdmVudE5hbWVzKTtcbiAgcmV0dXJuICR0cmFuc2l0aW9uO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNvbGxhcHNlJyxbJ3VpLmJvb3RzdHJhcC50cmFuc2l0aW9uJ10pXG5cbi8vIFRoZSBjb2xsYXBzaWJsZSBkaXJlY3RpdmUgaW5kaWNhdGVzIGEgYmxvY2sgb2YgaHRtbCB0aGF0IHdpbGwgZXhwYW5kIGFuZCBjb2xsYXBzZVxuLmRpcmVjdGl2ZSgnY29sbGFwc2UnLCBbJyR0cmFuc2l0aW9uJywgZnVuY3Rpb24oJHRyYW5zaXRpb24pIHtcbiAgLy8gQ1NTIHRyYW5zaXRpb25zIGRvbid0IHdvcmsgd2l0aCBoZWlnaHQ6IGF1dG8sIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgY2hhbmdlIHRoZSBoZWlnaHQgdG8gYVxuICAvLyBzcGVjaWZpYyB2YWx1ZSBhbmQgdGhlbiBvbmNlIHRoZSBhbmltYXRpb24gY29tcGxldGVzLCB3ZSBjYW4gcmVzZXQgdGhlIGhlaWdodCB0byBhdXRvLlxuICAvLyBVbmZvcnR1bmF0ZWx5IGlmIHlvdSBkbyB0aGlzIHdoaWxlIHRoZSBDU1MgdHJhbnNpdGlvbnMgYXJlIHNwZWNpZmllZCAoaS5lLiBpbiB0aGUgQ1NTIGNsYXNzXG4gIC8vIFwiY29sbGFwc2VcIikgdGhlbiB5b3UgdHJpZ2dlciBhIGNoYW5nZSB0byBoZWlnaHQgMCBpbiBiZXR3ZWVuLlxuICAvLyBUaGUgZml4IGlzIHRvIHJlbW92ZSB0aGUgXCJjb2xsYXBzZVwiIENTUyBjbGFzcyB3aGlsZSBjaGFuZ2luZyB0aGUgaGVpZ2h0IGJhY2sgdG8gYXV0byAtIHBoZXchXG4gIHZhciBmaXhVcEhlaWdodCA9IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBoZWlnaHQpIHtcbiAgICAvLyBXZSByZW1vdmUgdGhlIGNvbGxhcHNlIENTUyBjbGFzcyB0byBwcmV2ZW50IGEgdHJhbnNpdGlvbiB3aGVuIHdlIGNoYW5nZSB0byBoZWlnaHQ6IGF1dG9cbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzZScpO1xuICAgIGVsZW1lbnQuY3NzKHsgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgLy8gSXQgYXBwZWFycyB0aGF0ICByZWFkaW5nIG9mZnNldFdpZHRoIG1ha2VzIHRoZSBicm93c2VyIHJlYWxpc2UgdGhhdCB3ZSBoYXZlIGNoYW5nZWQgdGhlXG4gICAgLy8gaGVpZ2h0IGFscmVhZHkgOi0vXG4gICAgdmFyIHggPSBlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xuICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2NvbGxhcHNlJyk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcblxuICAgICAgdmFyIGlzQ29sbGFwc2VkO1xuICAgICAgdmFyIGluaXRpYWxBbmltU2tpcCA9IHRydWU7XG5cbiAgICAgIHNjb3BlLiR3YXRjaChhdHRycy5jb2xsYXBzZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29sbGFwc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcblxuICAgICAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgdmFyIGRvVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgICAgICBpZiAoIGN1cnJlbnRUcmFuc2l0aW9uICkge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0gJHRyYW5zaXRpb24oZWxlbWVudCxjaGFuZ2UpO1xuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKCkgeyBjdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDsgfSxcbiAgICAgICAgICBmdW5jdGlvbigpIHsgY3VycmVudFRyYW5zaXRpb24gPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgfTtcblxuICAgICAgdmFyIGV4cGFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaW5pdGlhbEFuaW1Ta2lwKSB7XG4gICAgICAgICAgaW5pdGlhbEFuaW1Ta2lwID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCAhaXNDb2xsYXBzZWQgKSB7XG4gICAgICAgICAgICBmaXhVcEhlaWdodChzY29wZSwgZWxlbWVudCwgJ2F1dG8nKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvVHJhbnNpdGlvbih7IGhlaWdodCA6IGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4JyB9KVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjaGVjayBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHVwZGF0ZSB0aGUgaGVpZ2h0IGlmIHRoZSB1c2VyIGhhcyBjbG9zZWRcbiAgICAgICAgICAgIC8vIHRoZSBncm91cCB3aGlsZSB0aGUgYW5pbWF0aW9uIHdhcyBzdGlsbCBydW5uaW5nXG4gICAgICAgICAgICBpZiAoICFpc0NvbGxhcHNlZCApIHtcbiAgICAgICAgICAgICAgZml4VXBIZWlnaHQoc2NvcGUsIGVsZW1lbnQsICdhdXRvJyk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2luJyk7XG4gICAgICAgIGlmIChpbml0aWFsQW5pbVNraXApIHtcbiAgICAgICAgICBpbml0aWFsQW5pbVNraXAgPSBmYWxzZTtcbiAgICAgICAgICBmaXhVcEhlaWdodChzY29wZSwgZWxlbWVudCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZml4VXBIZWlnaHQoc2NvcGUsIGVsZW1lbnQsIGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgZG9UcmFuc2l0aW9uKHsnaGVpZ2h0JzonMCd9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWNjb3JkaW9uJywgWyd1aS5ib290c3RyYXAuY29sbGFwc2UnXSlcblxuLmNvbnN0YW50KCdhY2NvcmRpb25Db25maWcnLCB7XG4gIGNsb3NlT3RoZXJzOiB0cnVlXG59KVxuXG4uY29udHJvbGxlcignQWNjb3JkaW9uQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICdhY2NvcmRpb25Db25maWcnLCBmdW5jdGlvbiAoJHNjb3BlLCAkYXR0cnMsIGFjY29yZGlvbkNvbmZpZykge1xuXG4gIC8vIFRoaXMgYXJyYXkga2VlcHMgdHJhY2sgb2YgdGhlIGFjY29yZGlvbiBncm91cHNcbiAgdGhpcy5ncm91cHMgPSBbXTtcblxuICAvLyBLZWVwIHJlZmVyZW5jZSB0byB1c2VyJ3Mgc2NvcGUgdG8gcHJvcGVybHkgYXNzaWduIGBpcy1vcGVuYFxuICB0aGlzLnNjb3BlID0gJHNjb3BlO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgZ3JvdXBzIGluIHRoaXMgYWNjb3JkaW9uIGFyZSBjbG9zZWQsIHVubGVzcyBjbG9zZS1vdGhlcnMgZXhwbGljaXRseSBzYXlzIG5vdCB0b1xuICB0aGlzLmNsb3NlT3RoZXJzID0gZnVuY3Rpb24ob3Blbkdyb3VwKSB7XG4gICAgdmFyIGNsb3NlT3RoZXJzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmNsb3NlT3RoZXJzKSA/ICRzY29wZS4kZXZhbCgkYXR0cnMuY2xvc2VPdGhlcnMpIDogYWNjb3JkaW9uQ29uZmlnLmNsb3NlT3RoZXJzO1xuICAgIGlmICggY2xvc2VPdGhlcnMgKSB7XG4gICAgICBhbmd1bGFyLmZvckVhY2godGhpcy5ncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICBpZiAoIGdyb3VwICE9PSBvcGVuR3JvdXAgKSB7XG4gICAgICAgICAgZ3JvdXAuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgdG8gYWRkIGl0c2VsZiB0byB0aGUgYWNjb3JkaW9uXG4gIHRoaXMuYWRkR3JvdXAgPSBmdW5jdGlvbihncm91cFNjb3BlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuZ3JvdXBzLnB1c2goZ3JvdXBTY29wZSk7XG5cbiAgICBncm91cFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHRoYXQucmVtb3ZlR3JvdXAoZ3JvdXBTY29wZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSB3aGVuIHRvIHJlbW92ZSBpdHNlbGZcbiAgdGhpcy5yZW1vdmVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCk7XG4gICAgaWYgKCBpbmRleCAhPT0gLTEgKSB7XG4gICAgICB0aGlzLmdyb3Vwcy5zcGxpY2UodGhpcy5ncm91cHMuaW5kZXhPZihncm91cCksIDEpO1xuICAgIH1cbiAgfTtcblxufV0pXG5cbi8vIFRoZSBhY2NvcmRpb24gZGlyZWN0aXZlIHNpbXBseSBzZXRzIHVwIHRoZSBkaXJlY3RpdmUgY29udHJvbGxlclxuLy8gYW5kIGFkZHMgYW4gYWNjb3JkaW9uIENTUyBjbGFzcyB0byBpdHNlbGYgZWxlbWVudC5cbi5kaXJlY3RpdmUoJ2FjY29yZGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDonRUEnLFxuICAgIGNvbnRyb2xsZXI6J0FjY29yZGlvbkNvbnRyb2xsZXInLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgcmVwbGFjZTogZmFsc2UsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWwnXG4gIH07XG59KVxuXG4vLyBUaGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSBpbmRpY2F0ZXMgYSBibG9jayBvZiBodG1sIHRoYXQgd2lsbCBleHBhbmQgYW5kIGNvbGxhcHNlIGluIGFuIGFjY29yZGlvblxuLmRpcmVjdGl2ZSgnYWNjb3JkaW9uR3JvdXAnLCBbJyRwYXJzZScsICckdHJhbnNpdGlvbicsICckdGltZW91dCcsIGZ1bmN0aW9uKCRwYXJzZSwgJHRyYW5zaXRpb24sICR0aW1lb3V0KSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTonXmFjY29yZGlvbicsICAgICAgICAgLy8gV2UgbmVlZCB0aGlzIGRpcmVjdGl2ZSB0byBiZSBpbnNpZGUgYW4gYWNjb3JkaW9uXG4gICAgcmVzdHJpY3Q6J0VBJyxcbiAgICB0cmFuc2NsdWRlOnRydWUsICAgICAgICAgICAgICAvLyBJdCB0cmFuc2NsdWRlcyB0aGUgY29udGVudHMgb2YgdGhlIGRpcmVjdGl2ZSBpbnRvIHRoZSB0ZW1wbGF0ZVxuICAgIHJlcGxhY2U6IHRydWUsICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZSB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIHRlbXBsYXRlXG4gICAgdGVtcGxhdGVVcmw6J3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbCcsXG4gICAgc2NvcGU6eyBoZWFkaW5nOidAJyB9LCAgICAgICAgLy8gQ3JlYXRlIGFuIGlzb2xhdGVkIHNjb3BlIGFuZCBpbnRlcnBvbGF0ZSB0aGUgaGVhZGluZyBhdHRyaWJ1dGUgb250byB0aGlzIHNjb3BlXG4gICAgY29udHJvbGxlcjogWyckc2NvcGUnLCBmdW5jdGlvbigkc2NvcGUpIHtcbiAgICAgIHRoaXMuc2V0SGVhZGluZyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oZWFkaW5nID0gZWxlbWVudDtcbiAgICAgIH07XG4gICAgfV0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBhY2NvcmRpb25DdHJsKSB7XG4gICAgICB2YXIgZ2V0SXNPcGVuLCBzZXRJc09wZW47XG5cbiAgICAgIGFjY29yZGlvbkN0cmwuYWRkR3JvdXAoc2NvcGUpO1xuXG4gICAgICBzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgIFxuICAgICAgaWYgKCBhdHRycy5pc09wZW4gKSB7XG4gICAgICAgIGdldElzT3BlbiA9ICRwYXJzZShhdHRycy5pc09wZW4pO1xuICAgICAgICBzZXRJc09wZW4gPSBnZXRJc09wZW4uYXNzaWduO1xuXG4gICAgICAgIGFjY29yZGlvbkN0cmwuc2NvcGUuJHdhdGNoKGdldElzT3BlbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5pc09wZW4gPSAhIXZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIHZhbHVlICkge1xuICAgICAgICAgIGFjY29yZGlvbkN0cmwuY2xvc2VPdGhlcnMoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICggc2V0SXNPcGVuICkge1xuICAgICAgICAgIHNldElzT3BlbihhY2NvcmRpb25DdHJsLnNjb3BlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4vLyBVc2UgYWNjb3JkaW9uLWhlYWRpbmcgYmVsb3cgYW4gYWNjb3JkaW9uLWdyb3VwIHRvIHByb3ZpZGUgYSBoZWFkaW5nIGNvbnRhaW5pbmcgSFRNTFxuLy8gPGFjY29yZGlvbi1ncm91cD5cbi8vICAgPGFjY29yZGlvbi1oZWFkaW5nPkhlYWRpbmcgY29udGFpbmluZyBIVE1MIC0gPGltZyBzcmM9XCIuLi5cIj48L2FjY29yZGlvbi1oZWFkaW5nPlxuLy8gPC9hY2NvcmRpb24tZ3JvdXA+XG4uZGlyZWN0aXZlKCdhY2NvcmRpb25IZWFkaW5nJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSwgICAvLyBHcmFiIHRoZSBjb250ZW50cyB0byBiZSB1c2VkIGFzIHRoZSBoZWFkaW5nXG4gICAgdGVtcGxhdGU6ICcnLCAgICAgICAvLyBJbiBlZmZlY3QgcmVtb3ZlIHRoaXMgZWxlbWVudCFcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uR3JvdXAnLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIsIHRyYW5zY2x1ZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBsaW5rKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBhY2NvcmRpb25Hcm91cEN0cmwpIHtcbiAgICAgICAgLy8gUGFzcyB0aGUgaGVhZGluZyB0byB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXJcbiAgICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgdHJhbnNjbHVkZWQgaW50byB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgIC8vIFtUaGUgc2Vjb25kIHBhcmFtZXRlciB0byB0cmFuc2NsdWRlIGNhdXNlcyB0aGUgZWxlbWVudHMgdG8gYmUgY2xvbmVkIHNvIHRoYXQgdGhleSB3b3JrIGluIG5nLXJlcGVhdF1cbiAgICAgICAgYWNjb3JkaW9uR3JvdXBDdHJsLnNldEhlYWRpbmcodHJhbnNjbHVkZShzY29wZSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59KVxuXG4vLyBVc2UgaW4gdGhlIGFjY29yZGlvbi1ncm91cCB0ZW1wbGF0ZSB0byBpbmRpY2F0ZSB3aGVyZSB5b3Ugd2FudCB0aGUgaGVhZGluZyB0byBiZSB0cmFuc2NsdWRlZFxuLy8gWW91IG11c3QgcHJvdmlkZSB0aGUgcHJvcGVydHkgb24gdGhlIGFjY29yZGlvbi1ncm91cCBjb250cm9sbGVyIHRoYXQgd2lsbCBob2xkIHRoZSB0cmFuc2NsdWRlZCBlbGVtZW50XG4vLyA8ZGl2IGNsYXNzPVwiYWNjb3JkaW9uLWdyb3VwXCI+XG4vLyAgIDxkaXYgY2xhc3M9XCJhY2NvcmRpb24taGVhZGluZ1wiID48YSAuLi4gYWNjb3JkaW9uLXRyYW5zY2x1ZGU9XCJoZWFkaW5nXCI+Li4uPC9hPjwvZGl2PlxuLy8gICAuLi5cbi8vIDwvZGl2PlxuLmRpcmVjdGl2ZSgnYWNjb3JkaW9uVHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdeYWNjb3JkaW9uR3JvdXAnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjb250cm9sbGVyKSB7XG4gICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7IHJldHVybiBjb250cm9sbGVyW2F0dHIuYWNjb3JkaW9uVHJhbnNjbHVkZV07IH0sIGZ1bmN0aW9uKGhlYWRpbmcpIHtcbiAgICAgICAgaWYgKCBoZWFkaW5nICkge1xuICAgICAgICAgIGVsZW1lbnQuaHRtbCgnJyk7XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcC5hbGVydFwiLCBbXSkuZGlyZWN0aXZlKCdhbGVydCcsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDonRUEnLFxuICAgIHRlbXBsYXRlVXJsOid0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sJyxcbiAgICB0cmFuc2NsdWRlOnRydWUsXG4gICAgcmVwbGFjZTp0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICB0eXBlOiAnPScsXG4gICAgICBjbG9zZTogJyYnXG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgaUVsZW1lbnQsIGlBdHRycykge1xuICAgICAgc2NvcGUuY2xvc2VhYmxlID0gXCJjbG9zZVwiIGluIGlBdHRycztcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5iaW5kSHRtbCcsIFtdKVxuXG4gIC5kaXJlY3RpdmUoJ2JpbmRIdG1sVW5zYWZlJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ25nLWJpbmRpbmcnKS5kYXRhKCckYmluZGluZycsIGF0dHIuYmluZEh0bWxVbnNhZmUpO1xuICAgICAgc2NvcGUuJHdhdGNoKGF0dHIuYmluZEh0bWxVbnNhZmUsIGZ1bmN0aW9uIGJpbmRIdG1sVW5zYWZlV2F0Y2hBY3Rpb24odmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5odG1sKHZhbHVlIHx8ICcnKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5idXR0b25zJywgW10pXG5cbi5jb25zdGFudCgnYnV0dG9uQ29uZmlnJywge1xuICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXG4gIHRvZ2dsZUV2ZW50OiAnY2xpY2snXG59KVxuXG4uZGlyZWN0aXZlKCdidG5SYWRpbycsIFsnYnV0dG9uQ29uZmlnJywgZnVuY3Rpb24gKGJ1dHRvbkNvbmZpZykge1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBidXR0b25Db25maWcuYWN0aXZlQ2xhc3MgfHwgJ2FjdGl2ZSc7XG4gIHZhciB0b2dnbGVFdmVudCA9IGJ1dHRvbkNvbmZpZy50b2dnbGVFdmVudCB8fCAnY2xpY2snO1xuXG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDdHJsKSB7XG5cbiAgICAgIC8vbW9kZWwgLT4gVUlcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBzY29wZS4kZXZhbChhdHRycy5idG5SYWRpbykpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vdWktPm1vZGVsXG4gICAgICBlbGVtZW50LmJpbmQodG9nZ2xlRXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKGFjdGl2ZUNsYXNzKSkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKHNjb3BlLiRldmFsKGF0dHJzLmJ0blJhZGlvKSk7XG4gICAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCdidG5DaGVja2JveCcsIFsnYnV0dG9uQ29uZmlnJywgZnVuY3Rpb24gKGJ1dHRvbkNvbmZpZykge1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBidXR0b25Db25maWcuYWN0aXZlQ2xhc3MgfHwgJ2FjdGl2ZSc7XG4gIHZhciB0b2dnbGVFdmVudCA9IGJ1dHRvbkNvbmZpZy50b2dnbGVFdmVudCB8fCAnY2xpY2snO1xuXG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ25nTW9kZWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWxDdHJsKSB7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFRydWVWYWx1ZSgpIHtcbiAgICAgICAgdmFyIHRydWVWYWx1ZSA9IHNjb3BlLiRldmFsKGF0dHJzLmJ0bkNoZWNrYm94VHJ1ZSk7XG4gICAgICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZCh0cnVlVmFsdWUpID8gdHJ1ZVZhbHVlIDogdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0RmFsc2VWYWx1ZSgpIHtcbiAgICAgICAgdmFyIGZhbHNlVmFsdWUgPSBzY29wZS4kZXZhbChhdHRycy5idG5DaGVja2JveEZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKGZhbHNlVmFsdWUpID8gZmFsc2VWYWx1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlbGVtZW50LnRvZ2dsZUNsYXNzKGFjdGl2ZUNsYXNzLCBhbmd1bGFyLmVxdWFscyhuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSwgZ2V0VHJ1ZVZhbHVlKCkpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vdWktPm1vZGVsXG4gICAgICBlbGVtZW50LmJpbmQodG9nZ2xlRXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGVsZW1lbnQuaGFzQ2xhc3MoYWN0aXZlQ2xhc3MpID8gZ2V0RmFsc2VWYWx1ZSgpIDogZ2V0VHJ1ZVZhbHVlKCkpO1xuICAgICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSk7XG5cbi8qKlxuKiBAbmdkb2Mgb3ZlcnZpZXdcbiogQG5hbWUgdWkuYm9vdHN0cmFwLmNhcm91c2VsXG4qXG4qIEBkZXNjcmlwdGlvblxuKiBBbmd1bGFySlMgdmVyc2lvbiBvZiBhbiBpbWFnZSBjYXJvdXNlbC5cbipcbiovXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmNhcm91c2VsJywgWyd1aS5ib290c3RyYXAudHJhbnNpdGlvbiddKVxuLmNvbnRyb2xsZXIoJ0Nhcm91c2VsQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyR0aW1lb3V0JywgJyR0cmFuc2l0aW9uJywgJyRxJywgZnVuY3Rpb24gKCRzY29wZSwgJHRpbWVvdXQsICR0cmFuc2l0aW9uLCAkcSkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgc2xpZGVzID0gc2VsZi5zbGlkZXMgPSBbXSxcbiAgICBjdXJyZW50SW5kZXggPSAtMSxcbiAgICBjdXJyZW50VGltZW91dCwgaXNQbGF5aW5nO1xuICBzZWxmLmN1cnJlbnRTbGlkZSA9IG51bGw7XG5cbiAgLyogZGlyZWN0aW9uOiBcInByZXZcIiBvciBcIm5leHRcIiAqL1xuICBzZWxmLnNlbGVjdCA9IGZ1bmN0aW9uKG5leHRTbGlkZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IHNsaWRlcy5pbmRleE9mKG5leHRTbGlkZSk7XG4gICAgLy9EZWNpZGUgZGlyZWN0aW9uIGlmIGl0J3Mgbm90IGdpdmVuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkaXJlY3Rpb24gPSBuZXh0SW5kZXggPiBjdXJyZW50SW5kZXggPyBcIm5leHRcIiA6IFwicHJldlwiO1xuICAgIH1cbiAgICBpZiAobmV4dFNsaWRlICYmIG5leHRTbGlkZSAhPT0gc2VsZi5jdXJyZW50U2xpZGUpIHtcbiAgICAgIGlmICgkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24uY2FuY2VsKCk7XG4gICAgICAgIC8vVGltZW91dCBzbyBuZy1jbGFzcyBpbiB0ZW1wbGF0ZSBoYXMgdGltZSB0byBmaXggY2xhc3NlcyBmb3IgZmluaXNoZWQgc2xpZGVcbiAgICAgICAgJHRpbWVvdXQoZ29OZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvTmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnb05leHQoKSB7XG4gICAgICAvL0lmIHdlIGhhdmUgYSBzbGlkZSB0byB0cmFuc2l0aW9uIGZyb20gYW5kIHdlIGhhdmUgYSB0cmFuc2l0aW9uIHR5cGUgYW5kIHdlJ3JlIGFsbG93ZWQsIGdvXG4gICAgICBpZiAoc2VsZi5jdXJyZW50U2xpZGUgJiYgYW5ndWxhci5pc1N0cmluZyhkaXJlY3Rpb24pICYmICEkc2NvcGUubm9UcmFuc2l0aW9uICYmIG5leHRTbGlkZS4kZWxlbWVudCkge1xuICAgICAgICAvL1dlIHNob3VsZG4ndCBkbyBjbGFzcyBtYW5pcCBpbiBoZXJlLCBidXQgaXQncyB0aGUgc2FtZSB3ZWlyZCB0aGluZyBib290c3RyYXAgZG9lcy4gbmVlZCB0byBmaXggc29tZXRpbWVcbiAgICAgICAgbmV4dFNsaWRlLiRlbGVtZW50LmFkZENsYXNzKGRpcmVjdGlvbik7XG4gICAgICAgIHZhciByZWZsb3cgPSBuZXh0U2xpZGUuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7IC8vZm9yY2UgcmVmbG93XG5cbiAgICAgICAgLy9TZXQgYWxsIG90aGVyIHNsaWRlcyB0byBzdG9wIGRvaW5nIHRoZWlyIHN0dWZmIGZvciB0aGUgbmV3IHRyYW5zaXRpb25cbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKHNsaWRlcywgZnVuY3Rpb24oc2xpZGUpIHtcbiAgICAgICAgICBhbmd1bGFyLmV4dGVuZChzbGlkZSwge2RpcmVjdGlvbjogJycsIGVudGVyaW5nOiBmYWxzZSwgbGVhdmluZzogZmFsc2UsIGFjdGl2ZTogZmFsc2V9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFuZ3VsYXIuZXh0ZW5kKG5leHRTbGlkZSwge2RpcmVjdGlvbjogZGlyZWN0aW9uLCBhY3RpdmU6IHRydWUsIGVudGVyaW5nOiB0cnVlfSk7XG4gICAgICAgIGFuZ3VsYXIuZXh0ZW5kKHNlbGYuY3VycmVudFNsaWRlfHx7fSwge2RpcmVjdGlvbjogZGlyZWN0aW9uLCBsZWF2aW5nOiB0cnVlfSk7XG5cbiAgICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9ICR0cmFuc2l0aW9uKG5leHRTbGlkZS4kZWxlbWVudCwge30pO1xuICAgICAgICAvL1dlIGhhdmUgdG8gY3JlYXRlIG5ldyBwb2ludGVycyBpbnNpZGUgYSBjbG9zdXJlIHNpbmNlIG5leHQgJiBjdXJyZW50IHdpbGwgY2hhbmdlXG4gICAgICAgIChmdW5jdGlvbihuZXh0LGN1cnJlbnQpIHtcbiAgICAgICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbigpeyB0cmFuc2l0aW9uRG9uZShuZXh0LCBjdXJyZW50KTsgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCl7IHRyYW5zaXRpb25Eb25lKG5leHQsIGN1cnJlbnQpOyB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfShuZXh0U2xpZGUsIHNlbGYuY3VycmVudFNsaWRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uRG9uZShuZXh0U2xpZGUsIHNlbGYuY3VycmVudFNsaWRlKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY3VycmVudFNsaWRlID0gbmV4dFNsaWRlO1xuICAgICAgY3VycmVudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgLy9ldmVyeSB0aW1lIHlvdSBjaGFuZ2Ugc2xpZGVzLCByZXNldCB0aGUgdGltZXJcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uRG9uZShuZXh0LCBjdXJyZW50KSB7XG4gICAgICBhbmd1bGFyLmV4dGVuZChuZXh0LCB7ZGlyZWN0aW9uOiAnJywgYWN0aXZlOiB0cnVlLCBsZWF2aW5nOiBmYWxzZSwgZW50ZXJpbmc6IGZhbHNlfSk7XG4gICAgICBhbmd1bGFyLmV4dGVuZChjdXJyZW50fHx7fSwge2RpcmVjdGlvbjogJycsIGFjdGl2ZTogZmFsc2UsIGxlYXZpbmc6IGZhbHNlLCBlbnRlcmluZzogZmFsc2V9KTtcbiAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKiBBbGxvdyBvdXRzaWRlIHBlb3BsZSB0byBjYWxsIGluZGV4T2Ygb24gc2xpZGVzIGFycmF5ICovXG4gIHNlbGYuaW5kZXhPZlNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICByZXR1cm4gc2xpZGVzLmluZGV4T2Yoc2xpZGUpO1xuICB9O1xuXG4gICRzY29wZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgc2xpZGVzLmxlbmd0aDtcblxuICAgIC8vUHJldmVudCB0aGlzIHVzZXItdHJpZ2dlcmVkIHRyYW5zaXRpb24gZnJvbSBvY2N1cnJpbmcgaWYgdGhlcmUgaXMgYWxyZWFkeSBvbmUgaW4gcHJvZ3Jlc3NcbiAgICBpZiAoISRzY29wZS4kY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBzZWxmLnNlbGVjdChzbGlkZXNbbmV3SW5kZXhdLCAnbmV4dCcpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXdJbmRleCA9IGN1cnJlbnRJbmRleCAtIDEgPCAwID8gc2xpZGVzLmxlbmd0aCAtIDEgOiBjdXJyZW50SW5kZXggLSAxO1xuXG4gICAgLy9QcmV2ZW50IHRoaXMgdXNlci10cmlnZ2VyZWQgdHJhbnNpdGlvbiBmcm9tIG9jY3VycmluZyBpZiB0aGVyZSBpcyBhbHJlYWR5IG9uZSBpbiBwcm9ncmVzc1xuICAgIGlmICghJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0KHNsaWRlc1tuZXdJbmRleF0sICdwcmV2Jyk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIHNlbGYuc2VsZWN0KHNsaWRlKTtcbiAgfTtcblxuICAkc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgICByZXR1cm4gc2VsZi5jdXJyZW50U2xpZGUgPT09IHNsaWRlO1xuICB9O1xuXG4gICRzY29wZS5zbGlkZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2xpZGVzO1xuICB9O1xuXG4gICRzY29wZS4kd2F0Y2goJ2ludGVydmFsJywgcmVzdGFydFRpbWVyKTtcbiAgZnVuY3Rpb24gcmVzdGFydFRpbWVyKCkge1xuICAgIGlmIChjdXJyZW50VGltZW91dCkge1xuICAgICAgJHRpbWVvdXQuY2FuY2VsKGN1cnJlbnRUaW1lb3V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICBpZiAoaXNQbGF5aW5nKSB7XG4gICAgICAgICRzY29wZS5uZXh0KCk7XG4gICAgICAgIHJlc3RhcnRUaW1lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcnZhbCA9ICskc2NvcGUuaW50ZXJ2YWw7XG4gICAgaWYgKCFpc05hTihpbnRlcnZhbCkgJiYgaW50ZXJ2YWw+PTApIHtcbiAgICAgIGN1cnJlbnRUaW1lb3V0ID0gJHRpbWVvdXQoZ28sIGludGVydmFsKTtcbiAgICB9XG4gIH1cbiAgJHNjb3BlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWlzUGxheWluZykge1xuICAgICAgaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHJlc3RhcnRUaW1lcigpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9QYXVzZSkge1xuICAgICAgaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICBpZiAoY3VycmVudFRpbWVvdXQpIHtcbiAgICAgICAgJHRpbWVvdXQuY2FuY2VsKGN1cnJlbnRUaW1lb3V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgc2VsZi5hZGRTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlLCBlbGVtZW50KSB7XG4gICAgc2xpZGUuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAvL2lmIHRoaXMgaXMgdGhlIGZpcnN0IHNsaWRlIG9yIHRoZSBzbGlkZSBpcyBzZXQgdG8gYWN0aXZlLCBzZWxlY3QgaXRcbiAgICBpZihzbGlkZXMubGVuZ3RoID09PSAxIHx8IHNsaWRlLmFjdGl2ZSkge1xuICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW3NsaWRlcy5sZW5ndGgtMV0pO1xuICAgICAgaWYgKHNsaWRlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAkc2NvcGUucGxheSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZS5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgc2VsZi5yZW1vdmVTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlKSB7XG4gICAgLy9nZXQgdGhlIGluZGV4IG9mIHRoZSBzbGlkZSBpbnNpZGUgdGhlIGNhcm91c2VsXG4gICAgdmFyIGluZGV4ID0gc2xpZGVzLmluZGV4T2Yoc2xpZGUpO1xuICAgIHNsaWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGlmIChzbGlkZXMubGVuZ3RoID4gMCAmJiBzbGlkZS5hY3RpdmUpIHtcbiAgICAgIGlmIChpbmRleCA+PSBzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tpbmRleC0xXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbmRleCA+IGluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXgtLTtcbiAgICB9XG4gIH07XG59XSlcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOmNhcm91c2VsXG4gKiBAcmVzdHJpY3QgRUFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENhcm91c2VsIGlzIHRoZSBvdXRlciBjb250YWluZXIgZm9yIGEgc2V0IG9mIGltYWdlICdzbGlkZXMnIHRvIHNob3djYXNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gaW50ZXJ2YWwgVGhlIHRpbWUsIGluIG1pbGxpc2Vjb25kcywgdGhhdCBpdCB3aWxsIHRha2UgdGhlIGNhcm91c2VsIHRvIGdvIHRvIHRoZSBuZXh0IHNsaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gbm9UcmFuc2l0aW9uIFdoZXRoZXIgdG8gZGlzYWJsZSB0cmFuc2l0aW9ucyBvbiB0aGUgY2Fyb3VzZWwuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBub1BhdXNlIFdoZXRoZXIgdG8gZGlzYWJsZSBwYXVzaW5nIG9uIHRoZSBjYXJvdXNlbCAoYnkgZGVmYXVsdCwgdGhlIGNhcm91c2VsIGludGVydmFsIHBhdXNlcyBvbiBob3ZlcikuXG4gKlxuICogQGV4YW1wbGVcbjxleGFtcGxlIG1vZHVsZT1cInVpLmJvb3RzdHJhcFwiPlxuICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgIDxjYXJvdXNlbD5cbiAgICAgIDxzbGlkZT5cbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzE1MC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxuICAgICAgICAgIDxwPkJlYXV0aWZ1bCE8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9zbGlkZT5cbiAgICAgIDxzbGlkZT5cbiAgICAgICAgPGltZyBzcmM9XCJodHRwOi8vcGxhY2VraXR0ZW4uY29tLzEwMC8xNTBcIiBzdHlsZT1cIm1hcmdpbjphdXRvO1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2Fyb3VzZWwtY2FwdGlvblwiPlxuICAgICAgICAgIDxwPkQnYXd3ITwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3NsaWRlPlxuICAgIDwvY2Fyb3VzZWw+XG4gIDwvZmlsZT5cbiAgPGZpbGUgbmFtZT1cImRlbW8uY3NzXCI+XG4gICAgLmNhcm91c2VsLWluZGljYXRvcnMge1xuICAgICAgdG9wOiBhdXRvO1xuICAgICAgYm90dG9tOiAxNXB4O1xuICAgIH1cbiAgPC9maWxlPlxuPC9leGFtcGxlPlxuICovXG4uZGlyZWN0aXZlKCdjYXJvdXNlbCcsIFtmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ0Nhcm91c2VsQ29udHJvbGxlcicsXG4gICAgcmVxdWlyZTogJ2Nhcm91c2VsJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2Nhcm91c2VsL2Nhcm91c2VsLmh0bWwnLFxuICAgIHNjb3BlOiB7XG4gICAgICBpbnRlcnZhbDogJz0nLFxuICAgICAgbm9UcmFuc2l0aW9uOiAnPScsXG4gICAgICBub1BhdXNlOiAnPSdcbiAgICB9XG4gIH07XG59XSlcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAuY2Fyb3VzZWwuZGlyZWN0aXZlOnNsaWRlXG4gKiBAcmVzdHJpY3QgRUFcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBzbGlkZSBpbnNpZGUgYSB7QGxpbmsgdWkuYm9vdHN0cmFwLmNhcm91c2VsLmRpcmVjdGl2ZTpjYXJvdXNlbCBjYXJvdXNlbH0uICBNdXN0IGJlIHBsYWNlZCBhcyBhIGNoaWxkIG9mIGEgY2Fyb3VzZWwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBhY3RpdmUgTW9kZWwgYmluZGluZywgd2hldGhlciBvciBub3QgdGhpcyBzbGlkZSBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbjxkaXYgbmctY29udHJvbGxlcj1cIkNhcm91c2VsRGVtb0N0cmxcIj5cbiAgPGNhcm91c2VsPlxuICAgIDxzbGlkZSBuZy1yZXBlYXQ9XCJzbGlkZSBpbiBzbGlkZXNcIiBhY3RpdmU9XCJzbGlkZS5hY3RpdmVcIj5cbiAgICAgIDxpbWcgbmctc3JjPVwie3tzbGlkZS5pbWFnZX19XCIgc3R5bGU9XCJtYXJnaW46YXV0bztcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1jYXB0aW9uXCI+XG4gICAgICAgIDxoND5TbGlkZSB7eyRpbmRleH19PC9oND5cbiAgICAgICAgPHA+e3tzbGlkZS50ZXh0fX08L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L3NsaWRlPlxuICA8L2Nhcm91c2VsPlxuICA8ZGl2IGNsYXNzPVwicm93LWZsdWlkXCI+XG4gICAgPGRpdiBjbGFzcz1cInNwYW42XCI+XG4gICAgICA8dWw+XG4gICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJzbGlkZSBpbiBzbGlkZXNcIj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1taW5pXCIgbmctY2xhc3M9XCJ7J2J0bi1pbmZvJzogIXNsaWRlLmFjdGl2ZSwgJ2J0bi1zdWNjZXNzJzogc2xpZGUuYWN0aXZlfVwiIG5nLWRpc2FibGVkPVwic2xpZGUuYWN0aXZlXCIgbmctY2xpY2s9XCJzbGlkZS5hY3RpdmUgPSB0cnVlXCI+c2VsZWN0PC9idXR0b24+XG4gICAgICAgICAge3skaW5kZXh9fToge3tzbGlkZS50ZXh0fX1cbiAgICAgICAgPC9saT5cbiAgICAgIDwvdWw+XG4gICAgICA8YSBjbGFzcz1cImJ0blwiIG5nLWNsaWNrPVwiYWRkU2xpZGUoKVwiPkFkZCBTbGlkZTwvYT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic3BhbjZcIj5cbiAgICAgIEludGVydmFsLCBpbiBtaWxsaXNlY29uZHM6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbmctbW9kZWw9XCJteUludGVydmFsXCI+XG4gICAgICA8YnIgLz5FbnRlciBhIG5lZ2F0aXZlIG51bWJlciB0byBzdG9wIHRoZSBpbnRlcnZhbC5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbiAgPC9maWxlPlxuICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG5mdW5jdGlvbiBDYXJvdXNlbERlbW9DdHJsKCRzY29wZSkge1xuICAkc2NvcGUubXlJbnRlcnZhbCA9IDUwMDA7XG4gIHZhciBzbGlkZXMgPSAkc2NvcGUuc2xpZGVzID0gW107XG4gICRzY29wZS5hZGRTbGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuZXdXaWR0aCA9IDIwMCArICgoc2xpZGVzLmxlbmd0aCArICgyNSAqIHNsaWRlcy5sZW5ndGgpKSAlIDE1MCk7XG4gICAgc2xpZGVzLnB1c2goe1xuICAgICAgaW1hZ2U6ICdodHRwOi8vcGxhY2VraXR0ZW4uY29tLycgKyBuZXdXaWR0aCArICcvMjAwJyxcbiAgICAgIHRleHQ6IFsnTW9yZScsJ0V4dHJhJywnTG90cyBvZicsJ1N1cnBsdXMnXVtzbGlkZXMubGVuZ3RoICUgNF0gKyAnICdcbiAgICAgICAgWydDYXRzJywgJ0tpdHR5cycsICdGZWxpbmVzJywgJ0N1dGVzJ11bc2xpZGVzLmxlbmd0aCAlIDRdXG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGk9MDsgaTw0OyBpKyspICRzY29wZS5hZGRTbGlkZSgpO1xufVxuICA8L2ZpbGU+XG4gIDxmaWxlIG5hbWU9XCJkZW1vLmNzc1wiPlxuICAgIC5jYXJvdXNlbC1pbmRpY2F0b3JzIHtcbiAgICAgIHRvcDogYXV0bztcbiAgICAgIGJvdHRvbTogMTVweDtcbiAgICB9XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiovXG5cbi5kaXJlY3RpdmUoJ3NsaWRlJywgWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXmNhcm91c2VsJyxcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9jYXJvdXNlbC9zbGlkZS5odG1sJyxcbiAgICBzY29wZToge1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY2Fyb3VzZWxDdHJsKSB7XG4gICAgICAvL1NldCB1cCBvcHRpb25hbCAnYWN0aXZlJyA9IGJpbmRpbmdcbiAgICAgIGlmIChhdHRycy5hY3RpdmUpIHtcbiAgICAgICAgdmFyIGdldEFjdGl2ZSA9ICRwYXJzZShhdHRycy5hY3RpdmUpO1xuICAgICAgICB2YXIgc2V0QWN0aXZlID0gZ2V0QWN0aXZlLmFzc2lnbjtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHNjb3BlLmFjdGl2ZSA9IGdldEFjdGl2ZShzY29wZS4kcGFyZW50KTtcbiAgICAgICAgc2NvcGUuJHdhdGNoKGZ1bmN0aW9uIHBhcmVudEFjdGl2ZVdhdGNoKCkge1xuICAgICAgICAgIHZhciBwYXJlbnRBY3RpdmUgPSBnZXRBY3RpdmUoc2NvcGUuJHBhcmVudCk7XG5cbiAgICAgICAgICBpZiAocGFyZW50QWN0aXZlICE9PSBzY29wZS5hY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBvdXQgb2Ygc3luYyBhbmQgbmVlZCB0byBjb3B5XG4gICAgICAgICAgICBpZiAocGFyZW50QWN0aXZlICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gcGFyZW50IGNoYW5nZWQgYW5kIGl0IGhhcyBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHNjb3BlLmFjdGl2ZSA9IHBhcmVudEFjdGl2ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgY2FuIGJlIGFzc2lnbmVkIHRoZW4gZG8gc29cbiAgICAgICAgICAgICAgc2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQsIHBhcmVudEFjdGl2ZSA9IGxhc3RWYWx1ZSA9IHNjb3BlLmFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJlbnRBY3RpdmU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXJvdXNlbEN0cmwuYWRkU2xpZGUoc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgLy93aGVuIHRoZSBzY29wZSBpcyBkZXN0cm95ZWQgdGhlbiByZW1vdmUgdGhlIHNsaWRlIGZyb20gdGhlIGN1cnJlbnQgc2xpZGVzIGFycmF5XG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhcm91c2VsQ3RybC5yZW1vdmVTbGlkZShzY29wZSk7XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuJHdhdGNoKCdhY3RpdmUnLCBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgIGNhcm91c2VsQ3RybC5zZWxlY3Qoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9zaXRpb24nLCBbXSlcblxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlIHRvIHJldHJpZXZlIHBvc2l0aW9uIG9mIERPTSBlbGVtZW50cy5cbiAqIEl0IGlzIG1lYW50IHRvIGJlIHVzZWQgd2hlcmUgd2UgbmVlZCB0byBhYnNvbHV0ZS1wb3NpdGlvbiBET00gZWxlbWVudHMgaW5cbiAqIHJlbGF0aW9uIHRvIG90aGVyLCBleGlzdGluZyBlbGVtZW50cyAodGhpcyBpcyB0aGUgY2FzZSBmb3IgdG9vbHRpcHMsIHBvcG92ZXJzLFxuICogdHlwZWFoZWFkIHN1Z2dlc3Rpb25zIGV0Yy4pLlxuICovXG4gIC5mYWN0b3J5KCckcG9zaXRpb24nLCBbJyRkb2N1bWVudCcsICckd2luZG93JywgZnVuY3Rpb24gKCRkb2N1bWVudCwgJHdpbmRvdykge1xuXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGUoZWwsIGNzc3Byb3ApIHtcbiAgICAgIGlmIChlbC5jdXJyZW50U3R5bGUpIHsgLy9JRVxuICAgICAgICByZXR1cm4gZWwuY3VycmVudFN0eWxlW2Nzc3Byb3BdO1xuICAgICAgfSBlbHNlIGlmICgkd2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgcmV0dXJuICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClbY3NzcHJvcF07XG4gICAgICB9XG4gICAgICAvLyBmaW5hbGx5IHRyeSBhbmQgZ2V0IGlubGluZSBzdHlsZVxuICAgICAgcmV0dXJuIGVsLnN0eWxlW2Nzc3Byb3BdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgc3RhdGljYWxseSBwb3NpdGlvbmVkXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSByYXcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIChnZXRTdHlsZShlbGVtZW50LCBcInBvc2l0aW9uXCIpIHx8ICdzdGF0aWMnICkgPT09ICdzdGF0aWMnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGNsb3Nlc3QsIG5vbi1zdGF0aWNhbGx5IHBvc2l0aW9uZWQgcGFyZW50T2Zmc2V0IG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgdmFyIHBhcmVudE9mZnNldEVsID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciBkb2NEb21FbCA9ICRkb2N1bWVudFswXTtcbiAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBkb2NEb21FbDtcbiAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBkb2NEb21FbCAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KSApIHtcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jRG9tRWw7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIHJlYWQtb25seSBlcXVpdmFsZW50IG9mIGpRdWVyeSdzIHBvc2l0aW9uIGZ1bmN0aW9uOlxuICAgICAgICogaHR0cDovL2FwaS5qcXVlcnkuY29tL3Bvc2l0aW9uL1xuICAgICAgICovXG4gICAgICBwb3NpdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsQkNSID0gdGhpcy5vZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRCQ1IgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50RWwgPSBwYXJlbnRPZmZzZXRFbChlbGVtZW50WzBdKTtcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudEVsICE9ICRkb2N1bWVudFswXSkge1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUiA9IHRoaXMub2Zmc2V0KGFuZ3VsYXIuZWxlbWVudChvZmZzZXRQYXJlbnRFbCkpO1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi50b3AgKz0gb2Zmc2V0UGFyZW50RWwuY2xpZW50VG9wIC0gb2Zmc2V0UGFyZW50RWwuc2Nyb2xsVG9wO1xuICAgICAgICAgIG9mZnNldFBhcmVudEJDUi5sZWZ0ICs9IG9mZnNldFBhcmVudEVsLmNsaWVudExlZnQgLSBvZmZzZXRQYXJlbnRFbC5zY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvdW5kaW5nQ2xpZW50UmVjdCA9IGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCB8fCBlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJyksXG4gICAgICAgICAgaGVpZ2h0OiBib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IHx8IGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0JyksXG4gICAgICAgICAgdG9wOiBlbEJDUi50b3AgLSBvZmZzZXRQYXJlbnRCQ1IudG9wLFxuICAgICAgICAgIGxlZnQ6IGVsQkNSLmxlZnQgLSBvZmZzZXRQYXJlbnRCQ1IubGVmdFxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBvZmZzZXQgZnVuY3Rpb246XG4gICAgICAgKiBodHRwOi8vYXBpLmpxdWVyeS5jb20vb2Zmc2V0L1xuICAgICAgICovXG4gICAgICBvZmZzZXQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSBlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiBib3VuZGluZ0NsaWVudFJlY3Qud2lkdGggfHwgZWxlbWVudC5wcm9wKCdvZmZzZXRXaWR0aCcpLFxuICAgICAgICAgIGhlaWdodDogYm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCB8fCBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpLFxuICAgICAgICAgIHRvcDogYm91bmRpbmdDbGllbnRSZWN0LnRvcCArICgkd2luZG93LnBhZ2VZT2Zmc2V0IHx8ICRkb2N1bWVudFswXS5ib2R5LnNjcm9sbFRvcCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICAgICAgbGVmdDogYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgKyAoJHdpbmRvdy5wYWdlWE9mZnNldCB8fCAkZG9jdW1lbnRbMF0uYm9keS5zY3JvbGxMZWZ0ICB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4uY29uc3RhbnQoJ2RhdGVwaWNrZXJDb25maWcnLCB7XG4gIGRheUZvcm1hdDogJ2RkJyxcbiAgbW9udGhGb3JtYXQ6ICdNTU1NJyxcbiAgeWVhckZvcm1hdDogJ3l5eXknLFxuICBkYXlIZWFkZXJGb3JtYXQ6ICdFRUUnLFxuICBkYXlUaXRsZUZvcm1hdDogJ01NTU0geXl5eScsXG4gIG1vbnRoVGl0bGVGb3JtYXQ6ICd5eXl5JyxcbiAgc2hvd1dlZWtzOiB0cnVlLFxuICBzdGFydGluZ0RheTogMCxcbiAgeWVhclJhbmdlOiAyMCxcbiAgbWluRGF0ZTogbnVsbCxcbiAgbWF4RGF0ZTogbnVsbFxufSlcblxuLmNvbnRyb2xsZXIoJ0RhdGVwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ2RhdGVGaWx0ZXInLCAnZGF0ZXBpY2tlckNvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCBkYXRlRmlsdGVyLCBkdENvbmZpZykge1xuICB2YXIgZm9ybWF0ID0ge1xuICAgIGRheTogICAgICAgIGdldFZhbHVlKCRhdHRycy5kYXlGb3JtYXQsICAgICAgICBkdENvbmZpZy5kYXlGb3JtYXQpLFxuICAgIG1vbnRoOiAgICAgIGdldFZhbHVlKCRhdHRycy5tb250aEZvcm1hdCwgICAgICBkdENvbmZpZy5tb250aEZvcm1hdCksXG4gICAgeWVhcjogICAgICAgZ2V0VmFsdWUoJGF0dHJzLnllYXJGb3JtYXQsICAgICAgIGR0Q29uZmlnLnllYXJGb3JtYXQpLFxuICAgIGRheUhlYWRlcjogIGdldFZhbHVlKCRhdHRycy5kYXlIZWFkZXJGb3JtYXQsICBkdENvbmZpZy5kYXlIZWFkZXJGb3JtYXQpLFxuICAgIGRheVRpdGxlOiAgIGdldFZhbHVlKCRhdHRycy5kYXlUaXRsZUZvcm1hdCwgICBkdENvbmZpZy5kYXlUaXRsZUZvcm1hdCksXG4gICAgbW9udGhUaXRsZTogZ2V0VmFsdWUoJGF0dHJzLm1vbnRoVGl0bGVGb3JtYXQsIGR0Q29uZmlnLm1vbnRoVGl0bGVGb3JtYXQpXG4gIH0sXG4gIHN0YXJ0aW5nRGF5ID0gZ2V0VmFsdWUoJGF0dHJzLnN0YXJ0aW5nRGF5LCAgICAgIGR0Q29uZmlnLnN0YXJ0aW5nRGF5KSxcbiAgeWVhclJhbmdlID0gICBnZXRWYWx1ZSgkYXR0cnMueWVhclJhbmdlLCAgICAgICAgZHRDb25maWcueWVhclJhbmdlKTtcblxuICB0aGlzLm1pbkRhdGUgPSBkdENvbmZpZy5taW5EYXRlID8gbmV3IERhdGUoZHRDb25maWcubWluRGF0ZSkgOiBudWxsO1xuICB0aGlzLm1heERhdGUgPSBkdENvbmZpZy5tYXhEYXRlID8gbmV3IERhdGUoZHRDb25maWcubWF4RGF0ZSkgOiBudWxsO1xuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gYW5ndWxhci5pc0RlZmluZWQodmFsdWUpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGgoIHllYXIsIG1vbnRoICkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMCkuZ2V0RGF0ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0ZXMoc3RhcnREYXRlLCBuKSB7XG4gICAgdmFyIGRhdGVzID0gbmV3IEFycmF5KG4pO1xuICAgIHZhciBjdXJyZW50ID0gc3RhcnREYXRlLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGRhdGVzW2krK10gPSBuZXcgRGF0ZShjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQuc2V0RGF0ZSggY3VycmVudC5nZXREYXRlKCkgKyAxICk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VEYXRlKGRhdGUsIGZvcm1hdCwgaXNTZWxlY3RlZCwgaXNTZWNvbmRhcnkpIHtcbiAgICByZXR1cm4geyBkYXRlOiBkYXRlLCBsYWJlbDogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQpLCBzZWxlY3RlZDogISFpc1NlbGVjdGVkLCBzZWNvbmRhcnk6ICEhaXNTZWNvbmRhcnkgfTtcbiAgfVxuXG4gIHRoaXMubW9kZXMgPSBbXG4gICAge1xuICAgICAgbmFtZTogJ2RheScsXG4gICAgICBnZXRWaXNpYmxlRGF0ZXM6IGZ1bmN0aW9uKGRhdGUsIHNlbGVjdGVkKSB7XG4gICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aCA9IGRhdGUuZ2V0TW9udGgoKSwgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IHN0YXJ0aW5nRGF5IC0gZmlyc3REYXlPZk1vbnRoLmdldERheSgpLFxuICAgICAgICBudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCA9IChkaWZmZXJlbmNlID4gMCkgPyA3IC0gZGlmZmVyZW5jZSA6IC0gZGlmZmVyZW5jZSxcbiAgICAgICAgZmlyc3REYXRlID0gbmV3IERhdGUoZmlyc3REYXlPZk1vbnRoKSwgbnVtRGF0ZXMgPSAwO1xuXG4gICAgICAgIGlmICggbnVtRGlzcGxheWVkRnJvbVByZXZpb3VzTW9udGggPiAwICkge1xuICAgICAgICAgIGZpcnN0RGF0ZS5zZXREYXRlKCAtIG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoICsgMSApO1xuICAgICAgICAgIG51bURhdGVzICs9IG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoOyAvLyBQcmV2aW91c1xuICAgICAgICB9XG4gICAgICAgIG51bURhdGVzICs9IGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoICsgMSk7IC8vIEN1cnJlbnRcbiAgICAgICAgbnVtRGF0ZXMgKz0gKDcgLSBudW1EYXRlcyAlIDcpICUgNzsgLy8gTmV4dFxuXG4gICAgICAgIHZhciBkYXlzID0gZ2V0RGF0ZXMoZmlyc3REYXRlLCBudW1EYXRlcyksIGxhYmVscyA9IG5ldyBBcnJheSg3KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRlczsgaSArKykge1xuICAgICAgICAgIHZhciBkdCA9IG5ldyBEYXRlKGRheXNbaV0pO1xuICAgICAgICAgIGRheXNbaV0gPSBtYWtlRGF0ZShkdCwgZm9ybWF0LmRheSwgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldERhdGUoKSA9PT0gZHQuZ2V0RGF0ZSgpICYmIHNlbGVjdGVkLmdldE1vbnRoKCkgPT09IGR0LmdldE1vbnRoKCkgJiYgc2VsZWN0ZWQuZ2V0RnVsbFllYXIoKSA9PT0gZHQuZ2V0RnVsbFllYXIoKSksIGR0LmdldE1vbnRoKCkgIT09IG1vbnRoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICAgIGxhYmVsc1tqXSA9IGRhdGVGaWx0ZXIoZGF5c1tqXS5kYXRlLCBmb3JtYXQuZGF5SGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBvYmplY3RzOiBkYXlzLCB0aXRsZTogZGF0ZUZpbHRlcihkYXRlLCBmb3JtYXQuZGF5VGl0bGUpLCBsYWJlbHM6IGxhYmVscyB9O1xuICAgICAgfSxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKCBkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpLCBkYXRlMS5nZXREYXRlKCkgKSAtIG5ldyBEYXRlKCBkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpLCBkYXRlMi5nZXREYXRlKCkgKSApO1xuICAgICAgfSxcbiAgICAgIHNwbGl0OiA3LFxuICAgICAgc3RlcDogeyBtb250aHM6IDEgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ21vbnRoJyxcbiAgICAgIGdldFZpc2libGVEYXRlczogZnVuY3Rpb24oZGF0ZSwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdmFyIG1vbnRocyA9IG5ldyBBcnJheSgxMiksIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDEyOyBpKysgKSB7XG4gICAgICAgICAgdmFyIGR0ID0gbmV3IERhdGUoeWVhciwgaSwgMSk7XG4gICAgICAgICAgbW9udGhzW2ldID0gbWFrZURhdGUoZHQsIGZvcm1hdC5tb250aCwgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmdldE1vbnRoKCkgPT09IGkgJiYgc2VsZWN0ZWQuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG9iamVjdHM6IG1vbnRocywgdGl0bGU6IGRhdGVGaWx0ZXIoZGF0ZSwgZm9ybWF0Lm1vbnRoVGl0bGUpIH07XG4gICAgICB9LFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSggZGF0ZTEuZ2V0RnVsbFllYXIoKSwgZGF0ZTEuZ2V0TW9udGgoKSApIC0gbmV3IERhdGUoIGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCkgKTtcbiAgICAgIH0sXG4gICAgICBzcGxpdDogMyxcbiAgICAgIHN0ZXA6IHsgeWVhcnM6IDEgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ3llYXInLFxuICAgICAgZ2V0VmlzaWJsZURhdGVzOiBmdW5jdGlvbihkYXRlLCBzZWxlY3RlZCkge1xuICAgICAgICB2YXIgeWVhcnMgPSBuZXcgQXJyYXkoeWVhclJhbmdlKSwgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSwgc3RhcnRZZWFyID0gcGFyc2VJbnQoKHllYXIgLSAxKSAvIHllYXJSYW5nZSwgMTApICogeWVhclJhbmdlICsgMTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgeWVhclJhbmdlOyBpKysgKSB7XG4gICAgICAgICAgdmFyIGR0ID0gbmV3IERhdGUoc3RhcnRZZWFyICsgaSwgMCwgMSk7XG4gICAgICAgICAgeWVhcnNbaV0gPSBtYWtlRGF0ZShkdCwgZm9ybWF0LnllYXIsIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5nZXRGdWxsWWVhcigpID09PSBkdC5nZXRGdWxsWWVhcigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgb2JqZWN0czogeWVhcnMsIHRpdGxlOiBbeWVhcnNbMF0ubGFiZWwsIHllYXJzW3llYXJSYW5nZSAtIDFdLmxhYmVsXS5qb2luKCcgLSAnKSB9O1xuICAgICAgfSxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEuZ2V0RnVsbFllYXIoKSAtIGRhdGUyLmdldEZ1bGxZZWFyKCk7XG4gICAgICB9LFxuICAgICAgc3BsaXQ6IDUsXG4gICAgICBzdGVwOiB7IHllYXJzOiB5ZWFyUmFuZ2UgfVxuICAgIH1cbiAgXTtcblxuICB0aGlzLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihkYXRlLCBtb2RlKSB7XG4gICAgdmFyIGN1cnJlbnRNb2RlID0gdGhpcy5tb2Rlc1ttb2RlIHx8IDBdO1xuICAgIHJldHVybiAoKHRoaXMubWluRGF0ZSAmJiBjdXJyZW50TW9kZS5jb21wYXJlKGRhdGUsIHRoaXMubWluRGF0ZSkgPCAwKSB8fCAodGhpcy5tYXhEYXRlICYmIGN1cnJlbnRNb2RlLmNvbXBhcmUoZGF0ZSwgdGhpcy5tYXhEYXRlKSA+IDApIHx8ICgkc2NvcGUuZGF0ZURpc2FibGVkICYmICRzY29wZS5kYXRlRGlzYWJsZWQoe2RhdGU6IGRhdGUsIG1vZGU6IGN1cnJlbnRNb2RlLm5hbWV9KSkpO1xuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoICdkYXRlcGlja2VyJywgWydkYXRlRmlsdGVyJywgJyRwYXJzZScsICdkYXRlcGlja2VyQ29uZmlnJywgJyRsb2cnLCBmdW5jdGlvbiAoZGF0ZUZpbHRlciwgJHBhcnNlLCBkYXRlcGlja2VyQ29uZmlnLCAkbG9nKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sJyxcbiAgICBzY29wZToge1xuICAgICAgZGF0ZURpc2FibGVkOiAnJidcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsnZGF0ZXBpY2tlcicsICc/Xm5nTW9kZWwnXSxcbiAgICBjb250cm9sbGVyOiAnRGF0ZXBpY2tlckNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsID0gY3RybHNbMV07XG5cbiAgICAgIGlmICghbmdNb2RlbCkge1xuICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcbiAgICAgIH1cblxuICAgICAgLy8gQ29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICB2YXIgbW9kZSA9IDAsIHNlbGVjdGVkID0gbmV3IERhdGUoKSwgc2hvd1dlZWtzID0gZGF0ZXBpY2tlckNvbmZpZy5zaG93V2Vla3M7XG5cbiAgICAgIGlmIChhdHRycy5zaG93V2Vla3MpIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLnNob3dXZWVrcyksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgc2hvd1dlZWtzID0gISEgdmFsdWU7XG4gICAgICAgICAgdXBkYXRlU2hvd1dlZWtOdW1iZXJzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU2hvd1dlZWtOdW1iZXJzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycy5taW4pIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1pbiksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgZGF0ZXBpY2tlckN0cmwubWluRGF0ZSA9IHZhbHVlID8gbmV3IERhdGUodmFsdWUpIDogbnVsbDtcbiAgICAgICAgICByZWZpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cnMubWF4KSB7XG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5tYXgpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGRhdGVwaWNrZXJDdHJsLm1heERhdGUgPSB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlKSA6IG51bGw7XG4gICAgICAgICAgcmVmaWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVTaG93V2Vla051bWJlcnMoKSB7XG4gICAgICAgIHNjb3BlLnNob3dXZWVrTnVtYmVycyA9IG1vZGUgPT09IDAgJiYgc2hvd1dlZWtzO1xuICAgICAgfVxuXG4gICAgICAvLyBTcGxpdCBhcnJheSBpbnRvIHNtYWxsZXIgYXJyYXlzXG4gICAgICBmdW5jdGlvbiBzcGxpdChhcnIsIHNpemUpIHtcbiAgICAgICAgdmFyIGFycmF5cyA9IFtdO1xuICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhcnJheXMucHVzaChhcnIuc3BsaWNlKDAsIHNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWZpbGwoIHVwZGF0ZVNlbGVjdGVkICkge1xuICAgICAgICB2YXIgZGF0ZSA9IG51bGwsIHZhbGlkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIG5nTW9kZWwuJG1vZGVsVmFsdWUgKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCBuZ01vZGVsLiRtb2RlbFZhbHVlICk7XG5cbiAgICAgICAgICBpZiAoIGlzTmFOKGRhdGUpICkge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICRsb2cuZXJyb3IoJ0RhdGVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIHVwZGF0ZVNlbGVjdGVkICkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZScsIHZhbGlkKTtcblxuICAgICAgICB2YXIgY3VycmVudE1vZGUgPSBkYXRlcGlja2VyQ3RybC5tb2Rlc1ttb2RlXSwgZGF0YSA9IGN1cnJlbnRNb2RlLmdldFZpc2libGVEYXRlcyhzZWxlY3RlZCwgZGF0ZSk7XG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChkYXRhLm9iamVjdHMsIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIG9iai5kaXNhYmxlZCA9IGRhdGVwaWNrZXJDdHJsLmlzRGlzYWJsZWQob2JqLmRhdGUsIG1vZGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZS1kaXNhYmxlZCcsICghZGF0ZSB8fCAhZGF0ZXBpY2tlckN0cmwuaXNEaXNhYmxlZChkYXRlKSkpO1xuXG4gICAgICAgIHNjb3BlLnJvd3MgPSBzcGxpdChkYXRhLm9iamVjdHMsIGN1cnJlbnRNb2RlLnNwbGl0KTtcbiAgICAgICAgc2NvcGUubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gICAgICAgIHNjb3BlLnRpdGxlID0gZGF0YS50aXRsZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0TW9kZSh2YWx1ZSkge1xuICAgICAgICBtb2RlID0gdmFsdWU7XG4gICAgICAgIHVwZGF0ZVNob3dXZWVrTnVtYmVycygpO1xuICAgICAgICByZWZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgbmdNb2RlbC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZmlsbCggdHJ1ZSApO1xuICAgICAgfTtcblxuICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oIGRhdGUgKSB7XG4gICAgICAgIGlmICggbW9kZSA9PT0gMCApIHtcbiAgICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZSggbmdNb2RlbC4kbW9kZWxWYWx1ZSApO1xuICAgICAgICAgIGR0LnNldEZ1bGxZZWFyKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkgKTtcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoIGR0ICk7XG4gICAgICAgICAgcmVmaWxsKCB0cnVlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSBkYXRlO1xuICAgICAgICAgIHNldE1vZGUoIG1vZGUgLSAxICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzY29wZS5tb3ZlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBzdGVwID0gZGF0ZXBpY2tlckN0cmwubW9kZXNbbW9kZV0uc3RlcDtcbiAgICAgICAgc2VsZWN0ZWQuc2V0TW9udGgoIHNlbGVjdGVkLmdldE1vbnRoKCkgKyBkaXJlY3Rpb24gKiAoc3RlcC5tb250aHMgfHwgMCkgKTtcbiAgICAgICAgc2VsZWN0ZWQuc2V0RnVsbFllYXIoIHNlbGVjdGVkLmdldEZ1bGxZZWFyKCkgKyBkaXJlY3Rpb24gKiAoc3RlcC55ZWFycyB8fCAwKSApO1xuICAgICAgICByZWZpbGwoKTtcbiAgICAgIH07XG4gICAgICBzY29wZS50b2dnbGVNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldE1vZGUoIChtb2RlICsgMSkgJSBkYXRlcGlja2VyQ3RybC5tb2Rlcy5sZW5ndGggKTtcbiAgICAgIH07XG4gICAgICBzY29wZS5nZXRXZWVrTnVtYmVyID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiAoIG1vZGUgPT09IDAgJiYgc2NvcGUuc2hvd1dlZWtOdW1iZXJzICYmIHJvdy5sZW5ndGggPT09IDcgKSA/IGdldElTTzg2MDFXZWVrTnVtYmVyKHJvd1swXS5kYXRlKSA6IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBnZXRJU084NjAxV2Vla051bWJlcihkYXRlKSB7XG4gICAgICAgIHZhciBjaGVja0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgY2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTsgLy8gVGh1cnNkYXlcbiAgICAgICAgdmFyIHRpbWUgPSBjaGVja0RhdGUuZ2V0VGltZSgpO1xuICAgICAgICBjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxuICAgICAgICBjaGVja0RhdGUuc2V0RGF0ZSgxKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgodGltZSAtIGNoZWNrRGF0ZSkgLyA4NjQwMDAwMCkgLyA3KSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb25zdGFudCgnZGF0ZXBpY2tlclBvcHVwQ29uZmlnJywge1xuICBkYXRlRm9ybWF0OiAneXl5eS1NTS1kZCcsXG4gIGN1cnJlbnRUZXh0OiAnVG9kYXknLFxuICB0b2dnbGVXZWVrc1RleHQ6ICdXZWVrcycsXG4gIGNsZWFyVGV4dDogJ0NsZWFyJyxcbiAgY2xvc2VUZXh0OiAnRG9uZScsXG4gIGNsb3NlT25EYXRlU2VsZWN0aW9uOiB0cnVlLFxuICBhcHBlbmRUb0JvZHk6IGZhbHNlXG59KVxuXG4uZGlyZWN0aXZlKCdkYXRlcGlja2VyUG9wdXAnLCBbJyRjb21waWxlJywgJyRwYXJzZScsICckZG9jdW1lbnQnLCAnJHBvc2l0aW9uJywgJ2RhdGVGaWx0ZXInLCAnZGF0ZXBpY2tlclBvcHVwQ29uZmlnJywgJ2RhdGVwaWNrZXJDb25maWcnLFxuZnVuY3Rpb24gKCRjb21waWxlLCAkcGFyc2UsICRkb2N1bWVudCwgJHBvc2l0aW9uLCBkYXRlRmlsdGVyLCBkYXRlcGlja2VyUG9wdXBDb25maWcsIGRhdGVwaWNrZXJDb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gICAgbGluazogZnVuY3Rpb24ob3JpZ2luYWxTY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgICAgIHZhciBkYXRlRm9ybWF0O1xuICAgICAgYXR0cnMuJG9ic2VydmUoJ2RhdGVwaWNrZXJQb3B1cCcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgZGF0ZUZvcm1hdCA9IHZhbHVlIHx8IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlRm9ybWF0O1xuICAgICAgICAgIG5nTW9kZWwuJHJlbmRlcigpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjbG9zZU9uRGF0ZVNlbGVjdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmNsb3NlT25EYXRlU2VsZWN0aW9uKSA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pIDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmNsb3NlT25EYXRlU2VsZWN0aW9uO1xuICAgICAgdmFyIGFwcGVuZFRvQm9keSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy5kYXRlcGlja2VyQXBwZW5kVG9Cb2R5KSA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5hcHBlbmRUb0JvZHk7XG5cbiAgICAgIC8vIGNyZWF0ZSBhIGNoaWxkIHNjb3BlIGZvciB0aGUgZGF0ZXBpY2tlciBkaXJlY3RpdmUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgc2NvcGVcbiAgICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xuXG4gICAgICBvcmlnaW5hbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgIH0pO1xuXG4gICAgICBhdHRycy4kb2JzZXJ2ZSgnY3VycmVudFRleHQnLCBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHNjb3BlLmN1cnJlbnRUZXh0ID0gYW5ndWxhci5pc0RlZmluZWQodGV4dCkgPyB0ZXh0IDogZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmN1cnJlbnRUZXh0O1xuICAgICAgfSk7XG4gICAgICBhdHRycy4kb2JzZXJ2ZSgndG9nZ2xlV2Vla3NUZXh0JywgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBzY29wZS50b2dnbGVXZWVrc1RleHQgPSBhbmd1bGFyLmlzRGVmaW5lZCh0ZXh0KSA/IHRleHQgOiBkYXRlcGlja2VyUG9wdXBDb25maWcudG9nZ2xlV2Vla3NUZXh0O1xuICAgICAgfSk7XG4gICAgICBhdHRycy4kb2JzZXJ2ZSgnY2xlYXJUZXh0JywgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBzY29wZS5jbGVhclRleHQgPSBhbmd1bGFyLmlzRGVmaW5lZCh0ZXh0KSA/IHRleHQgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuY2xlYXJUZXh0O1xuICAgICAgfSk7XG4gICAgICBhdHRycy4kb2JzZXJ2ZSgnY2xvc2VUZXh0JywgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBzY29wZS5jbG9zZVRleHQgPSBhbmd1bGFyLmlzRGVmaW5lZCh0ZXh0KSA/IHRleHQgOiBkYXRlcGlja2VyUG9wdXBDb25maWcuY2xvc2VUZXh0O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBnZXRJc09wZW4sIHNldElzT3BlbjtcbiAgICAgIGlmICggYXR0cnMuaXNPcGVuICkge1xuICAgICAgICBnZXRJc09wZW4gPSAkcGFyc2UoYXR0cnMuaXNPcGVuKTtcbiAgICAgICAgc2V0SXNPcGVuID0gZ2V0SXNPcGVuLmFzc2lnbjtcblxuICAgICAgICBvcmlnaW5hbFNjb3BlLiR3YXRjaChnZXRJc09wZW4sIGZ1bmN0aW9uIHVwZGF0ZU9wZW4odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5pc09wZW4gPSAhISB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzY29wZS5pc09wZW4gPSBnZXRJc09wZW4gPyBnZXRJc09wZW4ob3JpZ2luYWxTY29wZSkgOiBmYWxzZTsgLy8gSW5pdGlhbCBzdGF0ZVxuXG4gICAgICBmdW5jdGlvbiBzZXRPcGVuKCB2YWx1ZSApIHtcbiAgICAgICAgaWYgKHNldElzT3Blbikge1xuICAgICAgICAgIHNldElzT3BlbihvcmlnaW5hbFNjb3BlLCAhIXZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZS5pc09wZW4gPSAhIXZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkb2N1bWVudENsaWNrQmluZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChzY29wZS5pc09wZW4gJiYgZXZlbnQudGFyZ2V0ICE9PSBlbGVtZW50WzBdKSB7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBlbGVtZW50Rm9jdXNCaW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZXRPcGVuKCB0cnVlICk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gcG9wdXAgZWxlbWVudCB1c2VkIHRvIGRpc3BsYXkgY2FsZW5kYXJcbiAgICAgIHZhciBwb3B1cEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IGRhdGVwaWNrZXItcG9wdXAtd3JhcD48ZGl2IGRhdGVwaWNrZXI+PC9kaXY+PC9kaXY+Jyk7XG4gICAgICBwb3B1cEVsLmF0dHIoe1xuICAgICAgICAnbmctbW9kZWwnOiAnZGF0ZScsXG4gICAgICAgICduZy1jaGFuZ2UnOiAnZGF0ZVNlbGVjdGlvbigpJ1xuICAgICAgfSk7XG4gICAgICB2YXIgZGF0ZXBpY2tlckVsID0gYW5ndWxhci5lbGVtZW50KHBvcHVwRWwuY2hpbGRyZW4oKVswXSk7XG4gICAgICBpZiAoYXR0cnMuZGF0ZXBpY2tlck9wdGlvbnMpIHtcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoYW5ndWxhci5leHRlbmQoe30sIG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMuZGF0ZXBpY2tlck9wdGlvbnMpKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHJldmVyc2UgZnJvbSBkYXRlRmlsdGVyIHN0cmluZyB0byBEYXRlIG9iamVjdFxuICAgICAgZnVuY3Rpb24gcGFyc2VEYXRlKHZpZXdWYWx1ZSkge1xuICAgICAgICBpZiAoIXZpZXdWYWx1ZSkge1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc0RhdGUodmlld1ZhbHVlKSkge1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZpZXdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZpZXdWYWx1ZSkpIHtcbiAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHZpZXdWYWx1ZSk7XG4gICAgICAgICAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgnZGF0ZScsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCdkYXRlJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ2RhdGUnLCBmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmdNb2RlbC4kcGFyc2Vycy51bnNoaWZ0KHBhcnNlRGF0ZSk7XG5cbiAgICAgIC8vIElubmVyIGNoYW5nZVxuICAgICAgc2NvcGUuZGF0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoc2NvcGUuZGF0ZSk7XG4gICAgICAgIG5nTW9kZWwuJHJlbmRlcigpO1xuXG4gICAgICAgIGlmIChjbG9zZU9uRGF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgIHNldE9wZW4oIGZhbHNlICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnQuYmluZCgnaW5wdXQgY2hhbmdlIGtleXVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICB1cGRhdGVDYWxlbmRhcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPdXR0ZXIgY2hhbmdlXG4gICAgICBuZ01vZGVsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZ01vZGVsLiR2aWV3VmFsdWUgPyBkYXRlRmlsdGVyKG5nTW9kZWwuJHZpZXdWYWx1ZSwgZGF0ZUZvcm1hdCkgOiAnJztcbiAgICAgICAgZWxlbWVudC52YWwoZGF0ZSk7XG5cbiAgICAgICAgdXBkYXRlQ2FsZW5kYXIoKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbGVuZGFyKCkge1xuICAgICAgICBzY29wZS5kYXRlID0gbmdNb2RlbC4kbW9kZWxWYWx1ZTtcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkV2F0Y2hhYmxlQXR0cmlidXRlKGF0dHJpYnV0ZSwgc2NvcGVQcm9wZXJ0eSwgZGF0ZXBpY2tlckF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgb3JpZ2luYWxTY29wZS4kd2F0Y2goJHBhcnNlKGF0dHJpYnV0ZSksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICAgIHNjb3BlW3Njb3BlUHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoZGF0ZXBpY2tlckF0dHJpYnV0ZSB8fCBzY29wZVByb3BlcnR5LCBzY29wZVByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkV2F0Y2hhYmxlQXR0cmlidXRlKGF0dHJzLm1pbiwgJ21pbicpO1xuICAgICAgYWRkV2F0Y2hhYmxlQXR0cmlidXRlKGF0dHJzLm1heCwgJ21heCcpO1xuICAgICAgaWYgKGF0dHJzLnNob3dXZWVrcykge1xuICAgICAgICBhZGRXYXRjaGFibGVBdHRyaWJ1dGUoYXR0cnMuc2hvd1dlZWtzLCAnc2hvd1dlZWtzJywgJ3Nob3ctd2Vla3MnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlLnNob3dXZWVrcyA9IGRhdGVwaWNrZXJDb25maWcuc2hvd1dlZWtzO1xuICAgICAgICBkYXRlcGlja2VyRWwuYXR0cignc2hvdy13ZWVrcycsICdzaG93V2Vla3MnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRycy5kYXRlRGlzYWJsZWQpIHtcbiAgICAgICAgZGF0ZXBpY2tlckVsLmF0dHIoJ2RhdGUtZGlzYWJsZWQnLCBhdHRycy5kYXRlRGlzYWJsZWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgICAgc2NvcGUucG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KGVsZW1lbnQpIDogJHBvc2l0aW9uLnBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgICBzY29wZS5wb3NpdGlvbi50b3AgPSBzY29wZS5wb3NpdGlvbi50b3AgKyBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9jdW1lbnRCaW5kaW5nSW5pdGlhbGl6ZWQgPSBmYWxzZSwgZWxlbWVudEZvY3VzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAkZG9jdW1lbnQuYmluZCgnY2xpY2snLCBkb2N1bWVudENsaWNrQmluZCk7XG4gICAgICAgICAgaWYoZWxlbWVudEZvY3VzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudW5iaW5kKCdmb2N1cycsIGVsZW1lbnRGb2N1c0JpbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgZG9jdW1lbnRCaW5kaW5nSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGRvY3VtZW50QmluZGluZ0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAkZG9jdW1lbnQudW5iaW5kKCdjbGljaycsIGRvY3VtZW50Q2xpY2tCaW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5iaW5kKCdmb2N1cycsIGVsZW1lbnRGb2N1c0JpbmQpO1xuICAgICAgICAgIGVsZW1lbnRGb2N1c0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc2V0SXNPcGVuICkge1xuICAgICAgICAgIHNldElzT3BlbihvcmlnaW5hbFNjb3BlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgJHNldE1vZGVsVmFsdWUgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCkuYXNzaWduO1xuXG4gICAgICBzY29wZS50b2RheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2V0TW9kZWxWYWx1ZShvcmlnaW5hbFNjb3BlLCBuZXcgRGF0ZSgpKTtcbiAgICAgIH07XG4gICAgICBzY29wZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2V0TW9kZWxWYWx1ZShvcmlnaW5hbFNjb3BlLCBudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciAkcG9wdXAgPSAkY29tcGlsZShwb3B1cEVsKShzY29wZSk7XG4gICAgICBpZiAoIGFwcGVuZFRvQm9keSApIHtcbiAgICAgICAgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5hcHBlbmQoJHBvcHVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuYWZ0ZXIoJHBvcHVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgnZGF0ZXBpY2tlclBvcHVwV3JhcCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OidFQScsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvZGF0ZXBpY2tlci9wb3B1cC5odG1sJyxcbiAgICBsaW5rOmZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIGVsZW1lbnQuYmluZCgnY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vKlxuICogZHJvcGRvd25Ub2dnbGUgLSBQcm92aWRlcyBkcm9wZG93biBtZW51IGZ1bmN0aW9uYWxpdHkgaW4gcGxhY2Ugb2YgYm9vdHN0cmFwIGpzXG4gKiBAcmVzdHJpY3QgY2xhc3Mgb3IgYXR0cmlidXRlXG4gKiBAZXhhbXBsZTpcbiAgIDxsaSBjbGFzcz1cImRyb3Bkb3duXCI+XG4gICAgIDxhIGNsYXNzPVwiZHJvcGRvd24tdG9nZ2xlXCI+TXkgRHJvcGRvd24gTWVudTwvYT5cbiAgICAgPHVsIGNsYXNzPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJjaG9pY2UgaW4gZHJvcENob2ljZXNcIj5cbiAgICAgICAgIDxhIG5nLWhyZWY9XCJ7e2Nob2ljZS5ocmVmfX1cIj57e2Nob2ljZS50ZXh0fX08L2E+XG4gICAgICAgPC9saT5cbiAgICAgPC91bD5cbiAgIDwvbGk+XG4gKi9cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kcm9wZG93blRvZ2dsZScsIFtdKS5kaXJlY3RpdmUoJ2Ryb3Bkb3duVG9nZ2xlJywgWyckZG9jdW1lbnQnLCAnJGxvY2F0aW9uJywgZnVuY3Rpb24gKCRkb2N1bWVudCwgJGxvY2F0aW9uKSB7XG4gIHZhciBvcGVuRWxlbWVudCA9IG51bGwsXG4gICAgICBjbG9zZU1lbnUgICA9IGFuZ3VsYXIubm9vcDtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0NBJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHNjb3BlLiR3YXRjaCgnJGxvY2F0aW9uLnBhdGgnLCBmdW5jdGlvbigpIHsgY2xvc2VNZW51KCk7IH0pO1xuICAgICAgZWxlbWVudC5wYXJlbnQoKS5iaW5kKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBjbG9zZU1lbnUoKTsgfSk7XG4gICAgICBlbGVtZW50LmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRXYXNPcGVuID0gKGVsZW1lbnQgPT09IG9wZW5FbGVtZW50KTtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAoISFvcGVuRWxlbWVudCkge1xuICAgICAgICAgIGNsb3NlTWVudSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbGVtZW50V2FzT3BlbiAmJiAhZWxlbWVudC5oYXNDbGFzcygnZGlzYWJsZWQnKSAmJiAhZWxlbWVudC5wcm9wKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQoKS5hZGRDbGFzcygnb3BlbicpO1xuICAgICAgICAgIG9wZW5FbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICBjbG9zZU1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgY2xvc2VNZW51KTtcbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICAgICAgICAgIGNsb3NlTWVudSA9IGFuZ3VsYXIubm9vcDtcbiAgICAgICAgICAgIG9wZW5FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgICRkb2N1bWVudC5iaW5kKCdjbGljaycsIGNsb3NlTWVudSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5tb2RhbCcsIFtdKVxuXG4vKipcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB0aGF0IGFjdHMgYXMgYSBtYXAgYnV0IGFsc28gYWxsb3dzIGdldHRpbmcgLyByZW1vdmluZ1xuICogZWxlbWVudHMgaW4gdGhlIExJRk8gb3JkZXJcbiAqL1xuICAuZmFjdG9yeSgnJCRzdGFja2VkTWFwJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PSBzdGFja1tpXS5rZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAga2V5cy5wdXNoKHN0YWNrW2ldLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT0gc3RhY2tbaV0ua2V5KSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNwbGljZShpZHgsIDEpWzBdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIDEsIDEpWzBdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2subGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9KVxuXG4vKipcbiAqIEEgaGVscGVyIGRpcmVjdGl2ZSBmb3IgdGhlICRtb2RhbCBzZXJ2aWNlLiBJdCBjcmVhdGVzIGEgYmFja2Ryb3AgZWxlbWVudC5cbiAqL1xuICAuZGlyZWN0aXZlKCdtb2RhbEJhY2tkcm9wJywgWyckbW9kYWxTdGFjaycsICckdGltZW91dCcsIGZ1bmN0aW9uICgkbW9kYWxTdGFjaywgJHRpbWVvdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcblxuICAgICAgICAvL3RyaWdnZXIgQ1NTIHRyYW5zaXRpb25zXG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY29wZS5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuY2xvc2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgdmFyIG1vZGFsID0gJG1vZGFsU3RhY2suZ2V0VG9wKCk7XG4gICAgICAgICAgaWYgKG1vZGFsICYmIG1vZGFsLnZhbHVlLmJhY2tkcm9wICYmIG1vZGFsLnZhbHVlLmJhY2tkcm9wICE9ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5LCAnYmFja2Ryb3AgY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgnbW9kYWxXaW5kb3cnLCBbJyR0aW1lb3V0JywgZnVuY3Rpb24gKCR0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgaW5kZXg6ICdAJ1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbCcsXG4gICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHNjb3BlLndpbmRvd0NsYXNzID0gYXR0cnMud2luZG93Q2xhc3MgfHwgJyc7XG5cbiAgICAgICAgLy90cmlnZ2VyIENTUyB0cmFuc2l0aW9uc1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2NvcGUuYW5pbWF0ZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5mYWN0b3J5KCckbW9kYWxTdGFjaycsIFsnJGRvY3VtZW50JywgJyRjb21waWxlJywgJyRyb290U2NvcGUnLCAnJCRzdGFja2VkTWFwJyxcbiAgICBmdW5jdGlvbiAoJGRvY3VtZW50LCAkY29tcGlsZSwgJHJvb3RTY29wZSwgJCRzdGFja2VkTWFwKSB7XG5cbiAgICAgIHZhciBiYWNrZHJvcGpxTGl0ZUVsLCBiYWNrZHJvcERvbUVsO1xuICAgICAgdmFyIGJhY2tkcm9wU2NvcGUgPSAkcm9vdFNjb3BlLiRuZXcodHJ1ZSk7XG4gICAgICB2YXIgYm9keSA9ICRkb2N1bWVudC5maW5kKCdib2R5JykuZXEoMCk7XG4gICAgICB2YXIgb3BlbmVkV2luZG93cyA9ICQkc3RhY2tlZE1hcC5jcmVhdGVOZXcoKTtcbiAgICAgIHZhciAkbW9kYWxTdGFjayA9IHt9O1xuXG4gICAgICBmdW5jdGlvbiBiYWNrZHJvcEluZGV4KCkge1xuICAgICAgICB2YXIgdG9wQmFja2Ryb3BJbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3BlbmVkID0gb3BlbmVkV2luZG93cy5rZXlzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9wZW5lZFdpbmRvd3MuZ2V0KG9wZW5lZFtpXSkudmFsdWUuYmFja2Ryb3ApIHtcbiAgICAgICAgICAgIHRvcEJhY2tkcm9wSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wQmFja2Ryb3BJbmRleDtcbiAgICAgIH1cblxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goYmFja2Ryb3BJbmRleCwgZnVuY3Rpb24obmV3QmFja2Ryb3BJbmRleCl7XG4gICAgICAgIGJhY2tkcm9wU2NvcGUuaW5kZXggPSBuZXdCYWNrZHJvcEluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UpIHtcblxuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKS52YWx1ZTtcblxuICAgICAgICAvL2NsZWFuIHVwIHRoZSBzdGFja1xuICAgICAgICBvcGVuZWRXaW5kb3dzLnJlbW92ZShtb2RhbEluc3RhbmNlKTtcblxuICAgICAgICAvL3JlbW92ZSB3aW5kb3cgRE9NIGVsZW1lbnRcbiAgICAgICAgbW9kYWxXaW5kb3cubW9kYWxEb21FbC5yZW1vdmUoKTtcblxuICAgICAgICAvL3JlbW92ZSBiYWNrZHJvcCBpZiBubyBsb25nZXIgbmVlZGVkXG4gICAgICAgIGlmIChiYWNrZHJvcERvbUVsICYmIGJhY2tkcm9wSW5kZXgoKSA9PSAtMSkge1xuICAgICAgICAgIGJhY2tkcm9wRG9tRWwucmVtb3ZlKCk7XG4gICAgICAgICAgYmFja2Ryb3BEb21FbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZGVzdHJveSBzY29wZVxuICAgICAgICBtb2RhbFdpbmRvdy5tb2RhbFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgICRkb2N1bWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgbW9kYWw7XG5cbiAgICAgICAgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcbiAgICAgICAgICBtb2RhbCA9IG9wZW5lZFdpbmRvd3MudG9wKCk7XG4gICAgICAgICAgaWYgKG1vZGFsICYmIG1vZGFsLnZhbHVlLmtleWJvYXJkKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MobW9kYWwua2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgICRtb2RhbFN0YWNrLm9wZW4gPSBmdW5jdGlvbiAobW9kYWxJbnN0YW5jZSwgbW9kYWwpIHtcblxuICAgICAgICBvcGVuZWRXaW5kb3dzLmFkZChtb2RhbEluc3RhbmNlLCB7XG4gICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsLmRlZmVycmVkLFxuICAgICAgICAgIG1vZGFsU2NvcGU6IG1vZGFsLnNjb3BlLFxuICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbC5iYWNrZHJvcCxcbiAgICAgICAgICBrZXlib2FyZDogbW9kYWwua2V5Ym9hcmRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGFuZ3VsYXJEb21FbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiBtb2RhbC13aW5kb3c+PC9kaXY+Jyk7XG4gICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKCd3aW5kb3ctY2xhc3MnLCBtb2RhbC53aW5kb3dDbGFzcyk7XG4gICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKCdpbmRleCcsIG9wZW5lZFdpbmRvd3MubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgYW5ndWxhckRvbUVsLmh0bWwobW9kYWwuY29udGVudCk7XG5cbiAgICAgICAgdmFyIG1vZGFsRG9tRWwgPSAkY29tcGlsZShhbmd1bGFyRG9tRWwpKG1vZGFsLnNjb3BlKTtcbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbERvbUVsID0gbW9kYWxEb21FbDtcbiAgICAgICAgYm9keS5hcHBlbmQobW9kYWxEb21FbCk7XG5cbiAgICAgICAgaWYgKGJhY2tkcm9wSW5kZXgoKSA+PSAwICYmICFiYWNrZHJvcERvbUVsKSB7XG4gICAgICAgICAgICBiYWNrZHJvcGpxTGl0ZUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IG1vZGFsLWJhY2tkcm9wPjwvZGl2PicpO1xuICAgICAgICAgICAgYmFja2Ryb3BEb21FbCA9ICRjb21waWxlKGJhY2tkcm9wanFMaXRlRWwpKGJhY2tkcm9wU2NvcGUpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmQoYmFja2Ryb3BEb21FbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmNsb3NlID0gZnVuY3Rpb24gKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbW9kYWwgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgbW9kYWwudmFsdWUuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5kaXNtaXNzID0gZnVuY3Rpb24gKG1vZGFsSW5zdGFuY2UsIHJlYXNvbikge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKS52YWx1ZTtcbiAgICAgICAgaWYgKG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cuZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5lZFdpbmRvd3MudG9wKCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gJG1vZGFsU3RhY2s7XG4gICAgfV0pXG5cbiAgLnByb3ZpZGVyKCckbW9kYWwnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgJG1vZGFsUHJvdmlkZXIgPSB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJhY2tkcm9wOiB0cnVlLCAvL2NhbiBiZSBhbHNvIGZhbHNlIG9yICdzdGF0aWMnXG4gICAgICAgIGtleWJvYXJkOiB0cnVlXG4gICAgICB9LFxuICAgICAgJGdldDogWyckaW5qZWN0b3InLCAnJHJvb3RTY29wZScsICckcScsICckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckY29udHJvbGxlcicsICckbW9kYWxTdGFjaycsXG4gICAgICAgIGZ1bmN0aW9uICgkaW5qZWN0b3IsICRyb290U2NvcGUsICRxLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUsICRjb250cm9sbGVyLCAkbW9kYWxTdGFjaykge1xuXG4gICAgICAgICAgdmFyICRtb2RhbCA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVQcm9taXNlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnRlbXBsYXRlID8gJHEud2hlbihvcHRpb25zLnRlbXBsYXRlKSA6XG4gICAgICAgICAgICAgICRodHRwLmdldChvcHRpb25zLnRlbXBsYXRlVXJsLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBnZXRSZXNvbHZlUHJvbWlzZXMocmVzb2x2ZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlc0FyciA9IFtdO1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlc29sdmVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHZhbHVlKSB8fCBhbmd1bGFyLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNBcnIucHVzaCgkcS53aGVuKCRpbmplY3Rvci5pbnZva2UodmFsdWUpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzQXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRtb2RhbC5vcGVuID0gZnVuY3Rpb24gKG1vZGFsT3B0aW9ucykge1xuXG4gICAgICAgICAgICB2YXIgbW9kYWxSZXN1bHREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICB2YXIgbW9kYWxPcGVuZWREZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG5cbiAgICAgICAgICAgIC8vcHJlcGFyZSBhbiBpbnN0YW5jZSBvZiBhIG1vZGFsIHRvIGJlIGluamVjdGVkIGludG8gY29udHJvbGxlcnMgYW5kIHJldHVybmVkIHRvIGEgY2FsbGVyXG4gICAgICAgICAgICB2YXIgbW9kYWxJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgcmVzdWx0OiBtb2RhbFJlc3VsdERlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIG9wZW5lZDogbW9kYWxPcGVuZWREZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLmNsb3NlKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRpc21pc3M6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsSW5zdGFuY2UsIHJlYXNvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vbWVyZ2UgYW5kIGNsZWFuIHVwIG9wdGlvbnNcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucyA9IGFuZ3VsYXIuZXh0ZW5kKHt9LCAkbW9kYWxQcm92aWRlci5vcHRpb25zLCBtb2RhbE9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kYWxPcHRpb25zLnJlc29sdmUgPSBtb2RhbE9wdGlvbnMucmVzb2x2ZSB8fCB7fTtcblxuICAgICAgICAgICAgLy92ZXJpZnkgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMudGVtcGxhdGUgJiYgIW1vZGFsT3B0aW9ucy50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09uZSBvZiB0ZW1wbGF0ZSBvciB0ZW1wbGF0ZVVybCBvcHRpb25zIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICRxLmFsbChbZ2V0VGVtcGxhdGVQcm9taXNlKG1vZGFsT3B0aW9ucyldLmNvbmNhdChnZXRSZXNvbHZlUHJvbWlzZXMobW9kYWxPcHRpb25zLnJlc29sdmUpKSk7XG5cblxuICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIHJlc29sdmVTdWNjZXNzKHRwbEFuZFZhcnMpIHtcblxuICAgICAgICAgICAgICB2YXIgbW9kYWxTY29wZSA9IChtb2RhbE9wdGlvbnMuc2NvcGUgfHwgJHJvb3RTY29wZSkuJG5ldygpO1xuICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRjbG9zZSA9IG1vZGFsSW5zdGFuY2UuY2xvc2U7XG4gICAgICAgICAgICAgIG1vZGFsU2NvcGUuJGRpc21pc3MgPSBtb2RhbEluc3RhbmNlLmRpc21pc3M7XG5cbiAgICAgICAgICAgICAgdmFyIGN0cmxJbnN0YW5jZSwgY3RybExvY2FscyA9IHt9O1xuICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUl0ZXIgPSAxO1xuXG4gICAgICAgICAgICAgIC8vY29udHJvbGxlcnNcbiAgICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY3RybExvY2Fscy4kc2NvcGUgPSBtb2RhbFNjb3BlO1xuICAgICAgICAgICAgICAgIGN0cmxMb2NhbHMuJG1vZGFsSW5zdGFuY2UgPSBtb2RhbEluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChtb2RhbE9wdGlvbnMucmVzb2x2ZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGN0cmxMb2NhbHNba2V5XSA9IHRwbEFuZFZhcnNbcmVzb2x2ZUl0ZXIrK107XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UgPSAkY29udHJvbGxlcihtb2RhbE9wdGlvbnMuY29udHJvbGxlciwgY3RybExvY2Fscyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAkbW9kYWxTdGFjay5vcGVuKG1vZGFsSW5zdGFuY2UsIHtcbiAgICAgICAgICAgICAgICBzY29wZTogbW9kYWxTY29wZSxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZDogbW9kYWxSZXN1bHREZWZlcnJlZCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0cGxBbmRWYXJzWzBdLFxuICAgICAgICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbE9wdGlvbnMuYmFja2Ryb3AsXG4gICAgICAgICAgICAgICAga2V5Ym9hcmQ6IG1vZGFsT3B0aW9ucy5rZXlib2FyZCxcbiAgICAgICAgICAgICAgICB3aW5kb3dDbGFzczogbW9kYWxPcHRpb25zLndpbmRvd0NsYXNzXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiByZXNvbHZlRXJyb3IocmVhc29uKSB7XG4gICAgICAgICAgICAgIG1vZGFsUmVzdWx0RGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgbW9kYWxPcGVuZWREZWZlcnJlZC5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBtb2RhbE9wZW5lZERlZmVycmVkLnJlamVjdChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1vZGFsSW5zdGFuY2U7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJldHVybiAkbW9kYWw7XG4gICAgICAgIH1dXG4gICAgfTtcblxuICAgIHJldHVybiAkbW9kYWxQcm92aWRlcjtcbiAgfSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucGFnaW5hdGlvbicsIFtdKVxuXG4uY29udHJvbGxlcignUGFnaW5hdGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAnJHBhcnNlJywgJyRpbnRlcnBvbGF0ZScsIGZ1bmN0aW9uICgkc2NvcGUsICRhdHRycywgJHBhcnNlLCAkaW50ZXJwb2xhdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgc2V0TnVtUGFnZXMgPSAkYXR0cnMubnVtUGFnZXMgPyAkcGFyc2UoJGF0dHJzLm51bVBhZ2VzKS5hc3NpZ24gOiBhbmd1bGFyLm5vb3A7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZGVmYXVsdEl0ZW1zUGVyUGFnZSkge1xuICAgIGlmICgkYXR0cnMuaXRlbXNQZXJQYWdlKSB7XG4gICAgICAkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5pdGVtc1BlclBhZ2UpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzZWxmLml0ZW1zUGVyUGFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gc2VsZi5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pdGVtc1BlclBhZ2UgPSBkZWZhdWx0SXRlbXNQZXJQYWdlO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLm5vUHJldmlvdXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlID09PSAxO1xuICB9O1xuICB0aGlzLm5vTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhZ2UgPT09ICRzY29wZS50b3RhbFBhZ2VzO1xuICB9O1xuXG4gIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbihwYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZSA9PT0gcGFnZTtcbiAgfTtcblxuICB0aGlzLmNhbGN1bGF0ZVRvdGFsUGFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG90YWxQYWdlcyA9IHRoaXMuaXRlbXNQZXJQYWdlIDwgMSA/IDEgOiBNYXRoLmNlaWwoJHNjb3BlLnRvdGFsSXRlbXMgLyB0aGlzLml0ZW1zUGVyUGFnZSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRvdGFsUGFnZXMgfHwgMCwgMSk7XG4gIH07XG5cbiAgdGhpcy5nZXRBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgZGVmYXVsdFZhbHVlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZChhdHRyaWJ1dGUpID8gKGludGVycG9sYXRlID8gJGludGVycG9sYXRlKGF0dHJpYnV0ZSkoJHNjb3BlLiRwYXJlbnQpIDogJHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cmlidXRlKSkgOiBkZWZhdWx0VmFsdWU7XG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBhZ2UgPSBwYXJzZUludCgkc2NvcGUucGFnZSwgMTApIHx8IDE7XG4gICAgaWYgKHRoaXMucGFnZSA+IDAgJiYgdGhpcy5wYWdlIDw9ICRzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICAkc2NvcGUucGFnZXMgPSB0aGlzLmdldFBhZ2VzKHRoaXMucGFnZSwgJHNjb3BlLnRvdGFsUGFnZXMpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuc2VsZWN0UGFnZSA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgICBpZiAoICEgc2VsZi5pc0FjdGl2ZShwYWdlKSAmJiBwYWdlID4gMCAmJiBwYWdlIDw9ICRzY29wZS50b3RhbFBhZ2VzKSB7XG4gICAgICAkc2NvcGUucGFnZSA9IHBhZ2U7XG4gICAgICAkc2NvcGUub25TZWxlY3RQYWdlKHsgcGFnZTogcGFnZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLiR3YXRjaCgncGFnZScsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYucmVuZGVyKCk7XG4gIH0pO1xuXG4gICRzY29wZS4kd2F0Y2goJ3RvdGFsSXRlbXMnLCBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG90YWxQYWdlcyA9IHNlbGYuY2FsY3VsYXRlVG90YWxQYWdlcygpO1xuICB9KTtcblxuICAkc2NvcGUuJHdhdGNoKCd0b3RhbFBhZ2VzJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICBzZXROdW1QYWdlcygkc2NvcGUuJHBhcmVudCwgdmFsdWUpOyAvLyBSZWFkb25seSB2YXJpYWJsZVxuXG4gICAgaWYgKCBzZWxmLnBhZ2UgPiB2YWx1ZSApIHtcbiAgICAgICRzY29wZS5zZWxlY3RQYWdlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICB9XG4gIH0pO1xufV0pXG5cbi5jb25zdGFudCgncGFnaW5hdGlvbkNvbmZpZycsIHtcbiAgaXRlbXNQZXJQYWdlOiAxMCxcbiAgYm91bmRhcnlMaW5rczogZmFsc2UsXG4gIGRpcmVjdGlvbkxpbmtzOiB0cnVlLFxuICBmaXJzdFRleHQ6ICdGaXJzdCcsXG4gIHByZXZpb3VzVGV4dDogJ1ByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0JyxcbiAgbGFzdFRleHQ6ICdMYXN0JyxcbiAgcm90YXRlOiB0cnVlXG59KVxuXG4uZGlyZWN0aXZlKCdwYWdpbmF0aW9uJywgWyckcGFyc2UnLCAncGFnaW5hdGlvbkNvbmZpZycsIGZ1bmN0aW9uKCRwYXJzZSwgY29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgc2NvcGU6IHtcbiAgICAgIHBhZ2U6ICc9JyxcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcbiAgICAgIG9uU2VsZWN0UGFnZTonICYnXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiAnUGFnaW5hdGlvbkNvbnRyb2xsZXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWwnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwYWdpbmF0aW9uQ3RybCkge1xuXG4gICAgICAvLyBTZXR1cCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgIHZhciBtYXhTaXplLFxuICAgICAgYm91bmRhcnlMaW5rcyAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5ib3VuZGFyeUxpbmtzLCAgY29uZmlnLmJvdW5kYXJ5TGlua3MgICAgICApLFxuICAgICAgZGlyZWN0aW9uTGlua3MgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5kaXJlY3Rpb25MaW5rcywgY29uZmlnLmRpcmVjdGlvbkxpbmtzICAgICApLFxuICAgICAgZmlyc3RUZXh0ICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5maXJzdFRleHQsICAgICAgY29uZmlnLmZpcnN0VGV4dCwgICAgIHRydWUpLFxuICAgICAgcHJldmlvdXNUZXh0ICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5wcmV2aW91c1RleHQsICAgY29uZmlnLnByZXZpb3VzVGV4dCwgIHRydWUpLFxuICAgICAgbmV4dFRleHQgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5uZXh0VGV4dCwgICAgICAgY29uZmlnLm5leHRUZXh0LCAgICAgIHRydWUpLFxuICAgICAgbGFzdFRleHQgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5sYXN0VGV4dCwgICAgICAgY29uZmlnLmxhc3RUZXh0LCAgICAgIHRydWUpLFxuICAgICAgcm90YXRlICAgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5yb3RhdGUsICAgICAgICAgY29uZmlnLnJvdGF0ZSk7XG5cbiAgICAgIHBhZ2luYXRpb25DdHJsLmluaXQoY29uZmlnLml0ZW1zUGVyUGFnZSk7XG5cbiAgICAgIGlmIChhdHRycy5tYXhTaXplKSB7XG4gICAgICAgIHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZShhdHRycy5tYXhTaXplKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBtYXhTaXplID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICBwYWdpbmF0aW9uQ3RybC5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBwYWdlIG9iamVjdCB1c2VkIGluIHRlbXBsYXRlXG4gICAgICBmdW5jdGlvbiBtYWtlUGFnZShudW1iZXIsIHRleHQsIGlzQWN0aXZlLCBpc0Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBhY3RpdmU6IGlzQWN0aXZlLFxuICAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHBhZ2luYXRpb25DdHJsLmdldFBhZ2VzID0gZnVuY3Rpb24oY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMpIHtcbiAgICAgICAgdmFyIHBhZ2VzID0gW107XG5cbiAgICAgICAgLy8gRGVmYXVsdCBwYWdlIGxpbWl0c1xuICAgICAgICB2YXIgc3RhcnRQYWdlID0gMSwgZW5kUGFnZSA9IHRvdGFsUGFnZXM7XG4gICAgICAgIHZhciBpc01heFNpemVkID0gKCBhbmd1bGFyLmlzRGVmaW5lZChtYXhTaXplKSAmJiBtYXhTaXplIDwgdG90YWxQYWdlcyApO1xuXG4gICAgICAgIC8vIHJlY29tcHV0ZSBpZiBtYXhTaXplXG4gICAgICAgIGlmICggaXNNYXhTaXplZCApIHtcbiAgICAgICAgICBpZiAoIHJvdGF0ZSApIHtcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSBNYXRoLm1heChjdXJyZW50UGFnZSAtIE1hdGguZmxvb3IobWF4U2l6ZS8yKSwgMSk7XG4gICAgICAgICAgICBlbmRQYWdlICAgPSBzdGFydFBhZ2UgKyBtYXhTaXplIC0gMTtcblxuICAgICAgICAgICAgLy8gQWRqdXN0IGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgICAgICBpZiAoZW5kUGFnZSA+IHRvdGFsUGFnZXMpIHtcbiAgICAgICAgICAgICAgZW5kUGFnZSAgID0gdG90YWxQYWdlcztcbiAgICAgICAgICAgICAgc3RhcnRQYWdlID0gZW5kUGFnZSAtIG1heFNpemUgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBWaXNpYmxlIHBhZ2VzIGFyZSBwYWdpbmF0ZWQgd2l0aCBtYXhTaXplXG4gICAgICAgICAgICBzdGFydFBhZ2UgPSAoKE1hdGguY2VpbChjdXJyZW50UGFnZSAvIG1heFNpemUpIC0gMSkgKiBtYXhTaXplKSArIDE7XG5cbiAgICAgICAgICAgIC8vIEFkanVzdCBsYXN0IHBhZ2UgaWYgbGltaXQgaXMgZXhjZWVkZWRcbiAgICAgICAgICAgIGVuZFBhZ2UgPSBNYXRoLm1pbihzdGFydFBhZ2UgKyBtYXhTaXplIC0gMSwgdG90YWxQYWdlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHBhZ2UgbnVtYmVyIGxpbmtzXG4gICAgICAgIGZvciAodmFyIG51bWJlciA9IHN0YXJ0UGFnZTsgbnVtYmVyIDw9IGVuZFBhZ2U7IG51bWJlcisrKSB7XG4gICAgICAgICAgdmFyIHBhZ2UgPSBtYWtlUGFnZShudW1iZXIsIG51bWJlciwgcGFnaW5hdGlvbkN0cmwuaXNBY3RpdmUobnVtYmVyKSwgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbGlua3MgdG8gbW92ZSBiZXR3ZWVuIHBhZ2Ugc2V0c1xuICAgICAgICBpZiAoIGlzTWF4U2l6ZWQgJiYgISByb3RhdGUgKSB7XG4gICAgICAgICAgaWYgKCBzdGFydFBhZ2UgPiAxICkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUGFnZVNldCA9IG1ha2VQYWdlKHN0YXJ0UGFnZSAtIDEsICcuLi4nLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMudW5zaGlmdChwcmV2aW91c1BhZ2VTZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggZW5kUGFnZSA8IHRvdGFsUGFnZXMgKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFBhZ2VTZXQgPSBtYWtlUGFnZShlbmRQYWdlICsgMSwgJy4uLicsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlU2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgcHJldmlvdXMgJiBuZXh0IGxpbmtzXG4gICAgICAgIGlmIChkaXJlY3Rpb25MaW5rcykge1xuICAgICAgICAgIHZhciBwcmV2aW91c1BhZ2UgPSBtYWtlUGFnZShjdXJyZW50UGFnZSAtIDEsIHByZXZpb3VzVGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vUHJldmlvdXMoKSk7XG4gICAgICAgICAgcGFnZXMudW5zaGlmdChwcmV2aW91c1BhZ2UpO1xuXG4gICAgICAgICAgdmFyIG5leHRQYWdlID0gbWFrZVBhZ2UoY3VycmVudFBhZ2UgKyAxLCBuZXh0VGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vTmV4dCgpKTtcbiAgICAgICAgICBwYWdlcy5wdXNoKG5leHRQYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBmaXJzdCAmIGxhc3QgbGlua3NcbiAgICAgICAgaWYgKGJvdW5kYXJ5TGlua3MpIHtcbiAgICAgICAgICB2YXIgZmlyc3RQYWdlID0gbWFrZVBhZ2UoMSwgZmlyc3RUZXh0LCBmYWxzZSwgcGFnaW5hdGlvbkN0cmwubm9QcmV2aW91cygpKTtcbiAgICAgICAgICBwYWdlcy51bnNoaWZ0KGZpcnN0UGFnZSk7XG5cbiAgICAgICAgICB2YXIgbGFzdFBhZ2UgPSBtYWtlUGFnZSh0b3RhbFBhZ2VzLCBsYXN0VGV4dCwgZmFsc2UsIHBhZ2luYXRpb25DdHJsLm5vTmV4dCgpKTtcbiAgICAgICAgICBwYWdlcy5wdXNoKGxhc3RQYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWdlcztcbiAgICAgIH07XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb25zdGFudCgncGFnZXJDb25maWcnLCB7XG4gIGl0ZW1zUGVyUGFnZTogMTAsXG4gIHByZXZpb3VzVGV4dDogJ8KrIFByZXZpb3VzJyxcbiAgbmV4dFRleHQ6ICdOZXh0IMK7JyxcbiAgYWxpZ246IHRydWVcbn0pXG5cbi5kaXJlY3RpdmUoJ3BhZ2VyJywgWydwYWdlckNvbmZpZycsIGZ1bmN0aW9uKGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIHNjb3BlOiB7XG4gICAgICBwYWdlOiAnPScsXG4gICAgICB0b3RhbEl0ZW1zOiAnPScsXG4gICAgICBvblNlbGVjdFBhZ2U6JyAmJ1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogJ1BhZ2luYXRpb25Db250cm9sbGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3BhZ2luYXRpb24vcGFnZXIuaHRtbCcsXG4gICAgcmVwbGFjZTogdHJ1ZSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIHBhZ2luYXRpb25DdHJsKSB7XG5cbiAgICAgIC8vIFNldHVwIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICAgICAgdmFyIHByZXZpb3VzVGV4dCA9IHBhZ2luYXRpb25DdHJsLmdldEF0dHJpYnV0ZVZhbHVlKGF0dHJzLnByZXZpb3VzVGV4dCwgY29uZmlnLnByZXZpb3VzVGV4dCwgdHJ1ZSksXG4gICAgICBuZXh0VGV4dCAgICAgICAgID0gcGFnaW5hdGlvbkN0cmwuZ2V0QXR0cmlidXRlVmFsdWUoYXR0cnMubmV4dFRleHQsICAgICBjb25maWcubmV4dFRleHQsICAgICB0cnVlKSxcbiAgICAgIGFsaWduICAgICAgICAgICAgPSBwYWdpbmF0aW9uQ3RybC5nZXRBdHRyaWJ1dGVWYWx1ZShhdHRycy5hbGlnbiwgICAgICAgIGNvbmZpZy5hbGlnbik7XG5cbiAgICAgIHBhZ2luYXRpb25DdHJsLmluaXQoY29uZmlnLml0ZW1zUGVyUGFnZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBwYWdlIG9iamVjdCB1c2VkIGluIHRlbXBsYXRlXG4gICAgICBmdW5jdGlvbiBtYWtlUGFnZShudW1iZXIsIHRleHQsIGlzRGlzYWJsZWQsIGlzUHJldmlvdXMsIGlzTmV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgcHJldmlvdXM6ICggYWxpZ24gJiYgaXNQcmV2aW91cyApLFxuICAgICAgICAgIG5leHQ6ICggYWxpZ24gJiYgaXNOZXh0IClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcGFnaW5hdGlvbkN0cmwuZ2V0UGFnZXMgPSBmdW5jdGlvbihjdXJyZW50UGFnZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIG1ha2VQYWdlKGN1cnJlbnRQYWdlIC0gMSwgcHJldmlvdXNUZXh0LCBwYWdpbmF0aW9uQ3RybC5ub1ByZXZpb3VzKCksIHRydWUsIGZhbHNlKSxcbiAgICAgICAgICBtYWtlUGFnZShjdXJyZW50UGFnZSArIDEsIG5leHRUZXh0LCBwYWdpbmF0aW9uQ3RybC5ub05leHQoKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIF07XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogYW5pbWF0aW9uIGFzIGFcbiAqIGZ1bmN0aW9uLCBwbGFjZW1lbnQgYXMgYSBmdW5jdGlvbiwgaW5zaWRlLCBzdXBwb3J0IGZvciBtb3JlIHRyaWdnZXJzIHRoYW5cbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGh0bWwgdG9vbHRpcHMsIGFuZCBzZWxlY3RvciBkZWxlZ2F0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSggJ3VpLmJvb3RzdHJhcC50b29sdGlwJywgWyAndWkuYm9vdHN0cmFwLnBvc2l0aW9uJywgJ3VpLmJvb3RzdHJhcC5iaW5kSHRtbCcgXSApXG5cbi8qKlxuICogVGhlICR0b29sdGlwIHNlcnZpY2UgY3JlYXRlcyB0b29sdGlwLSBhbmQgcG9wb3Zlci1saWtlIGRpcmVjdGl2ZXMgYXMgd2VsbCBhc1xuICogaG91c2VzIGdsb2JhbCBvcHRpb25zIGZvciB0aGVtLlxuICovXG4ucHJvdmlkZXIoICckdG9vbHRpcCcsIGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhlIGRlZmF1bHQgb3B0aW9ucyB0b29sdGlwIGFuZCBwb3BvdmVyLlxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgcG9wdXBEZWxheTogMFxuICB9O1xuXG4gIC8vIERlZmF1bHQgaGlkZSB0cmlnZ2VycyBmb3IgZWFjaCBzaG93IHRyaWdnZXJcbiAgdmFyIHRyaWdnZXJNYXAgPSB7XG4gICAgJ21vdXNlZW50ZXInOiAnbW91c2VsZWF2ZScsXG4gICAgJ2NsaWNrJzogJ2NsaWNrJyxcbiAgICAnZm9jdXMnOiAnYmx1cidcbiAgfTtcblxuICAvLyBUaGUgb3B0aW9ucyBzcGVjaWZpZWQgdG8gdGhlIHByb3ZpZGVyIGdsb2JhbGx5LlxuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IHt9O1xuICBcbiAgLyoqXG4gICAqIGBvcHRpb25zKHt9KWAgYWxsb3dzIGdsb2JhbCBjb25maWd1cmF0aW9uIG9mIGFsbCB0b29sdGlwcyBpbiB0aGVcbiAgICogYXBwbGljYXRpb24uXG4gICAqXG4gICAqICAgdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCAnQXBwJywgWyd1aS5ib290c3RyYXAudG9vbHRpcCddLCBmdW5jdGlvbiggJHRvb2x0aXBQcm92aWRlciApIHtcbiAgICogICAgIC8vIHBsYWNlIHRvb2x0aXBzIGxlZnQgaW5zdGVhZCBvZiB0b3AgYnkgZGVmYXVsdFxuICAgKiAgICAgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zKCB7IHBsYWNlbWVudDogJ2xlZnQnIH0gKTtcbiAgICogICB9KTtcbiAgICovXG5cdHRoaXMub3B0aW9ucyA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRhbmd1bGFyLmV4dGVuZCggZ2xvYmFsT3B0aW9ucywgdmFsdWUgKTtcblx0fTtcblxuICAvKipcbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIGV4dGVuZCB0aGUgc2V0IG9mIHRyaWdnZXIgbWFwcGluZ3MgYXZhaWxhYmxlLiBFLmcuOlxuICAgKlxuICAgKiAgICR0b29sdGlwUHJvdmlkZXIuc2V0VHJpZ2dlcnMoICdvcGVuVHJpZ2dlcic6ICdjbG9zZVRyaWdnZXInICk7XG4gICAqL1xuICB0aGlzLnNldFRyaWdnZXJzID0gZnVuY3Rpb24gc2V0VHJpZ2dlcnMgKCB0cmlnZ2VycyApIHtcbiAgICBhbmd1bGFyLmV4dGVuZCggdHJpZ2dlck1hcCwgdHJpZ2dlcnMgKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgdHJhbnNsYXRpbmcgY2FtZWwtY2FzZSB0byBzbmFrZS1jYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lKXtcbiAgICB2YXIgcmVnZXhwID0gL1tBLVpdL2c7XG4gICAgdmFyIHNlcGFyYXRvciA9ICctJztcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKHJlZ2V4cCwgZnVuY3Rpb24obGV0dGVyLCBwb3MpIHtcbiAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYWN0dWFsIGluc3RhbmNlIG9mIHRoZSAkdG9vbHRpcCBzZXJ2aWNlLlxuICAgKiBUT0RPIHN1cHBvcnQgbXVsdGlwbGUgdHJpZ2dlcnNcbiAgICovXG4gIHRoaXMuJGdldCA9IFsgJyR3aW5kb3cnLCAnJGNvbXBpbGUnLCAnJHRpbWVvdXQnLCAnJHBhcnNlJywgJyRkb2N1bWVudCcsICckcG9zaXRpb24nLCAnJGludGVycG9sYXRlJywgZnVuY3Rpb24gKCAkd2luZG93LCAkY29tcGlsZSwgJHRpbWVvdXQsICRwYXJzZSwgJGRvY3VtZW50LCAkcG9zaXRpb24sICRpbnRlcnBvbGF0ZSApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gJHRvb2x0aXAgKCB0eXBlLCBwcmVmaXgsIGRlZmF1bHRUcmlnZ2VyU2hvdyApIHtcbiAgICAgIHZhciBvcHRpb25zID0gYW5ndWxhci5leHRlbmQoIHt9LCBkZWZhdWx0T3B0aW9ucywgZ2xvYmFsT3B0aW9ucyApO1xuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHNob3cgYW5kIGhpZGUgdHJpZ2dlcnMuXG4gICAgICAgKlxuICAgICAgICogSWYgYSB0cmlnZ2VyIGlzIHN1cHBsaWVkLFxuICAgICAgICogaXQgaXMgdXNlZCB0byBzaG93IHRoZSB0b29sdGlwOyBvdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdHJpZ2dlcmBcbiAgICAgICAqIG9wdGlvbiBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZDsgZWxzZSBpdCB3aWxsXG4gICAgICAgKiBkZWZhdWx0IHRvIHRoZSB0cmlnZ2VyIHN1cHBsaWVkIHRvIHRoaXMgZGlyZWN0aXZlIGZhY3RvcnkuXG4gICAgICAgKlxuICAgICAgICogVGhlIGhpZGUgdHJpZ2dlciBpcyBiYXNlZCBvbiB0aGUgc2hvdyB0cmlnZ2VyLiBJZiB0aGUgYHRyaWdnZXJgIG9wdGlvblxuICAgICAgICogd2FzIHBhc3NlZCB0byB0aGUgYCR0b29sdGlwUHJvdmlkZXIub3B0aW9uc2AgbWV0aG9kLCBpdCB3aWxsIHVzZSB0aGVcbiAgICAgICAqIG1hcHBlZCB0cmlnZ2VyIGZyb20gYHRyaWdnZXJNYXBgIG9yIHRoZSBwYXNzZWQgdHJpZ2dlciBpZiB0aGUgbWFwIGlzXG4gICAgICAgKiB1bmRlZmluZWQ7IG90aGVyd2lzZSwgaXQgdXNlcyB0aGUgYHRyaWdnZXJNYXBgIHZhbHVlIG9mIHRoZSBzaG93XG4gICAgICAgKiB0cmlnZ2VyOyBlbHNlIGl0IHdpbGwganVzdCB1c2UgdGhlIHNob3cgdHJpZ2dlci5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0VHJpZ2dlcnMgKCB0cmlnZ2VyICkge1xuICAgICAgICB2YXIgc2hvdyA9IHRyaWdnZXIgfHwgb3B0aW9ucy50cmlnZ2VyIHx8IGRlZmF1bHRUcmlnZ2VyU2hvdztcbiAgICAgICAgdmFyIGhpZGUgPSB0cmlnZ2VyTWFwW3Nob3ddIHx8IHNob3c7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hvdzogc2hvdyxcbiAgICAgICAgICBoaWRlOiBoaWRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3RpdmVOYW1lID0gc25ha2VfY2FzZSggdHlwZSApO1xuXG4gICAgICB2YXIgc3RhcnRTeW0gPSAkaW50ZXJwb2xhdGUuc3RhcnRTeW1ib2woKTtcbiAgICAgIHZhciBlbmRTeW0gPSAkaW50ZXJwb2xhdGUuZW5kU3ltYm9sKCk7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBcbiAgICAgICAgJzwnKyBkaXJlY3RpdmVOYW1lICsnLXBvcHVwICcrXG4gICAgICAgICAgJ3RpdGxlPVwiJytzdGFydFN5bSsndHRfdGl0bGUnK2VuZFN5bSsnXCIgJytcbiAgICAgICAgICAnY29udGVudD1cIicrc3RhcnRTeW0rJ3R0X2NvbnRlbnQnK2VuZFN5bSsnXCIgJytcbiAgICAgICAgICAncGxhY2VtZW50PVwiJytzdGFydFN5bSsndHRfcGxhY2VtZW50JytlbmRTeW0rJ1wiICcrXG4gICAgICAgICAgJ2FuaW1hdGlvbj1cInR0X2FuaW1hdGlvblwiICcrXG4gICAgICAgICAgJ2lzLW9wZW49XCJ0dF9pc09wZW5cIicrXG4gICAgICAgICAgJz4nK1xuICAgICAgICAnPC8nKyBkaXJlY3RpdmVOYW1lICsnLXBvcHVwPic7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgICAgICBzY29wZTogdHJ1ZSxcbiAgICAgICAgbGluazogZnVuY3Rpb24gbGluayAoIHNjb3BlLCBlbGVtZW50LCBhdHRycyApIHtcbiAgICAgICAgICB2YXIgdG9vbHRpcCA9ICRjb21waWxlKCB0ZW1wbGF0ZSApKCBzY29wZSApO1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgICAgICB2YXIgcG9wdXBUaW1lb3V0O1xuICAgICAgICAgIHZhciAkYm9keSA9ICRkb2N1bWVudC5maW5kKCAnYm9keScgKTtcbiAgICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoIG9wdGlvbnMuYXBwZW5kVG9Cb2R5ICkgPyBvcHRpb25zLmFwcGVuZFRvQm9keSA6IGZhbHNlO1xuICAgICAgICAgIHZhciB0cmlnZ2VycyA9IGdldFRyaWdnZXJzKCB1bmRlZmluZWQgKTtcbiAgICAgICAgICB2YXIgaGFzUmVnaXN0ZXJlZFRyaWdnZXJzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGhhc0VuYWJsZUV4cCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCsnRW5hYmxlJ10pO1xuXG4gICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHRvb2x0aXAgaXMgbm90IG9wZW4uXG4gICAgICAgICAgLy8gVE9ETyBhZGQgYWJpbGl0eSB0byBzdGFydCB0b29sdGlwIG9wZW5lZFxuICAgICAgICAgIHNjb3BlLnR0X2lzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgZnVuY3Rpb24gdG9nZ2xlVG9vbHRpcEJpbmQgKCkge1xuICAgICAgICAgICAgaWYgKCAhIHNjb3BlLnR0X2lzT3BlbiApIHtcbiAgICAgICAgICAgICAgc2hvd1Rvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCB3aXRoIGRlbGF5IGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNob3cgaXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICBmdW5jdGlvbiBzaG93VG9vbHRpcEJpbmQoKSB7XG4gICAgICAgICAgICBpZihoYXNFbmFibGVFeHAgJiYgIXNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCsnRW5hYmxlJ10pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggc2NvcGUudHRfcG9wdXBEZWxheSApIHtcbiAgICAgICAgICAgICAgcG9wdXBUaW1lb3V0ID0gJHRpbWVvdXQoIHNob3csIHNjb3BlLnR0X3BvcHVwRGVsYXkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjb3BlLiRhcHBseSggc2hvdyApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwQmluZCAoKSB7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2hvdyB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxuICAgICAgICAgIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgdHRXaWR0aCxcbiAgICAgICAgICAgICAgICB0dEhlaWdodCxcbiAgICAgICAgICAgICAgICB0dFBvc2l0aW9uO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBzaG93IGVtcHR5IHRvb2x0aXBzLlxuICAgICAgICAgICAgaWYgKCAhIHNjb3BlLnR0X2NvbnRlbnQgKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwZW5kaW5nIHJlbW92ZSB0cmFuc2l0aW9uLCB3ZSBtdXN0IGNhbmNlbCBpdCwgbGVzdCB0aGVcbiAgICAgICAgICAgIC8vIHRvb2x0aXAgYmUgbXlzdGVyaW91c2x5IHJlbW92ZWQuXG4gICAgICAgICAgICBpZiAoIHRyYW5zaXRpb25UaW1lb3V0ICkge1xuICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoIHRyYW5zaXRpb25UaW1lb3V0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaW5pdGlhbCBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgIHRvb2x0aXAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBOb3cgd2UgYWRkIGl0IHRvIHRoZSBET00gYmVjYXVzZSBuZWVkIHNvbWUgaW5mbyBhYm91dCBpdC4gQnV0IGl0J3Mgbm90IFxuICAgICAgICAgICAgLy8gdmlzaWJsZSB5ZXQgYW55d2F5LlxuICAgICAgICAgICAgaWYgKCBhcHBlbmRUb0JvZHkgKSB7XG4gICAgICAgICAgICAgICAgJGJvZHkuYXBwZW5kKCB0b29sdGlwICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LmFmdGVyKCB0b29sdGlwICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGRpcmVjdGl2ZSBlbGVtZW50LlxuICAgICAgICAgICAgcG9zaXRpb24gPSBhcHBlbmRUb0JvZHkgPyAkcG9zaXRpb24ub2Zmc2V0KCBlbGVtZW50ICkgOiAkcG9zaXRpb24ucG9zaXRpb24oIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSB0b29sdGlwIHNvIHdlIGNhbiBjZW50ZXIgaXQuXG4gICAgICAgICAgICB0dFdpZHRoID0gdG9vbHRpcC5wcm9wKCAnb2Zmc2V0V2lkdGgnICk7XG4gICAgICAgICAgICB0dEhlaWdodCA9IHRvb2x0aXAucHJvcCggJ29mZnNldEhlaWdodCcgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b29sdGlwJ3MgdG9wIGFuZCBsZWZ0IGNvb3JkaW5hdGVzIHRvIGNlbnRlciBpdCB3aXRoXG4gICAgICAgICAgICAvLyB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgIHN3aXRjaCAoIHNjb3BlLnR0X3BsYWNlbWVudCApIHtcbiAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHR0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCAvIDIgLSB0dEhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgcG9zaXRpb24ud2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHR0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyBwb3NpdGlvbi53aWR0aCAvIDIgLSB0dFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHR0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCArIHBvc2l0aW9uLmhlaWdodCAvIDIgLSB0dEhlaWdodCAvIDIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0IC0gdHRXaWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdHRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gdHRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgcG9zaXRpb24ud2lkdGggLyAyIC0gdHRXaWR0aCAvIDJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0dFBvc2l0aW9uLnRvcCArPSAncHgnO1xuICAgICAgICAgICAgdHRQb3NpdGlvbi5sZWZ0ICs9ICdweCc7XG5cbiAgICAgICAgICAgIC8vIE5vdyBzZXQgdGhlIGNhbGN1bGF0ZWQgcG9zaXRpb25pbmcuXG4gICAgICAgICAgICB0b29sdGlwLmNzcyggdHRQb3NpdGlvbiApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFuZCBzaG93IHRoZSB0b29sdGlwLlxuICAgICAgICAgICAgc2NvcGUudHRfaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGlkZSB0aGUgdG9vbHRpcCBwb3B1cCBlbGVtZW50LlxuICAgICAgICAgIGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3Q6IHdlIGRvbid0IHNob3cgaXQgYW55bW9yZS5cbiAgICAgICAgICAgIHNjb3BlLnR0X2lzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvL2lmIHRvb2x0aXAgaXMgZ29pbmcgdG8gYmUgc2hvd24gYWZ0ZXIgZGVsYXksIHdlIG11c3QgY2FuY2VsIHRoaXNcbiAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCggcG9wdXBUaW1lb3V0ICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFuZCBub3cgd2UgcmVtb3ZlIGl0IGZyb20gdGhlIERPTS4gSG93ZXZlciwgaWYgd2UgaGF2ZSBhbmltYXRpb24sIHdlIFxuICAgICAgICAgICAgLy8gbmVlZCB0byB3YWl0IGZvciBpdCB0byBleHBpcmUgYmVmb3JlaGFuZC5cbiAgICAgICAgICAgIC8vIEZJWE1FOiB0aGlzIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgcG9ydCBvZiB0aGUgdHJhbnNpdGlvbnMgbGlicmFyeS5cbiAgICAgICAgICAgIGlmICggc2NvcGUudHRfYW5pbWF0aW9uICkge1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBPYnNlcnZlIHRoZSByZWxldmFudCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCB0eXBlLCBmdW5jdGlvbiAoIHZhbCApIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgc2NvcGUudHRfY29udGVudCA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICggc2NvcGUudHRfaXNPcGVuICkge1xuICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHByZWZpeCsnVGl0bGUnLCBmdW5jdGlvbiAoIHZhbCApIHtcbiAgICAgICAgICAgIHNjb3BlLnR0X3RpdGxlID0gdmFsO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYXR0cnMuJG9ic2VydmUoIHByZWZpeCsnUGxhY2VtZW50JywgZnVuY3Rpb24gKCB2YWwgKSB7XG4gICAgICAgICAgICBzY29wZS50dF9wbGFjZW1lbnQgPSBhbmd1bGFyLmlzRGVmaW5lZCggdmFsICkgPyB2YWwgOiBvcHRpb25zLnBsYWNlbWVudDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKHByZWZpeCArICdBbmltYXRpb24nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBzY29wZS50dF9hbmltYXRpb24gPSBhbmd1bGFyLmlzRGVmaW5lZCh2YWwpID8gISF2YWwgOiBvcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCBwcmVmaXgrJ1BvcHVwRGVsYXknLCBmdW5jdGlvbiAoIHZhbCApIHtcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHBhcnNlSW50KCB2YWwsIDEwICk7XG4gICAgICAgICAgICBzY29wZS50dF9wb3B1cERlbGF5ID0gISBpc05hTihkZWxheSkgPyBkZWxheSA6IG9wdGlvbnMucG9wdXBEZWxheTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCBwcmVmaXgrJ1RyaWdnZXInLCBmdW5jdGlvbiAoIHZhbCApIHtcblxuICAgICAgICAgICAgaWYgKGhhc1JlZ2lzdGVyZWRUcmlnZ2Vycykge1xuICAgICAgICAgICAgICBlbGVtZW50LnVuYmluZCggdHJpZ2dlcnMuc2hvdywgc2hvd1Rvb2x0aXBCaW5kICk7XG4gICAgICAgICAgICAgIGVsZW1lbnQudW5iaW5kKCB0cmlnZ2Vycy5oaWRlLCBoaWRlVG9vbHRpcEJpbmQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJpZ2dlcnMgPSBnZXRUcmlnZ2VycyggdmFsICk7XG5cbiAgICAgICAgICAgIGlmICggdHJpZ2dlcnMuc2hvdyA9PT0gdHJpZ2dlcnMuaGlkZSApIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKCB0cmlnZ2Vycy5zaG93LCB0b2dnbGVUb29sdGlwQmluZCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKCB0cmlnZ2Vycy5zaG93LCBzaG93VG9vbHRpcEJpbmQgKTtcbiAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKCB0cmlnZ2Vycy5oaWRlLCBoaWRlVG9vbHRpcEJpbmQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzUmVnaXN0ZXJlZFRyaWdnZXJzID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCBwcmVmaXgrJ0FwcGVuZFRvQm9keScsIGZ1bmN0aW9uICggdmFsICkge1xuICAgICAgICAgICAgYXBwZW5kVG9Cb2R5ID0gYW5ndWxhci5pc0RlZmluZWQoIHZhbCApID8gJHBhcnNlKCB2YWwgKSggc2NvcGUgKSA6IGFwcGVuZFRvQm9keTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGlmIGEgdG9vbHRpcCBpcyBhdHRhY2hlZCB0byA8Ym9keT4gd2UgbmVlZCB0byByZW1vdmUgaXQgb25cbiAgICAgICAgICAvLyBsb2NhdGlvbiBjaGFuZ2UgYXMgaXRzIHBhcmVudCBzY29wZSB3aWxsIHByb2JhYmx5IG5vdCBiZSBkZXN0cm95ZWRcbiAgICAgICAgICAvLyBieSB0aGUgY2hhbmdlLlxuICAgICAgICAgIGlmICggYXBwZW5kVG9Cb2R5ICkge1xuICAgICAgICAgICAgc2NvcGUuJG9uKCckbG9jYXRpb25DaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24gY2xvc2VUb29sdGlwT25Mb2NhdGlvbkNoYW5nZVN1Y2Nlc3MgKCkge1xuICAgICAgICAgICAgaWYgKCBzY29wZS50dF9pc09wZW4gKSB7XG4gICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyBkZXN0cm95ZWQgYW5kIHJlbW92ZWQuXG4gICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uIG9uRGVzdHJveVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoIHBvcHVwVGltZW91dCApO1xuICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRvb2x0aXAudW5iaW5kKCk7XG4gICAgICAgICAgICB0b29sdGlwID0gbnVsbDtcbiAgICAgICAgICAgICRib2R5ID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9XTtcbn0pXG5cbi5kaXJlY3RpdmUoICd0b29sdGlwUG9wdXAnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCAndG9vbHRpcCcsIFsgJyR0b29sdGlwJywgZnVuY3Rpb24gKCAkdG9vbHRpcCApIHtcbiAgcmV0dXJuICR0b29sdGlwKCAndG9vbHRpcCcsICd0b29sdGlwJywgJ21vdXNlZW50ZXInICk7XG59XSlcblxuLmRpcmVjdGl2ZSggJ3Rvb2x0aXBIdG1sVW5zYWZlUG9wdXAnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCAndG9vbHRpcEh0bWxVbnNhZmUnLCBbICckdG9vbHRpcCcsIGZ1bmN0aW9uICggJHRvb2x0aXAgKSB7XG4gIHJldHVybiAkdG9vbHRpcCggJ3Rvb2x0aXBIdG1sVW5zYWZlJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicgKTtcbn1dKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogcG9wdXAgZGVsYXksIGFuaW1hdGlvbiBhcyBhXG4gKiBmdW5jdGlvbiwgcGxhY2VtZW50IGFzIGEgZnVuY3Rpb24sIGluc2lkZSwgc3VwcG9ydCBmb3IgbW9yZSB0cmlnZ2VycyB0aGFuXG4gKiBqdXN0IG1vdXNlIGVudGVyL2xlYXZlLCBodG1sIHBvcG92ZXJzLCBhbmQgc2VsZWN0b3IgZGVsZWdhdGF0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSggJ3VpLmJvb3RzdHJhcC5wb3BvdmVyJywgWyAndWkuYm9vdHN0cmFwLnRvb2x0aXAnIF0gKVxuLmRpcmVjdGl2ZSggJ3BvcG92ZXJQb3B1cCcsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7IHRpdGxlOiAnQCcsIGNvbnRlbnQ6ICdAJywgcGxhY2VtZW50OiAnQCcsIGFuaW1hdGlvbjogJyYnLCBpc09wZW46ICcmJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWwnXG4gIH07XG59KVxuLmRpcmVjdGl2ZSggJ3BvcG92ZXInLCBbICckY29tcGlsZScsICckdGltZW91dCcsICckcGFyc2UnLCAnJHdpbmRvdycsICckdG9vbHRpcCcsIGZ1bmN0aW9uICggJGNvbXBpbGUsICR0aW1lb3V0LCAkcGFyc2UsICR3aW5kb3csICR0b29sdGlwICkge1xuICByZXR1cm4gJHRvb2x0aXAoICdwb3BvdmVyJywgJ3BvcG92ZXInLCAnY2xpY2snICk7XG59XSk7XG5cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wcm9ncmVzc2JhcicsIFsndWkuYm9vdHN0cmFwLnRyYW5zaXRpb24nXSlcblxuLmNvbnN0YW50KCdwcm9ncmVzc0NvbmZpZycsIHtcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgYXV0b1R5cGU6IGZhbHNlLFxuICBzdGFja2VkVHlwZXM6IFsnc3VjY2VzcycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZGFuZ2VyJ11cbn0pXG5cbi5jb250cm9sbGVyKCdQcm9ncmVzc0JhckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAncHJvZ3Jlc3NDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgcHJvZ3Jlc3NDb25maWcpIHtcblxuICAgIC8vIFdoZXRoZXIgYmFyIHRyYW5zaXRpb25zIHNob3VsZCBiZSBhbmltYXRlZFxuICAgIHZhciBhbmltYXRlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFuaW1hdGUpID8gJHNjb3BlLiRldmFsKCRhdHRycy5hbmltYXRlKSA6IHByb2dyZXNzQ29uZmlnLmFuaW1hdGU7XG4gICAgdmFyIGF1dG9UeXBlID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmF1dG9UeXBlKSA/ICRzY29wZS4kZXZhbCgkYXR0cnMuYXV0b1R5cGUpIDogcHJvZ3Jlc3NDb25maWcuYXV0b1R5cGU7XG4gICAgdmFyIHN0YWNrZWRUeXBlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGFja2VkVHlwZXMpID8gJHNjb3BlLiRldmFsKCdbJyArICRhdHRycy5zdGFja2VkVHlwZXMgKyAnXScpIDogcHJvZ3Jlc3NDb25maWcuc3RhY2tlZFR5cGVzO1xuXG4gICAgLy8gQ3JlYXRlIGJhciBvYmplY3RcbiAgICB0aGlzLm1ha2VCYXIgPSBmdW5jdGlvbihuZXdCYXIsIG9sZEJhciwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gKGFuZ3VsYXIuaXNPYmplY3QobmV3QmFyKSkgPyBuZXdCYXIudmFsdWUgOiAobmV3QmFyIHx8IDApO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSAgKGFuZ3VsYXIuaXNPYmplY3Qob2xkQmFyKSkgPyBvbGRCYXIudmFsdWUgOiAob2xkQmFyIHx8IDApO1xuICAgICAgICB2YXIgdHlwZSA9IChhbmd1bGFyLmlzT2JqZWN0KG5ld0JhcikgJiYgYW5ndWxhci5pc0RlZmluZWQobmV3QmFyLnR5cGUpKSA/IG5ld0Jhci50eXBlIDogKGF1dG9UeXBlKSA/IGdldFN0YWNrZWRUeXBlKGluZGV4IHx8IDApIDogbnVsbDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogb2xkVmFsdWUsXG4gICAgICAgICAgICB0bzogbmV3VmFsdWUsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgYW5pbWF0ZTogYW5pbWF0ZVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRTdGFja2VkVHlwZShpbmRleCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZFR5cGVzW2luZGV4XTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEJhciA9IGZ1bmN0aW9uKGJhcikge1xuICAgICAgICAkc2NvcGUuYmFycy5wdXNoKGJhcik7XG4gICAgICAgICRzY29wZS50b3RhbFBlcmNlbnQgKz0gYmFyLnRvO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyQmFycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuYmFycyA9IFtdO1xuICAgICAgICAkc2NvcGUudG90YWxQZXJjZW50ID0gMDtcbiAgICB9O1xuICAgIHRoaXMuY2xlYXJCYXJzKCk7XG59XSlcblxuLmRpcmVjdGl2ZSgncHJvZ3Jlc3MnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0VBJyxcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgY29udHJvbGxlcjogJ1Byb2dyZXNzQmFyQ29udHJvbGxlcicsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICB2YWx1ZTogJz1wZXJjZW50JyxcbiAgICAgICAgICAgIG9uRnVsbDogJyYnLFxuICAgICAgICAgICAgb25FbXB0eTogJyYnXG4gICAgICAgIH0sXG4gICAgICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbCcsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCd2YWx1ZScsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xlYXJCYXJzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0FycmF5KG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFja2VkIHByb2dyZXNzIGJhclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIG49bmV3VmFsdWUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFkZEJhcihjb250cm9sbGVyLm1ha2VCYXIobmV3VmFsdWVbaV0sIG9sZFZhbHVlW2ldLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgYmFyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWRkQmFyKGNvbnRyb2xsZXIubWFrZUJhcihuZXdWYWx1ZSwgb2xkVmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gVG90YWwgcGVyY2VudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgndG90YWxQZXJjZW50JywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID49IDEwMCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLm9uRnVsbCgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgICAgICAgICAgICBzY29wZS5vbkVtcHR5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3Byb2dyZXNzYmFyJywgWyckdHJhbnNpdGlvbicsIGZ1bmN0aW9uKCR0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICB3aWR0aDogJz0nLFxuICAgICAgICAgICAgb2xkOiAnPScsXG4gICAgICAgICAgICB0eXBlOiAnPScsXG4gICAgICAgICAgICBhbmltYXRlOiAnPSdcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbCcsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goJ3dpZHRoJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuYW5pbWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNzcygnd2lkdGgnLCBzY29wZS5vbGQgKyAnJScpO1xuICAgICAgICAgICAgICAgICAgICAkdHJhbnNpdGlvbihlbGVtZW50LCB7d2lkdGg6IHZhbHVlICsgJyUnfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoJ3dpZHRoJywgdmFsdWUgKyAnJScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1dKTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucmF0aW5nJywgW10pXG5cbi5jb25zdGFudCgncmF0aW5nQ29uZmlnJywge1xuICBtYXg6IDUsXG4gIHN0YXRlT246IG51bGwsXG4gIHN0YXRlT2ZmOiBudWxsXG59KVxuXG4uY29udHJvbGxlcignUmF0aW5nQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRhdHRycycsICckcGFyc2UnLCAncmF0aW5nQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRwYXJzZSwgcmF0aW5nQ29uZmlnKSB7XG5cbiAgdGhpcy5tYXhSYW5nZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tYXgpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLm1heCkgOiByYXRpbmdDb25maWcubWF4O1xuICB0aGlzLnN0YXRlT24gPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc3RhdGVPbikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPbikgOiByYXRpbmdDb25maWcuc3RhdGVPbjtcbiAgdGhpcy5zdGF0ZU9mZiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9mZikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPZmYpIDogcmF0aW5nQ29uZmlnLnN0YXRlT2ZmO1xuXG4gIHRoaXMuY3JlYXRlUmF0ZU9iamVjdHMgPSBmdW5jdGlvbihzdGF0ZXMpIHtcbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBzdGF0ZU9uOiB0aGlzLnN0YXRlT24sXG4gICAgICBzdGF0ZU9mZjogdGhpcy5zdGF0ZU9mZlxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHN0YXRlc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHsgaW5kZXg6IGkgfSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH07XG5cbiAgLy8gR2V0IG9iamVjdHMgdXNlZCBpbiB0ZW1wbGF0ZVxuICAkc2NvcGUucmFuZ2UgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucmF0aW5nU3RhdGVzKSA/ICB0aGlzLmNyZWF0ZVJhdGVPYmplY3RzKGFuZ3VsYXIuY29weSgkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucmF0aW5nU3RhdGVzKSkpOiB0aGlzLmNyZWF0ZVJhdGVPYmplY3RzKG5ldyBBcnJheSh0aGlzLm1heFJhbmdlKSk7XG5cbiAgJHNjb3BlLnJhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICggJHNjb3BlLnJlYWRvbmx5IHx8ICRzY29wZS52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkc2NvcGUudmFsdWUgPSB2YWx1ZTtcbiAgfTtcblxuICAkc2NvcGUuZW50ZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICggISAkc2NvcGUucmVhZG9ubHkgKSB7XG4gICAgICAkc2NvcGUudmFsID0gdmFsdWU7XG4gICAgfVxuICAgICRzY29wZS5vbkhvdmVyKHt2YWx1ZTogdmFsdWV9KTtcbiAgfTtcblxuICAkc2NvcGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudmFsID0gYW5ndWxhci5jb3B5KCRzY29wZS52YWx1ZSk7XG4gICAgJHNjb3BlLm9uTGVhdmUoKTtcbiAgfTtcblxuICAkc2NvcGUuJHdhdGNoKCd2YWx1ZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgJHNjb3BlLnZhbCA9IHZhbHVlO1xuICB9KTtcblxuICAkc2NvcGUucmVhZG9ubHkgPSBmYWxzZTtcbiAgaWYgKCRhdHRycy5yZWFkb25seSkge1xuICAgICRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLnJlYWRvbmx5KSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICRzY29wZS5yZWFkb25seSA9ICEhdmFsdWU7XG4gICAgfSk7XG4gIH1cbn1dKVxuXG4uZGlyZWN0aXZlKCdyYXRpbmcnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIG9uSG92ZXI6ICcmJyxcbiAgICAgIG9uTGVhdmU6ICcmJ1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogJ1JhdGluZ0NvbnRyb2xsZXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sJyxcbiAgICByZXBsYWNlOiB0cnVlXG4gIH07XG59KTtcblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIHVpLmJvb3RzdHJhcC50YWJzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbmd1bGFySlMgdmVyc2lvbiBvZiB0aGUgdGFicyBkaXJlY3RpdmUuXG4gKi9cblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50YWJzJywgW10pXG5cbi5kaXJlY3RpdmUoJ3RhYnMnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdGFic2AgZGlyZWN0aXZlIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBtaWdyYXRlIHRvIGB0YWJzZXRgLiBJbnN0cnVjdGlvbnMgY2FuIGJlIGZvdW5kIGF0IGh0dHA6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvYm9vdHN0cmFwL3RyZWUvbWFzdGVyL0NIQU5HRUxPRy5tZFwiKTtcbiAgfTtcbn0pXG5cbi5jb250cm9sbGVyKCdUYWJzZXRDb250cm9sbGVyJywgWyckc2NvcGUnLCBmdW5jdGlvbiBUYWJzZXRDdHJsKCRzY29wZSkge1xuICB2YXIgY3RybCA9IHRoaXMsXG4gICAgICB0YWJzID0gY3RybC50YWJzID0gJHNjb3BlLnRhYnMgPSBbXTtcblxuICBjdHJsLnNlbGVjdCA9IGZ1bmN0aW9uKHRhYikge1xuICAgIGFuZ3VsYXIuZm9yRWFjaCh0YWJzLCBmdW5jdGlvbih0YWIpIHtcbiAgICAgIHRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB0YWIuYWN0aXZlID0gdHJ1ZTtcbiAgfTtcblxuICBjdHJsLmFkZFRhYiA9IGZ1bmN0aW9uIGFkZFRhYih0YWIpIHtcbiAgICB0YWJzLnB1c2godGFiKTtcbiAgICBpZiAodGFicy5sZW5ndGggPT09IDEgfHwgdGFiLmFjdGl2ZSkge1xuICAgICAgY3RybC5zZWxlY3QodGFiKTtcbiAgICB9XG4gIH07XG5cbiAgY3RybC5yZW1vdmVUYWIgPSBmdW5jdGlvbiByZW1vdmVUYWIodGFiKSB7XG4gICAgdmFyIGluZGV4ID0gdGFicy5pbmRleE9mKHRhYik7XG4gICAgLy9TZWxlY3QgYSBuZXcgdGFiIGlmIHRoZSB0YWIgdG8gYmUgcmVtb3ZlZCBpcyBzZWxlY3RlZFxuICAgIGlmICh0YWIuYWN0aXZlICYmIHRhYnMubGVuZ3RoID4gMSkge1xuICAgICAgLy9JZiB0aGlzIGlzIHRoZSBsYXN0IHRhYiwgc2VsZWN0IHRoZSBwcmV2aW91cyB0YWIuIGVsc2UsIHRoZSBuZXh0IHRhYi5cbiAgICAgIHZhciBuZXdBY3RpdmVJbmRleCA9IGluZGV4ID09IHRhYnMubGVuZ3RoIC0gMSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICAgIGN0cmwuc2VsZWN0KHRhYnNbbmV3QWN0aXZlSW5kZXhdKTtcbiAgICB9XG4gICAgdGFicy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9O1xufV0pXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYnNldFxuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUYWJzZXQgaXMgdGhlIG91dGVyIGNvbnRhaW5lciBmb3IgdGhlIHRhYnMgZGlyZWN0aXZlXG4gKlxuICogQHBhcmFtIHtib29sZWFuPX0gdmVydGljYWwgV2hldGhlciBvciBub3QgdG8gdXNlIHZlcnRpY2FsIHN0eWxpbmcgZm9yIHRoZSB0YWJzLlxuICogQHBhcmFtIHtzdHJpbmc9fSBkaXJlY3Rpb24gIFdoYXQgZGlyZWN0aW9uIHRoZSB0YWJzIHNob3VsZCBiZSByZW5kZXJlZC4gQXZhaWxhYmxlOlxuICogJ3JpZ2h0JywgJ2xlZnQnLCAnYmVsb3cnLlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8dGFic2V0PlxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDFcIj48Yj5GaXJzdDwvYj4gQ29udGVudCE8L3RhYj5cbiAgICAgIDx0YWIgaGVhZGluZz1cIlZlcnRpY2FsIFRhYiAyXCI+PGk+U2Vjb25kPC9pPiBDb250ZW50ITwvdGFiPlxuICAgIDwvdGFic2V0PlxuICAgIDxociAvPlxuICAgIDx0YWJzZXQgdmVydGljYWw9XCJ0cnVlXCI+XG4gICAgICA8dGFiIGhlYWRpbmc9XCJWZXJ0aWNhbCBUYWIgMVwiPjxiPkZpcnN0PC9iPiBWZXJ0aWNhbCBDb250ZW50ITwvdGFiPlxuICAgICAgPHRhYiBoZWFkaW5nPVwiVmVydGljYWwgVGFiIDJcIj48aT5TZWNvbmQ8L2k+IFZlcnRpY2FsIENvbnRlbnQhPC90YWI+XG4gICAgPC90YWJzZXQ+XG4gIDwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqL1xuLmRpcmVjdGl2ZSgndGFic2V0JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHJlcXVpcmU6ICdedGFic2V0JyxcbiAgICBzY29wZToge30sXG4gICAgY29udHJvbGxlcjogJ1RhYnNldENvbnRyb2xsZXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbCcsXG4gICAgY29tcGlsZTogZnVuY3Rpb24oZWxtLCBhdHRycywgdHJhbnNjbHVkZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdGFic2V0Q3RybCkge1xuICAgICAgICBzY29wZS52ZXJ0aWNhbCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnZlcnRpY2FsKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMudmVydGljYWwpIDogZmFsc2U7XG4gICAgICAgIHNjb3BlLnR5cGUgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRycy50eXBlKSA/IHNjb3BlLiRwYXJlbnQuJGV2YWwoYXR0cnMudHlwZSkgOiAndGFicyc7XG4gICAgICAgIHNjb3BlLmRpcmVjdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmRpcmVjdGlvbikgPyBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmRpcmVjdGlvbikgOiAndG9wJztcbiAgICAgICAgc2NvcGUudGFic0Fib3ZlID0gKHNjb3BlLmRpcmVjdGlvbiAhPSAnYmVsb3cnKTtcbiAgICAgICAgdGFic2V0Q3RybC4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGFic2V0Q3RybC4kdHJhbnNjbHVkZUZuID0gdHJhbnNjbHVkZTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufSlcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSB1aS5ib290c3RyYXAudGFicy5kaXJlY3RpdmU6dGFiXG4gKiBAcmVzdHJpY3QgRUFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IGhlYWRpbmcgVGhlIHZpc2libGUgaGVhZGluZywgb3IgdGl0bGUsIG9mIHRoZSB0YWIuIFNldCBIVE1MIGhlYWRpbmdzIHdpdGgge0BsaW5rIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJIZWFkaW5nIHRhYkhlYWRpbmd9LlxuICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3QgQW4gZXhwcmVzc2lvbiB0byBldmFsdWF0ZSB3aGVuIHRoZSB0YWIgaXMgc2VsZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBhY3RpdmUgQSBiaW5kaW5nLCB0ZWxsaW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGFiIGlzIHNlbGVjdGVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gZGlzYWJsZWQgQSBiaW5kaW5nLCB0ZWxsaW5nIHdoZXRoZXIgb3Igbm90IHRoaXMgdGFiIGlzIGRpc2FibGVkLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIHRhYiB3aXRoIGEgaGVhZGluZyBhbmQgY29udGVudC4gTXVzdCBiZSBwbGFjZWQgd2l0aGluIGEge0BsaW5rIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWJzZXQgdGFic2V0fS5cbiAqXG4gKiBAZXhhbXBsZVxuPGV4YW1wbGUgbW9kdWxlPVwidWkuYm9vdHN0cmFwXCI+XG4gIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgPGRpdiBuZy1jb250cm9sbGVyPVwiVGFic0RlbW9DdHJsXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbFwiIG5nLWNsaWNrPVwiaXRlbXNbMF0uYWN0aXZlID0gdHJ1ZVwiPlxuICAgICAgICBTZWxlY3QgaXRlbSAxLCB1c2luZyBhY3RpdmUgYmluZGluZ1xuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbWFsbFwiIG5nLWNsaWNrPVwiaXRlbXNbMV0uZGlzYWJsZWQgPSAhaXRlbXNbMV0uZGlzYWJsZWRcIj5cbiAgICAgICAgRW5hYmxlL2Rpc2FibGUgaXRlbSAyLCB1c2luZyBkaXNhYmxlZCBiaW5kaW5nXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxiciAvPlxuICAgICAgPHRhYnNldD5cbiAgICAgICAgPHRhYiBoZWFkaW5nPVwiVGFiIDFcIj5GaXJzdCBUYWI8L3RhYj5cbiAgICAgICAgPHRhYiBzZWxlY3Q9XCJhbGVydE1lKClcIj5cbiAgICAgICAgICA8dGFiLWhlYWRpbmc+PGkgY2xhc3M9XCJpY29uLWJlbGxcIj48L2k+IEFsZXJ0IG1lITwvdGFiLWhlYWRpbmc+XG4gICAgICAgICAgU2Vjb25kIFRhYiwgd2l0aCBhbGVydCBjYWxsYmFjayBhbmQgaHRtbCBoZWFkaW5nIVxuICAgICAgICA8L3RhYj5cbiAgICAgICAgPHRhYiBuZy1yZXBlYXQ9XCJpdGVtIGluIGl0ZW1zXCJcbiAgICAgICAgICBoZWFkaW5nPVwie3tpdGVtLnRpdGxlfX1cIlxuICAgICAgICAgIGRpc2FibGVkPVwiaXRlbS5kaXNhYmxlZFwiXG4gICAgICAgICAgYWN0aXZlPVwiaXRlbS5hY3RpdmVcIj5cbiAgICAgICAgICB7e2l0ZW0uY29udGVudH19XG4gICAgICAgIDwvdGFiPlxuICAgICAgPC90YWJzZXQ+XG4gICAgPC9kaXY+XG4gIDwvZmlsZT5cbiAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICAgIGZ1bmN0aW9uIFRhYnNEZW1vQ3RybCgkc2NvcGUpIHtcbiAgICAgICRzY29wZS5pdGVtcyA9IFtcbiAgICAgICAgeyB0aXRsZTpcIkR5bmFtaWMgVGl0bGUgMVwiLCBjb250ZW50OlwiRHluYW1pYyBJdGVtIDBcIiB9LFxuICAgICAgICB7IHRpdGxlOlwiRHluYW1pYyBUaXRsZSAyXCIsIGNvbnRlbnQ6XCJEeW5hbWljIEl0ZW0gMVwiLCBkaXNhYmxlZDogdHJ1ZSB9XG4gICAgICBdO1xuXG4gICAgICAkc2NvcGUuYWxlcnRNZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFsZXJ0KFwiWW91J3ZlIHNlbGVjdGVkIHRoZSBhbGVydCB0YWIhXCIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfTtcbiAgPC9maWxlPlxuPC9leGFtcGxlPlxuICovXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgdWkuYm9vdHN0cmFwLnRhYnMuZGlyZWN0aXZlOnRhYkhlYWRpbmdcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhbiBIVE1MIGhlYWRpbmcgZm9yIGEge0BsaW5rIHVpLmJvb3RzdHJhcC50YWJzLmRpcmVjdGl2ZTp0YWIgdGFifS4gTXVzdCBiZSBwbGFjZWQgYXMgYSBjaGlsZCBvZiBhIHRhYiBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG48ZXhhbXBsZSBtb2R1bGU9XCJ1aS5ib290c3RyYXBcIj5cbiAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICA8dGFic2V0PlxuICAgICAgPHRhYj5cbiAgICAgICAgPHRhYi1oZWFkaW5nPjxiPkhUTUw8L2I+IGluIG15IHRpdGxlcz8hPC90YWItaGVhZGluZz5cbiAgICAgICAgQW5kIHNvbWUgY29udGVudCwgdG9vIVxuICAgICAgPC90YWI+XG4gICAgICA8dGFiPlxuICAgICAgICA8dGFiLWhlYWRpbmc+PGkgY2xhc3M9XCJpY29uLWhlYXJ0XCI+PC9pPiBJY29uIGhlYWRpbmc/IT88L3RhYi1oZWFkaW5nPlxuICAgICAgICBUaGF0J3MgcmlnaHQuXG4gICAgICA8L3RhYj5cbiAgICA8L3RhYnNldD5cbiAgPC9maWxlPlxuPC9leGFtcGxlPlxuICovXG4uZGlyZWN0aXZlKCd0YWInLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdedGFic2V0JyxcbiAgICByZXN0cmljdDogJ0VBJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdGFicy90YWIuaHRtbCcsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBzY29wZToge1xuICAgICAgaGVhZGluZzogJ0AnLFxuICAgICAgb25TZWxlY3Q6ICcmc2VsZWN0JywgLy9UaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCBpbiBjb250ZW50SGVhZGluZ1RyYW5zY2x1ZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmNlIGl0IGluc2VydHMgdGhlIHRhYidzIGNvbnRlbnQgaW50byB0aGUgZG9tXG4gICAgICBvbkRlc2VsZWN0OiAnJmRlc2VsZWN0J1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAvL0VtcHR5IGNvbnRyb2xsZXIgc28gb3RoZXIgZGlyZWN0aXZlcyBjYW4gcmVxdWlyZSBiZWluZyAndW5kZXInIGEgdGFiXG4gICAgfSxcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbG0sIGF0dHJzLCB0cmFuc2NsdWRlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcG9zdExpbmsoc2NvcGUsIGVsbSwgYXR0cnMsIHRhYnNldEN0cmwpIHtcbiAgICAgICAgdmFyIGdldEFjdGl2ZSwgc2V0QWN0aXZlO1xuICAgICAgICBpZiAoYXR0cnMuYWN0aXZlKSB7XG4gICAgICAgICAgZ2V0QWN0aXZlID0gJHBhcnNlKGF0dHJzLmFjdGl2ZSk7XG4gICAgICAgICAgc2V0QWN0aXZlID0gZ2V0QWN0aXZlLmFzc2lnbjtcbiAgICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaChnZXRBY3RpdmUsIGZ1bmN0aW9uIHVwZGF0ZUFjdGl2ZSh2YWx1ZSwgb2xkVmFsKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCByZS1pbml0aWFsaXppbmcgc2NvcGUuYWN0aXZlIGFzIGl0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIC8vIGJlbG93LiAod2F0Y2hlciBpcyBjYWxsZWQgYXN5bmMgZHVyaW5nIGluaXQgd2l0aCB2YWx1ZSA9PT1cbiAgICAgICAgICAgIC8vIG9sZFZhbClcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsKSB7XG4gICAgICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9ICEhdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2NvcGUuYWN0aXZlID0gZ2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEFjdGl2ZSA9IGdldEFjdGl2ZSA9IGFuZ3VsYXIubm9vcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgICAgLy8gTm90ZSB0aGlzIHdhdGNoZXIgYWxzbyBpbml0aWFsaXplcyBhbmQgYXNzaWducyBzY29wZS5hY3RpdmUgdG8gdGhlXG4gICAgICAgICAgLy8gYXR0cnMuYWN0aXZlIGV4cHJlc3Npb24uXG4gICAgICAgICAgc2V0QWN0aXZlKHNjb3BlLiRwYXJlbnQsIGFjdGl2ZSk7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgdGFic2V0Q3RybC5zZWxlY3Qoc2NvcGUpO1xuICAgICAgICAgICAgc2NvcGUub25TZWxlY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NvcGUub25EZXNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCBhdHRycy5kaXNhYmxlZCApIHtcbiAgICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuZGlzYWJsZWQpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgc2NvcGUuZGlzYWJsZWQgPSAhISB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggISBzY29wZS5kaXNhYmxlZCApIHtcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRhYnNldEN0cmwuYWRkVGFiKHNjb3BlKTtcbiAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRhYnNldEN0cmwucmVtb3ZlVGFiKHNjb3BlKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvL1dlIG5lZWQgdG8gdHJhbnNjbHVkZSBsYXRlciwgb25jZSB0aGUgY29udGVudCBjb250YWluZXIgaXMgcmVhZHkuXG4gICAgICAgIC8vd2hlbiB0aGlzIGxpbmsgaGFwcGVucywgd2UncmUgaW5zaWRlIGEgdGFiIGhlYWRpbmcuXG4gICAgICAgIHNjb3BlLiR0cmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBbZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICByZXF1aXJlOiAnXnRhYicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYkN0cmwpIHtcbiAgICAgIHNjb3BlLiR3YXRjaCgnaGVhZGluZ0VsZW1lbnQnLCBmdW5jdGlvbiB1cGRhdGVIZWFkaW5nRWxlbWVudChoZWFkaW5nKSB7XG4gICAgICAgIGlmIChoZWFkaW5nKSB7XG4gICAgICAgICAgZWxtLmh0bWwoJycpO1xuICAgICAgICAgIGVsbS5hcHBlbmQoaGVhZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd0YWJDb250ZW50VHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogJ150YWJzZXQnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzKSB7XG4gICAgICB2YXIgdGFiID0gc2NvcGUuJGV2YWwoYXR0cnMudGFiQ29udGVudFRyYW5zY2x1ZGUpO1xuXG4gICAgICAvL05vdyBvdXIgdGFiIGlzIHJlYWR5IHRvIGJlIHRyYW5zY2x1ZGVkOiBib3RoIHRoZSB0YWIgaGVhZGluZyBhcmVhXG4gICAgICAvL2FuZCB0aGUgdGFiIGNvbnRlbnQgYXJlYSBhcmUgbG9hZGVkLiAgVHJhbnNjbHVkZSAnZW0gYm90aC5cbiAgICAgIHRhYi4kdHJhbnNjbHVkZUZuKHRhYi4kcGFyZW50LCBmdW5jdGlvbihjb250ZW50cykge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29udGVudHMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoaXNUYWJIZWFkaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvL0xldCB0YWJIZWFkaW5nVHJhbnNjbHVkZSBrbm93LlxuICAgICAgICAgICAgdGFiLmhlYWRpbmdFbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxtLmFwcGVuZChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBpc1RhYkhlYWRpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRhZ05hbWUgJiYgIChcbiAgICAgIG5vZGUuaGFzQXR0cmlidXRlKCd0YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS10YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYi1oZWFkaW5nJyB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRhLXRhYi1oZWFkaW5nJ1xuICAgICk7XG4gIH1cbn0pXG5cbi5kaXJlY3RpdmUoJ3RhYnNldFRpdGxlcycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogJ150YWJzZXQnLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGUvdGFicy90YWJzZXQtdGl0bGVzLmh0bWwnLFxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYnNldEN0cmwpIHtcbiAgICAgIGlmICghc2NvcGUuJGV2YWwoYXR0cnMudGFic2V0VGl0bGVzKSkge1xuICAgICAgICBlbG0ucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vdyB0aGF0IHRhYnMgbG9jYXRpb24gaGFzIGJlZW4gZGVjaWRlZCwgdHJhbnNjbHVkZSB0aGUgdGFiIHRpdGxlcyBpblxuICAgICAgICB0YWJzZXRDdHJsLiR0cmFuc2NsdWRlRm4odGFic2V0Q3RybC4kc2NvcGUuJHBhcmVudCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGVsbS5hcHBlbmQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRpbWVwaWNrZXInLCBbXSlcblxuLmNvbnN0YW50KCd0aW1lcGlja2VyQ29uZmlnJywge1xuICBob3VyU3RlcDogMSxcbiAgbWludXRlU3RlcDogMSxcbiAgc2hvd01lcmlkaWFuOiB0cnVlLFxuICBtZXJpZGlhbnM6IFsnQU0nLCAnUE0nXSxcbiAgcmVhZG9ubHlJbnB1dDogZmFsc2UsXG4gIG1vdXNld2hlZWw6IHRydWVcbn0pXG5cbi5kaXJlY3RpdmUoJ3RpbWVwaWNrZXInLCBbJyRwYXJzZScsICckbG9nJywgJ3RpbWVwaWNrZXJDb25maWcnLCBmdW5jdGlvbiAoJHBhcnNlLCAkbG9nLCB0aW1lcGlja2VyQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVxdWlyZTonP15uZ01vZGVsJyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7fSxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgICAgIGlmICggIW5nTW9kZWwgKSB7XG4gICAgICAgIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0ZWQgPSBuZXcgRGF0ZSgpLCBtZXJpZGlhbnMgPSB0aW1lcGlja2VyQ29uZmlnLm1lcmlkaWFucztcblxuICAgICAgdmFyIGhvdXJTdGVwID0gdGltZXBpY2tlckNvbmZpZy5ob3VyU3RlcDtcbiAgICAgIGlmIChhdHRycy5ob3VyU3RlcCkge1xuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuaG91clN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGhvdXJTdGVwID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW51dGVTdGVwID0gdGltZXBpY2tlckNvbmZpZy5taW51dGVTdGVwO1xuICAgICAgaWYgKGF0dHJzLm1pbnV0ZVN0ZXApIHtcbiAgICAgICAgc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKGF0dHJzLm1pbnV0ZVN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIG1pbnV0ZVN0ZXAgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gMTJIIC8gMjRIIG1vZGVcbiAgICAgIHNjb3BlLnNob3dNZXJpZGlhbiA9IHRpbWVwaWNrZXJDb25maWcuc2hvd01lcmlkaWFuO1xuICAgICAgaWYgKGF0dHJzLnNob3dNZXJpZGlhbikge1xuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuc2hvd01lcmlkaWFuKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBzY29wZS5zaG93TWVyaWRpYW4gPSAhIXZhbHVlO1xuXG4gICAgICAgICAgaWYgKCBuZ01vZGVsLiRlcnJvci50aW1lICkge1xuICAgICAgICAgICAgLy8gRXZhbHVhdGUgZnJvbSB0ZW1wbGF0ZVxuICAgICAgICAgICAgdmFyIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKSwgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCggaG91cnMgKSAmJiBhbmd1bGFyLmlzRGVmaW5lZCggbWludXRlcyApKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKCBob3VycyApO1xuICAgICAgICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVRlbXBsYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHNjb3BlLmhvdXJzIGluIDI0SCBtb2RlIGlmIHZhbGlkXG4gICAgICBmdW5jdGlvbiBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSAoICkge1xuICAgICAgICB2YXIgaG91cnMgPSBwYXJzZUludCggc2NvcGUuaG91cnMsIDEwICk7XG4gICAgICAgIHZhciB2YWxpZCA9ICggc2NvcGUuc2hvd01lcmlkaWFuICkgPyAoaG91cnMgPiAwICYmIGhvdXJzIDwgMTMpIDogKGhvdXJzID49IDAgJiYgaG91cnMgPCAyNCk7XG4gICAgICAgIGlmICggIXZhbGlkICkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHNjb3BlLnNob3dNZXJpZGlhbiApIHtcbiAgICAgICAgICBpZiAoIGhvdXJzID09PSAxMiApIHtcbiAgICAgICAgICAgIGhvdXJzID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzFdICkge1xuICAgICAgICAgICAgaG91cnMgPSBob3VycyArIDEyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cnM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKSB7XG4gICAgICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQoc2NvcGUubWludXRlcywgMTApO1xuICAgICAgICByZXR1cm4gKCBtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwICkgPyBtaW51dGVzIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYWQoIHZhbHVlICkge1xuICAgICAgICByZXR1cm4gKCBhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPCAyICkgPyAnMCcgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnB1dCBlbGVtZW50c1xuICAgICAgdmFyIGlucHV0cyA9IGVsZW1lbnQuZmluZCgnaW5wdXQnKSwgaG91cnNJbnB1dEVsID0gaW5wdXRzLmVxKDApLCBtaW51dGVzSW5wdXRFbCA9IGlucHV0cy5lcSgxKTtcblxuICAgICAgLy8gUmVzcG9uZCBvbiBtb3VzZXdoZWVsIHNwaW5cbiAgICAgIHZhciBtb3VzZXdoZWVsID0gKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLm1vdXNld2hlZWwpKSA/IHNjb3BlLiRldmFsKGF0dHJzLm1vdXNld2hlZWwpIDogdGltZXBpY2tlckNvbmZpZy5tb3VzZXdoZWVsO1xuICAgICAgaWYgKCBtb3VzZXdoZWVsICkge1xuXG4gICAgICAgIHZhciBpc1Njcm9sbGluZ1VwID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vcGljayBjb3JyZWN0IGRlbHRhIHZhcmlhYmxlIGRlcGVuZGluZyBvbiBldmVudFxuICAgICAgICAgIHZhciBkZWx0YSA9IChlLndoZWVsRGVsdGEpID8gZS53aGVlbERlbHRhIDogLWUuZGVsdGFZO1xuICAgICAgICAgIHJldHVybiAoZS5kZXRhaWwgfHwgZGVsdGEgPiAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBob3Vyc0lucHV0RWwuYmluZCgnbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoIChpc1Njcm9sbGluZ1VwKGUpKSA/IHNjb3BlLmluY3JlbWVudEhvdXJzKCkgOiBzY29wZS5kZWNyZW1lbnRIb3VycygpICk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBtaW51dGVzSW5wdXRFbC5iaW5kKCdtb3VzZXdoZWVsIHdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseSggKGlzU2Nyb2xsaW5nVXAoZSkpID8gc2NvcGUuaW5jcmVtZW50TWludXRlcygpIDogc2NvcGUuZGVjcmVtZW50TWludXRlcygpICk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUucmVhZG9ubHlJbnB1dCA9IChhbmd1bGFyLmlzRGVmaW5lZChhdHRycy5yZWFkb25seUlucHV0KSkgPyBzY29wZS4kZXZhbChhdHRycy5yZWFkb25seUlucHV0KSA6IHRpbWVwaWNrZXJDb25maWcucmVhZG9ubHlJbnB1dDtcbiAgICAgIGlmICggISBzY29wZS5yZWFkb25seUlucHV0ICkge1xuXG4gICAgICAgIHZhciBpbnZhbGlkYXRlID0gZnVuY3Rpb24oaW52YWxpZEhvdXJzLCBpbnZhbGlkTWludXRlcykge1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZpZXdWYWx1ZSggbnVsbCApO1xuICAgICAgICAgIG5nTW9kZWwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkSG91cnMpKSB7XG4gICAgICAgICAgICBzY29wZS5pbnZhbGlkSG91cnMgPSBpbnZhbGlkSG91cnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkTWludXRlcykpIHtcbiAgICAgICAgICAgIHNjb3BlLmludmFsaWRNaW51dGVzID0gaW52YWxpZE1pbnV0ZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNjb3BlLnVwZGF0ZUhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGhvdXJzID0gZ2V0SG91cnNGcm9tVGVtcGxhdGUoKTtcblxuICAgICAgICAgIGlmICggYW5ndWxhci5pc0RlZmluZWQoaG91cnMpICkge1xuICAgICAgICAgICAgc2VsZWN0ZWQuc2V0SG91cnMoIGhvdXJzICk7XG4gICAgICAgICAgICByZWZyZXNoKCAnaCcgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW52YWxpZGF0ZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaG91cnNJbnB1dEVsLmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKCAhc2NvcGUudmFsaWRIb3VycyAmJiBzY29wZS5ob3VycyA8IDEwKSB7XG4gICAgICAgICAgICBzY29wZS4kYXBwbHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzY29wZS5ob3VycyA9IHBhZCggc2NvcGUuaG91cnMgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2NvcGUudXBkYXRlTWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xuXG4gICAgICAgICAgaWYgKCBhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSApIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldE1pbnV0ZXMoIG1pbnV0ZXMgKTtcbiAgICAgICAgICAgIHJlZnJlc2goICdtJyApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIG1pbnV0ZXNJbnB1dEVsLmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKCAhc2NvcGUuaW52YWxpZE1pbnV0ZXMgJiYgc2NvcGUubWludXRlcyA8IDEwICkge1xuICAgICAgICAgICAgc2NvcGUuJGFwcGx5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2NvcGUubWludXRlcyA9IHBhZCggc2NvcGUubWludXRlcyApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlLnVwZGF0ZUhvdXJzID0gYW5ndWxhci5ub29wO1xuICAgICAgICBzY29wZS51cGRhdGVNaW51dGVzID0gYW5ndWxhci5ub29wO1xuICAgICAgfVxuXG4gICAgICBuZ01vZGVsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZ01vZGVsLiRtb2RlbFZhbHVlID8gbmV3IERhdGUoIG5nTW9kZWwuJG1vZGVsVmFsdWUgKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKCBpc05hTihkYXRlKSApIHtcbiAgICAgICAgICBuZ01vZGVsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcbiAgICAgICAgICAkbG9nLmVycm9yKCdUaW1lcGlja2VyIGRpcmVjdGl2ZTogXCJuZy1tb2RlbFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDAxLjAxLjE5NzAgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIFJGQzI4MjIgb3IgSVNPIDg2MDEgZGF0ZS4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIGRhdGUgKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IGRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1ha2VWYWxpZCgpO1xuICAgICAgICAgIHVwZGF0ZVRlbXBsYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIENhbGwgaW50ZXJuYWxseSB3aGVuIHdlIGtub3cgdGhhdCBtb2RlbCBpcyB2YWxpZC5cbiAgICAgIGZ1bmN0aW9uIHJlZnJlc2goIGtleWJvYXJkQ2hhbmdlICkge1xuICAgICAgICBtYWtlVmFsaWQoKTtcbiAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKCBuZXcgRGF0ZShzZWxlY3RlZCkgKTtcbiAgICAgICAgdXBkYXRlVGVtcGxhdGUoIGtleWJvYXJkQ2hhbmdlICk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1ha2VWYWxpZCgpIHtcbiAgICAgICAgbmdNb2RlbC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCB0cnVlKTtcbiAgICAgICAgc2NvcGUuaW52YWxpZEhvdXJzID0gZmFsc2U7XG4gICAgICAgIHNjb3BlLmludmFsaWRNaW51dGVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRlbXBsYXRlKCBrZXlib2FyZENoYW5nZSApIHtcbiAgICAgICAgdmFyIGhvdXJzID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSwgbWludXRlcyA9IHNlbGVjdGVkLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICBpZiAoIHNjb3BlLnNob3dNZXJpZGlhbiApIHtcbiAgICAgICAgICBob3VycyA9ICggaG91cnMgPT09IDAgfHwgaG91cnMgPT09IDEyICkgPyAxMiA6IGhvdXJzICUgMTI7IC8vIENvbnZlcnQgMjQgdG8gMTIgaG91ciBzeXN0ZW1cbiAgICAgICAgfVxuICAgICAgICBzY29wZS5ob3VycyA9ICBrZXlib2FyZENoYW5nZSA9PT0gJ2gnID8gaG91cnMgOiBwYWQoaG91cnMpO1xuICAgICAgICBzY29wZS5taW51dGVzID0ga2V5Ym9hcmRDaGFuZ2UgPT09ICdtJyA/IG1pbnV0ZXMgOiBwYWQobWludXRlcyk7XG4gICAgICAgIHNjb3BlLm1lcmlkaWFuID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyID8gbWVyaWRpYW5zWzBdIDogbWVyaWRpYW5zWzFdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRNaW51dGVzKCBtaW51dGVzICkge1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZSggc2VsZWN0ZWQuZ2V0VGltZSgpICsgbWludXRlcyAqIDYwMDAwICk7XG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKCBkdC5nZXRIb3VycygpLCBkdC5nZXRNaW51dGVzKCkgKTtcbiAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5pbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhZGRNaW51dGVzKCBob3VyU3RlcCAqIDYwICk7XG4gICAgICB9O1xuICAgICAgc2NvcGUuZGVjcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYWRkTWludXRlcyggLSBob3VyU3RlcCAqIDYwICk7XG4gICAgICB9O1xuICAgICAgc2NvcGUuaW5jcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhZGRNaW51dGVzKCBtaW51dGVTdGVwICk7XG4gICAgICB9O1xuICAgICAgc2NvcGUuZGVjcmVtZW50TWludXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhZGRNaW51dGVzKCAtIG1pbnV0ZVN0ZXAgKTtcbiAgICAgIH07XG4gICAgICBzY29wZS50b2dnbGVNZXJpZGlhbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBhZGRNaW51dGVzKCAxMiAqIDYwICogKCggc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyICkgPyAxIDogLTEpICk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50eXBlYWhlYWQnLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsICd1aS5ib290c3RyYXAuYmluZEh0bWwnXSlcblxuLyoqXG4gKiBBIGhlbHBlciBzZXJ2aWNlIHRoYXQgY2FuIHBhcnNlIHR5cGVhaGVhZCdzIHN5bnRheCAoc3RyaW5nIHByb3ZpZGVkIGJ5IHVzZXJzKVxuICogRXh0cmFjdGVkIHRvIGEgc2VwYXJhdGUgc2VydmljZSBmb3IgZWFzZSBvZiB1bml0IHRlc3RpbmdcbiAqL1xuICAuZmFjdG9yeSgndHlwZWFoZWFkUGFyc2VyJywgWyckcGFyc2UnLCBmdW5jdGlvbiAoJHBhcnNlKSB7XG5cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgMDAwMDAxMTEwMDAwMDAwMDAwMDAwMjIyMDAwMDAwMDAwMDAwMDAwMDMzMzMzMzMzMzMzMzMzMzAwMDAwMDAwMDAwNDQwMDBcbiAgdmFyIFRZUEVBSEVBRF9SRUdFWFAgPSAvXlxccyooLio/KSg/Olxccythc1xccysoLio/KSk/XFxzK2ZvclxccysoPzooW1xcJFxcd11bXFwkXFx3XFxkXSopKVxccytpblxccysoLiopJC87XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTpmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goVFlQRUFIRUFEX1JFR0VYUCksIG1vZGVsTWFwcGVyLCB2aWV3TWFwcGVyLCBzb3VyY2U7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHR5cGVhaGVhZCBzcGVjaWZpY2F0aW9uIGluIGZvcm0gb2YgJ19tb2RlbFZhbHVlXyAoYXMgX2xhYmVsXyk/IGZvciBfaXRlbV8gaW4gX2NvbGxlY3Rpb25fJ1wiICtcbiAgICAgICAgICAgIFwiIGJ1dCBnb3QgJ1wiICsgaW5wdXQgKyBcIicuXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtTmFtZTptYXRjaFszXSxcbiAgICAgICAgc291cmNlOiRwYXJzZShtYXRjaFs0XSksXG4gICAgICAgIHZpZXdNYXBwZXI6JHBhcnNlKG1hdGNoWzJdIHx8IG1hdGNoWzFdKSxcbiAgICAgICAgbW9kZWxNYXBwZXI6JHBhcnNlKG1hdGNoWzFdKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XSlcblxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWQnLCBbJyRjb21waWxlJywgJyRwYXJzZScsICckcScsICckdGltZW91dCcsICckZG9jdW1lbnQnLCAnJHBvc2l0aW9uJywgJ3R5cGVhaGVhZFBhcnNlcicsXG4gICAgZnVuY3Rpb24gKCRjb21waWxlLCAkcGFyc2UsICRxLCAkdGltZW91dCwgJGRvY3VtZW50LCAkcG9zaXRpb24sIHR5cGVhaGVhZFBhcnNlcikge1xuXG4gIHZhciBIT1RfS0VZUyA9IFs5LCAxMywgMjcsIDM4LCA0MF07XG5cbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiduZ01vZGVsJyxcbiAgICBsaW5rOmZ1bmN0aW9uIChvcmlnaW5hbFNjb3BlLCBlbGVtZW50LCBhdHRycywgbW9kZWxDdHJsKSB7XG5cbiAgICAgIC8vU1VQUE9SVEVEIEFUVFJJQlVURVMgKE9QVElPTlMpXG5cbiAgICAgIC8vbWluaW1hbCBubyBvZiBjaGFyYWN0ZXJzIHRoYXQgbmVlZHMgdG8gYmUgZW50ZXJlZCBiZWZvcmUgdHlwZWFoZWFkIGtpY2tzLWluXG4gICAgICB2YXIgbWluU2VhcmNoID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRNaW5MZW5ndGgpIHx8IDE7XG5cbiAgICAgIC8vbWluaW1hbCB3YWl0IHRpbWUgYWZ0ZXIgbGFzdCBjaGFyYWN0ZXIgdHlwZWQgYmVmb3JlIHR5cGVoZWFkIGtpY2tzLWluXG4gICAgICB2YXIgd2FpdFRpbWUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZFdhaXRNcykgfHwgMDtcblxuICAgICAgLy9zaG91bGQgaXQgcmVzdHJpY3QgbW9kZWwgdmFsdWVzIHRvIHRoZSBvbmVzIHNlbGVjdGVkIGZyb20gdGhlIHBvcHVwIG9ubHk/XG4gICAgICB2YXIgaXNFZGl0YWJsZSA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkRWRpdGFibGUpICE9PSBmYWxzZTtcblxuICAgICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgbWF0Y2hlcyBhcmUgYmVpbmcgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5XG4gICAgICB2YXIgaXNMb2FkaW5nU2V0dGVyID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZExvYWRpbmcpLmFzc2lnbiB8fCBhbmd1bGFyLm5vb3A7XG5cbiAgICAgIC8vYSBjYWxsYmFjayBleGVjdXRlZCB3aGVuIGEgbWF0Y2ggaXMgc2VsZWN0ZWRcbiAgICAgIHZhciBvblNlbGVjdENhbGxiYWNrID0gJHBhcnNlKGF0dHJzLnR5cGVhaGVhZE9uU2VsZWN0KTtcblxuICAgICAgdmFyIGlucHV0Rm9ybWF0dGVyID0gYXR0cnMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIgPyAkcGFyc2UoYXR0cnMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIpIDogdW5kZWZpbmVkO1xuXG4gICAgICAvL0lOVEVSTkFMIFZBUklBQkxFU1xuXG4gICAgICAvL21vZGVsIHNldHRlciBleGVjdXRlZCB1cG9uIG1hdGNoIHNlbGVjdGlvblxuICAgICAgdmFyICRzZXRNb2RlbFZhbHVlID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwpLmFzc2lnbjtcblxuICAgICAgLy9leHByZXNzaW9ucyB1c2VkIGJ5IHR5cGVhaGVhZFxuICAgICAgdmFyIHBhcnNlclJlc3VsdCA9IHR5cGVhaGVhZFBhcnNlci5wYXJzZShhdHRycy50eXBlYWhlYWQpO1xuXG4gICAgICB2YXIgaGFzRm9jdXM7XG5cbiAgICAgIC8vcG9wLXVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IG1hdGNoZXNcbiAgICAgIHZhciBwb3BVcEVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHR5cGVhaGVhZC1wb3B1cD48L2Rpdj4nKTtcbiAgICAgIHBvcFVwRWwuYXR0cih7XG4gICAgICAgIG1hdGNoZXM6ICdtYXRjaGVzJyxcbiAgICAgICAgYWN0aXZlOiAnYWN0aXZlSWR4JyxcbiAgICAgICAgc2VsZWN0OiAnc2VsZWN0KGFjdGl2ZUlkeCknLFxuICAgICAgICBxdWVyeTogJ3F1ZXJ5JyxcbiAgICAgICAgcG9zaXRpb246ICdwb3NpdGlvbidcbiAgICAgIH0pO1xuICAgICAgLy9jdXN0b20gaXRlbSB0ZW1wbGF0ZVxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKSkge1xuICAgICAgICBwb3BVcEVsLmF0dHIoJ3RlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKTtcbiAgICAgIH1cblxuICAgICAgLy9jcmVhdGUgYSBjaGlsZCBzY29wZSBmb3IgdGhlIHR5cGVhaGVhZCBkaXJlY3RpdmUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgc2NvcGVcbiAgICAgIC8vd2l0aCB0eXBlYWhlYWQtc3BlY2lmaWMgZGF0YSAobWF0Y2hlcywgcXVlcnkgZXRjLilcbiAgICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xuICAgICAgb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKXtcbiAgICAgICAgc2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzZXRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNjb3BlLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gLTE7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZ2V0TWF0Y2hlc0FzeW5jID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSkge1xuXG4gICAgICAgIHZhciBsb2NhbHMgPSB7JHZpZXdWYWx1ZTogaW5wdXRWYWx1ZX07XG4gICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgICAgJHEud2hlbihwYXJzZXJSZXN1bHQuc291cmNlKG9yaWdpbmFsU2NvcGUsIGxvY2FscykpLnRoZW4oZnVuY3Rpb24obWF0Y2hlcykge1xuXG4gICAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCBzZXZlcmFsIGFzeW5jIHF1ZXJpZXMgd2VyZSBpbiBwcm9ncmVzcyBpZiBhIHVzZXIgd2VyZSB0eXBpbmcgZmFzdFxuICAgICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXG4gICAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09IG1vZGVsQ3RybC4kdmlld1ZhbHVlICYmIGhhc0ZvY3VzKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gMDtcbiAgICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgIC8vdHJhbnNmb3JtIGxhYmVsc1xuICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSBtYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgIHNjb3BlLm1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBsYWJlbDogcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIoc2NvcGUsIGxvY2FscyksXG4gICAgICAgICAgICAgICAgICBtb2RlbDogbWF0Y2hlc1tpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2NvcGUucXVlcnkgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAvL3Bvc2l0aW9uIHBvcC11cCB3aXRoIG1hdGNoZXMgLSB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBpdHMgcG9zaXRpb24gZWFjaCB0aW1lIHdlIGFyZSBvcGVuaW5nIGEgd2luZG93XG4gICAgICAgICAgICAgIC8vd2l0aCBtYXRjaGVzIGFzIGEgcG9wLXVwIG1pZ2h0IGJlIGFic29sdXRlLXBvc2l0aW9uZWQgYW5kIHBvc2l0aW9uIG9mIGFuIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZCBvbiBhIHBhZ2VcbiAgICAgICAgICAgICAgLy9kdWUgdG8gb3RoZXIgZWxlbWVudHMgYmVpbmcgcmVuZGVyZWRcbiAgICAgICAgICAgICAgc2NvcGUucG9zaXRpb24gPSAkcG9zaXRpb24ucG9zaXRpb24oZWxlbWVudCk7XG4gICAgICAgICAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCA9IHNjb3BlLnBvc2l0aW9uLnRvcCArIGVsZW1lbnQucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXNldE1hdGNoZXMoKTtcblxuICAgICAgLy93ZSBuZWVkIHRvIHByb3BhZ2F0ZSB1c2VyJ3MgcXVlcnkgc28gd2UgY2FuIGhpZ2xpZ2h0IG1hdGNoZXNcbiAgICAgIHNjb3BlLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAvL0RlY2xhcmUgdGhlIHRpbWVvdXQgcHJvbWlzZSB2YXIgb3V0c2lkZSB0aGUgZnVuY3Rpb24gc2NvcGUgc28gdGhhdCBzdGFja2VkIGNhbGxzIGNhbiBiZSBjYW5jZWxsZWQgbGF0ZXIgXG4gICAgICB2YXIgdGltZW91dFByb21pc2U7XG5cbiAgICAgIC8vcGx1ZyBpbnRvICRwYXJzZXJzIHBpcGVsaW5lIHRvIG9wZW4gYSB0eXBlYWhlYWQgb24gdmlldyBjaGFuZ2VzIGluaXRpYXRlZCBmcm9tIERPTVxuICAgICAgLy8kcGFyc2VycyBraWNrLWluIG9uIGFsbCB0aGUgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGUgdmlldyBhcyB3ZWxsIGFzIG1hbnVhbGx5IHRyaWdnZXJlZCBieSAkc2V0Vmlld1ZhbHVlXG4gICAgICBtb2RlbEN0cmwuJHBhcnNlcnMudW5zaGlmdChmdW5jdGlvbiAoaW5wdXRWYWx1ZSkge1xuXG4gICAgICAgIGhhc0ZvY3VzID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLmxlbmd0aCA+PSBtaW5TZWFyY2gpIHtcbiAgICAgICAgICBpZiAod2FpdFRpbWUgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGltZW91dFByb21pc2UpIHtcbiAgICAgICAgICAgICAgJHRpbWVvdXQuY2FuY2VsKHRpbWVvdXRQcm9taXNlKTsvL2NhbmNlbCBwcmV2aW91cyB0aW1lb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSA9ICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgfSwgd2FpdFRpbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gUmVzZXQgaW4gY2FzZSB1c2VyIGhhZCB0eXBlZCBzb21ldGhpbmcgcHJldmlvdXNseS5cbiAgICAgICAgICAgIG1vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ2VkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uIChtb2RlbFZhbHVlKSB7XG5cbiAgICAgICAgdmFyIGNhbmRpZGF0ZVZpZXdWYWx1ZSwgZW1wdHlWaWV3VmFsdWU7XG4gICAgICAgIHZhciBsb2NhbHMgPSB7fTtcblxuICAgICAgICBpZiAoaW5wdXRGb3JtYXR0ZXIpIHtcblxuICAgICAgICAgIGxvY2Fsc1snJG1vZGVsJ10gPSBtb2RlbFZhbHVlO1xuICAgICAgICAgIHJldHVybiBpbnB1dEZvcm1hdHRlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvL2l0IG1pZ2h0IGhhcHBlbiB0aGF0IHdlIGRvbid0IGhhdmUgZW5vdWdoIGluZm8gdG8gcHJvcGVybHkgcmVuZGVyIGlucHV0IHZhbHVlXG4gICAgICAgICAgLy93ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGlzIHNpdHVhdGlvbiBhbmQgc2ltcGx5IHJldHVybiBtb2RlbCB2YWx1ZSBpZiB3ZSBjYW4ndCBhcHBseSBjdXN0b20gZm9ybWF0dGluZ1xuICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbW9kZWxWYWx1ZTtcbiAgICAgICAgICBjYW5kaWRhdGVWaWV3VmFsdWUgPSBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuICAgICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGVtcHR5Vmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcblxuICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVWaWV3VmFsdWUhPT0gZW1wdHlWaWV3VmFsdWUgPyBjYW5kaWRhdGVWaWV3VmFsdWUgOiBtb2RlbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24gKGFjdGl2ZUlkeCkge1xuICAgICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiB0aGUgJGRpZ2VzdCgpIGN5Y2xlXG4gICAgICAgIHZhciBsb2NhbHMgPSB7fTtcbiAgICAgICAgdmFyIG1vZGVsLCBpdGVtO1xuXG4gICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gaXRlbSA9IHNjb3BlLm1hdGNoZXNbYWN0aXZlSWR4XS5tb2RlbDtcbiAgICAgICAgbW9kZWwgPSBwYXJzZXJSZXN1bHQubW9kZWxNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICAgJHNldE1vZGVsVmFsdWUob3JpZ2luYWxTY29wZSwgbW9kZWwpO1xuICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuXG4gICAgICAgIG9uU2VsZWN0Q2FsbGJhY2sob3JpZ2luYWxTY29wZSwge1xuICAgICAgICAgICRpdGVtOiBpdGVtLFxuICAgICAgICAgICRtb2RlbDogbW9kZWwsXG4gICAgICAgICAgJGxhYmVsOiBwYXJzZXJSZXN1bHQudmlld01hcHBlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuXG4gICAgICAgIC8vcmV0dXJuIGZvY3VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIGEgbWFjaCB3YXMgc2VsZWN0ZWQgdmlhIGEgbW91c2UgY2xpY2sgZXZlbnRcbiAgICAgICAgZWxlbWVudFswXS5mb2N1cygpO1xuICAgICAgfTtcblxuICAgICAgLy9iaW5kIGtleWJvYXJkIGV2ZW50czogYXJyb3dzIHVwKDM4KSAvIGRvd24oNDApLCBlbnRlcigxMykgYW5kIHRhYig5KSwgZXNjKDI3KVxuICAgICAgZWxlbWVudC5iaW5kKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xuXG4gICAgICAgIC8vdHlwZWFoZWFkIGlzIG9wZW4gYW5kIGFuIFwiaW50ZXJlc3RpbmdcIiBrZXkgd2FzIHByZXNzZWRcbiAgICAgICAgaWYgKHNjb3BlLm1hdGNoZXMubGVuZ3RoID09PSAwIHx8IEhPVF9LRVlTLmluZGV4T2YoZXZ0LndoaWNoKSA9PT0gLTEpIHtcbiAgICAgICAgICBpZiAoZXZ0LndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmIChldnQud2hpY2ggPT09IDQwKSB7XG4gICAgICAgICAgc2NvcGUuYWN0aXZlSWR4ID0gKHNjb3BlLmFjdGl2ZUlkeCArIDEpICUgc2NvcGUubWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAzOCkge1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggPyBzY29wZS5hY3RpdmVJZHggOiBzY29wZS5tYXRjaGVzLmxlbmd0aCkgLSAxO1xuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGV2dC53aGljaCA9PT0gMTMgfHwgZXZ0LndoaWNoID09PSA5KSB7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSAyNykge1xuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGVsZW1lbnQuYmluZCgnYmx1cicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBLZWVwIHJlZmVyZW5jZSB0byBjbGljayBoYW5kbGVyIHRvIHVuYmluZCBpdC5cbiAgICAgIHZhciBkaXNtaXNzQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZWxlbWVudFswXSAhPT0gZXZ0LnRhcmdldCkge1xuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJGRvY3VtZW50LmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG5cbiAgICAgIG9yaWdpbmFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICRkb2N1bWVudC51bmJpbmQoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5hZnRlcigkY29tcGlsZShwb3BVcEVsKShzY29wZSkpO1xuICAgIH1cbiAgfTtcblxufV0pXG5cbiAgLmRpcmVjdGl2ZSgndHlwZWFoZWFkUG9wdXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OidFQScsXG4gICAgICBzY29wZTp7XG4gICAgICAgIG1hdGNoZXM6Jz0nLFxuICAgICAgICBxdWVyeTonPScsXG4gICAgICAgIGFjdGl2ZTonPScsXG4gICAgICAgIHBvc2l0aW9uOic9JyxcbiAgICAgICAgc2VsZWN0OicmJ1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2U6dHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOid0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWwnLFxuICAgICAgbGluazpmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG5cbiAgICAgICAgc2NvcGUudGVtcGxhdGVVcmwgPSBhdHRycy50ZW1wbGF0ZVVybDtcblxuICAgICAgICBzY29wZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uIChtYXRjaElkeCkge1xuICAgICAgICAgIHJldHVybiBzY29wZS5hY3RpdmUgPT0gbWF0Y2hJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0QWN0aXZlID0gZnVuY3Rpb24gKG1hdGNoSWR4KSB7XG4gICAgICAgICAgc2NvcGUuYWN0aXZlID0gbWF0Y2hJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0TWF0Y2ggPSBmdW5jdGlvbiAoYWN0aXZlSWR4KSB7XG4gICAgICAgICAgc2NvcGUuc2VsZWN0KHthY3RpdmVJZHg6YWN0aXZlSWR4fSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSlcblxuICAuZGlyZWN0aXZlKCd0eXBlYWhlYWRNYXRjaCcsIFsnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJGNvbXBpbGUnLCAnJHBhcnNlJywgZnVuY3Rpb24gKCRodHRwLCAkdGVtcGxhdGVDYWNoZSwgJGNvbXBpbGUsICRwYXJzZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDonRUEnLFxuICAgICAgc2NvcGU6e1xuICAgICAgICBpbmRleDonPScsXG4gICAgICAgIG1hdGNoOic9JyxcbiAgICAgICAgcXVlcnk6Jz0nXG4gICAgICB9LFxuICAgICAgbGluazpmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHZhciB0cGxVcmwgPSAkcGFyc2UoYXR0cnMudGVtcGxhdGVVcmwpKHNjb3BlLiRwYXJlbnQpIHx8ICd0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWwnO1xuICAgICAgICAkaHR0cC5nZXQodHBsVXJsLCB7Y2FjaGU6ICR0ZW1wbGF0ZUNhY2hlfSkuc3VjY2VzcyhmdW5jdGlvbih0cGxDb250ZW50KXtcbiAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aCgkY29tcGlsZSh0cGxDb250ZW50LnRyaW0oKSkoc2NvcGUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmZpbHRlcigndHlwZWFoZWFkSGlnaGxpZ2h0JywgZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleHAocXVlcnlUb0VzY2FwZSkge1xuICAgICAgcmV0dXJuIHF1ZXJ5VG9Fc2NhcGUucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csIFwiXFxcXCQxXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihtYXRjaEl0ZW0sIHF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcXVlcnkgPyBtYXRjaEl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ2V4cChxdWVyeSksICdnaScpLCAnPHN0cm9uZz4kJjwvc3Ryb25nPicpIDogbWF0Y2hJdGVtO1xuICAgIH07XG4gIH0pO1xuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcImFjY29yZGlvbi1ncm91cFxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJhY2NvcmRpb24taGVhZGluZ1xcXCIgPjxhIGNsYXNzPVxcXCJhY2NvcmRpb24tdG9nZ2xlXFxcIiBuZy1jbGljaz1cXFwiaXNPcGVuID0gIWlzT3BlblxcXCIgYWNjb3JkaW9uLXRyYW5zY2x1ZGU9XFxcImhlYWRpbmdcXFwiPnt7aGVhZGluZ319PC9hPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uLWJvZHlcXFwiIGNvbGxhcHNlPVxcXCIhaXNPcGVuXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uLWlubmVyXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24uaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYWNjb3JkaW9uXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz0nYWxlcnQnIG5nLWNsYXNzPSd0eXBlICYmIFxcXCJhbGVydC1cXFwiICsgdHlwZSc+XFxuXCIgK1xuICAgIFwiICAgIDxidXR0b24gbmctc2hvdz0nY2xvc2VhYmxlJyB0eXBlPSdidXR0b24nIGNsYXNzPSdjbG9zZScgbmctY2xpY2s9J2Nsb3NlKCknPiZ0aW1lczs8L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9jYXJvdXNlbC9jYXJvdXNlbC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLFxuICAgIFwiPGRpdiBuZy1tb3VzZWVudGVyPVxcXCJwYXVzZSgpXFxcIiBuZy1tb3VzZWxlYXZlPVxcXCJwbGF5KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbFxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxvbCBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5kaWNhdG9yc1xcXCIgbmctc2hvdz1cXFwic2xpZGVzKCkubGVuZ3RoID4gMVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8bGkgbmctcmVwZWF0PVxcXCJzbGlkZSBpbiBzbGlkZXMoKVxcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IGlzQWN0aXZlKHNsaWRlKX1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3Qoc2xpZGUpXFxcIj48L2xpPlxcblwiICtcbiAgICBcIiAgICA8L29sPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJjYXJvdXNlbC1pbm5lclxcXCIgbmctdHJhbnNjbHVkZT48L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPGEgbmctY2xpY2s9XFxcInByZXYoKVxcXCIgY2xhc3M9XFxcImNhcm91c2VsLWNvbnRyb2wgbGVmdFxcXCIgbmctc2hvdz1cXFwic2xpZGVzKCkubGVuZ3RoID4gMVxcXCI+JmxzYXF1bzs8L2E+XFxuXCIgK1xuICAgIFwiICAgIDxhIG5nLWNsaWNrPVxcXCJuZXh0KClcXFwiIGNsYXNzPVxcXCJjYXJvdXNlbC1jb250cm9sIHJpZ2h0XFxcIiBuZy1zaG93PVxcXCJzbGlkZXMoKS5sZW5ndGggPiAxXFxcIj4mcnNhcXVvOzwvYT5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIixcbiAgICBcIjxkaXYgbmctY2xhc3M9XFxcIntcXG5cIiArXG4gICAgXCIgICAgJ2FjdGl2ZSc6IGxlYXZpbmcgfHwgKGFjdGl2ZSAmJiAhZW50ZXJpbmcpLFxcblwiICtcbiAgICBcIiAgICAncHJldic6IChuZXh0IHx8IGFjdGl2ZSkgJiYgZGlyZWN0aW9uPT0ncHJldicsXFxuXCIgK1xuICAgIFwiICAgICduZXh0JzogKG5leHQgfHwgYWN0aXZlKSAmJiBkaXJlY3Rpb249PSduZXh0JyxcXG5cIiArXG4gICAgXCIgICAgJ3JpZ2h0JzogZGlyZWN0aW9uPT0ncHJldicsXFxuXCIgK1xuICAgIFwiICAgICdsZWZ0JzogZGlyZWN0aW9uPT0nbmV4dCdcXG5cIiArXG4gICAgXCIgIH1cXFwiIGNsYXNzPVxcXCJpdGVtXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5odG1sXCIsXG4gICAgXCI8dGFibGU+XFxuXCIgK1xuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBwdWxsLWxlZnRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKC0xKVxcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi1sZWZ0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGggY29sc3Bhbj1cXFwie3tyb3dzWzBdLmxlbmd0aCAtIDIgKyBzaG93V2Vla051bWJlcnN9fVxcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWJsb2NrXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIj48c3Ryb25nPnt7dGl0bGV9fTwvc3Ryb25nPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgICAgPHRoPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIHB1bGwtcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgICAgPHRyIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgbmctc2hvdz1cXFwibGFiZWxzLmxlbmd0aCA+IDBcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBuZy1zaG93PVxcXCJzaG93V2Vla051bWJlcnNcXFwiPiM8L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBuZy1yZXBlYXQ9XFxcImxhYmVsIGluIGxhYmVsc1xcXCI+e3tsYWJlbH19PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBuZy1yZXBlYXQ9XFxcInJvdyBpbiByb3dzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd1dlZWtOdW1iZXJzXFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPjxlbT57eyBnZXRXZWVrTnVtYmVyKHJvdykgfX08L2VtPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXJlcGVhdD1cXFwiZHQgaW4gcm93XFxcIiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHN0eWxlPVxcXCJ3aWR0aDoxMDAlO1xcXCIgY2xhc3M9XFxcImJ0blxcXCIgbmctY2xhc3M9XFxcInsnYnRuLWluZm8nOiBkdC5zZWxlY3RlZH1cXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoZHQuZGF0ZSlcXFwiIG5nLWRpc2FibGVkPVxcXCJkdC5kaXNhYmxlZFxcXCI+PHNwYW4gbmctY2xhc3M9XFxcInttdXRlZDogZHQuc2Vjb25kYXJ5fVxcXCI+e3tkdC5sYWJlbH19PC9zcGFuPjwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3Rib2R5PlxcblwiICtcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFwiLFxuICAgIFwiPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiBuZy1zdHlsZT1cXFwie2Rpc3BsYXk6IChpc09wZW4gJiYgJ2Jsb2NrJykgfHwgJ25vbmUnLCB0b3A6IHBvc2l0aW9uLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0KydweCd9XFxcIj5cXG5cIiArXG4gICAgXCJcdDxsaSBuZy10cmFuc2NsdWRlPjwvbGk+XFxuXCIgK1xuICAgIFwiXHQ8bGkgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvbGk+XFxuXCIgK1xuICAgIFwiXHQ8bGkgc3R5bGU9XFxcInBhZGRpbmc6IDlweDtcXFwiPlxcblwiICtcbiAgICBcIlx0XHQ8c3BhbiBjbGFzcz1cXFwiYnRuLWdyb3VwXFxcIj5cXG5cIiArXG4gICAgXCJcdFx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLWludmVyc2VcXFwiIG5nLWNsaWNrPVxcXCJ0b2RheSgpXFxcIj57e2N1cnJlbnRUZXh0fX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCJcdFx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLWluZm9cXFwiIG5nLWNsaWNrPVxcXCJzaG93V2Vla3MgPSAhIHNob3dXZWVrc1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IHNob3dXZWVrc31cXFwiPnt7dG9nZ2xlV2Vla3NUZXh0fX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCJcdFx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLWRhbmdlclxcXCIgbmctY2xpY2s9XFxcImNsZWFyKClcXFwiPnt7Y2xlYXJUZXh0fX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCJcdFx0PC9zcGFuPlxcblwiICtcbiAgICBcIlx0XHQ8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc21hbGwgYnRuLXN1Y2Nlc3MgcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcImlzT3BlbiA9IGZhbHNlXFxcIj57e2Nsb3NlVGV4dH19PC9idXR0b24+XFxuXCIgK1xuICAgIFwiXHQ8L2xpPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9tb2RhbC9iYWNrZHJvcC5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJtb2RhbC1iYWNrZHJvcCBmYWRlXFxcIiBuZy1jbGFzcz1cXFwie2luOiBhbmltYXRlfVxcXCIgbmctc3R5bGU9XFxcInsnei1pbmRleCc6IDEwNDAgKyBpbmRleCoxMH1cXFwiIG5nLWNsaWNrPVxcXCJjbG9zZSgkZXZlbnQpXFxcIj48L2Rpdj5cIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwibW9kYWwgZmFkZSB7eyB3aW5kb3dDbGFzcyB9fVxcXCIgbmctY2xhc3M9XFxcIntpbjogYW5pbWF0ZX1cXFwiIG5nLXN0eWxlPVxcXCJ7J3otaW5kZXgnOiAxMDUwICsgaW5kZXgqMTB9XFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2VyLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBhZ2VyXFxcIj5cXG5cIiArXG4gICAgXCIgIDx1bD5cXG5cIiArXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogcGFnZS5kaXNhYmxlZCwgcHJldmlvdXM6IHBhZ2UucHJldmlvdXMsIG5leHQ6IHBhZ2UubmV4dH1cXFwiPjxhIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UubnVtYmVyKVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPC91bD5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicGFnaW5hdGlvblxcXCI+PHVsPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLXJlcGVhdD1cXFwicGFnZSBpbiBwYWdlc1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IHBhZ2UuYWN0aXZlLCBkaXNhYmxlZDogcGFnZS5kaXNhYmxlZH1cXFwiPjxhIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UubnVtYmVyKVxcXCI+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIiAgPC91bD5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLWh0bWwtdW5zYWZlLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC11bnNhZmUtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcCB7e3BsYWNlbWVudH19XFxcIiBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCksIGZhZGU6IGFuaW1hdGlvbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBiaW5kLWh0bWwtdW5zYWZlPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcCB7e3BsYWNlbWVudH19XFxcIiBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCksIGZhZGU6IGFuaW1hdGlvbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXIuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicG9wb3ZlciB7e3BsYWNlbWVudH19XFxcIiBuZy1jbGFzcz1cXFwieyBpbjogaXNPcGVuKCksIGZhZGU6IGFuaW1hdGlvbigpIH1cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPGgzIGNsYXNzPVxcXCJwb3BvdmVyLXRpdGxlXFxcIiBuZy1iaW5kPVxcXCJ0aXRsZVxcXCIgbmctc2hvdz1cXFwidGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xuICAgIFwiICAgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJiYXJcXFwiIG5nLWNsYXNzPSd0eXBlICYmIFxcXCJiYXItXFxcIiArIHR5cGUnPjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPjxwcm9ncmVzc2JhciBuZy1yZXBlYXQ9XFxcImJhciBpbiBiYXJzXFxcIiB3aWR0aD1cXFwiYmFyLnRvXFxcIiBvbGQ9XFxcImJhci5mcm9tXFxcIiBhbmltYXRlPVxcXCJiYXIuYW5pbWF0ZVxcXCIgdHlwZT1cXFwiYmFyLnR5cGVcXFwiPjwvcHJvZ3Jlc3NiYXI+PC9kaXY+XCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFxuICAgIFwiPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCI+XFxuXCIgK1xuICAgIFwiXHQ8aSBuZy1yZXBlYXQ9XFxcInIgaW4gcmFuZ2VcXFwiIG5nLW1vdXNlZW50ZXI9XFxcImVudGVyKCRpbmRleCArIDEpXFxcIiBuZy1jbGljaz1cXFwicmF0ZSgkaW5kZXggKyAxKVxcXCIgbmctY2xhc3M9XFxcIiRpbmRleCA8IHZhbCAmJiAoci5zdGF0ZU9uIHx8ICdpY29uLXN0YXInKSB8fCAoci5zdGF0ZU9mZiB8fCAnaWNvbi1zdGFyLWVtcHR5JylcXFwiPjwvaT5cXG5cIiArXG4gICAgXCI8L3NwYW4+XCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYi5odG1sXCIsXG4gICAgXCI8bGkgbmctY2xhc3M9XFxcInthY3RpdmU6IGFjdGl2ZSwgZGlzYWJsZWQ6IGRpc2FibGVkfVxcXCI+XFxuXCIgK1xuICAgIFwiICA8YSBuZy1jbGljaz1cXFwic2VsZWN0KClcXFwiIHRhYi1oZWFkaW5nLXRyYW5zY2x1ZGU+e3toZWFkaW5nfX08L2E+XFxuXCIgK1xuICAgIFwiPC9saT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidGVtcGxhdGUvdGFicy90YWJzZXQtdGl0bGVzLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC10aXRsZXMuaHRtbFwiLFxuICAgIFwiPHVsIGNsYXNzPVxcXCJuYXYge3t0eXBlICYmICduYXYtJyArIHR5cGV9fVxcXCIgbmctY2xhc3M9XFxcInsnbmF2LXN0YWNrZWQnOiB2ZXJ0aWNhbH1cXFwiPlxcblwiICtcbiAgICBcIjwvdWw+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXCIsXG4gICAgXCJcXG5cIiArXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJ0YWJiYWJsZVxcXCIgbmctY2xhc3M9XFxcInsndGFicy1yaWdodCc6IGRpcmVjdGlvbiA9PSAncmlnaHQnLCAndGFicy1sZWZ0JzogZGlyZWN0aW9uID09ICdsZWZ0JywgJ3RhYnMtYmVsb3cnOiBkaXJlY3Rpb24gPT0gJ2JlbG93J31cXFwiPlxcblwiICtcbiAgICBcIiAgPGRpdiB0YWJzZXQtdGl0bGVzPVxcXCJ0YWJzQWJvdmVcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnRcXFwiPlxcblwiICtcbiAgICBcIiAgICA8ZGl2IGNsYXNzPVxcXCJ0YWItcGFuZVxcXCIgXFxuXCIgK1xuICAgIFwiICAgICAgICAgbmctcmVwZWF0PVxcXCJ0YWIgaW4gdGFic1xcXCIgXFxuXCIgK1xuICAgIFwiICAgICAgICAgbmctY2xhc3M9XFxcInthY3RpdmU6IHRhYi5hY3RpdmV9XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgIHRhYi1jb250ZW50LXRyYW5zY2x1ZGU9XFxcInRhYlxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDwvZGl2PlxcblwiICtcbiAgICBcIiAgPC9kaXY+XFxuXCIgK1xuICAgIFwiICA8ZGl2IHRhYnNldC10aXRsZXM9XFxcIiF0YWJzQWJvdmVcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90aW1lcGlja2VyL3RpbWVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsXG4gICAgXCI8dGFibGUgY2xhc3M9XFxcImZvcm0taW5saW5lXFxcIj5cXG5cIiArXG4gICAgXCJcdDx0ciBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiPlxcblwiICtcbiAgICBcIlx0XHQ8dGQ+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudEhvdXJzKClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiPjxpIGNsYXNzPVxcXCJpY29uLWNoZXZyb24tdXBcXFwiPjwvaT48L2E+PC90ZD5cXG5cIiArXG4gICAgXCJcdFx0PHRkPiZuYnNwOzwvdGQ+XFxuXCIgK1xuICAgIFwiXHRcdDx0ZD48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50TWludXRlcygpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIj48aSBjbGFzcz1cXFwiaWNvbi1jaGV2cm9uLXVwXFxcIj48L2k+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHRcdDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHQ8L3RyPlxcblwiICtcbiAgICBcIlx0PHRyPlxcblwiICtcbiAgICBcIlx0XHQ8dGQgY2xhc3M9XFxcImNvbnRyb2wtZ3JvdXBcXFwiIG5nLWNsYXNzPVxcXCJ7J2Vycm9yJzogaW52YWxpZEhvdXJzfVxcXCI+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJob3Vyc1xcXCIgbmctY2hhbmdlPVxcXCJ1cGRhdGVIb3VycygpXFxcIiBjbGFzcz1cXFwic3BhbjEgdGV4dC1jZW50ZXJcXFwiIG5nLW1vdXNld2hlZWw9XFxcImluY3JlbWVudEhvdXJzKClcXFwiIG5nLXJlYWRvbmx5PVxcXCJyZWFkb25seUlucHV0XFxcIiBtYXhsZW5ndGg9XFxcIjJcXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHRcdDx0ZD46PC90ZD5cXG5cIiArXG4gICAgXCJcdFx0PHRkIGNsYXNzPVxcXCJjb250cm9sLWdyb3VwXFxcIiBuZy1jbGFzcz1cXFwieydlcnJvcic6IGludmFsaWRNaW51dGVzfVxcXCI+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJtaW51dGVzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZU1pbnV0ZXMoKVxcXCIgY2xhc3M9XFxcInNwYW4xIHRleHQtY2VudGVyXFxcIiBuZy1yZWFkb25seT1cXFwicmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIj48L3RkPlxcblwiICtcbiAgICBcIlx0XHQ8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1lcmlkaWFuKClcXFwiIGNsYXNzPVxcXCJidG4gdGV4dC1jZW50ZXJcXFwiPnt7bWVyaWRpYW59fTwvYnV0dG9uPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHQ8L3RyPlxcblwiICtcbiAgICBcIlx0PHRyIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCI+XFxuXCIgK1xuICAgIFwiXHRcdDx0ZD48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50SG91cnMoKVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi1kb3duXFxcIj48L2k+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHRcdDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIlx0XHQ8dGQ+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudE1pbnV0ZXMoKVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCI+PGkgY2xhc3M9XFxcImljb24tY2hldnJvbi1kb3duXFxcIj48L2k+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHRcdDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiXHQ8L3RyPlxcblwiICtcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInRlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLFxuICAgIFwiPGEgdGFiaW5kZXg9XFxcIi0xXFxcIiBiaW5kLWh0bWwtdW5zYWZlPVxcXCJtYXRjaC5sYWJlbCB8IHR5cGVhaGVhZEhpZ2hsaWdodDpxdWVyeVxcXCI+PC9hPlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ0ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcIixcbiAgICBcIjx1bCBjbGFzcz1cXFwidHlwZWFoZWFkIGRyb3Bkb3duLW1lbnVcXFwiIG5nLXN0eWxlPVxcXCJ7ZGlzcGxheTogaXNPcGVuKCkmJidibG9jaycgfHwgJ25vbmUnLCB0b3A6IHBvc2l0aW9uLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0KydweCd9XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIG5nLXJlcGVhdD1cXFwibWF0Y2ggaW4gbWF0Y2hlc1xcXCIgbmctY2xhc3M9XFxcInthY3RpdmU6IGlzQWN0aXZlKCRpbmRleCkgfVxcXCIgbmctbW91c2VlbnRlcj1cXFwic2VsZWN0QWN0aXZlKCRpbmRleClcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3RNYXRjaCgkaW5kZXgpXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxkaXYgdHlwZWFoZWFkLW1hdGNoIGluZGV4PVxcXCIkaW5kZXhcXFwiIG1hdGNoPVxcXCJtYXRjaFxcXCIgcXVlcnk9XFxcInF1ZXJ5XFxcIiB0ZW1wbGF0ZS11cmw9XFxcInRlbXBsYXRlVXJsXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlwiKTtcbn1dKTtcblxufSkuY2FsbChnbG9iYWwsIG1vZHVsZSwgdW5kZWZpbmVkKTtcbiIsInZhciBnbG9iYWw9dHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9OyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGRlZmluZSkge1xuXG47IHJlcXVpcmUoXCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci9hbmd1bGFyLmpzXCIpO1xuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuMi42XG4gKiAoYykgMjAxMC0yMDE0IEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIHVuZGVmaW5lZCkgeyd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIG5nQ29va2llc1xuICogQGRlc2NyaXB0aW9uXG4gKlxuICogIyBuZ0Nvb2tpZXNcbiAqXG4gKiBUaGUgYG5nQ29va2llc2AgbW9kdWxlIHByb3ZpZGVzIGEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGJyb3dzZXIgY29va2llcy4gXG4gKlxuICoge0BpbnN0YWxsTW9kdWxlIGNvb2tpZXN9XG4gKlxuICogPGRpdiBkb2MtbW9kdWxlLWNvbXBvbmVudHM9XCJuZ0Nvb2tpZXNcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nQ29va2llcy4kY29va2llcyBgJGNvb2tpZXNgfSBhbmRcbiAqIHtAbGluayBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlIGAkY29va2llU3RvcmVgfSBmb3IgdXNhZ2UuXG4gKi9cblxuXG5hbmd1bGFyLm1vZHVsZSgnbmdDb29raWVzJywgWyduZyddKS5cbiAgLyoqXG4gICAqIEBuZ2RvYyBvYmplY3RcbiAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVzXG4gICAqIEByZXF1aXJlcyAkYnJvd3NlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHJvdmlkZXMgcmVhZC93cml0ZSBhY2Nlc3MgdG8gYnJvd3NlcidzIGNvb2tpZXMuXG4gICAqXG4gICAqIE9ubHkgYSBzaW1wbGUgT2JqZWN0IGlzIGV4cG9zZWQgYW5kIGJ5IGFkZGluZyBvciByZW1vdmluZyBwcm9wZXJ0aWVzIHRvL2Zyb21cbiAgICogdGhpcyBvYmplY3QsIG5ldyBjb29raWVzIGFyZSBjcmVhdGVkL2RlbGV0ZWQgYXQgdGhlIGVuZCBvZiBjdXJyZW50ICRldmFsLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nQ29va2llcyBgbmdDb29raWVzYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICAgPHNjcmlwdD5cbiAgICAgICAgIGZ1bmN0aW9uIEV4YW1wbGVDb250cm9sbGVyKCRjb29raWVzKSB7XG4gICAgICAgICAgIC8vIFJldHJpZXZpbmcgYSBjb29raWVcbiAgICAgICAgICAgdmFyIGZhdm9yaXRlQ29va2llID0gJGNvb2tpZXMubXlGYXZvcml0ZTtcbiAgICAgICAgICAgLy8gU2V0dGluZyBhIGNvb2tpZVxuICAgICAgICAgICAkY29va2llcy5teUZhdm9yaXRlID0gJ29hdG1lYWwnO1xuICAgICAgICAgfVxuICAgICAgIDwvc2NyaXB0PlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICA8L2RvYzpleGFtcGxlPlxuICAgKi9cbiAgIGZhY3RvcnkoJyRjb29raWVzJywgWyckcm9vdFNjb3BlJywgJyRicm93c2VyJywgZnVuY3Rpb24gKCRyb290U2NvcGUsICRicm93c2VyKSB7XG4gICAgICB2YXIgY29va2llcyA9IHt9LFxuICAgICAgICAgIGxhc3RDb29raWVzID0ge30sXG4gICAgICAgICAgbGFzdEJyb3dzZXJDb29raWVzLFxuICAgICAgICAgIHJ1bkV2YWwgPSBmYWxzZSxcbiAgICAgICAgICBjb3B5ID0gYW5ndWxhci5jb3B5LFxuICAgICAgICAgIGlzVW5kZWZpbmVkID0gYW5ndWxhci5pc1VuZGVmaW5lZDtcblxuICAgICAgLy9jcmVhdGVzIGEgcG9sbGVyIGZuIHRoYXQgY29waWVzIGFsbCBjb29raWVzIGZyb20gdGhlICRicm93c2VyIHRvIHNlcnZpY2UgJiBpbml0cyB0aGUgc2VydmljZVxuICAgICAgJGJyb3dzZXIuYWRkUG9sbEZuKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VycmVudENvb2tpZXMgPSAkYnJvd3Nlci5jb29raWVzKCk7XG4gICAgICAgIGlmIChsYXN0QnJvd3NlckNvb2tpZXMgIT0gY3VycmVudENvb2tpZXMpIHsgLy9yZWxpZXMgb24gYnJvd3Nlci5jb29raWVzKCkgaW1wbFxuICAgICAgICAgIGxhc3RCcm93c2VyQ29va2llcyA9IGN1cnJlbnRDb29raWVzO1xuICAgICAgICAgIGNvcHkoY3VycmVudENvb2tpZXMsIGxhc3RDb29raWVzKTtcbiAgICAgICAgICBjb3B5KGN1cnJlbnRDb29raWVzLCBjb29raWVzKTtcbiAgICAgICAgICBpZiAocnVuRXZhbCkgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcblxuICAgICAgcnVuRXZhbCA9IHRydWU7XG5cbiAgICAgIC8vYXQgdGhlIGVuZCBvZiBlYWNoIGV2YWwsIHB1c2ggY29va2llc1xuICAgICAgLy9UT0RPOiB0aGlzIHNob3VsZCBoYXBwZW4gYmVmb3JlIHRoZSBcImRlbGF5ZWRcIiB3YXRjaGVzIGZpcmUsIGJlY2F1c2UgaWYgc29tZSBjb29raWVzIGFyZSBub3RcbiAgICAgIC8vICAgICAgc3RyaW5ncyBvciBicm93c2VyIHJlZnVzZXMgdG8gc3RvcmUgc29tZSBjb29raWVzLCB3ZSB1cGRhdGUgdGhlIG1vZGVsIGluIHRoZSBwdXNoIGZuLlxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2gocHVzaCk7XG5cbiAgICAgIHJldHVybiBjb29raWVzO1xuXG5cbiAgICAgIC8qKlxuICAgICAgICogUHVzaGVzIGFsbCB0aGUgY29va2llcyBmcm9tIHRoZSBzZXJ2aWNlIHRvIHRoZSBicm93c2VyIGFuZCB2ZXJpZmllcyBpZiBhbGwgY29va2llcyB3ZXJlXG4gICAgICAgKiBzdG9yZWQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgIHZhciBuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBicm93c2VyQ29va2llcyxcbiAgICAgICAgICAgIHVwZGF0ZWQ7XG5cbiAgICAgICAgLy9kZWxldGUgYW55IGNvb2tpZXMgZGVsZXRlZCBpbiAkY29va2llc1xuICAgICAgICBmb3IgKG5hbWUgaW4gbGFzdENvb2tpZXMpIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoY29va2llc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICRicm93c2VyLmNvb2tpZXMobmFtZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3VwZGF0ZSBhbGwgY29va2llcyB1cGRhdGVkIGluICRjb29raWVzXG4gICAgICAgIGZvcihuYW1lIGluIGNvb2tpZXMpIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvb2tpZXNbbmFtZV07XG4gICAgICAgICAgaWYgKCFhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGxhc3RDb29raWVzW25hbWVdKSkge1xuICAgICAgICAgICAgICBjb29raWVzW25hbWVdID0gbGFzdENvb2tpZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgY29va2llc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSBsYXN0Q29va2llc1tuYW1lXSkge1xuICAgICAgICAgICAgJGJyb3dzZXIuY29va2llcyhuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3ZlcmlmeSB3aGF0IHdhcyBhY3R1YWxseSBzdG9yZWRcbiAgICAgICAgaWYgKHVwZGF0ZWQpe1xuICAgICAgICAgIHVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBicm93c2VyQ29va2llcyA9ICRicm93c2VyLmNvb2tpZXMoKTtcblxuICAgICAgICAgIGZvciAobmFtZSBpbiBjb29raWVzKSB7XG4gICAgICAgICAgICBpZiAoY29va2llc1tuYW1lXSAhPT0gYnJvd3NlckNvb2tpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgLy9kZWxldGUgb3IgcmVzZXQgYWxsIGNvb2tpZXMgdGhhdCB0aGUgYnJvd3NlciBkcm9wcGVkIGZyb20gJGNvb2tpZXNcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGJyb3dzZXJDb29raWVzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb29raWVzW25hbWVdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvb2tpZXNbbmFtZV0gPSBicm93c2VyQ29va2llc1tuYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XSkuXG5cblxuICAvKipcbiAgICogQG5nZG9jIG9iamVjdFxuICAgKiBAbmFtZSBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlXG4gICAqIEByZXF1aXJlcyAkY29va2llc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHJvdmlkZXMgYSBrZXktdmFsdWUgKHN0cmluZy1vYmplY3QpIHN0b3JhZ2UsIHRoYXQgaXMgYmFja2VkIGJ5IHNlc3Npb24gY29va2llcy5cbiAgICogT2JqZWN0cyBwdXQgb3IgcmV0cmlldmVkIGZyb20gdGhpcyBzdG9yYWdlIGFyZSBhdXRvbWF0aWNhbGx5IHNlcmlhbGl6ZWQgb3JcbiAgICogZGVzZXJpYWxpemVkIGJ5IGFuZ3VsYXIncyB0b0pzb24vZnJvbUpzb24uXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSB7QGxpbmsgbmdDb29raWVzIGBuZ0Nvb2tpZXNgfSBtb2R1bGUgdG8gYmUgaW5zdGFsbGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKi9cbiAgIGZhY3RvcnkoJyRjb29raWVTdG9yZScsIFsnJGNvb2tpZXMnLCBmdW5jdGlvbigkY29va2llcykge1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgKiBAbmFtZSBuZ0Nvb2tpZXMuJGNvb2tpZVN0b3JlI2dldFxuICAgICAgICAgKiBAbWV0aG9kT2YgbmdDb29raWVzLiRjb29raWVTdG9yZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgZ2l2ZW4gY29va2llIGtleVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIHRvIHVzZSBmb3IgbG9va3VwLlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBEZXNlcmlhbGl6ZWQgY29va2llIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAkY29va2llc1trZXldO1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA/IGFuZ3VsYXIuZnJvbUpzb24odmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVTdG9yZSNwdXRcbiAgICAgICAgICogQG1ldGhvZE9mIG5nQ29va2llcy4kY29va2llU3RvcmVcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFNldHMgYSB2YWx1ZSBmb3IgZ2l2ZW4gY29va2llIGtleVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IElkIGZvciB0aGUgYHZhbHVlYC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGJlIHN0b3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIHB1dDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICRjb29raWVzW2tleV0gPSBhbmd1bGFyLnRvSnNvbih2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICogQG5hbWUgbmdDb29raWVzLiRjb29raWVTdG9yZSNyZW1vdmVcbiAgICAgICAgICogQG1ldGhvZE9mIG5nQ29va2llcy4kY29va2llU3RvcmVcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJlbW92ZSBnaXZlbiBjb29raWVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBJZCBvZiB0aGUga2V5LXZhbHVlIHBhaXIgdG8gZGVsZXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBkZWxldGUgJGNvb2tpZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIH1dKTtcblxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcblxufSkuY2FsbChnbG9iYWwsIG1vZHVsZSwgdW5kZWZpbmVkKTtcbiIsInZhciBnbG9iYWw9dHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9OyhmdW5jdGlvbiBicm93c2VyaWZ5U2hpbShtb2R1bGUsIGRlZmluZSkge1xuXG47IHJlcXVpcmUoXCIvVXNlcnMvd2hlcmVzcmh5cy9TaXRlcy9qaWdzbnJlZWxzL2Jvd2VyX2NvbXBvbmVudHMvYW5ndWxhci9hbmd1bGFyLmpzXCIpO1xuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFySlMgdjEuMi42XG4gKiAoYykgMjAxMC0yMDE0IEdvb2dsZSwgSW5jLiBodHRwOi8vYW5ndWxhcmpzLm9yZ1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIHVuZGVmaW5lZCkgeyd1c2Ugc3RyaWN0JztcblxudmFyICRyZXNvdXJjZU1pbkVyciA9IGFuZ3VsYXIuJCRtaW5FcnIoJyRyZXNvdXJjZScpO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGFuZCByZWdleCB0byBsb29rdXAgYSBkb3R0ZWQgcGF0aCBvbiBhbiBvYmplY3Rcbi8vIHN0b3BwaW5nIGF0IHVuZGVmaW5lZC9udWxsLiAgVGhlIHBhdGggbXVzdCBiZSBjb21wb3NlZCBvZiBBU0NJSVxuLy8gaWRlbnRpZmllcnMgKGp1c3QgbGlrZSAkcGFyc2UpXG52YXIgTUVNQkVSX05BTUVfUkVHRVggPSAvXihcXC5bYS16QS1aXyRdWzAtOWEtekEtWl8kXSopKyQvO1xuXG5mdW5jdGlvbiBpc1ZhbGlkRG90dGVkUGF0aChwYXRoKSB7XG4gIHJldHVybiAocGF0aCAhPSBudWxsICYmIHBhdGggIT09ICcnICYmIHBhdGggIT09ICdoYXNPd25Qcm9wZXJ0eScgJiZcbiAgICAgIE1FTUJFUl9OQU1FX1JFR0VYLnRlc3QoJy4nICsgcGF0aCkpO1xufVxuXG5mdW5jdGlvbiBsb29rdXBEb3R0ZWRQYXRoKG9iaiwgcGF0aCkge1xuICBpZiAoIWlzVmFsaWREb3R0ZWRQYXRoKHBhdGgpKSB7XG4gICAgdGhyb3cgJHJlc291cmNlTWluRXJyKCdiYWRtZW1iZXInLCAnRG90dGVkIG1lbWJlciBwYXRoIFwiQHswfVwiIGlzIGludmFsaWQuJywgcGF0aCk7XG4gIH1cbiAgdmFyIGtleXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWkgJiYgb2JqICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIG9iaiA9IChvYmogIT09IG51bGwpID8gb2JqW2tleV0gOiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaGFsbG93IGNvcHkgb2YgYW4gb2JqZWN0IGFuZCBjbGVhciBvdGhlciBmaWVsZHMgZnJvbSB0aGUgZGVzdGluYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0NsZWFyQW5kQ29weShzcmMsIGRzdCkge1xuICBkc3QgPSBkc3QgfHwge307XG5cbiAgYW5ndWxhci5mb3JFYWNoKGRzdCwgZnVuY3Rpb24odmFsdWUsIGtleSl7XG4gICAgZGVsZXRlIGRzdFtrZXldO1xuICB9KTtcblxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleS5jaGFyQXQoMCkgIT09ICckJyAmJiBrZXkuY2hhckF0KDEpICE9PSAnJCcpIHtcbiAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIG5nUmVzb3VyY2VcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqICMgbmdSZXNvdXJjZVxuICpcbiAqIFRoZSBgbmdSZXNvdXJjZWAgbW9kdWxlIHByb3ZpZGVzIGludGVyYWN0aW9uIHN1cHBvcnQgd2l0aCBSRVNUZnVsIHNlcnZpY2VzXG4gKiB2aWEgdGhlICRyZXNvdXJjZSBzZXJ2aWNlLlxuICpcbiAqIHtAaW5zdGFsbE1vZHVsZSByZXNvdXJjZX1cbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nUmVzb3VyY2VcIj48L2Rpdj5cbiAqXG4gKiBTZWUge0BsaW5rIG5nUmVzb3VyY2UuJHJlc291cmNlIGAkcmVzb3VyY2VgfSBmb3IgdXNhZ2UuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZ1Jlc291cmNlLiRyZXNvdXJjZVxuICogQHJlcXVpcmVzICRodHRwXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIGZhY3Rvcnkgd2hpY2ggY3JlYXRlcyBhIHJlc291cmNlIG9iamVjdCB0aGF0IGxldHMgeW91IGludGVyYWN0IHdpdGhcbiAqIFtSRVNUZnVsXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JlcHJlc2VudGF0aW9uYWxfU3RhdGVfVHJhbnNmZXIpIHNlcnZlci1zaWRlIGRhdGEgc291cmNlcy5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgcmVzb3VyY2Ugb2JqZWN0IGhhcyBhY3Rpb24gbWV0aG9kcyB3aGljaCBwcm92aWRlIGhpZ2gtbGV2ZWwgYmVoYXZpb3JzIHdpdGhvdXRcbiAqIHRoZSBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhlIGxvdyBsZXZlbCB7QGxpbmsgbmcuJGh0dHAgJGh0dHB9IHNlcnZpY2UuXG4gKlxuICogUmVxdWlyZXMgdGhlIHtAbGluayBuZ1Jlc291cmNlIGBuZ1Jlc291cmNlYH0gbW9kdWxlIHRvIGJlIGluc3RhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIEEgcGFyYW1ldHJpemVkIFVSTCB0ZW1wbGF0ZSB3aXRoIHBhcmFtZXRlcnMgcHJlZml4ZWQgYnkgYDpgIGFzIGluXG4gKiAgIGAvdXNlci86dXNlcm5hbWVgLiBJZiB5b3UgYXJlIHVzaW5nIGEgVVJMIHdpdGggYSBwb3J0IG51bWJlciAoZS5nLlxuICogICBgaHR0cDovL2V4YW1wbGUuY29tOjgwODAvYXBpYCksIGl0IHdpbGwgYmUgcmVzcGVjdGVkLlxuICpcbiAqICAgSWYgeW91IGFyZSB1c2luZyBhIHVybCB3aXRoIGEgc3VmZml4LCBqdXN0IGFkZCB0aGUgc3VmZml4LCBsaWtlIHRoaXM6XG4gKiAgIGAkcmVzb3VyY2UoJ2h0dHA6Ly9leGFtcGxlLmNvbS9yZXNvdXJjZS5qc29uJylgIG9yIGAkcmVzb3VyY2UoJ2h0dHA6Ly9leGFtcGxlLmNvbS86aWQuanNvbicpYFxuICogICBvciBldmVuIGAkcmVzb3VyY2UoJ2h0dHA6Ly9leGFtcGxlLmNvbS9yZXNvdXJjZS86cmVzb3VyY2VfaWQuOmZvcm1hdCcpYFxuICogICBJZiB0aGUgcGFyYW1ldGVyIGJlZm9yZSB0aGUgc3VmZml4IGlzIGVtcHR5LCA6cmVzb3VyY2VfaWQgaW4gdGhpcyBjYXNlLCB0aGVuIHRoZSBgLy5gIHdpbGwgYmVcbiAqICAgY29sbGFwc2VkIGRvd24gdG8gYSBzaW5nbGUgYC5gLiAgSWYgeW91IG5lZWQgdGhpcyBzZXF1ZW5jZSB0byBhcHBlYXIgYW5kIG5vdCBjb2xsYXBzZSB0aGVuIHlvdVxuICogICBjYW4gZXNjYXBlIGl0IHdpdGggYC9cXC5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcGFyYW1EZWZhdWx0cyBEZWZhdWx0IHZhbHVlcyBmb3IgYHVybGAgcGFyYW1ldGVycy4gVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gaW5cbiAqICAgYGFjdGlvbnNgIG1ldGhvZHMuIElmIGFueSBvZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZXZlcnkgdGltZVxuICogICB3aGVuIGEgcGFyYW0gdmFsdWUgbmVlZHMgdG8gYmUgb2J0YWluZWQgZm9yIGEgcmVxdWVzdCAodW5sZXNzIHRoZSBwYXJhbSB3YXMgb3ZlcnJpZGRlbikuXG4gKlxuICogICBFYWNoIGtleSB2YWx1ZSBpbiB0aGUgcGFyYW1ldGVyIG9iamVjdCBpcyBmaXJzdCBib3VuZCB0byB1cmwgdGVtcGxhdGUgaWYgcHJlc2VudCBhbmQgdGhlbiBhbnlcbiAqICAgZXhjZXNzIGtleXMgYXJlIGFwcGVuZGVkIHRvIHRoZSB1cmwgc2VhcHBoIHF1ZXJ5IGFmdGVyIHRoZSBgP2AuXG4gKlxuICogICBHaXZlbiBhIHRlbXBsYXRlIGAvcGF0aC86dmVyYmAgYW5kIHBhcmFtZXRlciBge3ZlcmI6J2dyZWV0Jywgc2FsdXRhdGlvbjonSGVsbG8nfWAgcmVzdWx0cyBpblxuICogICBVUkwgYC9wYXRoL2dyZWV0P3NhbHV0YXRpb249SGVsbG9gLlxuICpcbiAqICAgSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBwcmVmaXhlZCB3aXRoIGBAYCB0aGVuIHRoZSB2YWx1ZSBvZiB0aGF0IHBhcmFtZXRlciBpcyBleHRyYWN0ZWQgZnJvbVxuICogICB0aGUgZGF0YSBvYmplY3QgKHVzZWZ1bCBmb3Igbm9uLUdFVCBvcGVyYXRpb25zKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdC48T2JqZWN0Pj19IGFjdGlvbnMgSGFzaCB3aXRoIGRlY2xhcmF0aW9uIG9mIGN1c3RvbSBhY3Rpb24gdGhhdCBzaG91bGQgZXh0ZW5kIHRoZVxuICogICBkZWZhdWx0IHNldCBvZiByZXNvdXJjZSBhY3Rpb25zLiBUaGUgZGVjbGFyYXRpb24gc2hvdWxkIGJlIGNyZWF0ZWQgaW4gdGhlIGZvcm1hdCBvZiB7QGxpbmtcbiAqICAgbmcuJGh0dHAjdXNhZ2VfcGFyYW1ldGVycyAkaHR0cC5jb25maWd9OlxuICpcbiAqICAgICAgIHthY3Rpb24xOiB7bWV0aG9kOj8sIHBhcmFtczo/LCBpc0FycmF5Oj8sIGhlYWRlcnM6PywgLi4ufSxcbiAqICAgICAgICBhY3Rpb24yOiB7bWV0aG9kOj8sIHBhcmFtczo/LCBpc0FycmF5Oj8sIGhlYWRlcnM6PywgLi4ufSxcbiAqICAgICAgICAuLi59XG4gKlxuICogICBXaGVyZTpcbiAqXG4gKiAgIC0gKipgYWN0aW9uYCoqIOKAkyB7c3RyaW5nfSDigJMgVGhlIG5hbWUgb2YgYWN0aW9uLiBUaGlzIG5hbWUgYmVjb21lcyB0aGUgbmFtZSBvZiB0aGUgbWV0aG9kIG9uXG4gKiAgICAgeW91ciByZXNvdXJjZSBvYmplY3QuXG4gKiAgIC0gKipgbWV0aG9kYCoqIOKAkyB7c3RyaW5nfSDigJMgSFRUUCByZXF1ZXN0IG1ldGhvZC4gVmFsaWQgbWV0aG9kcyBhcmU6IGBHRVRgLCBgUE9TVGAsIGBQVVRgLFxuICogICAgIGBERUxFVEVgLCBhbmQgYEpTT05QYC5cbiAqICAgLSAqKmBwYXJhbXNgKiog4oCTIHtPYmplY3Q9fSDigJMgT3B0aW9uYWwgc2V0IG9mIHByZS1ib3VuZCBwYXJhbWV0ZXJzIGZvciB0aGlzIGFjdGlvbi4gSWYgYW55IG9mXG4gKiAgICAgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgd2hlbiBhIHBhcmFtIHZhbHVlIG5lZWRzIHRvXG4gKiAgICAgYmUgb2J0YWluZWQgZm9yIGEgcmVxdWVzdCAodW5sZXNzIHRoZSBwYXJhbSB3YXMgb3ZlcnJpZGRlbikuXG4gKiAgIC0gKipgdXJsYCoqIOKAkyB7c3RyaW5nfSDigJMgYWN0aW9uIHNwZWNpZmljIGB1cmxgIG92ZXJyaWRlLiBUaGUgdXJsIHRlbXBsYXRpbmcgaXMgc3VwcG9ydGVkIGp1c3RcbiAqICAgICBsaWtlIGZvciB0aGUgcmVzb3VyY2UtbGV2ZWwgdXJscy5cbiAqICAgLSAqKmBpc0FycmF5YCoqIOKAkyB7Ym9vbGVhbj19IOKAkyBJZiB0cnVlIHRoZW4gdGhlIHJldHVybmVkIG9iamVjdCBmb3IgdGhpcyBhY3Rpb24gaXMgYW4gYXJyYXksXG4gKiAgICAgc2VlIGByZXR1cm5zYCBzZWN0aW9uLlxuICogICAtICoqYHRyYW5zZm9ybVJlcXVlc3RgKiog4oCTXG4gKiAgICAgYHtmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKXxBcnJheS48ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcik+fWAg4oCTXG4gKiAgICAgdHJhbnNmb3JtIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN1Y2ggZnVuY3Rpb25zLiBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHRha2VzIHRoZSBodHRwXG4gKiAgICAgcmVxdWVzdCBib2R5IGFuZCBoZWFkZXJzIGFuZCByZXR1cm5zIGl0cyB0cmFuc2Zvcm1lZCAodHlwaWNhbGx5IHNlcmlhbGl6ZWQpIHZlcnNpb24uXG4gKiAgIC0gKipgdHJhbnNmb3JtUmVzcG9uc2VgKiog4oCTXG4gKiAgICAgYHtmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKXxBcnJheS48ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcik+fWAg4oCTXG4gKiAgICAgdHJhbnNmb3JtIGZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIHN1Y2ggZnVuY3Rpb25zLiBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHRha2VzIHRoZSBodHRwXG4gKiAgICAgcmVzcG9uc2UgYm9keSBhbmQgaGVhZGVycyBhbmQgcmV0dXJucyBpdHMgdHJhbnNmb3JtZWQgKHR5cGljYWxseSBkZXNlcmlhbGl6ZWQpIHZlcnNpb24uXG4gKiAgIC0gKipgY2FjaGVgKiog4oCTIGB7Ym9vbGVhbnxDYWNoZX1gIOKAkyBJZiB0cnVlLCBhIGRlZmF1bHQgJGh0dHAgY2FjaGUgd2lsbCBiZSB1c2VkIHRvIGNhY2hlIHRoZVxuICogICAgIEdFVCByZXF1ZXN0LCBvdGhlcndpc2UgaWYgYSBjYWNoZSBpbnN0YW5jZSBidWlsdCB3aXRoXG4gKiAgICAge0BsaW5rIG5nLiRjYWNoZUZhY3RvcnkgJGNhY2hlRmFjdG9yeX0sIHRoaXMgY2FjaGUgd2lsbCBiZSB1c2VkIGZvclxuICogICAgIGNhY2hpbmcuXG4gKiAgIC0gKipgdGltZW91dGAqKiDigJMgYHtudW1iZXJ8UHJvbWlzZX1gIOKAkyB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcywgb3Ige0BsaW5rIG5nLiRxIHByb21pc2V9IHRoYXRcbiAqICAgICBzaG91bGQgYWJvcnQgdGhlIHJlcXVlc3Qgd2hlbiByZXNvbHZlZC5cbiAqICAgLSAqKmB3aXRoQ3JlZGVudGlhbHNgKiogLSBge2Jvb2xlYW59YCAtIHdoZXRoZXIgdG8gc2V0IHRoZSBgd2l0aENyZWRlbnRpYWxzYCBmbGFnIG9uIHRoZVxuICogICAgIFhIUiBvYmplY3QuIFNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vaHR0cF9hY2Nlc3NfY29udHJvbCNzZWN0aW9uXzVcbiAqICAgICByZXF1ZXN0cyB3aXRoIGNyZWRlbnRpYWxzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqICAgLSAqKmByZXNwb25zZVR5cGVgKiogLSBge3N0cmluZ31gIC0gc2VlIHtAbGlua1xuICogICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3Jlc3BvbnNlVHlwZSByZXF1ZXN0VHlwZX0uXG4gKiAgIC0gKipgaW50ZXJjZXB0b3JgKiogLSBge09iamVjdD19YCAtIFRoZSBpbnRlcmNlcHRvciBvYmplY3QgaGFzIHR3byBvcHRpb25hbCBtZXRob2RzIC1cbiAqICAgICBgcmVzcG9uc2VgIGFuZCBgcmVzcG9uc2VFcnJvcmAuIEJvdGggYHJlc3BvbnNlYCBhbmQgYHJlc3BvbnNlRXJyb3JgIGludGVyY2VwdG9ycyBnZXQgY2FsbGVkXG4gKiAgICAgd2l0aCBgaHR0cCByZXNwb25zZWAgb2JqZWN0LiBTZWUge0BsaW5rIG5nLiRodHRwICRodHRwIGludGVyY2VwdG9yc30uXG4gKlxuICogQHJldHVybnMge09iamVjdH0gQSByZXNvdXJjZSBcImNsYXNzXCIgb2JqZWN0IHdpdGggbWV0aG9kcyBmb3IgdGhlIGRlZmF1bHQgc2V0IG9mIHJlc291cmNlIGFjdGlvbnNcbiAqICAgb3B0aW9uYWxseSBleHRlbmRlZCB3aXRoIGN1c3RvbSBgYWN0aW9uc2AuIFRoZSBkZWZhdWx0IHNldCBjb250YWlucyB0aGVzZSBhY3Rpb25zOlxuICpcbiAqICAgICAgIHsgJ2dldCc6ICAgIHttZXRob2Q6J0dFVCd9LFxuICogICAgICAgICAnc2F2ZSc6ICAge21ldGhvZDonUE9TVCd9LFxuICogICAgICAgICAncXVlcnknOiAge21ldGhvZDonR0VUJywgaXNBcnJheTp0cnVlfSxcbiAqICAgICAgICAgJ3JlbW92ZSc6IHttZXRob2Q6J0RFTEVURSd9LFxuICogICAgICAgICAnZGVsZXRlJzoge21ldGhvZDonREVMRVRFJ30gfTtcbiAqXG4gKiAgIENhbGxpbmcgdGhlc2UgbWV0aG9kcyBpbnZva2UgYW4ge0BsaW5rIG5nLiRodHRwfSB3aXRoIHRoZSBzcGVjaWZpZWQgaHR0cCBtZXRob2QsXG4gKiAgIGRlc3RpbmF0aW9uIGFuZCBwYXJhbWV0ZXJzLiBXaGVuIHRoZSBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciB0aGVuIHRoZSBvYmplY3QgaXMgYW5cbiAqICAgaW5zdGFuY2Ugb2YgdGhlIHJlc291cmNlIGNsYXNzLiBUaGUgYWN0aW9ucyBgc2F2ZWAsIGByZW1vdmVgIGFuZCBgZGVsZXRlYCBhcmUgYXZhaWxhYmxlIG9uIGl0XG4gKiAgIGFzICBtZXRob2RzIHdpdGggdGhlIGAkYCBwcmVmaXguIFRoaXMgYWxsb3dzIHlvdSB0byBlYXNpbHkgcGVyZm9ybSBDUlVEIG9wZXJhdGlvbnMgKGNyZWF0ZSxcbiAqICAgcmVhZCwgdXBkYXRlLCBkZWxldGUpIG9uIHNlcnZlci1zaWRlIGRhdGEgbGlrZSB0aGlzOlxuICogICA8cHJlPlxuICAgICAgICB2YXIgVXNlciA9ICRyZXNvdXJjZSgnL3VzZXIvOnVzZXJJZCcsIHt1c2VySWQ6J0BpZCd9KTtcbiAgICAgICAgdmFyIHVzZXIgPSBVc2VyLmdldCh7dXNlcklkOjEyM30sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHVzZXIuYWJjID0gdHJ1ZTtcbiAgICAgICAgICB1c2VyLiRzYXZlKCk7XG4gICAgICAgIH0pO1xuICAgICA8L3ByZT5cbiAqXG4gKiAgIEl0IGlzIGltcG9ydGFudCB0byByZWFsaXplIHRoYXQgaW52b2tpbmcgYSAkcmVzb3VyY2Ugb2JqZWN0IG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFuXG4gKiAgIGVtcHR5IHJlZmVyZW5jZSAob2JqZWN0IG9yIGFycmF5IGRlcGVuZGluZyBvbiBgaXNBcnJheWApLiBPbmNlIHRoZSBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlXG4gKiAgIHNlcnZlciB0aGUgZXhpc3RpbmcgcmVmZXJlbmNlIGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBhY3R1YWwgZGF0YS4gVGhpcyBpcyBhIHVzZWZ1bCB0cmljayBzaW5jZVxuICogICB1c3VhbGx5IHRoZSByZXNvdXJjZSBpcyBhc3NpZ25lZCB0byBhIG1vZGVsIHdoaWNoIGlzIHRoZW4gcmVuZGVyZWQgYnkgdGhlIHZpZXcuIEhhdmluZyBhbiBlbXB0eVxuICogICBvYmplY3QgcmVzdWx0cyBpbiBubyByZW5kZXJpbmcsIG9uY2UgdGhlIGRhdGEgYXJyaXZlcyBmcm9tIHRoZSBzZXJ2ZXIgdGhlbiB0aGUgb2JqZWN0IGlzXG4gKiAgIHBvcHVsYXRlZCB3aXRoIHRoZSBkYXRhIGFuZCB0aGUgdmlldyBhdXRvbWF0aWNhbGx5IHJlLXJlbmRlcnMgaXRzZWxmIHNob3dpbmcgdGhlIG5ldyBkYXRhLiBUaGlzXG4gKiAgIG1lYW5zIHRoYXQgaW4gbW9zdCBjYXNlcyBvbmUgbmV2ZXIgaGFzIHRvIHdyaXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBhY3Rpb24gbWV0aG9kcy5cbiAqXG4gKiAgIFRoZSBhY3Rpb24gbWV0aG9kcyBvbiB0aGUgY2xhc3Mgb2JqZWN0IG9yIGluc3RhbmNlIG9iamVjdCBjYW4gYmUgaW52b2tlZCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqICAgcGFyYW1ldGVyczpcbiAqXG4gKiAgIC0gSFRUUCBHRVQgXCJjbGFzc1wiIGFjdGlvbnM6IGBSZXNvdXJjZS5hY3Rpb24oW3BhcmFtZXRlcnNdLCBbc3VjY2Vzc10sIFtlcnJvcl0pYFxuICogICAtIG5vbi1HRVQgXCJjbGFzc1wiIGFjdGlvbnM6IGBSZXNvdXJjZS5hY3Rpb24oW3BhcmFtZXRlcnNdLCBwb3N0RGF0YSwgW3N1Y2Nlc3NdLCBbZXJyb3JdKWBcbiAqICAgLSBub24tR0VUIGluc3RhbmNlIGFjdGlvbnM6ICBgaW5zdGFuY2UuJGFjdGlvbihbcGFyYW1ldGVyc10sIFtzdWNjZXNzXSwgW2Vycm9yXSlgXG4gKlxuICogICBTdWNjZXNzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoICh2YWx1ZSwgcmVzcG9uc2VIZWFkZXJzKSBhcmd1bWVudHMuIEVycm9yIGNhbGxiYWNrIGlzIGNhbGxlZFxuICogICB3aXRoIChodHRwUmVzcG9uc2UpIGFyZ3VtZW50LlxuICpcbiAqICAgQ2xhc3MgYWN0aW9ucyByZXR1cm4gZW1wdHkgaW5zdGFuY2UgKHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGJlbG93KS5cbiAqICAgSW5zdGFuY2UgYWN0aW9ucyByZXR1cm4gcHJvbWlzZSBvZiB0aGUgYWN0aW9uLlxuICpcbiAqICAgVGhlIFJlc291cmNlIGluc3RhbmNlcyBhbmQgY29sbGVjdGlvbiBoYXZlIHRoZXNlIGFkZGl0aW9uYWwgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYCRwcm9taXNlYDogdGhlIHtAbGluayBuZy4kcSBwcm9taXNlfSBvZiB0aGUgb3JpZ2luYWwgc2VydmVyIGludGVyYWN0aW9uIHRoYXQgY3JlYXRlZCB0aGlzXG4gKiAgICAgaW5zdGFuY2Ugb3IgY29sbGVjdGlvbi5cbiAqXG4gKiAgICAgT24gc3VjY2VzcywgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgc2FtZSByZXNvdXJjZSBpbnN0YW5jZSBvciBjb2xsZWN0aW9uIG9iamVjdCxcbiAqICAgICB1cGRhdGVkIHdpdGggZGF0YSBmcm9tIHNlcnZlci4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHVzZSBpblxuICogICAgIHtAbGluayBuZ1JvdXRlLiRyb3V0ZVByb3ZpZGVyIHJlc29sdmUgc2VjdGlvbiBvZiAkcm91dGVQcm92aWRlci53aGVuKCl9IHRvIGRlZmVyIHZpZXdcbiAqICAgICByZW5kZXJpbmcgdW50aWwgdGhlIHJlc291cmNlKHMpIGFyZSBsb2FkZWQuXG4gKlxuICogICAgIE9uIGZhaWx1cmUsIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHtAbGluayBuZy4kaHR0cCBodHRwIHJlc3BvbnNlfSBvYmplY3QsIHdpdGhvdXRcbiAqICAgICB0aGUgYHJlc291cmNlYCBwcm9wZXJ0eS5cbiAqXG4gKiAgIC0gYCRyZXNvbHZlZGA6IGB0cnVlYCBhZnRlciBmaXJzdCBzZXJ2ZXIgaW50ZXJhY3Rpb24gaXMgY29tcGxldGVkIChlaXRoZXIgd2l0aCBzdWNjZXNzIG9yXG4gKiAgICAgIHJlamVjdGlvbiksIGBmYWxzZWAgYmVmb3JlIHRoYXQuIEtub3dpbmcgaWYgdGhlIFJlc291cmNlIGhhcyBiZWVuIHJlc29sdmVkIGlzIHVzZWZ1bCBpblxuICogICAgICBkYXRhLWJpbmRpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAjIENyZWRpdCBjYXJkIHJlc291cmNlXG4gKlxuICogPHByZT5cbiAgICAgLy8gRGVmaW5lIENyZWRpdENhcmQgY2xhc3NcbiAgICAgdmFyIENyZWRpdENhcmQgPSAkcmVzb3VyY2UoJy91c2VyLzp1c2VySWQvY2FyZC86Y2FyZElkJyxcbiAgICAgIHt1c2VySWQ6MTIzLCBjYXJkSWQ6J0BpZCd9LCB7XG4gICAgICAgY2hhcmdlOiB7bWV0aG9kOidQT1NUJywgcGFyYW1zOntjaGFyZ2U6dHJ1ZX19XG4gICAgICB9KTtcblxuICAgICAvLyBXZSBjYW4gcmV0cmlldmUgYSBjb2xsZWN0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgICB2YXIgY2FyZHMgPSBDcmVkaXRDYXJkLnF1ZXJ5KGZ1bmN0aW9uKCkge1xuICAgICAgIC8vIEdFVDogL3VzZXIvMTIzL2NhcmRcbiAgICAgICAvLyBzZXJ2ZXIgcmV0dXJuczogWyB7aWQ6NDU2LCBudW1iZXI6JzEyMzQnLCBuYW1lOidTbWl0aCd9IF07XG5cbiAgICAgICB2YXIgY2FyZCA9IGNhcmRzWzBdO1xuICAgICAgIC8vIGVhY2ggaXRlbSBpcyBhbiBpbnN0YW5jZSBvZiBDcmVkaXRDYXJkXG4gICAgICAgZXhwZWN0KGNhcmQgaW5zdGFuY2VvZiBDcmVkaXRDYXJkKS50b0VxdWFsKHRydWUpO1xuICAgICAgIGNhcmQubmFtZSA9IFwiSi4gU21pdGhcIjtcbiAgICAgICAvLyBub24gR0VUIG1ldGhvZHMgYXJlIG1hcHBlZCBvbnRvIHRoZSBpbnN0YW5jZXNcbiAgICAgICBjYXJkLiRzYXZlKCk7XG4gICAgICAgLy8gUE9TVDogL3VzZXIvMTIzL2NhcmQvNDU2IHtpZDo0NTYsIG51bWJlcjonMTIzNCcsIG5hbWU6J0ouIFNtaXRoJ31cbiAgICAgICAvLyBzZXJ2ZXIgcmV0dXJuczoge2lkOjQ1NiwgbnVtYmVyOicxMjM0JywgbmFtZTogJ0ouIFNtaXRoJ307XG5cbiAgICAgICAvLyBvdXIgY3VzdG9tIG1ldGhvZCBpcyBtYXBwZWQgYXMgd2VsbC5cbiAgICAgICBjYXJkLiRjaGFyZ2Uoe2Ftb3VudDo5Ljk5fSk7XG4gICAgICAgLy8gUE9TVDogL3VzZXIvMTIzL2NhcmQvNDU2P2Ftb3VudD05Ljk5JmNoYXJnZT10cnVlIHtpZDo0NTYsIG51bWJlcjonMTIzNCcsIG5hbWU6J0ouIFNtaXRoJ31cbiAgICAgfSk7XG5cbiAgICAgLy8gd2UgY2FuIGNyZWF0ZSBhbiBpbnN0YW5jZSBhcyB3ZWxsXG4gICAgIHZhciBuZXdDYXJkID0gbmV3IENyZWRpdENhcmQoe251bWJlcjonMDEyMyd9KTtcbiAgICAgbmV3Q2FyZC5uYW1lID0gXCJNaWtlIFNtaXRoXCI7XG4gICAgIG5ld0NhcmQuJHNhdmUoKTtcbiAgICAgLy8gUE9TVDogL3VzZXIvMTIzL2NhcmQge251bWJlcjonMDEyMycsIG5hbWU6J01pa2UgU21pdGgnfVxuICAgICAvLyBzZXJ2ZXIgcmV0dXJuczoge2lkOjc4OSwgbnVtYmVyOicwMTIzJywgbmFtZTogJ01pa2UgU21pdGgnfTtcbiAgICAgZXhwZWN0KG5ld0NhcmQuaWQpLnRvRXF1YWwoNzg5KTtcbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uIGV4ZWN1dGlvbiBpcyBhIHJlc291cmNlIFwiY2xhc3NcIiB3aGljaCBoYXMgXCJzdGF0aWNcIiBtZXRob2RcbiAqIGZvciBlYWNoIGFjdGlvbiBpbiB0aGUgZGVmaW5pdGlvbi5cbiAqXG4gKiBDYWxsaW5nIHRoZXNlIG1ldGhvZHMgaW52b2tlIGAkaHR0cGAgb24gdGhlIGB1cmxgIHRlbXBsYXRlIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgLCBgcGFyYW1zYCBhbmRcbiAqIGBoZWFkZXJzYC5cbiAqIFdoZW4gdGhlIGRhdGEgaXMgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIHRoZW4gdGhlIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcmVzb3VyY2UgdHlwZSBhbmRcbiAqIGFsbCBvZiB0aGUgbm9uLUdFVCBtZXRob2RzIGFyZSBhdmFpbGFibGUgd2l0aCBgJGAgcHJlZml4LiBUaGlzIGFsbG93cyB5b3UgdG8gZWFzaWx5IHN1cHBvcnQgQ1JVRFxuICogb3BlcmF0aW9ucyAoY3JlYXRlLCByZWFkLCB1cGRhdGUsIGRlbGV0ZSkgb24gc2VydmVyLXNpZGUgZGF0YS5cblxuICAgPHByZT5cbiAgICAgdmFyIFVzZXIgPSAkcmVzb3VyY2UoJy91c2VyLzp1c2VySWQnLCB7dXNlcklkOidAaWQnfSk7XG4gICAgIHZhciB1c2VyID0gVXNlci5nZXQoe3VzZXJJZDoxMjN9LCBmdW5jdGlvbigpIHtcbiAgICAgICB1c2VyLmFiYyA9IHRydWU7XG4gICAgICAgdXNlci4kc2F2ZSgpO1xuICAgICB9KTtcbiAgIDwvcHJlPlxuICpcbiAqIEl0J3Mgd29ydGggbm90aW5nIHRoYXQgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgZm9yIGBnZXRgLCBgcXVlcnlgIGFuZCBvdGhlciBtZXRob2RzIGdldHMgcGFzc2VkXG4gKiBpbiB0aGUgcmVzcG9uc2UgdGhhdCBjYW1lIGZyb20gdGhlIHNlcnZlciBhcyB3ZWxsIGFzICRodHRwIGhlYWRlciBnZXR0ZXIgZnVuY3Rpb24sIHNvIG9uZVxuICogY291bGQgcmV3cml0ZSB0aGUgYWJvdmUgZXhhbXBsZSBhbmQgZ2V0IGFjY2VzcyB0byBodHRwIGhlYWRlcnMgYXM6XG4gKlxuICAgPHByZT5cbiAgICAgdmFyIFVzZXIgPSAkcmVzb3VyY2UoJy91c2VyLzp1c2VySWQnLCB7dXNlcklkOidAaWQnfSk7XG4gICAgIFVzZXIuZ2V0KHt1c2VySWQ6MTIzfSwgZnVuY3Rpb24odSwgZ2V0UmVzcG9uc2VIZWFkZXJzKXtcbiAgICAgICB1LmFiYyA9IHRydWU7XG4gICAgICAgdS4kc2F2ZShmdW5jdGlvbih1LCBwdXRSZXNwb25zZUhlYWRlcnMpIHtcbiAgICAgICAgIC8vdSA9PiBzYXZlZCB1c2VyIG9iamVjdFxuICAgICAgICAgLy9wdXRSZXNwb25zZUhlYWRlcnMgPT4gJGh0dHAgaGVhZGVyIGdldHRlclxuICAgICAgIH0pO1xuICAgICB9KTtcbiAgIDwvcHJlPlxuXG4gKiAjIENyZWF0aW5nIGEgY3VzdG9tICdQVVQnIHJlcXVlc3RcbiAqIEluIHRoaXMgZXhhbXBsZSB3ZSBjcmVhdGUgYSBjdXN0b20gbWV0aG9kIG9uIG91ciByZXNvdXJjZSB0byBtYWtlIGEgUFVUIHJlcXVlc3RcbiAqIDxwcmU+XG4gKlx0XHR2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsnbmdSZXNvdXJjZScsICduZ1JvdXRlJ10pO1xuICpcbiAqXHRcdC8vIFNvbWUgQVBJcyBleHBlY3QgYSBQVVQgcmVxdWVzdCBpbiB0aGUgZm9ybWF0IFVSTC9vYmplY3QvSURcbiAqXHRcdC8vIEhlcmUgd2UgYXJlIGNyZWF0aW5nIGFuICd1cGRhdGUnIG1ldGhvZCBcbiAqXHRcdGFwcC5mYWN0b3J5KCdOb3RlcycsIFsnJHJlc291cmNlJywgZnVuY3Rpb24oJHJlc291cmNlKSB7XG4gKiAgICByZXR1cm4gJHJlc291cmNlKCcvbm90ZXMvOmlkJywgbnVsbCxcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgICd1cGRhdGUnOiB7IG1ldGhvZDonUFVUJyB9XG4gKiAgICAgICAgfSk7XG4gKlx0XHR9XSk7XG4gKlxuICpcdFx0Ly8gSW4gb3VyIGNvbnRyb2xsZXIgd2UgZ2V0IHRoZSBJRCBmcm9tIHRoZSBVUkwgdXNpbmcgbmdSb3V0ZSBhbmQgJHJvdXRlUGFyYW1zXG4gKlx0XHQvLyBXZSBwYXNzIGluICRyb3V0ZVBhcmFtcyBhbmQgb3VyIE5vdGVzIGZhY3RvcnkgYWxvbmcgd2l0aCAkc2NvcGVcbiAqXHRcdGFwcC5jb250cm9sbGVyKCdOb3Rlc0N0cmwnLCBbJyRzY29wZScsICckcm91dGVQYXJhbXMnLCAnTm90ZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigkc2NvcGUsICRyb3V0ZVBhcmFtcywgTm90ZXMpIHtcbiAqICAgIC8vIEZpcnN0IGdldCBhIG5vdGUgb2JqZWN0IGZyb20gdGhlIGZhY3RvcnlcbiAqICAgIHZhciBub3RlID0gTm90ZXMuZ2V0KHsgaWQ6JHJvdXRlUGFyYW1zLmlkIH0pO1xuICogICAgJGlkID0gbm90ZS5pZDtcbiAqXG4gKiAgICAvLyBOb3cgY2FsbCB1cGRhdGUgcGFzc2luZyBpbiB0aGUgSUQgZmlyc3QgdGhlbiB0aGUgb2JqZWN0IHlvdSBhcmUgdXBkYXRpbmdcbiAqICAgIE5vdGVzLnVwZGF0ZSh7IGlkOiRpZCB9LCBub3RlKTtcbiAqXG4gKiAgICAvLyBUaGlzIHdpbGwgUFVUIC9ub3Rlcy9JRCB3aXRoIHRoZSBub3RlIG9iamVjdCBpbiB0aGUgcmVxdWVzdCBwYXlsb2FkXG4gKlx0XHR9XSk7XG4gKiA8L3ByZT5cbiAqL1xuYW5ndWxhci5tb2R1bGUoJ25nUmVzb3VyY2UnLCBbJ25nJ10pLlxuICBmYWN0b3J5KCckcmVzb3VyY2UnLCBbJyRodHRwJywgJyRxJywgZnVuY3Rpb24oJGh0dHAsICRxKSB7XG5cbiAgICB2YXIgREVGQVVMVF9BQ1RJT05TID0ge1xuICAgICAgJ2dldCc6ICAgIHttZXRob2Q6J0dFVCd9LFxuICAgICAgJ3NhdmUnOiAgIHttZXRob2Q6J1BPU1QnfSxcbiAgICAgICdxdWVyeSc6ICB7bWV0aG9kOidHRVQnLCBpc0FycmF5OnRydWV9LFxuICAgICAgJ3JlbW92ZSc6IHttZXRob2Q6J0RFTEVURSd9LFxuICAgICAgJ2RlbGV0ZSc6IHttZXRob2Q6J0RFTEVURSd9XG4gICAgfTtcbiAgICB2YXIgbm9vcCA9IGFuZ3VsYXIubm9vcCxcbiAgICAgICAgZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaCxcbiAgICAgICAgZXh0ZW5kID0gYW5ndWxhci5leHRlbmQsXG4gICAgICAgIGNvcHkgPSBhbmd1bGFyLmNvcHksXG4gICAgICAgIGlzRnVuY3Rpb24gPSBhbmd1bGFyLmlzRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIG91ciBjdXN0b20gbWV0aG9kIGJlY2F1c2UgZW5jb2RlVVJJQ29tcG9uZW50IGlzIHRvbyBhZ2dyZXNzaXZlIGFuZCBkb2Vzbid0IGZvbGxvd1xuICAgICAqIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzM5ODYudHh0IHdpdGggcmVnYXJkcyB0byB0aGUgY2hhcmFjdGVyIHNldCAocGNoYXIpIGFsbG93ZWQgaW4gcGF0aFxuICAgICAqIHNlZ21lbnRzOlxuICAgICAqICAgIHNlZ21lbnQgICAgICAgPSAqcGNoYXJcbiAgICAgKiAgICBwY2hhciAgICAgICAgID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICAgKiAgICBwY3QtZW5jb2RlZCAgID0gXCIlXCIgSEVYRElHIEhFWERJR1xuICAgICAqICAgIHVucmVzZXJ2ZWQgICAgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAgICAgKiAgICBzdWItZGVsaW1zICAgID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlTZWdtZW50KHZhbCkge1xuICAgICAgcmV0dXJuIGVuY29kZVVyaVF1ZXJ5KHZhbCwgdHJ1ZSkuXG4gICAgICAgIHJlcGxhY2UoLyUyNi9naSwgJyYnKS5cbiAgICAgICAgcmVwbGFjZSgvJTNEL2dpLCAnPScpLlxuICAgICAgICByZXBsYWNlKC8lMkIvZ2ksICcrJyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgZW5jb2RpbmcgKmtleSogb3IgKnZhbHVlKiBwYXJ0cyBvZiBxdWVyeSBjb21wb25lbnQuIFdlIG5lZWQgYVxuICAgICAqIGN1c3RvbSBtZXRob2QgYmVjYXVzZSBlbmNvZGVVUklDb21wb25lbnQgaXMgdG9vIGFnZ3Jlc3NpdmUgYW5kIGVuY29kZXMgc3R1ZmYgdGhhdCBkb2Vzbid0XG4gICAgICogaGF2ZSB0byBiZSBlbmNvZGVkIHBlciBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2OlxuICAgICAqICAgIHF1ZXJ5ICAgICAgID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAgKiAgICBwY2hhciAgICAgICAgID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICAgKiAgICB1bnJlc2VydmVkICAgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgICogICAgcGN0LWVuY29kZWQgICA9IFwiJVwiIEhFWERJRyBIRVhESUdcbiAgICAgKiAgICBzdWItZGVsaW1zICAgID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGVVcmlRdWVyeSh2YWwsIHBjdEVuY29kZVNwYWNlcykge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgICAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICAgICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICAgICAgcmVwbGFjZSgvJTIwL2csIChwY3RFbmNvZGVTcGFjZXMgPyAnJTIwJyA6ICcrJykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJvdXRlKHRlbXBsYXRlLCBkZWZhdWx0cykge1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzIHx8IHt9O1xuICAgICAgdGhpcy51cmxQYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICBSb3V0ZS5wcm90b3R5cGUgPSB7XG4gICAgICBzZXRVcmxQYXJhbXM6IGZ1bmN0aW9uKGNvbmZpZywgcGFyYW1zLCBhY3Rpb25VcmwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdXJsID0gYWN0aW9uVXJsIHx8IHNlbGYudGVtcGxhdGUsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlbmNvZGVkVmFsO1xuXG4gICAgICAgIHZhciB1cmxQYXJhbXMgPSBzZWxmLnVybFBhcmFtcyA9IHt9O1xuICAgICAgICBmb3JFYWNoKHVybC5zcGxpdCgvXFxXLyksIGZ1bmN0aW9uKHBhcmFtKXtcbiAgICAgICAgICBpZiAocGFyYW0gPT09ICdoYXNPd25Qcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIHRocm93ICRyZXNvdXJjZU1pbkVycignYmFkbmFtZScsIFwiaGFzT3duUHJvcGVydHkgaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyIG5hbWUuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShuZXcgUmVnRXhwKFwiXlxcXFxkKyRcIikudGVzdChwYXJhbSkpICYmIHBhcmFtICYmXG4gICAgICAgICAgICAgICAobmV3IFJlZ0V4cChcIihefFteXFxcXFxcXFxdKTpcIiArIHBhcmFtICsgXCIoXFxcXFd8JClcIikudGVzdCh1cmwpKSkge1xuICAgICAgICAgICAgdXJsUGFyYW1zW3BhcmFtXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL1xcXFw6L2csICc6Jyk7XG5cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICBmb3JFYWNoKHNlbGYudXJsUGFyYW1zLCBmdW5jdGlvbihfLCB1cmxQYXJhbSl7XG4gICAgICAgICAgdmFsID0gcGFyYW1zLmhhc093blByb3BlcnR5KHVybFBhcmFtKSA/IHBhcmFtc1t1cmxQYXJhbV0gOiBzZWxmLmRlZmF1bHRzW3VybFBhcmFtXTtcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodmFsKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGVuY29kZWRWYWwgPSBlbmNvZGVVcmlTZWdtZW50KHZhbCk7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShuZXcgUmVnRXhwKFwiOlwiICsgdXJsUGFyYW0gKyBcIihcXFxcV3wkKVwiLCBcImdcIiksIGVuY29kZWRWYWwgKyBcIiQxXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShuZXcgUmVnRXhwKFwiKFxcLz8pOlwiICsgdXJsUGFyYW0gKyBcIihcXFxcV3wkKVwiLCBcImdcIiksIGZ1bmN0aW9uKG1hdGNoLFxuICAgICAgICAgICAgICAgIGxlYWRpbmdTbGFzaGVzLCB0YWlsKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsLmNoYXJBdCgwKSA9PSAnLycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFpbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZ1NsYXNoZXMgKyB0YWlsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNsYXNoZXMgYW5kIHNldCB0aGUgdXJsXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9cXC8rJC8sICcnKTtcbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGNvbGxhcHNlIGAvLmAgaWYgZm91bmQgaW4gdGhlIGxhc3QgVVJMIHBhdGggc2VnbWVudCBiZWZvcmUgdGhlIHF1ZXJ5XG4gICAgICAgIC8vIEUuZy4gYGh0dHA6Ly91cmwuY29tL2lkLi9mb3JtYXQ/cT14YCBiZWNvbWVzIGBodHRwOi8vdXJsLmNvbS9pZC5mb3JtYXQ/cT14YFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvXFwuKD89XFx3KygkfFxcPykpLywgJy4nKTtcbiAgICAgICAgLy8gcmVwbGFjZSBlc2NhcGVkIGAvXFwuYCB3aXRoIGAvLmBcbiAgICAgICAgY29uZmlnLnVybCA9IHVybC5yZXBsYWNlKC9cXC9cXFxcXFwuLywgJy8uJyk7XG5cblxuICAgICAgICAvLyBzZXQgcGFyYW1zIC0gZGVsZWdhdGUgcGFyYW0gZW5jb2RpbmcgdG8gJGh0dHBcbiAgICAgICAgZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuICAgICAgICAgIGlmICghc2VsZi51cmxQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgY29uZmlnLnBhcmFtcyA9IGNvbmZpZy5wYXJhbXMgfHwge307XG4gICAgICAgICAgICBjb25maWcucGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIHJlc291cmNlRmFjdG9yeSh1cmwsIHBhcmFtRGVmYXVsdHMsIGFjdGlvbnMpIHtcbiAgICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZSh1cmwpO1xuXG4gICAgICBhY3Rpb25zID0gZXh0ZW5kKHt9LCBERUZBVUxUX0FDVElPTlMsIGFjdGlvbnMpO1xuXG4gICAgICBmdW5jdGlvbiBleHRyYWN0UGFyYW1zKGRhdGEsIGFjdGlvblBhcmFtcyl7XG4gICAgICAgIHZhciBpZHMgPSB7fTtcbiAgICAgICAgYWN0aW9uUGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbURlZmF1bHRzLCBhY3Rpb25QYXJhbXMpO1xuICAgICAgICBmb3JFYWNoKGFjdGlvblBhcmFtcywgZnVuY3Rpb24odmFsdWUsIGtleSl7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7IHZhbHVlID0gdmFsdWUoKTsgfVxuICAgICAgICAgIGlkc1trZXldID0gdmFsdWUgJiYgdmFsdWUuY2hhckF0ICYmIHZhbHVlLmNoYXJBdCgwKSA9PSAnQCcgP1xuICAgICAgICAgICAgbG9va3VwRG90dGVkUGF0aChkYXRhLCB2YWx1ZS5zdWJzdHIoMSkpIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWZhdWx0UmVzcG9uc2VJbnRlcmNlcHRvcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVzb3VyY2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJlc291cmNlKHZhbHVlKXtcbiAgICAgICAgc2hhbGxvd0NsZWFyQW5kQ29weSh2YWx1ZSB8fCB7fSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZvckVhY2goYWN0aW9ucywgZnVuY3Rpb24oYWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHZhciBoYXNCb2R5ID0gL14oUE9TVHxQVVR8UEFUQ0gpJC9pLnRlc3QoYWN0aW9uLm1ldGhvZCk7XG5cbiAgICAgICAgUmVzb3VyY2VbbmFtZV0gPSBmdW5jdGlvbihhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSB7fSwgZGF0YSwgc3VjY2VzcywgZXJyb3I7XG5cbiAgICAgICAgICAvKiBqc2hpbnQgLVcwODYgKi8gLyogKHB1cnBvc2VmdWxseSBmYWxsIHRocm91Z2ggY2FzZSBzdGF0ZW1lbnRzKSAqL1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZXJyb3IgPSBhNDtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBhMztcbiAgICAgICAgICAgIC8vZmFsbHRocm91Z2hcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYTIpKSB7XG4gICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGExKSkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBhMTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VjY2VzcyA9IGEyO1xuICAgICAgICAgICAgICBlcnJvciA9IGEzO1xuICAgICAgICAgICAgICAvL2ZhbGx0aHJvdWdoXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJhbXMgPSBhMTtcbiAgICAgICAgICAgICAgZGF0YSA9IGEyO1xuICAgICAgICAgICAgICBzdWNjZXNzID0gYTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGExKSkgc3VjY2VzcyA9IGExO1xuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQm9keSkgZGF0YSA9IGExO1xuICAgICAgICAgICAgZWxzZSBwYXJhbXMgPSBhMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDogYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICRyZXNvdXJjZU1pbkVycignYmFkYXJncycsXG4gICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdXAgdG8gNCBhcmd1bWVudHMgW3BhcmFtcywgZGF0YSwgc3VjY2VzcywgZXJyb3JdLCBnb3QgezB9IGFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoganNoaW50ICtXMDg2ICovIC8qIChwdXJwb3NlZnVsbHkgZmFsbCB0aHJvdWdoIGNhc2Ugc3RhdGVtZW50cykgKi9cblxuICAgICAgICAgIHZhciBpc0luc3RhbmNlQ2FsbCA9IHRoaXMgaW5zdGFuY2VvZiBSZXNvdXJjZTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpc0luc3RhbmNlQ2FsbCA/IGRhdGEgOiAoYWN0aW9uLmlzQXJyYXkgPyBbXSA6IG5ldyBSZXNvdXJjZShkYXRhKSk7XG4gICAgICAgICAgdmFyIGh0dHBDb25maWcgPSB7fTtcbiAgICAgICAgICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvciA9IGFjdGlvbi5pbnRlcmNlcHRvciAmJiBhY3Rpb24uaW50ZXJjZXB0b3IucmVzcG9uc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRSZXNwb25zZUludGVyY2VwdG9yO1xuICAgICAgICAgIHZhciByZXNwb25zZUVycm9ySW50ZXJjZXB0b3IgPSBhY3Rpb24uaW50ZXJjZXB0b3IgJiYgYWN0aW9uLmludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgICAgIGZvckVhY2goYWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9ICdwYXJhbXMnICYmIGtleSAhPSAnaXNBcnJheScgJiYga2V5ICE9ICdpbnRlcmNlcHRvcicpIHtcbiAgICAgICAgICAgICAgaHR0cENvbmZpZ1trZXldID0gY29weSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaGFzQm9keSkgaHR0cENvbmZpZy5kYXRhID0gZGF0YTtcbiAgICAgICAgICByb3V0ZS5zZXRVcmxQYXJhbXMoaHR0cENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHt9LCBleHRyYWN0UGFyYW1zKGRhdGEsIGFjdGlvbi5wYXJhbXMgfHwge30pLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24udXJsKTtcblxuICAgICAgICAgIHZhciBwcm9taXNlID0gJGh0dHAoaHR0cENvbmZpZykudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgICAgIHByb21pc2UgPSB2YWx1ZS4kcHJvbWlzZTtcblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgLy8gTmVlZCB0byBjb252ZXJ0IGFjdGlvbi5pc0FycmF5IHRvIGJvb2xlYW4gaW4gY2FzZSBpdCBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgLy8ganNoaW50IC1XMDE4XG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzQXJyYXkoZGF0YSkgIT09ICghIWFjdGlvbi5pc0FycmF5KSkge1xuICAgICAgICAgICAgICAgIHRocm93ICRyZXNvdXJjZU1pbkVycignYmFkY2ZnJywgJ0Vycm9yIGluIHJlc291cmNlIGNvbmZpZ3VyYXRpb24uIEV4cGVjdGVkICcgK1xuICAgICAgICAgICAgICAgICAgJ3Jlc3BvbnNlIHRvIGNvbnRhaW4gYW4gezB9IGJ1dCBnb3QgYW4gezF9JyxcbiAgICAgICAgICAgICAgICAgIGFjdGlvbi5pc0FycmF5PydhcnJheSc6J29iamVjdCcsIGFuZ3VsYXIuaXNBcnJheShkYXRhKT8nYXJyYXknOidvYmplY3QnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBqc2hpbnQgK1cwMThcbiAgICAgICAgICAgICAgaWYgKGFjdGlvbi5pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGRhdGEsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2gobmV3IFJlc291cmNlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93Q2xlYXJBbmRDb3B5KGRhdGEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS4kcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUuJHJlc29sdmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmVzcG9uc2UucmVzb3VyY2UgPSB2YWx1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YWx1ZS4kcmVzb2x2ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAoZXJyb3J8fG5vb3ApKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3BvbnNlSW50ZXJjZXB0b3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIChzdWNjZXNzfHxub29wKSh2YWx1ZSwgcmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXNwb25zZUVycm9ySW50ZXJjZXB0b3IpO1xuXG4gICAgICAgICAgaWYgKCFpc0luc3RhbmNlQ2FsbCkge1xuICAgICAgICAgICAgLy8gd2UgYXJlIGNyZWF0aW5nIGluc3RhbmNlIC8gY29sbGVjdGlvblxuICAgICAgICAgICAgLy8gLSBzZXQgdGhlIGluaXRpYWwgcHJvbWlzZVxuICAgICAgICAgICAgLy8gLSByZXR1cm4gdGhlIGluc3RhbmNlIC8gY29sbGVjdGlvblxuICAgICAgICAgICAgdmFsdWUuJHByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgdmFsdWUuJHJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpbnN0YW5jZSBjYWxsXG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG5cblxuICAgICAgICBSZXNvdXJjZS5wcm90b3R5cGVbJyQnICsgbmFtZV0gPSBmdW5jdGlvbihwYXJhbXMsIHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocGFyYW1zKSkge1xuICAgICAgICAgICAgZXJyb3IgPSBzdWNjZXNzOyBzdWNjZXNzID0gcGFyYW1zOyBwYXJhbXMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFJlc291cmNlW25hbWVdLmNhbGwodGhpcywgcGFyYW1zLCB0aGlzLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC4kcHJvbWlzZSB8fCByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgUmVzb3VyY2UuYmluZCA9IGZ1bmN0aW9uKGFkZGl0aW9uYWxQYXJhbURlZmF1bHRzKXtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlRmFjdG9yeSh1cmwsIGV4dGVuZCh7fSwgcGFyYW1EZWZhdWx0cywgYWRkaXRpb25hbFBhcmFtRGVmYXVsdHMpLCBhY3Rpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBSZXNvdXJjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb3VyY2VGYWN0b3J5O1xuICB9XSk7XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG5cbn0pLmNhbGwoZ2xvYmFsLCBtb2R1bGUsIHVuZGVmaW5lZCk7XG4iLCJ2YXIgZ2xvYmFsPXR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBkZWZpbmUpIHtcblxuOyByZXF1aXJlKFwiL1VzZXJzL3doZXJlc3JoeXMvU2l0ZXMvamlnc25yZWVscy9ib3dlcl9jb21wb25lbnRzL2FuZ3VsYXIvYW5ndWxhci5qc1wiKTtcbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhckpTIHYxLjIuNlxuICogKGMpIDIwMTAtMjAxNCBHb29nbGUsIEluYy4gaHR0cDovL2FuZ3VsYXJqcy5vcmdcbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24od2luZG93LCBhbmd1bGFyLCB1bmRlZmluZWQpIHsndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5nZG9jIG92ZXJ2aWV3XG4gKiBAbmFtZSBuZ1JvdXRlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiAjIG5nUm91dGVcbiAqXG4gKiBUaGUgYG5nUm91dGVgIG1vZHVsZSBwcm92aWRlcyByb3V0aW5nIGFuZCBkZWVwbGlua2luZyBzZXJ2aWNlcyBhbmQgZGlyZWN0aXZlcyBmb3IgYW5ndWxhciBhcHBzLlxuICpcbiAqICMjIEV4YW1wbGVcbiAqIFNlZSB7QGxpbmsgbmdSb3V0ZS4kcm91dGUjZXhhbXBsZSAkcm91dGV9IGZvciBhbiBleGFtcGxlIG9mIGNvbmZpZ3VyaW5nIGFuZCB1c2luZyBgbmdSb3V0ZWAuXG4gKiBcbiAqIHtAaW5zdGFsbE1vZHVsZSByb3V0ZX1cbiAqXG4gKiA8ZGl2IGRvYy1tb2R1bGUtY29tcG9uZW50cz1cIm5nUm91dGVcIj48L2Rpdj5cbiAqL1xuIC8qIGdsb2JhbCAtbmdSb3V0ZU1vZHVsZSAqL1xudmFyIG5nUm91dGVNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnbmdSb3V0ZScsIFsnbmcnXSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcignJHJvdXRlJywgJFJvdXRlUHJvdmlkZXIpO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nUm91dGUuJHJvdXRlUHJvdmlkZXJcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFVzZWQgZm9yIGNvbmZpZ3VyaW5nIHJvdXRlcy5cbiAqIFxuICogIyMgRXhhbXBsZVxuICogU2VlIHtAbGluayBuZ1JvdXRlLiRyb3V0ZSNleGFtcGxlICRyb3V0ZX0gZm9yIGFuIGV4YW1wbGUgb2YgY29uZmlndXJpbmcgYW5kIHVzaW5nIGBuZ1JvdXRlYC5cbiAqXG4gKiAjIyBEZXBlbmRlbmNpZXNcbiAqIFJlcXVpcmVzIHRoZSB7QGxpbmsgbmdSb3V0ZSBgbmdSb3V0ZWB9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXG4gKi9cbmZ1bmN0aW9uICRSb3V0ZVByb3ZpZGVyKCl7XG4gIGZ1bmN0aW9uIGluaGVyaXQocGFyZW50LCBleHRyYSkge1xuICAgIHJldHVybiBhbmd1bGFyLmV4dGVuZChuZXcgKGFuZ3VsYXIuZXh0ZW5kKGZ1bmN0aW9uKCkge30sIHtwcm90b3R5cGU6cGFyZW50fSkpKCksIGV4dHJhKTtcbiAgfVxuXG4gIHZhciByb3V0ZXMgPSB7fTtcblxuICAvKipcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSBuZ1JvdXRlLiRyb3V0ZVByb3ZpZGVyI3doZW5cbiAgICogQG1ldGhvZE9mIG5nUm91dGUuJHJvdXRlUHJvdmlkZXJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUm91dGUgcGF0aCAobWF0Y2hlZCBhZ2FpbnN0IGAkbG9jYXRpb24ucGF0aGApLiBJZiBgJGxvY2F0aW9uLnBhdGhgXG4gICAqICAgIGNvbnRhaW5zIHJlZHVuZGFudCB0cmFpbGluZyBzbGFzaCBvciBpcyBtaXNzaW5nIG9uZSwgdGhlIHJvdXRlIHdpbGwgc3RpbGwgbWF0Y2ggYW5kIHRoZVxuICAgKiAgICBgJGxvY2F0aW9uLnBhdGhgIHdpbGwgYmUgdXBkYXRlZCB0byBhZGQgb3IgZHJvcCB0aGUgdHJhaWxpbmcgc2xhc2ggdG8gZXhhY3RseSBtYXRjaCB0aGVcbiAgICogICAgcm91dGUgZGVmaW5pdGlvbi5cbiAgICpcbiAgICogICAgICAqIGBwYXRoYCBjYW4gY29udGFpbiBuYW1lZCBncm91cHMgc3RhcnRpbmcgd2l0aCBhIGNvbG9uOiBlLmcuIGA6bmFtZWAuIEFsbCBjaGFyYWN0ZXJzIHVwXG4gICAqICAgICAgICB0byB0aGUgbmV4dCBzbGFzaCBhcmUgbWF0Y2hlZCBhbmQgc3RvcmVkIGluIGAkcm91dGVQYXJhbXNgIHVuZGVyIHRoZSBnaXZlbiBgbmFtZWBcbiAgICogICAgICAgIHdoZW4gdGhlIHJvdXRlIG1hdGNoZXMuXG4gICAqICAgICAgKiBgcGF0aGAgY2FuIGNvbnRhaW4gbmFtZWQgZ3JvdXBzIHN0YXJ0aW5nIHdpdGggYSBjb2xvbiBhbmQgZW5kaW5nIHdpdGggYSBzdGFyOlxuICAgKiAgICAgICAgZS5nLmA6bmFtZSpgLiBBbGwgY2hhcmFjdGVycyBhcmUgZWFnZXJseSBzdG9yZWQgaW4gYCRyb3V0ZVBhcmFtc2AgdW5kZXIgdGhlIGdpdmVuIGBuYW1lYFxuICAgKiAgICAgICAgd2hlbiB0aGUgcm91dGUgbWF0Y2hlcy5cbiAgICogICAgICAqIGBwYXRoYCBjYW4gY29udGFpbiBvcHRpb25hbCBuYW1lZCBncm91cHMgd2l0aCBhIHF1ZXN0aW9uIG1hcms6IGUuZy5gOm5hbWU/YC5cbiAgICpcbiAgICogICAgRm9yIGV4YW1wbGUsIHJvdXRlcyBsaWtlIGAvY29sb3IvOmNvbG9yL2xhcmdlY29kZS86bGFyZ2Vjb2RlKlxcL2VkaXRgIHdpbGwgbWF0Y2hcbiAgICogICAgYC9jb2xvci9icm93bi9sYXJnZWNvZGUvY29kZS93aXRoL3NsYXNocy9lZGl0YCBhbmQgZXh0cmFjdDpcbiAgICpcbiAgICogICAgICAqIGBjb2xvcjogYnJvd25gXG4gICAqICAgICAgKiBgbGFyZ2Vjb2RlOiBjb2RlL3dpdGgvc2xhc2hzYC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJvdXRlIE1hcHBpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXNzaWduZWQgdG8gYCRyb3V0ZS5jdXJyZW50YCBvbiByb3V0ZVxuICAgKiAgICBtYXRjaC5cbiAgICpcbiAgICogICAgT2JqZWN0IHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgIC0gYGNvbnRyb2xsZXJgIOKAkyBgeyhzdHJpbmd8ZnVuY3Rpb24oKT19YCDigJMgQ29udHJvbGxlciBmbiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGhcbiAgICogICAgICBuZXdseSBjcmVhdGVkIHNjb3BlIG9yIHRoZSBuYW1lIG9mIGEge0BsaW5rIGFuZ3VsYXIuTW9kdWxlI2NvbnRyb2xsZXIgcmVnaXN0ZXJlZFxuICAgKiAgICAgIGNvbnRyb2xsZXJ9IGlmIHBhc3NlZCBhcyBhIHN0cmluZy5cbiAgICogICAgLSBgY29udHJvbGxlckFzYCDigJMgYHtzdHJpbmc9fWAg4oCTIEEgY29udHJvbGxlciBhbGlhcyBuYW1lLiBJZiBwcmVzZW50IHRoZSBjb250cm9sbGVyIHdpbGwgYmVcbiAgICogICAgICBwdWJsaXNoZWQgdG8gc2NvcGUgdW5kZXIgdGhlIGBjb250cm9sbGVyQXNgIG5hbWUuXG4gICAqICAgIC0gYHRlbXBsYXRlYCDigJMgYHtzdHJpbmc9fGZ1bmN0aW9uKCk9fWAg4oCTIGh0bWwgdGVtcGxhdGUgYXMgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0aGF0XG4gICAqICAgICAgcmV0dXJucyBhbiBodG1sIHRlbXBsYXRlIGFzIGEgc3RyaW5nIHdoaWNoIHNob3VsZCBiZSB1c2VkIGJ5IHtAbGlua1xuICAgKiAgICAgIG5nUm91dGUuZGlyZWN0aXZlOm5nVmlldyBuZ1ZpZXd9IG9yIHtAbGluayBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlIG5nSW5jbHVkZX0gZGlyZWN0aXZlcy5cbiAgICogICAgICBUaGlzIHByb3BlcnR5IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgdGVtcGxhdGVVcmxgLlxuICAgKlxuICAgKiAgICAgIElmIGB0ZW1wbGF0ZWAgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAqXG4gICAqICAgICAgLSBge0FycmF5LjxPYmplY3Q+fWAgLSByb3V0ZSBwYXJhbWV0ZXJzIGV4dHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50XG4gICAqICAgICAgICBgJGxvY2F0aW9uLnBhdGgoKWAgYnkgYXBwbHlpbmcgdGhlIGN1cnJlbnQgcm91dGVcbiAgICpcbiAgICogICAgLSBgdGVtcGxhdGVVcmxgIOKAkyBge3N0cmluZz18ZnVuY3Rpb24oKT19YCDigJMgcGF0aCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwYXRoIHRvIGFuIGh0bWxcbiAgICogICAgICB0ZW1wbGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGJ5IHtAbGluayBuZ1JvdXRlLmRpcmVjdGl2ZTpuZ1ZpZXcgbmdWaWV3fS5cbiAgICpcbiAgICogICAgICBJZiBgdGVtcGxhdGVVcmxgIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICAgIC0gYHtBcnJheS48T2JqZWN0Pn1gIC0gcm91dGUgcGFyYW1ldGVycyBleHRyYWN0ZWQgZnJvbSB0aGUgY3VycmVudFxuICAgKiAgICAgICAgYCRsb2NhdGlvbi5wYXRoKClgIGJ5IGFwcGx5aW5nIHRoZSBjdXJyZW50IHJvdXRlXG4gICAqXG4gICAqICAgIC0gYHJlc29sdmVgIC0gYHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24+PX1gIC0gQW4gb3B0aW9uYWwgbWFwIG9mIGRlcGVuZGVuY2llcyB3aGljaCBzaG91bGRcbiAgICogICAgICBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb250cm9sbGVyLiBJZiBhbnkgb2YgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSBwcm9taXNlcywgdGhlIHJvdXRlclxuICAgKiAgICAgIHdpbGwgd2FpdCBmb3IgdGhlbSBhbGwgdG8gYmUgcmVzb2x2ZWQgb3Igb25lIHRvIGJlIHJlamVjdGVkIGJlZm9yZSB0aGUgY29udHJvbGxlciBpc1xuICAgKiAgICAgIGluc3RhbnRpYXRlZC5cbiAgICogICAgICBJZiBhbGwgdGhlIHByb21pc2VzIGFyZSByZXNvbHZlZCBzdWNjZXNzZnVsbHksIHRoZSB2YWx1ZXMgb2YgdGhlIHJlc29sdmVkIHByb21pc2VzIGFyZVxuICAgKiAgICAgIGluamVjdGVkIGFuZCB7QGxpbmsgbmdSb3V0ZS4kcm91dGUjJHJvdXRlQ2hhbmdlU3VjY2VzcyAkcm91dGVDaGFuZ2VTdWNjZXNzfSBldmVudCBpc1xuICAgKiAgICAgIGZpcmVkLiBJZiBhbnkgb2YgdGhlIHByb21pc2VzIGFyZSByZWplY3RlZCB0aGVcbiAgICogICAgICB7QGxpbmsgbmdSb3V0ZS4kcm91dGUjJHJvdXRlQ2hhbmdlRXJyb3IgJHJvdXRlQ2hhbmdlRXJyb3J9IGV2ZW50IGlzIGZpcmVkLiBUaGUgbWFwIG9iamVjdFxuICAgKiAgICAgIGlzOlxuICAgKlxuICAgKiAgICAgIC0gYGtleWAg4oCTIGB7c3RyaW5nfWA6IGEgbmFtZSBvZiBhIGRlcGVuZGVuY3kgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgY29udHJvbGxlci5cbiAgICogICAgICAtIGBmYWN0b3J5YCAtIGB7c3RyaW5nfGZ1bmN0aW9ufWA6IElmIGBzdHJpbmdgIHRoZW4gaXQgaXMgYW4gYWxpYXMgZm9yIGEgc2VydmljZS5cbiAgICogICAgICAgIE90aGVyd2lzZSBpZiBmdW5jdGlvbiwgdGhlbiBpdCBpcyB7QGxpbmsgYXBpL0FVVE8uJGluamVjdG9yI2ludm9rZSBpbmplY3RlZH1cbiAgICogICAgICAgIGFuZCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRyZWF0ZWQgYXMgdGhlIGRlcGVuZGVuY3kuIElmIHRoZSByZXN1bHQgaXMgYSBwcm9taXNlLCBpdCBpc1xuICAgKiAgICAgICAgcmVzb2x2ZWQgYmVmb3JlIGl0cyB2YWx1ZSBpcyBpbmplY3RlZCBpbnRvIHRoZSBjb250cm9sbGVyLiBCZSBhd2FyZSB0aGF0XG4gICAqICAgICAgICBgbmdSb3V0ZS4kcm91dGVQYXJhbXNgIHdpbGwgc3RpbGwgcmVmZXIgdG8gdGhlIHByZXZpb3VzIHJvdXRlIHdpdGhpbiB0aGVzZSByZXNvbHZlXG4gICAqICAgICAgICBmdW5jdGlvbnMuICBVc2UgYCRyb3V0ZS5jdXJyZW50LnBhcmFtc2AgdG8gYWNjZXNzIHRoZSBuZXcgcm91dGUgcGFyYW1ldGVycywgaW5zdGVhZC5cbiAgICpcbiAgICogICAgLSBgcmVkaXJlY3RUb2Ag4oCTIHsoc3RyaW5nfGZ1bmN0aW9uKCkpPX0g4oCTIHZhbHVlIHRvIHVwZGF0ZVxuICAgKiAgICAgIHtAbGluayBuZy4kbG9jYXRpb24gJGxvY2F0aW9ufSBwYXRoIHdpdGggYW5kIHRyaWdnZXIgcm91dGUgcmVkaXJlY3Rpb24uXG4gICAqXG4gICAqICAgICAgSWYgYHJlZGlyZWN0VG9gIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICAgIC0gYHtPYmplY3QuPHN0cmluZz59YCAtIHJvdXRlIHBhcmFtZXRlcnMgZXh0cmFjdGVkIGZyb20gdGhlIGN1cnJlbnRcbiAgICogICAgICAgIGAkbG9jYXRpb24ucGF0aCgpYCBieSBhcHBseWluZyB0aGUgY3VycmVudCByb3V0ZSB0ZW1wbGF0ZVVybC5cbiAgICogICAgICAtIGB7c3RyaW5nfWAgLSBjdXJyZW50IGAkbG9jYXRpb24ucGF0aCgpYFxuICAgKiAgICAgIC0gYHtPYmplY3R9YCAtIGN1cnJlbnQgYCRsb2NhdGlvbi5zZWFyY2goKWBcbiAgICpcbiAgICogICAgICBUaGUgY3VzdG9tIGByZWRpcmVjdFRvYCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSBzdHJpbmcgd2hpY2ggd2lsbCBiZSB1c2VkXG4gICAqICAgICAgdG8gdXBkYXRlIGAkbG9jYXRpb24ucGF0aCgpYCBhbmQgYCRsb2NhdGlvbi5zZWFyY2goKWAuXG4gICAqXG4gICAqICAgIC0gYFtyZWxvYWRPblNlYXJjaD10cnVlXWAgLSB7Ym9vbGVhbj19IC0gcmVsb2FkIHJvdXRlIHdoZW4gb25seSBgJGxvY2F0aW9uLnNlYXJjaCgpYFxuICAgKiAgICAgIG9yIGAkbG9jYXRpb24uaGFzaCgpYCBjaGFuZ2VzLlxuICAgKlxuICAgKiAgICAgIElmIHRoZSBvcHRpb24gaXMgc2V0IHRvIGBmYWxzZWAgYW5kIHVybCBpbiB0aGUgYnJvd3NlciBjaGFuZ2VzLCB0aGVuXG4gICAqICAgICAgYCRyb3V0ZVVwZGF0ZWAgZXZlbnQgaXMgYnJvYWRjYXN0ZWQgb24gdGhlIHJvb3Qgc2NvcGUuXG4gICAqXG4gICAqICAgIC0gYFtjYXNlSW5zZW5zaXRpdmVNYXRjaD1mYWxzZV1gIC0ge2Jvb2xlYW49fSAtIG1hdGNoIHJvdXRlcyB3aXRob3V0IGJlaW5nIGNhc2Ugc2Vuc2l0aXZlXG4gICAqXG4gICAqICAgICAgSWYgdGhlIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLCB0aGVuIHRoZSBwYXJ0aWN1bGFyIHJvdXRlIGNhbiBiZSBtYXRjaGVkIHdpdGhvdXQgYmVpbmdcbiAgICogICAgICBjYXNlIHNlbnNpdGl2ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzZWxmXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBZGRzIGEgbmV3IHJvdXRlIGRlZmluaXRpb24gdG8gdGhlIGAkcm91dGVgIHNlcnZpY2UuXG4gICAqL1xuICB0aGlzLndoZW4gPSBmdW5jdGlvbihwYXRoLCByb3V0ZSkge1xuICAgIHJvdXRlc1twYXRoXSA9IGFuZ3VsYXIuZXh0ZW5kKFxuICAgICAge3JlbG9hZE9uU2VhcmNoOiB0cnVlfSxcbiAgICAgIHJvdXRlLFxuICAgICAgcGF0aCAmJiBwYXRoUmVnRXhwKHBhdGgsIHJvdXRlKVxuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgcmVkaXJlY3Rpb24gZm9yIHRyYWlsaW5nIHNsYXNoZXNcbiAgICBpZiAocGF0aCkge1xuICAgICAgdmFyIHJlZGlyZWN0UGF0aCA9IChwYXRoW3BhdGgubGVuZ3RoLTFdID09ICcvJylcbiAgICAgICAgICAgID8gcGF0aC5zdWJzdHIoMCwgcGF0aC5sZW5ndGgtMSlcbiAgICAgICAgICAgIDogcGF0aCArJy8nO1xuXG4gICAgICByb3V0ZXNbcmVkaXJlY3RQYXRoXSA9IGFuZ3VsYXIuZXh0ZW5kKFxuICAgICAgICB7cmVkaXJlY3RUbzogcGF0aH0sXG4gICAgICAgIHBhdGhSZWdFeHAocmVkaXJlY3RQYXRoLCByb3V0ZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgIC8qKlxuICAgICogQHBhcmFtIHBhdGgge3N0cmluZ30gcGF0aFxuICAgICogQHBhcmFtIG9wdHMge09iamVjdH0gb3B0aW9uc1xuICAgICogQHJldHVybiB7P09iamVjdH1cbiAgICAqXG4gICAgKiBAZGVzY3JpcHRpb25cbiAgICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGgsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICogYW5kIHRoZSBvcmlnaW5hbCBwYXRoLlxuICAgICpcbiAgICAqIEluc3BpcmVkIGJ5IHBhdGhSZXhwIGluIHZpc2lvbm1lZGlhL2V4cHJlc3MvbGliL3V0aWxzLmpzLlxuICAgICovXG4gIGZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0aCwgb3B0cykge1xuICAgIHZhciBpbnNlbnNpdGl2ZSA9IG9wdHMuY2FzZUluc2Vuc2l0aXZlTWF0Y2gsXG4gICAgICAgIHJldCA9IHtcbiAgICAgICAgICBvcmlnaW5hbFBhdGg6IHBhdGgsXG4gICAgICAgICAgcmVnZXhwOiBwYXRoXG4gICAgICAgIH0sXG4gICAgICAgIGtleXMgPSByZXQua2V5cyA9IFtdO1xuXG4gICAgcGF0aCA9IHBhdGhcbiAgICAgIC5yZXBsYWNlKC8oWygpLl0pL2csICdcXFxcJDEnKVxuICAgICAgLnJlcGxhY2UoLyhcXC8pPzooXFx3KykoW1xcP3xcXCpdKT8vZywgZnVuY3Rpb24oXywgc2xhc2gsIGtleSwgb3B0aW9uKXtcbiAgICAgICAgdmFyIG9wdGlvbmFsID0gb3B0aW9uID09PSAnPycgPyBvcHRpb24gOiBudWxsO1xuICAgICAgICB2YXIgc3RhciA9IG9wdGlvbiA9PT0gJyonID8gb3B0aW9uIDogbnVsbDtcbiAgICAgICAga2V5cy5wdXNoKHsgbmFtZToga2V5LCBvcHRpb25hbDogISFvcHRpb25hbCB9KTtcbiAgICAgICAgc2xhc2ggPSBzbGFzaCB8fCAnJztcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgKyAob3B0aW9uYWwgPyAnJyA6IHNsYXNoKVxuICAgICAgICAgICsgJyg/OidcbiAgICAgICAgICArIChvcHRpb25hbCA/IHNsYXNoIDogJycpXG4gICAgICAgICAgKyAoc3RhciAmJiAnKC4rPyknIHx8ICcoW14vXSspJylcbiAgICAgICAgICArIChvcHRpb25hbCB8fCAnJylcbiAgICAgICAgICArICcpJ1xuICAgICAgICAgICsgKG9wdGlvbmFsIHx8ICcnKTtcbiAgICAgIH0pXG4gICAgICAucmVwbGFjZSgvKFtcXC8kXFwqXSkvZywgJ1xcXFwkMScpO1xuXG4gICAgcmV0LnJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcGF0aCArICckJywgaW5zZW5zaXRpdmUgPyAnaScgOiAnJyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lIG5nUm91dGUuJHJvdXRlUHJvdmlkZXIjb3RoZXJ3aXNlXG4gICAqIEBtZXRob2RPZiBuZ1JvdXRlLiRyb3V0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHJvdXRlIGRlZmluaXRpb24gdGhhdCB3aWxsIGJlIHVzZWQgb24gcm91dGUgY2hhbmdlIHdoZW4gbm8gb3RoZXIgcm91dGUgZGVmaW5pdGlvblxuICAgKiBpcyBtYXRjaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIE1hcHBpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXNzaWduZWQgdG8gYCRyb3V0ZS5jdXJyZW50YC5cbiAgICogQHJldHVybnMge09iamVjdH0gc2VsZlxuICAgKi9cbiAgdGhpcy5vdGhlcndpc2UgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB0aGlzLndoZW4obnVsbCwgcGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIHRoaXMuJGdldCA9IFsnJHJvb3RTY29wZScsXG4gICAgICAgICAgICAgICAnJGxvY2F0aW9uJyxcbiAgICAgICAgICAgICAgICckcm91dGVQYXJhbXMnLFxuICAgICAgICAgICAgICAgJyRxJyxcbiAgICAgICAgICAgICAgICckaW5qZWN0b3InLFxuICAgICAgICAgICAgICAgJyRodHRwJyxcbiAgICAgICAgICAgICAgICckdGVtcGxhdGVDYWNoZScsXG4gICAgICAgICAgICAgICAnJHNjZScsXG4gICAgICBmdW5jdGlvbigkcm9vdFNjb3BlLCAkbG9jYXRpb24sICRyb3V0ZVBhcmFtcywgJHEsICRpbmplY3RvciwgJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkc2NlKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAgICogQG5hbWUgbmdSb3V0ZS4kcm91dGVcbiAgICAgKiBAcmVxdWlyZXMgJGxvY2F0aW9uXG4gICAgICogQHJlcXVpcmVzICRyb3V0ZVBhcmFtc1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGN1cnJlbnQgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHJvdXRlIGRlZmluaXRpb24uXG4gICAgICogVGhlIHJvdXRlIGRlZmluaXRpb24gY29udGFpbnM6XG4gICAgICpcbiAgICAgKiAgIC0gYGNvbnRyb2xsZXJgOiBUaGUgY29udHJvbGxlciBjb25zdHJ1Y3RvciBhcyBkZWZpbmUgaW4gcm91dGUgZGVmaW5pdGlvbi5cbiAgICAgKiAgIC0gYGxvY2Fsc2A6IEEgbWFwIG9mIGxvY2FscyB3aGljaCBpcyB1c2VkIGJ5IHtAbGluayBuZy4kY29udHJvbGxlciAkY29udHJvbGxlcn0gc2VydmljZSBmb3JcbiAgICAgKiAgICAgY29udHJvbGxlciBpbnN0YW50aWF0aW9uLiBUaGUgYGxvY2Fsc2AgY29udGFpblxuICAgICAqICAgICB0aGUgcmVzb2x2ZWQgdmFsdWVzIG9mIHRoZSBgcmVzb2x2ZWAgbWFwLiBBZGRpdGlvbmFsbHkgdGhlIGBsb2NhbHNgIGFsc28gY29udGFpbjpcbiAgICAgKlxuICAgICAqICAgICAtIGAkc2NvcGVgIC0gVGhlIGN1cnJlbnQgcm91dGUgc2NvcGUuXG4gICAgICogICAgIC0gYCR0ZW1wbGF0ZWAgLSBUaGUgY3VycmVudCByb3V0ZSB0ZW1wbGF0ZSBIVE1MLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtBcnJheS48T2JqZWN0Pn0gcm91dGVzIEFycmF5IG9mIGFsbCBjb25maWd1cmVkIHJvdXRlcy5cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGAkcm91dGVgIGlzIHVzZWQgZm9yIGRlZXAtbGlua2luZyBVUkxzIHRvIGNvbnRyb2xsZXJzIGFuZCB2aWV3cyAoSFRNTCBwYXJ0aWFscykuXG4gICAgICogSXQgd2F0Y2hlcyBgJGxvY2F0aW9uLnVybCgpYCBhbmQgdHJpZXMgdG8gbWFwIHRoZSBwYXRoIHRvIGFuIGV4aXN0aW5nIHJvdXRlIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBSZXF1aXJlcyB0aGUge0BsaW5rIG5nUm91dGUgYG5nUm91dGVgfSBtb2R1bGUgdG8gYmUgaW5zdGFsbGVkLlxuICAgICAqXG4gICAgICogWW91IGNhbiBkZWZpbmUgcm91dGVzIHRocm91Z2gge0BsaW5rIG5nUm91dGUuJHJvdXRlUHJvdmlkZXIgJHJvdXRlUHJvdmlkZXJ9J3MgQVBJLlxuICAgICAqXG4gICAgICogVGhlIGAkcm91dGVgIHNlcnZpY2UgaXMgdHlwaWNhbGx5IHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGVcbiAgICAgKiB7QGxpbmsgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3IGBuZ1ZpZXdgfSBkaXJlY3RpdmUgYW5kIHRoZVxuICAgICAqIHtAbGluayBuZ1JvdXRlLiRyb3V0ZVBhcmFtcyBgJHJvdXRlUGFyYW1zYH0gc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICAgVGhpcyBleGFtcGxlIHNob3dzIGhvdyBjaGFuZ2luZyB0aGUgVVJMIGhhc2ggY2F1c2VzIHRoZSBgJHJvdXRlYCB0byBtYXRjaCBhIHJvdXRlIGFnYWluc3QgdGhlXG4gICAgICAgVVJMLCBhbmQgdGhlIGBuZ1ZpZXdgIHB1bGxzIGluIHRoZSBwYXJ0aWFsLlxuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZXhhbXBsZSBpcyB1c2luZyB7QGxpbmsgbmcuZGlyZWN0aXZlOnNjcmlwdCBpbmxpbmVkIHRlbXBsYXRlc31cbiAgICAgICB0byBnZXQgaXQgd29ya2luZyBvbiBqc2ZpZGRsZSBhcyB3ZWxsLlxuXG4gICAgIDxleGFtcGxlIG1vZHVsZT1cIm5nVmlld0V4YW1wbGVcIiBkZXBzPVwiYW5ndWxhci1yb3V0ZS5qc1wiPlxuICAgICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJNYWluQ250bFwiPlxuICAgICAgICAgICBDaG9vc2U6XG4gICAgICAgICAgIDxhIGhyZWY9XCJCb29rL01vYnlcIj5Nb2J5PC9hPiB8XG4gICAgICAgICAgIDxhIGhyZWY9XCJCb29rL01vYnkvY2gvMVwiPk1vYnk6IENoMTwvYT4gfFxuICAgICAgICAgICA8YSBocmVmPVwiQm9vay9HYXRzYnlcIj5HYXRzYnk8L2E+IHxcbiAgICAgICAgICAgPGEgaHJlZj1cIkJvb2svR2F0c2J5L2NoLzQ/a2V5PXZhbHVlXCI+R2F0c2J5OiBDaDQ8L2E+IHxcbiAgICAgICAgICAgPGEgaHJlZj1cIkJvb2svU2NhcmxldFwiPlNjYXJsZXQgTGV0dGVyPC9hPjxici8+XG5cbiAgICAgICAgICAgPGRpdiBuZy12aWV3PjwvZGl2PlxuICAgICAgICAgICA8aHIgLz5cblxuICAgICAgICAgICA8cHJlPiRsb2NhdGlvbi5wYXRoKCkgPSB7eyRsb2NhdGlvbi5wYXRoKCl9fTwvcHJlPlxuICAgICAgICAgICA8cHJlPiRyb3V0ZS5jdXJyZW50LnRlbXBsYXRlVXJsID0ge3skcm91dGUuY3VycmVudC50ZW1wbGF0ZVVybH19PC9wcmU+XG4gICAgICAgICAgIDxwcmU+JHJvdXRlLmN1cnJlbnQucGFyYW1zID0ge3skcm91dGUuY3VycmVudC5wYXJhbXN9fTwvcHJlPlxuICAgICAgICAgICA8cHJlPiRyb3V0ZS5jdXJyZW50LnNjb3BlLm5hbWUgPSB7eyRyb3V0ZS5jdXJyZW50LnNjb3BlLm5hbWV9fTwvcHJlPlxuICAgICAgICAgICA8cHJlPiRyb3V0ZVBhcmFtcyA9IHt7JHJvdXRlUGFyYW1zfX08L3ByZT5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgIDwvZmlsZT5cblxuICAgICAgIDxmaWxlIG5hbWU9XCJib29rLmh0bWxcIj5cbiAgICAgICAgIGNvbnRyb2xsZXI6IHt7bmFtZX19PGJyIC8+XG4gICAgICAgICBCb29rIElkOiB7e3BhcmFtcy5ib29rSWR9fTxiciAvPlxuICAgICAgIDwvZmlsZT5cblxuICAgICAgIDxmaWxlIG5hbWU9XCJjaGFwdGVyLmh0bWxcIj5cbiAgICAgICAgIGNvbnRyb2xsZXI6IHt7bmFtZX19PGJyIC8+XG4gICAgICAgICBCb29rIElkOiB7e3BhcmFtcy5ib29rSWR9fTxiciAvPlxuICAgICAgICAgQ2hhcHRlciBJZDoge3twYXJhbXMuY2hhcHRlcklkfX1cbiAgICAgICA8L2ZpbGU+XG5cbiAgICAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICAgICBhbmd1bGFyLm1vZHVsZSgnbmdWaWV3RXhhbXBsZScsIFsnbmdSb3V0ZSddKVxuXG4gICAgICAgICAuY29uZmlnKGZ1bmN0aW9uKCRyb3V0ZVByb3ZpZGVyLCAkbG9jYXRpb25Qcm92aWRlcikge1xuICAgICAgICAgICAkcm91dGVQcm92aWRlci53aGVuKCcvQm9vay86Ym9va0lkJywge1xuICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYm9vay5odG1sJyxcbiAgICAgICAgICAgICBjb250cm9sbGVyOiBCb29rQ250bCxcbiAgICAgICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICAgICAvLyBJIHdpbGwgY2F1c2UgYSAxIHNlY29uZCBkZWxheVxuICAgICAgICAgICAgICAgZGVsYXk6IGZ1bmN0aW9uKCRxLCAkdGltZW91dCkge1xuICAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgICAgICAkdGltZW91dChkZWxheS5yZXNvbHZlLCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5LnByb21pc2U7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgJHJvdXRlUHJvdmlkZXIud2hlbignL0Jvb2svOmJvb2tJZC9jaC86Y2hhcHRlcklkJywge1xuICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY2hhcHRlci5odG1sJyxcbiAgICAgICAgICAgICBjb250cm9sbGVyOiBDaGFwdGVyQ250bFxuICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAvLyBjb25maWd1cmUgaHRtbDUgdG8gZ2V0IGxpbmtzIHdvcmtpbmcgb24ganNmaWRkbGVcbiAgICAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpO1xuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGZ1bmN0aW9uIE1haW5DbnRsKCRzY29wZSwgJHJvdXRlLCAkcm91dGVQYXJhbXMsICRsb2NhdGlvbikge1xuICAgICAgICAgICAkc2NvcGUuJHJvdXRlID0gJHJvdXRlO1xuICAgICAgICAgICAkc2NvcGUuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgICAgICAgICAkc2NvcGUuJHJvdXRlUGFyYW1zID0gJHJvdXRlUGFyYW1zO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmdW5jdGlvbiBCb29rQ250bCgkc2NvcGUsICRyb3V0ZVBhcmFtcykge1xuICAgICAgICAgICAkc2NvcGUubmFtZSA9IFwiQm9va0NudGxcIjtcbiAgICAgICAgICAgJHNjb3BlLnBhcmFtcyA9ICRyb3V0ZVBhcmFtcztcbiAgICAgICAgIH1cblxuICAgICAgICAgZnVuY3Rpb24gQ2hhcHRlckNudGwoJHNjb3BlLCAkcm91dGVQYXJhbXMpIHtcbiAgICAgICAgICAgJHNjb3BlLm5hbWUgPSBcIkNoYXB0ZXJDbnRsXCI7XG4gICAgICAgICAgICRzY29wZS5wYXJhbXMgPSAkcm91dGVQYXJhbXM7XG4gICAgICAgICB9XG4gICAgICAgPC9maWxlPlxuXG4gICAgICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gICAgICAgICBpdCgnc2hvdWxkIGxvYWQgYW5kIGNvbXBpbGUgY29ycmVjdCB0ZW1wbGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBlbGVtZW50KCdhOmNvbnRhaW5zKFwiTW9ieTogQ2gxXCIpJykuY2xpY2soKTtcbiAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctdmlld10nKS50ZXh0KCk7XG4gICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9jb250cm9sbGVyXFw6IENoYXB0ZXJDbnRsLyk7XG4gICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9Cb29rIElkXFw6IE1vYnkvKTtcbiAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvTWF0Y2goL0NoYXB0ZXIgSWRcXDogMS8pO1xuXG4gICAgICAgICAgIGVsZW1lbnQoJ2E6Y29udGFpbnMoXCJTY2FybGV0XCIpJykuY2xpY2soKTtcbiAgICAgICAgICAgc2xlZXAoMik7IC8vIHByb21pc2VzIGFyZSBub3QgcGFydCBvZiBzY2VuYXJpbyB3YWl0aW5nXG4gICAgICAgICAgIGNvbnRlbnQgPSBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctdmlld10nKS50ZXh0KCk7XG4gICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9jb250cm9sbGVyXFw6IEJvb2tDbnRsLyk7XG4gICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9Cb29rIElkXFw6IFNjYXJsZXQvKTtcbiAgICAgICAgIH0pO1xuICAgICAgIDwvZmlsZT5cbiAgICAgPC9leGFtcGxlPlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGV2ZW50XG4gICAgICogQG5hbWUgbmdSb3V0ZS4kcm91dGUjJHJvdXRlQ2hhbmdlU3RhcnRcbiAgICAgKiBAZXZlbnRPZiBuZ1JvdXRlLiRyb3V0ZVxuICAgICAqIEBldmVudFR5cGUgYnJvYWRjYXN0IG9uIHJvb3Qgc2NvcGVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBCcm9hZGNhc3RlZCBiZWZvcmUgYSByb3V0ZSBjaGFuZ2UuIEF0IHRoaXMgIHBvaW50IHRoZSByb3V0ZSBzZXJ2aWNlcyBzdGFydHNcbiAgICAgKiByZXNvbHZpbmcgYWxsIG9mIHRoZSBkZXBlbmRlbmNpZXMgbmVlZGVkIGZvciB0aGUgcm91dGUgY2hhbmdlIHRvIG9jY3Vycy5cbiAgICAgKiBUeXBpY2FsbHkgdGhpcyBpbnZvbHZlcyBmZXRjaGluZyB0aGUgdmlldyB0ZW1wbGF0ZSBhcyB3ZWxsIGFzIGFueSBkZXBlbmRlbmNpZXNcbiAgICAgKiBkZWZpbmVkIGluIGByZXNvbHZlYCByb3V0ZSBwcm9wZXJ0eS4gT25jZSAgYWxsIG9mIHRoZSBkZXBlbmRlbmNpZXMgYXJlIHJlc29sdmVkXG4gICAgICogYCRyb3V0ZUNoYW5nZVN1Y2Nlc3NgIGlzIGZpcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFuZ3VsYXJFdmVudCBTeW50aGV0aWMgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Um91dGV9IG5leHQgRnV0dXJlIHJvdXRlIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7Um91dGV9IGN1cnJlbnQgQ3VycmVudCByb3V0ZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAqIEBuYW1lIG5nUm91dGUuJHJvdXRlIyRyb3V0ZUNoYW5nZVN1Y2Nlc3NcbiAgICAgKiBAZXZlbnRPZiBuZ1JvdXRlLiRyb3V0ZVxuICAgICAqIEBldmVudFR5cGUgYnJvYWRjYXN0IG9uIHJvb3Qgc2NvcGVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBCcm9hZGNhc3RlZCBhZnRlciBhIHJvdXRlIGRlcGVuZGVuY2llcyBhcmUgcmVzb2x2ZWQuXG4gICAgICoge0BsaW5rIG5nUm91dGUuZGlyZWN0aXZlOm5nVmlldyBuZ1ZpZXd9IGxpc3RlbnMgZm9yIHRoZSBkaXJlY3RpdmVcbiAgICAgKiB0byBpbnN0YW50aWF0ZSB0aGUgY29udHJvbGxlciBhbmQgcmVuZGVyIHRoZSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFuZ3VsYXJFdmVudCBTeW50aGV0aWMgZXZlbnQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Um91dGV9IGN1cnJlbnQgQ3VycmVudCByb3V0ZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge1JvdXRlfFVuZGVmaW5lZH0gcHJldmlvdXMgUHJldmlvdXMgcm91dGUgaW5mb3JtYXRpb24sIG9yIHVuZGVmaW5lZCBpZiBjdXJyZW50IGlzXG4gICAgICogZmlyc3Qgcm91dGUgZW50ZXJlZC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAqIEBuYW1lIG5nUm91dGUuJHJvdXRlIyRyb3V0ZUNoYW5nZUVycm9yXG4gICAgICogQGV2ZW50T2YgbmdSb3V0ZS4kcm91dGVcbiAgICAgKiBAZXZlbnRUeXBlIGJyb2FkY2FzdCBvbiByb290IHNjb3BlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQnJvYWRjYXN0ZWQgaWYgYW55IG9mIHRoZSByZXNvbHZlIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmd1bGFyRXZlbnQgU3ludGhldGljIGV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7Um91dGV9IGN1cnJlbnQgQ3VycmVudCByb3V0ZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge1JvdXRlfSBwcmV2aW91cyBQcmV2aW91cyByb3V0ZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge1JvdXRlfSByZWplY3Rpb24gUmVqZWN0aW9uIG9mIHRoZSBwcm9taXNlLiBVc3VhbGx5IHRoZSBlcnJvciBvZiB0aGUgZmFpbGVkIHByb21pc2UuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZXZlbnRcbiAgICAgKiBAbmFtZSBuZ1JvdXRlLiRyb3V0ZSMkcm91dGVVcGRhdGVcbiAgICAgKiBAZXZlbnRPZiBuZ1JvdXRlLiRyb3V0ZVxuICAgICAqIEBldmVudFR5cGUgYnJvYWRjYXN0IG9uIHJvb3Qgc2NvcGVcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFRoZSBgcmVsb2FkT25TZWFyY2hgIHByb3BlcnR5IGhhcyBiZWVuIHNldCB0byBmYWxzZSwgYW5kIHdlIGFyZSByZXVzaW5nIHRoZSBzYW1lXG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIENvbnRyb2xsZXIuXG4gICAgICovXG5cbiAgICB2YXIgZm9yY2VSZWxvYWQgPSBmYWxzZSxcbiAgICAgICAgJHJvdXRlID0ge1xuICAgICAgICAgIHJvdXRlczogcm91dGVzLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgICAqIEBuYW1lIG5nUm91dGUuJHJvdXRlI3JlbG9hZFxuICAgICAgICAgICAqIEBtZXRob2RPZiBuZ1JvdXRlLiRyb3V0ZVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogQ2F1c2VzIGAkcm91dGVgIHNlcnZpY2UgdG8gcmVsb2FkIHRoZSBjdXJyZW50IHJvdXRlIGV2ZW4gaWZcbiAgICAgICAgICAgKiB7QGxpbmsgbmcuJGxvY2F0aW9uICRsb2NhdGlvbn0gaGFzbid0IGNoYW5nZWQuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBBcyBhIHJlc3VsdCBvZiB0aGF0LCB7QGxpbmsgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3IG5nVmlld31cbiAgICAgICAgICAgKiBjcmVhdGVzIG5ldyBzY29wZSwgcmVpbnN0YW50aWF0ZXMgdGhlIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvcmNlUmVsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyh1cGRhdGVSb3V0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCB1cGRhdGVSb3V0ZSk7XG5cbiAgICByZXR1cm4gJHJvdXRlO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbiB7c3RyaW5nfSBjdXJyZW50IHVybFxuICAgICAqIEBwYXJhbSByb3V0ZSB7T2JqZWN0fSByb3V0ZSByZWdleHAgdG8gbWF0Y2ggdGhlIHVybCBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7P09iamVjdH1cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENoZWNrIGlmIHRoZSByb3V0ZSBtYXRjaGVzIHRoZSBjdXJyZW50IHVybC5cbiAgICAgKlxuICAgICAqIEluc3BpcmVkIGJ5IG1hdGNoIGluXG4gICAgICogdmlzaW9ubWVkaWEvZXhwcmVzcy9saWIvcm91dGVyL3JvdXRlci5qcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzd2l0Y2hSb3V0ZU1hdGNoZXIob24sIHJvdXRlKSB7XG4gICAgICB2YXIga2V5cyA9IHJvdXRlLmtleXMsXG4gICAgICAgICAgcGFyYW1zID0ge307XG5cbiAgICAgIGlmICghcm91dGUucmVnZXhwKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIG0gPSByb3V0ZS5yZWdleHAuZXhlYyhvbik7XG4gICAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpIC0gMV07XG5cbiAgICAgICAgdmFyIHZhbCA9ICdzdHJpbmcnID09IHR5cGVvZiBtW2ldXG4gICAgICAgICAgICAgID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pXG4gICAgICAgICAgICAgIDogbVtpXTtcblxuICAgICAgICBpZiAoa2V5ICYmIHZhbCkge1xuICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlUm91dGUoKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcnNlUm91dGUoKSxcbiAgICAgICAgICBsYXN0ID0gJHJvdXRlLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChuZXh0ICYmIGxhc3QgJiYgbmV4dC4kJHJvdXRlID09PSBsYXN0LiQkcm91dGVcbiAgICAgICAgICAmJiBhbmd1bGFyLmVxdWFscyhuZXh0LnBhdGhQYXJhbXMsIGxhc3QucGF0aFBhcmFtcylcbiAgICAgICAgICAmJiAhbmV4dC5yZWxvYWRPblNlYXJjaCAmJiAhZm9yY2VSZWxvYWQpIHtcbiAgICAgICAgbGFzdC5wYXJhbXMgPSBuZXh0LnBhcmFtcztcbiAgICAgICAgYW5ndWxhci5jb3B5KGxhc3QucGFyYW1zLCAkcm91dGVQYXJhbXMpO1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRyb3V0ZVVwZGF0ZScsIGxhc3QpO1xuICAgICAgfSBlbHNlIGlmIChuZXh0IHx8IGxhc3QpIHtcbiAgICAgICAgZm9yY2VSZWxvYWQgPSBmYWxzZTtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckcm91dGVDaGFuZ2VTdGFydCcsIG5leHQsIGxhc3QpO1xuICAgICAgICAkcm91dGUuY3VycmVudCA9IG5leHQ7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgaWYgKG5leHQucmVkaXJlY3RUbykge1xuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNTdHJpbmcobmV4dC5yZWRpcmVjdFRvKSkge1xuICAgICAgICAgICAgICAkbG9jYXRpb24ucGF0aChpbnRlcnBvbGF0ZShuZXh0LnJlZGlyZWN0VG8sIG5leHQucGFyYW1zKSkuc2VhcmNoKG5leHQucGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJGxvY2F0aW9uLnVybChuZXh0LnJlZGlyZWN0VG8obmV4dC5wYXRoUGFyYW1zLCAkbG9jYXRpb24ucGF0aCgpLCAkbG9jYXRpb24uc2VhcmNoKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRxLndoZW4obmV4dCkuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgIHZhciBsb2NhbHMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgbmV4dC5yZXNvbHZlKSxcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLCB0ZW1wbGF0ZVVybDtcblxuICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gobG9jYWxzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgbG9jYWxzW2tleV0gPSBhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSA/XG4gICAgICAgICAgICAgICAgICAgICRpbmplY3Rvci5nZXQodmFsdWUpIDogJGluamVjdG9yLmludm9rZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCh0ZW1wbGF0ZSA9IG5leHQudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbih0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUobmV4dC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzRGVmaW5lZCh0ZW1wbGF0ZVVybCA9IG5leHQudGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbih0ZW1wbGF0ZVVybCkpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmwobmV4dC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybCA9ICRzY2UuZ2V0VHJ1c3RlZFJlc291cmNlVXJsKHRlbXBsYXRlVXJsKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodGVtcGxhdGVVcmwpKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0LmxvYWRlZFRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9ICRodHRwLmdldCh0ZW1wbGF0ZVVybCwge2NhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLlxuICAgICAgICAgICAgICAgICAgICAgIHRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLmRhdGE7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxzWyckdGVtcGxhdGUnXSA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAkcS5hbGwobG9jYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5cbiAgICAgICAgICAvLyBhZnRlciByb3V0ZSBjaGFuZ2VcbiAgICAgICAgICB0aGVuKGZ1bmN0aW9uKGxvY2Fscykge1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gJHJvdXRlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0LmxvY2FscyA9IGxvY2FscztcbiAgICAgICAgICAgICAgICBhbmd1bGFyLmNvcHkobmV4dC5wYXJhbXMsICRyb3V0ZVBhcmFtcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCckcm91dGVDaGFuZ2VTdWNjZXNzJywgbmV4dCwgbGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChuZXh0ID09ICRyb3V0ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJHJvdXRlQ2hhbmdlRXJyb3InLCBuZXh0LCBsYXN0LCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBhY3RpdmUgcm91dGUsIGJ5IG1hdGNoaW5nIGl0IGFnYWluc3QgdGhlIFVSTFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlUm91dGUoKSB7XG4gICAgICAvLyBNYXRjaCBhIHJvdXRlXG4gICAgICB2YXIgcGFyYW1zLCBtYXRjaDtcbiAgICAgIGFuZ3VsYXIuZm9yRWFjaChyb3V0ZXMsIGZ1bmN0aW9uKHJvdXRlLCBwYXRoKSB7XG4gICAgICAgIGlmICghbWF0Y2ggJiYgKHBhcmFtcyA9IHN3aXRjaFJvdXRlTWF0Y2hlcigkbG9jYXRpb24ucGF0aCgpLCByb3V0ZSkpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBpbmhlcml0KHJvdXRlLCB7XG4gICAgICAgICAgICBwYXJhbXM6IGFuZ3VsYXIuZXh0ZW5kKHt9LCAkbG9jYXRpb24uc2VhcmNoKCksIHBhcmFtcyksXG4gICAgICAgICAgICBwYXRoUGFyYW1zOiBwYXJhbXN9KTtcbiAgICAgICAgICBtYXRjaC4kJHJvdXRlID0gcm91dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gTm8gcm91dGUgbWF0Y2hlZDsgZmFsbGJhY2sgdG8gXCJvdGhlcndpc2VcIiByb3V0ZVxuICAgICAgcmV0dXJuIG1hdGNoIHx8IHJvdXRlc1tudWxsXSAmJiBpbmhlcml0KHJvdXRlc1tudWxsXSwge3BhcmFtczoge30sIHBhdGhQYXJhbXM6e319KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBpbnRlcnBvbGF0aW9uIG9mIHRoZSByZWRpcmVjdCBwYXRoIHdpdGggdGhlIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdHJpbmcsIHBhcmFtcykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYW5ndWxhci5mb3JFYWNoKChzdHJpbmd8fCcnKS5zcGxpdCgnOicpLCBmdW5jdGlvbihzZWdtZW50LCBpKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnRNYXRjaCA9IHNlZ21lbnQubWF0Y2goLyhcXHcrKSguKikvKTtcbiAgICAgICAgICB2YXIga2V5ID0gc2VnbWVudE1hdGNoWzFdO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtc1trZXldKTtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWdtZW50TWF0Y2hbMl0gfHwgJycpO1xuICAgICAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgIH1cbiAgfV07XG59XG5cbm5nUm91dGVNb2R1bGUucHJvdmlkZXIoJyRyb3V0ZVBhcmFtcycsICRSb3V0ZVBhcmFtc1Byb3ZpZGVyKTtcblxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nUm91dGUuJHJvdXRlUGFyYW1zXG4gKiBAcmVxdWlyZXMgJHJvdXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYCRyb3V0ZVBhcmFtc2Agc2VydmljZSBhbGxvd3MgeW91IHRvIHJldHJpZXZlIHRoZSBjdXJyZW50IHNldCBvZiByb3V0ZSBwYXJhbWV0ZXJzLlxuICpcbiAqIFJlcXVpcmVzIHRoZSB7QGxpbmsgbmdSb3V0ZSBgbmdSb3V0ZWB9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXG4gKlxuICogVGhlIHJvdXRlIHBhcmFtZXRlcnMgYXJlIGEgY29tYmluYXRpb24gb2Yge0BsaW5rIG5nLiRsb2NhdGlvbiBgJGxvY2F0aW9uYH0nc1xuICoge0BsaW5rIG5nLiRsb2NhdGlvbiNtZXRob2RzX3NlYXJjaCBgc2VhcmNoKClgfSBhbmQge0BsaW5rIG5nLiRsb2NhdGlvbiNtZXRob2RzX3BhdGggYHBhdGgoKWB9LlxuICogVGhlIGBwYXRoYCBwYXJhbWV0ZXJzIGFyZSBleHRyYWN0ZWQgd2hlbiB0aGUge0BsaW5rIG5nUm91dGUuJHJvdXRlIGAkcm91dGVgfSBwYXRoIGlzIG1hdGNoZWQuXG4gKlxuICogSW4gY2FzZSBvZiBwYXJhbWV0ZXIgbmFtZSBjb2xsaXNpb24sIGBwYXRoYCBwYXJhbXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYHNlYXJjaGAgcGFyYW1zLlxuICpcbiAqIFRoZSBzZXJ2aWNlIGd1YXJhbnRlZXMgdGhhdCB0aGUgaWRlbnRpdHkgb2YgdGhlIGAkcm91dGVQYXJhbXNgIG9iamVjdCB3aWxsIHJlbWFpbiB1bmNoYW5nZWRcbiAqIChidXQgaXRzIHByb3BlcnRpZXMgd2lsbCBsaWtlbHkgY2hhbmdlKSBldmVuIHdoZW4gYSByb3V0ZSBjaGFuZ2Ugb2NjdXJzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYCRyb3V0ZVBhcmFtc2AgYXJlIG9ubHkgdXBkYXRlZCAqYWZ0ZXIqIGEgcm91dGUgY2hhbmdlIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuXG4gKiBUaGlzIG1lYW5zIHRoYXQgeW91IGNhbm5vdCByZWx5IG9uIGAkcm91dGVQYXJhbXNgIGJlaW5nIGNvcnJlY3QgaW4gcm91dGUgcmVzb2x2ZSBmdW5jdGlvbnMuXG4gKiBJbnN0ZWFkIHlvdSBjYW4gdXNlIGAkcm91dGUuY3VycmVudC5wYXJhbXNgIHRvIGFjY2VzcyB0aGUgbmV3IHJvdXRlJ3MgcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogPHByZT5cbiAqICAvLyBHaXZlbjpcbiAqICAvLyBVUkw6IGh0dHA6Ly9zZXJ2ZXIuY29tL2luZGV4Lmh0bWwjL0NoYXB0ZXIvMS9TZWN0aW9uLzI/c2VhcmNoPW1vYnlcbiAqICAvLyBSb3V0ZTogL0NoYXB0ZXIvOmNoYXB0ZXJJZC9TZWN0aW9uLzpzZWN0aW9uSWRcbiAqICAvL1xuICogIC8vIFRoZW5cbiAqICAkcm91dGVQYXJhbXMgPT0+IHtjaGFwdGVySWQ6MSwgc2VjdGlvbklkOjIsIHNlYXJjaDonbW9ieSd9XG4gKiA8L3ByZT5cbiAqL1xuZnVuY3Rpb24gJFJvdXRlUGFyYW1zUHJvdmlkZXIoKSB7XG4gIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH07XG59XG5cbm5nUm91dGVNb2R1bGUuZGlyZWN0aXZlKCduZ1ZpZXcnLCBuZ1ZpZXdGYWN0b3J5KTtcbm5nUm91dGVNb2R1bGUuZGlyZWN0aXZlKCduZ1ZpZXcnLCBuZ1ZpZXdGaWxsQ29udGVudEZhY3RvcnkpO1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3XG4gKiBAcmVzdHJpY3QgRUNBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAjIE92ZXJ2aWV3XG4gKiBgbmdWaWV3YCBpcyBhIGRpcmVjdGl2ZSB0aGF0IGNvbXBsZW1lbnRzIHRoZSB7QGxpbmsgbmdSb3V0ZS4kcm91dGUgJHJvdXRlfSBzZXJ2aWNlIGJ5XG4gKiBpbmNsdWRpbmcgdGhlIHJlbmRlcmVkIHRlbXBsYXRlIG9mIHRoZSBjdXJyZW50IHJvdXRlIGludG8gdGhlIG1haW4gbGF5b3V0IChgaW5kZXguaHRtbGApIGZpbGUuXG4gKiBFdmVyeSB0aW1lIHRoZSBjdXJyZW50IHJvdXRlIGNoYW5nZXMsIHRoZSBpbmNsdWRlZCB2aWV3IGNoYW5nZXMgd2l0aCBpdCBhY2NvcmRpbmcgdG8gdGhlXG4gKiBjb25maWd1cmF0aW9uIG9mIHRoZSBgJHJvdXRlYCBzZXJ2aWNlLlxuICpcbiAqIFJlcXVpcmVzIHRoZSB7QGxpbmsgbmdSb3V0ZSBgbmdSb3V0ZWB9IG1vZHVsZSB0byBiZSBpbnN0YWxsZWQuXG4gKlxuICogQGFuaW1hdGlvbnNcbiAqIGVudGVyIC0gYW5pbWF0aW9uIGlzIHVzZWQgdG8gYnJpbmcgbmV3IGNvbnRlbnQgaW50byB0aGUgYnJvd3Nlci5cbiAqIGxlYXZlIC0gYW5pbWF0aW9uIGlzIHVzZWQgdG8gYW5pbWF0ZSBleGlzdGluZyBjb250ZW50IGF3YXkuXG4gKlxuICogVGhlIGVudGVyIGFuZCBsZWF2ZSBhbmltYXRpb24gb2NjdXIgY29uY3VycmVudGx5LlxuICpcbiAqIEBzY29wZVxuICogQHByaW9yaXR5IDQwMFxuICogQGV4YW1wbGVcbiAgICA8ZXhhbXBsZSBtb2R1bGU9XCJuZ1ZpZXdFeGFtcGxlXCIgZGVwcz1cImFuZ3VsYXItcm91dGUuanNcIiBhbmltYXRpb25zPVwidHJ1ZVwiPlxuICAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiTWFpbkNudGwgYXMgbWFpblwiPlxuICAgICAgICAgIENob29zZTpcbiAgICAgICAgICA8YSBocmVmPVwiQm9vay9Nb2J5XCI+TW9ieTwvYT4gfFxuICAgICAgICAgIDxhIGhyZWY9XCJCb29rL01vYnkvY2gvMVwiPk1vYnk6IENoMTwvYT4gfFxuICAgICAgICAgIDxhIGhyZWY9XCJCb29rL0dhdHNieVwiPkdhdHNieTwvYT4gfFxuICAgICAgICAgIDxhIGhyZWY9XCJCb29rL0dhdHNieS9jaC80P2tleT12YWx1ZVwiPkdhdHNieTogQ2g0PC9hPiB8XG4gICAgICAgICAgPGEgaHJlZj1cIkJvb2svU2NhcmxldFwiPlNjYXJsZXQgTGV0dGVyPC9hPjxici8+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidmlldy1hbmltYXRlLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGRpdiBuZy12aWV3IGNsYXNzPVwidmlldy1hbmltYXRlXCI+PC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGhyIC8+XG5cbiAgICAgICAgICA8cHJlPiRsb2NhdGlvbi5wYXRoKCkgPSB7e21haW4uJGxvY2F0aW9uLnBhdGgoKX19PC9wcmU+XG4gICAgICAgICAgPHByZT4kcm91dGUuY3VycmVudC50ZW1wbGF0ZVVybCA9IHt7bWFpbi4kcm91dGUuY3VycmVudC50ZW1wbGF0ZVVybH19PC9wcmU+XG4gICAgICAgICAgPHByZT4kcm91dGUuY3VycmVudC5wYXJhbXMgPSB7e21haW4uJHJvdXRlLmN1cnJlbnQucGFyYW1zfX08L3ByZT5cbiAgICAgICAgICA8cHJlPiRyb3V0ZS5jdXJyZW50LnNjb3BlLm5hbWUgPSB7e21haW4uJHJvdXRlLmN1cnJlbnQuc2NvcGUubmFtZX19PC9wcmU+XG4gICAgICAgICAgPHByZT4kcm91dGVQYXJhbXMgPSB7e21haW4uJHJvdXRlUGFyYW1zfX08L3ByZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2ZpbGU+XG5cbiAgICAgIDxmaWxlIG5hbWU9XCJib29rLmh0bWxcIj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICBjb250cm9sbGVyOiB7e2Jvb2submFtZX19PGJyIC8+XG4gICAgICAgICAgQm9vayBJZDoge3tib29rLnBhcmFtcy5ib29rSWR9fTxiciAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZmlsZT5cblxuICAgICAgPGZpbGUgbmFtZT1cImNoYXB0ZXIuaHRtbFwiPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIGNvbnRyb2xsZXI6IHt7Y2hhcHRlci5uYW1lfX08YnIgLz5cbiAgICAgICAgICBCb29rIElkOiB7e2NoYXB0ZXIucGFyYW1zLmJvb2tJZH19PGJyIC8+XG4gICAgICAgICAgQ2hhcHRlciBJZDoge3tjaGFwdGVyLnBhcmFtcy5jaGFwdGVySWR9fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZmlsZT5cblxuICAgICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XG4gICAgICAgIC52aWV3LWFuaW1hdGUtY29udGFpbmVyIHtcbiAgICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgICAgICBoZWlnaHQ6MTAwcHghaW1wb3J0YW50O1xuICAgICAgICAgIHBvc2l0aW9uOnJlbGF0aXZlO1xuICAgICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XG4gICAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcbiAgICAgICAgICBoZWlnaHQ6NDBweDtcbiAgICAgICAgICBvdmVyZmxvdzpoaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAudmlldy1hbmltYXRlIHtcbiAgICAgICAgICBwYWRkaW5nOjEwcHg7XG4gICAgICAgIH1cblxuICAgICAgICAudmlldy1hbmltYXRlLm5nLWVudGVyLCAudmlldy1hbmltYXRlLm5nLWxlYXZlIHtcbiAgICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMS41cztcbiAgICAgICAgICB0cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDEuNXM7XG5cbiAgICAgICAgICBkaXNwbGF5OmJsb2NrO1xuICAgICAgICAgIHdpZHRoOjEwMCU7XG4gICAgICAgICAgYm9yZGVyLWxlZnQ6MXB4IHNvbGlkIGJsYWNrO1xuXG4gICAgICAgICAgcG9zaXRpb246YWJzb2x1dGU7XG4gICAgICAgICAgdG9wOjA7XG4gICAgICAgICAgbGVmdDowO1xuICAgICAgICAgIHJpZ2h0OjA7XG4gICAgICAgICAgYm90dG9tOjA7XG4gICAgICAgICAgcGFkZGluZzoxMHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLnZpZXctYW5pbWF0ZS5uZy1lbnRlciB7XG4gICAgICAgICAgbGVmdDoxMDAlO1xuICAgICAgICB9XG4gICAgICAgIC52aWV3LWFuaW1hdGUubmctZW50ZXIubmctZW50ZXItYWN0aXZlIHtcbiAgICAgICAgICBsZWZ0OjA7XG4gICAgICAgIH1cbiAgICAgICAgLnZpZXctYW5pbWF0ZS5uZy1sZWF2ZS5uZy1sZWF2ZS1hY3RpdmUge1xuICAgICAgICAgIGxlZnQ6LTEwMCU7XG4gICAgICAgIH1cbiAgICAgIDwvZmlsZT5cblxuICAgICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICAgICAgICBhbmd1bGFyLm1vZHVsZSgnbmdWaWV3RXhhbXBsZScsIFsnbmdSb3V0ZScsICduZ0FuaW1hdGUnXSxcbiAgICAgICAgICBmdW5jdGlvbigkcm91dGVQcm92aWRlciwgJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICRyb3V0ZVByb3ZpZGVyLndoZW4oJy9Cb29rLzpib29rSWQnLCB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnYm9vay5odG1sJyxcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogQm9va0NudGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJBczogJ2Jvb2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRyb3V0ZVByb3ZpZGVyLndoZW4oJy9Cb29rLzpib29rSWQvY2gvOmNoYXB0ZXJJZCcsIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjaGFwdGVyLmh0bWwnLFxuICAgICAgICAgICAgICBjb250cm9sbGVyOiBDaGFwdGVyQ250bCxcbiAgICAgICAgICAgICAgY29udHJvbGxlckFzOiAnY2hhcHRlcidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb25maWd1cmUgaHRtbDUgdG8gZ2V0IGxpbmtzIHdvcmtpbmcgb24ganNmaWRkbGVcbiAgICAgICAgICAgICRsb2NhdGlvblByb3ZpZGVyLmh0bWw1TW9kZSh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gTWFpbkNudGwoJHJvdXRlLCAkcm91dGVQYXJhbXMsICRsb2NhdGlvbikge1xuICAgICAgICAgIHRoaXMuJHJvdXRlID0gJHJvdXRlO1xuICAgICAgICAgIHRoaXMuJGxvY2F0aW9uID0gJGxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuJHJvdXRlUGFyYW1zID0gJHJvdXRlUGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQm9va0NudGwoJHJvdXRlUGFyYW1zKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gXCJCb29rQ250bFwiO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gJHJvdXRlUGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQ2hhcHRlckNudGwoJHJvdXRlUGFyYW1zKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gXCJDaGFwdGVyQ250bFwiO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gJHJvdXRlUGFyYW1zO1xuICAgICAgICB9XG4gICAgICA8L2ZpbGU+XG5cbiAgICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxuICAgICAgICBpdCgnc2hvdWxkIGxvYWQgYW5kIGNvbXBpbGUgY29ycmVjdCB0ZW1wbGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnQoJ2E6Y29udGFpbnMoXCJNb2J5OiBDaDFcIiknKS5jbGljaygpO1xuICAgICAgICAgIHZhciBjb250ZW50ID0gZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgW25nLXZpZXddJykudGV4dCgpO1xuICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9jb250cm9sbGVyXFw6IENoYXB0ZXJDbnRsLyk7XG4gICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvTWF0Y2goL0Jvb2sgSWRcXDogTW9ieS8pO1xuICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9DaGFwdGVyIElkXFw6IDEvKTtcblxuICAgICAgICAgIGVsZW1lbnQoJ2E6Y29udGFpbnMoXCJTY2FybGV0XCIpJykuY2xpY2soKTtcbiAgICAgICAgICBjb250ZW50ID0gZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgW25nLXZpZXddJykudGV4dCgpO1xuICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b01hdGNoKC9jb250cm9sbGVyXFw6IEJvb2tDbnRsLyk7XG4gICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvTWF0Y2goL0Jvb2sgSWRcXDogU2NhcmxldC8pO1xuICAgICAgICB9KTtcbiAgICAgIDwvZmlsZT5cbiAgICA8L2V4YW1wbGU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBldmVudFxuICogQG5hbWUgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3IyR2aWV3Q29udGVudExvYWRlZFxuICogQGV2ZW50T2YgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3XG4gKiBAZXZlbnRUeXBlIGVtaXQgb24gdGhlIGN1cnJlbnQgbmdWaWV3IHNjb3BlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVtaXR0ZWQgZXZlcnkgdGltZSB0aGUgbmdWaWV3IGNvbnRlbnQgaXMgcmVsb2FkZWQuXG4gKi9cbm5nVmlld0ZhY3RvcnkuJGluamVjdCA9IFsnJHJvdXRlJywgJyRhbmNob3JTY3JvbGwnLCAnJGFuaW1hdGUnXTtcbmZ1bmN0aW9uIG5nVmlld0ZhY3RvcnkoICAgJHJvdXRlLCAgICRhbmNob3JTY3JvbGwsICAgJGFuaW1hdGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VDQScsXG4gICAgdGVybWluYWw6IHRydWUsXG4gICAgcHJpb3JpdHk6IDQwMCxcbiAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBhdHRyLCBjdHJsLCAkdHJhbnNjbHVkZSkge1xuICAgICAgICB2YXIgY3VycmVudFNjb3BlLFxuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgICBhdXRvU2Nyb2xsRXhwID0gYXR0ci5hdXRvc2Nyb2xsLFxuICAgICAgICAgICAgb25sb2FkRXhwID0gYXR0ci5vbmxvYWQgfHwgJyc7XG5cbiAgICAgICAgc2NvcGUuJG9uKCckcm91dGVDaGFuZ2VTdWNjZXNzJywgdXBkYXRlKTtcbiAgICAgICAgdXBkYXRlKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gY2xlYW51cExhc3RWaWV3KCkge1xuICAgICAgICAgIGlmIChjdXJyZW50U2NvcGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICRhbmltYXRlLmxlYXZlKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgdmFyIGxvY2FscyA9ICRyb3V0ZS5jdXJyZW50ICYmICRyb3V0ZS5jdXJyZW50LmxvY2FscyxcbiAgICAgICAgICAgICAgdGVtcGxhdGUgPSBsb2NhbHMgJiYgbG9jYWxzLiR0ZW1wbGF0ZTtcblxuICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSAkcm91dGUuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGFsc28gbGluayBhbGwgY2hpbGRyZW4gb2YgbmctdmlldyB0aGF0IHdlcmUgY29udGFpbmVkIGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gaHRtbC4gSWYgdGhhdCBjb250ZW50IGNvbnRhaW5zIGNvbnRyb2xsZXJzLCAuLi4gdGhleSBjb3VsZCBwb2xsdXRlL2NoYW5nZSB0aGUgc2NvcGUuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB1c2luZyBuZy12aWV3IG9uIGFuIGVsZW1lbnQgd2l0aCBhZGRpdGlvbmFsIGNvbnRlbnQgZG9lcyBub3QgbWFrZSBzZW5zZS4uLlxuICAgICAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QgcmVtb3ZlIHRoZW0gaW4gdGhlIGNsb25lQXR0Y2hGbiBvZiAkdHJhbnNjbHVkZSBhcyB0aGF0XG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBpcyBjYWxsZWQgYmVmb3JlIGxpbmtpbmcgdGhlIGNvbnRlbnQsIHdoaWNoIHdvdWxkIGFwcGx5IGNoaWxkXG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzIHRvIG5vbiBleGlzdGluZyBlbGVtZW50cy5cbiAgICAgICAgICAgIHZhciBjbG9uZSA9ICR0cmFuc2NsdWRlKG5ld1Njb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjbG9uZSwgbnVsbCwgY3VycmVudEVsZW1lbnQgfHwgJGVsZW1lbnQsIGZ1bmN0aW9uIG9uTmdWaWV3RW50ZXIgKCkge1xuICAgICAgICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChhdXRvU2Nyb2xsRXhwKVxuICAgICAgICAgICAgICAgICAgJiYgKCFhdXRvU2Nyb2xsRXhwIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSkge1xuICAgICAgICAgICAgICAgICAgJGFuY2hvclNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0VmlldygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2xvbmU7XG4gICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBjdXJyZW50LnNjb3BlID0gbmV3U2NvcGU7XG4gICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyR2aWV3Q29udGVudExvYWRlZCcpO1xuICAgICAgICAgICAgY3VycmVudFNjb3BlLiRldmFsKG9ubG9hZEV4cCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFudXBMYXN0VmlldygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gVGhpcyBkaXJlY3RpdmUgaXMgY2FsbGVkIGR1cmluZyB0aGUgJHRyYW5zY2x1ZGUgY2FsbCBvZiB0aGUgZmlyc3QgYG5nVmlld2AgZGlyZWN0aXZlLlxuLy8gSXQgd2lsbCByZXBsYWNlIGFuZCBjb21waWxlIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IHdpdGggdGhlIGxvYWRlZCB0ZW1wbGF0ZS5cbi8vIFdlIG5lZWQgdGhpcyBkaXJlY3RpdmUgc28gdGhhdCB0aGUgZWxlbWVudCBjb250ZW50IGlzIGFscmVhZHkgZmlsbGVkIHdoZW5cbi8vIHRoZSBsaW5rIGZ1bmN0aW9uIG9mIGFub3RoZXIgZGlyZWN0aXZlIG9uIHRoZSBzYW1lIGVsZW1lbnQgYXMgbmdWaWV3XG4vLyBpcyBjYWxsZWQuXG5uZ1ZpZXdGaWxsQ29udGVudEZhY3RvcnkuJGluamVjdCA9IFsnJGNvbXBpbGUnLCAnJGNvbnRyb2xsZXInLCAnJHJvdXRlJ107XG5mdW5jdGlvbiBuZ1ZpZXdGaWxsQ29udGVudEZhY3RvcnkoJGNvbXBpbGUsICRjb250cm9sbGVyLCAkcm91dGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0VDQScsXG4gICAgcHJpb3JpdHk6IC00MDAsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICB2YXIgY3VycmVudCA9ICRyb3V0ZS5jdXJyZW50LFxuICAgICAgICAgIGxvY2FscyA9IGN1cnJlbnQubG9jYWxzO1xuXG4gICAgICAkZWxlbWVudC5odG1sKGxvY2Fscy4kdGVtcGxhdGUpO1xuXG4gICAgICB2YXIgbGluayA9ICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpO1xuXG4gICAgICBpZiAoY3VycmVudC5jb250cm9sbGVyKSB7XG4gICAgICAgIGxvY2Fscy4kc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSAkY29udHJvbGxlcihjdXJyZW50LmNvbnRyb2xsZXIsIGxvY2Fscyk7XG4gICAgICAgIGlmIChjdXJyZW50LmNvbnRyb2xsZXJBcykge1xuICAgICAgICAgIHNjb3BlW2N1cnJlbnQuY29udHJvbGxlckFzXSA9IGNvbnRyb2xsZXI7XG4gICAgICAgIH1cbiAgICAgICAgJGVsZW1lbnQuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVyKTtcbiAgICAgICAgJGVsZW1lbnQuY2hpbGRyZW4oKS5kYXRhKCckbmdDb250cm9sbGVyQ29udHJvbGxlcicsIGNvbnRyb2xsZXIpO1xuICAgICAgfVxuXG4gICAgICBsaW5rKHNjb3BlKTtcbiAgICB9XG4gIH07XG59XG5cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG5cbn0pLmNhbGwoZ2xvYmFsLCBtb2R1bGUsIHVuZGVmaW5lZCk7XG4iLCJ2YXIgZ2xvYmFsPXR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS4yLjZcbiAqIChjKSAyMDEwLTIwMTQgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkgeyd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGlzIG9iamVjdCBwcm92aWRlcyBhIHV0aWxpdHkgZm9yIHByb2R1Y2luZyByaWNoIEVycm9yIG1lc3NhZ2VzIHdpdGhpblxuICogQW5ndWxhci4gSXQgY2FuIGJlIGNhbGxlZCBhcyBmb2xsb3dzOlxuICpcbiAqIHZhciBleGFtcGxlTWluRXJyID0gbWluRXJyKCdleGFtcGxlJyk7XG4gKiB0aHJvdyBleGFtcGxlTWluRXJyKCdvbmUnLCAnVGhpcyB7MH0gaXMgezF9JywgZm9vLCBiYXIpO1xuICpcbiAqIFRoZSBhYm92ZSBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIG1pbkVyciBpbiB0aGUgZXhhbXBsZSBuYW1lc3BhY2UuIFRoZVxuICogcmVzdWx0aW5nIGVycm9yIHdpbGwgaGF2ZSBhIG5hbWVzcGFjZWQgZXJyb3IgY29kZSBvZiBleGFtcGxlLm9uZS4gIFRoZVxuICogcmVzdWx0aW5nIGVycm9yIHdpbGwgcmVwbGFjZSB7MH0gd2l0aCB0aGUgdmFsdWUgb2YgZm9vLCBhbmQgezF9IHdpdGggdGhlXG4gKiB2YWx1ZSBvZiBiYXIuIFRoZSBvYmplY3QgaXMgbm90IHJlc3RyaWN0ZWQgaW4gdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXQgY2FuXG4gKiB0YWtlLlxuICpcbiAqIElmIGZld2VyIGFyZ3VtZW50cyBhcmUgc3BlY2lmaWVkIHRoYW4gbmVjZXNzYXJ5IGZvciBpbnRlcnBvbGF0aW9uLCB0aGUgZXh0cmFcbiAqIGludGVycG9sYXRpb24gbWFya2VycyB3aWxsIGJlIHByZXNlcnZlZCBpbiB0aGUgZmluYWwgc3RyaW5nLlxuICpcbiAqIFNpbmNlIGRhdGEgd2lsbCBiZSBwYXJzZWQgc3RhdGljYWxseSBkdXJpbmcgYSBidWlsZCBzdGVwLCBzb21lIHJlc3RyaWN0aW9uc1xuICogYXJlIGFwcGxpZWQgd2l0aCByZXNwZWN0IHRvIGhvdyBtaW5FcnIgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGFuZCBjYWxsZWQuXG4gKiBJbnN0YW5jZXMgc2hvdWxkIGhhdmUgbmFtZXMgb2YgdGhlIGZvcm0gbmFtZXNwYWNlTWluRXJyIGZvciBhIG1pbkVyciBjcmVhdGVkXG4gKiB1c2luZyBtaW5FcnIoJ25hbWVzcGFjZScpIC4gRXJyb3IgY29kZXMsIG5hbWVzcGFjZXMgYW5kIHRlbXBsYXRlIHN0cmluZ3NcbiAqIHNob3VsZCBhbGwgYmUgc3RhdGljIHN0cmluZ3MsIG5vdCB2YXJpYWJsZXMgb3IgZ2VuZXJhbCBleHByZXNzaW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlIFRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgbmV3IG1pbkVyciBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZywgLi4uKTogRXJyb3J9IGluc3RhbmNlXG4gKi9cblxuZnVuY3Rpb24gbWluRXJyKG1vZHVsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb2RlID0gYXJndW1lbnRzWzBdLFxuICAgICAgcHJlZml4ID0gJ1snICsgKG1vZHVsZSA/IG1vZHVsZSArICc6JyA6ICcnKSArIGNvZGUgKyAnXSAnLFxuICAgICAgdGVtcGxhdGUgPSBhcmd1bWVudHNbMV0sXG4gICAgICB0ZW1wbGF0ZUFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICBzdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpLnJlcGxhY2UoLyBcXHtbXFxzXFxTXSokLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlLCBpO1xuXG4gICAgbWVzc2FnZSA9IHByZWZpeCArIHRlbXBsYXRlLnJlcGxhY2UoL1xce1xcZCtcXH0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICB2YXIgaW5kZXggPSArbWF0Y2guc2xpY2UoMSwgLTEpLCBhcmc7XG5cbiAgICAgIGlmIChpbmRleCArIDIgPCB0ZW1wbGF0ZUFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGFyZyA9IHRlbXBsYXRlQXJnc1tpbmRleCArIDJdO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKS5yZXBsYWNlKC8gP1xce1tcXHNcXFNdKiQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdG9Kc29uKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgJ1xcbmh0dHA6Ly9lcnJvcnMuYW5ndWxhcmpzLm9yZy8xLjIuNi8nICtcbiAgICAgIChtb2R1bGUgPyBtb2R1bGUgKyAnLycgOiAnJykgKyBjb2RlO1xuICAgIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgKGkgPT0gMiA/ICc/JyA6ICcmJykgKyAncCcgKyAoaS0yKSArICc9JyArXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfTtcbn1cblxuLyogV2UgbmVlZCB0byB0ZWxsIGpzaGludCB3aGF0IHZhcmlhYmxlcyBhcmUgYmVpbmcgZXhwb3J0ZWQgKi9cbi8qIGdsb2JhbFxuICAgIC1hbmd1bGFyLFxuICAgIC1tc2llLFxuICAgIC1qcUxpdGUsXG4gICAgLWpRdWVyeSxcbiAgICAtc2xpY2UsXG4gICAgLXB1c2gsXG4gICAgLXRvU3RyaW5nLFxuICAgIC1uZ01pbkVycixcbiAgICAtX2FuZ3VsYXIsXG4gICAgLWFuZ3VsYXJNb2R1bGUsXG4gICAgLW5vZGVOYW1lXyxcbiAgICAtdWlkLFxuXG4gICAgLWxvd2VyY2FzZSxcbiAgICAtdXBwZXJjYXNlLFxuICAgIC1tYW51YWxMb3dlcmNhc2UsXG4gICAgLW1hbnVhbFVwcGVyY2FzZSxcbiAgICAtbm9kZU5hbWVfLFxuICAgIC1pc0FycmF5TGlrZSxcbiAgICAtZm9yRWFjaCxcbiAgICAtc29ydGVkS2V5cyxcbiAgICAtZm9yRWFjaFNvcnRlZCxcbiAgICAtcmV2ZXJzZVBhcmFtcyxcbiAgICAtbmV4dFVpZCxcbiAgICAtc2V0SGFzaEtleSxcbiAgICAtZXh0ZW5kLFxuICAgIC1pbnQsXG4gICAgLWluaGVyaXQsXG4gICAgLW5vb3AsXG4gICAgLWlkZW50aXR5LFxuICAgIC12YWx1ZUZuLFxuICAgIC1pc1VuZGVmaW5lZCxcbiAgICAtaXNEZWZpbmVkLFxuICAgIC1pc09iamVjdCxcbiAgICAtaXNTdHJpbmcsXG4gICAgLWlzTnVtYmVyLFxuICAgIC1pc0RhdGUsXG4gICAgLWlzQXJyYXksXG4gICAgLWlzRnVuY3Rpb24sXG4gICAgLWlzUmVnRXhwLFxuICAgIC1pc1dpbmRvdyxcbiAgICAtaXNTY29wZSxcbiAgICAtaXNGaWxlLFxuICAgIC1pc0Jvb2xlYW4sXG4gICAgLXRyaW0sXG4gICAgLWlzRWxlbWVudCxcbiAgICAtbWFrZU1hcCxcbiAgICAtbWFwLFxuICAgIC1zaXplLFxuICAgIC1pbmNsdWRlcyxcbiAgICAtaW5kZXhPZixcbiAgICAtYXJyYXlSZW1vdmUsXG4gICAgLWlzTGVhZk5vZGUsXG4gICAgLWNvcHksXG4gICAgLXNoYWxsb3dDb3B5LFxuICAgIC1lcXVhbHMsXG4gICAgLWNzcCxcbiAgICAtY29uY2F0LFxuICAgIC1zbGljZUFyZ3MsXG4gICAgLWJpbmQsXG4gICAgLXRvSnNvblJlcGxhY2VyLFxuICAgIC10b0pzb24sXG4gICAgLWZyb21Kc29uLFxuICAgIC10b0Jvb2xlYW4sXG4gICAgLXN0YXJ0aW5nVGFnLFxuICAgIC10cnlEZWNvZGVVUklDb21wb25lbnQsXG4gICAgLXBhcnNlS2V5VmFsdWUsXG4gICAgLXRvS2V5VmFsdWUsXG4gICAgLWVuY29kZVVyaVNlZ21lbnQsXG4gICAgLWVuY29kZVVyaVF1ZXJ5LFxuICAgIC1hbmd1bGFySW5pdCxcbiAgICAtYm9vdHN0cmFwLFxuICAgIC1zbmFrZV9jYXNlLFxuICAgIC1iaW5kSlF1ZXJ5LFxuICAgIC1hc3NlcnRBcmcsXG4gICAgLWFzc2VydEFyZ0ZuLFxuICAgIC1hc3NlcnROb3RIYXNPd25Qcm9wZXJ0eSxcbiAgICAtZ2V0dGVyLFxuICAgIC1nZXRCbG9ja0VsZW1lbnRzLFxuXG4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIubG93ZXJjYXNlXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgdGhlIHNwZWNpZmllZCBzdHJpbmcgdG8gbG93ZXJjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IExvd2VyY2FzZWQgc3RyaW5nLlxuICovXG52YXIgbG93ZXJjYXNlID0gZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gaXNTdHJpbmcoc3RyaW5nKSA/IHN0cmluZy50b0xvd2VyQ2FzZSgpIDogc3RyaW5nO307XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIudXBwZXJjYXNlXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgdGhlIHNwZWNpZmllZCBzdHJpbmcgdG8gdXBwZXJjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIHVwcGVyY2FzZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVwcGVyY2FzZWQgc3RyaW5nLlxuICovXG52YXIgdXBwZXJjYXNlID0gZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gaXNTdHJpbmcoc3RyaW5nKSA/IHN0cmluZy50b1VwcGVyQ2FzZSgpIDogc3RyaW5nO307XG5cblxudmFyIG1hbnVhbExvd2VyY2FzZSA9IGZ1bmN0aW9uKHMpIHtcbiAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gIHJldHVybiBpc1N0cmluZyhzKVxuICAgICAgPyBzLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uKGNoKSB7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2guY2hhckNvZGVBdCgwKSB8IDMyKTt9KVxuICAgICAgOiBzO1xufTtcbnZhciBtYW51YWxVcHBlcmNhc2UgPSBmdW5jdGlvbihzKSB7XG4gIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICByZXR1cm4gaXNTdHJpbmcocylcbiAgICAgID8gcy5yZXBsYWNlKC9bYS16XS9nLCBmdW5jdGlvbihjaCkge3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoLmNoYXJDb2RlQXQoMCkgJiB+MzIpO30pXG4gICAgICA6IHM7XG59O1xuXG5cbi8vIFN0cmluZyN0b0xvd2VyQ2FzZSBhbmQgU3RyaW5nI3RvVXBwZXJDYXNlIGRvbid0IHByb2R1Y2UgY29ycmVjdCByZXN1bHRzIGluIGJyb3dzZXJzIHdpdGggVHVya2lzaFxuLy8gbG9jYWxlLCBmb3IgdGhpcyByZWFzb24gd2UgbmVlZCB0byBkZXRlY3QgdGhpcyBjYXNlIGFuZCByZWRlZmluZSBsb3dlcmNhc2UvdXBwZXJjYXNlIG1ldGhvZHNcbi8vIHdpdGggY29ycmVjdCBidXQgc2xvd2VyIGFsdGVybmF0aXZlcy5cbmlmICgnaScgIT09ICdJJy50b0xvd2VyQ2FzZSgpKSB7XG4gIGxvd2VyY2FzZSA9IG1hbnVhbExvd2VyY2FzZTtcbiAgdXBwZXJjYXNlID0gbWFudWFsVXBwZXJjYXNlO1xufVxuXG5cbnZhciAvKiogaG9sZHMgbWFqb3IgdmVyc2lvbiBudW1iZXIgZm9yIElFIG9yIE5hTiBmb3IgcmVhbCBicm93c2VycyAqL1xuICAgIG1zaWUsXG4gICAganFMaXRlLCAgICAgICAgICAgLy8gZGVsYXkgYmluZGluZyBzaW5jZSBqUXVlcnkgY291bGQgYmUgbG9hZGVkIGFmdGVyIHVzLlxuICAgIGpRdWVyeSwgICAgICAgICAgIC8vIGRlbGF5IGJpbmRpbmdcbiAgICBzbGljZSAgICAgICAgICAgICA9IFtdLnNsaWNlLFxuICAgIHB1c2ggICAgICAgICAgICAgID0gW10ucHVzaCxcbiAgICB0b1N0cmluZyAgICAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgbmdNaW5FcnIgICAgICAgICAgPSBtaW5FcnIoJ25nJyksXG5cblxuICAgIF9hbmd1bGFyICAgICAgICAgID0gd2luZG93LmFuZ3VsYXIsXG4gICAgLyoqIEBuYW1lIGFuZ3VsYXIgKi9cbiAgICBhbmd1bGFyICAgICAgICAgICA9IHdpbmRvdy5hbmd1bGFyIHx8ICh3aW5kb3cuYW5ndWxhciA9IHt9KSxcbiAgICBhbmd1bGFyTW9kdWxlLFxuICAgIG5vZGVOYW1lXyxcbiAgICB1aWQgICAgICAgICAgICAgICA9IFsnMCcsICcwJywgJzAnXTtcblxuLyoqXG4gKiBJRSAxMSBjaGFuZ2VkIHRoZSBmb3JtYXQgb2YgdGhlIFVzZXJBZ2VudCBzdHJpbmcuXG4gKiBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM3NTAzLmFzcHhcbiAqL1xubXNpZSA9IGludCgoL21zaWUgKFxcZCspLy5leGVjKGxvd2VyY2FzZShuYXZpZ2F0b3IudXNlckFnZW50KSkgfHwgW10pWzFdKTtcbmlmIChpc05hTihtc2llKSkge1xuICBtc2llID0gaW50KCgvdHJpZGVudFxcLy4qOyBydjooXFxkKykvLmV4ZWMobG93ZXJjYXNlKG5hdmlnYXRvci51c2VyQWdlbnQpKSB8fCBbXSlbMV0pO1xufVxuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYG9iamAgaXMgYW4gYXJyYXkgb3IgYXJyYXktbGlrZSBvYmplY3QgKE5vZGVMaXN0LCBBcmd1bWVudHMsXG4gKiAgICAgICAgICAgICAgICAgICBTdHJpbmcgLi4uKVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IGlzV2luZG93KG9iaikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICBpZiAob2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGlzU3RyaW5nKG9iaikgfHwgaXNBcnJheShvYmopIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgYW5ndWxhci5mb3JFYWNoXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEludm9rZXMgdGhlIGBpdGVyYXRvcmAgZnVuY3Rpb24gb25jZSBmb3IgZWFjaCBpdGVtIGluIGBvYmpgIGNvbGxlY3Rpb24sIHdoaWNoIGNhbiBiZSBlaXRoZXIgYW5cbiAqIG9iamVjdCBvciBhbiBhcnJheS4gVGhlIGBpdGVyYXRvcmAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIGBpdGVyYXRvcih2YWx1ZSwga2V5KWAsIHdoZXJlIGB2YWx1ZWBcbiAqIGlzIHRoZSB2YWx1ZSBvZiBhbiBvYmplY3QgcHJvcGVydHkgb3IgYW4gYXJyYXkgZWxlbWVudCBhbmQgYGtleWAgaXMgdGhlIG9iamVjdCBwcm9wZXJ0eSBrZXkgb3JcbiAqIGFycmF5IGVsZW1lbnQgaW5kZXguIFNwZWNpZnlpbmcgYSBgY29udGV4dGAgZm9yIHRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbC5cbiAqXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBhbmd1bGFyLmZvcmVhY2hgLlxuICpcbiAgIDxwcmU+XG4gICAgIHZhciB2YWx1ZXMgPSB7bmFtZTogJ21pc2tvJywgZ2VuZGVyOiAnbWFsZSd9O1xuICAgICB2YXIgbG9nID0gW107XG4gICAgIGFuZ3VsYXIuZm9yRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuICAgICAgIHRoaXMucHVzaChrZXkgKyAnOiAnICsgdmFsdWUpO1xuICAgICB9LCBsb2cpO1xuICAgICBleHBlY3QobG9nKS50b0VxdWFsKFsnbmFtZTogbWlza28nLCAnZ2VuZGVyOm1hbGUnXSk7XG4gICA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIE9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvciBJdGVyYXRvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dCBPYmplY3QgdG8gYmVjb21lIGNvbnRleHQgKGB0aGlzYCkgZm9yIHRoZSBpdGVyYXRvciBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9IFJlZmVyZW5jZSB0byBgb2JqYC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gIHZhciBrZXk7XG4gIGlmIChvYmopIHtcbiAgICBpZiAoaXNGdW5jdGlvbihvYmopKXtcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGlmIGhhc093blByb3BlcnR5IGV4aXN0cyxcbiAgICAgICAgLy8gYXMgb24gSUU4IHRoZSByZXN1bHQgb2YgcXVlcnlTZWxlY3RvckFsbCBpcyBhbiBvYmplY3Qgd2l0aG91dCBhIGhhc093blByb3BlcnR5IGZ1bmN0aW9uXG4gICAgICAgIGlmIChrZXkgIT0gJ3Byb3RvdHlwZScgJiYga2V5ICE9ICdsZW5ndGgnICYmIGtleSAhPSAnbmFtZScgJiYgKCFvYmouaGFzT3duUHJvcGVydHkgfHwgb2JqLmhhc093blByb3BlcnR5KGtleSkpKSB7XG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqLmZvckVhY2ggJiYgb2JqLmZvckVhY2ggIT09IGZvckVhY2gpIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoa2V5ID0gMDsga2V5IDwgb2JqLmxlbmd0aDsga2V5KyspXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZEtleXMob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cy5zb3J0KCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTb3J0ZWQob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICB2YXIga2V5cyA9IHNvcnRlZEtleXMob2JqKTtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuXG4vKipcbiAqIHdoZW4gdXNpbmcgZm9yRWFjaCB0aGUgcGFyYW1zIGFyZSB2YWx1ZSwga2V5LCBidXQgaXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIGhhdmUga2V5LCB2YWx1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCAqKX0gaXRlcmF0b3JGblxuICogQHJldHVybnMge2Z1bmN0aW9uKCosIHN0cmluZyl9XG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VQYXJhbXMoaXRlcmF0b3JGbikge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGtleSkgeyBpdGVyYXRvckZuKGtleSwgdmFsdWUpOyB9O1xufVxuXG4vKipcbiAqIEEgY29uc2lzdGVudCB3YXkgb2YgY3JlYXRpbmcgdW5pcXVlIElEcyBpbiBhbmd1bGFyLiBUaGUgSUQgaXMgYSBzZXF1ZW5jZSBvZiBhbHBoYSBudW1lcmljXG4gKiBjaGFyYWN0ZXJzIHN1Y2ggYXMgJzAxMkFCQycuIFRoZSByZWFzb24gd2h5IHdlIGFyZSBub3QgdXNpbmcgc2ltcGx5IGEgbnVtYmVyIGNvdW50ZXIgaXMgdGhhdFxuICogdGhlIG51bWJlciBzdHJpbmcgZ2V0cyBsb25nZXIgb3ZlciB0aW1lLCBhbmQgaXQgY2FuIGFsc28gb3ZlcmZsb3csIHdoZXJlIGFzIHRoZSBuZXh0SWRcbiAqIHdpbGwgZ3JvdyBtdWNoIHNsb3dlciwgaXQgaXMgYSBzdHJpbmcsIGFuZCBpdCB3aWxsIG5ldmVyIG92ZXJmbG93LlxuICpcbiAqIEByZXR1cm5zIGFuIHVuaXF1ZSBhbHBoYS1udW1lcmljIHN0cmluZ1xuICovXG5mdW5jdGlvbiBuZXh0VWlkKCkge1xuICB2YXIgaW5kZXggPSB1aWQubGVuZ3RoO1xuICB2YXIgZGlnaXQ7XG5cbiAgd2hpbGUoaW5kZXgpIHtcbiAgICBpbmRleC0tO1xuICAgIGRpZ2l0ID0gdWlkW2luZGV4XS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChkaWdpdCA9PSA1NyAvKic5JyovKSB7XG4gICAgICB1aWRbaW5kZXhdID0gJ0EnO1xuICAgICAgcmV0dXJuIHVpZC5qb2luKCcnKTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0ID09IDkwICAvKidaJyovKSB7XG4gICAgICB1aWRbaW5kZXhdID0gJzAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1aWRbaW5kZXhdID0gU3RyaW5nLmZyb21DaGFyQ29kZShkaWdpdCArIDEpO1xuICAgICAgcmV0dXJuIHVpZC5qb2luKCcnKTtcbiAgICB9XG4gIH1cbiAgdWlkLnVuc2hpZnQoJzAnKTtcbiAgcmV0dXJuIHVpZC5qb2luKCcnKTtcbn1cblxuXG4vKipcbiAqIFNldCBvciBjbGVhciB0aGUgaGFzaGtleSBmb3IgYW4gb2JqZWN0LlxuICogQHBhcmFtIG9iaiBvYmplY3RcbiAqIEBwYXJhbSBoIHRoZSBoYXNoa2V5ICghdHJ1dGh5IHRvIGRlbGV0ZSB0aGUgaGFzaGtleSlcbiAqL1xuZnVuY3Rpb24gc2V0SGFzaEtleShvYmosIGgpIHtcbiAgaWYgKGgpIHtcbiAgICBvYmouJCRoYXNoS2V5ID0gaDtcbiAgfVxuICBlbHNlIHtcbiAgICBkZWxldGUgb2JqLiQkaGFzaEtleTtcbiAgfVxufVxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgYW5ndWxhci5leHRlbmRcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRXh0ZW5kcyB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGBkc3RgIGJ5IGNvcHlpbmcgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGBzcmNgIG9iamVjdChzKVxuICogdG8gYGRzdGAuIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSBgc3JjYCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNyYyBTb3VyY2Ugb2JqZWN0KHMpLlxuICogQHJldHVybnMge09iamVjdH0gUmVmZXJlbmNlIHRvIGBkc3RgLlxuICovXG5mdW5jdGlvbiBleHRlbmQoZHN0KSB7XG4gIHZhciBoID0gZHN0LiQkaGFzaEtleTtcbiAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG9iail7XG4gICAgaWYgKG9iaiAhPT0gZHN0KSB7XG4gICAgICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSl7XG4gICAgICAgIGRzdFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHNldEhhc2hLZXkoZHN0LGgpO1xuICByZXR1cm4gZHN0O1xufVxuXG5mdW5jdGlvbiBpbnQoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKTtcbn1cblxuXG5mdW5jdGlvbiBpbmhlcml0KHBhcmVudCwgZXh0cmEpIHtcbiAgcmV0dXJuIGV4dGVuZChuZXcgKGV4dGVuZChmdW5jdGlvbigpIHt9LCB7cHJvdG90eXBlOnBhcmVudH0pKSgpLCBleHRyYSk7XG59XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLm5vb3BcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIG5vIG9wZXJhdGlvbnMuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY29kZSBpbiB0aGVcbiAqIGZ1bmN0aW9uYWwgc3R5bGUuXG4gICA8cHJlPlxuICAgICBmdW5jdGlvbiBmb28oY2FsbGJhY2spIHtcbiAgICAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlUmVzdWx0KCk7XG4gICAgICAgKGNhbGxiYWNrIHx8IGFuZ3VsYXIubm9vcCkocmVzdWx0KTtcbiAgICAgfVxuICAgPC9wcmU+XG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC4kaW5qZWN0ID0gW107XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuaWRlbnRpdHlcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY29kZSBpbiB0aGVcbiAqIGZ1bmN0aW9uYWwgc3R5bGUuXG4gKlxuICAgPHByZT5cbiAgICAgZnVuY3Rpb24gdHJhbnNmb3JtZXIodHJhbnNmb3JtYXRpb25GbiwgdmFsdWUpIHtcbiAgICAgICByZXR1cm4gKHRyYW5zZm9ybWF0aW9uRm4gfHwgYW5ndWxhci5pZGVudGl0eSkodmFsdWUpO1xuICAgICB9O1xuICAgPC9wcmU+XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KCQpIHtyZXR1cm4gJDt9XG5pZGVudGl0eS4kaW5qZWN0ID0gW107XG5cblxuZnVuY3Rpb24gdmFsdWVGbih2YWx1ZSkge3JldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gdmFsdWU7fTt9XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmlzVW5kZWZpbmVkXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJzt9XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuaXNEZWZpbmVkXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJzt9XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuaXNPYmplY3RcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRGV0ZXJtaW5lcyBpZiBhIHJlZmVyZW5jZSBpcyBhbiBgT2JqZWN0YC4gVW5saWtlIGB0eXBlb2ZgIGluIEphdmFTY3JpcHQsIGBudWxsYHMgYXJlIG5vdFxuICogY29uc2lkZXJlZCB0byBiZSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhbiBgT2JqZWN0YCBidXQgbm90IGBudWxsYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpe3JldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7fVxuXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmlzU3RyaW5nXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYSBgU3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpe3JldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO31cblxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgYW5ndWxhci5pc051bWJlclxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGEgYE51bWJlcmAuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYE51bWJlcmAuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJzt9XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuaXNEYXRlXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVybWluZXMgaWYgYSB2YWx1ZSBpcyBhIGRhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBSZWZlcmVuY2UgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYERhdGVgLlxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgYW5ndWxhci5pc0FycmF5XG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVybWluZXMgaWYgYSByZWZlcmVuY2UgaXMgYW4gYEFycmF5YC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYW4gYEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuaXNGdW5jdGlvblxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGEgYEZ1bmN0aW9uYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFJlZmVyZW5jZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgYSBgRnVuY3Rpb25gLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKXtyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO31cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSB2YWx1ZSBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIGBSZWdFeHBgLlxuICovXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5cbi8qKlxuICogQ2hlY2tzIGlmIGBvYmpgIGlzIGEgd2luZG93IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqYCBpcyBhIHdpbmRvdyBvYmouXG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5kb2N1bWVudCAmJiBvYmoubG9jYXRpb24gJiYgb2JqLmFsZXJ0ICYmIG9iai5zZXRJbnRlcnZhbDtcbn1cblxuXG5mdW5jdGlvbiBpc1Njb3BlKG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai4kZXZhbEFzeW5jICYmIG9iai4kd2F0Y2g7XG59XG5cblxuZnVuY3Rpb24gaXNGaWxlKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cblxuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbn1cblxuXG52YXIgdHJpbSA9IChmdW5jdGlvbigpIHtcbiAgLy8gbmF0aXZlIHRyaW0gaXMgd2F5IGZhc3RlcjogaHR0cDovL2pzcGVyZi5jb20vYW5ndWxhci10cmltLXRlc3RcbiAgLy8gYnV0IElFIGRvZXNuJ3QgaGF2ZSBpdC4uLiA6LShcbiAgLy8gVE9ETzogd2Ugc2hvdWxkIG1vdmUgdGhpcyBpbnRvIElFL0VTNSBwb2x5ZmlsbFxuICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpIDogdmFsdWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmlzRWxlbWVudFxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEZXRlcm1pbmVzIGlmIGEgcmVmZXJlbmNlIGlzIGEgRE9NIGVsZW1lbnQgKG9yIHdyYXBwZWQgalF1ZXJ5IGVsZW1lbnQpLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgUmVmZXJlbmNlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50IChvciB3cmFwcGVkIGpRdWVyeSBlbGVtZW50KS5cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiZcbiAgICAobm9kZS5ub2RlTmFtZSAgLy8gd2UgYXJlIGEgZGlyZWN0IGVsZW1lbnRcbiAgICB8fCAobm9kZS5vbiAmJiBub2RlLmZpbmQpKSk7ICAvLyB3ZSBoYXZlIGFuIG9uIGFuZCBmaW5kIG1ldGhvZCBwYXJ0IG9mIGpRdWVyeSBBUElcbn1cblxuLyoqXG4gKiBAcGFyYW0gc3RyICdrZXkxLGtleTIsLi4uJ1xuICogQHJldHVybnMge29iamVjdH0gaW4gdGhlIGZvcm0gb2Yge2tleTE6dHJ1ZSwga2V5Mjp0cnVlLCAuLi59XG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyKXtcbiAgdmFyIG9iaiA9IHt9LCBpdGVtcyA9IHN0ci5zcGxpdChcIixcIiksIGk7XG4gIGZvciAoIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKysgKVxuICAgIG9ialsgaXRlbXNbaV0gXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cblxuaWYgKG1zaWUgPCA5KSB7XG4gIG5vZGVOYW1lXyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5ub2RlTmFtZSA/IGVsZW1lbnQgOiBlbGVtZW50WzBdO1xuICAgIHJldHVybiAoZWxlbWVudC5zY29wZU5hbWUgJiYgZWxlbWVudC5zY29wZU5hbWUgIT0gJ0hUTUwnKVxuICAgICAgPyB1cHBlcmNhc2UoZWxlbWVudC5zY29wZU5hbWUgKyAnOicgKyBlbGVtZW50Lm5vZGVOYW1lKSA6IGVsZW1lbnQubm9kZU5hbWU7XG4gIH07XG59IGVsc2Uge1xuICBub2RlTmFtZV8gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUgPyBlbGVtZW50Lm5vZGVOYW1lIDogZWxlbWVudFswXS5ub2RlTmFtZTtcbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBtYXAob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogRGV0ZXJtaW5lcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYW4gb2JqZWN0IGhhcywgb3JcbiAqIHRoZSBsZW5ndGggb2YgYSBzdHJpbmcuXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF1Z21lbnQgdGhlIE9iamVjdCB0eXBlIGluIEFuZ3VsYXIgZXhwcmVzc2lvbnMuIFNlZVxuICoge0BsaW5rIGFuZ3VsYXIuT2JqZWN0fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBBbmd1bGFyIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxzdHJpbmd9IG9iaiBPYmplY3QsIGFycmF5LCBvciBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW293blByb3BzT25seT1mYWxzZV0gQ291bnQgb25seSBcIm93blwiIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2l6ZSBvZiBgb2JqYCBvciBgMGAgaWYgYG9iamAgaXMgbmVpdGhlciBhbiBvYmplY3Qgbm9yIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBzaXplKG9iaiwgb3duUHJvcHNPbmx5KSB7XG4gIHZhciBjb3VudCA9IDAsIGtleTtcblxuICBpZiAoaXNBcnJheShvYmopIHx8IGlzU3RyaW5nKG9iaikpIHtcbiAgICByZXR1cm4gb2JqLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKXtcbiAgICBmb3IgKGtleSBpbiBvYmopXG4gICAgICBpZiAoIW93blByb3BzT25seSB8fCBvYmouaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgY291bnQrKztcbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn1cblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhhcnJheSwgb2JqKSB7XG4gIHJldHVybiBpbmRleE9mKGFycmF5LCBvYmopICE9IC0xO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKGFycmF5LCBvYmopIHtcbiAgaWYgKGFycmF5LmluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKG9iaik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmogPT09IGFycmF5W2ldKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGFycmF5UmVtb3ZlKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgaW5kZXggPSBpbmRleE9mKGFycmF5LCB2YWx1ZSk7XG4gIGlmIChpbmRleCA+PTApXG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBpc0xlYWZOb2RlIChub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVOYW1lKSB7XG4gICAgY2FzZSBcIk9QVElPTlwiOlxuICAgIGNhc2UgXCJQUkVcIjpcbiAgICBjYXNlIFwiVElUTEVcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmNvcHlcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiBgc291cmNlYCwgd2hpY2ggc2hvdWxkIGJlIGFuIG9iamVjdCBvciBhbiBhcnJheS5cbiAqXG4gKiAqIElmIG5vIGRlc3RpbmF0aW9uIGlzIHN1cHBsaWVkLCBhIGNvcHkgb2YgdGhlIG9iamVjdCBvciBhcnJheSBpcyBjcmVhdGVkLlxuICogKiBJZiBhIGRlc3RpbmF0aW9uIGlzIHByb3ZpZGVkLCBhbGwgb2YgaXRzIGVsZW1lbnRzIChmb3IgYXJyYXkpIG9yIHByb3BlcnRpZXMgKGZvciBvYmplY3RzKVxuICogICBhcmUgZGVsZXRlZCBhbmQgdGhlbiBhbGwgZWxlbWVudHMvcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2UgYXJlIGNvcGllZCB0byBpdC5cbiAqICogSWYgYHNvdXJjZWAgaXMgbm90IGFuIG9iamVjdCBvciBhcnJheSAoaW5jLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgKSwgYHNvdXJjZWAgaXMgcmV0dXJuZWQuXG4gKiAqIElmIGBzb3VyY2VgIGlzIGlkZW50aWNhbCB0byAnZGVzdGluYXRpb24nIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgc291cmNlIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1ha2UgYSBjb3B5LlxuICogICAgICAgICAgICAgICAgICAgQ2FuIGJlIGFueSB0eXBlLCBpbmNsdWRpbmcgcHJpbWl0aXZlcywgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGAuXG4gKiBAcGFyYW0geyhPYmplY3R8QXJyYXkpPX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gaW50byB3aGljaCB0aGUgc291cmNlIGlzIGNvcGllZC4gSWZcbiAqICAgICBwcm92aWRlZCwgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlIGFzIGBzb3VyY2VgLlxuICogQHJldHVybnMgeyp9IFRoZSBjb3B5IG9yIHVwZGF0ZWQgYGRlc3RpbmF0aW9uYCwgaWYgYGRlc3RpbmF0aW9uYCB3YXMgc3BlY2lmaWVkLlxuICpcbiAqIEBleGFtcGxlXG4gPGRvYzpleGFtcGxlPlxuIDxkb2M6c291cmNlPlxuIDxkaXYgbmctY29udHJvbGxlcj1cIkNvbnRyb2xsZXJcIj5cbiA8Zm9ybSBub3ZhbGlkYXRlIGNsYXNzPVwic2ltcGxlLWZvcm1cIj5cbiBOYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInVzZXIubmFtZVwiIC8+PGJyIC8+XG4gRS1tYWlsOiA8aW5wdXQgdHlwZT1cImVtYWlsXCIgbmctbW9kZWw9XCJ1c2VyLmVtYWlsXCIgLz48YnIgLz5cbiBHZW5kZXI6IDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuZy1tb2RlbD1cInVzZXIuZ2VuZGVyXCIgdmFsdWU9XCJtYWxlXCIgLz5tYWxlXG4gPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5nLW1vZGVsPVwidXNlci5nZW5kZXJcIiB2YWx1ZT1cImZlbWFsZVwiIC8+ZmVtYWxlPGJyIC8+XG4gPGJ1dHRvbiBuZy1jbGljaz1cInJlc2V0KClcIj5SRVNFVDwvYnV0dG9uPlxuIDxidXR0b24gbmctY2xpY2s9XCJ1cGRhdGUodXNlcilcIj5TQVZFPC9idXR0b24+XG4gPC9mb3JtPlxuIDxwcmU+Zm9ybSA9IHt7dXNlciB8IGpzb259fTwvcHJlPlxuIDxwcmU+bWFzdGVyID0ge3ttYXN0ZXIgfCBqc29ufX08L3ByZT5cbiA8L2Rpdj5cblxuIDxzY3JpcHQ+XG4gZnVuY3Rpb24gQ29udHJvbGxlcigkc2NvcGUpIHtcbiAgICAkc2NvcGUubWFzdGVyPSB7fTtcblxuICAgICRzY29wZS51cGRhdGUgPSBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAvLyBFeGFtcGxlIHdpdGggMSBhcmd1bWVudFxuICAgICAgJHNjb3BlLm1hc3Rlcj0gYW5ndWxhci5jb3B5KHVzZXIpO1xuICAgIH07XG5cbiAgICAkc2NvcGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4YW1wbGUgd2l0aCAyIGFyZ3VtZW50c1xuICAgICAgYW5ndWxhci5jb3B5KCRzY29wZS5tYXN0ZXIsICRzY29wZS51c2VyKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnJlc2V0KCk7XG4gIH1cbiA8L3NjcmlwdD5cbiA8L2RvYzpzb3VyY2U+XG4gPC9kb2M6ZXhhbXBsZT5cbiAqL1xuZnVuY3Rpb24gY29weShzb3VyY2UsIGRlc3RpbmF0aW9uKXtcbiAgaWYgKGlzV2luZG93KHNvdXJjZSkgfHwgaXNTY29wZShzb3VyY2UpKSB7XG4gICAgdGhyb3cgbmdNaW5FcnIoJ2Nwd3MnLFxuICAgICAgXCJDYW4ndCBjb3B5ISBNYWtpbmcgY29waWVzIG9mIFdpbmRvdyBvciBTY29wZSBpbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gIH1cblxuICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IGNvcHkoc291cmNlLCBbXSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGF0ZShzb3VyY2UpKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gbmV3IERhdGUoc291cmNlLmdldFRpbWUoKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHNvdXJjZSkpIHtcbiAgICAgICAgZGVzdGluYXRpb24gPSBuZXcgUmVnRXhwKHNvdXJjZS5zb3VyY2UpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gY29weShzb3VyY2UsIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gZGVzdGluYXRpb24pIHRocm93IG5nTWluRXJyKCdjcGknLFxuICAgICAgXCJDYW4ndCBjb3B5ISBTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSBpZGVudGljYWwuXCIpO1xuICAgIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVzdGluYXRpb24ucHVzaChjb3B5KHNvdXJjZVtpXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaCA9IGRlc3RpbmF0aW9uLiQkaGFzaEtleTtcbiAgICAgIGZvckVhY2goZGVzdGluYXRpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuICAgICAgICBkZWxldGUgZGVzdGluYXRpb25ba2V5XTtcbiAgICAgIH0pO1xuICAgICAgZm9yICggdmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IGNvcHkoc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgICAgc2V0SGFzaEtleShkZXN0aW5hdGlvbixoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkoc3JjLCBkc3QpIHtcbiAgZHN0ID0gZHN0IHx8IHt9O1xuXG4gIGZvcih2YXIga2V5IGluIHNyYykge1xuICAgIC8vIHNoYWxsb3dDb3B5IGlzIG9ubHkgZXZlciBjYWxsZWQgYnkgJGNvbXBpbGUgbm9kZUxpbmtGbiwgd2hpY2ggaGFzIGNvbnRyb2wgb3ZlciBzcmNcbiAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHVzaW5nIG91ciBjdXN0b20gaGFzT3duUHJvcGVydHkgaGVyZVxuICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkuY2hhckF0KDApICE9PSAnJCcgJiYga2V5LmNoYXJBdCgxKSAhPT0gJyQnKSB7XG4gICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuZXF1YWxzXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERldGVybWluZXMgaWYgdHdvIG9iamVjdHMgb3IgdHdvIHZhbHVlcyBhcmUgZXF1aXZhbGVudC4gU3VwcG9ydHMgdmFsdWUgdHlwZXMsIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb25zLCBhcnJheXMgYW5kIG9iamVjdHMuXG4gKlxuICogVHdvIG9iamVjdHMgb3IgdmFsdWVzIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAqXG4gKiAqIEJvdGggb2JqZWN0cyBvciB2YWx1ZXMgcGFzcyBgPT09YCBjb21wYXJpc29uLlxuICogKiBCb3RoIG9iamVjdHMgb3IgdmFsdWVzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCBhbGwgb2YgdGhlaXIgcHJvcGVydGllcyBhcmUgZXF1YWwgYnlcbiAqICAgY29tcGFyaW5nIHRoZW0gd2l0aCBgYW5ndWxhci5lcXVhbHNgLlxuICogKiBCb3RoIHZhbHVlcyBhcmUgTmFOLiAoSW4gSmF2YVNjcmlwdCwgTmFOID09IE5hTiA9PiBmYWxzZS4gQnV0IHdlIGNvbnNpZGVyIHR3byBOYU4gYXMgZXF1YWwpXG4gKiAqIEJvdGggdmFsdWVzIHJlcHJlc2VudCB0aGUgc2FtZSByZWd1bGFyIGV4cHJlc3Npb24gKEluIEphdmFzU2NyaXB0LFxuICogICAvYWJjLyA9PSAvYWJjLyA9PiBmYWxzZS4gQnV0IHdlIGNvbnNpZGVyIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGFzIGVxdWFsIHdoZW4gdGhlaXIgdGV4dHVhbFxuICogICByZXByZXNlbnRhdGlvbiBtYXRjaGVzKS5cbiAqXG4gKiBEdXJpbmcgYSBwcm9wZXJ0eSBjb21wYXJpc29uLCBwcm9wZXJ0aWVzIG9mIGBmdW5jdGlvbmAgdHlwZSBhbmQgcHJvcGVydGllcyB3aXRoIG5hbWVzXG4gKiB0aGF0IGJlZ2luIHdpdGggYCRgIGFyZSBpZ25vcmVkLlxuICpcbiAqIFNjb3BlIGFuZCBET01XaW5kb3cgb2JqZWN0cyBhcmUgYmVpbmcgY29tcGFyZWQgb25seSBieSBpZGVudGlmeSAoYD09PWApLlxuICpcbiAqIEBwYXJhbSB7Kn0gbzEgT2JqZWN0IG9yIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG8yIE9iamVjdCBvciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYXJndW1lbnRzIGFyZSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKG8xLCBvMikge1xuICBpZiAobzEgPT09IG8yKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvMSAhPT0gbzEgJiYgbzIgIT09IG8yKSByZXR1cm4gdHJ1ZTsgLy8gTmFOID09PSBOYU5cbiAgdmFyIHQxID0gdHlwZW9mIG8xLCB0MiA9IHR5cGVvZiBvMiwgbGVuZ3RoLCBrZXksIGtleVNldDtcbiAgaWYgKHQxID09IHQyKSB7XG4gICAgaWYgKHQxID09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShvMSkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KG8yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoKGxlbmd0aCA9IG8xLmxlbmd0aCkgPT0gbzIubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yKGtleT0wOyBrZXk8bGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMobzFba2V5XSwgbzJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKG8xKSkge1xuICAgICAgICByZXR1cm4gaXNEYXRlKG8yKSAmJiBvMS5nZXRUaW1lKCkgPT0gbzIuZ2V0VGltZSgpO1xuICAgICAgfSBlbHNlIGlmIChpc1JlZ0V4cChvMSkgJiYgaXNSZWdFeHAobzIpKSB7XG4gICAgICAgIHJldHVybiBvMS50b1N0cmluZygpID09IG8yLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTY29wZShvMSkgfHwgaXNTY29wZShvMikgfHwgaXNXaW5kb3cobzEpIHx8IGlzV2luZG93KG8yKSB8fCBpc0FycmF5KG8yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBrZXlTZXQgPSB7fTtcbiAgICAgICAgZm9yKGtleSBpbiBvMSkge1xuICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnJCcgfHwgaXNGdW5jdGlvbihvMVtrZXldKSkgY29udGludWU7XG4gICAgICAgICAgaWYgKCFlcXVhbHMobzFba2V5XSwgbzJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBrZXlTZXRba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGtleSBpbiBvMikge1xuICAgICAgICAgIGlmICgha2V5U2V0Lmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSAhPT0gJyQnICYmXG4gICAgICAgICAgICAgIG8yW2tleV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAhaXNGdW5jdGlvbihvMltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuZnVuY3Rpb24gY3NwKCkge1xuICByZXR1cm4gKGRvY3VtZW50LnNlY3VyaXR5UG9saWN5ICYmIGRvY3VtZW50LnNlY3VyaXR5UG9saWN5LmlzQWN0aXZlKSB8fFxuICAgICAgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgJiZcbiAgICAgICEhKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tuZy1jc3BdJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtbmctY3NwXScpKSk7XG59XG5cblxuZnVuY3Rpb24gY29uY2F0KGFycmF5MSwgYXJyYXkyLCBpbmRleCkge1xuICByZXR1cm4gYXJyYXkxLmNvbmNhdChzbGljZS5jYWxsKGFycmF5MiwgaW5kZXgpKTtcbn1cblxuZnVuY3Rpb24gc2xpY2VBcmdzKGFyZ3MsIHN0YXJ0SW5kZXgpIHtcbiAgcmV0dXJuIHNsaWNlLmNhbGwoYXJncywgc3RhcnRJbmRleCB8fCAwKTtcbn1cblxuXG4vKiBqc2hpbnQgLVcxMDEgKi9cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmJpbmRcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIGZ1bmN0aW9uIGBmbmAgYm91bmQgdG8gYHNlbGZgIChgc2VsZmAgYmVjb21lcyB0aGUgYHRoaXNgIGZvclxuICogYGZuYCkuIFlvdSBjYW4gc3VwcGx5IG9wdGlvbmFsIGBhcmdzYCB0aGF0IGFyZSBwcmVib3VuZCB0byB0aGUgZnVuY3Rpb24uIFRoaXMgZmVhdHVyZSBpcyBhbHNvXG4gKiBrbm93biBhcyBbcGFydGlhbCBhcHBsaWNhdGlvbl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJ0aWFsX2FwcGxpY2F0aW9uKSwgYXNcbiAqIGRpc3Rpbmd1aXNoZWQgZnJvbSBbZnVuY3Rpb24gY3VycnlpbmddKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3VycnlpbmcjQ29udHJhc3Rfd2l0aF9wYXJ0aWFsX2Z1bmN0aW9uX2FwcGxpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBDb250ZXh0IHdoaWNoIGBmbmAgc2hvdWxkIGJlIGV2YWx1YXRlZCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm4gRnVuY3Rpb24gdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgT3B0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHByZWJvdW5kIHRvIHRoZSBgZm5gIGZ1bmN0aW9uIGNhbGwuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKX0gRnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgYGZuYCB3aXRoIGFsbCB0aGUgc3BlY2lmaWVkIGJpbmRpbmdzLlxuICovXG4vKiBqc2hpbnQgK1cxMDEgKi9cbmZ1bmN0aW9uIGJpbmQoc2VsZiwgZm4pIHtcbiAgdmFyIGN1cnJ5QXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gc2xpY2VBcmdzKGFyZ3VtZW50cywgMikgOiBbXTtcbiAgaWYgKGlzRnVuY3Rpb24oZm4pICYmICEoZm4gaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgcmV0dXJuIGN1cnJ5QXJncy5sZW5ndGhcbiAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgID8gZm4uYXBwbHkoc2VsZiwgY3VycnlBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKVxuICAgICAgICAgICAgOiBmbi5hcHBseShzZWxmLCBjdXJyeUFyZ3MpO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICA/IGZuLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIDogZm4uY2FsbChzZWxmKTtcbiAgICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBJRSwgbmF0aXZlIG1ldGhvZHMgYXJlIG5vdCBmdW5jdGlvbnMgc28gdGhleSBjYW5ub3QgYmUgYm91bmQgKG5vdGU6IHRoZXkgZG9uJ3QgbmVlZCB0byBiZSlcbiAgICByZXR1cm4gZm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB0b0pzb25SZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIHZhciB2YWwgPSB2YWx1ZTtcblxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgdmFsID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGlzV2luZG93KHZhbHVlKSkge1xuICAgIHZhbCA9ICckV0lORE9XJztcbiAgfSBlbHNlIGlmICh2YWx1ZSAmJiAgZG9jdW1lbnQgPT09IHZhbHVlKSB7XG4gICAgdmFsID0gJyRET0NVTUVOVCc7XG4gIH0gZWxzZSBpZiAoaXNTY29wZSh2YWx1ZSkpIHtcbiAgICB2YWwgPSAnJFNDT1BFJztcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIudG9Kc29uXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNlcmlhbGl6ZXMgaW5wdXQgaW50byBhIEpTT04tZm9ybWF0dGVkIHN0cmluZy4gUHJvcGVydGllcyB3aXRoIGxlYWRpbmcgJCBjaGFyYWN0ZXJzIHdpbGwgYmVcbiAqIHN0cmlwcGVkIHNpbmNlIGFuZ3VsYXIgdXNlcyB0aGlzIG5vdGF0aW9uIGludGVybmFsbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8RGF0ZXxzdHJpbmd8bnVtYmVyfSBvYmogSW5wdXQgdG8gYmUgc2VyaWFsaXplZCBpbnRvIEpTT04uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwcmV0dHkgSWYgc2V0IHRvIHRydWUsIHRoZSBKU09OIG91dHB1dCB3aWxsIGNvbnRhaW4gbmV3bGluZXMgYW5kIHdoaXRlc3BhY2UuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gSlNPTi1pZmllZCBzdHJpbmcgcmVwcmVzZW50aW5nIGBvYmpgLlxuICovXG5mdW5jdGlvbiB0b0pzb24ob2JqLCBwcmV0dHkpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCB0b0pzb25SZXBsYWNlciwgcHJldHR5ID8gJyAgJyA6IG51bGwpO1xufVxuXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmZyb21Kc29uXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIERlc2VyaWFsaXplcyBhIEpTT04gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIEpTT04gc3RyaW5nIHRvIGRlc2VyaWFsaXplLlxuICogQHJldHVybnMge09iamVjdHxBcnJheXxEYXRlfHN0cmluZ3xudW1iZXJ9IERlc2VyaWFsaXplZCB0aGluZ3kuXG4gKi9cbmZ1bmN0aW9uIGZyb21Kc29uKGpzb24pIHtcbiAgcmV0dXJuIGlzU3RyaW5nKGpzb24pXG4gICAgICA/IEpTT04ucGFyc2UoanNvbilcbiAgICAgIDoganNvbjtcbn1cblxuXG5mdW5jdGlvbiB0b0Jvb2xlYW4odmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgIHZhciB2ID0gbG93ZXJjYXNlKFwiXCIgKyB2YWx1ZSk7XG4gICAgdmFsdWUgPSAhKHYgPT0gJ2YnIHx8IHYgPT0gJzAnIHx8IHYgPT0gJ2ZhbHNlJyB8fCB2ID09ICdubycgfHwgdiA9PSAnbicgfHwgdiA9PSAnW10nKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0aW5nVGFnKGVsZW1lbnQpIHtcbiAgZWxlbWVudCA9IGpxTGl0ZShlbGVtZW50KS5jbG9uZSgpO1xuICB0cnkge1xuICAgIC8vIHR1cm5zIG91dCBJRSBkb2VzIG5vdCBsZXQgeW91IHNldCAuaHRtbCgpIG9uIGVsZW1lbnRzIHdoaWNoXG4gICAgLy8gYXJlIG5vdCBhbGxvd2VkIHRvIGhhdmUgY2hpbGRyZW4uIFNvIHdlIGp1c3QgaWdub3JlIGl0LlxuICAgIGVsZW1lbnQuZW1wdHkoKTtcbiAgfSBjYXRjaChlKSB7fVxuICAvLyBBcyBQZXIgRE9NIFN0YW5kYXJkc1xuICB2YXIgVEVYVF9OT0RFID0gMztcbiAgdmFyIGVsZW1IdG1sID0ganFMaXRlKCc8ZGl2PicpLmFwcGVuZChlbGVtZW50KS5odG1sKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVsZW1lbnRbMF0ubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IGxvd2VyY2FzZShlbGVtSHRtbCkgOlxuICAgICAgICBlbGVtSHRtbC5cbiAgICAgICAgICBtYXRjaCgvXig8W14+XSs+KS8pWzFdLlxuICAgICAgICAgIHJlcGxhY2UoL148KFtcXHdcXC1dKykvLCBmdW5jdGlvbihtYXRjaCwgbm9kZU5hbWUpIHsgcmV0dXJuICc8JyArIGxvd2VyY2FzZShub2RlTmFtZSk7IH0pO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gbG93ZXJjYXNlKGVsZW1IdG1sKTtcbiAgfVxuXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFRyaWVzIHRvIGRlY29kZSB0aGUgVVJJIGNvbXBvbmVudCB3aXRob3V0IHRocm93aW5nIGFuIGV4Y2VwdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHN0ciB2YWx1ZSBwb3RlbnRpYWwgVVJJIGNvbXBvbmVudCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgY2FuIGJlIGRlY29kZWRcbiAqIHdpdGggdGhlIGRlY29kZVVSSUNvbXBvbmVudCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdHJ5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIElnbm9yZSBhbnkgaW52YWxpZCB1cmkgY29tcG9uZW50XG4gIH1cbn1cblxuXG4vKipcbiAqIFBhcnNlcyBhbiBlc2NhcGVkIHVybCBxdWVyeSBzdHJpbmcgaW50byBrZXktdmFsdWUgcGFpcnMuXG4gKiBAcmV0dXJucyBPYmplY3QuPChzdHJpbmd8Ym9vbGVhbik+XG4gKi9cbmZ1bmN0aW9uIHBhcnNlS2V5VmFsdWUoLyoqc3RyaW5nKi9rZXlWYWx1ZSkge1xuICB2YXIgb2JqID0ge30sIGtleV92YWx1ZSwga2V5O1xuICBmb3JFYWNoKChrZXlWYWx1ZSB8fCBcIlwiKS5zcGxpdCgnJicpLCBmdW5jdGlvbihrZXlWYWx1ZSl7XG4gICAgaWYgKCBrZXlWYWx1ZSApIHtcbiAgICAgIGtleV92YWx1ZSA9IGtleVZhbHVlLnNwbGl0KCc9Jyk7XG4gICAgICBrZXkgPSB0cnlEZWNvZGVVUklDb21wb25lbnQoa2V5X3ZhbHVlWzBdKTtcbiAgICAgIGlmICggaXNEZWZpbmVkKGtleSkgKSB7XG4gICAgICAgIHZhciB2YWwgPSBpc0RlZmluZWQoa2V5X3ZhbHVlWzFdKSA/IHRyeURlY29kZVVSSUNvbXBvbmVudChrZXlfdmFsdWVbMV0pIDogdHJ1ZTtcbiAgICAgICAgaWYgKCFvYmpba2V5XSkge1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9IGVsc2UgaWYoaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgICBvYmpba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV0sdmFsXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHRvS2V5VmFsdWUob2JqKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuICBmb3JFYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24oYXJyYXlWYWx1ZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVyaVF1ZXJ5KGtleSwgdHJ1ZSkgK1xuICAgICAgICAgICAgICAgICAgIChhcnJheVZhbHVlID09PSB0cnVlID8gJycgOiAnPScgKyBlbmNvZGVVcmlRdWVyeShhcnJheVZhbHVlLCB0cnVlKSkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZVVyaVF1ZXJ5KGtleSwgdHJ1ZSkgK1xuICAgICAgICAgICAgICAgKHZhbHVlID09PSB0cnVlID8gJycgOiAnPScgKyBlbmNvZGVVcmlRdWVyeSh2YWx1ZSwgdHJ1ZSkpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcGFydHMubGVuZ3RoID8gcGFydHMuam9pbignJicpIDogJyc7XG59XG5cblxuLyoqXG4gKiBXZSBuZWVkIG91ciBjdXN0b20gbWV0aG9kIGJlY2F1c2UgZW5jb2RlVVJJQ29tcG9uZW50IGlzIHRvbyBhZ2dyZXNzaXZlIGFuZCBkb2Vzbid0IGZvbGxvd1xuICogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzk4Ni50eHQgd2l0aCByZWdhcmRzIHRvIHRoZSBjaGFyYWN0ZXIgc2V0IChwY2hhcikgYWxsb3dlZCBpbiBwYXRoXG4gKiBzZWdtZW50czpcbiAqICAgIHNlZ21lbnQgICAgICAgPSAqcGNoYXJcbiAqICAgIHBjaGFyICAgICAgICAgPSB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgLyBcIkBcIlxuICogICAgcGN0LWVuY29kZWQgICA9IFwiJVwiIEhFWERJRyBIRVhESUdcbiAqICAgIHVucmVzZXJ2ZWQgICAgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAqICAgIHN1Yi1kZWxpbXMgICAgPSBcIiFcIiAvIFwiJFwiIC8gXCImXCIgLyBcIidcIiAvIFwiKFwiIC8gXCIpXCJcbiAqICAgICAgICAgICAgICAgICAgICAgLyBcIipcIiAvIFwiK1wiIC8gXCIsXCIgLyBcIjtcIiAvIFwiPVwiXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVyaVNlZ21lbnQodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVcmlRdWVyeSh2YWwsIHRydWUpLlxuICAgICAgICAgICAgIHJlcGxhY2UoLyUyNi9naSwgJyYnKS5cbiAgICAgICAgICAgICByZXBsYWNlKC8lM0QvZ2ksICc9JykuXG4gICAgICAgICAgICAgcmVwbGFjZSgvJTJCL2dpLCAnKycpO1xufVxuXG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGVuY29kaW5nICprZXkqIG9yICp2YWx1ZSogcGFydHMgb2YgcXVlcnkgY29tcG9uZW50LiBXZSBuZWVkIGEgY3VzdG9tXG4gKiBtZXRob2QgYmVjYXVzZSBlbmNvZGVVUklDb21wb25lbnQgaXMgdG9vIGFnZ3Jlc3NpdmUgYW5kIGVuY29kZXMgc3R1ZmYgdGhhdCBkb2Vzbid0IGhhdmUgdG8gYmVcbiAqIGVuY29kZWQgcGVyIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODY6XG4gKiAgICBxdWVyeSAgICAgICA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG4gKiAgICBwY2hhciAgICAgICAgID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAqICAgIHVucmVzZXJ2ZWQgICAgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAqICAgIHBjdC1lbmNvZGVkICAgPSBcIiVcIiBIRVhESUcgSEVYRElHXG4gKiAgICBzdWItZGVsaW1zICAgID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiXG4gKiAgICAgICAgICAgICAgICAgICAgIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICovXG5mdW5jdGlvbiBlbmNvZGVVcmlRdWVyeSh2YWwsIHBjdEVuY29kZVNwYWNlcykge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgICAgICAgICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgICAgICAgICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICAgICAgICAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICAgICAgICAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgICAgICAgICAgcmVwbGFjZSgvJTIwL2csIChwY3RFbmNvZGVTcGFjZXMgPyAnJTIwJyA6ICcrJykpO1xufVxuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQXBwXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2FuZ3VsYXIuTW9kdWxlfSBuZ0FwcCBhbiBvcHRpb25hbCBhcHBsaWNhdGlvblxuICogICB7QGxpbmsgYW5ndWxhci5tb2R1bGUgbW9kdWxlfSBuYW1lIHRvIGxvYWQuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVXNlIHRoaXMgZGlyZWN0aXZlIHRvICoqYXV0by1ib290c3RyYXAqKiBhbiBBbmd1bGFySlMgYXBwbGljYXRpb24uIFRoZSBgbmdBcHBgIGRpcmVjdGl2ZVxuICogZGVzaWduYXRlcyB0aGUgKipyb290IGVsZW1lbnQqKiBvZiB0aGUgYXBwbGljYXRpb24gYW5kIGlzIHR5cGljYWxseSBwbGFjZWQgbmVhciB0aGUgcm9vdCBlbGVtZW50XG4gKiBvZiB0aGUgcGFnZSAtIGUuZy4gb24gdGhlIGA8Ym9keT5gIG9yIGA8aHRtbD5gIHRhZ3MuXG4gKlxuICogT25seSBvbmUgQW5ndWxhckpTIGFwcGxpY2F0aW9uIGNhbiBiZSBhdXRvLWJvb3RzdHJhcHBlZCBwZXIgSFRNTCBkb2N1bWVudC4gVGhlIGZpcnN0IGBuZ0FwcGBcbiAqIGZvdW5kIGluIHRoZSBkb2N1bWVudCB3aWxsIGJlIHVzZWQgdG8gZGVmaW5lIHRoZSByb290IGVsZW1lbnQgdG8gYXV0by1ib290c3RyYXAgYXMgYW5cbiAqIGFwcGxpY2F0aW9uLiBUbyBydW4gbXVsdGlwbGUgYXBwbGljYXRpb25zIGluIGFuIEhUTUwgZG9jdW1lbnQgeW91IG11c3QgbWFudWFsbHkgYm9vdHN0cmFwIHRoZW0gdXNpbmdcbiAqIHtAbGluayBhbmd1bGFyLmJvb3RzdHJhcH0gaW5zdGVhZC4gQW5ndWxhckpTIGFwcGxpY2F0aW9ucyBjYW5ub3QgYmUgbmVzdGVkIHdpdGhpbiBlYWNoIG90aGVyLlxuICpcbiAqIFlvdSBjYW4gc3BlY2lmeSBhbiAqKkFuZ3VsYXJKUyBtb2R1bGUqKiB0byBiZSB1c2VkIGFzIHRoZSByb290IG1vZHVsZSBmb3IgdGhlIGFwcGxpY2F0aW9uLiAgVGhpc1xuICogbW9kdWxlIHdpbGwgYmUgbG9hZGVkIGludG8gdGhlIHtAbGluayBBVVRPLiRpbmplY3Rvcn0gd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgYm9vdHN0cmFwcGVkIGFuZFxuICogc2hvdWxkIGNvbnRhaW4gdGhlIGFwcGxpY2F0aW9uIGNvZGUgbmVlZGVkIG9yIGhhdmUgZGVwZW5kZW5jaWVzIG9uIG90aGVyIG1vZHVsZXMgdGhhdCB3aWxsXG4gKiBjb250YWluIHRoZSBjb2RlLiBTZWUge0BsaW5rIGFuZ3VsYXIubW9kdWxlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSBiZWxvdyBpZiB0aGUgYG5nQXBwYCBkaXJlY3RpdmUgd2VyZSBub3QgcGxhY2VkIG9uIHRoZSBgaHRtbGAgZWxlbWVudCB0aGVuIHRoZVxuICogZG9jdW1lbnQgd291bGQgbm90IGJlIGNvbXBpbGVkLCB0aGUgYEFwcENvbnRyb2xsZXJgIHdvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgYW5kIHRoZSBge3sgYStiIH19YFxuICogd291bGQgbm90IGJlIHJlc29sdmVkIHRvIGAzYC5cbiAqXG4gKiBgbmdBcHBgIGlzIHRoZSBlYXNpZXN0LCBhbmQgbW9zdCBjb21tb24sIHdheSB0byBib290c3RyYXAgYW4gYXBwbGljYXRpb24uXG4gKlxuIDxleGFtcGxlIG1vZHVsZT1cIm5nQXBwRGVtb1wiPlxuICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgIDxkaXYgbmctY29udHJvbGxlcj1cIm5nQXBwRGVtb0NvbnRyb2xsZXJcIj5cbiAgICAgSSBjYW4gYWRkOiB7e2F9fSArIHt7Yn19ID0gIHt7IGErYiB9fVxuICAgPC9maWxlPlxuICAgPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICAgYW5ndWxhci5tb2R1bGUoJ25nQXBwRGVtbycsIFtdKS5jb250cm9sbGVyKCduZ0FwcERlbW9Db250cm9sbGVyJywgZnVuY3Rpb24oJHNjb3BlKSB7XG4gICAgICRzY29wZS5hID0gMTtcbiAgICAgJHNjb3BlLmIgPSAyO1xuICAgfSk7XG4gICA8L2ZpbGU+XG4gPC9leGFtcGxlPlxuICpcbiAqL1xuZnVuY3Rpb24gYW5ndWxhckluaXQoZWxlbWVudCwgYm9vdHN0cmFwKSB7XG4gIHZhciBlbGVtZW50cyA9IFtlbGVtZW50XSxcbiAgICAgIGFwcEVsZW1lbnQsXG4gICAgICBtb2R1bGUsXG4gICAgICBuYW1lcyA9IFsnbmc6YXBwJywgJ25nLWFwcCcsICd4LW5nLWFwcCcsICdkYXRhLW5nLWFwcCddLFxuICAgICAgTkdfQVBQX0NMQVNTX1JFR0VYUCA9IC9cXHNuZ1s6XFwtXWFwcCg6XFxzKihbXFx3XFxkX10rKTs/KT9cXHMvO1xuXG4gIGZ1bmN0aW9uIGFwcGVuZChlbGVtZW50KSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgZm9yRWFjaChuYW1lcywgZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBhcHBlbmQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZSkpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoJzonLCAnXFxcXDonKTtcbiAgICBpZiAoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICBmb3JFYWNoKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBuYW1lKSwgYXBwZW5kKTtcbiAgICAgIGZvckVhY2goZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuJyArIG5hbWUgKyAnXFxcXDonKSwgYXBwZW5kKTtcbiAgICAgIGZvckVhY2goZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIG5hbWUgKyAnXScpLCBhcHBlbmQpO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yRWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghYXBwRWxlbWVudCkge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnO1xuICAgICAgdmFyIG1hdGNoID0gTkdfQVBQX0NMQVNTX1JFR0VYUC5leGVjKGNsYXNzTmFtZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgYXBwRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIG1vZHVsZSA9IChtYXRjaFsyXSB8fCAnJykucmVwbGFjZSgvXFxzKy9nLCAnLCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaChlbGVtZW50LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICBpZiAoIWFwcEVsZW1lbnQgJiYgbmFtZXNbYXR0ci5uYW1lXSkge1xuICAgICAgICAgICAgYXBwRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBtb2R1bGUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKGFwcEVsZW1lbnQpIHtcbiAgICBib290c3RyYXAoYXBwRWxlbWVudCwgbW9kdWxlID8gW21vZHVsZV0gOiBbXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIGFuZ3VsYXIuYm9vdHN0cmFwXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIG1hbnVhbGx5IHN0YXJ0IHVwIGFuZ3VsYXIgYXBwbGljYXRpb24uXG4gKlxuICogU2VlOiB7QGxpbmsgZ3VpZGUvYm9vdHN0cmFwIEJvb3RzdHJhcH1cbiAqXG4gKiBOb3RlIHRoYXQgbmdTY2VuYXJpby1iYXNlZCBlbmQtdG8tZW5kIHRlc3RzIGNhbm5vdCB1c2UgdGhpcyBmdW5jdGlvbiB0byBib290c3RyYXAgbWFudWFsbHkuXG4gKiBUaGV5IG11c3QgdXNlIHtAbGluayBhcGkvbmcuZGlyZWN0aXZlOm5nQXBwIG5nQXBwfS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRE9NIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHJvb3Qgb2YgYW5ndWxhciBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfEZ1bmN0aW9ufEFycmF5Pj19IG1vZHVsZXMgYW4gYXJyYXkgb2YgbW9kdWxlcyB0byBsb2FkIGludG8gdGhlIGFwcGxpY2F0aW9uLlxuICogICAgIEVhY2ggaXRlbSBpbiB0aGUgYXJyYXkgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIGEgcHJlZGVmaW5lZCBtb2R1bGUgb3IgYSAoREkgYW5ub3RhdGVkKVxuICogICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGJ5IHRoZSBpbmplY3RvciBhcyBhIHJ1biBibG9jay5cbiAqICAgICBTZWU6IHtAbGluayBhbmd1bGFyLm1vZHVsZSBtb2R1bGVzfVxuICogQHJldHVybnMge0FVVE8uJGluamVjdG9yfSBSZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIGluamVjdG9yIGZvciB0aGlzIGFwcC5cbiAqL1xuZnVuY3Rpb24gYm9vdHN0cmFwKGVsZW1lbnQsIG1vZHVsZXMpIHtcbiAgdmFyIGRvQm9vdHN0cmFwID0gZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudCA9IGpxTGl0ZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50LmluamVjdG9yKCkpIHtcbiAgICAgIHZhciB0YWcgPSAoZWxlbWVudFswXSA9PT0gZG9jdW1lbnQpID8gJ2RvY3VtZW50JyA6IHN0YXJ0aW5nVGFnKGVsZW1lbnQpO1xuICAgICAgdGhyb3cgbmdNaW5FcnIoJ2J0c3RycGQnLCBcIkFwcCBBbHJlYWR5IEJvb3RzdHJhcHBlZCB3aXRoIHRoaXMgRWxlbWVudCAnezB9J1wiLCB0YWcpO1xuICAgIH1cblxuICAgIG1vZHVsZXMgPSBtb2R1bGVzIHx8IFtdO1xuICAgIG1vZHVsZXMudW5zaGlmdChbJyRwcm92aWRlJywgZnVuY3Rpb24oJHByb3ZpZGUpIHtcbiAgICAgICRwcm92aWRlLnZhbHVlKCckcm9vdEVsZW1lbnQnLCBlbGVtZW50KTtcbiAgICB9XSk7XG4gICAgbW9kdWxlcy51bnNoaWZ0KCduZycpO1xuICAgIHZhciBpbmplY3RvciA9IGNyZWF0ZUluamVjdG9yKG1vZHVsZXMpO1xuICAgIGluamVjdG9yLmludm9rZShbJyRyb290U2NvcGUnLCAnJHJvb3RFbGVtZW50JywgJyRjb21waWxlJywgJyRpbmplY3RvcicsICckYW5pbWF0ZScsXG4gICAgICAgZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGNvbXBpbGUsIGluamVjdG9yLCBhbmltYXRlKSB7XG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50LmRhdGEoJyRpbmplY3RvcicsIGluamVjdG9yKTtcbiAgICAgICAgICBjb21waWxlKGVsZW1lbnQpKHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XVxuICAgICk7XG4gICAgcmV0dXJuIGluamVjdG9yO1xuICB9O1xuXG4gIHZhciBOR19ERUZFUl9CT09UU1RSQVAgPSAvXk5HX0RFRkVSX0JPT1RTVFJBUCEvO1xuXG4gIGlmICh3aW5kb3cgJiYgIU5HX0RFRkVSX0JPT1RTVFJBUC50ZXN0KHdpbmRvdy5uYW1lKSkge1xuICAgIHJldHVybiBkb0Jvb3RzdHJhcCgpO1xuICB9XG5cbiAgd2luZG93Lm5hbWUgPSB3aW5kb3cubmFtZS5yZXBsYWNlKE5HX0RFRkVSX0JPT1RTVFJBUCwgJycpO1xuICBhbmd1bGFyLnJlc3VtZUJvb3RzdHJhcCA9IGZ1bmN0aW9uKGV4dHJhTW9kdWxlcykge1xuICAgIGZvckVhY2goZXh0cmFNb2R1bGVzLCBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgIG1vZHVsZXMucHVzaChtb2R1bGUpO1xuICAgIH0pO1xuICAgIGRvQm9vdHN0cmFwKCk7XG4gIH07XG59XG5cbnZhciBTTkFLRV9DQVNFX1JFR0VYUCA9IC9bQS1aXS9nO1xuZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lLCBzZXBhcmF0b3Ipe1xuICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJ18nO1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKFNOQUtFX0NBU0VfUkVHRVhQLCBmdW5jdGlvbihsZXR0ZXIsIHBvcykge1xuICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiaW5kSlF1ZXJ5KCkge1xuICAvLyBiaW5kIHRvIGpRdWVyeSBpZiBwcmVzZW50O1xuICBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuICAvLyByZXNldCB0byBqUXVlcnkgb3IgZGVmYXVsdCB0byB1cy5cbiAgaWYgKGpRdWVyeSkge1xuICAgIGpxTGl0ZSA9IGpRdWVyeTtcbiAgICBleHRlbmQoalF1ZXJ5LmZuLCB7XG4gICAgICBzY29wZTogSlFMaXRlUHJvdG90eXBlLnNjb3BlLFxuICAgICAgaXNvbGF0ZVNjb3BlOiBKUUxpdGVQcm90b3R5cGUuaXNvbGF0ZVNjb3BlLFxuICAgICAgY29udHJvbGxlcjogSlFMaXRlUHJvdG90eXBlLmNvbnRyb2xsZXIsXG4gICAgICBpbmplY3RvcjogSlFMaXRlUHJvdG90eXBlLmluamVjdG9yLFxuICAgICAgaW5oZXJpdGVkRGF0YTogSlFMaXRlUHJvdG90eXBlLmluaGVyaXRlZERhdGFcbiAgICB9KTtcbiAgICAvLyBNZXRob2Qgc2lnbmF0dXJlOlxuICAgIC8vICAgICBqcUxpdGVQYXRjaEpRdWVyeVJlbW92ZShuYW1lLCBkaXNwYXRjaFRoaXMsIGZpbHRlckVsZW1zLCBnZXR0ZXJJZk5vQXJndW1lbnRzKVxuICAgIGpxTGl0ZVBhdGNoSlF1ZXJ5UmVtb3ZlKCdyZW1vdmUnLCB0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAganFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUoJ2VtcHR5JywgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAganFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUoJ2h0bWwnLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGpxTGl0ZSA9IEpRTGl0ZTtcbiAgfVxuICBhbmd1bGFyLmVsZW1lbnQgPSBqcUxpdGU7XG59XG5cbi8qKlxuICogdGhyb3cgZXJyb3IgaWYgdGhlIGFyZ3VtZW50IGlzIGZhbHN5LlxuICovXG5mdW5jdGlvbiBhc3NlcnRBcmcoYXJnLCBuYW1lLCByZWFzb24pIHtcbiAgaWYgKCFhcmcpIHtcbiAgICB0aHJvdyBuZ01pbkVycignYXJlcScsIFwiQXJndW1lbnQgJ3swfScgaXMgezF9XCIsIChuYW1lIHx8ICc/JyksIChyZWFzb24gfHwgXCJyZXF1aXJlZFwiKSk7XG4gIH1cbiAgcmV0dXJuIGFyZztcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJnRm4oYXJnLCBuYW1lLCBhY2NlcHRBcnJheUFubm90YXRpb24pIHtcbiAgaWYgKGFjY2VwdEFycmF5QW5ub3RhdGlvbiAmJiBpc0FycmF5KGFyZykpIHtcbiAgICAgIGFyZyA9IGFyZ1thcmcubGVuZ3RoIC0gMV07XG4gIH1cblxuICBhc3NlcnRBcmcoaXNGdW5jdGlvbihhcmcpLCBuYW1lLCAnbm90IGEgZnVuY3Rpb24sIGdvdCAnICtcbiAgICAgIChhcmcgJiYgdHlwZW9mIGFyZyA9PSAnb2JqZWN0JyA/IGFyZy5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnIDogdHlwZW9mIGFyZykpO1xuICByZXR1cm4gYXJnO1xufVxuXG4vKipcbiAqIHRocm93IGVycm9yIGlmIHRoZSBuYW1lIGdpdmVuIGlzIGhhc093blByb3BlcnR5XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgICAgdGhlIG5hbWUgdG8gdGVzdFxuICogQHBhcmFtICB7U3RyaW5nfSBjb250ZXh0IHRoZSBjb250ZXh0IGluIHdoaWNoIHRoZSBuYW1lIGlzIHVzZWQsIHN1Y2ggYXMgbW9kdWxlIG9yIGRpcmVjdGl2ZVxuICovXG5mdW5jdGlvbiBhc3NlcnROb3RIYXNPd25Qcm9wZXJ0eShuYW1lLCBjb250ZXh0KSB7XG4gIGlmIChuYW1lID09PSAnaGFzT3duUHJvcGVydHknKSB7XG4gICAgdGhyb3cgbmdNaW5FcnIoJ2JhZG5hbWUnLCBcImhhc093blByb3BlcnR5IGlzIG5vdCBhIHZhbGlkIHswfSBuYW1lXCIsIGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBhY2Nlc3NpYmxlIGZyb20gdGhlIG9iamVjdCBieSBwYXRoLiBBbnkgdW5kZWZpbmVkIHRyYXZlcnNhbHMgYXJlIGlnbm9yZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogc3RhcnRpbmcgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIHRyYXZlcnNlXG4gKiBAcGFyYW0ge2Jvb2xlYW49dHJ1ZX0gYmluZEZuVG9TY29wZVxuICogQHJldHVybnMgdmFsdWUgYXMgYWNjZXNzaWJsZSBieSBwYXRoXG4gKi9cbi8vVE9ETyhtaXNrbyk6IHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmVtb3ZlZFxuZnVuY3Rpb24gZ2V0dGVyKG9iaiwgcGF0aCwgYmluZEZuVG9TY29wZSkge1xuICBpZiAoIXBhdGgpIHJldHVybiBvYmo7XG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIga2V5O1xuICB2YXIgbGFzdEluc3RhbmNlID0gb2JqO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKG9iaikge1xuICAgICAgb2JqID0gKGxhc3RJbnN0YW5jZSA9IG9iailba2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKCFiaW5kRm5Ub1Njb3BlICYmIGlzRnVuY3Rpb24ob2JqKSkge1xuICAgIHJldHVybiBiaW5kKGxhc3RJbnN0YW5jZSwgb2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgRE9NIHNpYmxpbmdzIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgaW4gdGhlIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgbGlrZSBvYmplY3RcbiAqIEByZXR1cm5zIGpRbGl0ZSBvYmplY3QgY29udGFpbmluZyB0aGUgZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gZ2V0QmxvY2tFbGVtZW50cyhub2Rlcykge1xuICB2YXIgc3RhcnROb2RlID0gbm9kZXNbMF0sXG4gICAgICBlbmROb2RlID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gIGlmIChzdGFydE5vZGUgPT09IGVuZE5vZGUpIHtcbiAgICByZXR1cm4ganFMaXRlKHN0YXJ0Tm9kZSk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IHN0YXJ0Tm9kZTtcbiAgdmFyIGVsZW1lbnRzID0gW2VsZW1lbnRdO1xuXG4gIGRvIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcbiAgICBpZiAoIWVsZW1lbnQpIGJyZWFrO1xuICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gIH0gd2hpbGUgKGVsZW1lbnQgIT09IGVuZE5vZGUpO1xuXG4gIHJldHVybiBqcUxpdGUoZWxlbWVudHMpO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBpbnRlcmZhY2VcbiAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBJbnRlcmZhY2UgZm9yIGNvbmZpZ3VyaW5nIGFuZ3VsYXIge0BsaW5rIGFuZ3VsYXIubW9kdWxlIG1vZHVsZXN9LlxuICovXG5cbmZ1bmN0aW9uIHNldHVwTW9kdWxlTG9hZGVyKHdpbmRvdykge1xuXG4gIHZhciAkaW5qZWN0b3JNaW5FcnIgPSBtaW5FcnIoJyRpbmplY3RvcicpO1xuICB2YXIgbmdNaW5FcnIgPSBtaW5FcnIoJ25nJyk7XG5cbiAgZnVuY3Rpb24gZW5zdXJlKG9iaiwgbmFtZSwgZmFjdG9yeSkge1xuICAgIHJldHVybiBvYmpbbmFtZV0gfHwgKG9ialtuYW1lXSA9IGZhY3RvcnkoKSk7XG4gIH1cblxuICB2YXIgYW5ndWxhciA9IGVuc3VyZSh3aW5kb3csICdhbmd1bGFyJywgT2JqZWN0KTtcblxuICAvLyBXZSBuZWVkIHRvIGV4cG9zZSBgYW5ndWxhci4kJG1pbkVycmAgdG8gbW9kdWxlcyBzdWNoIGFzIGBuZ1Jlc291cmNlYCB0aGF0IHJlZmVyZW5jZSBpdCBkdXJpbmcgYm9vdHN0cmFwXG4gIGFuZ3VsYXIuJCRtaW5FcnIgPSBhbmd1bGFyLiQkbWluRXJyIHx8IG1pbkVycjtcblxuICByZXR1cm4gZW5zdXJlKGFuZ3VsYXIsICdtb2R1bGUnLCBmdW5jdGlvbigpIHtcbiAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBhbmd1bGFyLk1vZHVsZT59ICovXG4gICAgdmFyIG1vZHVsZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGFuZ3VsYXIubW9kdWxlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgYGFuZ3VsYXIubW9kdWxlYCBpcyBhIGdsb2JhbCBwbGFjZSBmb3IgY3JlYXRpbmcsIHJlZ2lzdGVyaW5nIGFuZCByZXRyaWV2aW5nIEFuZ3VsYXJcbiAgICAgKiBtb2R1bGVzLlxuICAgICAqIEFsbCBtb2R1bGVzIChhbmd1bGFyIGNvcmUgb3IgM3JkIHBhcnR5KSB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgdG8gYW4gYXBwbGljYXRpb24gbXVzdCBiZVxuICAgICAqIHJlZ2lzdGVyZWQgdXNpbmcgdGhpcyBtZWNoYW5pc20uXG4gICAgICpcbiAgICAgKiBXaGVuIHBhc3NlZCB0d28gb3IgbW9yZSBhcmd1bWVudHMsIGEgbmV3IG1vZHVsZSBpcyBjcmVhdGVkLiAgSWYgcGFzc2VkIG9ubHkgb25lIGFyZ3VtZW50LCBhblxuICAgICAqIGV4aXN0aW5nIG1vZHVsZSAodGhlIG5hbWUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgbW9kdWxlYCkgaXMgcmV0cmlldmVkLlxuICAgICAqXG4gICAgICpcbiAgICAgKiAjIE1vZHVsZVxuICAgICAqXG4gICAgICogQSBtb2R1bGUgaXMgYSBjb2xsZWN0aW9uIG9mIHNlcnZpY2VzLCBkaXJlY3RpdmVzLCBmaWx0ZXJzLCBhbmQgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgKiBgYW5ndWxhci5tb2R1bGVgIGlzIHVzZWQgdG8gY29uZmlndXJlIHRoZSB7QGxpbmsgQVVUTy4kaW5qZWN0b3IgJGluamVjdG9yfS5cbiAgICAgKlxuICAgICAqIDxwcmU+XG4gICAgICogLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZVxuICAgICAqIHZhciBteU1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdteU1vZHVsZScsIFtdKTtcbiAgICAgKlxuICAgICAqIC8vIHJlZ2lzdGVyIGEgbmV3IHNlcnZpY2VcbiAgICAgKiBteU1vZHVsZS52YWx1ZSgnYXBwTmFtZScsICdNeUNvb2xBcHAnKTtcbiAgICAgKlxuICAgICAqIC8vIGNvbmZpZ3VyZSBleGlzdGluZyBzZXJ2aWNlcyBpbnNpZGUgaW5pdGlhbGl6YXRpb24gYmxvY2tzLlxuICAgICAqIG15TW9kdWxlLmNvbmZpZyhmdW5jdGlvbigkbG9jYXRpb25Qcm92aWRlcikge1xuICAgICAqICAgLy8gQ29uZmlndXJlIGV4aXN0aW5nIHByb3ZpZGVyc1xuICAgICAqICAgJGxvY2F0aW9uUHJvdmlkZXIuaGFzaFByZWZpeCgnIScpO1xuICAgICAqIH0pO1xuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogVGhlbiB5b3UgY2FuIGNyZWF0ZSBhbiBpbmplY3RvciBhbmQgbG9hZCB5b3VyIG1vZHVsZXMgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBhbmd1bGFyLmluamVjdG9yKFsnbmcnLCAnTXlNb2R1bGUnXSlcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIgaXQncyBtb3JlIGxpa2VseSB0aGF0IHlvdSdsbCBqdXN0IHVzZVxuICAgICAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdBcHAgbmdBcHB9IG9yXG4gICAgICoge0BsaW5rIGFuZ3VsYXIuYm9vdHN0cmFwfSB0byBzaW1wbGlmeSB0aGlzIHByb2Nlc3MgZm9yIHlvdS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbW9kdWxlIHRvIGNyZWF0ZSBvciByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+PX0gcmVxdWlyZXMgSWYgc3BlY2lmaWVkIHRoZW4gbmV3IG1vZHVsZSBpcyBiZWluZyBjcmVhdGVkLiBJZlxuICAgICAqICAgICAgICB1bnNwZWNpZmllZCB0aGVuIHRoZSB0aGUgbW9kdWxlIGlzIGJlaW5nIHJldHJpZXZlZCBmb3IgZnVydGhlciBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZ0ZuIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBtb2R1bGUuIFNhbWUgYXNcbiAgICAgKiAgICAgICAge0BsaW5rIGFuZ3VsYXIuTW9kdWxlI21ldGhvZHNfY29uZmlnIE1vZHVsZSNjb25maWcoKX0uXG4gICAgICogQHJldHVybnMge21vZHVsZX0gbmV3IG1vZHVsZSB3aXRoIHRoZSB7QGxpbmsgYW5ndWxhci5Nb2R1bGV9IGFwaS5cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gbW9kdWxlKG5hbWUsIHJlcXVpcmVzLCBjb25maWdGbikge1xuICAgICAgdmFyIGFzc2VydE5vdEhhc093blByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2hhc093blByb3BlcnR5Jykge1xuICAgICAgICAgIHRocm93IG5nTWluRXJyKCdiYWRuYW1lJywgJ2hhc093blByb3BlcnR5IGlzIG5vdCBhIHZhbGlkIHswfSBuYW1lJywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGFzc2VydE5vdEhhc093blByb3BlcnR5KG5hbWUsICdtb2R1bGUnKTtcbiAgICAgIGlmIChyZXF1aXJlcyAmJiBtb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIG1vZHVsZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuc3VyZShtb2R1bGVzLCBuYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFyZXF1aXJlcykge1xuICAgICAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycignbm9tb2QnLCBcIk1vZHVsZSAnezB9JyBpcyBub3QgYXZhaWxhYmxlISBZb3UgZWl0aGVyIG1pc3NwZWxsZWQgXCIgK1xuICAgICAgICAgICAgIFwidGhlIG1vZHVsZSBuYW1lIG9yIGZvcmdvdCB0byBsb2FkIGl0LiBJZiByZWdpc3RlcmluZyBhIG1vZHVsZSBlbnN1cmUgdGhhdCB5b3UgXCIgK1xuICAgICAgICAgICAgIFwic3BlY2lmeSB0aGUgZGVwZW5kZW5jaWVzIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXCIsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXkuPEFycmF5LjwqPj59ICovXG4gICAgICAgIHZhciBpbnZva2VRdWV1ZSA9IFtdO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5LjxGdW5jdGlvbj59ICovXG4gICAgICAgIHZhciBydW5CbG9ja3MgPSBbXTtcblxuICAgICAgICB2YXIgY29uZmlnID0gaW52b2tlTGF0ZXIoJyRpbmplY3RvcicsICdpbnZva2UnKTtcblxuICAgICAgICAvKiogQHR5cGUge2FuZ3VsYXIuTW9kdWxlfSAqL1xuICAgICAgICB2YXIgbW9kdWxlSW5zdGFuY2UgPSB7XG4gICAgICAgICAgLy8gUHJpdmF0ZSBzdGF0ZVxuICAgICAgICAgIF9pbnZva2VRdWV1ZTogaW52b2tlUXVldWUsXG4gICAgICAgICAgX3J1bkJsb2NrczogcnVuQmxvY2tzLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5nZG9jIHByb3BlcnR5XG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjcmVxdWlyZXNcbiAgICAgICAgICAgKiBAcHJvcGVydHlPZiBhbmd1bGFyLk1vZHVsZVxuICAgICAgICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gTGlzdCBvZiBtb2R1bGUgbmFtZXMgd2hpY2ggbXVzdCBiZSBsb2FkZWQgYmVmb3JlIHRoaXMgbW9kdWxlLlxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqIEhvbGRzIHRoZSBsaXN0IG9mIG1vZHVsZXMgd2hpY2ggdGhlIGluamVjdG9yIHdpbGwgbG9hZCBiZWZvcmUgdGhlIGN1cnJlbnQgbW9kdWxlIGlzXG4gICAgICAgICAgICogbG9hZGVkLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJlcXVpcmVzOiByZXF1aXJlcyxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBwcm9wZXJ0eVxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI25hbWVcbiAgICAgICAgICAgKiBAcHJvcGVydHlPZiBhbmd1bGFyLk1vZHVsZVxuICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IE5hbWUgb2YgdGhlIG1vZHVsZS5cbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuYW1lOiBuYW1lLFxuXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjcHJvdmlkZXJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBzZXJ2aWNlIG5hbWVcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm92aWRlclR5cGUgQ29uc3RydWN0aW9uIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgdGhlXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZpY2UuXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogU2VlIHtAbGluayBBVVRPLiRwcm92aWRlI3Byb3ZpZGVyICRwcm92aWRlLnByb3ZpZGVyKCl9LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHByb3ZpZGVyOiBpbnZva2VMYXRlcignJHByb3ZpZGUnLCAncHJvdmlkZXInKSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNmYWN0b3J5XG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VydmljZSBuYW1lXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvdmlkZXJGdW5jdGlvbiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIHRoZSBzZXJ2aWNlLlxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNmYWN0b3J5ICRwcm92aWRlLmZhY3RvcnkoKX0uXG4gICAgICAgICAgICovXG4gICAgICAgICAgZmFjdG9yeTogaW52b2tlTGF0ZXIoJyRwcm92aWRlJywgJ2ZhY3RvcnknKSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNzZXJ2aWNlXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VydmljZSBuYW1lXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW5zdGFudGlhdGVkLlxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNzZXJ2aWNlICRwcm92aWRlLnNlcnZpY2UoKX0uXG4gICAgICAgICAgICovXG4gICAgICAgICAgc2VydmljZTogaW52b2tlTGF0ZXIoJyRwcm92aWRlJywgJ3NlcnZpY2UnKSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSN2YWx1ZVxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHNlcnZpY2UgbmFtZVxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFNlcnZpY2UgaW5zdGFuY2Ugb2JqZWN0LlxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSN2YWx1ZSAkcHJvdmlkZS52YWx1ZSgpfS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YWx1ZTogaW52b2tlTGF0ZXIoJyRwcm92aWRlJywgJ3ZhbHVlJyksXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjY29uc3RhbnRcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb25zdGFudCBuYW1lXG4gICAgICAgICAgICogQHBhcmFtIHsqfSBvYmplY3QgQ29uc3RhbnQgdmFsdWUuXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogQmVjYXVzZSB0aGUgY29uc3RhbnQgYXJlIGZpeGVkLCB0aGV5IGdldCBhcHBsaWVkIGJlZm9yZSBvdGhlciBwcm92aWRlIG1ldGhvZHMuXG4gICAgICAgICAgICogU2VlIHtAbGluayBBVVRPLiRwcm92aWRlI2NvbnN0YW50ICRwcm92aWRlLmNvbnN0YW50KCl9LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0YW50OiBpbnZva2VMYXRlcignJHByb3ZpZGUnLCAnY29uc3RhbnQnLCAndW5zaGlmdCcpLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2FuaW1hdGlvblxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGFuaW1hdGlvbiBuYW1lXG4gICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYW5pbWF0aW9uRmFjdG9yeSBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgYW5cbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5cbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICoqTk9URSoqOiBhbmltYXRpb25zIHRha2UgZWZmZWN0IG9ubHkgaWYgdGhlICoqbmdBbmltYXRlKiogbW9kdWxlIGlzIGxvYWRlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogRGVmaW5lcyBhbiBhbmltYXRpb24gaG9vayB0aGF0IGNhbiBiZSBsYXRlciB1c2VkIHdpdGhcbiAgICAgICAgICAgKiB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlICRhbmltYXRlfSBzZXJ2aWNlIGFuZCBkaXJlY3RpdmVzIHRoYXQgdXNlIHRoaXMgc2VydmljZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIDxwcmU+XG4gICAgICAgICAgICogbW9kdWxlLmFuaW1hdGlvbignLmFuaW1hdGlvbi1uYW1lJywgZnVuY3Rpb24oJGluamVjdDEsICRpbmplY3QyKSB7XG4gICAgICAgICAgICogICByZXR1cm4ge1xuICAgICAgICAgICAqICAgICBldmVudE5hbWUgOiBmdW5jdGlvbihlbGVtZW50LCBkb25lKSB7XG4gICAgICAgICAgICogICAgICAgLy9jb2RlIHRvIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICogICAgICAgLy9vbmNlIGNvbXBsZXRlLCB0aGVuIHJ1biBkb25lKClcbiAgICAgICAgICAgKiAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FuY2VsbGF0aW9uRnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAqICAgICAgICAgLy9jb2RlIHRvIGNhbmNlbCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICogICAgICAgfVxuICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICogICB9XG4gICAgICAgICAgICogfSlcbiAgICAgICAgICAgKiA8L3ByZT5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlUHJvdmlkZXIjcmVnaXN0ZXIgJGFuaW1hdGVQcm92aWRlci5yZWdpc3RlcigpfSBhbmRcbiAgICAgICAgICAgKiB7QGxpbmsgbmdBbmltYXRlIG5nQW5pbWF0ZSBtb2R1bGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFuaW1hdGlvbjogaW52b2tlTGF0ZXIoJyRhbmltYXRlUHJvdmlkZXInLCAncmVnaXN0ZXInKSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNmaWx0ZXJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWx0ZXIgbmFtZS5cbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJGYWN0b3J5IEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZSBvZiBmaWx0ZXIuXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogU2VlIHtAbGluayBuZy4kZmlsdGVyUHJvdmlkZXIjcmVnaXN0ZXIgJGZpbHRlclByb3ZpZGVyLnJlZ2lzdGVyKCl9LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZpbHRlcjogaW52b2tlTGF0ZXIoJyRmaWx0ZXJQcm92aWRlcicsICdyZWdpc3RlcicpLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI2NvbnRyb2xsZXJcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcbiAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IG5hbWUgQ29udHJvbGxlciBuYW1lLCBvciBhbiBvYmplY3QgbWFwIG9mIGNvbnRyb2xsZXJzIHdoZXJlIHRoZVxuICAgICAgICAgICAqICAgIGtleXMgYXJlIHRoZSBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIGNvbnN0cnVjdG9ycy5cbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDb250cm9sbGVyIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgICAqIFNlZSB7QGxpbmsgbmcuJGNvbnRyb2xsZXJQcm92aWRlciNyZWdpc3RlciAkY29udHJvbGxlclByb3ZpZGVyLnJlZ2lzdGVyKCl9LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnRyb2xsZXI6IGludm9rZUxhdGVyKCckY29udHJvbGxlclByb3ZpZGVyJywgJ3JlZ2lzdGVyJyksXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgICAgICogQG5hbWUgYW5ndWxhci5Nb2R1bGUjZGlyZWN0aXZlXG4gICAgICAgICAgICogQG1ldGhvZE9mIGFuZ3VsYXIuTW9kdWxlXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBuYW1lIERpcmVjdGl2ZSBuYW1lLCBvciBhbiBvYmplY3QgbWFwIG9mIGRpcmVjdGl2ZXMgd2hlcmUgdGhlXG4gICAgICAgICAgICogICAga2V5cyBhcmUgdGhlIG5hbWVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgZmFjdG9yaWVzLlxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpcmVjdGl2ZUZhY3RvcnkgRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mXG4gICAgICAgICAgICogZGlyZWN0aXZlcy5cbiAgICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICAgKiBTZWUge0BsaW5rIG5nLiRjb21waWxlUHJvdmlkZXIjbWV0aG9kc19kaXJlY3RpdmUgJGNvbXBpbGVQcm92aWRlci5kaXJlY3RpdmUoKX0uXG4gICAgICAgICAgICovXG4gICAgICAgICAgZGlyZWN0aXZlOiBpbnZva2VMYXRlcignJGNvbXBpbGVQcm92aWRlcicsICdkaXJlY3RpdmUnKSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAgICAgKiBAbmFtZSBhbmd1bGFyLk1vZHVsZSNjb25maWdcbiAgICAgICAgICAgKiBAbWV0aG9kT2YgYW5ndWxhci5Nb2R1bGVcbiAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWdGbiBFeGVjdXRlIHRoaXMgZnVuY3Rpb24gb24gbW9kdWxlIGxvYWQuIFVzZWZ1bCBmb3Igc2VydmljZVxuICAgICAgICAgICAqICAgIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIHdvcmsgd2hpY2ggbmVlZHMgdG8gYmUgcGVyZm9ybWVkIG9uIG1vZHVsZSBsb2FkaW5nLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAgICAgICAqIEBuYW1lIGFuZ3VsYXIuTW9kdWxlI3J1blxuICAgICAgICAgICAqIEBtZXRob2RPZiBhbmd1bGFyLk1vZHVsZVxuICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGluaXRpYWxpemF0aW9uRm4gRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIGFmdGVyIGluamVjdG9yIGNyZWF0aW9uLlxuICAgICAgICAgICAqICAgIFVzZWZ1bCBmb3IgYXBwbGljYXRpb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIHdvcmsgd2hpY2ggc2hvdWxkIGJlIHBlcmZvcm1lZCB3aGVuIHRoZSBpbmplY3RvciBpcyBkb25lXG4gICAgICAgICAgICogbG9hZGluZyBhbGwgbW9kdWxlcy5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBydW46IGZ1bmN0aW9uKGJsb2NrKSB7XG4gICAgICAgICAgICBydW5CbG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbmZpZ0ZuKSB7XG4gICAgICAgICAgY29uZmlnKGNvbmZpZ0ZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgbW9kdWxlSW5zdGFuY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm92aWRlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gaW5zZXJ0TWV0aG9kXG4gICAgICAgICAqIEByZXR1cm5zIHthbmd1bGFyLk1vZHVsZX1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGludm9rZUxhdGVyKHByb3ZpZGVyLCBtZXRob2QsIGluc2VydE1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGludm9rZVF1ZXVlW2luc2VydE1ldGhvZCB8fCAncHVzaCddKFtwcm92aWRlciwgbWV0aG9kLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVJbnN0YW5jZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9KTtcblxufVxuXG4vKiBnbG9iYWxcbiAgICBhbmd1bGFyTW9kdWxlOiB0cnVlLFxuICAgIHZlcnNpb246IHRydWUsXG4gICAgXG4gICAgJExvY2FsZVByb3ZpZGVyLFxuICAgICRDb21waWxlUHJvdmlkZXIsXG4gICAgXG4gICAgaHRtbEFuY2hvckRpcmVjdGl2ZSxcbiAgICBpbnB1dERpcmVjdGl2ZSxcbiAgICBpbnB1dERpcmVjdGl2ZSxcbiAgICBmb3JtRGlyZWN0aXZlLFxuICAgIHNjcmlwdERpcmVjdGl2ZSxcbiAgICBzZWxlY3REaXJlY3RpdmUsXG4gICAgc3R5bGVEaXJlY3RpdmUsXG4gICAgb3B0aW9uRGlyZWN0aXZlLFxuICAgIG5nQmluZERpcmVjdGl2ZSxcbiAgICBuZ0JpbmRIdG1sRGlyZWN0aXZlLFxuICAgIG5nQmluZFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIG5nQ2xhc3NEaXJlY3RpdmUsXG4gICAgbmdDbGFzc0V2ZW5EaXJlY3RpdmUsXG4gICAgbmdDbGFzc09kZERpcmVjdGl2ZSxcbiAgICBuZ0NzcERpcmVjdGl2ZSxcbiAgICBuZ0Nsb2FrRGlyZWN0aXZlLFxuICAgIG5nQ29udHJvbGxlckRpcmVjdGl2ZSxcbiAgICBuZ0Zvcm1EaXJlY3RpdmUsXG4gICAgbmdIaWRlRGlyZWN0aXZlLFxuICAgIG5nSWZEaXJlY3RpdmUsXG4gICAgbmdJbmNsdWRlRGlyZWN0aXZlLFxuICAgIG5nSW5jbHVkZUZpbGxDb250ZW50RGlyZWN0aXZlLFxuICAgIG5nSW5pdERpcmVjdGl2ZSxcbiAgICBuZ05vbkJpbmRhYmxlRGlyZWN0aXZlLFxuICAgIG5nUGx1cmFsaXplRGlyZWN0aXZlLFxuICAgIG5nUmVwZWF0RGlyZWN0aXZlLFxuICAgIG5nU2hvd0RpcmVjdGl2ZSxcbiAgICBuZ1N0eWxlRGlyZWN0aXZlLFxuICAgIG5nU3dpdGNoRGlyZWN0aXZlLFxuICAgIG5nU3dpdGNoV2hlbkRpcmVjdGl2ZSxcbiAgICBuZ1N3aXRjaERlZmF1bHREaXJlY3RpdmUsXG4gICAgbmdPcHRpb25zRGlyZWN0aXZlLFxuICAgIG5nVHJhbnNjbHVkZURpcmVjdGl2ZSxcbiAgICBuZ01vZGVsRGlyZWN0aXZlLFxuICAgIG5nTGlzdERpcmVjdGl2ZSxcbiAgICBuZ0NoYW5nZURpcmVjdGl2ZSxcbiAgICByZXF1aXJlZERpcmVjdGl2ZSxcbiAgICByZXF1aXJlZERpcmVjdGl2ZSxcbiAgICBuZ1ZhbHVlRGlyZWN0aXZlLFxuICAgIG5nQXR0cmlidXRlQWxpYXNEaXJlY3RpdmVzLFxuICAgIG5nRXZlbnREaXJlY3RpdmVzLFxuXG4gICAgJEFuY2hvclNjcm9sbFByb3ZpZGVyLFxuICAgICRBbmltYXRlUHJvdmlkZXIsXG4gICAgJEJyb3dzZXJQcm92aWRlcixcbiAgICAkQ2FjaGVGYWN0b3J5UHJvdmlkZXIsXG4gICAgJENvbnRyb2xsZXJQcm92aWRlcixcbiAgICAkRG9jdW1lbnRQcm92aWRlcixcbiAgICAkRXhjZXB0aW9uSGFuZGxlclByb3ZpZGVyLFxuICAgICRGaWx0ZXJQcm92aWRlcixcbiAgICAkSW50ZXJwb2xhdGVQcm92aWRlcixcbiAgICAkSW50ZXJ2YWxQcm92aWRlcixcbiAgICAkSHR0cFByb3ZpZGVyLFxuICAgICRIdHRwQmFja2VuZFByb3ZpZGVyLFxuICAgICRMb2NhdGlvblByb3ZpZGVyLFxuICAgICRMb2dQcm92aWRlcixcbiAgICAkUGFyc2VQcm92aWRlcixcbiAgICAkUm9vdFNjb3BlUHJvdmlkZXIsXG4gICAgJFFQcm92aWRlcixcbiAgICAkJFNhbml0aXplVXJpUHJvdmlkZXIsXG4gICAgJFNjZVByb3ZpZGVyLFxuICAgICRTY2VEZWxlZ2F0ZVByb3ZpZGVyLFxuICAgICRTbmlmZmVyUHJvdmlkZXIsXG4gICAgJFRlbXBsYXRlQ2FjaGVQcm92aWRlcixcbiAgICAkVGltZW91dFByb3ZpZGVyLFxuICAgICRXaW5kb3dQcm92aWRlclxuKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBwcm9wZXJ0eVxuICogQG5hbWUgYW5ndWxhci52ZXJzaW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IEFuZ3VsYXJKUyB2ZXJzaW9uLiBUaGlzIG9iamVjdCBoYXMgdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIGBmdWxsYCDigJMgYHtzdHJpbmd9YCDigJMgRnVsbCB2ZXJzaW9uIHN0cmluZywgc3VjaCBhcyBcIjAuOS4xOFwiLlxuICogLSBgbWFqb3JgIOKAkyBge251bWJlcn1gIOKAkyBNYWpvciB2ZXJzaW9uIG51bWJlciwgc3VjaCBhcyBcIjBcIi5cbiAqIC0gYG1pbm9yYCDigJMgYHtudW1iZXJ9YCDigJMgTWlub3IgdmVyc2lvbiBudW1iZXIsIHN1Y2ggYXMgXCI5XCIuXG4gKiAtIGBkb3RgIOKAkyBge251bWJlcn1gIOKAkyBEb3QgdmVyc2lvbiBudW1iZXIsIHN1Y2ggYXMgXCIxOFwiLlxuICogLSBgY29kZU5hbWVgIOKAkyBge3N0cmluZ31gIOKAkyBDb2RlIG5hbWUgb2YgdGhlIHJlbGVhc2UsIHN1Y2ggYXMgXCJqaWdnbGluZy1hcm1mYXRcIi5cbiAqL1xudmFyIHZlcnNpb24gPSB7XG4gIGZ1bGw6ICcxLjIuNicsICAgIC8vIGFsbCBvZiB0aGVzZSBwbGFjZWhvbGRlciBzdHJpbmdzIHdpbGwgYmUgcmVwbGFjZWQgYnkgZ3J1bnQnc1xuICBtYWpvcjogMSwgICAgLy8gcGFja2FnZSB0YXNrXG4gIG1pbm9yOiAyLFxuICBkb3Q6IDYsXG4gIGNvZGVOYW1lOiAndGFjby1zYWxzYWZpY2F0aW9uJ1xufTtcblxuXG5mdW5jdGlvbiBwdWJsaXNoRXh0ZXJuYWxBUEkoYW5ndWxhcil7XG4gIGV4dGVuZChhbmd1bGFyLCB7XG4gICAgJ2Jvb3RzdHJhcCc6IGJvb3RzdHJhcCxcbiAgICAnY29weSc6IGNvcHksXG4gICAgJ2V4dGVuZCc6IGV4dGVuZCxcbiAgICAnZXF1YWxzJzogZXF1YWxzLFxuICAgICdlbGVtZW50JzoganFMaXRlLFxuICAgICdmb3JFYWNoJzogZm9yRWFjaCxcbiAgICAnaW5qZWN0b3InOiBjcmVhdGVJbmplY3RvcixcbiAgICAnbm9vcCc6bm9vcCxcbiAgICAnYmluZCc6YmluZCxcbiAgICAndG9Kc29uJzogdG9Kc29uLFxuICAgICdmcm9tSnNvbic6IGZyb21Kc29uLFxuICAgICdpZGVudGl0eSc6aWRlbnRpdHksXG4gICAgJ2lzVW5kZWZpbmVkJzogaXNVbmRlZmluZWQsXG4gICAgJ2lzRGVmaW5lZCc6IGlzRGVmaW5lZCxcbiAgICAnaXNTdHJpbmcnOiBpc1N0cmluZyxcbiAgICAnaXNGdW5jdGlvbic6IGlzRnVuY3Rpb24sXG4gICAgJ2lzT2JqZWN0JzogaXNPYmplY3QsXG4gICAgJ2lzTnVtYmVyJzogaXNOdW1iZXIsXG4gICAgJ2lzRWxlbWVudCc6IGlzRWxlbWVudCxcbiAgICAnaXNBcnJheSc6IGlzQXJyYXksXG4gICAgJ3ZlcnNpb24nOiB2ZXJzaW9uLFxuICAgICdpc0RhdGUnOiBpc0RhdGUsXG4gICAgJ2xvd2VyY2FzZSc6IGxvd2VyY2FzZSxcbiAgICAndXBwZXJjYXNlJzogdXBwZXJjYXNlLFxuICAgICdjYWxsYmFja3MnOiB7Y291bnRlcjogMH0sXG4gICAgJyQkbWluRXJyJzogbWluRXJyLFxuICAgICckJGNzcCc6IGNzcFxuICB9KTtcblxuICBhbmd1bGFyTW9kdWxlID0gc2V0dXBNb2R1bGVMb2FkZXIod2luZG93KTtcbiAgdHJ5IHtcbiAgICBhbmd1bGFyTW9kdWxlKCduZ0xvY2FsZScpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYW5ndWxhck1vZHVsZSgnbmdMb2NhbGUnLCBbXSkucHJvdmlkZXIoJyRsb2NhbGUnLCAkTG9jYWxlUHJvdmlkZXIpO1xuICB9XG5cbiAgYW5ndWxhck1vZHVsZSgnbmcnLCBbJ25nTG9jYWxlJ10sIFsnJHByb3ZpZGUnLFxuICAgIGZ1bmN0aW9uIG5nTW9kdWxlKCRwcm92aWRlKSB7XG4gICAgICAvLyAkJHNhbml0aXplVXJpUHJvdmlkZXIgbmVlZHMgdG8gYmUgYmVmb3JlICRjb21waWxlUHJvdmlkZXIgYXMgaXQgaXMgdXNlZCBieSBpdC5cbiAgICAgICRwcm92aWRlLnByb3ZpZGVyKHtcbiAgICAgICAgJCRzYW5pdGl6ZVVyaTogJCRTYW5pdGl6ZVVyaVByb3ZpZGVyXG4gICAgICB9KTtcbiAgICAgICRwcm92aWRlLnByb3ZpZGVyKCckY29tcGlsZScsICRDb21waWxlUHJvdmlkZXIpLlxuICAgICAgICBkaXJlY3RpdmUoe1xuICAgICAgICAgICAgYTogaHRtbEFuY2hvckRpcmVjdGl2ZSxcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dERpcmVjdGl2ZSxcbiAgICAgICAgICAgIHRleHRhcmVhOiBpbnB1dERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGZvcm06IGZvcm1EaXJlY3RpdmUsXG4gICAgICAgICAgICBzY3JpcHQ6IHNjcmlwdERpcmVjdGl2ZSxcbiAgICAgICAgICAgIHNlbGVjdDogc2VsZWN0RGlyZWN0aXZlLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlRGlyZWN0aXZlLFxuICAgICAgICAgICAgb3B0aW9uOiBvcHRpb25EaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0JpbmQ6IG5nQmluZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nQmluZEh0bWw6IG5nQmluZEh0bWxEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0JpbmRUZW1wbGF0ZTogbmdCaW5kVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0NsYXNzOiBuZ0NsYXNzRGlyZWN0aXZlLFxuICAgICAgICAgICAgbmdDbGFzc0V2ZW46IG5nQ2xhc3NFdmVuRGlyZWN0aXZlLFxuICAgICAgICAgICAgbmdDbGFzc09kZDogbmdDbGFzc09kZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nQ2xvYWs6IG5nQ2xvYWtEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0NvbnRyb2xsZXI6IG5nQ29udHJvbGxlckRpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nRm9ybTogbmdGb3JtRGlyZWN0aXZlLFxuICAgICAgICAgICAgbmdIaWRlOiBuZ0hpZGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0lmOiBuZ0lmRGlyZWN0aXZlLFxuICAgICAgICAgICAgbmdJbmNsdWRlOiBuZ0luY2x1ZGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0luaXQ6IG5nSW5pdERpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nTm9uQmluZGFibGU6IG5nTm9uQmluZGFibGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ1BsdXJhbGl6ZTogbmdQbHVyYWxpemVEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ1JlcGVhdDogbmdSZXBlYXREaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ1Nob3c6IG5nU2hvd0RpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nU3R5bGU6IG5nU3R5bGVEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ1N3aXRjaDogbmdTd2l0Y2hEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ1N3aXRjaFdoZW46IG5nU3dpdGNoV2hlbkRpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nU3dpdGNoRGVmYXVsdDogbmdTd2l0Y2hEZWZhdWx0RGlyZWN0aXZlLFxuICAgICAgICAgICAgbmdPcHRpb25zOiBuZ09wdGlvbnNEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ1RyYW5zY2x1ZGU6IG5nVHJhbnNjbHVkZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nTW9kZWw6IG5nTW9kZWxEaXJlY3RpdmUsXG4gICAgICAgICAgICBuZ0xpc3Q6IG5nTGlzdERpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nQ2hhbmdlOiBuZ0NoYW5nZURpcmVjdGl2ZSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZERpcmVjdGl2ZSxcbiAgICAgICAgICAgIG5nUmVxdWlyZWQ6IHJlcXVpcmVkRGlyZWN0aXZlLFxuICAgICAgICAgICAgbmdWYWx1ZTogbmdWYWx1ZURpcmVjdGl2ZVxuICAgICAgICB9KS5cbiAgICAgICAgZGlyZWN0aXZlKHtcbiAgICAgICAgICBuZ0luY2x1ZGU6IG5nSW5jbHVkZUZpbGxDb250ZW50RGlyZWN0aXZlXG4gICAgICAgIH0pLlxuICAgICAgICBkaXJlY3RpdmUobmdBdHRyaWJ1dGVBbGlhc0RpcmVjdGl2ZXMpLlxuICAgICAgICBkaXJlY3RpdmUobmdFdmVudERpcmVjdGl2ZXMpO1xuICAgICAgJHByb3ZpZGUucHJvdmlkZXIoe1xuICAgICAgICAkYW5jaG9yU2Nyb2xsOiAkQW5jaG9yU2Nyb2xsUHJvdmlkZXIsXG4gICAgICAgICRhbmltYXRlOiAkQW5pbWF0ZVByb3ZpZGVyLFxuICAgICAgICAkYnJvd3NlcjogJEJyb3dzZXJQcm92aWRlcixcbiAgICAgICAgJGNhY2hlRmFjdG9yeTogJENhY2hlRmFjdG9yeVByb3ZpZGVyLFxuICAgICAgICAkY29udHJvbGxlcjogJENvbnRyb2xsZXJQcm92aWRlcixcbiAgICAgICAgJGRvY3VtZW50OiAkRG9jdW1lbnRQcm92aWRlcixcbiAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXI6ICRFeGNlcHRpb25IYW5kbGVyUHJvdmlkZXIsXG4gICAgICAgICRmaWx0ZXI6ICRGaWx0ZXJQcm92aWRlcixcbiAgICAgICAgJGludGVycG9sYXRlOiAkSW50ZXJwb2xhdGVQcm92aWRlcixcbiAgICAgICAgJGludGVydmFsOiAkSW50ZXJ2YWxQcm92aWRlcixcbiAgICAgICAgJGh0dHA6ICRIdHRwUHJvdmlkZXIsXG4gICAgICAgICRodHRwQmFja2VuZDogJEh0dHBCYWNrZW5kUHJvdmlkZXIsXG4gICAgICAgICRsb2NhdGlvbjogJExvY2F0aW9uUHJvdmlkZXIsXG4gICAgICAgICRsb2c6ICRMb2dQcm92aWRlcixcbiAgICAgICAgJHBhcnNlOiAkUGFyc2VQcm92aWRlcixcbiAgICAgICAgJHJvb3RTY29wZTogJFJvb3RTY29wZVByb3ZpZGVyLFxuICAgICAgICAkcTogJFFQcm92aWRlcixcbiAgICAgICAgJHNjZTogJFNjZVByb3ZpZGVyLFxuICAgICAgICAkc2NlRGVsZWdhdGU6ICRTY2VEZWxlZ2F0ZVByb3ZpZGVyLFxuICAgICAgICAkc25pZmZlcjogJFNuaWZmZXJQcm92aWRlcixcbiAgICAgICAgJHRlbXBsYXRlQ2FjaGU6ICRUZW1wbGF0ZUNhY2hlUHJvdmlkZXIsXG4gICAgICAgICR0aW1lb3V0OiAkVGltZW91dFByb3ZpZGVyLFxuICAgICAgICAkd2luZG93OiAkV2luZG93UHJvdmlkZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgXSk7XG59XG5cbi8qIGdsb2JhbFxuXG4gIC1KUUxpdGVQcm90b3R5cGUsXG4gIC1hZGRFdmVudExpc3RlbmVyRm4sXG4gIC1yZW1vdmVFdmVudExpc3RlbmVyRm4sXG4gIC1CT09MRUFOX0FUVFJcbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vSlFMaXRlXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmVsZW1lbnRcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV3JhcHMgYSByYXcgRE9NIGVsZW1lbnQgb3IgSFRNTCBzdHJpbmcgYXMgYSBbalF1ZXJ5XShodHRwOi8vanF1ZXJ5LmNvbSkgZWxlbWVudC5cbiAqXG4gKiBJZiBqUXVlcnkgaXMgYXZhaWxhYmxlLCBgYW5ndWxhci5lbGVtZW50YCBpcyBhbiBhbGlhcyBmb3IgdGhlXG4gKiBbalF1ZXJ5XShodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LykgZnVuY3Rpb24uIElmIGpRdWVyeSBpcyBub3QgYXZhaWxhYmxlLCBgYW5ndWxhci5lbGVtZW50YFxuICogZGVsZWdhdGVzIHRvIEFuZ3VsYXIncyBidWlsdC1pbiBzdWJzZXQgb2YgalF1ZXJ5LCBjYWxsZWQgXCJqUXVlcnkgbGl0ZVwiIG9yIFwianFMaXRlLlwiXG4gKlxuICogPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXN1Y2Nlc3NcIj5qcUxpdGUgaXMgYSB0aW55LCBBUEktY29tcGF0aWJsZSBzdWJzZXQgb2YgalF1ZXJ5IHRoYXQgYWxsb3dzXG4gKiBBbmd1bGFyIHRvIG1hbmlwdWxhdGUgdGhlIERPTSBpbiBhIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsZSB3YXkuICoqanFMaXRlKiogaW1wbGVtZW50cyBvbmx5IHRoZSBtb3N0XG4gKiBjb21tb25seSBuZWVkZWQgZnVuY3Rpb25hbGl0eSB3aXRoIHRoZSBnb2FsIG9mIGhhdmluZyBhIHZlcnkgc21hbGwgZm9vdHByaW50LjwvZGl2PlxuICpcbiAqIFRvIHVzZSBqUXVlcnksIHNpbXBseSBsb2FkIGl0IGJlZm9yZSBgRE9NQ29udGVudExvYWRlZGAgZXZlbnQgZmlyZWQuXG4gKlxuICogPGRpdiBjbGFzcz1cImFsZXJ0XCI+KipOb3RlOioqIGFsbCBlbGVtZW50IHJlZmVyZW5jZXMgaW4gQW5ndWxhciBhcmUgYWx3YXlzIHdyYXBwZWQgd2l0aCBqUXVlcnkgb3JcbiAqIGpxTGl0ZTsgdGhleSBhcmUgbmV2ZXIgcmF3IERPTSByZWZlcmVuY2VzLjwvZGl2PlxuICpcbiAqICMjIEFuZ3VsYXIncyBqcUxpdGVcbiAqIGpxTGl0ZSBwcm92aWRlcyBvbmx5IHRoZSBmb2xsb3dpbmcgalF1ZXJ5IG1ldGhvZHM6XG4gKlxuICogLSBbYGFkZENsYXNzKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vYWRkQ2xhc3MvKVxuICogLSBbYGFmdGVyKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vYWZ0ZXIvKVxuICogLSBbYGFwcGVuZCgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2FwcGVuZC8pXG4gKiAtIFtgYXR0cigpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2F0dHIvKVxuICogLSBbYGJpbmQoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9vbi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzLCBzZWxlY3RvcnMgb3IgZXZlbnREYXRhXG4gKiAtIFtgY2hpbGRyZW4oKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9jaGlsZHJlbi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBzZWxlY3RvcnNcbiAqIC0gW2BjbG9uZSgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2Nsb25lLylcbiAqIC0gW2Bjb250ZW50cygpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2NvbnRlbnRzLylcbiAqIC0gW2Bjc3MoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9jc3MvKVxuICogLSBbYGRhdGEoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9kYXRhLylcbiAqIC0gW2BlbXB0eSgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2VtcHR5LylcbiAqIC0gW2BlcSgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2VxLylcbiAqIC0gW2BmaW5kKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vZmluZC8pIC0gTGltaXRlZCB0byBsb29rdXBzIGJ5IHRhZyBuYW1lXG4gKiAtIFtgaGFzQ2xhc3MoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9oYXNDbGFzcy8pXG4gKiAtIFtgaHRtbCgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2h0bWwvKVxuICogLSBbYG5leHQoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9uZXh0LykgLSBEb2VzIG5vdCBzdXBwb3J0IHNlbGVjdG9yc1xuICogLSBbYG9uKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vb24vKSAtIERvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcywgc2VsZWN0b3JzIG9yIGV2ZW50RGF0YVxuICogLSBbYG9mZigpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL29mZi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG9yIHNlbGVjdG9yc1xuICogLSBbYG9uZSgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL29uZS8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG9yIHNlbGVjdG9yc1xuICogLSBbYHBhcmVudCgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3BhcmVudC8pIC0gRG9lcyBub3Qgc3VwcG9ydCBzZWxlY3RvcnNcbiAqIC0gW2BwcmVwZW5kKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcHJlcGVuZC8pXG4gKiAtIFtgcHJvcCgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3Byb3AvKVxuICogLSBbYHJlYWR5KClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVhZHkvKVxuICogLSBbYHJlbW92ZSgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlbW92ZS8pXG4gKiAtIFtgcmVtb3ZlQXR0cigpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlbW92ZUF0dHIvKVxuICogLSBbYHJlbW92ZUNsYXNzKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vcmVtb3ZlQ2xhc3MvKVxuICogLSBbYHJlbW92ZURhdGEoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9yZW1vdmVEYXRhLylcbiAqIC0gW2ByZXBsYWNlV2l0aCgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL3JlcGxhY2VXaXRoLylcbiAqIC0gW2B0ZXh0KClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vdGV4dC8pXG4gKiAtIFtgdG9nZ2xlQ2xhc3MoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS90b2dnbGVDbGFzcy8pXG4gKiAtIFtgdHJpZ2dlckhhbmRsZXIoKWBdKGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS90cmlnZ2VySGFuZGxlci8pIC0gUGFzc2VzIGEgZHVtbXkgZXZlbnQgb2JqZWN0IHRvIGhhbmRsZXJzLlxuICogLSBbYHVuYmluZCgpYF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL29mZi8pIC0gRG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzXG4gKiAtIFtgdmFsKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vdmFsLylcbiAqIC0gW2B3cmFwKClgXShodHRwOi8vYXBpLmpxdWVyeS5jb20vd3JhcC8pXG4gKlxuICogIyMgalF1ZXJ5L2pxTGl0ZSBFeHRyYXNcbiAqIEFuZ3VsYXIgYWxzbyBwcm92aWRlcyB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgZXZlbnRzIHRvIGJvdGggalF1ZXJ5IGFuZCBqcUxpdGU6XG4gKlxuICogIyMjIEV2ZW50c1xuICogLSBgJGRlc3Ryb3lgIC0gQW5ndWxhckpTIGludGVyY2VwdHMgYWxsIGpxTGl0ZS9qUXVlcnkncyBET00gZGVzdHJ1Y3Rpb24gYXBpcyBhbmQgZmlyZXMgdGhpcyBldmVudFxuICogICAgb24gYWxsIERPTSBub2RlcyBiZWluZyByZW1vdmVkLiAgVGhpcyBjYW4gYmUgdXNlZCB0byBjbGVhbiB1cCBhbnkgM3JkIHBhcnR5IGJpbmRpbmdzIHRvIHRoZSBET01cbiAqICAgIGVsZW1lbnQgYmVmb3JlIGl0IGlzIHJlbW92ZWQuXG4gKlxuICogIyMjIE1ldGhvZHNcbiAqIC0gYGNvbnRyb2xsZXIobmFtZSlgIC0gcmV0cmlldmVzIHRoZSBjb250cm9sbGVyIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgb3IgaXRzIHBhcmVudC4gQnkgZGVmYXVsdFxuICogICByZXRyaWV2ZXMgY29udHJvbGxlciBhc3NvY2lhdGVkIHdpdGggdGhlIGBuZ0NvbnRyb2xsZXJgIGRpcmVjdGl2ZS4gSWYgYG5hbWVgIGlzIHByb3ZpZGVkIGFzXG4gKiAgIGNhbWVsQ2FzZSBkaXJlY3RpdmUgbmFtZSwgdGhlbiB0aGUgY29udHJvbGxlciBmb3IgdGhpcyBkaXJlY3RpdmUgd2lsbCBiZSByZXRyaWV2ZWQgKGUuZy5cbiAqICAgYCduZ01vZGVsJ2ApLlxuICogLSBgaW5qZWN0b3IoKWAgLSByZXRyaWV2ZXMgdGhlIGluamVjdG9yIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQgb3IgaXRzIHBhcmVudC5cbiAqIC0gYHNjb3BlKClgIC0gcmV0cmlldmVzIHRoZSB7QGxpbmsgYXBpL25nLiRyb290U2NvcGUuU2NvcGUgc2NvcGV9IG9mIHRoZSBjdXJyZW50XG4gKiAgIGVsZW1lbnQgb3IgaXRzIHBhcmVudC5cbiAqIC0gYGlzb2xhdGVTY29wZSgpYCAtIHJldHJpZXZlcyBhbiBpc29sYXRlIHtAbGluayBhcGkvbmcuJHJvb3RTY29wZS5TY29wZSBzY29wZX0gaWYgb25lIGlzIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZVxuICogICBjdXJyZW50IGVsZW1lbnQuIFRoaXMgZ2V0dGVyIHNob3VsZCBiZSB1c2VkIG9ubHkgb24gZWxlbWVudHMgdGhhdCBjb250YWluIGEgZGlyZWN0aXZlIHdoaWNoIHN0YXJ0cyBhIG5ldyBpc29sYXRlXG4gKiAgIHNjb3BlLiBDYWxsaW5nIGBzY29wZSgpYCBvbiB0aGlzIGVsZW1lbnQgYWx3YXlzIHJldHVybnMgdGhlIG9yaWdpbmFsIG5vbi1pc29sYXRlIHNjb3BlLlxuICogLSBgaW5oZXJpdGVkRGF0YSgpYCAtIHNhbWUgYXMgYGRhdGEoKWAsIGJ1dCB3YWxrcyB1cCB0aGUgRE9NIHVudGlsIGEgdmFsdWUgaXMgZm91bmQgb3IgdGhlIHRvcFxuICogICBwYXJlbnQgZWxlbWVudCBpcyByZWFjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfERPTUVsZW1lbnR9IGVsZW1lbnQgSFRNTCBzdHJpbmcgb3IgRE9NRWxlbWVudCB0byBiZSB3cmFwcGVkIGludG8galF1ZXJ5LlxuICogQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdC5cbiAqL1xuXG52YXIganFDYWNoZSA9IEpRTGl0ZS5jYWNoZSA9IHt9LFxuICAgIGpxTmFtZSA9IEpRTGl0ZS5leHBhbmRvID0gJ25nLScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICBqcUlkID0gMSxcbiAgICBhZGRFdmVudExpc3RlbmVyRm4gPSAod2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXJcbiAgICAgID8gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgZm4pIHtlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGZhbHNlKTt9XG4gICAgICA6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7ZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pO30pLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJGbiA9ICh3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgPyBmdW5jdGlvbihlbGVtZW50LCB0eXBlLCBmbikge2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgZmFsc2UpOyB9XG4gICAgICA6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7ZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgZm4pOyB9KTtcblxuZnVuY3Rpb24ganFOZXh0SWQoKSB7IHJldHVybiArK2pxSWQ7IH1cblxuXG52YXIgU1BFQ0lBTF9DSEFSU19SRUdFWFAgPSAvKFtcXDpcXC1cXF9dKyguKSkvZztcbnZhciBNT1pfSEFDS19SRUdFWFAgPSAvXm1veihbQS1aXSkvO1xudmFyIGpxTGl0ZU1pbkVyciA9IG1pbkVycignanFMaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgc25ha2VfY2FzZSB0byBjYW1lbENhc2UuXG4gKiBBbHNvIHRoZXJlIGlzIHNwZWNpYWwgY2FzZSBmb3IgTW96IHByZWZpeCBzdGFydGluZyB3aXRoIHVwcGVyIGNhc2UgbGV0dGVyLlxuICogQHBhcmFtIG5hbWUgTmFtZSB0byBub3JtYWxpemVcbiAqL1xuZnVuY3Rpb24gY2FtZWxDYXNlKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuXG4gICAgcmVwbGFjZShTUEVDSUFMX0NIQVJTX1JFR0VYUCwgZnVuY3Rpb24oXywgc2VwYXJhdG9yLCBsZXR0ZXIsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIG9mZnNldCA/IGxldHRlci50b1VwcGVyQ2FzZSgpIDogbGV0dGVyO1xuICAgIH0pLlxuICAgIHJlcGxhY2UoTU9aX0hBQ0tfUkVHRVhQLCAnTW96JDEnKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBqUXVlcnkgbXV0YXRpb24gcGF0Y2hcbi8vXG4vLyBJbiBjb25qdW5jdGlvbiB3aXRoIGJpbmRKUXVlcnkgaW50ZXJjZXB0cyBhbGwgalF1ZXJ5J3MgRE9NIGRlc3RydWN0aW9uIGFwaXMgYW5kIGZpcmVzIGFcbi8vICRkZXN0cm95IGV2ZW50IG9uIGFsbCBET00gbm9kZXMgYmVpbmcgcmVtb3ZlZC5cbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24ganFMaXRlUGF0Y2hKUXVlcnlSZW1vdmUobmFtZSwgZGlzcGF0Y2hUaGlzLCBmaWx0ZXJFbGVtcywgZ2V0dGVySWZOb0FyZ3VtZW50cykge1xuICB2YXIgb3JpZ2luYWxKcUZuID0galF1ZXJ5LmZuW25hbWVdO1xuICBvcmlnaW5hbEpxRm4gPSBvcmlnaW5hbEpxRm4uJG9yaWdpbmFsIHx8IG9yaWdpbmFsSnFGbjtcbiAgcmVtb3ZlUGF0Y2guJG9yaWdpbmFsID0gb3JpZ2luYWxKcUZuO1xuICBqUXVlcnkuZm5bbmFtZV0gPSByZW1vdmVQYXRjaDtcblxuICBmdW5jdGlvbiByZW1vdmVQYXRjaChwYXJhbSkge1xuICAgIC8vIGpzaGludCAtVzA0MFxuICAgIHZhciBsaXN0ID0gZmlsdGVyRWxlbXMgJiYgcGFyYW0gPyBbdGhpcy5maWx0ZXIocGFyYW0pXSA6IFt0aGlzXSxcbiAgICAgICAgZmlyZUV2ZW50ID0gZGlzcGF0Y2hUaGlzLFxuICAgICAgICBzZXQsIHNldEluZGV4LCBzZXRMZW5ndGgsXG4gICAgICAgIGVsZW1lbnQsIGNoaWxkSW5kZXgsIGNoaWxkTGVuZ3RoLCBjaGlsZHJlbjtcblxuICAgIGlmICghZ2V0dGVySWZOb0FyZ3VtZW50cyB8fCBwYXJhbSAhPSBudWxsKSB7XG4gICAgICB3aGlsZShsaXN0Lmxlbmd0aCkge1xuICAgICAgICBzZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGZvcihzZXRJbmRleCA9IDAsIHNldExlbmd0aCA9IHNldC5sZW5ndGg7IHNldEluZGV4IDwgc2V0TGVuZ3RoOyBzZXRJbmRleCsrKSB7XG4gICAgICAgICAgZWxlbWVudCA9IGpxTGl0ZShzZXRbc2V0SW5kZXhdKTtcbiAgICAgICAgICBpZiAoZmlyZUV2ZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCckZGVzdHJveScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQgPSAhZmlyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IoY2hpbGRJbmRleCA9IDAsIGNoaWxkTGVuZ3RoID0gKGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbigpKS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNoaWxkSW5kZXggPCBjaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goalF1ZXJ5KGNoaWxkcmVuW2NoaWxkSW5kZXhdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW5hbEpxRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIEpRTGl0ZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSlFMaXRlKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEpRTGl0ZSkpIHtcbiAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT0gJzwnKSB7XG4gICAgICB0aHJvdyBqcUxpdGVNaW5FcnIoJ25vc2VsJywgJ0xvb2tpbmcgdXAgZWxlbWVudHMgdmlhIHNlbGVjdG9ycyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGpxTGl0ZSEgU2VlOiBodHRwOi8vZG9jcy5hbmd1bGFyanMub3JnL2FwaS9hbmd1bGFyLmVsZW1lbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBKUUxpdGUoZWxlbWVudCk7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gUmVhZCBhYm91dCB0aGUgTm9TY29wZSBlbGVtZW50cyBoZXJlOlxuICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMzg5NyhWUy44NSkuYXNweFxuICAgIGRpdi5pbm5lckhUTUwgPSAnPGRpdj4mIzE2MDs8L2Rpdj4nICsgZWxlbWVudDsgLy8gSUUgaW5zYW5pdHkgdG8gbWFrZSBOb1Njb3BlIGVsZW1lbnRzIHdvcmshXG4gICAgZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTsgLy8gcmVtb3ZlIHRoZSBzdXBlcmZsdW91cyBkaXZcbiAgICBqcUxpdGVBZGROb2Rlcyh0aGlzLCBkaXYuY2hpbGROb2Rlcyk7XG4gICAgdmFyIGZyYWdtZW50ID0ganFMaXRlKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgZnJhZ21lbnQuYXBwZW5kKHRoaXMpOyAvLyBkZXRhY2ggdGhlIGVsZW1lbnRzIGZyb20gdGhlIHRlbXBvcmFyeSBET00gZGl2LlxuICB9IGVsc2Uge1xuICAgIGpxTGl0ZUFkZE5vZGVzKHRoaXMsIGVsZW1lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGpxTGl0ZUNsb25lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xufVxuXG5mdW5jdGlvbiBqcUxpdGVEZWFsb2MoZWxlbWVudCl7XG4gIGpxTGl0ZVJlbW92ZURhdGEoZWxlbWVudCk7XG4gIGZvciAoIHZhciBpID0gMCwgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMgfHwgW107IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGpxTGl0ZURlYWxvYyhjaGlsZHJlbltpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24ganFMaXRlT2ZmKGVsZW1lbnQsIHR5cGUsIGZuLCB1bnN1cHBvcnRlZCkge1xuICBpZiAoaXNEZWZpbmVkKHVuc3VwcG9ydGVkKSkgdGhyb3cganFMaXRlTWluRXJyKCdvZmZhcmdzJywgJ2pxTGl0ZSNvZmYoKSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgc2VsZWN0b3JgIGFyZ3VtZW50Jyk7XG5cbiAgdmFyIGV2ZW50cyA9IGpxTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnZXZlbnRzJyksXG4gICAgICBoYW5kbGUgPSBqcUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2hhbmRsZScpO1xuXG4gIGlmICghaGFuZGxlKSByZXR1cm47IC8vbm8gbGlzdGVuZXJzIHJlZ2lzdGVyZWRcblxuICBpZiAoaXNVbmRlZmluZWQodHlwZSkpIHtcbiAgICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXZlbnRIYW5kbGVyLCB0eXBlKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyRm4oZWxlbWVudCwgdHlwZSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaCh0eXBlLnNwbGl0KCcgJyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChmbikpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckZuKGVsZW1lbnQsIHR5cGUsIGV2ZW50c1t0eXBlXSk7XG4gICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVJlbW92ZShldmVudHNbdHlwZV0gfHwgW10sIGZuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBqcUxpdGVSZW1vdmVEYXRhKGVsZW1lbnQsIG5hbWUpIHtcbiAgdmFyIGV4cGFuZG9JZCA9IGVsZW1lbnRbanFOYW1lXSxcbiAgICAgIGV4cGFuZG9TdG9yZSA9IGpxQ2FjaGVbZXhwYW5kb0lkXTtcblxuICBpZiAoZXhwYW5kb1N0b3JlKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSBqcUNhY2hlW2V4cGFuZG9JZF0uZGF0YVtuYW1lXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXhwYW5kb1N0b3JlLmhhbmRsZSkge1xuICAgICAgZXhwYW5kb1N0b3JlLmV2ZW50cy4kZGVzdHJveSAmJiBleHBhbmRvU3RvcmUuaGFuZGxlKHt9LCAnJGRlc3Ryb3knKTtcbiAgICAgIGpxTGl0ZU9mZihlbGVtZW50KTtcbiAgICB9XG4gICAgZGVsZXRlIGpxQ2FjaGVbZXhwYW5kb0lkXTtcbiAgICBlbGVtZW50W2pxTmFtZV0gPSB1bmRlZmluZWQ7IC8vIGllIGRvZXMgbm90IGFsbG93IGRlbGV0aW9uIG9mIGF0dHJpYnV0ZXMgb24gZWxlbWVudHMuXG4gIH1cbn1cblxuZnVuY3Rpb24ganFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIGV4cGFuZG9JZCA9IGVsZW1lbnRbanFOYW1lXSxcbiAgICAgIGV4cGFuZG9TdG9yZSA9IGpxQ2FjaGVbZXhwYW5kb0lkIHx8IC0xXTtcblxuICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgIGlmICghZXhwYW5kb1N0b3JlKSB7XG4gICAgICBlbGVtZW50W2pxTmFtZV0gPSBleHBhbmRvSWQgPSBqcU5leHRJZCgpO1xuICAgICAgZXhwYW5kb1N0b3JlID0ganFDYWNoZVtleHBhbmRvSWRdID0ge307XG4gICAgfVxuICAgIGV4cGFuZG9TdG9yZVtrZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGFuZG9TdG9yZSAmJiBleHBhbmRvU3RvcmVba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBqcUxpdGVEYXRhKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBqcUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2RhdGEnKSxcbiAgICAgIGlzU2V0dGVyID0gaXNEZWZpbmVkKHZhbHVlKSxcbiAgICAgIGtleURlZmluZWQgPSAhaXNTZXR0ZXIgJiYgaXNEZWZpbmVkKGtleSksXG4gICAgICBpc1NpbXBsZUdldHRlciA9IGtleURlZmluZWQgJiYgIWlzT2JqZWN0KGtleSk7XG5cbiAgaWYgKCFkYXRhICYmICFpc1NpbXBsZUdldHRlcikge1xuICAgIGpxTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnZGF0YScsIGRhdGEgPSB7fSk7XG4gIH1cblxuICBpZiAoaXNTZXR0ZXIpIHtcbiAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoa2V5RGVmaW5lZCkge1xuICAgICAgaWYgKGlzU2ltcGxlR2V0dGVyKSB7XG4gICAgICAgIC8vIGRvbid0IGNyZWF0ZSBkYXRhIGluIHRoaXMgY2FzZS5cbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgZGF0YVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW5kKGRhdGEsIGtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqcUxpdGVIYXNDbGFzcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoKFwiIFwiICsgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiKS5yZXBsYWNlKC9bXFxuXFx0XS9nLCBcIiBcIikuXG4gICAgICBpbmRleE9mKCBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCIgKSA+IC0xKTtcbn1cblxuZnVuY3Rpb24ganFMaXRlUmVtb3ZlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3Nlcykge1xuICBpZiAoY3NzQ2xhc3NlcyAmJiBlbGVtZW50LnNldEF0dHJpYnV0ZSkge1xuICAgIGZvckVhY2goY3NzQ2xhc3Nlcy5zcGxpdCgnICcpLCBmdW5jdGlvbihjc3NDbGFzcykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdHJpbShcbiAgICAgICAgICAoXCIgXCIgKyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCIpXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXG5cXHRdL2csIFwiIFwiKVxuICAgICAgICAgIC5yZXBsYWNlKFwiIFwiICsgdHJpbShjc3NDbGFzcykgKyBcIiBcIiwgXCIgXCIpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBqcUxpdGVBZGRDbGFzcyhlbGVtZW50LCBjc3NDbGFzc2VzKSB7XG4gIGlmIChjc3NDbGFzc2VzICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIGV4aXN0aW5nQ2xhc3NlcyA9ICgnICcgKyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXFx0XS9nLCBcIiBcIik7XG5cbiAgICBmb3JFYWNoKGNzc0NsYXNzZXMuc3BsaXQoJyAnKSwgZnVuY3Rpb24oY3NzQ2xhc3MpIHtcbiAgICAgIGNzc0NsYXNzID0gdHJpbShjc3NDbGFzcyk7XG4gICAgICBpZiAoZXhpc3RpbmdDbGFzc2VzLmluZGV4T2YoJyAnICsgY3NzQ2xhc3MgKyAnICcpID09PSAtMSkge1xuICAgICAgICBleGlzdGluZ0NsYXNzZXMgKz0gY3NzQ2xhc3MgKyAnICc7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0cmltKGV4aXN0aW5nQ2xhc3NlcykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGpxTGl0ZUFkZE5vZGVzKHJvb3QsIGVsZW1lbnRzKSB7XG4gIGlmIChlbGVtZW50cykge1xuICAgIGVsZW1lbnRzID0gKCFlbGVtZW50cy5ub2RlTmFtZSAmJiBpc0RlZmluZWQoZWxlbWVudHMubGVuZ3RoKSAmJiAhaXNXaW5kb3coZWxlbWVudHMpKVxuICAgICAgPyBlbGVtZW50c1xuICAgICAgOiBbIGVsZW1lbnRzIF07XG4gICAgZm9yKHZhciBpPTA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcm9vdC5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ganFMaXRlQ29udHJvbGxlcihlbGVtZW50LCBuYW1lKSB7XG4gIHJldHVybiBqcUxpdGVJbmhlcml0ZWREYXRhKGVsZW1lbnQsICckJyArIChuYW1lIHx8ICduZ0NvbnRyb2xsZXInICkgKyAnQ29udHJvbGxlcicpO1xufVxuXG5mdW5jdGlvbiBqcUxpdGVJbmhlcml0ZWREYXRhKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGVsZW1lbnQgPSBqcUxpdGUoZWxlbWVudCk7XG5cbiAgLy8gaWYgZWxlbWVudCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IHdvcmsgd2l0aCB0aGUgaHRtbCBlbGVtZW50IGluc3RlYWRcbiAgLy8gdGhpcyBtYWtlcyAkKGRvY3VtZW50KS5zY29wZSgpIHBvc3NpYmxlXG4gIGlmKGVsZW1lbnRbMF0ubm9kZVR5cGUgPT0gOSkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LmZpbmQoJ2h0bWwnKTtcbiAgfVxuICB2YXIgbmFtZXMgPSBpc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXTtcblxuICB3aGlsZSAoZWxlbWVudC5sZW5ndGgpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG5hbWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmICgodmFsdWUgPSBlbGVtZW50LmRhdGEobmFtZXNbaV0pKSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGpxTGl0ZUVtcHR5KGVsZW1lbnQpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAganFMaXRlRGVhbG9jKGNoaWxkTm9kZXNbaV0pO1xuICB9XG4gIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBGdW5jdGlvbnMgd2hpY2ggYXJlIGRlY2xhcmVkIGRpcmVjdGx5LlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgSlFMaXRlUHJvdG90eXBlID0gSlFMaXRlLnByb3RvdHlwZSA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKCkge1xuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBmbigpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGRvY3VtZW50IGFscmVhZHkgaXMgbG9hZGVkXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpe1xuICAgICAgc2V0VGltZW91dCh0cmlnZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignRE9NQ29udGVudExvYWRlZCcsIHRyaWdnZXIpOyAvLyB3b3JrcyBmb3IgbW9kZXJuIGJyb3dzZXJzIGFuZCBJRTlcbiAgICAgIC8vIHdlIGNhbiBub3QgdXNlIGpxTGl0ZSBzaW5jZSB3ZSBhcmUgbm90IGRvbmUgbG9hZGluZyBhbmQgalF1ZXJ5IGNvdWxkIGJlIGxvYWRlZCBsYXRlci5cbiAgICAgIC8vIGpzaGludCAtVzA2NFxuICAgICAgSlFMaXRlKHdpbmRvdykub24oJ2xvYWQnLCB0cmlnZ2VyKTsgLy8gZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCBmb3Igb3RoZXJzXG4gICAgICAvLyBqc2hpbnQgK1cwNjRcbiAgICB9XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICBmb3JFYWNoKHRoaXMsIGZ1bmN0aW9uKGUpeyB2YWx1ZS5wdXNoKCcnICsgZSk7fSk7XG4gICAgcmV0dXJuICdbJyArIHZhbHVlLmpvaW4oJywgJykgKyAnXSc7XG4gIH0sXG5cbiAgZXE6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4ID49IDApID8ganFMaXRlKHRoaXNbaW5kZXhdKSA6IGpxTGl0ZSh0aGlzW3RoaXMubGVuZ3RoICsgaW5kZXhdKTtcbiAgfSxcblxuICBsZW5ndGg6IDAsXG4gIHB1c2g6IHB1c2gsXG4gIHNvcnQ6IFtdLnNvcnQsXG4gIHNwbGljZTogW10uc3BsaWNlXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEZ1bmN0aW9ucyBpdGVyYXRpbmcgZ2V0dGVyL3NldHRlcnMuXG4vLyB0aGVzZSBmdW5jdGlvbnMgcmV0dXJuIHNlbGYgb24gc2V0dGVyIGFuZFxuLy8gdmFsdWUgb24gZ2V0LlxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgQk9PTEVBTl9BVFRSID0ge307XG5mb3JFYWNoKCdtdWx0aXBsZSxzZWxlY3RlZCxjaGVja2VkLGRpc2FibGVkLHJlYWRPbmx5LHJlcXVpcmVkLG9wZW4nLnNwbGl0KCcsJyksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gIEJPT0xFQU5fQVRUUltsb3dlcmNhc2UodmFsdWUpXSA9IHZhbHVlO1xufSk7XG52YXIgQk9PTEVBTl9FTEVNRU5UUyA9IHt9O1xuZm9yRWFjaCgnaW5wdXQsc2VsZWN0LG9wdGlvbix0ZXh0YXJlYSxidXR0b24sZm9ybSxkZXRhaWxzJy5zcGxpdCgnLCcpLCBmdW5jdGlvbih2YWx1ZSkge1xuICBCT09MRUFOX0VMRU1FTlRTW3VwcGVyY2FzZSh2YWx1ZSldID0gdHJ1ZTtcbn0pO1xuXG5mdW5jdGlvbiBnZXRCb29sZWFuQXR0ck5hbWUoZWxlbWVudCwgbmFtZSkge1xuICAvLyBjaGVjayBkb20gbGFzdCBzaW5jZSB3ZSB3aWxsIG1vc3QgbGlrZWx5IGZhaWwgb24gbmFtZVxuICB2YXIgYm9vbGVhbkF0dHIgPSBCT09MRUFOX0FUVFJbbmFtZS50b0xvd2VyQ2FzZSgpXTtcblxuICAvLyBib29sZWFuQXR0ciBpcyBoZXJlIHR3aWNlIHRvIG1pbmltaXplIERPTSBhY2Nlc3NcbiAgcmV0dXJuIGJvb2xlYW5BdHRyICYmIEJPT0xFQU5fRUxFTUVOVFNbZWxlbWVudC5ub2RlTmFtZV0gJiYgYm9vbGVhbkF0dHI7XG59XG5cbmZvckVhY2goe1xuICBkYXRhOiBqcUxpdGVEYXRhLFxuICBpbmhlcml0ZWREYXRhOiBqcUxpdGVJbmhlcml0ZWREYXRhLFxuXG4gIHNjb3BlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgLy8gQ2FuJ3QgdXNlIGpxTGl0ZURhdGEgaGVyZSBkaXJlY3RseSBzbyB3ZSBzdGF5IGNvbXBhdGlibGUgd2l0aCBqUXVlcnkhXG4gICAgcmV0dXJuIGpxTGl0ZShlbGVtZW50KS5kYXRhKCckc2NvcGUnKSB8fCBqcUxpdGVJbmhlcml0ZWREYXRhKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50LCBbJyRpc29sYXRlU2NvcGUnLCAnJHNjb3BlJ10pO1xuICB9LFxuXG4gIGlzb2xhdGVTY29wZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIENhbid0IHVzZSBqcUxpdGVEYXRhIGhlcmUgZGlyZWN0bHkgc28gd2Ugc3RheSBjb21wYXRpYmxlIHdpdGggalF1ZXJ5IVxuICAgIHJldHVybiBqcUxpdGUoZWxlbWVudCkuZGF0YSgnJGlzb2xhdGVTY29wZScpIHx8IGpxTGl0ZShlbGVtZW50KS5kYXRhKCckaXNvbGF0ZVNjb3BlTm9UZW1wbGF0ZScpO1xuICB9LFxuXG4gIGNvbnRyb2xsZXI6IGpxTGl0ZUNvbnRyb2xsZXIgLFxuXG4gIGluamVjdG9yOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGpxTGl0ZUluaGVyaXRlZERhdGEoZWxlbWVudCwgJyRpbmplY3RvcicpO1xuICB9LFxuXG4gIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKGVsZW1lbnQsbmFtZSkge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9LFxuXG4gIGhhc0NsYXNzOiBqcUxpdGVIYXNDbGFzcyxcblxuICBjc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcblxuICAgIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWw7XG5cbiAgICAgIGlmIChtc2llIDw9IDgpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBzb21lIElFIHNwZWNpZmljIHdlaXJkbmVzcyB0aGF0IGpRdWVyeSAxLjYuNCBkb2VzIG5vdCBzdXJlIHdoeVxuICAgICAgICB2YWwgPSBlbGVtZW50LmN1cnJlbnRTdHlsZSAmJiBlbGVtZW50LmN1cnJlbnRTdHlsZVtuYW1lXTtcbiAgICAgICAgaWYgKHZhbCA9PT0gJycpIHZhbCA9ICdhdXRvJztcbiAgICAgIH1cblxuICAgICAgdmFsID0gdmFsIHx8IGVsZW1lbnQuc3R5bGVbbmFtZV07XG5cbiAgICAgIGlmIChtc2llIDw9IDgpIHtcbiAgICAgICAgLy8ganF1ZXJ5IHdlaXJkbmVzcyA6LS9cbiAgICAgICAgdmFsID0gKHZhbCA9PT0gJycpID8gdW5kZWZpbmVkIDogdmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIHZhbDtcbiAgICB9XG4gIH0sXG5cbiAgYXR0cjogZnVuY3Rpb24oZWxlbWVudCwgbmFtZSwgdmFsdWUpe1xuICAgIHZhciBsb3dlcmNhc2VkTmFtZSA9IGxvd2VyY2FzZShuYW1lKTtcbiAgICBpZiAoQk9PTEVBTl9BVFRSW2xvd2VyY2FzZWROYW1lXSkge1xuICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCEhdmFsdWUpIHtcbiAgICAgICAgICBlbGVtZW50W25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCBsb3dlcmNhc2VkTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudFtuYW1lXSA9IGZhbHNlO1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGxvd2VyY2FzZWROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChlbGVtZW50W25hbWVdIHx8XG4gICAgICAgICAgICAgICAgIChlbGVtZW50LmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKG5hbWUpfHwgbm9vcCkuc3BlY2lmaWVkKVxuICAgICAgICAgICAgICAgPyBsb3dlcmNhc2VkTmFtZVxuICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgLy8gdGhlIGV4dHJhIGFyZ3VtZW50IFwiMlwiIGlzIHRvIGdldCB0aGUgcmlnaHQgdGhpbmcgZm9yIGEuaHJlZiBpbiBJRSwgc2VlIGpRdWVyeSBjb2RlXG4gICAgICAvLyBzb21lIGVsZW1lbnRzIChlLmcuIERvY3VtZW50KSBkb24ndCBoYXZlIGdldCBhdHRyaWJ1dGUsIHNvIHJldHVybiB1bmRlZmluZWRcbiAgICAgIHZhciByZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lLCAyKTtcbiAgICAgIC8vIG5vcm1hbGl6ZSBub24tZXhpc3RpbmcgYXR0cmlidXRlcyB0byB1bmRlZmluZWQgKGFzIGpRdWVyeSlcbiAgICAgIHJldHVybiByZXQgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIHByb3A6IGZ1bmN0aW9uKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIGVsZW1lbnRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnRbbmFtZV07XG4gICAgfVxuICB9LFxuXG4gIHRleHQ6IChmdW5jdGlvbigpIHtcbiAgICB2YXIgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFkgPSBbXTtcbiAgICBpZiAobXNpZSA8IDkpIHtcbiAgICAgIE5PREVfVFlQRV9URVhUX1BST1BFUlRZWzFdID0gJ2lubmVyVGV4dCc7ICAgIC8qKiBFbGVtZW50ICoqL1xuICAgICAgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbM10gPSAnbm9kZVZhbHVlJzsgICAgLyoqIFRleHQgKiovXG4gICAgfSBlbHNlIHtcbiAgICAgIE5PREVfVFlQRV9URVhUX1BST1BFUlRZWzFdID0gICAgICAgICAgICAgICAgIC8qKiBFbGVtZW50ICoqL1xuICAgICAgTk9ERV9UWVBFX1RFWFRfUFJPUEVSVFlbM10gPSAndGV4dENvbnRlbnQnOyAgLyoqIFRleHQgKiovXG4gICAgfVxuICAgIGdldFRleHQuJGR2ID0gJyc7XG4gICAgcmV0dXJuIGdldFRleHQ7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0KGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgdGV4dFByb3AgPSBOT0RFX1RZUEVfVEVYVF9QUk9QRVJUWVtlbGVtZW50Lm5vZGVUeXBlXTtcbiAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRleHRQcm9wID8gZWxlbWVudFt0ZXh0UHJvcF0gOiAnJztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRbdGV4dFByb3BdID0gdmFsdWU7XG4gICAgfVxuICB9KSgpLFxuXG4gIHZhbDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICBpZiAobm9kZU5hbWVfKGVsZW1lbnQpID09PSAnU0VMRUNUJyAmJiBlbGVtZW50Lm11bHRpcGxlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yRWFjaChlbGVtZW50Lm9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gIH0sXG5cbiAgaHRtbDogZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBjaGlsZE5vZGVzID0gZWxlbWVudC5jaGlsZE5vZGVzOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAganFMaXRlRGVhbG9jKGNoaWxkTm9kZXNbaV0pO1xuICAgIH1cbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHZhbHVlO1xuICB9LFxuXG4gIGVtcHR5OiBqcUxpdGVFbXB0eVxufSwgZnVuY3Rpb24oZm4sIG5hbWUpe1xuICAvKipcbiAgICogUHJvcGVydGllczogd3JpdGVzIHJldHVybiBzZWxlY3Rpb24sIHJlYWRzIHJldHVybiBmaXJzdCB2YWx1ZVxuICAgKi9cbiAgSlFMaXRlLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICB2YXIgaSwga2V5O1xuXG4gICAgLy8ganFMaXRlSGFzQ2xhc3MgaGFzIG9ubHkgdHdvIGFyZ3VtZW50cywgYnV0IGlzIGEgZ2V0dGVyLW9ubHkgZm4sIHNvIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGl0XG4gICAgLy8gaW4gYSB3YXkgdGhhdCBzdXJ2aXZlcyBtaW5pZmljYXRpb24uXG4gICAgLy8ganFMaXRlRW1wdHkgdGFrZXMgbm8gYXJndW1lbnRzIGJ1dCBpcyBhIHNldHRlci5cbiAgICBpZiAoZm4gIT09IGpxTGl0ZUVtcHR5ICYmXG4gICAgICAgICgoKGZuLmxlbmd0aCA9PSAyICYmIChmbiAhPT0ganFMaXRlSGFzQ2xhc3MgJiYgZm4gIT09IGpxTGl0ZUNvbnRyb2xsZXIpKSA/IGFyZzEgOiBhcmcyKSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGFyZzEpKSB7XG5cbiAgICAgICAgLy8gd2UgYXJlIGEgd3JpdGUsIGJ1dCB0aGUgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHRoZSBrZXkvdmFsdWVzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGZuID09PSBqcUxpdGVEYXRhKSB7XG4gICAgICAgICAgICAvLyBkYXRhKCkgdGFrZXMgdGhlIHdob2xlIG9iamVjdCBpbiBqUXVlcnlcbiAgICAgICAgICAgIGZuKHRoaXNbaV0sIGFyZzEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhcmcxKSB7XG4gICAgICAgICAgICAgIGZuKHRoaXNbaV0sIGtleSwgYXJnMVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIHNlbGYgZm9yIGNoYWluaW5nXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgYXJlIGEgcmVhZCwgc28gcmVhZCB0aGUgZmlyc3QgY2hpbGQuXG4gICAgICAgIHZhciB2YWx1ZSA9IGZuLiRkdjtcbiAgICAgICAgLy8gT25seSBpZiB3ZSBoYXZlICRkdiBkbyB3ZSBpdGVyYXRlIG92ZXIgYWxsLCBvdGhlcndpc2UgaXQgaXMganVzdCB0aGUgZmlyc3QgZWxlbWVudC5cbiAgICAgICAgdmFyIGpqID0gKHZhbHVlID09PSB1bmRlZmluZWQpID8gTWF0aC5taW4odGhpcy5sZW5ndGgsIDEpIDogdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgamo7IGorKykge1xuICAgICAgICAgIHZhciBub2RlVmFsdWUgPSBmbih0aGlzW2pdLCBhcmcxLCBhcmcyKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgKyBub2RlVmFsdWUgOiBub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBhcmUgYSB3cml0ZSwgc28gYXBwbHkgdG8gYWxsIGNoaWxkcmVuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbih0aGlzW2ldLCBhcmcxLCBhcmcyKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzZWxmIGZvciBjaGFpbmluZ1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SGFuZGxlcihlbGVtZW50LCBldmVudHMpIHtcbiAgdmFyIGV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCwgdHlwZSkge1xuICAgIGlmICghZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7IC8vaWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlOyAvL2llXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50O1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZChldmVudC5kZWZhdWx0UHJldmVudGVkKSkge1xuICAgICAgdmFyIHByZXZlbnQgPSBldmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBwcmV2ZW50LmNhbGwoZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkIHx8IGV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gQ29weSBldmVudCBoYW5kbGVycyBpbiBjYXNlIGV2ZW50IGhhbmRsZXJzIGFycmF5IGlzIG1vZGlmaWVkIGR1cmluZyBleGVjdXRpb24uXG4gICAgdmFyIGV2ZW50SGFuZGxlcnNDb3B5ID0gc2hhbGxvd0NvcHkoZXZlbnRzW3R5cGUgfHwgZXZlbnQudHlwZV0gfHwgW10pO1xuXG4gICAgZm9yRWFjaChldmVudEhhbmRsZXJzQ29weSwgZnVuY3Rpb24oZm4pIHtcbiAgICAgIGZuLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIG1vbmtleS1wYXRjaGVkIG1ldGhvZHMgKElFKSxcbiAgICAvLyBhcyB0aGV5IHdvdWxkIGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBJRTguXG4gICAgaWYgKG1zaWUgPD0gOCkge1xuICAgICAgLy8gSUU3LzggZG9lcyBub3QgYWxsb3cgdG8gZGVsZXRlIHByb3BlcnR5IG9uIG5hdGl2ZSBvYmplY3RcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gbnVsbDtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IG51bGw7XG4gICAgICBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJdCBzaG91bGRuJ3QgYWZmZWN0IG5vcm1hbCBicm93c2VycyAobmF0aXZlIG1ldGhvZHMgYXJlIGRlZmluZWQgb24gcHJvdG90eXBlKS5cbiAgICAgIGRlbGV0ZSBldmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgIGRlbGV0ZSBldmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICBkZWxldGUgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRIYW5kbGVyLmVsZW0gPSBlbGVtZW50O1xuICByZXR1cm4gZXZlbnRIYW5kbGVyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEZ1bmN0aW9ucyBpdGVyYXRpbmcgdHJhdmVyc2FsLlxuLy8gVGhlc2UgZnVuY3Rpb25zIGNoYWluIHJlc3VsdHMgaW50byBhIHNpbmdsZVxuLy8gc2VsZWN0b3IuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZvckVhY2goe1xuICByZW1vdmVEYXRhOiBqcUxpdGVSZW1vdmVEYXRhLFxuXG4gIGRlYWxvYzoganFMaXRlRGVhbG9jLFxuXG4gIG9uOiBmdW5jdGlvbiBvbkZuKGVsZW1lbnQsIHR5cGUsIGZuLCB1bnN1cHBvcnRlZCl7XG4gICAgaWYgKGlzRGVmaW5lZCh1bnN1cHBvcnRlZCkpIHRocm93IGpxTGl0ZU1pbkVycignb25hcmdzJywgJ2pxTGl0ZSNvbigpIGRvZXMgbm90IHN1cHBvcnQgdGhlIGBzZWxlY3RvcmAgb3IgYGV2ZW50RGF0YWAgcGFyYW1ldGVycycpO1xuXG4gICAgdmFyIGV2ZW50cyA9IGpxTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnZXZlbnRzJyksXG4gICAgICAgIGhhbmRsZSA9IGpxTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnaGFuZGxlJyk7XG5cbiAgICBpZiAoIWV2ZW50cykganFMaXRlRXhwYW5kb1N0b3JlKGVsZW1lbnQsICdldmVudHMnLCBldmVudHMgPSB7fSk7XG4gICAgaWYgKCFoYW5kbGUpIGpxTGl0ZUV4cGFuZG9TdG9yZShlbGVtZW50LCAnaGFuZGxlJywgaGFuZGxlID0gY3JlYXRlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cykpO1xuXG4gICAgZm9yRWFjaCh0eXBlLnNwbGl0KCcgJyksIGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgdmFyIGV2ZW50Rm5zID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAoIWV2ZW50Rm5zKSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtb3VzZWVudGVyJyB8fCB0eXBlID09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgIHZhciBjb250YWlucyA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMgfHwgZG9jdW1lbnQuYm9keS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiA/XG4gICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2VcbiAgICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuICAgICAgICAgICAgICBhZG93bi5jb250YWlucyA/XG4gICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG4gICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgZnVuY3Rpb24oIGEsIGIgKSB7XG4gICAgICAgICAgICAgIGlmICggYiApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcbiAgICAgICAgICAgICAgICAgIGlmICggYiA9PT0gYSApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBbXTtcblxuICAgICAgICAgIC8vIFJlZmVyIHRvIGpRdWVyeSdzIGltcGxlbWVudGF0aW9uIG9mIG1vdXNlZW50ZXIgJiBtb3VzZWxlYXZlXG4gICAgICAgICAgLy8gUmVhZCBhYm91dCBtb3VzZWVudGVyIGFuZCBtb3VzZWxlYXZlOlxuICAgICAgICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX21vdXNlLmh0bWwjbGluazhcbiAgICAgICAgICB2YXIgZXZlbnRtYXAgPSB7IG1vdXNlbGVhdmUgOiBcIm1vdXNlb3V0XCIsIG1vdXNlZW50ZXIgOiBcIm1vdXNlb3ZlclwifTtcblxuICAgICAgICAgIG9uRm4oZWxlbWVudCwgZXZlbnRtYXBbdHlwZV0sIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICAvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuICAgICAgICAgICAgaWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFjb250YWlucyh0YXJnZXQsIHJlbGF0ZWQpKSApe1xuICAgICAgICAgICAgICBoYW5kbGUoZXZlbnQsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lckZuKGVsZW1lbnQsIHR5cGUsIGhhbmRsZSk7XG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRGbnMgPSBldmVudHNbdHlwZV07XG4gICAgICB9XG4gICAgICBldmVudEZucy5wdXNoKGZuKTtcbiAgICB9KTtcbiAgfSxcblxuICBvZmY6IGpxTGl0ZU9mZixcblxuICBvbmU6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGZuKSB7XG4gICAgZWxlbWVudCA9IGpxTGl0ZShlbGVtZW50KTtcblxuICAgIC8vYWRkIHRoZSBsaXN0ZW5lciB0d2ljZSBzbyB0aGF0IHdoZW4gaXQgaXMgY2FsbGVkXG4gICAgLy95b3UgY2FuIHJlbW92ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYW5kIHN0aWxsIGJlXG4gICAgLy9hYmxlIHRvIGNhbGwgZWxlbWVudC5vZmYoZXYsIGZuKSBub3JtYWxseVxuICAgIGVsZW1lbnQub24odHlwZSwgZnVuY3Rpb24gb25GbigpIHtcbiAgICAgIGVsZW1lbnQub2ZmKHR5cGUsIGZuKTtcbiAgICAgIGVsZW1lbnQub2ZmKHR5cGUsIG9uRm4pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQub24odHlwZSwgZm4pO1xuICB9LFxuXG4gIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihlbGVtZW50LCByZXBsYWNlTm9kZSkge1xuICAgIHZhciBpbmRleCwgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGpxTGl0ZURlYWxvYyhlbGVtZW50KTtcbiAgICBmb3JFYWNoKG5ldyBKUUxpdGUocmVwbGFjZU5vZGUpLCBmdW5jdGlvbihub2RlKXtcbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGluZGV4Lm5leHRTaWJsaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpbmRleCA9IG5vZGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2hpbGRyZW46IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3JFYWNoKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSlcbiAgICAgICAgY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH0sXG5cbiAgY29udGVudHM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZE5vZGVzIHx8IFtdO1xuICB9LFxuXG4gIGFwcGVuZDogZnVuY3Rpb24oZWxlbWVudCwgbm9kZSkge1xuICAgIGZvckVhY2gobmV3IEpRTGl0ZShub2RlKSwgZnVuY3Rpb24oY2hpbGQpe1xuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEgfHwgZWxlbWVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgcHJlcGVuZDogZnVuY3Rpb24oZWxlbWVudCwgbm9kZSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICB2YXIgaW5kZXggPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBmb3JFYWNoKG5ldyBKUUxpdGUobm9kZSksIGZ1bmN0aW9uKGNoaWxkKXtcbiAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGluZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB3cmFwOiBmdW5jdGlvbihlbGVtZW50LCB3cmFwTm9kZSkge1xuICAgIHdyYXBOb2RlID0ganFMaXRlKHdyYXBOb2RlKVswXTtcbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQod3JhcE5vZGUsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB3cmFwTm9kZS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBqcUxpdGVEZWFsb2MoZWxlbWVudCk7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH0sXG5cbiAgYWZ0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIG5ld0VsZW1lbnQpIHtcbiAgICB2YXIgaW5kZXggPSBlbGVtZW50LCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgZm9yRWFjaChuZXcgSlFMaXRlKG5ld0VsZW1lbnQpLCBmdW5jdGlvbihub2RlKXtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgaW5kZXgubmV4dFNpYmxpbmcpO1xuICAgICAgaW5kZXggPSBub2RlO1xuICAgIH0pO1xuICB9LFxuXG4gIGFkZENsYXNzOiBqcUxpdGVBZGRDbGFzcyxcbiAgcmVtb3ZlQ2xhc3M6IGpxTGl0ZVJlbW92ZUNsYXNzLFxuXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3RvciwgY29uZGl0aW9uKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGNvbmRpdGlvbikpIHtcbiAgICAgIGNvbmRpdGlvbiA9ICFqcUxpdGVIYXNDbGFzcyhlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIChjb25kaXRpb24gPyBqcUxpdGVBZGRDbGFzcyA6IGpxTGl0ZVJlbW92ZUNsYXNzKShlbGVtZW50LCBzZWxlY3Rvcik7XG4gIH0sXG5cbiAgcGFyZW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG5cbiAgICAvLyBJRTggZG9lc24ndCBoYXZlIG5leHRFbGVtZW50U2libGluZ1xuICAgIHZhciBlbG0gPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgIHdoaWxlIChlbG0gIT0gbnVsbCAmJiBlbG0ubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIGVsbSA9IGVsbS5uZXh0U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGVsbTtcbiAgfSxcblxuICBmaW5kOiBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGlmIChlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG5cbiAgY2xvbmU6IGpxTGl0ZUNsb25lLFxuXG4gIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50RGF0YSkge1xuICAgIHZhciBldmVudEZucyA9IChqcUxpdGVFeHBhbmRvU3RvcmUoZWxlbWVudCwgJ2V2ZW50cycpIHx8IHt9KVtldmVudE5hbWVdO1xuXG4gICAgZXZlbnREYXRhID0gZXZlbnREYXRhIHx8IFtdO1xuXG4gICAgdmFyIGV2ZW50ID0gW3tcbiAgICAgIHByZXZlbnREZWZhdWx0OiBub29wLFxuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBub29wXG4gICAgfV07XG5cbiAgICBmb3JFYWNoKGV2ZW50Rm5zLCBmdW5jdGlvbihmbikge1xuICAgICAgZm4uYXBwbHkoZWxlbWVudCwgZXZlbnQuY29uY2F0KGV2ZW50RGF0YSkpO1xuICAgIH0pO1xuICB9XG59LCBmdW5jdGlvbihmbiwgbmFtZSl7XG4gIC8qKlxuICAgKiBjaGFpbmluZyBmdW5jdGlvbnNcbiAgICovXG4gIEpRTGl0ZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IGZuKHRoaXNbaV0sIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgIC8vIGFueSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdmFsdWUgbmVlZHMgdG8gYmUgd3JhcHBlZFxuICAgICAgICAgIHZhbHVlID0ganFMaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAganFMaXRlQWRkTm9kZXModmFsdWUsIGZuKHRoaXNbaV0sIGFyZzEsIGFyZzIsIGFyZzMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXM7XG4gIH07XG5cbiAgLy8gYmluZCBsZWdhY3kgYmluZC91bmJpbmQgdG8gb24vb2ZmXG4gIEpRTGl0ZS5wcm90b3R5cGUuYmluZCA9IEpRTGl0ZS5wcm90b3R5cGUub247XG4gIEpRTGl0ZS5wcm90b3R5cGUudW5iaW5kID0gSlFMaXRlLnByb3RvdHlwZS5vZmY7XG59KTtcblxuLyoqXG4gKiBDb21wdXRlcyBhIGhhc2ggb2YgYW4gJ29iaicuXG4gKiBIYXNoIG9mIGE6XG4gKiAgc3RyaW5nIGlzIHN0cmluZ1xuICogIG51bWJlciBpcyBudW1iZXIgYXMgc3RyaW5nXG4gKiAgb2JqZWN0IGlzIGVpdGhlciByZXN1bHQgb2YgY2FsbGluZyAkJGhhc2hLZXkgZnVuY3Rpb24gb24gdGhlIG9iamVjdCBvciB1bmlxdWVseSBnZW5lcmF0ZWQgaWQsXG4gKiAgICAgICAgIHRoYXQgaXMgYWxzbyBhc3NpZ25lZCB0byB0aGUgJCRoYXNoS2V5IHByb3BlcnR5IG9mIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybnMge3N0cmluZ30gaGFzaCBzdHJpbmcgc3VjaCB0aGF0IHRoZSBzYW1lIGlucHV0IHdpbGwgaGF2ZSB0aGUgc2FtZSBoYXNoIHN0cmluZy5cbiAqICAgICAgICAgVGhlIHJlc3VsdGluZyBzdHJpbmcga2V5IGlzIGluICd0eXBlOmhhc2hLZXknIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gaGFzaEtleShvYmopIHtcbiAgdmFyIG9ialR5cGUgPSB0eXBlb2Ygb2JqLFxuICAgICAga2V5O1xuXG4gIGlmIChvYmpUeXBlID09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgKGtleSA9IG9iai4kJGhhc2hLZXkpID09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIG11c3QgaW52b2tlIG9uIG9iamVjdCB0byBrZWVwIHRoZSByaWdodCB0aGlzXG4gICAgICBrZXkgPSBvYmouJCRoYXNoS2V5KCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gb2JqLiQkaGFzaEtleSA9IG5leHRVaWQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gb2JqO1xuICB9XG5cbiAgcmV0dXJuIG9ialR5cGUgKyAnOicgKyBrZXk7XG59XG5cbi8qKlxuICogSGFzaE1hcCB3aGljaCBjYW4gdXNlIG9iamVjdHMgYXMga2V5c1xuICovXG5mdW5jdGlvbiBIYXNoTWFwKGFycmF5KXtcbiAgZm9yRWFjaChhcnJheSwgdGhpcy5wdXQsIHRoaXMpO1xufVxuSGFzaE1hcC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBTdG9yZSBrZXkgdmFsdWUgcGFpclxuICAgKiBAcGFyYW0ga2V5IGtleSB0byBzdG9yZSBjYW4gYmUgYW55IHR5cGVcbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIHN0b3JlIGNhbiBiZSBhbnkgdHlwZVxuICAgKi9cbiAgcHV0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1toYXNoS2V5KGtleSldID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHJldHVybnMgdGhlIHZhbHVlIGZvciB0aGUga2V5XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzW2hhc2hLZXkoa2V5KV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUga2V5L3ZhbHVlIHBhaXJcbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzW2tleSA9IGhhc2hLZXkoa2V5KV07XG4gICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBhbmd1bGFyLmluamVjdG9yXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgcmV0cmlldmluZyBzZXJ2aWNlcyBhcyB3ZWxsIGFzIGZvclxuICogZGVwZW5kZW5jeSBpbmplY3Rpb24gKHNlZSB7QGxpbmsgZ3VpZGUvZGkgZGVwZW5kZW5jeSBpbmplY3Rpb259KS5cbiAqXG5cbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3xGdW5jdGlvbj59IG1vZHVsZXMgQSBsaXN0IG9mIG1vZHVsZSBmdW5jdGlvbnMgb3IgdGhlaXIgYWxpYXNlcy4gU2VlXG4gKiAgICAgICAge0BsaW5rIGFuZ3VsYXIubW9kdWxlfS4gVGhlIGBuZ2AgbW9kdWxlIG11c3QgYmUgZXhwbGljaXRseSBhZGRlZC5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSBJbmplY3RvciBmdW5jdGlvbi4gU2VlIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBUeXBpY2FsIHVzYWdlXG4gKiA8cHJlPlxuICogICAvLyBjcmVhdGUgYW4gaW5qZWN0b3JcbiAqICAgdmFyICRpbmplY3RvciA9IGFuZ3VsYXIuaW5qZWN0b3IoWyduZyddKTtcbiAqXG4gKiAgIC8vIHVzZSB0aGUgaW5qZWN0b3IgdG8ga2ljayBvZmYgeW91ciBhcHBsaWNhdGlvblxuICogICAvLyB1c2UgdGhlIHR5cGUgaW5mZXJlbmNlIHRvIGF1dG8gaW5qZWN0IGFyZ3VtZW50cywgb3IgdXNlIGltcGxpY2l0IGluamVjdGlvblxuICogICAkaW5qZWN0b3IuaW52b2tlKGZ1bmN0aW9uKCRyb290U2NvcGUsICRjb21waWxlLCAkZG9jdW1lbnQpe1xuICogICAgICRjb21waWxlKCRkb2N1bWVudCkoJHJvb3RTY29wZSk7XG4gKiAgICAgJHJvb3RTY29wZS4kZGlnZXN0KCk7XG4gKiAgIH0pO1xuICogPC9wcmU+XG4gKlxuICogU29tZXRpbWVzIHlvdSB3YW50IHRvIGdldCBhY2Nlc3MgdG8gdGhlIGluamVjdG9yIG9mIGEgY3VycmVudGx5IHJ1bm5pbmcgQW5ndWxhciBhcHBcbiAqIGZyb20gb3V0c2lkZSBBbmd1bGFyLiBQZXJoYXBzLCB5b3Ugd2FudCB0byBpbmplY3QgYW5kIGNvbXBpbGUgc29tZSBtYXJrdXAgYWZ0ZXIgdGhlXG4gKiBhcHBsaWNhdGlvbiBoYXMgYmVlbiBib290c3RyYXBwZWQuIFlvdSBjYW4gZG8gdGhpcyB1c2luZyBleHRyYSBgaW5qZWN0b3IoKWAgYWRkZWRcbiAqIHRvIEpRdWVyeS9qcUxpdGUgZWxlbWVudHMuIFNlZSB7QGxpbmsgYW5ndWxhci5lbGVtZW50fS5cbiAqXG4gKiAqVGhpcyBpcyBmYWlybHkgcmFyZSBidXQgY291bGQgYmUgdGhlIGNhc2UgaWYgYSB0aGlyZCBwYXJ0eSBsaWJyYXJ5IGlzIGluamVjdGluZyB0aGVcbiAqIG1hcmt1cC4qXG4gKlxuICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlIGEgbmV3IGJsb2NrIG9mIEhUTUwgY29udGFpbmluZyBhIGBuZy1jb250cm9sbGVyYFxuICogZGlyZWN0aXZlIGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IGJvZHkgYnkgSlF1ZXJ5LiBXZSB0aGVuIGNvbXBpbGUgYW5kIGxpbmtcbiAqIGl0IGludG8gdGhlIGN1cnJlbnQgQW5ndWxhckpTIHNjb3BlLlxuICpcbiAqIDxwcmU+XG4gKiB2YXIgJGRpdiA9ICQoJzxkaXYgbmctY29udHJvbGxlcj1cIk15Q3RybFwiPnt7Y29udGVudC5sYWJlbH19PC9kaXY+Jyk7XG4gKiAkKGRvY3VtZW50LmJvZHkpLmFwcGVuZCgkZGl2KTtcbiAqXG4gKiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmluamVjdG9yKCkuaW52b2tlKGZ1bmN0aW9uKCRjb21waWxlKSB7XG4gKiAgIHZhciBzY29wZSA9IGFuZ3VsYXIuZWxlbWVudCgkZGl2KS5zY29wZSgpO1xuICogICAkY29tcGlsZSgkZGl2KShzY29wZSk7XG4gKiB9KTtcbiAqIDwvcHJlPlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2Mgb3ZlcnZpZXdcbiAqIEBuYW1lIEFVVE9cbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEltcGxpY2l0IG1vZHVsZSB3aGljaCBnZXRzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gZWFjaCB7QGxpbmsgQVVUTy4kaW5qZWN0b3IgJGluamVjdG9yfS5cbiAqL1xuXG52YXIgRk5fQVJHUyA9IC9eZnVuY3Rpb25cXHMqW15cXChdKlxcKFxccyooW15cXCldKilcXCkvbTtcbnZhciBGTl9BUkdfU1BMSVQgPSAvLC87XG52YXIgRk5fQVJHID0gL15cXHMqKF8/KShcXFMrPylcXDFcXHMqJC87XG52YXIgU1RSSVBfQ09NTUVOVFMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvbWc7XG52YXIgJGluamVjdG9yTWluRXJyID0gbWluRXJyKCckaW5qZWN0b3InKTtcbmZ1bmN0aW9uIGFubm90YXRlKGZuKSB7XG4gIHZhciAkaW5qZWN0LFxuICAgICAgZm5UZXh0LFxuICAgICAgYXJnRGVjbCxcbiAgICAgIGxhc3Q7XG5cbiAgaWYgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCEoJGluamVjdCA9IGZuLiRpbmplY3QpKSB7XG4gICAgICAkaW5qZWN0ID0gW107XG4gICAgICBpZiAoZm4ubGVuZ3RoKSB7XG4gICAgICAgIGZuVGV4dCA9IGZuLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuICAgICAgICBhcmdEZWNsID0gZm5UZXh0Lm1hdGNoKEZOX0FSR1MpO1xuICAgICAgICBmb3JFYWNoKGFyZ0RlY2xbMV0uc3BsaXQoRk5fQVJHX1NQTElUKSwgZnVuY3Rpb24oYXJnKXtcbiAgICAgICAgICBhcmcucmVwbGFjZShGTl9BUkcsIGZ1bmN0aW9uKGFsbCwgdW5kZXJzY29yZSwgbmFtZSl7XG4gICAgICAgICAgICAkaW5qZWN0LnB1c2gobmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm4uJGluamVjdCA9ICRpbmplY3Q7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZm4pKSB7XG4gICAgbGFzdCA9IGZuLmxlbmd0aCAtIDE7XG4gICAgYXNzZXJ0QXJnRm4oZm5bbGFzdF0sICdmbicpO1xuICAgICRpbmplY3QgPSBmbi5zbGljZSgwLCBsYXN0KTtcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnRBcmdGbihmbiwgJ2ZuJywgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuICRpbmplY3Q7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIEFVVE8uJGluamVjdG9yXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBgJGluamVjdG9yYCBpcyB1c2VkIHRvIHJldHJpZXZlIG9iamVjdCBpbnN0YW5jZXMgYXMgZGVmaW5lZCBieVxuICoge0BsaW5rIEFVVE8uJHByb3ZpZGUgcHJvdmlkZXJ9LCBpbnN0YW50aWF0ZSB0eXBlcywgaW52b2tlIG1ldGhvZHMsXG4gKiBhbmQgbG9hZCBtb2R1bGVzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgYWx3YXlzIGhvbGRzIHRydWU6XG4gKlxuICogPHByZT5cbiAqICAgdmFyICRpbmplY3RvciA9IGFuZ3VsYXIuaW5qZWN0b3IoKTtcbiAqICAgZXhwZWN0KCRpbmplY3Rvci5nZXQoJyRpbmplY3RvcicpKS50b0JlKCRpbmplY3Rvcik7XG4gKiAgIGV4cGVjdCgkaW5qZWN0b3IuaW52b2tlKGZ1bmN0aW9uKCRpbmplY3Rvcil7XG4gKiAgICAgcmV0dXJuICRpbmplY3RvcjtcbiAqICAgfSkudG9CZSgkaW5qZWN0b3IpO1xuICogPC9wcmU+XG4gKlxuICogIyBJbmplY3Rpb24gRnVuY3Rpb24gQW5ub3RhdGlvblxuICpcbiAqIEphdmFTY3JpcHQgZG9lcyBub3QgaGF2ZSBhbm5vdGF0aW9ucywgYW5kIGFubm90YXRpb25zIGFyZSBuZWVkZWQgZm9yIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBUaGVcbiAqIGZvbGxvd2luZyBhcmUgYWxsIHZhbGlkIHdheXMgb2YgYW5ub3RhdGluZyBmdW5jdGlvbiB3aXRoIGluamVjdGlvbiBhcmd1bWVudHMgYW5kIGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIDxwcmU+XG4gKiAgIC8vIGluZmVycmVkIChvbmx5IHdvcmtzIGlmIGNvZGUgbm90IG1pbmlmaWVkL29iZnVzY2F0ZWQpXG4gKiAgICRpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oc2VydmljZUEpe30pO1xuICpcbiAqICAgLy8gYW5ub3RhdGVkXG4gKiAgIGZ1bmN0aW9uIGV4cGxpY2l0KHNlcnZpY2VBKSB7fTtcbiAqICAgZXhwbGljaXQuJGluamVjdCA9IFsnc2VydmljZUEnXTtcbiAqICAgJGluamVjdG9yLmludm9rZShleHBsaWNpdCk7XG4gKlxuICogICAvLyBpbmxpbmVcbiAqICAgJGluamVjdG9yLmludm9rZShbJ3NlcnZpY2VBJywgZnVuY3Rpb24oc2VydmljZUEpe31dKTtcbiAqIDwvcHJlPlxuICpcbiAqICMjIEluZmVyZW5jZVxuICpcbiAqIEluIEphdmFTY3JpcHQgY2FsbGluZyBgdG9TdHJpbmcoKWAgb24gYSBmdW5jdGlvbiByZXR1cm5zIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uLiBUaGUgZGVmaW5pdGlvblxuICogY2FuIHRoZW4gYmUgcGFyc2VkIGFuZCB0aGUgZnVuY3Rpb24gYXJndW1lbnRzIGNhbiBiZSBleHRyYWN0ZWQuICpOT1RFOiogVGhpcyBkb2VzIG5vdCB3b3JrIHdpdGhcbiAqIG1pbmlmaWNhdGlvbiwgYW5kIG9iZnVzY2F0aW9uIHRvb2xzIHNpbmNlIHRoZXNlIHRvb2xzIGNoYW5nZSB0aGUgYXJndW1lbnQgbmFtZXMuXG4gKlxuICogIyMgYCRpbmplY3RgIEFubm90YXRpb25cbiAqIEJ5IGFkZGluZyBhIGAkaW5qZWN0YCBwcm9wZXJ0eSBvbnRvIGEgZnVuY3Rpb24gdGhlIGluamVjdGlvbiBwYXJhbWV0ZXJzIGNhbiBiZSBzcGVjaWZpZWQuXG4gKlxuICogIyMgSW5saW5lXG4gKiBBcyBhbiBhcnJheSBvZiBpbmplY3Rpb24gbmFtZXMsIHdoZXJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGFycmF5IGlzIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICovXG5cbi8qKlxuICogQG5nZG9jIG1ldGhvZFxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjZ2V0XG4gKiBAbWV0aG9kT2YgQVVUTy4kaW5qZWN0b3JcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiBhbiBpbnN0YW5jZSBvZiB0aGUgc2VydmljZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJuIHsqfSBUaGUgaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgbWV0aG9kXG4gKiBAbmFtZSBBVVRPLiRpbmplY3RvciNpbnZva2VcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSW52b2tlIHRoZSBtZXRob2QgYW5kIHN1cHBseSB0aGUgbWV0aG9kIGFyZ3VtZW50cyBmcm9tIHRoZSBgJGluamVjdG9yYC5cbiAqXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gRnVuY3Rpb24gcGFyYW1ldGVycyBhcmUgaW5qZWN0ZWQgYWNjb3JkaW5nIHRvIHRoZVxuICogICB7QGxpbmsgZ3VpZGUvZGkgJGluamVjdCBBbm5vdGF0aW9ufSBydWxlcy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2VsZiBUaGUgYHRoaXNgIGZvciB0aGUgaW52b2tlZCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdD19IGxvY2FscyBPcHRpb25hbCBvYmplY3QuIElmIHByZXNldCB0aGVuIGFueSBhcmd1bWVudCBuYW1lcyBhcmUgcmVhZCBmcm9tIHRoaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCBmaXJzdCwgYmVmb3JlIHRoZSBgJGluamVjdG9yYCBpcyBjb25zdWx0ZWQuXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBpbnZva2VkIGBmbmAgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgbWV0aG9kXG4gKiBAbmFtZSBBVVRPLiRpbmplY3RvciNoYXNcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWxsb3dzIHRoZSB1c2VyIHRvIHF1ZXJ5IGlmIHRoZSBwYXJ0aWN1bGFyIHNlcnZpY2UgZXhpc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IE5hbWUgb2YgdGhlIHNlcnZpY2UgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIGluamVjdG9yIGhhcyBnaXZlbiBzZXJ2aWNlLlxuICovXG5cbi8qKlxuICogQG5nZG9jIG1ldGhvZFxuICogQG5hbWUgQVVUTy4kaW5qZWN0b3IjaW5zdGFudGlhdGVcbiAqIEBtZXRob2RPZiBBVVRPLiRpbmplY3RvclxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgSlMgdHlwZS4gVGhlIG1ldGhvZCB0YWtlcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGludm9rZXMgdGhlIG5ld1xuICogb3BlcmF0b3IgYW5kIHN1cHBsaWVzIGFsbCBvZiB0aGUgYXJndW1lbnRzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhcyBzcGVjaWZpZWQgYnkgdGhlXG4gKiBjb25zdHJ1Y3RvciBhbm5vdGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFR5cGUgQW5ub3RhdGVkIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3Q9fSBsb2NhbHMgT3B0aW9uYWwgb2JqZWN0LiBJZiBwcmVzZXQgdGhlbiBhbnkgYXJndW1lbnQgbmFtZXMgYXJlIHJlYWQgZnJvbSB0aGlzXG4gKiBvYmplY3QgZmlyc3QsIGJlZm9yZSB0aGUgYCRpbmplY3RvcmAgaXMgY29uc3VsdGVkLlxuICogQHJldHVybnMge09iamVjdH0gbmV3IGluc3RhbmNlIG9mIGBUeXBlYC5cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBtZXRob2RcbiAqIEBuYW1lIEFVVE8uJGluamVjdG9yI2Fubm90YXRlXG4gKiBAbWV0aG9kT2YgQVVUTy4kaW5qZWN0b3JcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc2VydmljZSBuYW1lcyB3aGljaCB0aGUgZnVuY3Rpb24gaXMgcmVxdWVzdGluZyBmb3IgaW5qZWN0aW9uLiBUaGlzIEFQSSBpc1xuICogdXNlZCBieSB0aGUgaW5qZWN0b3IgdG8gZGV0ZXJtaW5lIHdoaWNoIHNlcnZpY2VzIG5lZWQgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgZnVuY3Rpb24gd2hlbiB0aGVcbiAqIGZ1bmN0aW9uIGlzIGludm9rZWQuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIGluIHdoaWNoIHRoZSBmdW5jdGlvbiBjYW4gYmUgYW5ub3RhdGVkIHdpdGggdGhlIG5lZWRlZFxuICogZGVwZW5kZW5jaWVzLlxuICpcbiAqICMgQXJndW1lbnQgbmFtZXNcbiAqXG4gKiBUaGUgc2ltcGxlc3QgZm9ybSBpcyB0byBleHRyYWN0IHRoZSBkZXBlbmRlbmNpZXMgZnJvbSB0aGUgYXJndW1lbnRzIG9mIHRoZSBmdW5jdGlvbi4gVGhpcyBpcyBkb25lXG4gKiBieSBjb252ZXJ0aW5nIHRoZSBmdW5jdGlvbiBpbnRvIGEgc3RyaW5nIHVzaW5nIGB0b1N0cmluZygpYCBtZXRob2QgYW5kIGV4dHJhY3RpbmcgdGhlIGFyZ3VtZW50XG4gKiBuYW1lcy5cbiAqIDxwcmU+XG4gKiAgIC8vIEdpdmVuXG4gKiAgIGZ1bmN0aW9uIE15Q29udHJvbGxlcigkc2NvcGUsICRyb3V0ZSkge1xuICogICAgIC8vIC4uLlxuICogICB9XG4gKlxuICogICAvLyBUaGVuXG4gKiAgIGV4cGVjdChpbmplY3Rvci5hbm5vdGF0ZShNeUNvbnRyb2xsZXIpKS50b0VxdWFsKFsnJHNjb3BlJywgJyRyb3V0ZSddKTtcbiAqIDwvcHJlPlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdvcmsgd2l0aCBjb2RlIG1pbmlmaWNhdGlvbiAvIG9iZnVzY2F0aW9uLiBGb3IgdGhpcyByZWFzb24gdGhlIGZvbGxvd2luZ1xuICogYW5ub3RhdGlvbiBzdHJhdGVnaWVzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogIyBUaGUgYCRpbmplY3RgIHByb3BlcnR5XG4gKlxuICogSWYgYSBmdW5jdGlvbiBoYXMgYW4gYCRpbmplY3RgIHByb3BlcnR5IGFuZCBpdHMgdmFsdWUgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgdGhlbiB0aGUgc3RyaW5nc1xuICogcmVwcmVzZW50IG5hbWVzIG9mIHNlcnZpY2VzIHRvIGJlIGluamVjdGVkIGludG8gdGhlIGZ1bmN0aW9uLlxuICogPHByZT5cbiAqICAgLy8gR2l2ZW5cbiAqICAgdmFyIE15Q29udHJvbGxlciA9IGZ1bmN0aW9uKG9iZnVzY2F0ZWRTY29wZSwgb2JmdXNjYXRlZFJvdXRlKSB7XG4gKiAgICAgLy8gLi4uXG4gKiAgIH1cbiAqICAgLy8gRGVmaW5lIGZ1bmN0aW9uIGRlcGVuZGVuY2llc1xuICogICBNeUNvbnRyb2xsZXJbJyRpbmplY3QnXSA9IFsnJHNjb3BlJywgJyRyb3V0ZSddO1xuICpcbiAqICAgLy8gVGhlblxuICogICBleHBlY3QoaW5qZWN0b3IuYW5ub3RhdGUoTXlDb250cm9sbGVyKSkudG9FcXVhbChbJyRzY29wZScsICckcm91dGUnXSk7XG4gKiA8L3ByZT5cbiAqXG4gKiAjIFRoZSBhcnJheSBub3RhdGlvblxuICpcbiAqIEl0IGlzIG9mdGVuIGRlc2lyYWJsZSB0byBpbmxpbmUgSW5qZWN0ZWQgZnVuY3Rpb25zIGFuZCB0aGF0J3Mgd2hlbiBzZXR0aW5nIHRoZSBgJGluamVjdGAgcHJvcGVydHlcbiAqIGlzIHZlcnkgaW5jb252ZW5pZW50LiBJbiB0aGVzZSBzaXR1YXRpb25zIHVzaW5nIHRoZSBhcnJheSBub3RhdGlvbiB0byBzcGVjaWZ5IHRoZSBkZXBlbmRlbmNpZXMgaW5cbiAqIGEgd2F5IHRoYXQgc3Vydml2ZXMgbWluaWZpY2F0aW9uIGlzIGEgYmV0dGVyIGNob2ljZTpcbiAqXG4gKiA8cHJlPlxuICogICAvLyBXZSB3aXNoIHRvIHdyaXRlIHRoaXMgKG5vdCBtaW5pZmljYXRpb24gLyBvYmZ1c2NhdGlvbiBzYWZlKVxuICogICBpbmplY3Rvci5pbnZva2UoZnVuY3Rpb24oJGNvbXBpbGUsICRyb290U2NvcGUpIHtcbiAqICAgICAvLyAuLi5cbiAqICAgfSk7XG4gKlxuICogICAvLyBXZSBhcmUgZm9yY2VkIHRvIHdyaXRlIGJyZWFrIGlubGluaW5nXG4gKiAgIHZhciB0bXBGbiA9IGZ1bmN0aW9uKG9iZnVzY2F0ZWRDb21waWxlLCBvYmZ1c2NhdGVkUm9vdFNjb3BlKSB7XG4gKiAgICAgLy8gLi4uXG4gKiAgIH07XG4gKiAgIHRtcEZuLiRpbmplY3QgPSBbJyRjb21waWxlJywgJyRyb290U2NvcGUnXTtcbiAqICAgaW5qZWN0b3IuaW52b2tlKHRtcEZuKTtcbiAqXG4gKiAgIC8vIFRvIGJldHRlciBzdXBwb3J0IGlubGluZSBmdW5jdGlvbiB0aGUgaW5saW5lIGFubm90YXRpb24gaXMgc3VwcG9ydGVkXG4gKiAgIGluamVjdG9yLmludm9rZShbJyRjb21waWxlJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbihvYmZDb21waWxlLCBvYmZSb290U2NvcGUpIHtcbiAqICAgICAvLyAuLi5cbiAqICAgfV0pO1xuICpcbiAqICAgLy8gVGhlcmVmb3JlXG4gKiAgIGV4cGVjdChpbmplY3Rvci5hbm5vdGF0ZShcbiAqICAgICAgWyckY29tcGlsZScsICckcm9vdFNjb3BlJywgZnVuY3Rpb24ob2JmdXNfJGNvbXBpbGUsIG9iZnVzXyRyb290U2NvcGUpIHt9XSlcbiAqICAgICkudG9FcXVhbChbJyRjb21waWxlJywgJyRyb290U2NvcGUnXSk7XG4gKiA8L3ByZT5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufEFycmF5LjxzdHJpbmd8RnVuY3Rpb24+fSBmbiBGdW5jdGlvbiBmb3Igd2hpY2ggZGVwZW5kZW50IHNlcnZpY2UgbmFtZXMgbmVlZCB0b1xuICogYmUgcmV0cmlldmVkIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IFRoZSBuYW1lcyBvZiB0aGUgc2VydmljZXMgd2hpY2ggdGhlIGZ1bmN0aW9uIHJlcXVpcmVzLlxuICovXG5cblxuXG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgQVVUTy4kcHJvdmlkZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFRoZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSAkcHJvdmlkZX0gc2VydmljZSBoYXMgYSBudW1iZXIgb2YgbWV0aG9kcyBmb3IgcmVnaXN0ZXJpbmcgY29tcG9uZW50c1xuICogd2l0aCB0aGUge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0uIE1hbnkgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZSBhbHNvIGV4cG9zZWQgb25cbiAqIHtAbGluayBhbmd1bGFyLk1vZHVsZX0uXG4gKlxuICogQW4gQW5ndWxhciAqKnNlcnZpY2UqKiBpcyBhIHNpbmdsZXRvbiBvYmplY3QgY3JlYXRlZCBieSBhICoqc2VydmljZSBmYWN0b3J5KiouICBUaGVzZSAqKnNlcnZpY2VcbiAqIGZhY3RvcmllcyoqIGFyZSBmdW5jdGlvbnMgd2hpY2gsIGluIHR1cm4sIGFyZSBjcmVhdGVkIGJ5IGEgKipzZXJ2aWNlIHByb3ZpZGVyKiouXG4gKiBUaGUgKipzZXJ2aWNlIHByb3ZpZGVycyoqIGFyZSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMuIFdoZW4gaW5zdGFudGlhdGVkIHRoZXkgbXVzdCBjb250YWluIGFcbiAqIHByb3BlcnR5IGNhbGxlZCBgJGdldGAsIHdoaWNoIGhvbGRzIHRoZSAqKnNlcnZpY2UgZmFjdG9yeSoqIGZ1bmN0aW9uLlxuICpcbiAqIFdoZW4geW91IHJlcXVlc3QgYSBzZXJ2aWNlLCB0aGUge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0gaXMgcmVzcG9uc2libGUgZm9yIGZpbmRpbmcgdGhlXG4gKiBjb3JyZWN0ICoqc2VydmljZSBwcm92aWRlcioqLCBpbnN0YW50aWF0aW5nIGl0IGFuZCB0aGVuIGNhbGxpbmcgaXRzIGAkZ2V0YCAqKnNlcnZpY2UgZmFjdG9yeSoqXG4gKiBmdW5jdGlvbiB0byBnZXQgdGhlIGluc3RhbmNlIG9mIHRoZSAqKnNlcnZpY2UqKi5cbiAqXG4gKiBPZnRlbiBzZXJ2aWNlcyBoYXZlIG5vIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgdGhlcmUgaXMgbm8gbmVlZCB0byBhZGQgbWV0aG9kcyB0byB0aGUgc2VydmljZVxuICogcHJvdmlkZXIuICBUaGUgcHJvdmlkZXIgd2lsbCBiZSBubyBtb3JlIHRoYW4gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRoIGEgYCRnZXRgIHByb3BlcnR5LiBGb3JcbiAqIHRoZXNlIGNhc2VzIHRoZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSAkcHJvdmlkZX0gc2VydmljZSBoYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyB0byByZWdpc3RlclxuICogc2VydmljZXMgd2l0aG91dCBzcGVjaWZ5aW5nIGEgcHJvdmlkZXIuXG4gKlxuICogKiB7QGxpbmsgQVVUTy4kcHJvdmlkZSNtZXRob2RzX3Byb3ZpZGVyIHByb3ZpZGVyKHByb3ZpZGVyKX0gLSByZWdpc3RlcnMgYSAqKnNlcnZpY2UgcHJvdmlkZXIqKiB3aXRoIHRoZVxuICogICAgIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9XG4gKiAqIHtAbGluayBBVVRPLiRwcm92aWRlI21ldGhvZHNfY29uc3RhbnQgY29uc3RhbnQob2JqKX0gLSByZWdpc3RlcnMgYSB2YWx1ZS9vYmplY3QgdGhhdCBjYW4gYmUgYWNjZXNzZWQgYnlcbiAqICAgICBwcm92aWRlcnMgYW5kIHNlcnZpY2VzLlxuICogKiB7QGxpbmsgQVVUTy4kcHJvdmlkZSNtZXRob2RzX3ZhbHVlIHZhbHVlKG9iail9IC0gcmVnaXN0ZXJzIGEgdmFsdWUvb2JqZWN0IHRoYXQgY2FuIG9ubHkgYmUgYWNjZXNzZWQgYnlcbiAqICAgICBzZXJ2aWNlcywgbm90IHByb3ZpZGVycy5cbiAqICoge0BsaW5rIEFVVE8uJHByb3ZpZGUjbWV0aG9kc19mYWN0b3J5IGZhY3RvcnkoZm4pfSAtIHJlZ2lzdGVycyBhIHNlcnZpY2UgKipmYWN0b3J5IGZ1bmN0aW9uKiosIGBmbmAsXG4gKiAgICAgdGhhdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSAqKnNlcnZpY2UgcHJvdmlkZXIqKiBvYmplY3QsIHdob3NlIGAkZ2V0YCBwcm9wZXJ0eSB3aWxsIGNvbnRhaW4gdGhlXG4gKiAgICAgZ2l2ZW4gZmFjdG9yeSBmdW5jdGlvbi5cbiAqICoge0BsaW5rIEFVVE8uJHByb3ZpZGUjbWV0aG9kc19zZXJ2aWNlIHNlcnZpY2UoY2xhc3MpfSAtIHJlZ2lzdGVycyBhICoqY29uc3RydWN0b3IgZnVuY3Rpb24qKiwgYGNsYXNzYCB0aGF0XG4gKiAgICAgdGhhdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSAqKnNlcnZpY2UgcHJvdmlkZXIqKiBvYmplY3QsIHdob3NlIGAkZ2V0YCBwcm9wZXJ0eSB3aWxsIGluc3RhbnRpYXRlXG4gKiAgICAgIGEgbmV3IG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKlxuICogU2VlIHRoZSBpbmRpdmlkdWFsIG1ldGhvZHMgZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGV4YW1wbGVzLlxuICovXG5cbi8qKlxuICogQG5nZG9jIG1ldGhvZFxuICogQG5hbWUgQVVUTy4kcHJvdmlkZSNwcm92aWRlclxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlZ2lzdGVyIGEgKipwcm92aWRlciBmdW5jdGlvbioqIHdpdGggdGhlIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LiBQcm92aWRlciBmdW5jdGlvbnNcbiAqIGFyZSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMsIHdob3NlIGluc3RhbmNlcyBhcmUgcmVzcG9uc2libGUgZm9yIFwicHJvdmlkaW5nXCIgYSBmYWN0b3J5IGZvciBhXG4gKiBzZXJ2aWNlLlxuICpcbiAqIFNlcnZpY2UgcHJvdmlkZXIgbmFtZXMgc3RhcnQgd2l0aCB0aGUgbmFtZSBvZiB0aGUgc2VydmljZSB0aGV5IHByb3ZpZGUgZm9sbG93ZWQgYnkgYFByb3ZpZGVyYC5cbiAqIEZvciBleGFtcGxlLCB0aGUge0BsaW5rIG5nLiRsb2cgJGxvZ30gc2VydmljZSBoYXMgYSBwcm92aWRlciBjYWxsZWRcbiAqIHtAbGluayBuZy4kbG9nUHJvdmlkZXIgJGxvZ1Byb3ZpZGVyfS5cbiAqXG4gKiBTZXJ2aWNlIHByb3ZpZGVyIG9iamVjdHMgY2FuIGhhdmUgYWRkaXRpb25hbCBtZXRob2RzIHdoaWNoIGFsbG93IGNvbmZpZ3VyYXRpb24gb2YgdGhlIHByb3ZpZGVyXG4gKiBhbmQgaXRzIHNlcnZpY2UuIEltcG9ydGFudGx5LCB5b3UgY2FuIGNvbmZpZ3VyZSB3aGF0IGtpbmQgb2Ygc2VydmljZSBpcyBjcmVhdGVkIGJ5IHRoZSBgJGdldGBcbiAqIG1ldGhvZCwgb3IgaG93IHRoYXQgc2VydmljZSB3aWxsIGFjdC4gRm9yIGV4YW1wbGUsIHRoZSB7QGxpbmsgbmcuJGxvZ1Byb3ZpZGVyICRsb2dQcm92aWRlcn0gaGFzIGFcbiAqIG1ldGhvZCB7QGxpbmsgbmcuJGxvZ1Byb3ZpZGVyI2RlYnVnRW5hYmxlZCBkZWJ1Z0VuYWJsZWR9XG4gKiB3aGljaCBsZXRzIHlvdSBzcGVjaWZ5IHdoZXRoZXIgdGhlIHtAbGluayBuZy4kbG9nICRsb2d9IHNlcnZpY2Ugd2lsbCBsb2cgZGVidWcgbWVzc2FnZXMgdG8gdGhlXG4gKiBjb25zb2xlIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UuIE5PVEU6IHRoZSBwcm92aWRlciB3aWxsIGJlIGF2YWlsYWJsZSB1bmRlciBgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnUHJvdmlkZXInYCBrZXkuXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24oKSl9IHByb3ZpZGVyIElmIHRoZSBwcm92aWRlciBpczpcbiAqXG4gKiAgIC0gYE9iamVjdGA6IHRoZW4gaXQgc2hvdWxkIGhhdmUgYSBgJGdldGAgbWV0aG9kLiBUaGUgYCRnZXRgIG1ldGhvZCB3aWxsIGJlIGludm9rZWQgdXNpbmdcbiAqICAgICAgICAgICAgICAge0BsaW5rIEFVVE8uJGluamVjdG9yI2ludm9rZSAkaW5qZWN0b3IuaW52b2tlKCl9IHdoZW4gYW4gaW5zdGFuY2UgbmVlZHMgdG8gYmVcbiAqICAgICAgICAgICAgICAgY3JlYXRlZC5cbiAqICAgLSBgQ29uc3RydWN0b3JgOiBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgcHJvdmlkZXIgd2lsbCBiZSBjcmVhdGVkIHVzaW5nXG4gKiAgICAgICAgICAgICAgIHtAbGluayBBVVRPLiRpbmplY3RvciNpbnN0YW50aWF0ZSAkaW5qZWN0b3IuaW5zdGFudGlhdGUoKX0sIHRoZW4gdHJlYXRlZCBhc1xuICogICAgICAgICAgICAgICBgb2JqZWN0YC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIHByb3ZpZGVyIGluc3RhbmNlXG5cbiAqIEBleGFtcGxlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBjcmVhdGUgYSBzaW1wbGUgZXZlbnQgdHJhY2tpbmcgc2VydmljZSBhbmQgcmVnaXN0ZXIgaXQgdXNpbmdcbiAqIHtAbGluayBBVVRPLiRwcm92aWRlI21ldGhvZHNfcHJvdmlkZXIgJHByb3ZpZGUucHJvdmlkZXIoKX0uXG4gKlxuICogPHByZT5cbiAqICAvLyBEZWZpbmUgdGhlIGV2ZW50VHJhY2tlciBwcm92aWRlclxuICogIGZ1bmN0aW9uIEV2ZW50VHJhY2tlclByb3ZpZGVyKCkge1xuICogICAgdmFyIHRyYWNraW5nVXJsID0gJy90cmFjayc7XG4gKlxuICogICAgLy8gQSBwcm92aWRlciBtZXRob2QgZm9yIGNvbmZpZ3VyaW5nIHdoZXJlIHRoZSB0cmFja2VkIGV2ZW50cyBzaG91bGQgYmVlbiBzYXZlZFxuICogICAgdGhpcy5zZXRUcmFja2luZ1VybCA9IGZ1bmN0aW9uKHVybCkge1xuICogICAgICB0cmFja2luZ1VybCA9IHVybDtcbiAqICAgIH07XG4gKlxuICogICAgLy8gVGhlIHNlcnZpY2UgZmFjdG9yeSBmdW5jdGlvblxuICogICAgdGhpcy4kZ2V0ID0gWyckaHR0cCcsIGZ1bmN0aW9uKCRodHRwKSB7XG4gKiAgICAgIHZhciB0cmFja2VkRXZlbnRzID0ge307XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLy8gQ2FsbCB0aGlzIHRvIHRyYWNrIGFuIGV2ZW50XG4gKiAgICAgICAgZXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gKiAgICAgICAgICB2YXIgY291bnQgPSB0cmFja2VkRXZlbnRzW2V2ZW50XSB8fCAwO1xuICogICAgICAgICAgY291bnQgKz0gMTtcbiAqICAgICAgICAgIHRyYWNrZWRFdmVudHNbZXZlbnRdID0gY291bnQ7XG4gKiAgICAgICAgICByZXR1cm4gY291bnQ7XG4gKiAgICAgICAgfSxcbiAqICAgICAgICAvLyBDYWxsIHRoaXMgdG8gc2F2ZSB0aGUgdHJhY2tlZCBldmVudHMgdG8gdGhlIHRyYWNraW5nVXJsXG4gKiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAkaHR0cC5wb3N0KHRyYWNraW5nVXJsLCB0cmFja2VkRXZlbnRzKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH07XG4gKiAgICB9XTtcbiAqICB9XG4gKlxuICogIGRlc2NyaWJlKCdldmVudFRyYWNrZXInLCBmdW5jdGlvbigpIHtcbiAqICAgIHZhciBwb3N0U3B5O1xuICpcbiAqICAgIGJlZm9yZUVhY2gobW9kdWxlKGZ1bmN0aW9uKCRwcm92aWRlKSB7XG4gKiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBldmVudFRyYWNrZXIgcHJvdmlkZXJcbiAqICAgICAgJHByb3ZpZGUucHJvdmlkZXIoJ2V2ZW50VHJhY2tlcicsIEV2ZW50VHJhY2tlclByb3ZpZGVyKTtcbiAqICAgIH0pKTtcbiAqXG4gKiAgICBiZWZvcmVFYWNoKG1vZHVsZShmdW5jdGlvbihldmVudFRyYWNrZXJQcm92aWRlcikge1xuICogICAgICAvLyBDb25maWd1cmUgZXZlbnRUcmFja2VyIHByb3ZpZGVyXG4gKiAgICAgIGV2ZW50VHJhY2tlclByb3ZpZGVyLnNldFRyYWNraW5nVXJsKCcvY3VzdG9tLXRyYWNrJyk7XG4gKiAgICB9KSk7XG4gKlxuICogICAgaXQoJ3RyYWNrcyBldmVudHMnLCBpbmplY3QoZnVuY3Rpb24oZXZlbnRUcmFja2VyKSB7XG4gKiAgICAgIGV4cGVjdChldmVudFRyYWNrZXIuZXZlbnQoJ2xvZ2luJykpLnRvRXF1YWwoMSk7XG4gKiAgICAgIGV4cGVjdChldmVudFRyYWNrZXIuZXZlbnQoJ2xvZ2luJykpLnRvRXF1YWwoMik7XG4gKiAgICB9KSk7XG4gKlxuICogICAgaXQoJ3NhdmVzIHRvIHRoZSB0cmFja2luZyB1cmwnLCBpbmplY3QoZnVuY3Rpb24oZXZlbnRUcmFja2VyLCAkaHR0cCkge1xuICogICAgICBwb3N0U3B5ID0gc3B5T24oJGh0dHAsICdwb3N0Jyk7XG4gKiAgICAgIGV2ZW50VHJhY2tlci5ldmVudCgnbG9naW4nKTtcbiAqICAgICAgZXZlbnRUcmFja2VyLnNhdmUoKTtcbiAqICAgICAgZXhwZWN0KHBvc3RTcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAqICAgICAgZXhwZWN0KHBvc3RTcHkubW9zdFJlY2VudENhbGwuYXJnc1swXSkubm90LnRvRXF1YWwoJy90cmFjaycpO1xuICogICAgICBleHBlY3QocG9zdFNweS5tb3N0UmVjZW50Q2FsbC5hcmdzWzBdKS50b0VxdWFsKCcvY3VzdG9tLXRyYWNrJyk7XG4gKiAgICAgIGV4cGVjdChwb3N0U3B5Lm1vc3RSZWNlbnRDYWxsLmFyZ3NbMV0pLnRvRXF1YWwoeyAnbG9naW4nOiAxIH0pO1xuICogICAgfSkpO1xuICogIH0pO1xuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgbWV0aG9kXG4gKiBAbmFtZSBBVVRPLiRwcm92aWRlI2ZhY3RvcnlcbiAqIEBtZXRob2RPZiBBVVRPLiRwcm92aWRlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZWdpc3RlciBhICoqc2VydmljZSBmYWN0b3J5KiosIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHRvIHJldHVybiB0aGUgc2VydmljZSBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgc2hvcnQgZm9yIHJlZ2lzdGVyaW5nIGEgc2VydmljZSB3aGVyZSBpdHMgcHJvdmlkZXIgY29uc2lzdHMgb2Ygb25seSBhIGAkZ2V0YCBwcm9wZXJ0eSxcbiAqIHdoaWNoIGlzIHRoZSBnaXZlbiBzZXJ2aWNlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNmYWN0b3J5ICRwcm92aWRlLmZhY3RvcnkoZ2V0Rm4pfSBpZiB5b3UgZG8gbm90IG5lZWQgdG9cbiAqIGNvbmZpZ3VyZSB5b3VyIHNlcnZpY2UgaW4gYSBwcm92aWRlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9ICRnZXRGbiBUaGUgJGdldEZuIGZvciB0aGUgaW5zdGFuY2UgY3JlYXRpb24uIEludGVybmFsbHkgdGhpcyBpcyBhIHNob3J0IGhhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBgJHByb3ZpZGUucHJvdmlkZXIobmFtZSwgeyRnZXQ6ICRnZXRGbn0pYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IHJlZ2lzdGVyZWQgcHJvdmlkZXIgaW5zdGFuY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogSGVyZSBpcyBhbiBleGFtcGxlIG9mIHJlZ2lzdGVyaW5nIGEgc2VydmljZVxuICogPHByZT5cbiAqICAgJHByb3ZpZGUuZmFjdG9yeSgncGluZycsIFsnJGh0dHAnLCBmdW5jdGlvbigkaHR0cCkge1xuICogICAgIHJldHVybiBmdW5jdGlvbiBwaW5nKCkge1xuICogICAgICAgcmV0dXJuICRodHRwLnNlbmQoJy9waW5nJyk7XG4gKiAgICAgfTtcbiAqICAgfV0pO1xuICogPC9wcmU+XG4gKiBZb3Ugd291bGQgdGhlbiBpbmplY3QgYW5kIHVzZSB0aGlzIHNlcnZpY2UgbGlrZSB0aGlzOlxuICogPHByZT5cbiAqICAgc29tZU1vZHVsZS5jb250cm9sbGVyKCdDdHJsJywgWydwaW5nJywgZnVuY3Rpb24ocGluZykge1xuICogICAgIHBpbmcoKTtcbiAqICAgfV0pO1xuICogPC9wcmU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBtZXRob2RcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjc2VydmljZVxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlZ2lzdGVyIGEgKipzZXJ2aWNlIGNvbnN0cnVjdG9yKiosIHdoaWNoIHdpbGwgYmUgaW52b2tlZCB3aXRoIGBuZXdgIHRvIGNyZWF0ZSB0aGUgc2VydmljZVxuICogaW5zdGFuY2UuXG4gKiBUaGlzIGlzIHNob3J0IGZvciByZWdpc3RlcmluZyBhIHNlcnZpY2Ugd2hlcmUgaXRzIHByb3ZpZGVyJ3MgYCRnZXRgIHByb3BlcnR5IGlzIHRoZSBzZXJ2aWNlXG4gKiBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgc2VydmljZSBpbnN0YW5jZS5cbiAqXG4gKiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgQVVUTy4kcHJvdmlkZSNtZXRob2RzX3NlcnZpY2UgJHByb3ZpZGUuc2VydmljZShjbGFzcyl9IGlmIHlvdSBkZWZpbmUgeW91ciBzZXJ2aWNlXG4gKiBhcyBhIHR5cGUvY2xhc3MuIFRoaXMgaXMgY29tbW9uIHdoZW4gdXNpbmcge0BsaW5rIGh0dHA6Ly9jb2ZmZWVzY3JpcHQub3JnIENvZmZlZVNjcmlwdH0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGluc3RhbmNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQSBjbGFzcyAoY29uc3RydWN0b3IgZnVuY3Rpb24pIHRoYXQgd2lsbCBiZSBpbnN0YW50aWF0ZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIHByb3ZpZGVyIGluc3RhbmNlXG4gKlxuICogQGV4YW1wbGVcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiByZWdpc3RlcmluZyBhIHNlcnZpY2UgdXNpbmdcbiAqIHtAbGluayBBVVRPLiRwcm92aWRlI21ldGhvZHNfc2VydmljZSAkcHJvdmlkZS5zZXJ2aWNlKGNsYXNzKX0gdGhhdCBpcyBkZWZpbmVkIGFzIGEgQ29mZmVlU2NyaXB0IGNsYXNzLlxuICogPHByZT5cbiAqICAgY2xhc3MgUGluZ1xuICogICAgIGNvbnN0cnVjdG9yOiAoQCRodHRwKSAtPlxuICogICAgIHNlbmQ6ICgpID0+XG4gKiAgICAgICBAJGh0dHAuZ2V0KCcvcGluZycpXG4gKlxuICogICAkcHJvdmlkZS5zZXJ2aWNlKCdwaW5nJywgWyckaHR0cCcsIFBpbmddKVxuICogPC9wcmU+XG4gKiBZb3Ugd291bGQgdGhlbiBpbmplY3QgYW5kIHVzZSB0aGlzIHNlcnZpY2UgbGlrZSB0aGlzOlxuICogPHByZT5cbiAqICAgc29tZU1vZHVsZS5jb250cm9sbGVyICdDdHJsJywgWydwaW5nJywgKHBpbmcpIC0+XG4gKiAgICAgcGluZy5zZW5kKClcbiAqICAgXVxuICogPC9wcmU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBtZXRob2RcbiAqIEBuYW1lIEFVVE8uJHByb3ZpZGUjdmFsdWVcbiAqIEBtZXRob2RPZiBBVVRPLiRwcm92aWRlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBSZWdpc3RlciBhICoqdmFsdWUgc2VydmljZSoqIHdpdGggdGhlIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LCBzdWNoIGFzIGEgc3RyaW5nLCBhXG4gKiBudW1iZXIsIGFuIGFycmF5LCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbi4gIFRoaXMgaXMgc2hvcnQgZm9yIHJlZ2lzdGVyaW5nIGEgc2VydmljZSB3aGVyZSBpdHNcbiAqIHByb3ZpZGVyJ3MgYCRnZXRgIHByb3BlcnR5IGlzIGEgZmFjdG9yeSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB0aGUgKip2YWx1ZVxuICogc2VydmljZSoqLlxuICpcbiAqIFZhbHVlIHNlcnZpY2VzIGFyZSBzaW1pbGFyIHRvIGNvbnN0YW50IHNlcnZpY2VzLCBleGNlcHQgdGhhdCB0aGV5IGNhbm5vdCBiZSBpbmplY3RlZCBpbnRvIGFcbiAqIG1vZHVsZSBjb25maWd1cmF0aW9uIGZ1bmN0aW9uIChzZWUge0BsaW5rIGFuZ3VsYXIuTW9kdWxlI2NvbmZpZ30pIGJ1dCB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGJ5XG4gKiBhbiBBbmd1bGFyXG4gKiB7QGxpbmsgQVVUTy4kcHJvdmlkZSNkZWNvcmF0b3IgZGVjb3JhdG9yfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IHJlZ2lzdGVyZWQgcHJvdmlkZXIgaW5zdGFuY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogSGVyZSBhcmUgc29tZSBleGFtcGxlcyBvZiBjcmVhdGluZyB2YWx1ZSBzZXJ2aWNlcy5cbiAqIDxwcmU+XG4gKiAgICRwcm92aWRlLnZhbHVlKCdBRE1JTl9VU0VSJywgJ2FkbWluJyk7XG4gKlxuICogICAkcHJvdmlkZS52YWx1ZSgnUm9sZUxvb2t1cCcsIHsgYWRtaW46IDAsIHdyaXRlcjogMSwgcmVhZGVyOiAyIH0pO1xuICpcbiAqICAgJHByb3ZpZGUudmFsdWUoJ2hhbGZPZicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgICAgcmV0dXJuIHZhbHVlIC8gMjtcbiAqICAgfSk7XG4gKiA8L3ByZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIG1ldGhvZFxuICogQG5hbWUgQVVUTy4kcHJvdmlkZSNjb25zdGFudFxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlZ2lzdGVyIGEgKipjb25zdGFudCBzZXJ2aWNlKiosIHN1Y2ggYXMgYSBzdHJpbmcsIGEgbnVtYmVyLCBhbiBhcnJheSwgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sXG4gKiB3aXRoIHRoZSB7QGxpbmsgQVVUTy4kaW5qZWN0b3IgJGluamVjdG9yfS4gVW5saWtlIHtAbGluayBBVVRPLiRwcm92aWRlI3ZhbHVlIHZhbHVlfSBpdCBjYW4gYmVcbiAqIGluamVjdGVkIGludG8gYSBtb2R1bGUgY29uZmlndXJhdGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBhbmd1bGFyLk1vZHVsZSNjb25maWd9KSBhbmQgaXQgY2Fubm90XG4gKiBiZSBvdmVycmlkZGVuIGJ5IGFuIEFuZ3VsYXIge0BsaW5rIEFVVE8uJHByb3ZpZGUjZGVjb3JhdG9yIGRlY29yYXRvcn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnN0YW50LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgY29uc3RhbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZWdpc3RlcmVkIGluc3RhbmNlXG4gKlxuICogQGV4YW1wbGVcbiAqIEhlcmUgYSBzb21lIGV4YW1wbGVzIG9mIGNyZWF0aW5nIGNvbnN0YW50czpcbiAqIDxwcmU+XG4gKiAgICRwcm92aWRlLmNvbnN0YW50KCdTSEFSRF9IRUlHSFQnLCAzMDYpO1xuICpcbiAqICAgJHByb3ZpZGUuY29uc3RhbnQoJ01ZX0NPTE9VUlMnLCBbJ3JlZCcsICdibHVlJywgJ2dyZXknXSk7XG4gKlxuICogICAkcHJvdmlkZS5jb25zdGFudCgnZG91YmxlJywgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgICByZXR1cm4gdmFsdWUgKiAyO1xuICogICB9KTtcbiAqIDwvcHJlPlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2MgbWV0aG9kXG4gKiBAbmFtZSBBVVRPLiRwcm92aWRlI2RlY29yYXRvclxuICogQG1ldGhvZE9mIEFVVE8uJHByb3ZpZGVcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFJlZ2lzdGVyIGEgKipzZXJ2aWNlIGRlY29yYXRvcioqIHdpdGggdGhlIHtAbGluayBBVVRPLiRpbmplY3RvciAkaW5qZWN0b3J9LiBBIHNlcnZpY2UgZGVjb3JhdG9yXG4gKiBpbnRlcmNlcHRzIHRoZSBjcmVhdGlvbiBvZiBhIHNlcnZpY2UsIGFsbG93aW5nIGl0IHRvIG92ZXJyaWRlIG9yIG1vZGlmeSB0aGUgYmVoYXZpb3VyIG9mIHRoZVxuICogc2VydmljZS4gVGhlIG9iamVjdCByZXR1cm5lZCBieSB0aGUgZGVjb3JhdG9yIG1heSBiZSB0aGUgb3JpZ2luYWwgc2VydmljZSwgb3IgYSBuZXcgc2VydmljZVxuICogb2JqZWN0IHdoaWNoIHJlcGxhY2VzIG9yIHdyYXBzIGFuZCBkZWxlZ2F0ZXMgdG8gdGhlIG9yaWdpbmFsIHNlcnZpY2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgdG8gZGVjb3JhdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGRlY29yYXRvciBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBzZXJ2aWNlIG5lZWRzIHRvIGJlXG4gKiAgICBpbnN0YW50aWF0ZWQgYW5kIHNob3VsZCByZXR1cm4gdGhlIGRlY29yYXRlZCBzZXJ2aWNlIGluc3RhbmNlLiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHVzaW5nXG4gKiAgICB0aGUge0BsaW5rIEFVVE8uJGluamVjdG9yI2ludm9rZSBpbmplY3Rvci5pbnZva2V9IG1ldGhvZCBhbmQgaXMgdGhlcmVmb3JlIGZ1bGx5IGluamVjdGFibGUuXG4gKiAgICBMb2NhbCBpbmplY3Rpb24gYXJndW1lbnRzOlxuICpcbiAqICAgICogYCRkZWxlZ2F0ZWAgLSBUaGUgb3JpZ2luYWwgc2VydmljZSBpbnN0YW5jZSwgd2hpY2ggY2FuIGJlIG1vbmtleSBwYXRjaGVkLCBjb25maWd1cmVkLFxuICogICAgICBkZWNvcmF0ZWQgb3IgZGVsZWdhdGVkIHRvLlxuICpcbiAqIEBleGFtcGxlXG4gKiBIZXJlIHdlIGRlY29yYXRlIHRoZSB7QGxpbmsgbmcuJGxvZyAkbG9nfSBzZXJ2aWNlIHRvIGNvbnZlcnQgd2FybmluZ3MgdG8gZXJyb3JzIGJ5IGludGVyY2VwdGluZ1xuICogY2FsbHMgdG8ge0BsaW5rIG5nLiRsb2cjZXJyb3IgJGxvZy53YXJuKCl9LlxuICogPHByZT5cbiAqICAgJHByb3ZpZGVyLmRlY29yYXRvcignJGxvZycsIFsnJGRlbGVnYXRlJywgZnVuY3Rpb24oJGRlbGVnYXRlKSB7XG4gKiAgICAgJGRlbGVnYXRlLndhcm4gPSAkZGVsZWdhdGUuZXJyb3I7XG4gKiAgICAgcmV0dXJuICRkZWxlZ2F0ZTtcbiAqICAgfV0pO1xuICogPC9wcmU+XG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVJbmplY3Rvcihtb2R1bGVzVG9Mb2FkKSB7XG4gIHZhciBJTlNUQU5USUFUSU5HID0ge30sXG4gICAgICBwcm92aWRlclN1ZmZpeCA9ICdQcm92aWRlcicsXG4gICAgICBwYXRoID0gW10sXG4gICAgICBsb2FkZWRNb2R1bGVzID0gbmV3IEhhc2hNYXAoKSxcbiAgICAgIHByb3ZpZGVyQ2FjaGUgPSB7XG4gICAgICAgICRwcm92aWRlOiB7XG4gICAgICAgICAgICBwcm92aWRlcjogc3VwcG9ydE9iamVjdChwcm92aWRlciksXG4gICAgICAgICAgICBmYWN0b3J5OiBzdXBwb3J0T2JqZWN0KGZhY3RvcnkpLFxuICAgICAgICAgICAgc2VydmljZTogc3VwcG9ydE9iamVjdChzZXJ2aWNlKSxcbiAgICAgICAgICAgIHZhbHVlOiBzdXBwb3J0T2JqZWN0KHZhbHVlKSxcbiAgICAgICAgICAgIGNvbnN0YW50OiBzdXBwb3J0T2JqZWN0KGNvbnN0YW50KSxcbiAgICAgICAgICAgIGRlY29yYXRvcjogZGVjb3JhdG9yXG4gICAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3ZpZGVySW5qZWN0b3IgPSAocHJvdmlkZXJDYWNoZS4kaW5qZWN0b3IgPVxuICAgICAgICAgIGNyZWF0ZUludGVybmFsSW5qZWN0b3IocHJvdmlkZXJDYWNoZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ3VucHInLCBcIlVua25vd24gcHJvdmlkZXI6IHswfVwiLCBwYXRoLmpvaW4oJyA8LSAnKSk7XG4gICAgICAgICAgfSkpLFxuICAgICAgaW5zdGFuY2VDYWNoZSA9IHt9LFxuICAgICAgaW5zdGFuY2VJbmplY3RvciA9IChpbnN0YW5jZUNhY2hlLiRpbmplY3RvciA9XG4gICAgICAgICAgY3JlYXRlSW50ZXJuYWxJbmplY3RvcihpbnN0YW5jZUNhY2hlLCBmdW5jdGlvbihzZXJ2aWNlbmFtZSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJJbmplY3Rvci5nZXQoc2VydmljZW5hbWUgKyBwcm92aWRlclN1ZmZpeCk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VJbmplY3Rvci5pbnZva2UocHJvdmlkZXIuJGdldCwgcHJvdmlkZXIpO1xuICAgICAgICAgIH0pKTtcblxuXG4gIGZvckVhY2gobG9hZE1vZHVsZXMobW9kdWxlc1RvTG9hZCksIGZ1bmN0aW9uKGZuKSB7IGluc3RhbmNlSW5qZWN0b3IuaW52b2tlKGZuIHx8IG5vb3ApOyB9KTtcblxuICByZXR1cm4gaW5zdGFuY2VJbmplY3RvcjtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gJHByb3ZpZGVyXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGZ1bmN0aW9uIHN1cHBvcnRPYmplY3QoZGVsZWdhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgICAgZm9yRWFjaChrZXksIHJldmVyc2VQYXJhbXMoZGVsZWdhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWxlZ2F0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvdmlkZXIobmFtZSwgcHJvdmlkZXJfKSB7XG4gICAgYXNzZXJ0Tm90SGFzT3duUHJvcGVydHkobmFtZSwgJ3NlcnZpY2UnKTtcbiAgICBpZiAoaXNGdW5jdGlvbihwcm92aWRlcl8pIHx8IGlzQXJyYXkocHJvdmlkZXJfKSkge1xuICAgICAgcHJvdmlkZXJfID0gcHJvdmlkZXJJbmplY3Rvci5pbnN0YW50aWF0ZShwcm92aWRlcl8pO1xuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVyXy4kZ2V0KSB7XG4gICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ3BnZXQnLCBcIlByb3ZpZGVyICd7MH0nIG11c3QgZGVmaW5lICRnZXQgZmFjdG9yeSBtZXRob2QuXCIsIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXJDYWNoZVtuYW1lICsgcHJvdmlkZXJTdWZmaXhdID0gcHJvdmlkZXJfO1xuICB9XG5cbiAgZnVuY3Rpb24gZmFjdG9yeShuYW1lLCBmYWN0b3J5Rm4pIHsgcmV0dXJuIHByb3ZpZGVyKG5hbWUsIHsgJGdldDogZmFjdG9yeUZuIH0pOyB9XG5cbiAgZnVuY3Rpb24gc2VydmljZShuYW1lLCBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmYWN0b3J5KG5hbWUsIFsnJGluamVjdG9yJywgZnVuY3Rpb24oJGluamVjdG9yKSB7XG4gICAgICByZXR1cm4gJGluamVjdG9yLmluc3RhbnRpYXRlKGNvbnN0cnVjdG9yKTtcbiAgICB9XSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZShuYW1lLCB2YWwpIHsgcmV0dXJuIGZhY3RvcnkobmFtZSwgdmFsdWVGbih2YWwpKTsgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gICAgYXNzZXJ0Tm90SGFzT3duUHJvcGVydHkobmFtZSwgJ2NvbnN0YW50Jyk7XG4gICAgcHJvdmlkZXJDYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIGluc3RhbmNlQ2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29yYXRvcihzZXJ2aWNlTmFtZSwgZGVjb3JGbikge1xuICAgIHZhciBvcmlnUHJvdmlkZXIgPSBwcm92aWRlckluamVjdG9yLmdldChzZXJ2aWNlTmFtZSArIHByb3ZpZGVyU3VmZml4KSxcbiAgICAgICAgb3JpZyRnZXQgPSBvcmlnUHJvdmlkZXIuJGdldDtcblxuICAgIG9yaWdQcm92aWRlci4kZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JpZ0luc3RhbmNlID0gaW5zdGFuY2VJbmplY3Rvci5pbnZva2Uob3JpZyRnZXQsIG9yaWdQcm92aWRlcik7XG4gICAgICByZXR1cm4gaW5zdGFuY2VJbmplY3Rvci5pbnZva2UoZGVjb3JGbiwgbnVsbCwgeyRkZWxlZ2F0ZTogb3JpZ0luc3RhbmNlfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNb2R1bGUgTG9hZGluZ1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gbG9hZE1vZHVsZXMobW9kdWxlc1RvTG9hZCl7XG4gICAgdmFyIHJ1bkJsb2NrcyA9IFtdLCBtb2R1bGVGbiwgaW52b2tlUXVldWUsIGksIGlpO1xuICAgIGZvckVhY2gobW9kdWxlc1RvTG9hZCwgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICBpZiAobG9hZGVkTW9kdWxlcy5nZXQobW9kdWxlKSkgcmV0dXJuO1xuICAgICAgbG9hZGVkTW9kdWxlcy5wdXQobW9kdWxlLCB0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKG1vZHVsZSkpIHtcbiAgICAgICAgICBtb2R1bGVGbiA9IGFuZ3VsYXJNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgICBydW5CbG9ja3MgPSBydW5CbG9ja3MuY29uY2F0KGxvYWRNb2R1bGVzKG1vZHVsZUZuLnJlcXVpcmVzKSkuY29uY2F0KG1vZHVsZUZuLl9ydW5CbG9ja3MpO1xuXG4gICAgICAgICAgZm9yKGludm9rZVF1ZXVlID0gbW9kdWxlRm4uX2ludm9rZVF1ZXVlLCBpID0gMCwgaWkgPSBpbnZva2VRdWV1ZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW52b2tlQXJncyA9IGludm9rZVF1ZXVlW2ldLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXJJbmplY3Rvci5nZXQoaW52b2tlQXJnc1swXSk7XG5cbiAgICAgICAgICAgIHByb3ZpZGVyW2ludm9rZUFyZ3NbMV1dLmFwcGx5KHByb3ZpZGVyLCBpbnZva2VBcmdzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihtb2R1bGUpKSB7XG4gICAgICAgICAgICBydW5CbG9ja3MucHVzaChwcm92aWRlckluamVjdG9yLmludm9rZShtb2R1bGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KG1vZHVsZSkpIHtcbiAgICAgICAgICAgIHJ1bkJsb2Nrcy5wdXNoKHByb3ZpZGVySW5qZWN0b3IuaW52b2tlKG1vZHVsZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2VydEFyZ0ZuKG1vZHVsZSwgJ21vZHVsZScpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc0FycmF5KG1vZHVsZSkpIHtcbiAgICAgICAgICBtb2R1bGUgPSBtb2R1bGVbbW9kdWxlLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLm1lc3NhZ2UgJiYgZS5zdGFjayAmJiBlLnN0YWNrLmluZGV4T2YoZS5tZXNzYWdlKSA9PSAtMSkge1xuICAgICAgICAgIC8vIFNhZmFyaSAmIEZGJ3Mgc3RhY2sgdHJhY2VzIGRvbid0IGNvbnRhaW4gZXJyb3IubWVzc2FnZSBjb250ZW50XG4gICAgICAgICAgLy8gdW5saWtlIHRob3NlIG9mIENocm9tZSBhbmQgSUVcbiAgICAgICAgICAvLyBTbyBpZiBzdGFjayBkb2Vzbid0IGNvbnRhaW4gbWVzc2FnZSwgd2UgY3JlYXRlIGEgbmV3IHN0cmluZyB0aGF0IGNvbnRhaW5zIGJvdGguXG4gICAgICAgICAgLy8gU2luY2UgZXJyb3Iuc3RhY2sgaXMgcmVhZC1vbmx5IGluIFNhZmFyaSwgSSdtIG92ZXJyaWRpbmcgZSBhbmQgbm90IGUuc3RhY2sgaGVyZS5cbiAgICAgICAgICAvKiBqc2hpbnQgLVcwMjIgKi9cbiAgICAgICAgICBlID0gZS5tZXNzYWdlICsgJ1xcbicgKyBlLnN0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICRpbmplY3Rvck1pbkVycignbW9kdWxlcnInLCBcIkZhaWxlZCB0byBpbnN0YW50aWF0ZSBtb2R1bGUgezB9IGR1ZSB0bzpcXG57MX1cIixcbiAgICAgICAgICAgICAgICAgIG1vZHVsZSwgZS5zdGFjayB8fCBlLm1lc3NhZ2UgfHwgZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJ1bkJsb2NrcztcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbnRlcm5hbCBJbmplY3RvclxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbEluamVjdG9yKGNhY2hlLCBmYWN0b3J5KSB7XG5cbiAgICBmdW5jdGlvbiBnZXRTZXJ2aWNlKHNlcnZpY2VOYW1lKSB7XG4gICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoc2VydmljZU5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZVtzZXJ2aWNlTmFtZV0gPT09IElOU1RBTlRJQVRJTkcpIHtcbiAgICAgICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ2NkZXAnLCAnQ2lyY3VsYXIgZGVwZW5kZW5jeSBmb3VuZDogezB9JywgcGF0aC5qb2luKCcgPC0gJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZVtzZXJ2aWNlTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhdGgudW5zaGlmdChzZXJ2aWNlTmFtZSk7XG4gICAgICAgICAgY2FjaGVbc2VydmljZU5hbWVdID0gSU5TVEFOVElBVElORztcbiAgICAgICAgICByZXR1cm4gY2FjaGVbc2VydmljZU5hbWVdID0gZmFjdG9yeShzZXJ2aWNlTmFtZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcGF0aC5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlKGZuLCBzZWxmLCBsb2NhbHMpe1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAkaW5qZWN0ID0gYW5ub3RhdGUoZm4pLFxuICAgICAgICAgIGxlbmd0aCwgaSxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGZvcihpID0gMCwgbGVuZ3RoID0gJGluamVjdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSAkaW5qZWN0W2ldO1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyAkaW5qZWN0b3JNaW5FcnIoJ2l0a24nLFxuICAgICAgICAgICAgICAgICAgJ0luY29ycmVjdCBpbmplY3Rpb24gdG9rZW4hIEV4cGVjdGVkIHNlcnZpY2UgbmFtZSBhcyBzdHJpbmcsIGdvdCB7MH0nLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChcbiAgICAgICAgICBsb2NhbHMgJiYgbG9jYWxzLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICA/IGxvY2Fsc1trZXldXG4gICAgICAgICAgOiBnZXRTZXJ2aWNlKGtleSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghZm4uJGluamVjdCkge1xuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgd2UgbXVzdCBiZSBhbiBhcnJheS5cbiAgICAgICAgZm4gPSBmbltsZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9hbmd1bGFyanMtaW52b2tlLWFwcGx5LXZzLXN3aXRjaFxuICAgICAgLy8gIzUzODhcbiAgICAgIHJldHVybiBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZShUeXBlLCBsb2NhbHMpIHtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgaW5zdGFuY2UsIHJldHVybmVkVmFsdWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIFR5cGUgaXMgYW5ub3RhdGVkIGFuZCB1c2UganVzdCB0aGUgZ2l2ZW4gZnVuY3Rpb24gYXQgbi0xIGFzIHBhcmFtZXRlclxuICAgICAgLy8gZS5nLiBzb21lTW9kdWxlLmZhY3RvcnkoJ2dyZWV0ZXInLCBbJyR3aW5kb3cnLCBmdW5jdGlvbihyZW5hbWVkJHdpbmRvdykge31dKTtcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IChpc0FycmF5KFR5cGUpID8gVHlwZVtUeXBlLmxlbmd0aCAtIDFdIDogVHlwZSkucHJvdG90eXBlO1xuICAgICAgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIHJldHVybmVkVmFsdWUgPSBpbnZva2UoVHlwZSwgaW5zdGFuY2UsIGxvY2Fscyk7XG5cbiAgICAgIHJldHVybiBpc09iamVjdChyZXR1cm5lZFZhbHVlKSB8fCBpc0Z1bmN0aW9uKHJldHVybmVkVmFsdWUpID8gcmV0dXJuZWRWYWx1ZSA6IGluc3RhbmNlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpbnZva2U6IGludm9rZSxcbiAgICAgIGluc3RhbnRpYXRlOiBpbnN0YW50aWF0ZSxcbiAgICAgIGdldDogZ2V0U2VydmljZSxcbiAgICAgIGFubm90YXRlOiBhbm5vdGF0ZSxcbiAgICAgIGhhczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXJDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lICsgcHJvdmlkZXJTdWZmaXgpIHx8IGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIG5nLiRhbmNob3JTY3JvbGxcbiAqIEByZXF1aXJlcyAkd2luZG93XG4gKiBAcmVxdWlyZXMgJGxvY2F0aW9uXG4gKiBAcmVxdWlyZXMgJHJvb3RTY29wZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogV2hlbiBjYWxsZWQsIGl0IGNoZWNrcyBjdXJyZW50IHZhbHVlIG9mIGAkbG9jYXRpb24uaGFzaCgpYCBhbmQgc2Nyb2xsIHRvIHJlbGF0ZWQgZWxlbWVudCxcbiAqIGFjY29yZGluZyB0byBydWxlcyBzcGVjaWZpZWQgaW5cbiAqIHtAbGluayBodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjL092ZXJ2aWV3Lmh0bWwjdGhlLWluZGljYXRlZC1wYXJ0LW9mLXRoZS1kb2N1bWVudCBIdG1sNSBzcGVjfS5cbiAqXG4gKiBJdCBhbHNvIHdhdGNoZXMgdGhlIGAkbG9jYXRpb24uaGFzaCgpYCBhbmQgc2Nyb2xscyB3aGVuZXZlciBpdCBjaGFuZ2VzIHRvIG1hdGNoIGFueSBhbmNob3IuXG4gKiBUaGlzIGNhbiBiZSBkaXNhYmxlZCBieSBjYWxsaW5nIGAkYW5jaG9yU2Nyb2xsUHJvdmlkZXIuZGlzYWJsZUF1dG9TY3JvbGxpbmcoKWAuXG4gKiBcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZT5cbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgICA8ZGl2IGlkPVwic2Nyb2xsQXJlYVwiIG5nLWNvbnRyb2xsZXI9XCJTY3JvbGxDdHJsXCI+XG4gICAgICAgICA8YSBuZy1jbGljaz1cImdvdG9Cb3R0b20oKVwiPkdvIHRvIGJvdHRvbTwvYT5cbiAgICAgICAgIDxhIGlkPVwiYm90dG9tXCI+PC9hPiBZb3UncmUgYXQgdGhlIGJvdHRvbSFcbiAgICAgICA8L2Rpdj5cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICAgZnVuY3Rpb24gU2Nyb2xsQ3RybCgkc2NvcGUsICRsb2NhdGlvbiwgJGFuY2hvclNjcm9sbCkge1xuICAgICAgICAgJHNjb3BlLmdvdG9Cb3R0b20gPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgLy8gc2V0IHRoZSBsb2NhdGlvbi5oYXNoIHRvIHRoZSBpZCBvZlxuICAgICAgICAgICAvLyB0aGUgZWxlbWVudCB5b3Ugd2lzaCB0byBzY3JvbGwgdG8uXG4gICAgICAgICAgICRsb2NhdGlvbi5oYXNoKCdib3R0b20nKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgIC8vIGNhbGwgJGFuY2hvclNjcm9sbCgpXG4gICAgICAgICAgICRhbmNob3JTY3JvbGwoKTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxuICAgICAgICNzY3JvbGxBcmVhIHtcbiAgICAgICAgIGhlaWdodDogMzUwcHg7XG4gICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICB9XG5cbiAgICAgICAjYm90dG9tIHtcbiAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgbWFyZ2luLXRvcDogMjAwMHB4O1xuICAgICAgIH1cbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG5mdW5jdGlvbiAkQW5jaG9yU2Nyb2xsUHJvdmlkZXIoKSB7XG5cbiAgdmFyIGF1dG9TY3JvbGxpbmdFbmFibGVkID0gdHJ1ZTtcblxuICB0aGlzLmRpc2FibGVBdXRvU2Nyb2xsaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgYXV0b1Njcm9sbGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgfTtcblxuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCAnJGxvY2F0aW9uJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbigkd2luZG93LCAkbG9jYXRpb24sICRyb290U2NvcGUpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSAkd2luZG93LmRvY3VtZW50O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBmaXJzdCBhbmNob3IgZnJvbSBhIE5vZGVMaXN0XG4gICAgLy8gY2FuJ3QgdXNlIGZpbHRlci5maWx0ZXIsIGFzIGl0IGFjY2VwdHMgb25seSBpbnN0YW5jZXMgb2YgQXJyYXlcbiAgICAvLyBhbmQgSUUgY2FuJ3QgY29udmVydCBOb2RlTGlzdCB0byBhbiBhcnJheSB1c2luZyBbXS5zbGljZVxuICAgIC8vIFRPRE8odm9qdGEpOiB1c2UgZmlsdGVyIGlmIHdlIGNoYW5nZSBpdCB0byBhY2NlcHQgbGlzdHMgYXMgd2VsbFxuICAgIGZ1bmN0aW9uIGdldEZpcnN0QW5jaG9yKGxpc3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgZm9yRWFjaChsaXN0LCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGlmICghcmVzdWx0ICYmIGxvd2VyY2FzZShlbGVtZW50Lm5vZGVOYW1lKSA9PT0gJ2EnKSByZXN1bHQgPSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbCgpIHtcbiAgICAgIHZhciBoYXNoID0gJGxvY2F0aW9uLmhhc2goKSwgZWxtO1xuXG4gICAgICAvLyBlbXB0eSBoYXNoLCBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZVxuICAgICAgaWYgKCFoYXNoKSAkd2luZG93LnNjcm9sbFRvKDAsIDApO1xuXG4gICAgICAvLyBlbGVtZW50IHdpdGggZ2l2ZW4gaWRcbiAgICAgIGVsc2UgaWYgKChlbG0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKSkpIGVsbS5zY3JvbGxJbnRvVmlldygpO1xuXG4gICAgICAvLyBmaXJzdCBhbmNob3Igd2l0aCBnaXZlbiBuYW1lIDotRFxuICAgICAgZWxzZSBpZiAoKGVsbSA9IGdldEZpcnN0QW5jaG9yKGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpKSkpIGVsbS5zY3JvbGxJbnRvVmlldygpO1xuXG4gICAgICAvLyBubyBlbGVtZW50IGFuZCBoYXNoID09ICd0b3AnLCBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZVxuICAgICAgZWxzZSBpZiAoaGFzaCA9PT0gJ3RvcCcpICR3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gZG9lcyBub3Qgc2Nyb2xsIHdoZW4gdXNlciBjbGlja3Mgb24gYW5jaG9yIGxpbmsgdGhhdCBpcyBjdXJyZW50bHkgb25cbiAgICAvLyAobm8gdXJsIGNoYW5nZSwgbm8gJGxvY2F0aW9uLmhhc2goKSBjaGFuZ2UpLCBicm93c2VyIG5hdGl2ZSBkb2VzIHNjcm9sbFxuICAgIGlmIChhdXRvU2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24gYXV0b1Njcm9sbFdhdGNoKCkge3JldHVybiAkbG9jYXRpb24uaGFzaCgpO30sXG4gICAgICAgIGZ1bmN0aW9uIGF1dG9TY3JvbGxXYXRjaEFjdGlvbigpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRldmFsQXN5bmMoc2Nyb2xsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcm9sbDtcbiAgfV07XG59XG5cbnZhciAkYW5pbWF0ZU1pbkVyciA9IG1pbkVycignJGFuaW1hdGUnKTtcblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kYW5pbWF0ZVByb3ZpZGVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mICRhbmltYXRlIHRoYXQgZG9lc24ndCBwZXJmb3JtIGFueSBhbmltYXRpb25zLCBpbnN0ZWFkIGp1c3RcbiAqIHN5bmNocm9ub3VzbHkgcGVyZm9ybXMgRE9NXG4gKiB1cGRhdGVzIGFuZCBjYWxscyBkb25lKCkgY2FsbGJhY2tzLlxuICpcbiAqIEluIG9yZGVyIHRvIGVuYWJsZSBhbmltYXRpb25zIHRoZSBuZ0FuaW1hdGUgbW9kdWxlIGhhcyB0byBiZSBsb2FkZWQuXG4gKlxuICogVG8gc2VlIHRoZSBmdW5jdGlvbmFsIGltcGxlbWVudGF0aW9uIGNoZWNrIG91dCBzcmMvbmdBbmltYXRlL2FuaW1hdGUuanNcbiAqL1xudmFyICRBbmltYXRlUHJvdmlkZXIgPSBbJyRwcm92aWRlJywgZnVuY3Rpb24oJHByb3ZpZGUpIHtcblxuICBcbiAgdGhpcy4kJHNlbGVjdG9ycyA9IHt9O1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy4kYW5pbWF0ZVByb3ZpZGVyI3JlZ2lzdGVyXG4gICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVByb3ZpZGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZWdpc3RlcnMgYSBuZXcgaW5qZWN0YWJsZSBhbmltYXRpb24gZmFjdG9yeSBmdW5jdGlvbi4gVGhlIGZhY3RvcnkgZnVuY3Rpb24gcHJvZHVjZXMgdGhlXG4gICAqIGFuaW1hdGlvbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50IHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmVcbiAgICogYW5pbWF0ZWQuXG4gICAqXG4gICAqICAgKiBgZXZlbnRGbmA6IGBmdW5jdGlvbihFbGVtZW50LCBkb25lRnVuY3Rpb24pYCBUaGUgZWxlbWVudCB0byBhbmltYXRlLCB0aGUgYGRvbmVGdW5jdGlvbmBcbiAgICogICBtdXN0IGJlIGNhbGxlZCBvbmNlIHRoZSBlbGVtZW50IGFuaW1hdGlvbiBpcyBjb21wbGV0ZS4gSWYgYSBmdW5jdGlvbiBpcyByZXR1cm5lZCB0aGVuIHRoZVxuICAgKiAgIGFuaW1hdGlvbiBzZXJ2aWNlIHdpbGwgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY2FuY2VsIHRoZSBhbmltYXRpb24gd2hlbmV2ZXIgYSBjYW5jZWwgZXZlbnQgaXNcbiAgICogICB0cmlnZ2VyZWQuXG4gICAqXG4gICAqXG4gICAqPHByZT5cbiAgICogICByZXR1cm4ge1xuICAgICAqICAgICBldmVudEZuIDogZnVuY3Rpb24oZWxlbWVudCwgZG9uZSkge1xuICAgICAqICAgICAgIC8vY29kZSB0byBydW4gdGhlIGFuaW1hdGlvblxuICAgICAqICAgICAgIC8vb25jZSBjb21wbGV0ZSwgdGhlbiBydW4gZG9uZSgpXG4gICAgICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhbmNlbGxhdGlvbkZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgLy9jb2RlIHRvIGNhbmNlbCB0aGUgYW5pbWF0aW9uXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAqPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhY3RvcnkgVGhlIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHJldHVybiB0aGUgYW5pbWF0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlxuICAgKi9cbiAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGZhY3RvcnkpIHtcbiAgICB2YXIga2V5ID0gbmFtZSArICctYW5pbWF0aW9uJztcbiAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSAhPSAnLicpIHRocm93ICRhbmltYXRlTWluRXJyKCdub3Rjc2VsJyxcbiAgICAgICAgXCJFeHBlY3RpbmcgY2xhc3Mgc2VsZWN0b3Igc3RhcnRpbmcgd2l0aCAnLicgZ290ICd7MH0nLlwiLCBuYW1lKTtcbiAgICB0aGlzLiQkc2VsZWN0b3JzW25hbWUuc3Vic3RyKDEpXSA9IGtleTtcbiAgICAkcHJvdmlkZS5mYWN0b3J5KGtleSwgZmFjdG9yeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy4kYW5pbWF0ZVByb3ZpZGVyI2NsYXNzTmFtZUZpbHRlclxuICAgKiBAbWV0aG9kT2YgbmcuJGFuaW1hdGVQcm92aWRlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU2V0cyBhbmQvb3IgcmV0dXJucyB0aGUgQ1NTIGNsYXNzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIGNoZWNrZWQgd2hlbiBwZXJmb3JtaW5nXG4gICAqIGFuIGFuaW1hdGlvbi4gVXBvbiBib290c3RyYXAgdGhlIGNsYXNzTmFtZUZpbHRlciB2YWx1ZSBpcyBub3Qgc2V0IGF0IGFsbCBhbmQgd2lsbFxuICAgKiB0aGVyZWZvcmUgZW5hYmxlICRhbmltYXRlIHRvIGF0dGVtcHQgdG8gcGVyZm9ybSBhbiBhbmltYXRpb24gb24gYW55IGVsZW1lbnQuXG4gICAqIFdoZW4gc2V0dGluZyB0aGUgY2xhc3NOYW1lRmlsdGVyIHZhbHVlLCBhbmltYXRpb25zIHdpbGwgb25seSBiZSBwZXJmb3JtZWQgb24gZWxlbWVudHNcbiAgICogdGhhdCBzdWNjZXNzZnVsbHkgbWF0Y2ggdGhlIGZpbHRlciBleHByZXNzaW9uLiBUaGlzIGluIHR1cm4gY2FuIGJvb3N0IHBlcmZvcm1hbmNlXG4gICAqIGZvciBsb3ctcG93ZXJlZCBkZXZpY2VzIGFzIHdlbGwgYXMgYXBwbGljYXRpb25zIGNvbnRhaW5pbmcgYSBsb3Qgb2Ygc3RydWN0dXJhbCBvcGVyYXRpb25zLlxuICAgKiBAcGFyYW0ge1JlZ0V4cD19IGV4cHJlc3Npb24gVGhlIGNsYXNzTmFtZSBleHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IGFsbCBhbmltYXRpb25zXG4gICAqIEByZXR1cm4ge1JlZ0V4cH0gVGhlIGN1cnJlbnQgQ1NTIGNsYXNzTmFtZSBleHByZXNzaW9uIHZhbHVlLiBJZiBudWxsIHRoZW4gdGhlcmUgaXMgbm8gZXhwcmVzc2lvbiB2YWx1ZVxuICAgKi9cbiAgdGhpcy5jbGFzc05hbWVGaWx0ZXIgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy4kJGNsYXNzTmFtZUZpbHRlciA9IChleHByZXNzaW9uIGluc3RhbmNlb2YgUmVnRXhwKSA/IGV4cHJlc3Npb24gOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kJGNsYXNzTmFtZUZpbHRlcjtcbiAgfTtcblxuICB0aGlzLiRnZXQgPSBbJyR0aW1lb3V0JywgZnVuY3Rpb24oJHRpbWVvdXQpIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG5nZG9jIG9iamVjdFxuICAgICAqIEBuYW1lIG5nLiRhbmltYXRlXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSAkYW5pbWF0ZSBzZXJ2aWNlIHByb3ZpZGVzIHJ1ZGltZW50YXJ5IERPTSBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIHRvXG4gICAgICogaW5zZXJ0LCByZW1vdmUgYW5kIG1vdmUgZWxlbWVudHMgd2l0aGluIHRoZSBET00sIGFzIHdlbGwgYXMgYWRkaW5nIGFuZCByZW1vdmluZyBjbGFzc2VzLlxuICAgICAqIFRoaXMgc2VydmljZSBpcyB0aGUgY29yZSBzZXJ2aWNlIHVzZWQgYnkgdGhlIG5nQW5pbWF0ZSAkYW5pbWF0b3Igc2VydmljZSB3aGljaCBwcm92aWRlc1xuICAgICAqIGhpZ2gtbGV2ZWwgYW5pbWF0aW9uIGhvb2tzIGZvciBDU1MgYW5kIEphdmFTY3JpcHQuXG4gICAgICpcbiAgICAgKiAkYW5pbWF0ZSBpcyBhdmFpbGFibGUgaW4gdGhlIEFuZ3VsYXJKUyBjb3JlLCBob3dldmVyLCB0aGUgbmdBbmltYXRlIG1vZHVsZSBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogdG8gZW5hYmxlIGZ1bGwgb3V0IGFuaW1hdGlvbiBzdXBwb3J0LiBPdGhlcndpc2UsICRhbmltYXRlIHdpbGwgb25seSBwZXJmb3JtIHNpbXBsZSBET01cbiAgICAgKiBtYW5pcHVsYXRpb24gb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIFRvIGxlYXJuIG1vcmUgYWJvdXQgZW5hYmxpbmcgYW5pbWF0aW9uIHN1cHBvcnQsIGNsaWNrIGhlcmUgdG8gdmlzaXQgdGhlIHtAbGluayBuZ0FuaW1hdGVcbiAgICAgKiBuZ0FuaW1hdGUgbW9kdWxlIHBhZ2V9IGFzIHdlbGwgYXMgdGhlIHtAbGluayBuZ0FuaW1hdGUuJGFuaW1hdGUgbmdBbmltYXRlICRhbmltYXRlIHNlcnZpY2VcbiAgICAgKiBwYWdlfS5cbiAgICAgKi9cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRhbmltYXRlI2VudGVyXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGFuaW1hdGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGRlc2NyaXB0aW9uIEluc2VydHMgdGhlIGVsZW1lbnQgaW50byB0aGUgRE9NIGVpdGhlciBhZnRlciB0aGUgYGFmdGVyYCBlbGVtZW50IG9yIHdpdGhpblxuICAgICAgICogICB0aGUgYHBhcmVudGAgZWxlbWVudC4gT25jZSBjb21wbGV0ZSwgdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB3aGljaCB3aWxsIGJlIGluc2VydGVkIGludG8gdGhlIERPTVxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IHBhcmVudCB0aGUgcGFyZW50IGVsZW1lbnQgd2hpY2ggd2lsbCBhcHBlbmQgdGhlIGVsZW1lbnQgYXNcbiAgICAgICAqICAgYSBjaGlsZCAoaWYgdGhlIGFmdGVyIGVsZW1lbnQgaXMgbm90IHByZXNlbnQpXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gYWZ0ZXIgdGhlIHNpYmxpbmcgZWxlbWVudCB3aGljaCB3aWxsIGFwcGVuZCB0aGUgZWxlbWVudFxuICAgICAgICogICBhZnRlciBpdHNlbGZcbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBkb25lIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW5cbiAgICAgICAqICAgaW5zZXJ0ZWQgaW50byB0aGUgRE9NXG4gICAgICAgKi9cbiAgICAgIGVudGVyIDogZnVuY3Rpb24oZWxlbWVudCwgcGFyZW50LCBhZnRlciwgZG9uZSkge1xuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBhZnRlci5hZnRlcihlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50WzBdKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5wYXJlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBkb25lICYmICR0aW1lb3V0KGRvbmUsIDAsIGZhbHNlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjbGVhdmVcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uIE9uY2UgY29tcGxldGUsIHRoZSBkb25lKCkgY2FsbGJhY2sgd2lsbCBiZVxuICAgICAgICogICBmaXJlZCAoaWYgcHJvdmlkZWQpLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGRvbmUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgZWxlbWVudCBoYXMgYmVlblxuICAgICAgICogICByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgICAgICovXG4gICAgICBsZWF2ZSA6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgZG9uZSAmJiAkdGltZW91dChkb25lLCAwLCBmYWxzZSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRhbmltYXRlI21vdmVcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZGVzY3JpcHRpb24gTW92ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBlbGVtZW50IHdpdGhpbiB0aGUgRE9NIHRvIGJlIHBsYWNlZFxuICAgICAgICogZWl0aGVyIGFmdGVyIHRoZSBgYWZ0ZXJgIGVsZW1lbnQgb3IgaW5zaWRlIG9mIHRoZSBgcGFyZW50YCBlbGVtZW50LiBPbmNlIGNvbXBsZXRlLCB0aGVcbiAgICAgICAqIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXG4gICAgICAgKiBcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5L2pxTGl0ZSBlbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgbW92ZWQgYXJvdW5kIHdpdGhpbiB0aGVcbiAgICAgICAqICAgRE9NXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gcGFyZW50IHRoZSBwYXJlbnQgZWxlbWVudCB3aGVyZSB0aGUgZWxlbWVudCB3aWxsIGJlXG4gICAgICAgKiAgIGluc2VydGVkIGludG8gKGlmIHRoZSBhZnRlciBlbGVtZW50IGlzIG5vdCBwcmVzZW50KVxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGFmdGVyIHRoZSBzaWJsaW5nIGVsZW1lbnQgd2hlcmUgdGhlIGVsZW1lbnQgd2lsbCBiZVxuICAgICAgICogICBwb3NpdGlvbmVkIG5leHQgdG9cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb249fSBkb25lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAoaWYgcHJvdmlkZWQpIHRoYXQgd2lsbCBiZSBmaXJlZCBhZnRlciB0aGVcbiAgICAgICAqICAgZWxlbWVudCBoYXMgYmVlbiBtb3ZlZCB0byBpdHMgbmV3IHBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgIG1vdmUgOiBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIGFmdGVyLCBkb25lKSB7XG4gICAgICAgIC8vIERvIG5vdCByZW1vdmUgZWxlbWVudCBiZWZvcmUgaW5zZXJ0LiBSZW1vdmluZyB3aWxsIGNhdXNlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAgICAvLyBlbGVtZW50IHRvIGJlIGRyb3BwZWQuIEluc2VydCB3aWxsIGltcGxpY2l0bHkgZG8gdGhlIHJlbW92ZS5cbiAgICAgICAgdGhpcy5lbnRlcihlbGVtZW50LCBwYXJlbnQsIGFmdGVyLCBkb25lKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjYWRkQ2xhc3NcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB0aGUgcHJvdmlkZWQgY2xhc3NOYW1lIENTUyBjbGFzcyB2YWx1ZSB0byB0aGUgcHJvdmlkZWQgZWxlbWVudC4gT25jZVxuICAgICAgICogY29tcGxldGUsIHRoZSBkb25lKCkgY2FsbGJhY2sgd2lsbCBiZSBmaXJlZCAoaWYgcHJvdmlkZWQpLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnkvanFMaXRlIGVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBoYXZlIHRoZSBjbGFzc05hbWUgdmFsdWVcbiAgICAgICAqICAgYWRkZWQgdG8gaXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyB3aGljaCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gZG9uZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKGlmIHByb3ZpZGVkKSB0aGF0IHdpbGwgYmUgZmlyZWQgYWZ0ZXIgdGhlXG4gICAgICAgKiAgIGNsYXNzTmFtZSB2YWx1ZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZWxlbWVudFxuICAgICAgICovXG4gICAgICBhZGRDbGFzcyA6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZSkge1xuICAgICAgICBjbGFzc05hbWUgPSBpc1N0cmluZyhjbGFzc05hbWUpID9cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgOlxuICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoY2xhc3NOYW1lKSA/IGNsYXNzTmFtZS5qb2luKCcgJykgOiAnJztcbiAgICAgICAgZm9yRWFjaChlbGVtZW50LCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGpxTGl0ZUFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb25lICYmICR0aW1lb3V0KGRvbmUsIDAsIGZhbHNlKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJGFuaW1hdGUjcmVtb3ZlQ2xhc3NcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kYW5pbWF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyB0aGUgcHJvdmlkZWQgY2xhc3NOYW1lIENTUyBjbGFzcyB2YWx1ZSBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50LlxuICAgICAgICogT25jZSBjb21wbGV0ZSwgdGhlIGRvbmUoKSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkIChpZiBwcm92aWRlZCkuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeS9qcUxpdGUgZWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB3aGljaCB3aWxsIGhhdmUgdGhlIGNsYXNzTmFtZSB2YWx1ZVxuICAgICAgICogICByZW1vdmVkIGZyb20gaXRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyB3aGljaCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbj19IGRvbmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIChpZiBwcm92aWRlZCkgdGhhdCB3aWxsIGJlIGZpcmVkIGFmdGVyIHRoZVxuICAgICAgICogICBjbGFzc05hbWUgdmFsdWUgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICAgKi9cbiAgICAgIHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGlzU3RyaW5nKGNsYXNzTmFtZSkgP1xuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA6XG4gICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShjbGFzc05hbWUpID8gY2xhc3NOYW1lLmpvaW4oJyAnKSA6ICcnO1xuICAgICAgICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAganFMaXRlUmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvbmUgJiYgJHRpbWVvdXQoZG9uZSwgMCwgZmFsc2UpO1xuICAgICAgfSxcblxuICAgICAgZW5hYmxlZCA6IG5vb3BcbiAgICB9O1xuICB9XTtcbn1dO1xuXG4vKipcbiAqICEgVGhpcyBpcyBhIHByaXZhdGUgdW5kb2N1bWVudGVkIHNlcnZpY2UgIVxuICpcbiAqIEBuYW1lIG5nLiRicm93c2VyXG4gKiBAcmVxdWlyZXMgJGxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIG9iamVjdCBoYXMgdHdvIGdvYWxzOlxuICpcbiAqIC0gaGlkZSBhbGwgdGhlIGdsb2JhbCBzdGF0ZSBpbiB0aGUgYnJvd3NlciBjYXVzZWQgYnkgdGhlIHdpbmRvdyBvYmplY3RcbiAqIC0gYWJzdHJhY3QgYXdheSBhbGwgdGhlIGJyb3dzZXIgc3BlY2lmaWMgZmVhdHVyZXMgYW5kIGluY29uc2lzdGVuY2llc1xuICpcbiAqIEZvciB0ZXN0cyB3ZSBwcm92aWRlIHtAbGluayBuZ01vY2suJGJyb3dzZXIgbW9jayBpbXBsZW1lbnRhdGlvbn0gb2YgdGhlIGAkYnJvd3NlcmBcbiAqIHNlcnZpY2UsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBjb252ZW5pZW50IHRlc3Rpbmcgb2YgdGhlIGFwcGxpY2F0aW9uIHdpdGhvdXQgdGhlIGludGVyYWN0aW9uIHdpdGhcbiAqIHRoZSByZWFsIGJyb3dzZXIgYXBpcy5cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gd2luZG93IFRoZSBnbG9iYWwgd2luZG93IG9iamVjdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudCBqUXVlcnkgd3JhcHBlZCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gWEhSIFhNTEh0dHBSZXF1ZXN0IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtvYmplY3R9ICRsb2cgY29uc29sZS5sb2cgb3IgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgaW50ZXJmYWNlLlxuICogQHBhcmFtIHtvYmplY3R9ICRzbmlmZmVyICRzbmlmZmVyIHNlcnZpY2VcbiAqL1xuZnVuY3Rpb24gQnJvd3Nlcih3aW5kb3csIGRvY3VtZW50LCAkbG9nLCAkc25pZmZlcikge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICByYXdEb2N1bWVudCA9IGRvY3VtZW50WzBdLFxuICAgICAgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICBoaXN0b3J5ID0gd2luZG93Lmhpc3RvcnksXG4gICAgICBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQsXG4gICAgICBjbGVhclRpbWVvdXQgPSB3aW5kb3cuY2xlYXJUaW1lb3V0LFxuICAgICAgcGVuZGluZ0RlZmVySWRzID0ge307XG5cbiAgc2VsZi5pc01vY2sgPSBmYWxzZTtcblxuICB2YXIgb3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQgPSAwO1xuICB2YXIgb3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzID0gW107XG5cbiAgLy8gVE9ETyh2b2p0YSk6IHJlbW92ZSB0aGlzIHRlbXBvcmFyeSBhcGlcbiAgc2VsZi4kJGNvbXBsZXRlT3V0c3RhbmRpbmdSZXF1ZXN0ID0gY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3Q7XG4gIHNlbGYuJCRpbmNPdXRzdGFuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uKCkgeyBvdXRzdGFuZGluZ1JlcXVlc3RDb3VudCsrOyB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYGZuYCBmdW5jdGlvbihzdXBwb3J0cyBjdXJyeWluZykgYW5kIGRlY3JlbWVudHMgdGhlIGBvdXRzdGFuZGluZ1JlcXVlc3RDYWxsYmFja3NgXG4gICAqIGNvdW50ZXIuIElmIHRoZSBjb3VudGVyIHJlYWNoZXMgMCwgYWxsIHRoZSBgb3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzYCBhcmUgZXhlY3V0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbi5hcHBseShudWxsLCBzbGljZUFyZ3MoYXJndW1lbnRzLCAxKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG91dHN0YW5kaW5nUmVxdWVzdENvdW50LS07XG4gICAgICBpZiAob3V0c3RhbmRpbmdSZXF1ZXN0Q291bnQgPT09IDApIHtcbiAgICAgICAgd2hpbGUob3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRzdGFuZGluZ1JlcXVlc3RDYWxsYmFja3MucG9wKCkoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAkbG9nLmVycm9yKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyB1c2VkIG9ubHkgYnkgc2NlbmFyaW8gcnVubmVyXG4gICAqIFRPRE8odm9qdGEpOiBwcmVmaXggdGhpcyBtZXRob2Qgd2l0aCAkJCA/XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIG5vIG91dHN0YW5kaW5nIHJlcXVlc3RcbiAgICovXG4gIHNlbGYubm90aWZ5V2hlbk5vT3V0c3RhbmRpbmdSZXF1ZXN0cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgLy8gZm9yY2UgYnJvd3NlciB0byBleGVjdXRlIGFsbCBwb2xsRm5zIC0gdGhpcyBpcyBuZWVkZWQgc28gdGhhdCBjb29raWVzIGFuZCBvdGhlciBwb2xsZXJzIGZpcmVcbiAgICAvLyBhdCBzb21lIGRldGVybWluaXN0aWMgdGltZSBpbiByZXNwZWN0IHRvIHRoZSB0ZXN0IHJ1bm5lcidzIGFjdGlvbnMuIExlYXZpbmcgdGhpbmdzIHVwIHRvIHRoZVxuICAgIC8vIHJlZ3VsYXIgcG9sbGVyIHdvdWxkIHJlc3VsdCBpbiBmbGFreSB0ZXN0cy5cbiAgICBmb3JFYWNoKHBvbGxGbnMsIGZ1bmN0aW9uKHBvbGxGbil7IHBvbGxGbigpOyB9KTtcblxuICAgIGlmIChvdXRzdGFuZGluZ1JlcXVlc3RDb3VudCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0c3RhbmRpbmdSZXF1ZXN0Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBQb2xsIFdhdGNoZXIgQVBJXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHZhciBwb2xsRm5zID0gW10sXG4gICAgICBwb2xsVGltZW91dDtcblxuICAvKipcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjYWRkUG9sbEZuXG4gICAqIEBtZXRob2RPZiBuZy4kYnJvd3NlclxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIFBvbGwgZnVuY3Rpb24gdG8gYWRkXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBZGRzIGEgZnVuY3Rpb24gdG8gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIHRoYXQgcG9sbGVyIHBlcmlvZGljYWxseSBleGVjdXRlcyxcbiAgICogYW5kIHN0YXJ0cyBwb2xsaW5nIGlmIG5vdCBzdGFydGVkIHlldC5cbiAgICpcbiAgICogQHJldHVybnMge2Z1bmN0aW9uKCl9IHRoZSBhZGRlZCBmdW5jdGlvblxuICAgKi9cbiAgc2VsZi5hZGRQb2xsRm4gPSBmdW5jdGlvbihmbikge1xuICAgIGlmIChpc1VuZGVmaW5lZChwb2xsVGltZW91dCkpIHN0YXJ0UG9sbGVyKDEwMCwgc2V0VGltZW91dCk7XG4gICAgcG9sbEZucy5wdXNoKGZuKTtcbiAgICByZXR1cm4gZm47XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBIb3cgb2Z0ZW4gc2hvdWxkIGJyb3dzZXIgY2FsbCBwb2xsIGZ1bmN0aW9ucyAobXMpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gc2V0VGltZW91dCBSZWZlcmVuY2UgdG8gYSByZWFsIG9yIGZha2UgYHNldFRpbWVvdXRgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ29uZmlndXJlcyB0aGUgcG9sbGVyIHRvIHJ1biBpbiB0aGUgc3BlY2lmaWVkIGludGVydmFscywgdXNpbmcgdGhlIHNwZWNpZmllZFxuICAgKiBzZXRUaW1lb3V0IGZuIGFuZCBraWNrcyBpdCBvZmYuXG4gICAqL1xuICBmdW5jdGlvbiBzdGFydFBvbGxlcihpbnRlcnZhbCwgc2V0VGltZW91dCkge1xuICAgIChmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgIGZvckVhY2gocG9sbEZucywgZnVuY3Rpb24ocG9sbEZuKXsgcG9sbEZuKCk7IH0pO1xuICAgICAgcG9sbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNoZWNrLCBpbnRlcnZhbCk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFVSTCBBUElcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICB2YXIgbGFzdEJyb3dzZXJVcmwgPSBsb2NhdGlvbi5ocmVmLFxuICAgICAgYmFzZUVsZW1lbnQgPSBkb2N1bWVudC5maW5kKCdiYXNlJyksXG4gICAgICBuZXdMb2NhdGlvbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBuYW1lIG5nLiRicm93c2VyI3VybFxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdFVFRFUjpcbiAgICogV2l0aG91dCBhbnkgYXJndW1lbnQsIHRoaXMgbWV0aG9kIGp1c3QgcmV0dXJucyBjdXJyZW50IHZhbHVlIG9mIGxvY2F0aW9uLmhyZWYuXG4gICAqXG4gICAqIFNFVFRFUjpcbiAgICogV2l0aCBhdCBsZWFzdCBvbmUgYXJndW1lbnQsIHRoaXMgbWV0aG9kIHNldHMgdXJsIHRvIG5ldyB2YWx1ZS5cbiAgICogSWYgaHRtbDUgaGlzdG9yeSBhcGkgc3VwcG9ydGVkLCBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIGlzIHVzZWQsIG90aGVyd2lzZVxuICAgKiBsb2NhdGlvbi5ocmVmL2xvY2F0aW9uLnJlcGxhY2UgaXMgdXNlZC5cbiAgICogUmV0dXJucyBpdHMgb3duIGluc3RhbmNlIHRvIGFsbG93IGNoYWluaW5nXG4gICAqXG4gICAqIE5PVEU6IHRoaXMgYXBpIGlzIGludGVuZGVkIGZvciB1c2Ugb25seSBieSB0aGUgJGxvY2F0aW9uIHNlcnZpY2UuIFBsZWFzZSB1c2UgdGhlXG4gICAqIHtAbGluayBuZy4kbG9jYXRpb24gJGxvY2F0aW9uIHNlcnZpY2V9IHRvIGNoYW5nZSB1cmwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgTmV3IHVybCAod2hlbiB1c2VkIGFzIHNldHRlcilcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcmVwbGFjZSBTaG91bGQgbmV3IHVybCByZXBsYWNlIGN1cnJlbnQgaGlzdG9yeSByZWNvcmQgP1xuICAgKi9cbiAgc2VsZi51cmwgPSBmdW5jdGlvbih1cmwsIHJlcGxhY2UpIHtcbiAgICAvLyBBbmRyb2lkIEJyb3dzZXIgQkZDYWNoZSBjYXVzZXMgbG9jYXRpb24gcmVmZXJlbmNlIHRvIGJlY29tZSBzdGFsZS5cbiAgICBpZiAobG9jYXRpb24gIT09IHdpbmRvdy5sb2NhdGlvbikgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbiAgICAvLyBzZXR0ZXJcbiAgICBpZiAodXJsKSB7XG4gICAgICBpZiAobGFzdEJyb3dzZXJVcmwgPT0gdXJsKSByZXR1cm47XG4gICAgICBsYXN0QnJvd3NlclVybCA9IHVybDtcbiAgICAgIGlmICgkc25pZmZlci5oaXN0b3J5KSB7XG4gICAgICAgIGlmIChyZXBsYWNlKSBoaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCAnJywgdXJsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJycsIHVybCk7XG4gICAgICAgICAgLy8gQ3JhenkgT3BlcmEgQnVnOiBodHRwOi8vbXkub3BlcmEuY29tL2NvbW11bml0eS9mb3J1bXMvdG9waWMuZG1sP2lkPTExODU0NjJcbiAgICAgICAgICBiYXNlRWxlbWVudC5hdHRyKCdocmVmJywgYmFzZUVsZW1lbnQuYXR0cignaHJlZicpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYXRpb24gPSB1cmw7XG4gICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgbG9jYXRpb24ucmVwbGFjZSh1cmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIC8vIGdldHRlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAtIG5ld0xvY2F0aW9uIGlzIGEgd29ya2Fyb3VuZCBmb3IgYW4gSUU3LTkgaXNzdWUgd2l0aCBsb2NhdGlvbi5yZXBsYWNlIGFuZCBsb2NhdGlvbi5ocmVmXG4gICAgICAvLyAgIG1ldGhvZHMgbm90IHVwZGF0aW5nIGxvY2F0aW9uLmhyZWYgc3luY2hyb25vdXNseS5cbiAgICAgIC8vIC0gdGhlIHJlcGxhY2VtZW50IGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDA3MTcyXG4gICAgICByZXR1cm4gbmV3TG9jYXRpb24gfHwgbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8lMjcvZyxcIidcIik7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cmxDaGFuZ2VMaXN0ZW5lcnMgPSBbXSxcbiAgICAgIHVybENoYW5nZUluaXQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBmaXJlVXJsQ2hhbmdlKCkge1xuICAgIG5ld0xvY2F0aW9uID0gbnVsbDtcbiAgICBpZiAobGFzdEJyb3dzZXJVcmwgPT0gc2VsZi51cmwoKSkgcmV0dXJuO1xuXG4gICAgbGFzdEJyb3dzZXJVcmwgPSBzZWxmLnVybCgpO1xuICAgIGZvckVhY2godXJsQ2hhbmdlTGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoc2VsZi51cmwoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjb25VcmxDaGFuZ2VcbiAgICogQG1ldGhvZE9mIG5nLiRicm93c2VyXG4gICAqIEBUT0RPKHZvanRhKTogcmVmYWN0b3IgdG8gdXNlIG5vZGUncyBzeW50YXggZm9yIGV2ZW50c1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXIgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCwgd2hlbiB1cmwgY2hhbmdlcy5cbiAgICpcbiAgICogSXQncyBvbmx5IGNhbGxlZCB3aGVuIHRoZSB1cmwgaXMgY2hhbmdlZCBieSBvdXRzaWRlIG9mIGFuZ3VsYXI6XG4gICAqIC0gdXNlciB0eXBlcyBkaWZmZXJlbnQgdXJsIGludG8gYWRkcmVzcyBiYXJcbiAgICogLSB1c2VyIGNsaWNrcyBvbiBoaXN0b3J5IChmb3J3YXJkL2JhY2spIGJ1dHRvblxuICAgKiAtIHVzZXIgY2xpY2tzIG9uIGEgbGlua1xuICAgKlxuICAgKiBJdCdzIG5vdCBjYWxsZWQgd2hlbiB1cmwgaXMgY2hhbmdlZCBieSAkYnJvd3Nlci51cmwoKSBtZXRob2RcbiAgICpcbiAgICogVGhlIGxpc3RlbmVyIGdldHMgY2FsbGVkIHdpdGggbmV3IHVybCBhcyBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIE5PVEU6IHRoaXMgYXBpIGlzIGludGVuZGVkIGZvciB1c2Ugb25seSBieSB0aGUgJGxvY2F0aW9uIHNlcnZpY2UuIFBsZWFzZSB1c2UgdGhlXG4gICAqIHtAbGluayBuZy4kbG9jYXRpb24gJGxvY2F0aW9uIHNlcnZpY2V9IHRvIG1vbml0b3IgdXJsIGNoYW5nZXMgaW4gYW5ndWxhciBhcHBzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHVybCBjaGFuZ2VzLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpfSBSZXR1cm5zIHRoZSByZWdpc3RlcmVkIGxpc3RlbmVyIGZuIC0gaGFuZHkgaWYgdGhlIGZuIGlzIGFub255bW91cy5cbiAgICovXG4gIHNlbGYub25VcmxDaGFuZ2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICghdXJsQ2hhbmdlSW5pdCkge1xuICAgICAgLy8gV2UgbGlzdGVuIG9uIGJvdGggKGhhc2hjaGFuZ2UvcG9wc3RhdGUpIHdoZW4gYXZhaWxhYmxlLCBhcyBzb21lIGJyb3dzZXJzIChlLmcuIE9wZXJhKVxuICAgICAgLy8gZG9uJ3QgZmlyZSBwb3BzdGF0ZSB3aGVuIHVzZXIgY2hhbmdlIHRoZSBhZGRyZXNzIGJhciBhbmQgZG9uJ3QgZmlyZSBoYXNoY2hhbmdlIHdoZW4gdXJsXG4gICAgICAvLyBjaGFuZ2VkIGJ5IHB1c2gvcmVwbGFjZVN0YXRlXG5cbiAgICAgIC8vIGh0bWw1IGhpc3RvcnkgYXBpIC0gcG9wc3RhdGUgZXZlbnRcbiAgICAgIGlmICgkc25pZmZlci5oaXN0b3J5KSBqcUxpdGUod2luZG93KS5vbigncG9wc3RhdGUnLCBmaXJlVXJsQ2hhbmdlKTtcbiAgICAgIC8vIGhhc2hjaGFuZ2UgZXZlbnRcbiAgICAgIGlmICgkc25pZmZlci5oYXNoY2hhbmdlKSBqcUxpdGUod2luZG93KS5vbignaGFzaGNoYW5nZScsIGZpcmVVcmxDaGFuZ2UpO1xuICAgICAgLy8gcG9sbGluZ1xuICAgICAgZWxzZSBzZWxmLmFkZFBvbGxGbihmaXJlVXJsQ2hhbmdlKTtcblxuICAgICAgdXJsQ2hhbmdlSW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgdXJsQ2hhbmdlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfTtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNaXNjIEFQSVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNiYXNlSHJlZlxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcbiAgICogXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIGN1cnJlbnQgPGJhc2UgaHJlZj5cbiAgICogKGFsd2F5cyByZWxhdGl2ZSAtIHdpdGhvdXQgZG9tYWluKVxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nPX0gY3VycmVudCA8YmFzZSBocmVmPlxuICAgKi9cbiAgc2VsZi5iYXNlSHJlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBocmVmID0gYmFzZUVsZW1lbnQuYXR0cignaHJlZicpO1xuICAgIHJldHVybiBocmVmID8gaHJlZi5yZXBsYWNlKC9eaHR0cHM/XFw6XFwvXFwvW15cXC9dKi8sICcnKSA6ICcnO1xuICB9O1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIENvb2tpZXMgQVBJXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHZhciBsYXN0Q29va2llcyA9IHt9O1xuICB2YXIgbGFzdENvb2tpZVN0cmluZyA9ICcnO1xuICB2YXIgY29va2llUGF0aCA9IHNlbGYuYmFzZUhyZWYoKTtcblxuICAvKipcbiAgICogQG5hbWUgbmcuJGJyb3dzZXIjY29va2llc1xuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIENvb2tpZSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdmFsdWUgQ29va2llIHZhbHVlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgY29va2llcyBtZXRob2QgcHJvdmlkZXMgYSAncHJpdmF0ZScgbG93IGxldmVsIGFjY2VzcyB0byBicm93c2VyIGNvb2tpZXMuXG4gICAqIEl0IGlzIG5vdCBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LCB1c2UgdGhlICRjb29raWUgc2VydmljZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuIHZhbHVlcyB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIG1ldGhvZCB3YXMgY2FsbGVkIHdpdGggYXMgZm9sbG93czpcbiAgICogXG4gICAqIC0gY29va2llcygpIC0+IGhhc2ggb2YgYWxsIGNvb2tpZXMsIHRoaXMgaXMgTk9UIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUsIHNvIGRvIG5vdCBtb2RpZnlcbiAgICogICBpdFxuICAgKiAtIGNvb2tpZXMobmFtZSwgdmFsdWUpIC0+IHNldCBuYW1lIHRvIHZhbHVlLCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgZGVsZXRlIHRoZSBjb29raWVcbiAgICogLSBjb29raWVzKG5hbWUpIC0+IHRoZSBzYW1lIGFzIChuYW1lLCB1bmRlZmluZWQpID09IERFTEVURVMgKG5vIG9uZSBjYWxscyBpdCByaWdodCBub3cgdGhhdFxuICAgKiAgIHdheSlcbiAgICogXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEhhc2ggb2YgYWxsIGNvb2tpZXMgKGlmIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIpXG4gICAqL1xuICBzZWxmLmNvb2tpZXMgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIC8qIGdsb2JhbCBlc2NhcGU6IGZhbHNlLCB1bmVzY2FwZTogZmFsc2UgKi9cbiAgICB2YXIgY29va2llTGVuZ3RoLCBjb29raWVBcnJheSwgY29va2llLCBpLCBpbmRleDtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByYXdEb2N1bWVudC5jb29raWUgPSBlc2NhcGUobmFtZSkgKyBcIj07cGF0aD1cIiArIGNvb2tpZVBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgY29va2llTGVuZ3RoID0gKHJhd0RvY3VtZW50LmNvb2tpZSA9IGVzY2FwZShuYW1lKSArICc9JyArIGVzY2FwZSh2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnO3BhdGg9JyArIGNvb2tpZVBhdGgpLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAvLyBwZXIgaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjEwOS50eHQgYnJvd3NlciBtdXN0IGFsbG93IGF0IG1pbmltdW06XG4gICAgICAgICAgLy8gLSAzMDAgY29va2llc1xuICAgICAgICAgIC8vIC0gMjAgY29va2llcyBwZXIgdW5pcXVlIGRvbWFpblxuICAgICAgICAgIC8vIC0gNDA5NiBieXRlcyBwZXIgY29va2llXG4gICAgICAgICAgaWYgKGNvb2tpZUxlbmd0aCA+IDQwOTYpIHtcbiAgICAgICAgICAgICRsb2cud2FybihcIkNvb2tpZSAnXCIrIG5hbWUgK1xuICAgICAgICAgICAgICBcIicgcG9zc2libHkgbm90IHNldCBvciBvdmVyZmxvd2VkIGJlY2F1c2UgaXQgd2FzIHRvbyBsYXJnZSAoXCIrXG4gICAgICAgICAgICAgIGNvb2tpZUxlbmd0aCArIFwiID4gNDA5NiBieXRlcykhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmF3RG9jdW1lbnQuY29va2llICE9PSBsYXN0Q29va2llU3RyaW5nKSB7XG4gICAgICAgIGxhc3RDb29raWVTdHJpbmcgPSByYXdEb2N1bWVudC5jb29raWU7XG4gICAgICAgIGNvb2tpZUFycmF5ID0gbGFzdENvb2tpZVN0cmluZy5zcGxpdChcIjsgXCIpO1xuICAgICAgICBsYXN0Q29va2llcyA9IHt9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29raWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvb2tpZSA9IGNvb2tpZUFycmF5W2ldO1xuICAgICAgICAgIGluZGV4ID0gY29va2llLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7IC8vaWdub3JlIG5hbWVsZXNzIGNvb2tpZXNcbiAgICAgICAgICAgIG5hbWUgPSB1bmVzY2FwZShjb29raWUuc3Vic3RyaW5nKDAsIGluZGV4KSk7XG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgdmFsdWUgdGhhdCBpcyBzZWVuIGZvciBhIGNvb2tpZSBpcyB0aGUgbW9zdFxuICAgICAgICAgICAgLy8gc3BlY2lmaWMgb25lLiAgdmFsdWVzIGZvciB0aGUgc2FtZSBjb29raWUgbmFtZSB0aGF0XG4gICAgICAgICAgICAvLyBmb2xsb3cgYXJlIGZvciBsZXNzIHNwZWNpZmljIHBhdGhzLlxuICAgICAgICAgICAgaWYgKGxhc3RDb29raWVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGFzdENvb2tpZXNbbmFtZV0gPSB1bmVzY2FwZShjb29raWUuc3Vic3RyaW5nKGluZGV4ICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RDb29raWVzO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNkZWZlclxuICAgKiBAbWV0aG9kT2YgbmcuJGJyb3dzZXJcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBmbiBBIGZ1bmN0aW9uLCB3aG8ncyBleGVjdXRpb24gc2hvdWxkIGJlIGRlZmVycmVkLlxuICAgKiBAcGFyYW0ge251bWJlcj19IFtkZWxheT0wXSBvZiBtaWxsaXNlY29uZHMgdG8gZGVmZXIgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICogQHJldHVybnMgeyp9IERlZmVySWQgdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIHRhc2sgdmlhIGAkYnJvd3Nlci5kZWZlci5jYW5jZWwoKWAuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBFeGVjdXRlcyBhIGZuIGFzeW5jaHJvbm91c2x5IHZpYSBgc2V0VGltZW91dChmbiwgZGVsYXkpYC5cbiAgICpcbiAgICogVW5saWtlIHdoZW4gY2FsbGluZyBgc2V0VGltZW91dGAgZGlyZWN0bHksIGluIHRlc3QgdGhpcyBmdW5jdGlvbiBpcyBtb2NrZWQgYW5kIGluc3RlYWQgb2YgdXNpbmdcbiAgICogYHNldFRpbWVvdXRgIGluIHRlc3RzLCB0aGUgZm5zIGFyZSBxdWV1ZWQgaW4gYW4gYXJyYXksIHdoaWNoIGNhbiBiZSBwcm9ncmFtbWF0aWNhbGx5IGZsdXNoZWRcbiAgICogdmlhIGAkYnJvd3Nlci5kZWZlci5mbHVzaCgpYC5cbiAgICpcbiAgICovXG4gIHNlbGYuZGVmZXIgPSBmdW5jdGlvbihmbiwgZGVsYXkpIHtcbiAgICB2YXIgdGltZW91dElkO1xuICAgIG91dHN0YW5kaW5nUmVxdWVzdENvdW50Kys7XG4gICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nRGVmZXJJZHNbdGltZW91dElkXTtcbiAgICAgIGNvbXBsZXRlT3V0c3RhbmRpbmdSZXF1ZXN0KGZuKTtcbiAgICB9LCBkZWxheSB8fCAwKTtcbiAgICBwZW5kaW5nRGVmZXJJZHNbdGltZW91dElkXSA9IHRydWU7XG4gICAgcmV0dXJuIHRpbWVvdXRJZDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAbmFtZSBuZy4kYnJvd3NlciNkZWZlci5jYW5jZWxcbiAgICogQG1ldGhvZE9mIG5nLiRicm93c2VyLmRlZmVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDYW5jZWxzIGEgZGVmZXJyZWQgdGFzayBpZGVudGlmaWVkIHdpdGggYGRlZmVySWRgLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRlZmVySWQgVG9rZW4gcmV0dXJuZWQgYnkgdGhlIGAkYnJvd3Nlci5kZWZlcmAgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFzayBoYXNuJ3QgZXhlY3V0ZWQgeWV0IGFuZCB3YXMgc3VjY2Vzc2Z1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZC5cbiAgICovXG4gIHNlbGYuZGVmZXIuY2FuY2VsID0gZnVuY3Rpb24oZGVmZXJJZCkge1xuICAgIGlmIChwZW5kaW5nRGVmZXJJZHNbZGVmZXJJZF0pIHtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nRGVmZXJJZHNbZGVmZXJJZF07XG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJJZCk7XG4gICAgICBjb21wbGV0ZU91dHN0YW5kaW5nUmVxdWVzdChub29wKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbn1cblxuZnVuY3Rpb24gJEJyb3dzZXJQcm92aWRlcigpe1xuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCAnJGxvZycsICckc25pZmZlcicsICckZG9jdW1lbnQnLFxuICAgICAgZnVuY3Rpb24oICR3aW5kb3csICAgJGxvZywgICAkc25pZmZlciwgICAkZG9jdW1lbnQpe1xuICAgICAgICByZXR1cm4gbmV3IEJyb3dzZXIoJHdpbmRvdywgJGRvY3VtZW50LCAkbG9nLCAkc25pZmZlcik7XG4gICAgICB9XTtcbn1cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kY2FjaGVGYWN0b3J5XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGYWN0b3J5IHRoYXQgY29uc3RydWN0cyBjYWNoZSBvYmplY3RzIGFuZCBnaXZlcyBhY2Nlc3MgdG8gdGhlbS5cbiAqIFxuICogPHByZT5cbiAqIFxuICogIHZhciBjYWNoZSA9ICRjYWNoZUZhY3RvcnkoJ2NhY2hlSWQnKTtcbiAqICBleHBlY3QoJGNhY2hlRmFjdG9yeS5nZXQoJ2NhY2hlSWQnKSkudG9CZShjYWNoZSk7XG4gKiAgZXhwZWN0KCRjYWNoZUZhY3RvcnkuZ2V0KCdub1N1Y2hDYWNoZUlkJykpLm5vdC50b0JlRGVmaW5lZCgpO1xuICpcbiAqICBjYWNoZS5wdXQoXCJrZXlcIiwgXCJ2YWx1ZVwiKTtcbiAqICBjYWNoZS5wdXQoXCJhbm90aGVyIGtleVwiLCBcImFub3RoZXIgdmFsdWVcIik7XG4gKlxuICogIC8vIFdlJ3ZlIHNwZWNpZmllZCBubyBvcHRpb25zIG9uIGNyZWF0aW9uXG4gKiAgZXhwZWN0KGNhY2hlLmluZm8oKSkudG9FcXVhbCh7aWQ6ICdjYWNoZUlkJywgc2l6ZTogMn0pOyBcbiAqIFxuICogPC9wcmU+XG4gKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZUlkIE5hbWUgb3IgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgY2FjaGUuXG4gKiBAcGFyYW0ge29iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QgdGhhdCBzcGVjaWZpZXMgdGhlIGNhY2hlIGJlaGF2aW9yLiBQcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBge251bWJlcj19YCBgY2FwYWNpdHlgIOKAlCB0dXJucyB0aGUgY2FjaGUgaW50byBMUlUgY2FjaGUuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gTmV3bHkgY3JlYXRlZCBjYWNoZSBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHNldCBvZiBtZXRob2RzOlxuICpcbiAqIC0gYHtvYmplY3R9YCBgaW5mbygpYCDigJQgUmV0dXJucyBpZCwgc2l6ZSwgYW5kIG9wdGlvbnMgb2YgY2FjaGUuXG4gKiAtIGB7eyp9fWAgYHB1dCh7c3RyaW5nfSBrZXksIHsqfSB2YWx1ZSlgIOKAlCBQdXRzIGEgbmV3IGtleS12YWx1ZSBwYWlyIGludG8gdGhlIGNhY2hlIGFuZCByZXR1cm5zXG4gKiAgIGl0LlxuICogLSBge3sqfX1gIGBnZXQoe3N0cmluZ30ga2V5KWAg4oCUIFJldHVybnMgY2FjaGVkIHZhbHVlIGZvciBga2V5YCBvciB1bmRlZmluZWQgZm9yIGNhY2hlIG1pc3MuXG4gKiAtIGB7dm9pZH1gIGByZW1vdmUoe3N0cmluZ30ga2V5KWAg4oCUIFJlbW92ZXMgYSBrZXktdmFsdWUgcGFpciBmcm9tIHRoZSBjYWNoZS5cbiAqIC0gYHt2b2lkfWAgYHJlbW92ZUFsbCgpYCDigJQgUmVtb3ZlcyBhbGwgY2FjaGVkIHZhbHVlcy5cbiAqIC0gYHt2b2lkfWAgYGRlc3Ryb3koKWAg4oCUIFJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGlzIGNhY2hlIGZyb20gJGNhY2hlRmFjdG9yeS5cbiAqXG4gKi9cbmZ1bmN0aW9uICRDYWNoZUZhY3RvcnlQcm92aWRlcigpIHtcblxuICB0aGlzLiRnZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FjaGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBjYWNoZUZhY3RvcnkoY2FjaGVJZCwgb3B0aW9ucykge1xuICAgICAgaWYgKGNhY2hlSWQgaW4gY2FjaGVzKSB7XG4gICAgICAgIHRocm93IG1pbkVycignJGNhY2hlRmFjdG9yeScpKCdpaWQnLCBcIkNhY2hlSWQgJ3swfScgaXMgYWxyZWFkeSB0YWtlbiFcIiwgY2FjaGVJZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplID0gMCxcbiAgICAgICAgICBzdGF0cyA9IGV4dGVuZCh7fSwgb3B0aW9ucywge2lkOiBjYWNoZUlkfSksXG4gICAgICAgICAgZGF0YSA9IHt9LFxuICAgICAgICAgIGNhcGFjaXR5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jYXBhY2l0eSkgfHwgTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICBscnVIYXNoID0ge30sXG4gICAgICAgICAgZnJlc2hFbmQgPSBudWxsLFxuICAgICAgICAgIHN0YWxlRW5kID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGNhY2hlc1tjYWNoZUlkXSA9IHtcblxuICAgICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgbHJ1RW50cnkgPSBscnVIYXNoW2tleV0gfHwgKGxydUhhc2hba2V5XSA9IHtrZXk6IGtleX0pO1xuXG4gICAgICAgICAgcmVmcmVzaChscnVFbnRyeSk7XG5cbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGRhdGEpKSBzaXplKys7XG4gICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgICBpZiAoc2l6ZSA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShzdGFsZUVuZC5rZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgdmFyIGxydUVudHJ5ID0gbHJ1SGFzaFtrZXldO1xuXG4gICAgICAgICAgaWYgKCFscnVFbnRyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgcmVmcmVzaChscnVFbnRyeSk7XG5cbiAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB2YXIgbHJ1RW50cnkgPSBscnVIYXNoW2tleV07XG5cbiAgICAgICAgICBpZiAoIWxydUVudHJ5KSByZXR1cm47XG5cbiAgICAgICAgICBpZiAobHJ1RW50cnkgPT0gZnJlc2hFbmQpIGZyZXNoRW5kID0gbHJ1RW50cnkucDtcbiAgICAgICAgICBpZiAobHJ1RW50cnkgPT0gc3RhbGVFbmQpIHN0YWxlRW5kID0gbHJ1RW50cnkubjtcbiAgICAgICAgICBsaW5rKGxydUVudHJ5Lm4sbHJ1RW50cnkucCk7XG5cbiAgICAgICAgICBkZWxldGUgbHJ1SGFzaFtrZXldO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgICAgc2l6ZS0tO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgICAgbHJ1SGFzaCA9IHt9O1xuICAgICAgICAgIGZyZXNoRW5kID0gc3RhbGVFbmQgPSBudWxsO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgc3RhdHMgPSBudWxsO1xuICAgICAgICAgIGxydUhhc2ggPSBudWxsO1xuICAgICAgICAgIGRlbGV0ZSBjYWNoZXNbY2FjaGVJZF07XG4gICAgICAgIH0sXG5cblxuICAgICAgICBpbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBzdGF0cywge3NpemU6IHNpemV9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuXG4gICAgICAvKipcbiAgICAgICAqIG1ha2VzIHRoZSBgZW50cnlgIHRoZSBmcmVzaEVuZCBvZiB0aGUgTFJVIGxpbmtlZCBsaXN0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlZnJlc2goZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5ICE9IGZyZXNoRW5kKSB7XG4gICAgICAgICAgaWYgKCFzdGFsZUVuZCkge1xuICAgICAgICAgICAgc3RhbGVFbmQgPSBlbnRyeTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWxlRW5kID09IGVudHJ5KSB7XG4gICAgICAgICAgICBzdGFsZUVuZCA9IGVudHJ5Lm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluayhlbnRyeS5uLCBlbnRyeS5wKTtcbiAgICAgICAgICBsaW5rKGVudHJ5LCBmcmVzaEVuZCk7XG4gICAgICAgICAgZnJlc2hFbmQgPSBlbnRyeTtcbiAgICAgICAgICBmcmVzaEVuZC5uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8qKlxuICAgICAgICogYmlkaXJlY3Rpb25hbGx5IGxpbmtzIHR3byBlbnRyaWVzIG9mIHRoZSBMUlUgbGlua2VkIGxpc3RcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbGluayhuZXh0RW50cnksIHByZXZFbnRyeSkge1xuICAgICAgICBpZiAobmV4dEVudHJ5ICE9IHByZXZFbnRyeSkge1xuICAgICAgICAgIGlmIChuZXh0RW50cnkpIG5leHRFbnRyeS5wID0gcHJldkVudHJ5OyAvL3Agc3RhbmRzIGZvciBwcmV2aW91cywgJ3ByZXYnIGRpZG4ndCBtaW5pZnlcbiAgICAgICAgICBpZiAocHJldkVudHJ5KSBwcmV2RW50cnkubiA9IG5leHRFbnRyeTsgLy9uIHN0YW5kcyBmb3IgbmV4dCwgJ25leHQnIGRpZG4ndCBtaW5pZnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG4gIC8qKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lIG5nLiRjYWNoZUZhY3RvcnkjaW5mb1xuICAgKiBAbWV0aG9kT2YgbmcuJGNhY2hlRmFjdG9yeVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCB0aGUgb2YgdGhlIGNhY2hlcyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0ga2V5LXZhbHVlIG1hcCBvZiBgY2FjaGVJZGAgdG8gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGBjYWNoZSNpbmZvYFxuICAgKi9cbiAgICBjYWNoZUZhY3RvcnkuaW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGluZm8gPSB7fTtcbiAgICAgIGZvckVhY2goY2FjaGVzLCBmdW5jdGlvbihjYWNoZSwgY2FjaGVJZCkge1xuICAgICAgICBpbmZvW2NhY2hlSWRdID0gY2FjaGUuaW5mbygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9O1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGNhY2hlRmFjdG9yeSNnZXRcbiAgICogQG1ldGhvZE9mIG5nLiRjYWNoZUZhY3RvcnlcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdldCBhY2Nlc3MgdG8gYSBjYWNoZSBvYmplY3QgYnkgdGhlIGBjYWNoZUlkYCB1c2VkIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZUlkIE5hbWUgb3IgaWQgb2YgYSBjYWNoZSB0byBhY2Nlc3MuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhY2hlIG9iamVjdCBpZGVudGlmaWVkIGJ5IHRoZSBjYWNoZUlkIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoIGNhY2hlLlxuICAgKi9cbiAgICBjYWNoZUZhY3RvcnkuZ2V0ID0gZnVuY3Rpb24oY2FjaGVJZCkge1xuICAgICAgcmV0dXJuIGNhY2hlc1tjYWNoZUlkXTtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gY2FjaGVGYWN0b3J5O1xuICB9O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiR0ZW1wbGF0ZUNhY2hlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgZmlyc3QgdGltZSBhIHRlbXBsYXRlIGlzIHVzZWQsIGl0IGlzIGxvYWRlZCBpbiB0aGUgdGVtcGxhdGUgY2FjaGUgZm9yIHF1aWNrIHJldHJpZXZhbC4gWW91XG4gKiBjYW4gbG9hZCB0ZW1wbGF0ZXMgZGlyZWN0bHkgaW50byB0aGUgY2FjaGUgaW4gYSBgc2NyaXB0YCB0YWcsIG9yIGJ5IGNvbnN1bWluZyB0aGVcbiAqIGAkdGVtcGxhdGVDYWNoZWAgc2VydmljZSBkaXJlY3RseS5cbiAqIFxuICogQWRkaW5nIHZpYSB0aGUgYHNjcmlwdGAgdGFnOlxuICogPHByZT5cbiAqIDxodG1sIG5nLWFwcD5cbiAqIDxoZWFkPlxuICogPHNjcmlwdCB0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiIGlkPVwidGVtcGxhdGVJZC5odG1sXCI+XG4gKiAgIFRoaXMgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIHRlbXBsYXRlXG4gKiA8L3NjcmlwdD5cbiAqIDwvaGVhZD5cbiAqICAgLi4uXG4gKiA8L2h0bWw+XG4gKiA8L3ByZT5cbiAqIFxuICogKipOb3RlOioqIHRoZSBgc2NyaXB0YCB0YWcgY29udGFpbmluZyB0aGUgdGVtcGxhdGUgZG9lcyBub3QgbmVlZCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgYGhlYWRgIG9mXG4gKiB0aGUgZG9jdW1lbnQsIGJ1dCBpdCBtdXN0IGJlIGJlbG93IHRoZSBgbmctYXBwYCBkZWZpbml0aW9uLlxuICogXG4gKiBBZGRpbmcgdmlhIHRoZSAkdGVtcGxhdGVDYWNoZSBzZXJ2aWNlOlxuICogXG4gKiA8cHJlPlxuICogdmFyIG15QXBwID0gYW5ndWxhci5tb2R1bGUoJ215QXBwJywgW10pO1xuICogbXlBcHAucnVuKGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gKiAgICR0ZW1wbGF0ZUNhY2hlLnB1dCgndGVtcGxhdGVJZC5odG1sJywgJ1RoaXMgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIHRlbXBsYXRlJyk7XG4gKiB9KTtcbiAqIDwvcHJlPlxuICogXG4gKiBUbyByZXRyaWV2ZSB0aGUgdGVtcGxhdGUgbGF0ZXIsIHNpbXBseSB1c2UgaXQgaW4geW91ciBIVE1MOlxuICogPHByZT5cbiAqIDxkaXYgbmctaW5jbHVkZT1cIiAndGVtcGxhdGVJZC5odG1sJyBcIj48L2Rpdj5cbiAqIDwvcHJlPlxuICogXG4gKiBvciBnZXQgaXQgdmlhIEphdmFzY3JpcHQ6XG4gKiA8cHJlPlxuICogJHRlbXBsYXRlQ2FjaGUuZ2V0KCd0ZW1wbGF0ZUlkLmh0bWwnKVxuICogPC9wcmU+XG4gKiBcbiAqIFNlZSB7QGxpbmsgbmcuJGNhY2hlRmFjdG9yeSAkY2FjaGVGYWN0b3J5fS5cbiAqXG4gKi9cbmZ1bmN0aW9uICRUZW1wbGF0ZUNhY2hlUHJvdmlkZXIoKSB7XG4gIHRoaXMuJGdldCA9IFsnJGNhY2hlRmFjdG9yeScsIGZ1bmN0aW9uKCRjYWNoZUZhY3RvcnkpIHtcbiAgICByZXR1cm4gJGNhY2hlRmFjdG9yeSgndGVtcGxhdGVzJyk7XG4gIH1dO1xufVxuXG4vKiAhIFZBUklBQkxFL0ZVTkNUSU9OIE5BTUlORyBDT05WRU5USU9OUyBUSEFUIEFQUExZIFRPIFRISVMgRklMRSFcbiAqXG4gKiBET00tcmVsYXRlZCB2YXJpYWJsZXM6XG4gKlxuICogLSBcIm5vZGVcIiAtIERPTSBOb2RlXG4gKiAtIFwiZWxlbWVudFwiIC0gRE9NIEVsZW1lbnQgb3IgTm9kZVxuICogLSBcIiRub2RlXCIgb3IgXCIkZWxlbWVudFwiIC0ganFMaXRlLXdyYXBwZWQgbm9kZSBvciBlbGVtZW50XG4gKlxuICpcbiAqIENvbXBpbGVyIHJlbGF0ZWQgc3R1ZmY6XG4gKlxuICogLSBcImxpbmtGblwiIC0gbGlua2luZyBmbiBvZiBhIHNpbmdsZSBkaXJlY3RpdmVcbiAqIC0gXCJub2RlTGlua0ZuXCIgLSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYWxsIGxpbmtpbmcgZm5zIGZvciBhIHBhcnRpY3VsYXIgbm9kZVxuICogLSBcImNoaWxkTGlua0ZuXCIgLSAgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGFsbCBsaW5raW5nIGZucyBmb3IgY2hpbGQgbm9kZXMgb2YgYSBwYXJ0aWN1bGFyIG5vZGVcbiAqIC0gXCJjb21wb3NpdGVMaW5rRm5cIiAtIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhbGwgbGlua2luZyBmbnMgZm9yIGEgY29tcGlsYXRpb24gcm9vdCAobm9kZUxpc3QpXG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgbmcuJGNvbXBpbGVcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29tcGlsZXMgYSBwaWVjZSBvZiBIVE1MIHN0cmluZyBvciBET00gaW50byBhIHRlbXBsYXRlIGFuZCBwcm9kdWNlcyBhIHRlbXBsYXRlIGZ1bmN0aW9uLCB3aGljaFxuICogY2FuIHRoZW4gYmUgdXNlZCB0byBsaW5rIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIGBzY29wZWB9IGFuZCB0aGUgdGVtcGxhdGUgdG9nZXRoZXIuXG4gKlxuICogVGhlIGNvbXBpbGF0aW9uIGlzIGEgcHJvY2VzcyBvZiB3YWxraW5nIHRoZSBET00gdHJlZSBhbmQgbWF0Y2hpbmcgRE9NIGVsZW1lbnRzIHRvXG4gKiB7QGxpbmsgbmcuJGNvbXBpbGVQcm92aWRlciNtZXRob2RzX2RpcmVjdGl2ZSBkaXJlY3RpdmVzfS5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtd2FybmluZ1wiPlxuICogKipOb3RlOioqIFRoaXMgZG9jdW1lbnQgaXMgYW4gaW4tZGVwdGggcmVmZXJlbmNlIG9mIGFsbCBkaXJlY3RpdmUgb3B0aW9ucy5cbiAqIEZvciBhIGdlbnRsZSBpbnRyb2R1Y3Rpb24gdG8gZGlyZWN0aXZlcyB3aXRoIGV4YW1wbGVzIG9mIGNvbW1vbiB1c2UgY2FzZXMsXG4gKiBzZWUgdGhlIHtAbGluayBndWlkZS9kaXJlY3RpdmUgZGlyZWN0aXZlIGd1aWRlfS5cbiAqIDwvZGl2PlxuICpcbiAqICMjIENvbXByZWhlbnNpdmUgRGlyZWN0aXZlIEFQSVxuICpcbiAqIFRoZXJlIGFyZSBtYW55IGRpZmZlcmVudCBvcHRpb25zIGZvciBhIGRpcmVjdGl2ZS5cbiAqXG4gKiBUaGUgZGlmZmVyZW5jZSByZXNpZGVzIGluIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKiBZb3UgY2FuIGVpdGhlciByZXR1cm4gYSBcIkRpcmVjdGl2ZSBEZWZpbml0aW9uIE9iamVjdFwiIChzZWUgYmVsb3cpIHRoYXQgZGVmaW5lcyB0aGUgZGlyZWN0aXZlIHByb3BlcnRpZXMsXG4gKiBvciBqdXN0IHRoZSBgcG9zdExpbmtgIGZ1bmN0aW9uIChhbGwgb3RoZXIgcHJvcGVydGllcyB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgdmFsdWVzKS5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtc3VjY2Vzc1wiPlxuICogKipCZXN0IFByYWN0aWNlOioqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBcImRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFwiIGZvcm0uXG4gKiA8L2Rpdj5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBkaXJlY3RpdmUgZGVjbGFyZWQgd2l0aCBhIERpcmVjdGl2ZSBEZWZpbml0aW9uIE9iamVjdDpcbiAqXG4gKiA8cHJlPlxuICogICB2YXIgbXlNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSguLi4pO1xuICpcbiAqICAgbXlNb2R1bGUuZGlyZWN0aXZlKCdkaXJlY3RpdmVOYW1lJywgZnVuY3Rpb24gZmFjdG9yeShpbmplY3RhYmxlcykge1xuICogICAgIHZhciBkaXJlY3RpdmVEZWZpbml0aW9uT2JqZWN0ID0ge1xuICogICAgICAgcHJpb3JpdHk6IDAsXG4gKiAgICAgICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+JywgLy8gb3IgLy8gZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykgeyAuLi4gfSxcbiAqICAgICAgIC8vIG9yXG4gKiAgICAgICAvLyB0ZW1wbGF0ZVVybDogJ2RpcmVjdGl2ZS5odG1sJywgLy8gb3IgLy8gZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykgeyAuLi4gfSxcbiAqICAgICAgIHJlcGxhY2U6IGZhbHNlLFxuICogICAgICAgdHJhbnNjbHVkZTogZmFsc2UsXG4gKiAgICAgICByZXN0cmljdDogJ0EnLFxuICogICAgICAgc2NvcGU6IGZhbHNlLFxuICogICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkdHJhbnNjbHVkZSwgb3RoZXJJbmplY3RhYmxlcykgeyAuLi4gfSxcbiAqICAgICAgIHJlcXVpcmU6ICdzaWJsaW5nRGlyZWN0aXZlTmFtZScsIC8vIG9yIC8vIFsnXnBhcmVudERpcmVjdGl2ZU5hbWUnLCAnP29wdGlvbmFsRGlyZWN0aXZlTmFtZScsICc/Xm9wdGlvbmFsUGFyZW50J10sXG4gKiAgICAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRFbGVtZW50LCB0QXR0cnMsIHRyYW5zY2x1ZGUpIHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBwcmU6IGZ1bmN0aW9uIHByZUxpbmsoc2NvcGUsIGlFbGVtZW50LCBpQXR0cnMsIGNvbnRyb2xsZXIpIHsgLi4uIH0sXG4gKiAgICAgICAgICAgcG9zdDogZnVuY3Rpb24gcG9zdExpbmsoc2NvcGUsIGlFbGVtZW50LCBpQXR0cnMsIGNvbnRyb2xsZXIpIHsgLi4uIH1cbiAqICAgICAgICAgfVxuICogICAgICAgICAvLyBvclxuICogICAgICAgICAvLyByZXR1cm4gZnVuY3Rpb24gcG9zdExpbmsoIC4uLiApIHsgLi4uIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICAvLyBvclxuICogICAgICAgLy8gbGluazoge1xuICogICAgICAgLy8gIHByZTogZnVuY3Rpb24gcHJlTGluayhzY29wZSwgaUVsZW1lbnQsIGlBdHRycywgY29udHJvbGxlcikgeyAuLi4gfSxcbiAqICAgICAgIC8vICBwb3N0OiBmdW5jdGlvbiBwb3N0TGluayhzY29wZSwgaUVsZW1lbnQsIGlBdHRycywgY29udHJvbGxlcikgeyAuLi4gfVxuICogICAgICAgLy8gfVxuICogICAgICAgLy8gb3JcbiAqICAgICAgIC8vIGxpbms6IGZ1bmN0aW9uIHBvc3RMaW5rKCAuLi4gKSB7IC4uLiB9XG4gKiAgICAgfTtcbiAqICAgICByZXR1cm4gZGlyZWN0aXZlRGVmaW5pdGlvbk9iamVjdDtcbiAqICAgfSk7XG4gKiA8L3ByZT5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtd2FybmluZ1wiPlxuICogKipOb3RlOioqIEFueSB1bnNwZWNpZmllZCBvcHRpb25zIHdpbGwgdXNlIHRoZSBkZWZhdWx0IHZhbHVlLiBZb3UgY2FuIHNlZSB0aGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cuXG4gKiA8L2Rpdj5cbiAqXG4gKiBUaGVyZWZvcmUgdGhlIGFib3ZlIGNhbiBiZSBzaW1wbGlmaWVkIGFzOlxuICpcbiAqIDxwcmU+XG4gKiAgIHZhciBteU1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKC4uLik7XG4gKlxuICogICBteU1vZHVsZS5kaXJlY3RpdmUoJ2RpcmVjdGl2ZU5hbWUnLCBmdW5jdGlvbiBmYWN0b3J5KGluamVjdGFibGVzKSB7XG4gKiAgICAgdmFyIGRpcmVjdGl2ZURlZmluaXRpb25PYmplY3QgPSB7XG4gKiAgICAgICBsaW5rOiBmdW5jdGlvbiBwb3N0TGluayhzY29wZSwgaUVsZW1lbnQsIGlBdHRycykgeyAuLi4gfVxuICogICAgIH07XG4gKiAgICAgcmV0dXJuIGRpcmVjdGl2ZURlZmluaXRpb25PYmplY3Q7XG4gKiAgICAgLy8gb3JcbiAqICAgICAvLyByZXR1cm4gZnVuY3Rpb24gcG9zdExpbmsoc2NvcGUsIGlFbGVtZW50LCBpQXR0cnMpIHsgLi4uIH1cbiAqICAgfSk7XG4gKiA8L3ByZT5cbiAqXG4gKlxuICpcbiAqICMjIyBEaXJlY3RpdmUgRGVmaW5pdGlvbiBPYmplY3RcbiAqXG4gKiBUaGUgZGlyZWN0aXZlIGRlZmluaXRpb24gb2JqZWN0IHByb3ZpZGVzIGluc3RydWN0aW9ucyB0byB0aGUge0BsaW5rIGFwaS9uZy4kY29tcGlsZVxuICogY29tcGlsZXJ9LiBUaGUgYXR0cmlidXRlcyBhcmU6XG4gKlxuICogIyMjIyBgcHJpb3JpdHlgXG4gKiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBkaXJlY3RpdmVzIGRlZmluZWQgb24gYSBzaW5nbGUgRE9NIGVsZW1lbnQsIHNvbWV0aW1lcyBpdFxuICogaXMgbmVjZXNzYXJ5IHRvIHNwZWNpZnkgdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBkaXJlY3RpdmVzIGFyZSBhcHBsaWVkLiBUaGUgYHByaW9yaXR5YCBpcyB1c2VkXG4gKiB0byBzb3J0IHRoZSBkaXJlY3RpdmVzIGJlZm9yZSB0aGVpciBgY29tcGlsZWAgZnVuY3Rpb25zIGdldCBjYWxsZWQuIFByaW9yaXR5IGlzIGRlZmluZWQgYXMgYVxuICogbnVtYmVyLiBEaXJlY3RpdmVzIHdpdGggZ3JlYXRlciBudW1lcmljYWwgYHByaW9yaXR5YCBhcmUgY29tcGlsZWQgZmlyc3QuIFByZS1saW5rIGZ1bmN0aW9uc1xuICogYXJlIGFsc28gcnVuIGluIHByaW9yaXR5IG9yZGVyLCBidXQgcG9zdC1saW5rIGZ1bmN0aW9ucyBhcmUgcnVuIGluIHJldmVyc2Ugb3JkZXIuIFRoZSBvcmRlclxuICogb2YgZGlyZWN0aXZlcyB3aXRoIHRoZSBzYW1lIHByaW9yaXR5IGlzIHVuZGVmaW5lZC4gVGhlIGRlZmF1bHQgcHJpb3JpdHkgaXMgYDBgLlxuICpcbiAqICMjIyMgYHRlcm1pbmFsYFxuICogSWYgc2V0IHRvIHRydWUgdGhlbiB0aGUgY3VycmVudCBgcHJpb3JpdHlgIHdpbGwgYmUgdGhlIGxhc3Qgc2V0IG9mIGRpcmVjdGl2ZXNcbiAqIHdoaWNoIHdpbGwgZXhlY3V0ZSAoYW55IGRpcmVjdGl2ZXMgYXQgdGhlIGN1cnJlbnQgcHJpb3JpdHkgd2lsbCBzdGlsbCBleGVjdXRlXG4gKiBhcyB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uIG9uIHNhbWUgYHByaW9yaXR5YCBpcyB1bmRlZmluZWQpLlxuICpcbiAqICMjIyMgYHNjb3BlYFxuICogKipJZiBzZXQgdG8gYHRydWVgLCoqIHRoZW4gYSBuZXcgc2NvcGUgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGlzIGRpcmVjdGl2ZS4gSWYgbXVsdGlwbGUgZGlyZWN0aXZlcyBvbiB0aGVcbiAqIHNhbWUgZWxlbWVudCByZXF1ZXN0IGEgbmV3IHNjb3BlLCBvbmx5IG9uZSBuZXcgc2NvcGUgaXMgY3JlYXRlZC4gVGhlIG5ldyBzY29wZSBydWxlIGRvZXMgbm90XG4gKiBhcHBseSBmb3IgdGhlIHJvb3Qgb2YgdGhlIHRlbXBsYXRlIHNpbmNlIHRoZSByb290IG9mIHRoZSB0ZW1wbGF0ZSBhbHdheXMgZ2V0cyBhIG5ldyBzY29wZS5cbiAqXG4gKiAqKklmIHNldCB0byBge31gIChvYmplY3QgaGFzaCksKiogdGhlbiBhIG5ldyBcImlzb2xhdGVcIiBzY29wZSBpcyBjcmVhdGVkLiBUaGUgJ2lzb2xhdGUnIHNjb3BlIGRpZmZlcnMgZnJvbVxuICogbm9ybWFsIHNjb3BlIGluIHRoYXQgaXQgZG9lcyBub3QgcHJvdG90eXBpY2FsbHkgaW5oZXJpdCBmcm9tIHRoZSBwYXJlbnQgc2NvcGUuIFRoaXMgaXMgdXNlZnVsXG4gKiB3aGVuIGNyZWF0aW5nIHJldXNhYmxlIGNvbXBvbmVudHMsIHdoaWNoIHNob3VsZCBub3QgYWNjaWRlbnRhbGx5IHJlYWQgb3IgbW9kaWZ5IGRhdGEgaW4gdGhlXG4gKiBwYXJlbnQgc2NvcGUuXG4gKlxuICogVGhlICdpc29sYXRlJyBzY29wZSB0YWtlcyBhbiBvYmplY3QgaGFzaCB3aGljaCBkZWZpbmVzIGEgc2V0IG9mIGxvY2FsIHNjb3BlIHByb3BlcnRpZXNcbiAqIGRlcml2ZWQgZnJvbSB0aGUgcGFyZW50IHNjb3BlLiBUaGVzZSBsb2NhbCBwcm9wZXJ0aWVzIGFyZSB1c2VmdWwgZm9yIGFsaWFzaW5nIHZhbHVlcyBmb3JcbiAqIHRlbXBsYXRlcy4gTG9jYWxzIGRlZmluaXRpb24gaXMgYSBoYXNoIG9mIGxvY2FsIHNjb3BlIHByb3BlcnR5IHRvIGl0cyBzb3VyY2U6XG4gKlxuICogKiBgQGAgb3IgYEBhdHRyYCAtIGJpbmQgYSBsb2NhbCBzY29wZSBwcm9wZXJ0eSB0byB0aGUgdmFsdWUgb2YgRE9NIGF0dHJpYnV0ZS4gVGhlIHJlc3VsdCBpc1xuICogICBhbHdheXMgYSBzdHJpbmcgc2luY2UgRE9NIGF0dHJpYnV0ZXMgYXJlIHN0cmluZ3MuIElmIG5vIGBhdHRyYCBuYW1lIGlzIHNwZWNpZmllZCAgdGhlbiB0aGVcbiAqICAgYXR0cmlidXRlIG5hbWUgaXMgYXNzdW1lZCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgbG9jYWwgbmFtZS5cbiAqICAgR2l2ZW4gYDx3aWRnZXQgbXktYXR0cj1cImhlbGxvIHt7bmFtZX19XCI+YCBhbmQgd2lkZ2V0IGRlZmluaXRpb25cbiAqICAgb2YgYHNjb3BlOiB7IGxvY2FsTmFtZTonQG15QXR0cicgfWAsIHRoZW4gd2lkZ2V0IHNjb3BlIHByb3BlcnR5IGBsb2NhbE5hbWVgIHdpbGwgcmVmbGVjdFxuICogICB0aGUgaW50ZXJwb2xhdGVkIHZhbHVlIG9mIGBoZWxsbyB7e25hbWV9fWAuIEFzIHRoZSBgbmFtZWAgYXR0cmlidXRlIGNoYW5nZXMgc28gd2lsbCB0aGVcbiAqICAgYGxvY2FsTmFtZWAgcHJvcGVydHkgb24gdGhlIHdpZGdldCBzY29wZS4gVGhlIGBuYW1lYCBpcyByZWFkIGZyb20gdGhlIHBhcmVudCBzY29wZSAobm90XG4gKiAgIGNvbXBvbmVudCBzY29wZSkuXG4gKlxuICogKiBgPWAgb3IgYD1hdHRyYCAtIHNldCB1cCBiaS1kaXJlY3Rpb25hbCBiaW5kaW5nIGJldHdlZW4gYSBsb2NhbCBzY29wZSBwcm9wZXJ0eSBhbmQgdGhlXG4gKiAgIHBhcmVudCBzY29wZSBwcm9wZXJ0eSBvZiBuYW1lIGRlZmluZWQgdmlhIHRoZSB2YWx1ZSBvZiB0aGUgYGF0dHJgIGF0dHJpYnV0ZS4gSWYgbm8gYGF0dHJgXG4gKiAgIG5hbWUgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGxvY2FsIG5hbWUuXG4gKiAgIEdpdmVuIGA8d2lkZ2V0IG15LWF0dHI9XCJwYXJlbnRNb2RlbFwiPmAgYW5kIHdpZGdldCBkZWZpbml0aW9uIG9mXG4gKiAgIGBzY29wZTogeyBsb2NhbE1vZGVsOic9bXlBdHRyJyB9YCwgdGhlbiB3aWRnZXQgc2NvcGUgcHJvcGVydHkgYGxvY2FsTW9kZWxgIHdpbGwgcmVmbGVjdCB0aGVcbiAqICAgdmFsdWUgb2YgYHBhcmVudE1vZGVsYCBvbiB0aGUgcGFyZW50IHNjb3BlLiBBbnkgY2hhbmdlcyB0byBgcGFyZW50TW9kZWxgIHdpbGwgYmUgcmVmbGVjdGVkXG4gKiAgIGluIGBsb2NhbE1vZGVsYCBhbmQgYW55IGNoYW5nZXMgaW4gYGxvY2FsTW9kZWxgIHdpbGwgcmVmbGVjdCBpbiBgcGFyZW50TW9kZWxgLiBJZiB0aGUgcGFyZW50XG4gKiAgIHNjb3BlIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIGl0IHdpbGwgdGhyb3cgYSBOT05fQVNTSUdOQUJMRV9NT0RFTF9FWFBSRVNTSU9OIGV4Y2VwdGlvbi4gWW91XG4gKiAgIGNhbiBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzaW5nIGA9P2Agb3IgYD0/YXR0cmAgaW4gb3JkZXIgdG8gZmxhZyB0aGUgcHJvcGVydHkgYXMgb3B0aW9uYWwuXG4gKlxuICogKiBgJmAgb3IgYCZhdHRyYCAtIHByb3ZpZGVzIGEgd2F5IHRvIGV4ZWN1dGUgYW4gZXhwcmVzc2lvbiBpbiB0aGUgY29udGV4dCBvZiB0aGUgcGFyZW50IHNjb3BlLlxuICogICBJZiBubyBgYXR0cmAgbmFtZSBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgYXR0cmlidXRlIG5hbWUgaXMgYXNzdW1lZCB0byBiZSB0aGUgc2FtZSBhcyB0aGVcbiAqICAgbG9jYWwgbmFtZS4gR2l2ZW4gYDx3aWRnZXQgbXktYXR0cj1cImNvdW50ID0gY291bnQgKyB2YWx1ZVwiPmAgYW5kIHdpZGdldCBkZWZpbml0aW9uIG9mXG4gKiAgIGBzY29wZTogeyBsb2NhbEZuOicmbXlBdHRyJyB9YCwgdGhlbiBpc29sYXRlIHNjb3BlIHByb3BlcnR5IGBsb2NhbEZuYCB3aWxsIHBvaW50IHRvXG4gKiAgIGEgZnVuY3Rpb24gd3JhcHBlciBmb3IgdGhlIGBjb3VudCA9IGNvdW50ICsgdmFsdWVgIGV4cHJlc3Npb24uIE9mdGVuIGl0J3MgZGVzaXJhYmxlIHRvXG4gKiAgIHBhc3MgZGF0YSBmcm9tIHRoZSBpc29sYXRlZCBzY29wZSB2aWEgYW4gZXhwcmVzc2lvbiBhbmQgdG8gdGhlIHBhcmVudCBzY29wZSwgdGhpcyBjYW4gYmVcbiAqICAgZG9uZSBieSBwYXNzaW5nIGEgbWFwIG9mIGxvY2FsIHZhcmlhYmxlIG5hbWVzIGFuZCB2YWx1ZXMgaW50byB0aGUgZXhwcmVzc2lvbiB3cmFwcGVyIGZuLlxuICogICBGb3IgZXhhbXBsZSwgaWYgdGhlIGV4cHJlc3Npb24gaXMgYGluY3JlbWVudChhbW91bnQpYCB0aGVuIHdlIGNhbiBzcGVjaWZ5IHRoZSBhbW91bnQgdmFsdWVcbiAqICAgYnkgY2FsbGluZyB0aGUgYGxvY2FsRm5gIGFzIGBsb2NhbEZuKHthbW91bnQ6IDIyfSlgLlxuICpcbiAqXG4gKlxuICogIyMjIyBgY29udHJvbGxlcmBcbiAqIENvbnRyb2xsZXIgY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBiZWZvcmUgdGhlXG4gKiBwcmUtbGlua2luZyBwaGFzZSBhbmQgaXQgaXMgc2hhcmVkIHdpdGggb3RoZXIgZGlyZWN0aXZlcyAoc2VlXG4gKiBgcmVxdWlyZWAgYXR0cmlidXRlKS4gVGhpcyBhbGxvd3MgdGhlIGRpcmVjdGl2ZXMgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyIGFuZCBhdWdtZW50XG4gKiBlYWNoIG90aGVyJ3MgYmVoYXZpb3IuIFRoZSBjb250cm9sbGVyIGlzIGluamVjdGFibGUgKGFuZCBzdXBwb3J0cyBicmFja2V0IG5vdGF0aW9uKSB3aXRoIHRoZSBmb2xsb3dpbmcgbG9jYWxzOlxuICpcbiAqICogYCRzY29wZWAgLSBDdXJyZW50IHNjb3BlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogKiBgJGVsZW1lbnRgIC0gQ3VycmVudCBlbGVtZW50XG4gKiAqIGAkYXR0cnNgIC0gQ3VycmVudCBhdHRyaWJ1dGVzIG9iamVjdCBmb3IgdGhlIGVsZW1lbnRcbiAqICogYCR0cmFuc2NsdWRlYCAtIEEgdHJhbnNjbHVkZSBsaW5raW5nIGZ1bmN0aW9uIHByZS1ib3VuZCB0byB0aGUgY29ycmVjdCB0cmFuc2NsdXNpb24gc2NvcGUuXG4gKiAgICBUaGUgc2NvcGUgY2FuIGJlIG92ZXJyaWRkZW4gYnkgYW4gb3B0aW9uYWwgZmlyc3QgYXJndW1lbnQuXG4gKiAgIGBmdW5jdGlvbihbc2NvcGVdLCBjbG9uZUxpbmtpbmdGbilgLlxuICpcbiAqXG4gKiAjIyMjIGByZXF1aXJlYFxuICogUmVxdWlyZSBhbm90aGVyIGRpcmVjdGl2ZSBhbmQgaW5qZWN0IGl0cyBjb250cm9sbGVyIGFzIHRoZSBmb3VydGggYXJndW1lbnQgdG8gdGhlIGxpbmtpbmcgZnVuY3Rpb24uIFRoZVxuICogYHJlcXVpcmVgIHRha2VzIGEgc3RyaW5nIG5hbWUgKG9yIGFycmF5IG9mIHN0cmluZ3MpIG9mIHRoZSBkaXJlY3RpdmUocykgdG8gcGFzcyBpbi4gSWYgYW4gYXJyYXkgaXMgdXNlZCwgdGhlXG4gKiBpbmplY3RlZCBhcmd1bWVudCB3aWxsIGJlIGFuIGFycmF5IGluIGNvcnJlc3BvbmRpbmcgb3JkZXIuIElmIG5vIHN1Y2ggZGlyZWN0aXZlIGNhbiBiZVxuICogZm91bmQsIG9yIGlmIHRoZSBkaXJlY3RpdmUgZG9lcyBub3QgaGF2ZSBhIGNvbnRyb2xsZXIsIHRoZW4gYW4gZXJyb3IgaXMgcmFpc2VkLiBUaGUgbmFtZSBjYW4gYmUgcHJlZml4ZWQgd2l0aDpcbiAqXG4gKiAqIChubyBwcmVmaXgpIC0gTG9jYXRlIHRoZSByZXF1aXJlZCBjb250cm9sbGVyIG9uIHRoZSBjdXJyZW50IGVsZW1lbnQuIFRocm93IGFuIGVycm9yIGlmIG5vdCBmb3VuZC5cbiAqICogYD9gIC0gQXR0ZW1wdCB0byBsb2NhdGUgdGhlIHJlcXVpcmVkIGNvbnRyb2xsZXIgb3IgcGFzcyBgbnVsbGAgdG8gdGhlIGBsaW5rYCBmbiBpZiBub3QgZm91bmQuXG4gKiAqIGBeYCAtIExvY2F0ZSB0aGUgcmVxdWlyZWQgY29udHJvbGxlciBieSBzZWFyY2hpbmcgdGhlIGVsZW1lbnQncyBwYXJlbnRzLiBUaHJvdyBhbiBlcnJvciBpZiBub3QgZm91bmQuXG4gKiAqIGA/XmAgLSBBdHRlbXB0IHRvIGxvY2F0ZSB0aGUgcmVxdWlyZWQgY29udHJvbGxlciBieSBzZWFyY2hpbmcgdGhlIGVsZW1lbnQncyBwYXJlbnRzIG9yIHBhc3MgYG51bGxgIHRvIHRoZVxuICogICBgbGlua2AgZm4gaWYgbm90IGZvdW5kLlxuICpcbiAqXG4gKiAjIyMjIGBjb250cm9sbGVyQXNgXG4gKiBDb250cm9sbGVyIGFsaWFzIGF0IHRoZSBkaXJlY3RpdmUgc2NvcGUuIEFuIGFsaWFzIGZvciB0aGUgY29udHJvbGxlciBzbyBpdFxuICogY2FuIGJlIHJlZmVyZW5jZWQgYXQgdGhlIGRpcmVjdGl2ZSB0ZW1wbGF0ZS4gVGhlIGRpcmVjdGl2ZSBuZWVkcyB0byBkZWZpbmUgYSBzY29wZSBmb3IgdGhpc1xuICogY29uZmlndXJhdGlvbiB0byBiZSB1c2VkLiBVc2VmdWwgaW4gdGhlIGNhc2Ugd2hlbiBkaXJlY3RpdmUgaXMgdXNlZCBhcyBjb21wb25lbnQuXG4gKlxuICpcbiAqICMjIyMgYHJlc3RyaWN0YFxuICogU3RyaW5nIG9mIHN1YnNldCBvZiBgRUFDTWAgd2hpY2ggcmVzdHJpY3RzIHRoZSBkaXJlY3RpdmUgdG8gYSBzcGVjaWZpYyBkaXJlY3RpdmVcbiAqIGRlY2xhcmF0aW9uIHN0eWxlLiBJZiBvbWl0dGVkLCB0aGUgZGVmYXVsdCAoYXR0cmlidXRlcyBvbmx5KSBpcyB1c2VkLlxuICpcbiAqICogYEVgIC0gRWxlbWVudCBuYW1lOiBgPG15LWRpcmVjdGl2ZT48L215LWRpcmVjdGl2ZT5gXG4gKiAqIGBBYCAtIEF0dHJpYnV0ZSAoZGVmYXVsdCk6IGA8ZGl2IG15LWRpcmVjdGl2ZT1cImV4cFwiPjwvZGl2PmBcbiAqICogYENgIC0gQ2xhc3M6IGA8ZGl2IGNsYXNzPVwibXktZGlyZWN0aXZlOiBleHA7XCI+PC9kaXY+YFxuICogKiBgTWAgLSBDb21tZW50OiBgPCEtLSBkaXJlY3RpdmU6IG15LWRpcmVjdGl2ZSBleHAgLS0+YFxuICpcbiAqXG4gKiAjIyMjIGB0ZW1wbGF0ZWBcbiAqIHJlcGxhY2UgdGhlIGN1cnJlbnQgZWxlbWVudCB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgSFRNTC4gVGhlIHJlcGxhY2VtZW50IHByb2Nlc3NcbiAqIG1pZ3JhdGVzIGFsbCBvZiB0aGUgYXR0cmlidXRlcyAvIGNsYXNzZXMgZnJvbSB0aGUgb2xkIGVsZW1lbnQgdG8gdGhlIG5ldyBvbmUuIFNlZSB0aGVcbiAqIHtAbGluayBndWlkZS9kaXJlY3RpdmUjY3JlYXRpbmctY3VzdG9tLWRpcmVjdGl2ZXNfY3JlYXRpbmctZGlyZWN0aXZlc190ZW1wbGF0ZS1leHBhbmRpbmctZGlyZWN0aXZlXG4gKiBEaXJlY3RpdmVzIEd1aWRlfSBmb3IgYW4gZXhhbXBsZS5cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgYHRlbXBsYXRlYCBhcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRlbXBsYXRlIG9yIGFzIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXNcbiAqIHR3byBhcmd1bWVudHMgYHRFbGVtZW50YCBhbmQgYHRBdHRyc2AgKGRlc2NyaWJlZCBpbiB0aGUgYGNvbXBpbGVgIGZ1bmN0aW9uIGFwaSBiZWxvdykgYW5kXG4gKiByZXR1cm5zIGEgc3RyaW5nIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdGVtcGxhdGUuXG4gKlxuICpcbiAqICMjIyMgYHRlbXBsYXRlVXJsYFxuICogU2FtZSBhcyBgdGVtcGxhdGVgIGJ1dCB0aGUgdGVtcGxhdGUgaXMgbG9hZGVkIGZyb20gdGhlIHNwZWNpZmllZCBVUkwuIEJlY2F1c2VcbiAqIHRoZSB0ZW1wbGF0ZSBsb2FkaW5nIGlzIGFzeW5jaHJvbm91cyB0aGUgY29tcGlsYXRpb24vbGlua2luZyBpcyBzdXNwZW5kZWQgdW50aWwgdGhlIHRlbXBsYXRlXG4gKiBpcyBsb2FkZWQuXG4gKlxuICogWW91IGNhbiBzcGVjaWZ5IGB0ZW1wbGF0ZVVybGAgYXMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBVUkwgb3IgYXMgYSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0d29cbiAqIGFyZ3VtZW50cyBgdEVsZW1lbnRgIGFuZCBgdEF0dHJzYCAoZGVzY3JpYmVkIGluIHRoZSBgY29tcGlsZWAgZnVuY3Rpb24gYXBpIGJlbG93KSBhbmQgcmV0dXJuc1xuICogYSBzdHJpbmcgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB1cmwuICBJbiBlaXRoZXIgY2FzZSwgdGhlIHRlbXBsYXRlIFVSTCBpcyBwYXNzZWQgdGhyb3VnaCB7QGxpbmtcbiAqIGFwaS9uZy4kc2NlI21ldGhvZHNfZ2V0VHJ1c3RlZFJlc291cmNlVXJsICRzY2UuZ2V0VHJ1c3RlZFJlc291cmNlVXJsfS5cbiAqXG4gKlxuICogIyMjIyBgcmVwbGFjZWBcbiAqIHNwZWNpZnkgd2hlcmUgdGhlIHRlbXBsYXRlIHNob3VsZCBiZSBpbnNlcnRlZC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqXG4gKiAqIGB0cnVlYCAtIHRoZSB0ZW1wbGF0ZSB3aWxsIHJlcGxhY2UgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqICogYGZhbHNlYCAtIHRoZSB0ZW1wbGF0ZSB3aWxsIHJlcGxhY2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gKlxuICpcbiAqICMjIyMgYHRyYW5zY2x1ZGVgXG4gKiBjb21waWxlIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IGFuZCBtYWtlIGl0IGF2YWlsYWJsZSB0byB0aGUgZGlyZWN0aXZlLlxuICogVHlwaWNhbGx5IHVzZWQgd2l0aCB7QGxpbmsgYXBpL25nLmRpcmVjdGl2ZTpuZ1RyYW5zY2x1ZGVcbiAqIG5nVHJhbnNjbHVkZX0uIFRoZSBhZHZhbnRhZ2Ugb2YgdHJhbnNjbHVzaW9uIGlzIHRoYXQgdGhlIGxpbmtpbmcgZnVuY3Rpb24gcmVjZWl2ZXMgYVxuICogdHJhbnNjbHVzaW9uIGZ1bmN0aW9uIHdoaWNoIGlzIHByZS1ib3VuZCB0byB0aGUgY29ycmVjdCBzY29wZS4gSW4gYSB0eXBpY2FsIHNldHVwIHRoZSB3aWRnZXRcbiAqIGNyZWF0ZXMgYW4gYGlzb2xhdGVgIHNjb3BlLCBidXQgdGhlIHRyYW5zY2x1c2lvbiBpcyBub3QgYSBjaGlsZCwgYnV0IGEgc2libGluZyBvZiB0aGUgYGlzb2xhdGVgXG4gKiBzY29wZS4gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgdGhlIHdpZGdldCB0byBoYXZlIHByaXZhdGUgc3RhdGUsIGFuZCB0aGUgdHJhbnNjbHVzaW9uIHRvXG4gKiBiZSBib3VuZCB0byB0aGUgcGFyZW50IChwcmUtYGlzb2xhdGVgKSBzY29wZS5cbiAqXG4gKiAqIGB0cnVlYCAtIHRyYW5zY2x1ZGUgdGhlIGNvbnRlbnQgb2YgdGhlIGRpcmVjdGl2ZS5cbiAqICogYCdlbGVtZW50J2AgLSB0cmFuc2NsdWRlIHRoZSB3aG9sZSBlbGVtZW50IGluY2x1ZGluZyBhbnkgZGlyZWN0aXZlcyBkZWZpbmVkIGF0IGxvd2VyIHByaW9yaXR5LlxuICpcbiAqXG4gKiAjIyMjIGBjb21waWxlYFxuICpcbiAqIDxwcmU+XG4gKiAgIGZ1bmN0aW9uIGNvbXBpbGUodEVsZW1lbnQsIHRBdHRycywgdHJhbnNjbHVkZSkgeyAuLi4gfVxuICogPC9wcmU+XG4gKlxuICogVGhlIGNvbXBpbGUgZnVuY3Rpb24gZGVhbHMgd2l0aCB0cmFuc2Zvcm1pbmcgdGhlIHRlbXBsYXRlIERPTS4gU2luY2UgbW9zdCBkaXJlY3RpdmVzIGRvIG5vdCBkb1xuICogdGVtcGxhdGUgdHJhbnNmb3JtYXRpb24sIGl0IGlzIG5vdCB1c2VkIG9mdGVuLiBFeGFtcGxlcyB0aGF0IHJlcXVpcmUgY29tcGlsZSBmdW5jdGlvbnMgYXJlXG4gKiBkaXJlY3RpdmVzIHRoYXQgdHJhbnNmb3JtIHRlbXBsYXRlIERPTSwgc3VjaCBhcyB7QGxpbmtcbiAqIGFwaS9uZy5kaXJlY3RpdmU6bmdSZXBlYXQgbmdSZXBlYXR9LCBvciBsb2FkIHRoZSBjb250ZW50c1xuICogYXN5bmNocm9ub3VzbHksIHN1Y2ggYXMge0BsaW5rIGFwaS9uZ1JvdXRlLmRpcmVjdGl2ZTpuZ1ZpZXcgbmdWaWV3fS4gVGhlXG4gKiBjb21waWxlIGZ1bmN0aW9uIHRha2VzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzLlxuICpcbiAqICAgKiBgdEVsZW1lbnRgIC0gdGVtcGxhdGUgZWxlbWVudCAtIFRoZSBlbGVtZW50IHdoZXJlIHRoZSBkaXJlY3RpdmUgaGFzIGJlZW4gZGVjbGFyZWQuIEl0IGlzXG4gKiAgICAgc2FmZSB0byBkbyB0ZW1wbGF0ZSB0cmFuc2Zvcm1hdGlvbiBvbiB0aGUgZWxlbWVudCBhbmQgY2hpbGQgZWxlbWVudHMgb25seS5cbiAqXG4gKiAgICogYHRBdHRyc2AgLSB0ZW1wbGF0ZSBhdHRyaWJ1dGVzIC0gTm9ybWFsaXplZCBsaXN0IG9mIGF0dHJpYnV0ZXMgZGVjbGFyZWQgb24gdGhpcyBlbGVtZW50IHNoYXJlZFxuICogICAgIGJldHdlZW4gYWxsIGRpcmVjdGl2ZSBjb21waWxlIGZ1bmN0aW9ucy5cbiAqXG4gKiAgICogYHRyYW5zY2x1ZGVgIC0gIFsqREVQUkVDQVRFRCohXSBBIHRyYW5zY2x1ZGUgbGlua2luZyBmdW5jdGlvbjogYGZ1bmN0aW9uKHNjb3BlLCBjbG9uZUxpbmtpbmdGbilgXG4gKlxuICogPGRpdiBjbGFzcz1cImFsZXJ0IGFsZXJ0LXdhcm5pbmdcIj5cbiAqICoqTm90ZToqKiBUaGUgdGVtcGxhdGUgaW5zdGFuY2UgYW5kIHRoZSBsaW5rIGluc3RhbmNlIG1heSBiZSBkaWZmZXJlbnQgb2JqZWN0cyBpZiB0aGUgdGVtcGxhdGUgaGFzXG4gKiBiZWVuIGNsb25lZC4gRm9yIHRoaXMgcmVhc29uIGl0IGlzICoqbm90Kiogc2FmZSB0byBkbyBhbnl0aGluZyBvdGhlciB0aGFuIERPTSB0cmFuc2Zvcm1hdGlvbnMgdGhhdFxuICogYXBwbHkgdG8gYWxsIGNsb25lZCBET00gbm9kZXMgd2l0aGluIHRoZSBjb21waWxlIGZ1bmN0aW9uLiBTcGVjaWZpY2FsbHksIERPTSBsaXN0ZW5lciByZWdpc3RyYXRpb25cbiAqIHNob3VsZCBiZSBkb25lIGluIGEgbGlua2luZyBmdW5jdGlvbiByYXRoZXIgdGhhbiBpbiBhIGNvbXBpbGUgZnVuY3Rpb24uXG4gKiA8L2Rpdj5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtZXJyb3JcIj5cbiAqICoqTm90ZToqKiBUaGUgYHRyYW5zY2x1ZGVgIGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBjb21waWxlIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQsIGFzIGl0XG4gKiAgIGUuZy4gZG9lcyBub3Qga25vdyBhYm91dCB0aGUgcmlnaHQgb3V0ZXIgc2NvcGUuIFBsZWFzZSB1c2UgdGhlIHRyYW5zY2x1ZGUgZnVuY3Rpb24gdGhhdCBpcyBwYXNzZWRcbiAqICAgdG8gdGhlIGxpbmsgZnVuY3Rpb24gaW5zdGVhZC5cbiAqIDwvZGl2PlxuXG4gKiBBIGNvbXBpbGUgZnVuY3Rpb24gY2FuIGhhdmUgYSByZXR1cm4gdmFsdWUgd2hpY2ggY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdC5cbiAqXG4gKiAqIHJldHVybmluZyBhIChwb3N0LWxpbmspIGZ1bmN0aW9uIC0gaXMgZXF1aXZhbGVudCB0byByZWdpc3RlcmluZyB0aGUgbGlua2luZyBmdW5jdGlvbiB2aWEgdGhlXG4gKiAgIGBsaW5rYCBwcm9wZXJ0eSBvZiB0aGUgY29uZmlnIG9iamVjdCB3aGVuIHRoZSBjb21waWxlIGZ1bmN0aW9uIGlzIGVtcHR5LlxuICpcbiAqICogcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGZ1bmN0aW9uKHMpIHJlZ2lzdGVyZWQgdmlhIGBwcmVgIGFuZCBgcG9zdGAgcHJvcGVydGllcyAtIGFsbG93cyB5b3UgdG9cbiAqICAgY29udHJvbCB3aGVuIGEgbGlua2luZyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGR1cmluZyB0aGUgbGlua2luZyBwaGFzZS4gU2VlIGluZm8gYWJvdXRcbiAqICAgcHJlLWxpbmtpbmcgYW5kIHBvc3QtbGlua2luZyBmdW5jdGlvbnMgYmVsb3cuXG4gKlxuICpcbiAqICMjIyMgYGxpbmtgXG4gKiBUaGlzIHByb3BlcnR5IGlzIHVzZWQgb25seSBpZiB0aGUgYGNvbXBpbGVgIHByb3BlcnR5IGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIDxwcmU+XG4gKiAgIGZ1bmN0aW9uIGxpbmsoc2NvcGUsIGlFbGVtZW50LCBpQXR0cnMsIGNvbnRyb2xsZXIsIHRyYW5zY2x1ZGVGbikgeyAuLi4gfVxuICogPC9wcmU+XG4gKlxuICogVGhlIGxpbmsgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHJlZ2lzdGVyaW5nIERPTSBsaXN0ZW5lcnMgYXMgd2VsbCBhcyB1cGRhdGluZyB0aGUgRE9NLiBJdCBpc1xuICogZXhlY3V0ZWQgYWZ0ZXIgdGhlIHRlbXBsYXRlIGhhcyBiZWVuIGNsb25lZC4gVGhpcyBpcyB3aGVyZSBtb3N0IG9mIHRoZSBkaXJlY3RpdmUgbG9naWMgd2lsbCBiZVxuICogcHV0LlxuICpcbiAqICAgKiBgc2NvcGVgIC0ge0BsaW5rIGFwaS9uZy4kcm9vdFNjb3BlLlNjb3BlIFNjb3BlfSAtIFRoZSBzY29wZSB0byBiZSB1c2VkIGJ5IHRoZVxuICogICAgIGRpcmVjdGl2ZSBmb3IgcmVnaXN0ZXJpbmcge0BsaW5rIGFwaS9uZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJHdhdGNoIHdhdGNoZXN9LlxuICpcbiAqICAgKiBgaUVsZW1lbnRgIC0gaW5zdGFuY2UgZWxlbWVudCAtIFRoZSBlbGVtZW50IHdoZXJlIHRoZSBkaXJlY3RpdmUgaXMgdG8gYmUgdXNlZC4gSXQgaXMgc2FmZSB0b1xuICogICAgIG1hbmlwdWxhdGUgdGhlIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50IG9ubHkgaW4gYHBvc3RMaW5rYCBmdW5jdGlvbiBzaW5jZSB0aGUgY2hpbGRyZW4gaGF2ZVxuICogICAgIGFscmVhZHkgYmVlbiBsaW5rZWQuXG4gKlxuICogICAqIGBpQXR0cnNgIC0gaW5zdGFuY2UgYXR0cmlidXRlcyAtIE5vcm1hbGl6ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzIGRlY2xhcmVkIG9uIHRoaXMgZWxlbWVudCBzaGFyZWRcbiAqICAgICBiZXR3ZWVuIGFsbCBkaXJlY3RpdmUgbGlua2luZyBmdW5jdGlvbnMuXG4gKlxuICogICAqIGBjb250cm9sbGVyYCAtIGEgY29udHJvbGxlciBpbnN0YW5jZSAtIEEgY29udHJvbGxlciBpbnN0YW5jZSBpZiBhdCBsZWFzdCBvbmUgZGlyZWN0aXZlIG9uIHRoZVxuICogICAgIGVsZW1lbnQgZGVmaW5lcyBhIGNvbnRyb2xsZXIuIFRoZSBjb250cm9sbGVyIGlzIHNoYXJlZCBhbW9uZyBhbGwgdGhlIGRpcmVjdGl2ZXMsIHdoaWNoIGFsbG93c1xuICogICAgIHRoZSBkaXJlY3RpdmVzIHRvIHVzZSB0aGUgY29udHJvbGxlcnMgYXMgYSBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKlxuICogICAqIGB0cmFuc2NsdWRlRm5gIC0gQSB0cmFuc2NsdWRlIGxpbmtpbmcgZnVuY3Rpb24gcHJlLWJvdW5kIHRvIHRoZSBjb3JyZWN0IHRyYW5zY2x1c2lvbiBzY29wZS5cbiAqICAgICBUaGUgc2NvcGUgY2FuIGJlIG92ZXJyaWRkZW4gYnkgYW4gb3B0aW9uYWwgZmlyc3QgYXJndW1lbnQuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGAkdHJhbnNjbHVkZWBcbiAqICAgICBwYXJhbWV0ZXIgb2YgZGlyZWN0aXZlIGNvbnRyb2xsZXJzLlxuICogICAgIGBmdW5jdGlvbihbc2NvcGVdLCBjbG9uZUxpbmtpbmdGbilgLlxuICpcbiAqXG4gKiAjIyMjIFByZS1saW5raW5nIGZ1bmN0aW9uXG4gKlxuICogRXhlY3V0ZWQgYmVmb3JlIHRoZSBjaGlsZCBlbGVtZW50cyBhcmUgbGlua2VkLiBOb3Qgc2FmZSB0byBkbyBET00gdHJhbnNmb3JtYXRpb24gc2luY2UgdGhlXG4gKiBjb21waWxlciBsaW5raW5nIGZ1bmN0aW9uIHdpbGwgZmFpbCB0byBsb2NhdGUgdGhlIGNvcnJlY3QgZWxlbWVudHMgZm9yIGxpbmtpbmcuXG4gKlxuICogIyMjIyBQb3N0LWxpbmtpbmcgZnVuY3Rpb25cbiAqXG4gKiBFeGVjdXRlZCBhZnRlciB0aGUgY2hpbGQgZWxlbWVudHMgYXJlIGxpbmtlZC4gSXQgaXMgc2FmZSB0byBkbyBET00gdHJhbnNmb3JtYXRpb24gaW4gdGhlIHBvc3QtbGlua2luZyBmdW5jdGlvbi5cbiAqXG4gKiA8YSBuYW1lPVwiQXR0cmlidXRlc1wiPjwvYT5cbiAqICMjIyBBdHRyaWJ1dGVzXG4gKlxuICogVGhlIHtAbGluayBhcGkvbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXMgQXR0cmlidXRlc30gb2JqZWN0IC0gcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGluIHRoZVxuICogYGxpbmsoKWAgb3IgYGNvbXBpbGUoKWAgZnVuY3Rpb25zLiBJdCBoYXMgYSB2YXJpZXR5IG9mIHVzZXMuXG4gKlxuICogYWNjZXNzaW5nICpOb3JtYWxpemVkIGF0dHJpYnV0ZSBuYW1lczoqXG4gKiBEaXJlY3RpdmVzIGxpa2UgJ25nQmluZCcgY2FuIGJlIGV4cHJlc3NlZCBpbiBtYW55IHdheXM6ICduZzpiaW5kJywgYGRhdGEtbmctYmluZGAsIG9yICd4LW5nLWJpbmQnLlxuICogdGhlIGF0dHJpYnV0ZXMgb2JqZWN0IGFsbG93cyBmb3Igbm9ybWFsaXplZCBhY2Nlc3MgdG9cbiAqICAgdGhlIGF0dHJpYnV0ZXMuXG4gKlxuICogKiAqRGlyZWN0aXZlIGludGVyLWNvbW11bmljYXRpb246KiBBbGwgZGlyZWN0aXZlcyBzaGFyZSB0aGUgc2FtZSBpbnN0YW5jZSBvZiB0aGUgYXR0cmlidXRlc1xuICogICBvYmplY3Qgd2hpY2ggYWxsb3dzIHRoZSBkaXJlY3RpdmVzIHRvIHVzZSB0aGUgYXR0cmlidXRlcyBvYmplY3QgYXMgaW50ZXIgZGlyZWN0aXZlXG4gKiAgIGNvbW11bmljYXRpb24uXG4gKlxuICogKiAqU3VwcG9ydHMgaW50ZXJwb2xhdGlvbjoqIEludGVycG9sYXRpb24gYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgdG8gdGhlIGF0dHJpYnV0ZSBvYmplY3RcbiAqICAgYWxsb3dpbmcgb3RoZXIgZGlyZWN0aXZlcyB0byByZWFkIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKlxuICogKiAqT2JzZXJ2aW5nIGludGVycG9sYXRlZCBhdHRyaWJ1dGVzOiogVXNlIGAkb2JzZXJ2ZWAgdG8gb2JzZXJ2ZSB0aGUgdmFsdWUgY2hhbmdlcyBvZiBhdHRyaWJ1dGVzXG4gKiAgIHRoYXQgY29udGFpbiBpbnRlcnBvbGF0aW9uIChlLmcuIGBzcmM9XCJ7e2Jhcn19XCJgKS4gTm90IG9ubHkgaXMgdGhpcyB2ZXJ5IGVmZmljaWVudCBidXQgaXQncyBhbHNvXG4gKiAgIHRoZSBvbmx5IHdheSB0byBlYXNpbHkgZ2V0IHRoZSBhY3R1YWwgdmFsdWUgYmVjYXVzZSBkdXJpbmcgdGhlIGxpbmtpbmcgcGhhc2UgdGhlIGludGVycG9sYXRpb25cbiAqICAgaGFzbid0IGJlZW4gZXZhbHVhdGVkIHlldCBhbmQgc28gdGhlIHZhbHVlIGlzIGF0IHRoaXMgdGltZSBzZXQgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogPHByZT5cbiAqIGZ1bmN0aW9uIGxpbmtpbmdGbihzY29wZSwgZWxtLCBhdHRycywgY3RybCkge1xuICogICAvLyBnZXQgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICogICBjb25zb2xlLmxvZyhhdHRycy5uZ01vZGVsKTtcbiAqXG4gKiAgIC8vIGNoYW5nZSB0aGUgYXR0cmlidXRlXG4gKiAgIGF0dHJzLiRzZXQoJ25nTW9kZWwnLCAnbmV3IHZhbHVlJyk7XG4gKlxuICogICAvLyBvYnNlcnZlIGNoYW5nZXMgdG8gaW50ZXJwb2xhdGVkIGF0dHJpYnV0ZVxuICogICBhdHRycy4kb2JzZXJ2ZSgnbmdNb2RlbCcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ25nTW9kZWwgaGFzIGNoYW5nZWQgdmFsdWUgdG8gJyArIHZhbHVlKTtcbiAqICAgfSk7XG4gKiB9XG4gKiA8L3ByZT5cbiAqXG4gKiBCZWxvdyBpcyBhbiBleGFtcGxlIHVzaW5nIGAkY29tcGlsZVByb3ZpZGVyYC5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtd2FybmluZ1wiPlxuICogKipOb3RlKio6IFR5cGljYWxseSBkaXJlY3RpdmVzIGFyZSByZWdpc3RlcmVkIHdpdGggYG1vZHVsZS5kaXJlY3RpdmVgLiBUaGUgZXhhbXBsZSBiZWxvdyBpc1xuICogdG8gaWxsdXN0cmF0ZSBob3cgYCRjb21waWxlYCB3b3Jrcy5cbiAqIDwvZGl2PlxuICpcbiA8ZG9jOmV4YW1wbGUgbW9kdWxlPVwiY29tcGlsZVwiPlxuICAgPGRvYzpzb3VyY2U+XG4gICAgPHNjcmlwdD5cbiAgICAgIGFuZ3VsYXIubW9kdWxlKCdjb21waWxlJywgW10sIGZ1bmN0aW9uKCRjb21waWxlUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gY29uZmlndXJlIG5ldyAnY29tcGlsZScgZGlyZWN0aXZlIGJ5IHBhc3NpbmcgYSBkaXJlY3RpdmVcbiAgICAgICAgLy8gZmFjdG9yeSBmdW5jdGlvbi4gVGhlIGZhY3RvcnkgZnVuY3Rpb24gaW5qZWN0cyB0aGUgJyRjb21waWxlJ1xuICAgICAgICAkY29tcGlsZVByb3ZpZGVyLmRpcmVjdGl2ZSgnY29tcGlsZScsIGZ1bmN0aW9uKCRjb21waWxlKSB7XG4gICAgICAgICAgLy8gZGlyZWN0aXZlIGZhY3RvcnkgY3JlYXRlcyBhIGxpbmsgZnVuY3Rpb25cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICBzY29wZS4kd2F0Y2goXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgIC8vIHdhdGNoIHRoZSAnY29tcGlsZScgZXhwcmVzc2lvbiBmb3IgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS4kZXZhbChhdHRycy5jb21waWxlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSAnY29tcGlsZScgZXhwcmVzc2lvbiBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIGl0IGludG8gdGhlIGN1cnJlbnQgRE9NXG4gICAgICAgICAgICAgICAgZWxlbWVudC5odG1sKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGUgdGhlIG5ldyBET00gYW5kIGxpbmsgaXQgdG8gdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyBzY29wZS5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSBvbmx5IGNvbXBpbGUgLmNoaWxkTm9kZXMgc28gdGhhdFxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGdldCBpbnRvIGluZmluaXRlIGxvb3AgY29tcGlsaW5nIG91cnNlbHZlc1xuICAgICAgICAgICAgICAgICRjb21waWxlKGVsZW1lbnQuY29udGVudHMoKSkoc2NvcGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgJHNjb3BlLm5hbWUgPSAnQW5ndWxhcic7XG4gICAgICAgICRzY29wZS5odG1sID0gJ0hlbGxvIHt7bmFtZX19JztcbiAgICAgIH1cbiAgICA8L3NjcmlwdD5cbiAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgICA8aW5wdXQgbmctbW9kZWw9XCJuYW1lXCI+IDxicj5cbiAgICAgIDx0ZXh0YXJlYSBuZy1tb2RlbD1cImh0bWxcIj48L3RleHRhcmVhPiA8YnI+XG4gICAgICA8ZGl2IGNvbXBpbGU9XCJodG1sXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gICA8L2RvYzpzb3VyY2U+XG4gICA8ZG9jOnNjZW5hcmlvPlxuICAgICBpdCgnc2hvdWxkIGF1dG8gY29tcGlsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgIGV4cGVjdChlbGVtZW50KCdkaXZbY29tcGlsZV0nKS50ZXh0KCkpLnRvQmUoJ0hlbGxvIEFuZ3VsYXInKTtcbiAgICAgICBpbnB1dCgnaHRtbCcpLmVudGVyKCd7e25hbWV9fSEnKTtcbiAgICAgICBleHBlY3QoZWxlbWVudCgnZGl2W2NvbXBpbGVdJykudGV4dCgpKS50b0JlKCdBbmd1bGFyIScpO1xuICAgICB9KTtcbiAgIDwvZG9jOnNjZW5hcmlvPlxuIDwvZG9jOmV4YW1wbGU+XG5cbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IG9yIEhUTUwgc3RyaW5nIHRvIGNvbXBpbGUgaW50byBhIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihhbmd1bGFyLlNjb3BlWywgY2xvbmVBdHRhY2hGbl19IHRyYW5zY2x1ZGUgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGRpcmVjdGl2ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UHJpb3JpdHkgb25seSBhcHBseSBkaXJlY3RpdmVzIGxvd2VyIHRoZW4gZ2l2ZW4gcHJpb3JpdHkgKE9ubHkgZWZmZWN0cyB0aGVcbiAqICAgICAgICAgICAgICAgICByb290IGVsZW1lbnQocyksIG5vdCB0aGVpciBjaGlsZHJlbilcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzY29wZVssIGNsb25lQXR0YWNoRm5dKX0gYSBsaW5rIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgdG8gYmluZCB0ZW1wbGF0ZVxuICogKGEgRE9NIGVsZW1lbnQvdHJlZSkgdG8gYSBzY29wZS4gV2hlcmU6XG4gKlxuICogICogYHNjb3BlYCAtIEEge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUgU2NvcGV9IHRvIGJpbmQgdG8uXG4gKiAgKiBgY2xvbmVBdHRhY2hGbmAgLSBJZiBgY2xvbmVBdHRhY2hGbmAgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGxpbmsgZnVuY3Rpb24gd2lsbCBjbG9uZSB0aGVcbiAqICBgdGVtcGxhdGVgIGFuZCBjYWxsIHRoZSBgY2xvbmVBdHRhY2hGbmAgZnVuY3Rpb24gYWxsb3dpbmcgdGhlIGNhbGxlciB0byBhdHRhY2ggdGhlXG4gKiAgY2xvbmVkIGVsZW1lbnRzIHRvIHRoZSBET00gZG9jdW1lbnQgYXQgdGhlIGFwcHJvcHJpYXRlIHBsYWNlLiBUaGUgYGNsb25lQXR0YWNoRm5gIGlzXG4gKiAgY2FsbGVkIGFzOiA8YnI+IGBjbG9uZUF0dGFjaEZuKGNsb25lZEVsZW1lbnQsIHNjb3BlKWAgd2hlcmU6XG4gKlxuICogICAgICAqIGBjbG9uZWRFbGVtZW50YCAtIGlzIGEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGBlbGVtZW50YCBwYXNzZWQgaW50byB0aGUgY29tcGlsZXIuXG4gKiAgICAgICogYHNjb3BlYCAtIGlzIHRoZSBjdXJyZW50IHNjb3BlIHdpdGggd2hpY2ggdGhlIGxpbmtpbmcgZnVuY3Rpb24gaXMgd29ya2luZyB3aXRoLlxuICpcbiAqIENhbGxpbmcgdGhlIGxpbmtpbmcgZnVuY3Rpb24gcmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgdGVtcGxhdGUuIEl0IGlzIGVpdGhlciB0aGUgb3JpZ2luYWxcbiAqIGVsZW1lbnQgcGFzc2VkIGluLCBvciB0aGUgY2xvbmUgb2YgdGhlIGVsZW1lbnQgaWYgdGhlIGBjbG9uZUF0dGFjaEZuYCBpcyBwcm92aWRlZC5cbiAqXG4gKiBBZnRlciBsaW5raW5nIHRoZSB2aWV3IGlzIG5vdCB1cGRhdGVkIHVudGlsIGFmdGVyIGEgY2FsbCB0byAkZGlnZXN0IHdoaWNoIHR5cGljYWxseSBpcyBkb25lIGJ5XG4gKiBBbmd1bGFyIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogSWYgeW91IG5lZWQgYWNjZXNzIHRvIHRoZSBib3VuZCB2aWV3LCB0aGVyZSBhcmUgdHdvIHdheXMgdG8gZG8gaXQ6XG4gKlxuICogLSBJZiB5b3UgYXJlIG5vdCBhc2tpbmcgdGhlIGxpbmtpbmcgZnVuY3Rpb24gdG8gY2xvbmUgdGhlIHRlbXBsYXRlLCBjcmVhdGUgdGhlIERPTSBlbGVtZW50KHMpXG4gKiAgIGJlZm9yZSB5b3Ugc2VuZCB0aGVtIHRvIHRoZSBjb21waWxlciBhbmQga2VlcCB0aGlzIHJlZmVyZW5jZSBhcm91bmQuXG4gKiAgIDxwcmU+XG4gKiAgICAgdmFyIGVsZW1lbnQgPSAkY29tcGlsZSgnPHA+e3t0b3RhbH19PC9wPicpKHNjb3BlKTtcbiAqICAgPC9wcmU+XG4gKlxuICogLSBpZiBvbiB0aGUgb3RoZXIgaGFuZCwgeW91IG5lZWQgdGhlIGVsZW1lbnQgdG8gYmUgY2xvbmVkLCB0aGUgdmlldyByZWZlcmVuY2UgZnJvbSB0aGUgb3JpZ2luYWxcbiAqICAgZXhhbXBsZSB3b3VsZCBub3QgcG9pbnQgdG8gdGhlIGNsb25lLCBidXQgcmF0aGVyIHRvIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjbG9uZWQuIEluXG4gKiAgIHRoaXMgY2FzZSwgeW91IGNhbiBhY2Nlc3MgdGhlIGNsb25lIHZpYSB0aGUgY2xvbmVBdHRhY2hGbjpcbiAqICAgPHByZT5cbiAqICAgICB2YXIgdGVtcGxhdGVFbGVtZW50ID0gYW5ndWxhci5lbGVtZW50KCc8cD57e3RvdGFsfX08L3A+JyksXG4gKiAgICAgICAgIHNjb3BlID0gLi4uLjtcbiAqXG4gKiAgICAgdmFyIGNsb25lZEVsZW1lbnQgPSAkY29tcGlsZSh0ZW1wbGF0ZUVsZW1lbnQpKHNjb3BlLCBmdW5jdGlvbihjbG9uZWRFbGVtZW50LCBzY29wZSkge1xuICogICAgICAgLy9hdHRhY2ggdGhlIGNsb25lIHRvIERPTSBkb2N1bWVudCBhdCB0aGUgcmlnaHQgcGxhY2VcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy9ub3cgd2UgaGF2ZSByZWZlcmVuY2UgdG8gdGhlIGNsb25lZCBET00gdmlhIGBjbG9uZWRFbGVtZW50YFxuICogICA8L3ByZT5cbiAqXG4gKlxuICogRm9yIGluZm9ybWF0aW9uIG9uIGhvdyB0aGUgY29tcGlsZXIgd29ya3MsIHNlZSB0aGVcbiAqIHtAbGluayBndWlkZS9jb21waWxlciBBbmd1bGFyIEhUTUwgQ29tcGlsZXJ9IHNlY3Rpb24gb2YgdGhlIERldmVsb3BlciBHdWlkZS5cbiAqL1xuXG52YXIgJGNvbXBpbGVNaW5FcnIgPSBtaW5FcnIoJyRjb21waWxlJyk7XG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lIG5nLiRjb21waWxlUHJvdmlkZXJcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICovXG4kQ29tcGlsZVByb3ZpZGVyLiRpbmplY3QgPSBbJyRwcm92aWRlJywgJyQkc2FuaXRpemVVcmlQcm92aWRlciddO1xuZnVuY3Rpb24gJENvbXBpbGVQcm92aWRlcigkcHJvdmlkZSwgJCRzYW5pdGl6ZVVyaVByb3ZpZGVyKSB7XG4gIHZhciBoYXNEaXJlY3RpdmVzID0ge30sXG4gICAgICBTdWZmaXggPSAnRGlyZWN0aXZlJyxcbiAgICAgIENPTU1FTlRfRElSRUNUSVZFX1JFR0VYUCA9IC9eXFxzKmRpcmVjdGl2ZVxcOlxccyooW1xcZFxcd1xcLV9dKylcXHMrKC4qKSQvLFxuICAgICAgQ0xBU1NfRElSRUNUSVZFX1JFR0VYUCA9IC8oKFtcXGRcXHdcXC1fXSspKD86XFw6KFteO10rKSk/Oz8pLztcblxuICAvLyBSZWY6IGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvd2ViYXBwYXBpcy5odG1sI2V2ZW50LWhhbmRsZXItaWRsLWF0dHJpYnV0ZXNcbiAgLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBmdXR1cmUgRE9NIGV2ZW50IGF0dHJpYnV0ZSBuYW1lcyB3aWxsIGJlZ2luIHdpdGhcbiAgLy8gJ29uJyBhbmQgYmUgY29tcG9zZWQgb2Ygb25seSBFbmdsaXNoIGxldHRlcnMuXG4gIHZhciBFVkVOVF9IQU5ETEVSX0FUVFJfUkVHRVhQID0gL14ob25bYS16XSt8Zm9ybWFjdGlvbikkLztcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLiRjb21waWxlUHJvdmlkZXIjZGlyZWN0aXZlXG4gICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZVByb3ZpZGVyXG4gICAqIEBmdW5jdGlvblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVnaXN0ZXIgYSBuZXcgZGlyZWN0aXZlIHdpdGggdGhlIGNvbXBpbGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IG5hbWUgTmFtZSBvZiB0aGUgZGlyZWN0aXZlIGluIGNhbWVsLWNhc2UgKGkuZS4gPGNvZGU+bmdCaW5kPC9jb2RlPiB3aGljaFxuICAgKiAgICB3aWxsIG1hdGNoIGFzIDxjb2RlPm5nLWJpbmQ8L2NvZGU+KSwgb3IgYW4gb2JqZWN0IG1hcCBvZiBkaXJlY3RpdmVzIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGVcbiAgICogICAgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBmYWN0b3JpZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258QXJyYXl9IGRpcmVjdGl2ZUZhY3RvcnkgQW4gaW5qZWN0YWJsZSBkaXJlY3RpdmUgZmFjdG9yeSBmdW5jdGlvbi4gU2VlXG4gICAqICAgIHtAbGluayBndWlkZS9kaXJlY3RpdmV9IGZvciBtb3JlIGluZm8uXG4gICAqIEByZXR1cm5zIHtuZy4kY29tcGlsZVByb3ZpZGVyfSBTZWxmIGZvciBjaGFpbmluZy5cbiAgICovXG4gICB0aGlzLmRpcmVjdGl2ZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0aXZlKG5hbWUsIGRpcmVjdGl2ZUZhY3RvcnkpIHtcbiAgICBhc3NlcnROb3RIYXNPd25Qcm9wZXJ0eShuYW1lLCAnZGlyZWN0aXZlJyk7XG4gICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICBhc3NlcnRBcmcoZGlyZWN0aXZlRmFjdG9yeSwgJ2RpcmVjdGl2ZUZhY3RvcnknKTtcbiAgICAgIGlmICghaGFzRGlyZWN0aXZlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBoYXNEaXJlY3RpdmVzW25hbWVdID0gW107XG4gICAgICAgICRwcm92aWRlLmZhY3RvcnkobmFtZSArIFN1ZmZpeCwgWyckaW5qZWN0b3InLCAnJGV4Y2VwdGlvbkhhbmRsZXInLFxuICAgICAgICAgIGZ1bmN0aW9uKCRpbmplY3RvciwgJGV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gW107XG4gICAgICAgICAgICBmb3JFYWNoKGhhc0RpcmVjdGl2ZXNbbmFtZV0sIGZ1bmN0aW9uKGRpcmVjdGl2ZUZhY3RvcnksIGluZGV4KSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9ICRpbmplY3Rvci5pbnZva2UoZGlyZWN0aXZlRmFjdG9yeSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGlyZWN0aXZlKSkge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlID0geyBjb21waWxlOiB2YWx1ZUZuKGRpcmVjdGl2ZSkgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFkaXJlY3RpdmUuY29tcGlsZSAmJiBkaXJlY3RpdmUubGluaykge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBpbGUgPSB2YWx1ZUZuKGRpcmVjdGl2ZS5saW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLnByaW9yaXR5ID0gZGlyZWN0aXZlLnByaW9yaXR5IHx8IDA7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlLm5hbWUgPSBkaXJlY3RpdmUubmFtZSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5yZXF1aXJlID0gZGlyZWN0aXZlLnJlcXVpcmUgfHwgKGRpcmVjdGl2ZS5jb250cm9sbGVyICYmIGRpcmVjdGl2ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUucmVzdHJpY3QgPSBkaXJlY3RpdmUucmVzdHJpY3QgfHwgJ0EnO1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChkaXJlY3RpdmUpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXM7XG4gICAgICAgICAgfV0pO1xuICAgICAgfVxuICAgICAgaGFzRGlyZWN0aXZlc1tuYW1lXS5wdXNoKGRpcmVjdGl2ZUZhY3RvcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKG5hbWUsIHJldmVyc2VQYXJhbXMocmVnaXN0ZXJEaXJlY3RpdmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLiRjb21waWxlUHJvdmlkZXIjYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3RcbiAgICogQG1ldGhvZE9mIG5nLiRjb21waWxlUHJvdmlkZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgb3Igb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgZm9yIHdoaXRlbGlzdGluZyBvZiBzYWZlXG4gICAqIHVybHMgZHVyaW5nIGFbaHJlZl0gc2FuaXRpemF0aW9uLlxuICAgKlxuICAgKiBUaGUgc2FuaXRpemF0aW9uIGlzIGEgc2VjdXJpdHkgbWVhc3VyZSBhaW1lZCBhdCBwcmV2ZW50IFhTUyBhdHRhY2tzIHZpYSBodG1sIGxpbmtzLlxuICAgKlxuICAgKiBBbnkgdXJsIGFib3V0IHRvIGJlIGFzc2lnbmVkIHRvIGFbaHJlZl0gdmlhIGRhdGEtYmluZGluZyBpcyBmaXJzdCBub3JtYWxpemVkIGFuZCB0dXJuZWQgaW50b1xuICAgKiBhbiBhYnNvbHV0ZSB1cmwuIEFmdGVyd2FyZHMsIHRoZSB1cmwgaXMgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3RgXG4gICAqIHJlZ3VsYXIgZXhwcmVzc2lvbi4gSWYgYSBtYXRjaCBpcyBmb3VuZCwgdGhlIG9yaWdpbmFsIHVybCBpcyB3cml0dGVuIGludG8gdGhlIGRvbS4gT3RoZXJ3aXNlLFxuICAgKiB0aGUgYWJzb2x1dGUgdXJsIGlzIHByZWZpeGVkIHdpdGggYCd1bnNhZmU6J2Agc3RyaW5nIGFuZCBvbmx5IHRoZW4gaXMgaXQgd3JpdHRlbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwPX0gcmVnZXhwIE5ldyByZWdleHAgdG8gd2hpdGVsaXN0IHVybHMgd2l0aC5cbiAgICogQHJldHVybnMge1JlZ0V4cHxuZy4kY29tcGlsZVByb3ZpZGVyfSBDdXJyZW50IFJlZ0V4cCBpZiBjYWxsZWQgd2l0aG91dCB2YWx1ZSBvciBzZWxmIGZvclxuICAgKiAgICBjaGFpbmluZyBvdGhlcndpc2UuXG4gICAqL1xuICB0aGlzLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gZnVuY3Rpb24ocmVnZXhwKSB7XG4gICAgaWYgKGlzRGVmaW5lZChyZWdleHApKSB7XG4gICAgICAkJHNhbml0aXplVXJpUHJvdmlkZXIuYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QocmVnZXhwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJCRzYW5pdGl6ZVVyaVByb3ZpZGVyLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy4kY29tcGlsZVByb3ZpZGVyI2ltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdFxuICAgKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGVQcm92aWRlclxuICAgKiBAZnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHJpZXZlcyBvciBvdmVycmlkZXMgdGhlIGRlZmF1bHQgcmVndWxhciBleHByZXNzaW9uIHRoYXQgaXMgdXNlZCBmb3Igd2hpdGVsaXN0aW5nIG9mIHNhZmVcbiAgICogdXJscyBkdXJpbmcgaW1nW3NyY10gc2FuaXRpemF0aW9uLlxuICAgKlxuICAgKiBUaGUgc2FuaXRpemF0aW9uIGlzIGEgc2VjdXJpdHkgbWVhc3VyZSBhaW1lZCBhdCBwcmV2ZW50IFhTUyBhdHRhY2tzIHZpYSBodG1sIGxpbmtzLlxuICAgKlxuICAgKiBBbnkgdXJsIGFib3V0IHRvIGJlIGFzc2lnbmVkIHRvIGltZ1tzcmNdIHZpYSBkYXRhLWJpbmRpbmcgaXMgZmlyc3Qgbm9ybWFsaXplZCBhbmQgdHVybmVkIGludG9cbiAgICogYW4gYWJzb2x1dGUgdXJsLiBBZnRlcndhcmRzLCB0aGUgdXJsIGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgYGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdGBcbiAgICogcmVndWxhciBleHByZXNzaW9uLiBJZiBhIG1hdGNoIGlzIGZvdW5kLCB0aGUgb3JpZ2luYWwgdXJsIGlzIHdyaXR0ZW4gaW50byB0aGUgZG9tLiBPdGhlcndpc2UsXG4gICAqIHRoZSBhYnNvbHV0ZSB1cmwgaXMgcHJlZml4ZWQgd2l0aCBgJ3Vuc2FmZTonYCBzdHJpbmcgYW5kIG9ubHkgdGhlbiBpcyBpdCB3cml0dGVuIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHA9fSByZWdleHAgTmV3IHJlZ2V4cCB0byB3aGl0ZWxpc3QgdXJscyB3aXRoLlxuICAgKiBAcmV0dXJucyB7UmVnRXhwfG5nLiRjb21waWxlUHJvdmlkZXJ9IEN1cnJlbnQgUmVnRXhwIGlmIGNhbGxlZCB3aXRob3V0IHZhbHVlIG9yIHNlbGYgZm9yXG4gICAqICAgIGNoYWluaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIHRoaXMuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gZnVuY3Rpb24ocmVnZXhwKSB7XG4gICAgaWYgKGlzRGVmaW5lZChyZWdleHApKSB7XG4gICAgICAkJHNhbml0aXplVXJpUHJvdmlkZXIuaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0KHJlZ2V4cCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICQkc2FuaXRpemVVcmlQcm92aWRlci5pbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3QoKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy4kZ2V0ID0gW1xuICAgICAgICAgICAgJyRpbmplY3RvcicsICckaW50ZXJwb2xhdGUnLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCAnJGh0dHAnLCAnJHRlbXBsYXRlQ2FjaGUnLCAnJHBhcnNlJyxcbiAgICAgICAgICAgICckY29udHJvbGxlcicsICckcm9vdFNjb3BlJywgJyRkb2N1bWVudCcsICckc2NlJywgJyRhbmltYXRlJywgJyQkc2FuaXRpemVVcmknLFxuICAgIGZ1bmN0aW9uKCRpbmplY3RvciwgICAkaW50ZXJwb2xhdGUsICAgJGV4Y2VwdGlvbkhhbmRsZXIsICAgJGh0dHAsICAgJHRlbXBsYXRlQ2FjaGUsICAgJHBhcnNlLFxuICAgICAgICAgICAgICRjb250cm9sbGVyLCAgICRyb290U2NvcGUsICAgJGRvY3VtZW50LCAgICRzY2UsICAgJGFuaW1hdGUsICAgJCRzYW5pdGl6ZVVyaSkge1xuXG4gICAgdmFyIEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB0aGlzLiQkZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLiRhdHRyID0gYXR0ciB8fCB7fTtcbiAgICB9O1xuXG4gICAgQXR0cmlidXRlcy5wcm90b3R5cGUgPSB7XG4gICAgICAkbm9ybWFsaXplOiBkaXJlY3RpdmVOb3JtYWxpemUsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzIyRhZGRDbGFzc1xuICAgICAgICogQG1ldGhvZE9mIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIEFkZHMgdGhlIENTUyBjbGFzcyB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGNsYXNzVmFsIHBhcmFtZXRlciB0byB0aGUgZWxlbWVudC4gSWYgYW5pbWF0aW9uc1xuICAgICAgICogYXJlIGVuYWJsZWQgdGhlbiBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgZm9yIHRoZSBjbGFzcyBhZGRpdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NWYWwgVGhlIGNsYXNzTmFtZSB2YWx1ZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgJGFkZENsYXNzIDogZnVuY3Rpb24oY2xhc3NWYWwpIHtcbiAgICAgICAgaWYoY2xhc3NWYWwgJiYgY2xhc3NWYWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKHRoaXMuJCRlbGVtZW50LCBjbGFzc1ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkcmVtb3ZlQ2xhc3NcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlc1xuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZW1vdmVzIHRoZSBDU1MgY2xhc3MgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBjbGFzc1ZhbCBwYXJhbWV0ZXIgZnJvbSB0aGUgZWxlbWVudC4gSWZcbiAgICAgICAqIGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQgdGhlbiBhbiBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQgZm9yIHRoZSBjbGFzcyByZW1vdmFsLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1ZhbCBUaGUgY2xhc3NOYW1lIHZhbHVlIHRoYXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgJHJlbW92ZUNsYXNzIDogZnVuY3Rpb24oY2xhc3NWYWwpIHtcbiAgICAgICAgaWYoY2xhc3NWYWwgJiYgY2xhc3NWYWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKHRoaXMuJCRlbGVtZW50LCBjbGFzc1ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkdXBkYXRlQ2xhc3NcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlc1xuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBBZGRzIGFuZCByZW1vdmVzIHRoZSBhcHByb3ByaWF0ZSBDU1MgY2xhc3MgdmFsdWVzIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBkaWZmZXJlbmNlXG4gICAgICAgKiBiZXR3ZWVuIHRoZSBuZXcgYW5kIG9sZCBDU1MgY2xhc3MgdmFsdWVzIChzcGVjaWZpZWQgYXMgbmV3Q2xhc3NlcyBhbmQgb2xkQ2xhc3NlcykuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0NsYXNzZXMgVGhlIGN1cnJlbnQgQ1NTIGNsYXNzTmFtZSB2YWx1ZVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZENsYXNzZXMgVGhlIGZvcm1lciBDU1MgY2xhc3NOYW1lIHZhbHVlXG4gICAgICAgKi9cbiAgICAgICR1cGRhdGVDbGFzcyA6IGZ1bmN0aW9uKG5ld0NsYXNzZXMsIG9sZENsYXNzZXMpIHtcbiAgICAgICAgdGhpcy4kcmVtb3ZlQ2xhc3ModG9rZW5EaWZmZXJlbmNlKG9sZENsYXNzZXMsIG5ld0NsYXNzZXMpKTtcbiAgICAgICAgdGhpcy4kYWRkQ2xhc3ModG9rZW5EaWZmZXJlbmNlKG5ld0NsYXNzZXMsIG9sZENsYXNzZXMpKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgbm9ybWFsaXplZCBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgaW4gYSB3YXkgc3VjaCB0aGF0IGFsbCBkaXJlY3RpdmVzXG4gICAgICAgKiBjYW4gc2hhcmUgdGhlIGF0dHJpYnV0ZS4gVGhpcyBmdW5jdGlvbiBwcm9wZXJseSBoYW5kbGVzIGJvb2xlYW4gYXR0cmlidXRlcy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgTm9ybWFsaXplZCBrZXkuIChpZSBuZ0F0dHJpYnV0ZSlcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuIElmIGBudWxsYCBhdHRyaWJ1dGUgd2lsbCBiZSBkZWxldGVkLlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gd3JpdGVBdHRyIElmIGZhbHNlLCBkb2VzIG5vdCB3cml0ZSB0aGUgdmFsdWUgdG8gRE9NIGVsZW1lbnQgYXR0cmlidXRlLlxuICAgICAgICogICAgIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZz19IGF0dHJOYW1lIE9wdGlvbmFsIG5vbmUgbm9ybWFsaXplZCBuYW1lLiBEZWZhdWx0cyB0byBrZXkuXG4gICAgICAgKi9cbiAgICAgICRzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIHdyaXRlQXR0ciwgYXR0ck5hbWUpIHtcbiAgICAgICAgLy8gVE9ETzogZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGVycm9yIGlmIFwiY2xhc3NcIlxuICAgICAgICAvL2lzIHNldCB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgbWF5IGNhdXNlICR1cGRhdGVDbGFzcyB0b1xuICAgICAgICAvL2JlY29tZSB1bnN0YWJsZS5cblxuICAgICAgICB2YXIgYm9vbGVhbktleSA9IGdldEJvb2xlYW5BdHRyTmFtZSh0aGlzLiQkZWxlbWVudFswXSwga2V5KSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWwsXG4gICAgICAgICAgICBub2RlTmFtZTtcblxuICAgICAgICBpZiAoYm9vbGVhbktleSkge1xuICAgICAgICAgIHRoaXMuJCRlbGVtZW50LnByb3Aoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgYXR0ck5hbWUgPSBib29sZWFuS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIG5vcm1hbGl6ZWQga2V5IHRvIGFjdHVhbCBrZXlcbiAgICAgICAgaWYgKGF0dHJOYW1lKSB7XG4gICAgICAgICAgdGhpcy4kYXR0cltrZXldID0gYXR0ck5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0ck5hbWUgPSB0aGlzLiRhdHRyW2tleV07XG4gICAgICAgICAgaWYgKCFhdHRyTmFtZSkge1xuICAgICAgICAgICAgdGhpcy4kYXR0cltrZXldID0gYXR0ck5hbWUgPSBzbmFrZV9jYXNlKGtleSwgJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlTmFtZSA9IG5vZGVOYW1lXyh0aGlzLiQkZWxlbWVudCk7XG5cbiAgICAgICAgLy8gc2FuaXRpemUgYVtocmVmXSBhbmQgaW1nW3NyY10gdmFsdWVzXG4gICAgICAgIGlmICgobm9kZU5hbWUgPT09ICdBJyAmJiBrZXkgPT09ICdocmVmJykgfHxcbiAgICAgICAgICAgIChub2RlTmFtZSA9PT0gJ0lNRycgJiYga2V5ID09PSAnc3JjJykpIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZSA9ICQkc2FuaXRpemVVcmkodmFsdWUsIGtleSA9PT0gJ3NyYycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdyaXRlQXR0ciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy4kJGVsZW1lbnQucmVtb3ZlQXR0cihhdHRyTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJCRlbGVtZW50LmF0dHIoYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJlIG9ic2VydmVyc1xuICAgICAgICB2YXIgJCRvYnNlcnZlcnMgPSB0aGlzLiQkb2JzZXJ2ZXJzO1xuICAgICAgICAkJG9ic2VydmVycyAmJiBmb3JFYWNoKCQkb2JzZXJ2ZXJzW2tleV0sIGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXMjJG9ic2VydmVcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlc1xuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBPYnNlcnZlcyBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBvYnNlcnZlciBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBkdXJpbmcgdGhlIG5leHQgYCRkaWdlc3RgIGZvbGxvd2luZ1xuICAgICAgICogY29tcGlsYXRpb24uIFRoZSBvYnNlcnZlciBpcyB0aGVuIGludm9rZWQgd2hlbmV2ZXIgdGhlIGludGVycG9sYXRlZCB2YWx1ZVxuICAgICAgICogY2hhbmdlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IE5vcm1hbGl6ZWQga2V5LiAoaWUgbmdBdHRyaWJ1dGUpIC5cbiAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW50ZXJwb2xhdGVkVmFsdWUpfSBmbiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyXG4gICAgICAgICAgICAgICAgdGhlIGludGVycG9sYXRlZCB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgKiAgICAgICAgU2VlIHRoZSB7QGxpbmsgZ3VpZGUvZGlyZWN0aXZlI0F0dHJpYnV0ZXMgRGlyZWN0aXZlc30gZ3VpZGUgZm9yIG1vcmUgaW5mby5cbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSB0aGUgYGZuYCBwYXJhbWV0ZXIuXG4gICAgICAgKi9cbiAgICAgICRvYnNlcnZlOiBmdW5jdGlvbihrZXksIGZuKSB7XG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMsXG4gICAgICAgICAgICAkJG9ic2VydmVycyA9IChhdHRycy4kJG9ic2VydmVycyB8fCAoYXR0cnMuJCRvYnNlcnZlcnMgPSB7fSkpLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gKCQkb2JzZXJ2ZXJzW2tleV0gfHwgKCQkb2JzZXJ2ZXJzW2tleV0gPSBbXSkpO1xuXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgICAgICAgJHJvb3RTY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghbGlzdGVuZXJzLiQkaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIG5vIG9uZSByZWdpc3RlcmVkIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIGZ1bmN0aW9uLCBzbyBsZXRzIGNhbGwgaXQgbWFudWFsbHlcbiAgICAgICAgICAgIGZuKGF0dHJzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXJ0U3ltYm9sID0gJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sKCksXG4gICAgICAgIGVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKSxcbiAgICAgICAgZGVub3JtYWxpemVUZW1wbGF0ZSA9IChzdGFydFN5bWJvbCA9PSAne3snIHx8IGVuZFN5bWJvbCAgPT0gJ319JylcbiAgICAgICAgICAgID8gaWRlbnRpdHlcbiAgICAgICAgICAgIDogZnVuY3Rpb24gZGVub3JtYWxpemVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgvXFx7XFx7L2csIHN0YXJ0U3ltYm9sKS5yZXBsYWNlKC99fS9nLCBlbmRTeW1ib2wpO1xuICAgICAgICB9LFxuICAgICAgICBOR19BVFRSX0JJTkRJTkcgPSAvXm5nQXR0cltBLVpdLztcblxuXG4gICAgcmV0dXJuIGNvbXBpbGU7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBmdW5jdGlvbiBjb21waWxlKCRjb21waWxlTm9kZXMsIHRyYW5zY2x1ZGVGbiwgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29tcGlsZUNvbnRleHQpIHtcbiAgICAgIGlmICghKCRjb21waWxlTm9kZXMgaW5zdGFuY2VvZiBqcUxpdGUpKSB7XG4gICAgICAgIC8vIGpxdWVyeSBhbHdheXMgcmV3cmFwcywgd2hlcmVhcyB3ZSBuZWVkIHRvIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzZWxlY3RvciBzbyB0aGF0IHdlIGNhblxuICAgICAgICAvLyBtb2RpZnkgaXQuXG4gICAgICAgICRjb21waWxlTm9kZXMgPSBqcUxpdGUoJGNvbXBpbGVOb2Rlcyk7XG4gICAgICB9XG4gICAgICAvLyBXZSBjYW4gbm90IGNvbXBpbGUgdG9wIGxldmVsIHRleHQgZWxlbWVudHMgc2luY2UgdGV4dCBub2RlcyBjYW4gYmUgbWVyZ2VkIGFuZCB3ZSB3aWxsXG4gICAgICAvLyBub3QgYmUgYWJsZSB0byBhdHRhY2ggc2NvcGUgZGF0YSB0byB0aGVtLCBzbyB3ZSB3aWxsIHdyYXAgdGhlbSBpbiA8c3Bhbj5cbiAgICAgIGZvckVhY2goJGNvbXBpbGVOb2RlcywgZnVuY3Rpb24obm9kZSwgaW5kZXgpe1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzIC8qIHRleHQgbm9kZSAqLyAmJiBub2RlLm5vZGVWYWx1ZS5tYXRjaCgvXFxTKy8pIC8qIG5vbi1lbXB0eSAqLyApIHtcbiAgICAgICAgICAkY29tcGlsZU5vZGVzW2luZGV4XSA9IG5vZGUgPSBqcUxpdGUobm9kZSkud3JhcCgnPHNwYW4+PC9zcGFuPicpLnBhcmVudCgpWzBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBjb21wb3NpdGVMaW5rRm4gPVxuICAgICAgICAgICAgICBjb21waWxlTm9kZXMoJGNvbXBpbGVOb2RlcywgdHJhbnNjbHVkZUZuLCAkY29tcGlsZU5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSwgcHJldmlvdXNDb21waWxlQ29udGV4dCk7XG4gICAgICBzYWZlQWRkQ2xhc3MoJGNvbXBpbGVOb2RlcywgJ25nLXNjb3BlJyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcHVibGljTGlua0ZuKHNjb3BlLCBjbG9uZUNvbm5lY3RGbiwgdHJhbnNjbHVkZUNvbnRyb2xsZXJzKXtcbiAgICAgICAgYXNzZXJ0QXJnKHNjb3BlLCAnc2NvcGUnKTtcbiAgICAgICAgLy8gaW1wb3J0YW50ISE6IHdlIG11c3QgY2FsbCBvdXIganFMaXRlLmNsb25lKCkgc2luY2UgdGhlIGpRdWVyeSBvbmUgaXMgdHJ5aW5nIHRvIGJlIHNtYXJ0XG4gICAgICAgIC8vIGFuZCBzb21ldGltZXMgY2hhbmdlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBET00uXG4gICAgICAgIHZhciAkbGlua05vZGUgPSBjbG9uZUNvbm5lY3RGblxuICAgICAgICAgID8gSlFMaXRlUHJvdG90eXBlLmNsb25lLmNhbGwoJGNvbXBpbGVOb2RlcykgLy8gSU1QT1JUQU5UISEhXG4gICAgICAgICAgOiAkY29tcGlsZU5vZGVzO1xuXG4gICAgICAgIGZvckVhY2godHJhbnNjbHVkZUNvbnRyb2xsZXJzLCBmdW5jdGlvbihpbnN0YW5jZSwgbmFtZSkge1xuICAgICAgICAgICRsaW5rTm9kZS5kYXRhKCckJyArIG5hbWUgKyAnQ29udHJvbGxlcicsIGluc3RhbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXR0YWNoIHNjb3BlIG9ubHkgdG8gbm9uLXRleHQgbm9kZXMuXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGlpID0gJGxpbmtOb2RlLmxlbmd0aDsgaTxpaTsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSAkbGlua05vZGVbaV0sXG4gICAgICAgICAgICAgIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcbiAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgLyogZWxlbWVudCAqLyB8fCBub2RlVHlwZSA9PT0gOSAvKiBkb2N1bWVudCAqLykge1xuICAgICAgICAgICAgJGxpbmtOb2RlLmVxKGkpLmRhdGEoJyRzY29wZScsIHNjb3BlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvbmVDb25uZWN0Rm4pIGNsb25lQ29ubmVjdEZuKCRsaW5rTm9kZSwgc2NvcGUpO1xuICAgICAgICBpZiAoY29tcG9zaXRlTGlua0ZuKSBjb21wb3NpdGVMaW5rRm4oc2NvcGUsICRsaW5rTm9kZSwgJGxpbmtOb2RlKTtcbiAgICAgICAgcmV0dXJuICRsaW5rTm9kZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2FmZUFkZENsYXNzKCRlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICRlbGVtZW50LmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLy8gaWdub3JlLCBzaW5jZSBpdCBtZWFucyB0aGF0IHdlIGFyZSB0cnlpbmcgdG8gc2V0IGNsYXNzIG9uXG4gICAgICAgIC8vIFNWRyBlbGVtZW50LCB3aGVyZSBjbGFzcyBuYW1lIGlzIHJlYWQtb25seS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21waWxlIGZ1bmN0aW9uIG1hdGNoZXMgZWFjaCBub2RlIGluIG5vZGVMaXN0IGFnYWluc3QgdGhlIGRpcmVjdGl2ZXMuIE9uY2UgYWxsIGRpcmVjdGl2ZXNcbiAgICAgKiBmb3IgYSBwYXJ0aWN1bGFyIG5vZGUgYXJlIGNvbGxlY3RlZCB0aGVpciBjb21waWxlIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQuIFRoZSBjb21waWxlXG4gICAgICogZnVuY3Rpb25zIHJldHVybiB2YWx1ZXMgLSB0aGUgbGlua2luZyBmdW5jdGlvbnMgLSBhcmUgY29tYmluZWQgaW50byBhIGNvbXBvc2l0ZSBsaW5raW5nXG4gICAgICogZnVuY3Rpb24sIHdoaWNoIGlzIHRoZSBhIGxpbmtpbmcgZnVuY3Rpb24gZm9yIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZUxpc3QgYW4gYXJyYXkgb2Ygbm9kZXMgb3IgTm9kZUxpc3QgdG8gY29tcGlsZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oYW5ndWxhci5TY29wZVssIGNsb25lQXR0YWNoRm5dfSB0cmFuc2NsdWRlRm4gQSBsaW5raW5nIGZ1bmN0aW9uLCB3aGVyZSB0aGVcbiAgICAgKiAgICAgICAgc2NvcGUgYXJndW1lbnQgaXMgYXV0by1nZW5lcmF0ZWQgdG8gdGhlIG5ldyBjaGlsZCBvZiB0aGUgdHJhbnNjbHVkZWQgcGFyZW50IHNjb3BlLlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudD19ICRyb290RWxlbWVudCBJZiB0aGUgbm9kZUxpc3QgaXMgdGhlIHJvb3Qgb2YgdGhlIGNvbXBpbGF0aW9uIHRyZWUgdGhlblxuICAgICAqICAgICAgICB0aGUgcm9vdEVsZW1lbnQgbXVzdCBiZSBzZXQgdGhlIGpxTGl0ZSBjb2xsZWN0aW9uIG9mIHRoZSBjb21waWxlIHJvb3QuIFRoaXMgaXNcbiAgICAgKiAgICAgICAgbmVlZGVkIHNvIHRoYXQgdGhlIGpxTGl0ZSBjb2xsZWN0aW9uIGl0ZW1zIGNhbiBiZSByZXBsYWNlZCB3aXRoIHdpZGdldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBtYXhQcmlvcml0eSBNYXggZGlyZWN0aXZlIHByaW9yaXR5LlxuICAgICAqIEByZXR1cm5zIHs/ZnVuY3Rpb259IEEgY29tcG9zaXRlIGxpbmtpbmcgZnVuY3Rpb24gb2YgYWxsIG9mIHRoZSBtYXRjaGVkIGRpcmVjdGl2ZXMgb3IgbnVsbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21waWxlTm9kZXMobm9kZUxpc3QsIHRyYW5zY2x1ZGVGbiwgJHJvb3RFbGVtZW50LCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29tcGlsZUNvbnRleHQpIHtcbiAgICAgIHZhciBsaW5rRm5zID0gW10sXG4gICAgICAgICAgYXR0cnMsIGRpcmVjdGl2ZXMsIG5vZGVMaW5rRm4sIGNoaWxkTm9kZXMsIGNoaWxkTGlua0ZuLCBsaW5rRm5Gb3VuZDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhdHRycyA9IG5ldyBBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgLy8gd2UgbXVzdCBhbHdheXMgcmVmZXIgdG8gbm9kZUxpc3RbaV0gc2luY2UgdGhlIG5vZGVzIGNhbiBiZSByZXBsYWNlZCB1bmRlcm5lYXRoIHVzLlxuICAgICAgICBkaXJlY3RpdmVzID0gY29sbGVjdERpcmVjdGl2ZXMobm9kZUxpc3RbaV0sIFtdLCBhdHRycywgaSA9PT0gMCA/IG1heFByaW9yaXR5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZURpcmVjdGl2ZSk7XG5cbiAgICAgICAgbm9kZUxpbmtGbiA9IChkaXJlY3RpdmVzLmxlbmd0aClcbiAgICAgICAgICAgID8gYXBwbHlEaXJlY3RpdmVzVG9Ob2RlKGRpcmVjdGl2ZXMsIG5vZGVMaXN0W2ldLCBhdHRycywgdHJhbnNjbHVkZUZuLCAkcm9vdEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIFtdLCBbXSwgcHJldmlvdXNDb21waWxlQ29udGV4dClcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICBpZiAobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnNjb3BlKSB7XG4gICAgICAgICAgc2FmZUFkZENsYXNzKGpxTGl0ZShub2RlTGlzdFtpXSksICduZy1zY29wZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRMaW5rRm4gPSAobm9kZUxpbmtGbiAmJiBub2RlTGlua0ZuLnRlcm1pbmFsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIShjaGlsZE5vZGVzID0gbm9kZUxpc3RbaV0uY2hpbGROb2RlcykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAhY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogY29tcGlsZU5vZGVzKGNoaWxkTm9kZXMsXG4gICAgICAgICAgICAgICAgIG5vZGVMaW5rRm4gPyBub2RlTGlua0ZuLnRyYW5zY2x1ZGUgOiB0cmFuc2NsdWRlRm4pO1xuXG4gICAgICAgIGxpbmtGbnMucHVzaChub2RlTGlua0ZuLCBjaGlsZExpbmtGbik7XG4gICAgICAgIGxpbmtGbkZvdW5kID0gbGlua0ZuRm91bmQgfHwgbm9kZUxpbmtGbiB8fCBjaGlsZExpbmtGbjtcbiAgICAgICAgLy91c2UgdGhlIHByZXZpb3VzIGNvbnRleHQgb25seSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHZpcnR1YWwgZ3JvdXBcbiAgICAgICAgcHJldmlvdXNDb21waWxlQ29udGV4dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybiBhIGxpbmtpbmcgZnVuY3Rpb24gaWYgd2UgaGF2ZSBmb3VuZCBhbnl0aGluZywgbnVsbCBvdGhlcndpc2VcbiAgICAgIHJldHVybiBsaW5rRm5Gb3VuZCA/IGNvbXBvc2l0ZUxpbmtGbiA6IG51bGw7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBvc2l0ZUxpbmtGbihzY29wZSwgbm9kZUxpc3QsICRyb290RWxlbWVudCwgYm91bmRUcmFuc2NsdWRlRm4pIHtcbiAgICAgICAgdmFyIG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuLCBub2RlLCAkbm9kZSwgY2hpbGRTY29wZSwgY2hpbGRUcmFuc2NsdWRlRm4sIGksIGlpLCBuO1xuXG4gICAgICAgIC8vIGNvcHkgbm9kZUxpc3Qgc28gdGhhdCBsaW5raW5nIGRvZXNuJ3QgYnJlYWsgZHVlIHRvIGxpdmUgbGlzdCB1cGRhdGVzLlxuICAgICAgICB2YXIgbm9kZUxpc3RMZW5ndGggPSBub2RlTGlzdC5sZW5ndGgsXG4gICAgICAgICAgICBzdGFibGVOb2RlTGlzdCA9IG5ldyBBcnJheShub2RlTGlzdExlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlTGlzdExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3RhYmxlTm9kZUxpc3RbaV0gPSBub2RlTGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gMCwgbiA9IDAsIGlpID0gbGlua0Zucy5sZW5ndGg7IGkgPCBpaTsgbisrKSB7XG4gICAgICAgICAgbm9kZSA9IHN0YWJsZU5vZGVMaXN0W25dO1xuICAgICAgICAgIG5vZGVMaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAgICAgY2hpbGRMaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAgICAgJG5vZGUgPSBqcUxpdGUobm9kZSk7XG5cbiAgICAgICAgICBpZiAobm9kZUxpbmtGbikge1xuICAgICAgICAgICAgaWYgKG5vZGVMaW5rRm4uc2NvcGUpIHtcbiAgICAgICAgICAgICAgY2hpbGRTY29wZSA9IHNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgICAgJG5vZGUuZGF0YSgnJHNjb3BlJywgY2hpbGRTY29wZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGlsZFNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZFRyYW5zY2x1ZGVGbiA9IG5vZGVMaW5rRm4udHJhbnNjbHVkZTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyYW5zY2x1ZGVGbiB8fCAoIWJvdW5kVHJhbnNjbHVkZUZuICYmIHRyYW5zY2x1ZGVGbikpIHtcbiAgICAgICAgICAgICAgbm9kZUxpbmtGbihjaGlsZExpbmtGbiwgY2hpbGRTY29wZSwgbm9kZSwgJHJvb3RFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUJvdW5kVHJhbnNjbHVkZUZuKHNjb3BlLCBjaGlsZFRyYW5zY2x1ZGVGbiB8fCB0cmFuc2NsdWRlRm4pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlTGlua0ZuKGNoaWxkTGlua0ZuLCBjaGlsZFNjb3BlLCBub2RlLCAkcm9vdEVsZW1lbnQsIGJvdW5kVHJhbnNjbHVkZUZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkTGlua0ZuKSB7XG4gICAgICAgICAgICBjaGlsZExpbmtGbihzY29wZSwgbm9kZS5jaGlsZE5vZGVzLCB1bmRlZmluZWQsIGJvdW5kVHJhbnNjbHVkZUZuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCb3VuZFRyYW5zY2x1ZGVGbihzY29wZSwgdHJhbnNjbHVkZUZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRUcmFuc2NsdWRlRm4odHJhbnNjbHVkZWRTY29wZSwgY2xvbmVGbiwgY29udHJvbGxlcnMpIHtcbiAgICAgICAgdmFyIHNjb3BlQ3JlYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdHJhbnNjbHVkZWRTY29wZSkge1xuICAgICAgICAgIHRyYW5zY2x1ZGVkU2NvcGUgPSBzY29wZS4kbmV3KCk7XG4gICAgICAgICAgdHJhbnNjbHVkZWRTY29wZS4kJHRyYW5zY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgICBzY29wZUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsb25lID0gdHJhbnNjbHVkZUZuKHRyYW5zY2x1ZGVkU2NvcGUsIGNsb25lRm4sIGNvbnRyb2xsZXJzKTtcbiAgICAgICAgaWYgKHNjb3BlQ3JlYXRlZCkge1xuICAgICAgICAgIGNsb25lLm9uKCckZGVzdHJveScsIGJpbmQodHJhbnNjbHVkZWRTY29wZSwgdHJhbnNjbHVkZWRTY29wZS4kZGVzdHJveSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9va3MgZm9yIGRpcmVjdGl2ZXMgb24gdGhlIGdpdmVuIG5vZGUgYW5kIGFkZHMgdGhlbSB0byB0aGUgZGlyZWN0aXZlIGNvbGxlY3Rpb24gd2hpY2ggaXNcbiAgICAgKiBzb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSBOb2RlIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gZGlyZWN0aXZlcyBBbiBhcnJheSB0byB3aGljaCB0aGUgZGlyZWN0aXZlcyBhcmUgYWRkZWQgdG8uIFRoaXMgYXJyYXkgaXMgc29ydGVkIGJlZm9yZVxuICAgICAqICAgICAgICB0aGUgZnVuY3Rpb24gcmV0dXJucy5cbiAgICAgKiBAcGFyYW0gYXR0cnMgVGhlIHNoYXJlZCBhdHRycyBvYmplY3Qgd2hpY2ggaXMgdXNlZCB0byBwb3B1bGF0ZSB0aGUgbm9ybWFsaXplZCBhdHRyaWJ1dGVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbWF4UHJpb3JpdHkgTWF4IGRpcmVjdGl2ZSBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb2xsZWN0RGlyZWN0aXZlcyhub2RlLCBkaXJlY3RpdmVzLCBhdHRycywgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSkge1xuICAgICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZSxcbiAgICAgICAgICBhdHRyc01hcCA9IGF0dHJzLiRhdHRyLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGNsYXNzTmFtZTtcblxuICAgICAgc3dpdGNoKG5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMTogLyogRWxlbWVudCAqL1xuICAgICAgICAgIC8vIHVzZSB0aGUgbm9kZSBuYW1lOiA8ZGlyZWN0aXZlPlxuICAgICAgICAgIGFkZERpcmVjdGl2ZShkaXJlY3RpdmVzLFxuICAgICAgICAgICAgICBkaXJlY3RpdmVOb3JtYWxpemUobm9kZU5hbWVfKG5vZGUpLnRvTG93ZXJDYXNlKCkpLCAnRScsIG1heFByaW9yaXR5LCBpZ25vcmVEaXJlY3RpdmUpO1xuXG4gICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgZm9yICh2YXIgYXR0ciwgbmFtZSwgbk5hbWUsIG5nQXR0ck5hbWUsIHZhbHVlLCBuQXR0cnMgPSBub2RlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgaiA9IDAsIGpqID0gbkF0dHJzICYmIG5BdHRycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYXR0clN0YXJ0TmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGF0dHJFbmROYW1lID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGF0dHIgPSBuQXR0cnNbal07XG4gICAgICAgICAgICBpZiAoIW1zaWUgfHwgbXNpZSA+PSA4IHx8IGF0dHIuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICAgIC8vIHN1cHBvcnQgbmdBdHRyIGF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgICAgICAgICAgIG5nQXR0ck5hbWUgPSBkaXJlY3RpdmVOb3JtYWxpemUobmFtZSk7XG4gICAgICAgICAgICAgIGlmIChOR19BVFRSX0JJTkRJTkcudGVzdChuZ0F0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBzbmFrZV9jYXNlKG5nQXR0ck5hbWUuc3Vic3RyKDYpLCAnLScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5OYW1lID0gbmdBdHRyTmFtZS5yZXBsYWNlKC8oU3RhcnR8RW5kKSQvLCAnJyk7XG4gICAgICAgICAgICAgIGlmIChuZ0F0dHJOYW1lID09PSBkaXJlY3RpdmVOTmFtZSArICdTdGFydCcpIHtcbiAgICAgICAgICAgICAgICBhdHRyU3RhcnROYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBhdHRyRW5kTmFtZSA9IG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gNSkgKyAnZW5kJztcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMCwgbmFtZS5sZW5ndGggLSA2KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5OYW1lID0gZGlyZWN0aXZlTm9ybWFsaXplKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIGF0dHJzTWFwW25OYW1lXSA9IG5hbWU7XG4gICAgICAgICAgICAgIGF0dHJzW25OYW1lXSA9IHZhbHVlID0gdHJpbShhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKGdldEJvb2xlYW5BdHRyTmFtZShub2RlLCBuTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tuTmFtZV0gPSB0cnVlOyAvLyBwcmVzZW5jZSBtZWFucyB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkQXR0ckludGVycG9sYXRlRGlyZWN0aXZlKG5vZGUsIGRpcmVjdGl2ZXMsIHZhbHVlLCBuTmFtZSk7XG4gICAgICAgICAgICAgIGFkZERpcmVjdGl2ZShkaXJlY3RpdmVzLCBuTmFtZSwgJ0EnLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlLCBhdHRyU3RhcnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJFbmROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1c2UgY2xhc3MgYXMgZGlyZWN0aXZlXG4gICAgICAgICAgY2xhc3NOYW1lID0gbm9kZS5jbGFzc05hbWU7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNsYXNzTmFtZSkgJiYgY2xhc3NOYW1lICE9PSAnJykge1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gQ0xBU1NfRElSRUNUSVZFX1JFR0VYUC5leGVjKGNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgbk5hbWUgPSBkaXJlY3RpdmVOb3JtYWxpemUobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICBpZiAoYWRkRGlyZWN0aXZlKGRpcmVjdGl2ZXMsIG5OYW1lLCAnQycsIG1heFByaW9yaXR5LCBpZ25vcmVEaXJlY3RpdmUpKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbbk5hbWVdID0gdHJpbShtYXRjaFszXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnN1YnN0cihtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6IC8qIFRleHQgTm9kZSAqL1xuICAgICAgICAgIGFkZFRleHRJbnRlcnBvbGF0ZURpcmVjdGl2ZShkaXJlY3RpdmVzLCBub2RlLm5vZGVWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODogLyogQ29tbWVudCAqL1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRjaCA9IENPTU1FTlRfRElSRUNUSVZFX1JFR0VYUC5leGVjKG5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBuTmFtZSA9IGRpcmVjdGl2ZU5vcm1hbGl6ZShtYXRjaFsxXSk7XG4gICAgICAgICAgICAgIGlmIChhZGREaXJlY3RpdmUoZGlyZWN0aXZlcywgbk5hbWUsICdNJywgbWF4UHJpb3JpdHksIGlnbm9yZURpcmVjdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tuTmFtZV0gPSB0cmltKG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHR1cm5zIG91dCB0aGF0IHVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcyBJRTkgdGhyb3dzIGVycm9ycyB3aGVuIG9uZSBhdHRlbXB0cyB0byByZWFkXG4gICAgICAgICAgICAvLyBjb21tZW50J3Mgbm9kZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEp1c3QgaWdub3JlIGl0IGFuZCBjb250aW51ZS4gKENhbid0IHNlZW0gdG8gcmVwcm9kdWNlIGluIHRlc3QgY2FzZS4pXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVzLnNvcnQoYnlQcmlvcml0eSk7XG4gICAgICByZXR1cm4gZGlyZWN0aXZlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG5vZGUgd2l0aCBhbiBkaXJlY3RpdmUtc3RhcnQgaXQgY29sbGVjdHMgYWxsIG9mIHRoZSBzaWJsaW5ncyB1bnRpbCBpdCBmaW5kc1xuICAgICAqIGRpcmVjdGl2ZS1lbmQuXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKiBAcGFyYW0gYXR0clN0YXJ0XG4gICAgICogQHBhcmFtIGF0dHJFbmRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cFNjYW4obm9kZSwgYXR0clN0YXJ0LCBhdHRyRW5kKSB7XG4gICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICBpZiAoYXR0clN0YXJ0ICYmIG5vZGUuaGFzQXR0cmlidXRlICYmIG5vZGUuaGFzQXR0cmlidXRlKGF0dHJTdGFydCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG5vZGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCd1dGVyZGlyJyxcbiAgICAgICAgICAgICAgICAgICAgICBcIlVudGVybWluYXRlZCBhdHRyaWJ1dGUsIGZvdW5kICd7MH0nIGJ1dCBubyBtYXRjaGluZyAnezF9JyBmb3VuZC5cIixcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyU3RhcnQsIGF0dHJFbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxIC8qKiBFbGVtZW50ICoqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJTdGFydCkpIGRlcHRoKys7XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0ckVuZCkpIGRlcHRoLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH0gd2hpbGUgKGRlcHRoID4gMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ganFMaXRlKG5vZGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIGZvciBsaW5raW5nIGZ1bmN0aW9uIHdoaWNoIGNvbnZlcnRzIG5vcm1hbCBsaW5raW5nIGZ1bmN0aW9uIGludG8gYSBncm91cGVkXG4gICAgICogbGlua2luZyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gbGlua0ZuXG4gICAgICogQHBhcmFtIGF0dHJTdGFydFxuICAgICAqIEBwYXJhbSBhdHRyRW5kXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdyb3VwRWxlbWVudHNMaW5rRm5XcmFwcGVyKGxpbmtGbiwgYXR0clN0YXJ0LCBhdHRyRW5kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjb250cm9sbGVycywgdHJhbnNjbHVkZUZuKSB7XG4gICAgICAgIGVsZW1lbnQgPSBncm91cFNjYW4oZWxlbWVudFswXSwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcbiAgICAgICAgcmV0dXJuIGxpbmtGbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXJzLCB0cmFuc2NsdWRlRm4pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmNlIHRoZSBkaXJlY3RpdmVzIGhhdmUgYmVlbiBjb2xsZWN0ZWQsIHRoZWlyIGNvbXBpbGUgZnVuY3Rpb25zIGFyZSBleGVjdXRlZC4gVGhpcyBtZXRob2RcbiAgICAgKiBpcyByZXNwb25zaWJsZSBmb3IgaW5saW5pbmcgZGlyZWN0aXZlIHRlbXBsYXRlcyBhcyB3ZWxsIGFzIHRlcm1pbmF0aW5nIHRoZSBhcHBsaWNhdGlvblxuICAgICAqIG9mIHRoZSBkaXJlY3RpdmVzIGlmIHRoZSB0ZXJtaW5hbCBkaXJlY3RpdmUgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRpcmVjdGl2ZXMgQXJyYXkgb2YgY29sbGVjdGVkIGRpcmVjdGl2ZXMgdG8gZXhlY3V0ZSB0aGVpciBjb21waWxlIGZ1bmN0aW9uLlxuICAgICAqICAgICAgICB0aGlzIG5lZWRzIHRvIGJlIHByZS1zb3J0ZWQgYnkgcHJpb3JpdHkgb3JkZXIuXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb21waWxlTm9kZSBUaGUgcmF3IERPTSBub2RlIHRvIGFwcGx5IHRoZSBjb21waWxlIGZ1bmN0aW9ucyB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUF0dHJzIFRoZSBzaGFyZWQgYXR0cmlidXRlIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihhbmd1bGFyLlNjb3BlWywgY2xvbmVBdHRhY2hGbl19IHRyYW5zY2x1ZGVGbiBBIGxpbmtpbmcgZnVuY3Rpb24sIHdoZXJlIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSBhcmd1bWVudCBpcyBhdXRvLWdlbmVyYXRlZCB0byB0aGUgbmV3XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIG9mIHRoZSB0cmFuc2NsdWRlZCBwYXJlbnQgc2NvcGUuXG4gICAgICogQHBhcmFtIHtKUUxpdGV9IGpxQ29sbGVjdGlvbiBJZiB3ZSBhcmUgd29ya2luZyBvbiB0aGUgcm9vdCBvZiB0aGUgY29tcGlsZSB0cmVlIHRoZW4gdGhpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgaGFzIHRoZSByb290IGpxTGl0ZSBhcnJheSBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIG5vZGVzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbiBpdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdD19IG9yaWdpbmFsUmVwbGFjZURpcmVjdGl2ZSBBbiBvcHRpb25hbCBkaXJlY3RpdmUgdGhhdCB3aWxsIGJlIGlnbm9yZWQgd2hlblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgdHJhbnNjbHVzaW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEZ1bmN0aW9uPn0gcHJlTGlua0Zuc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPEZ1bmN0aW9uPn0gcG9zdExpbmtGbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldmlvdXNDb21waWxlQ29udGV4dCBDb250ZXh0IHVzZWQgZm9yIHByZXZpb3VzIGNvbXBpbGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVxuICAgICAqIEByZXR1cm5zIGxpbmtGblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFwcGx5RGlyZWN0aXZlc1RvTm9kZShkaXJlY3RpdmVzLCBjb21waWxlTm9kZSwgdGVtcGxhdGVBdHRycywgdHJhbnNjbHVkZUZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcUNvbGxlY3Rpb24sIG9yaWdpbmFsUmVwbGFjZURpcmVjdGl2ZSwgcHJlTGlua0ZucywgcG9zdExpbmtGbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ29tcGlsZUNvbnRleHQpIHtcbiAgICAgIHByZXZpb3VzQ29tcGlsZUNvbnRleHQgPSBwcmV2aW91c0NvbXBpbGVDb250ZXh0IHx8IHt9O1xuXG4gICAgICB2YXIgdGVybWluYWxQcmlvcml0eSA9IC1OdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgIG5ld1Njb3BlRGlyZWN0aXZlLFxuICAgICAgICAgIGNvbnRyb2xsZXJEaXJlY3RpdmVzID0gcHJldmlvdXNDb21waWxlQ29udGV4dC5jb250cm9sbGVyRGlyZWN0aXZlcyxcbiAgICAgICAgICBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUgPSBwcmV2aW91c0NvbXBpbGVDb250ZXh0Lm5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSxcbiAgICAgICAgICB0ZW1wbGF0ZURpcmVjdGl2ZSA9IHByZXZpb3VzQ29tcGlsZUNvbnRleHQudGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZSA9IHByZXZpb3VzQ29tcGlsZUNvbnRleHQubm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZSxcbiAgICAgICAgICBoYXNUcmFuc2NsdWRlRGlyZWN0aXZlID0gZmFsc2UsXG4gICAgICAgICAgaGFzRWxlbWVudFRyYW5zY2x1ZGVEaXJlY3RpdmUgPSBmYWxzZSxcbiAgICAgICAgICAkY29tcGlsZU5vZGUgPSB0ZW1wbGF0ZUF0dHJzLiQkZWxlbWVudCA9IGpxTGl0ZShjb21waWxlTm9kZSksXG4gICAgICAgICAgZGlyZWN0aXZlLFxuICAgICAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICAgICAgJHRlbXBsYXRlLFxuICAgICAgICAgIHJlcGxhY2VEaXJlY3RpdmUgPSBvcmlnaW5hbFJlcGxhY2VEaXJlY3RpdmUsXG4gICAgICAgICAgY2hpbGRUcmFuc2NsdWRlRm4gPSB0cmFuc2NsdWRlRm4sXG4gICAgICAgICAgbGlua0ZuLFxuICAgICAgICAgIGRpcmVjdGl2ZVZhbHVlO1xuXG4gICAgICAvLyBleGVjdXRlcyBhbGwgZGlyZWN0aXZlcyBvbiB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICBmb3IodmFyIGkgPSAwLCBpaSA9IGRpcmVjdGl2ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBkaXJlY3RpdmUgPSBkaXJlY3RpdmVzW2ldO1xuICAgICAgICB2YXIgYXR0clN0YXJ0ID0gZGlyZWN0aXZlLiQkc3RhcnQ7XG4gICAgICAgIHZhciBhdHRyRW5kID0gZGlyZWN0aXZlLiQkZW5kO1xuXG4gICAgICAgIC8vIGNvbGxlY3QgbXVsdGlibG9jayBzZWN0aW9uc1xuICAgICAgICBpZiAoYXR0clN0YXJ0KSB7XG4gICAgICAgICAgJGNvbXBpbGVOb2RlID0gZ3JvdXBTY2FuKGNvbXBpbGVOb2RlLCBhdHRyU3RhcnQsIGF0dHJFbmQpO1xuICAgICAgICB9XG4gICAgICAgICR0ZW1wbGF0ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodGVybWluYWxQcmlvcml0eSA+IGRpcmVjdGl2ZS5wcmlvcml0eSkge1xuICAgICAgICAgIGJyZWFrOyAvLyBwcmV2ZW50IGZ1cnRoZXIgcHJvY2Vzc2luZyBvZiBkaXJlY3RpdmVzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlyZWN0aXZlVmFsdWUgPSBkaXJlY3RpdmUuc2NvcGUpIHtcbiAgICAgICAgICBuZXdTY29wZURpcmVjdGl2ZSA9IG5ld1Njb3BlRGlyZWN0aXZlIHx8IGRpcmVjdGl2ZTtcblxuICAgICAgICAgIC8vIHNraXAgdGhlIGNoZWNrIGZvciBkaXJlY3RpdmVzIHdpdGggYXN5bmMgdGVtcGxhdGVzLCB3ZSdsbCBjaGVjayB0aGUgZGVyaXZlZCBzeW5jXG4gICAgICAgICAgLy8gZGlyZWN0aXZlIHdoZW4gdGhlIHRlbXBsYXRlIGFycml2ZXNcbiAgICAgICAgICBpZiAoIWRpcmVjdGl2ZS50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgYXNzZXJ0Tm9EdXBsaWNhdGUoJ25ldy9pc29sYXRlZCBzY29wZScsIG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSwgZGlyZWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvbXBpbGVOb2RlKTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChkaXJlY3RpdmVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubmFtZTtcblxuICAgICAgICBpZiAoIWRpcmVjdGl2ZS50ZW1wbGF0ZVVybCAmJiBkaXJlY3RpdmUuY29udHJvbGxlcikge1xuICAgICAgICAgIGRpcmVjdGl2ZVZhbHVlID0gZGlyZWN0aXZlLmNvbnRyb2xsZXI7XG4gICAgICAgICAgY29udHJvbGxlckRpcmVjdGl2ZXMgPSBjb250cm9sbGVyRGlyZWN0aXZlcyB8fCB7fTtcbiAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZShcIidcIiArIGRpcmVjdGl2ZU5hbWUgKyBcIicgY29udHJvbGxlclwiLFxuICAgICAgICAgICAgICBjb250cm9sbGVyRGlyZWN0aXZlc1tkaXJlY3RpdmVOYW1lXSwgZGlyZWN0aXZlLCAkY29tcGlsZU5vZGUpO1xuICAgICAgICAgIGNvbnRyb2xsZXJEaXJlY3RpdmVzW2RpcmVjdGl2ZU5hbWVdID0gZGlyZWN0aXZlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGl2ZVZhbHVlID0gZGlyZWN0aXZlLnRyYW5zY2x1ZGUpIHtcbiAgICAgICAgICBoYXNUcmFuc2NsdWRlRGlyZWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBuZ0lmIGFuZCBuZ1JlcGVhdCBzbyB0aGF0IHdlIGRvbid0IGNvbXBsYWluIGFib3V0IGR1cGxpY2F0ZSB0cmFuc2NsdXNpb24uXG4gICAgICAgICAgLy8gVGhpcyBvcHRpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBieSBkaXJlY3RpdmVzIHRoYXQga25vdyBob3cgdG8gaG93IHRvIHNhZmVseSBoYW5kbGUgZWxlbWVudCB0cmFuc2NsdXNpb24sXG4gICAgICAgICAgLy8gd2hlcmUgdGhlIHRyYW5zY2x1ZGVkIG5vZGVzIGFyZSBhZGRlZCBvciByZXBsYWNlZCBhZnRlciBsaW5raW5nLlxuICAgICAgICAgIGlmICghZGlyZWN0aXZlLiQkdGxiKSB7XG4gICAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZSgndHJhbnNjbHVzaW9uJywgbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZSwgZGlyZWN0aXZlLCAkY29tcGlsZU5vZGUpO1xuICAgICAgICAgICAgbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aXZlVmFsdWUgPT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgICAgICBoYXNFbGVtZW50VHJhbnNjbHVkZURpcmVjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0ZXJtaW5hbFByaW9yaXR5ID0gZGlyZWN0aXZlLnByaW9yaXR5O1xuICAgICAgICAgICAgJHRlbXBsYXRlID0gZ3JvdXBTY2FuKGNvbXBpbGVOb2RlLCBhdHRyU3RhcnQsIGF0dHJFbmQpO1xuICAgICAgICAgICAgJGNvbXBpbGVOb2RlID0gdGVtcGxhdGVBdHRycy4kJGVsZW1lbnQgPVxuICAgICAgICAgICAgICAgIGpxTGl0ZShkb2N1bWVudC5jcmVhdGVDb21tZW50KCcgJyArIGRpcmVjdGl2ZU5hbWUgKyAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUF0dHJzW2RpcmVjdGl2ZU5hbWVdICsgJyAnKSk7XG4gICAgICAgICAgICBjb21waWxlTm9kZSA9ICRjb21waWxlTm9kZVswXTtcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoKGpxQ29sbGVjdGlvbiwganFMaXRlKHNsaWNlQXJncygkdGVtcGxhdGUpKSwgY29tcGlsZU5vZGUpO1xuXG4gICAgICAgICAgICBjaGlsZFRyYW5zY2x1ZGVGbiA9IGNvbXBpbGUoJHRlbXBsYXRlLCB0cmFuc2NsdWRlRm4sIHRlcm1pbmFsUHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZURpcmVjdGl2ZSAmJiByZXBsYWNlRGlyZWN0aXZlLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHBhc3MgaW46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGNvbnRyb2xsZXJEaXJlY3RpdmVzIC0gb3RoZXJ3aXNlIHdlJ2xsIGNyZWF0ZSBkdXBsaWNhdGVzIGNvbnRyb2xsZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSBvciB0ZW1wbGF0ZURpcmVjdGl2ZSAtIGNvbWJpbmluZyB0ZW1wbGF0ZXMgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlbGVtZW50IHRyYW5zY2x1c2lvbiBkb2Vzbid0IG1ha2Ugc2Vuc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCBvbmx5IG5vblRsYlRyYW5zY2x1ZGVEaXJlY3RpdmUgc28gdGhhdCB3ZSBwcmV2ZW50IHB1dHRpbmcgdHJhbnNjbHVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiB0aGUgc2FtZSBlbGVtZW50IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZTogbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdGVtcGxhdGUgPSBqcUxpdGUoanFMaXRlQ2xvbmUoY29tcGlsZU5vZGUpKS5jb250ZW50cygpO1xuICAgICAgICAgICAgJGNvbXBpbGVOb2RlLmVtcHR5KCk7IC8vIGNsZWFyIGNvbnRlbnRzXG4gICAgICAgICAgICBjaGlsZFRyYW5zY2x1ZGVGbiA9IGNvbXBpbGUoJHRlbXBsYXRlLCB0cmFuc2NsdWRlRm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3RpdmUudGVtcGxhdGUpIHtcbiAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZSgndGVtcGxhdGUnLCB0ZW1wbGF0ZURpcmVjdGl2ZSwgZGlyZWN0aXZlLCAkY29tcGlsZU5vZGUpO1xuICAgICAgICAgIHRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuXG4gICAgICAgICAgZGlyZWN0aXZlVmFsdWUgPSAoaXNGdW5jdGlvbihkaXJlY3RpdmUudGVtcGxhdGUpKVxuICAgICAgICAgICAgICA/IGRpcmVjdGl2ZS50ZW1wbGF0ZSgkY29tcGlsZU5vZGUsIHRlbXBsYXRlQXR0cnMpXG4gICAgICAgICAgICAgIDogZGlyZWN0aXZlLnRlbXBsYXRlO1xuXG4gICAgICAgICAgZGlyZWN0aXZlVmFsdWUgPSBkZW5vcm1hbGl6ZVRlbXBsYXRlKGRpcmVjdGl2ZVZhbHVlKTtcblxuICAgICAgICAgIGlmIChkaXJlY3RpdmUucmVwbGFjZSkge1xuICAgICAgICAgICAgcmVwbGFjZURpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgICR0ZW1wbGF0ZSA9IGpxTGl0ZSgnPGRpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0oZGlyZWN0aXZlVmFsdWUpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JykuY29udGVudHMoKTtcbiAgICAgICAgICAgIGNvbXBpbGVOb2RlID0gJHRlbXBsYXRlWzBdO1xuXG4gICAgICAgICAgICBpZiAoJHRlbXBsYXRlLmxlbmd0aCAhPSAxIHx8IGNvbXBpbGVOb2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCd0cGxydCcsXG4gICAgICAgICAgICAgICAgICBcIlRlbXBsYXRlIGZvciBkaXJlY3RpdmUgJ3swfScgbXVzdCBoYXZlIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gezF9XCIsXG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmVOYW1lLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcGxhY2VXaXRoKGpxQ29sbGVjdGlvbiwgJGNvbXBpbGVOb2RlLCBjb21waWxlTm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBuZXdUZW1wbGF0ZUF0dHJzID0geyRhdHRyOiB7fX07XG5cbiAgICAgICAgICAgIC8vIGNvbWJpbmUgZGlyZWN0aXZlcyBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIGFuZCBmcm9tIHRoZSB0ZW1wbGF0ZTpcbiAgICAgICAgICAgIC8vIC0gdGFrZSB0aGUgYXJyYXkgb2YgZGlyZWN0aXZlcyBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAgICAvLyAtIHNwbGl0IGl0IGludG8gdHdvIHBhcnRzLCB0aG9zZSB0aGF0IGFscmVhZHkgYXBwbGllZCAocHJvY2Vzc2VkKSBhbmQgdGhvc2UgdGhhdCB3ZXJlbid0ICh1bnByb2Nlc3NlZClcbiAgICAgICAgICAgIC8vIC0gY29sbGVjdCBkaXJlY3RpdmVzIGZyb20gdGhlIHRlbXBsYXRlIGFuZCBzb3J0IHRoZW0gYnkgcHJpb3JpdHlcbiAgICAgICAgICAgIC8vIC0gY29tYmluZSBkaXJlY3RpdmVzIGFzOiBwcm9jZXNzZWQgKyB0ZW1wbGF0ZSArIHVucHJvY2Vzc2VkXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVzID0gY29sbGVjdERpcmVjdGl2ZXMoY29tcGlsZU5vZGUsIFtdLCBuZXdUZW1wbGF0ZUF0dHJzKTtcbiAgICAgICAgICAgIHZhciB1bnByb2Nlc3NlZERpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzLnNwbGljZShpICsgMSwgZGlyZWN0aXZlcy5sZW5ndGggLSAoaSArIDEpKTtcblxuICAgICAgICAgICAgaWYgKG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBtYXJrRGlyZWN0aXZlc0FzSXNvbGF0ZSh0ZW1wbGF0ZURpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXMuY29uY2F0KHRlbXBsYXRlRGlyZWN0aXZlcykuY29uY2F0KHVucHJvY2Vzc2VkRGlyZWN0aXZlcyk7XG4gICAgICAgICAgICBtZXJnZVRlbXBsYXRlQXR0cmlidXRlcyh0ZW1wbGF0ZUF0dHJzLCBuZXdUZW1wbGF0ZUF0dHJzKTtcblxuICAgICAgICAgICAgaWkgPSBkaXJlY3RpdmVzLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGNvbXBpbGVOb2RlLmh0bWwoZGlyZWN0aXZlVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJlY3RpdmUudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICBhc3NlcnROb0R1cGxpY2F0ZSgndGVtcGxhdGUnLCB0ZW1wbGF0ZURpcmVjdGl2ZSwgZGlyZWN0aXZlLCAkY29tcGlsZU5vZGUpO1xuICAgICAgICAgIHRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuXG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZS5yZXBsYWNlKSB7XG4gICAgICAgICAgICByZXBsYWNlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGVMaW5rRm4gPSBjb21waWxlVGVtcGxhdGVVcmwoZGlyZWN0aXZlcy5zcGxpY2UoaSwgZGlyZWN0aXZlcy5sZW5ndGggLSBpKSwgJGNvbXBpbGVOb2RlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZUF0dHJzLCBqcUNvbGxlY3Rpb24sIGNoaWxkVHJhbnNjbHVkZUZuLCBwcmVMaW5rRm5zLCBwb3N0TGlua0Zucywge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJEaXJlY3RpdmVzOiBjb250cm9sbGVyRGlyZWN0aXZlcyxcbiAgICAgICAgICAgICAgICBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmU6IG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZURpcmVjdGl2ZTogdGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgICAgICAgICAgbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZTogbm9uVGxiVHJhbnNjbHVkZURpcmVjdGl2ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBpaSA9IGRpcmVjdGl2ZXMubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGl2ZS5jb21waWxlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpbmtGbiA9IGRpcmVjdGl2ZS5jb21waWxlKCRjb21waWxlTm9kZSwgdGVtcGxhdGVBdHRycywgY2hpbGRUcmFuc2NsdWRlRm4pO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obGlua0ZuKSkge1xuICAgICAgICAgICAgICBhZGRMaW5rRm5zKG51bGwsIGxpbmtGbiwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGlua0ZuKSB7XG4gICAgICAgICAgICAgIGFkZExpbmtGbnMobGlua0ZuLnByZSwgbGlua0ZuLnBvc3QsIGF0dHJTdGFydCwgYXR0ckVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSwgc3RhcnRpbmdUYWcoJGNvbXBpbGVOb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpcmVjdGl2ZS50ZXJtaW5hbCkge1xuICAgICAgICAgIG5vZGVMaW5rRm4udGVybWluYWwgPSB0cnVlO1xuICAgICAgICAgIHRlcm1pbmFsUHJpb3JpdHkgPSBNYXRoLm1heCh0ZXJtaW5hbFByaW9yaXR5LCBkaXJlY3RpdmUucHJpb3JpdHkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgbm9kZUxpbmtGbi5zY29wZSA9IG5ld1Njb3BlRGlyZWN0aXZlICYmIG5ld1Njb3BlRGlyZWN0aXZlLnNjb3BlID09PSB0cnVlO1xuICAgICAgbm9kZUxpbmtGbi50cmFuc2NsdWRlID0gaGFzVHJhbnNjbHVkZURpcmVjdGl2ZSAmJiBjaGlsZFRyYW5zY2x1ZGVGbjtcblxuICAgICAgLy8gbWlnaHQgYmUgbm9ybWFsIG9yIGRlbGF5ZWQgbm9kZUxpbmtGbiBkZXBlbmRpbmcgb24gaWYgdGVtcGxhdGVVcmwgaXMgcHJlc2VudFxuICAgICAgcmV0dXJuIG5vZGVMaW5rRm47XG5cbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGZ1bmN0aW9uIGFkZExpbmtGbnMocHJlLCBwb3N0LCBhdHRyU3RhcnQsIGF0dHJFbmQpIHtcbiAgICAgICAgaWYgKHByZSkge1xuICAgICAgICAgIGlmIChhdHRyU3RhcnQpIHByZSA9IGdyb3VwRWxlbWVudHNMaW5rRm5XcmFwcGVyKHByZSwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcbiAgICAgICAgICBwcmUucmVxdWlyZSA9IGRpcmVjdGl2ZS5yZXF1aXJlO1xuICAgICAgICAgIGlmIChuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUgPT09IGRpcmVjdGl2ZSB8fCBkaXJlY3RpdmUuJCRpc29sYXRlU2NvcGUpIHtcbiAgICAgICAgICAgIHByZSA9IGNsb25lQW5kQW5ub3RhdGVGbihwcmUsIHtpc29sYXRlU2NvcGU6IHRydWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJlTGlua0Zucy5wdXNoKHByZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc3QpIHtcbiAgICAgICAgICBpZiAoYXR0clN0YXJ0KSBwb3N0ID0gZ3JvdXBFbGVtZW50c0xpbmtGbldyYXBwZXIocG9zdCwgYXR0clN0YXJ0LCBhdHRyRW5kKTtcbiAgICAgICAgICBwb3N0LnJlcXVpcmUgPSBkaXJlY3RpdmUucmVxdWlyZTtcbiAgICAgICAgICBpZiAobmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlID09PSBkaXJlY3RpdmUgfHwgZGlyZWN0aXZlLiQkaXNvbGF0ZVNjb3BlKSB7XG4gICAgICAgICAgICBwb3N0ID0gY2xvbmVBbmRBbm5vdGF0ZUZuKHBvc3QsIHtpc29sYXRlU2NvcGU6IHRydWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zdExpbmtGbnMucHVzaChwb3N0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGZ1bmN0aW9uIGdldENvbnRyb2xsZXJzKHJlcXVpcmUsICRlbGVtZW50LCBlbGVtZW50Q29udHJvbGxlcnMpIHtcbiAgICAgICAgdmFyIHZhbHVlLCByZXRyaWV2YWxNZXRob2QgPSAnZGF0YScsIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1N0cmluZyhyZXF1aXJlKSkge1xuICAgICAgICAgIHdoaWxlKCh2YWx1ZSA9IHJlcXVpcmUuY2hhckF0KDApKSA9PSAnXicgfHwgdmFsdWUgPT0gJz8nKSB7XG4gICAgICAgICAgICByZXF1aXJlID0gcmVxdWlyZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gJ14nKSB7XG4gICAgICAgICAgICAgIHJldHJpZXZhbE1ldGhvZCA9ICdpbmhlcml0ZWREYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbmFsID0gb3B0aW9uYWwgfHwgdmFsdWUgPT0gJz8nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudENvbnRyb2xsZXJzICYmIHJldHJpZXZhbE1ldGhvZCA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnRDb250cm9sbGVyc1tyZXF1aXJlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAkZWxlbWVudFtyZXRyaWV2YWxNZXRob2RdKCckJyArIHJlcXVpcmUgKyAnQ29udHJvbGxlcicpO1xuXG4gICAgICAgICAgaWYgKCF2YWx1ZSAmJiAhb3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCdjdHJlcScsXG4gICAgICAgICAgICAgICAgXCJDb250cm9sbGVyICd7MH0nLCByZXF1aXJlZCBieSBkaXJlY3RpdmUgJ3sxfScsIGNhbid0IGJlIGZvdW5kIVwiLFxuICAgICAgICAgICAgICAgIHJlcXVpcmUsIGRpcmVjdGl2ZU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShyZXF1aXJlKSkge1xuICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgZm9yRWFjaChyZXF1aXJlLCBmdW5jdGlvbihyZXF1aXJlKSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGdldENvbnRyb2xsZXJzKHJlcXVpcmUsICRlbGVtZW50LCBlbGVtZW50Q29udHJvbGxlcnMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cblxuICAgICAgZnVuY3Rpb24gbm9kZUxpbmtGbihjaGlsZExpbmtGbiwgc2NvcGUsIGxpbmtOb2RlLCAkcm9vdEVsZW1lbnQsIGJvdW5kVHJhbnNjbHVkZUZuKSB7XG4gICAgICAgIHZhciBhdHRycywgJGVsZW1lbnQsIGksIGlpLCBsaW5rRm4sIGNvbnRyb2xsZXIsIGlzb2xhdGVTY29wZSwgZWxlbWVudENvbnRyb2xsZXJzID0ge30sIHRyYW5zY2x1ZGVGbjtcblxuICAgICAgICBpZiAoY29tcGlsZU5vZGUgPT09IGxpbmtOb2RlKSB7XG4gICAgICAgICAgYXR0cnMgPSB0ZW1wbGF0ZUF0dHJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJzID0gc2hhbGxvd0NvcHkodGVtcGxhdGVBdHRycywgbmV3IEF0dHJpYnV0ZXMoanFMaXRlKGxpbmtOb2RlKSwgdGVtcGxhdGVBdHRycy4kYXR0cikpO1xuICAgICAgICB9XG4gICAgICAgICRlbGVtZW50ID0gYXR0cnMuJCRlbGVtZW50O1xuXG4gICAgICAgIGlmIChuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICB2YXIgTE9DQUxfUkVHRVhQID0gL15cXHMqKFtAPSZdKShcXD8/KVxccyooXFx3KilcXHMqJC87XG4gICAgICAgICAgdmFyICRsaW5rTm9kZSA9IGpxTGl0ZShsaW5rTm9kZSk7XG5cbiAgICAgICAgICBpc29sYXRlU2NvcGUgPSBzY29wZS4kbmV3KHRydWUpO1xuXG4gICAgICAgICAgaWYgKHRlbXBsYXRlRGlyZWN0aXZlICYmICh0ZW1wbGF0ZURpcmVjdGl2ZSA9PT0gbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLiQkb3JpZ2luYWxEaXJlY3RpdmUpKSB7XG4gICAgICAgICAgICAkbGlua05vZGUuZGF0YSgnJGlzb2xhdGVTY29wZScsIGlzb2xhdGVTY29wZSkgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkbGlua05vZGUuZGF0YSgnJGlzb2xhdGVTY29wZU5vVGVtcGxhdGUnLCBpc29sYXRlU2NvcGUpO1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBzYWZlQWRkQ2xhc3MoJGxpbmtOb2RlLCAnbmctaXNvbGF0ZS1zY29wZScpO1xuXG4gICAgICAgICAgZm9yRWFjaChuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUuc2NvcGUsIGZ1bmN0aW9uKGRlZmluaXRpb24sIHNjb3BlTmFtZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gZGVmaW5pdGlvbi5tYXRjaChMT0NBTF9SRUdFWFApIHx8IFtdLFxuICAgICAgICAgICAgICAgIGF0dHJOYW1lID0gbWF0Y2hbM10gfHwgc2NvcGVOYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0gKG1hdGNoWzJdID09ICc/JyksXG4gICAgICAgICAgICAgICAgbW9kZSA9IG1hdGNoWzFdLCAvLyBALCA9LCBvciAmXG4gICAgICAgICAgICAgICAgbGFzdFZhbHVlLFxuICAgICAgICAgICAgICAgIHBhcmVudEdldCwgcGFyZW50U2V0LCBjb21wYXJlO1xuXG4gICAgICAgICAgICBpc29sYXRlU2NvcGUuJCRpc29sYXRlQmluZGluZ3Nbc2NvcGVOYW1lXSA9IG1vZGUgKyBhdHRyTmFtZTtcblxuICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG5cbiAgICAgICAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUoYXR0ck5hbWUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBpc29sYXRlU2NvcGVbc2NvcGVOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF0dHJzLiQkb2JzZXJ2ZXJzW2F0dHJOYW1lXS4kJHNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgaWYoIGF0dHJzW2F0dHJOYW1lXSApIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUgaGFzIGJlZW4gcHJvdmlkZWQgdGhlbiB3ZSB0cmlnZ2VyIGFuIGludGVycG9sYXRpb24gdG8gZW5zdXJlXG4gICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWUgaXMgdGhlcmUgZm9yIHVzZSBpbiB0aGUgbGluayBmblxuICAgICAgICAgICAgICAgICAgaXNvbGF0ZVNjb3BlW3Njb3BlTmFtZV0gPSAkaW50ZXJwb2xhdGUoYXR0cnNbYXR0ck5hbWVdKShzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbCAmJiAhYXR0cnNbYXR0ck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudEdldCA9ICRwYXJzZShhdHRyc1thdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRHZXQubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IGVxdWFscztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29tcGFyZSA9IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50U2V0ID0gcGFyZW50R2V0LmFzc2lnbiB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBjaGFuZ2UsIG9yIHdlIHdpbGwgdGhyb3cgdGhpcyBleGNlcHRpb24gb24gZXZlcnkgJGRpZ2VzdFxuICAgICAgICAgICAgICAgICAgbGFzdFZhbHVlID0gaXNvbGF0ZVNjb3BlW3Njb3BlTmFtZV0gPSBwYXJlbnRHZXQoc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ25vbmFzc2lnbicsXG4gICAgICAgICAgICAgICAgICAgICAgXCJFeHByZXNzaW9uICd7MH0nIHVzZWQgd2l0aCBkaXJlY3RpdmUgJ3sxfScgaXMgbm9uLWFzc2lnbmFibGUhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnNbYXR0ck5hbWVdLCBuZXdJc29sYXRlU2NvcGVEaXJlY3RpdmUubmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBpc29sYXRlU2NvcGVbc2NvcGVOYW1lXSA9IHBhcmVudEdldChzY29wZSk7XG4gICAgICAgICAgICAgICAgaXNvbGF0ZVNjb3BlLiR3YXRjaChmdW5jdGlvbiBwYXJlbnRWYWx1ZVdhdGNoKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFZhbHVlID0gcGFyZW50R2V0KHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShwYXJlbnRWYWx1ZSwgaXNvbGF0ZVNjb3BlW3Njb3BlTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBvdXQgb2Ygc3luYyBhbmQgbmVlZCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShwYXJlbnRWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmVudCBjaGFuZ2VkIGFuZCBpdCBoYXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgICAgIGlzb2xhdGVTY29wZVtzY29wZU5hbWVdID0gcGFyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBjYW4gYmUgYXNzaWduZWQgdGhlbiBkbyBzb1xuICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFNldChzY29wZSwgcGFyZW50VmFsdWUgPSBpc29sYXRlU2NvcGVbc2NvcGVOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0VmFsdWUgPSBwYXJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBwYXJlbnRHZXQubGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgcGFyZW50R2V0ID0gJHBhcnNlKGF0dHJzW2F0dHJOYW1lXSk7XG4gICAgICAgICAgICAgICAgaXNvbGF0ZVNjb3BlW3Njb3BlTmFtZV0gPSBmdW5jdGlvbihsb2NhbHMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRHZXQoc2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCdpc2NwJyxcbiAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIGlzb2xhdGUgc2NvcGUgZGVmaW5pdGlvbiBmb3IgZGlyZWN0aXZlICd7MH0nLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgRGVmaW5pdGlvbjogey4uLiB7MX06ICd7Mn0nIC4uLn1cIixcbiAgICAgICAgICAgICAgICAgICAgbmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLm5hbWUsIHNjb3BlTmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNjbHVkZUZuID0gYm91bmRUcmFuc2NsdWRlRm4gJiYgY29udHJvbGxlcnNCb3VuZFRyYW5zY2x1ZGU7XG4gICAgICAgIGlmIChjb250cm9sbGVyRGlyZWN0aXZlcykge1xuICAgICAgICAgIGZvckVhY2goY29udHJvbGxlckRpcmVjdGl2ZXMsIGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGxvY2FscyA9IHtcbiAgICAgICAgICAgICAgJHNjb3BlOiBkaXJlY3RpdmUgPT09IG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSB8fCBkaXJlY3RpdmUuJCRpc29sYXRlU2NvcGUgPyBpc29sYXRlU2NvcGUgOiBzY29wZSxcbiAgICAgICAgICAgICAgJGVsZW1lbnQ6ICRlbGVtZW50LFxuICAgICAgICAgICAgICAkYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgICAkdHJhbnNjbHVkZTogdHJhbnNjbHVkZUZuXG4gICAgICAgICAgICB9LCBjb250cm9sbGVySW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBkaXJlY3RpdmUuY29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyID09ICdAJykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyID0gYXR0cnNbZGlyZWN0aXZlLm5hbWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250cm9sbGVySW5zdGFuY2UgPSAkY29udHJvbGxlcihjb250cm9sbGVyLCBsb2NhbHMpO1xuICAgICAgICAgICAgLy8gRm9yIGRpcmVjdGl2ZXMgd2l0aCBlbGVtZW50IHRyYW5zY2x1c2lvbiB0aGUgZWxlbWVudCBpcyBhIGNvbW1lbnQsXG4gICAgICAgICAgICAvLyBidXQgalF1ZXJ5IC5kYXRhIGRvZXNuJ3Qgc3VwcG9ydCBhdHRhY2hpbmcgZGF0YSB0byBjb21tZW50IG5vZGVzIGFzIGl0J3MgaGFyZCB0b1xuICAgICAgICAgICAgLy8gY2xlYW4gdXAgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgzMzUpLlxuICAgICAgICAgICAgLy8gSW5zdGVhZCwgd2Ugc2F2ZSB0aGUgY29udHJvbGxlcnMgZm9yIHRoZSBlbGVtZW50IGluIGEgbG9jYWwgaGFzaCBhbmQgYXR0YWNoIHRvIC5kYXRhXG4gICAgICAgICAgICAvLyBsYXRlciwgb25jZSB3ZSBoYXZlIHRoZSBhY3R1YWwgZWxlbWVudC5cbiAgICAgICAgICAgIGVsZW1lbnRDb250cm9sbGVyc1tkaXJlY3RpdmUubmFtZV0gPSBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoIWhhc0VsZW1lbnRUcmFuc2NsdWRlRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICRlbGVtZW50LmRhdGEoJyQnICsgZGlyZWN0aXZlLm5hbWUgKyAnQ29udHJvbGxlcicsIGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuY29udHJvbGxlckFzKSB7XG4gICAgICAgICAgICAgIGxvY2Fscy4kc2NvcGVbZGlyZWN0aXZlLmNvbnRyb2xsZXJBc10gPSBjb250cm9sbGVySW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQUkVMSU5LSU5HXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBwcmVMaW5rRm5zLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlua0ZuID0gcHJlTGlua0Zuc1tpXTtcbiAgICAgICAgICAgIGxpbmtGbihsaW5rRm4uaXNvbGF0ZVNjb3BlID8gaXNvbGF0ZVNjb3BlIDogc2NvcGUsICRlbGVtZW50LCBhdHRycyxcbiAgICAgICAgICAgICAgICBsaW5rRm4ucmVxdWlyZSAmJiBnZXRDb250cm9sbGVycyhsaW5rRm4ucmVxdWlyZSwgJGVsZW1lbnQsIGVsZW1lbnRDb250cm9sbGVycyksIHRyYW5zY2x1ZGVGbik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSwgc3RhcnRpbmdUYWcoJGVsZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSRUNVUlNJT05cbiAgICAgICAgLy8gV2Ugb25seSBwYXNzIHRoZSBpc29sYXRlIHNjb3BlLCBpZiB0aGUgaXNvbGF0ZSBkaXJlY3RpdmUgaGFzIGEgdGVtcGxhdGUsXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgY2hpbGQgZWxlbWVudHMgZG8gbm90IGJlbG9uZyB0byB0aGUgaXNvbGF0ZSBkaXJlY3RpdmUuXG4gICAgICAgIHZhciBzY29wZVRvQ2hpbGQgPSBzY29wZTtcbiAgICAgICAgaWYgKG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZSAmJiAobmV3SXNvbGF0ZVNjb3BlRGlyZWN0aXZlLnRlbXBsYXRlIHx8IG5ld0lzb2xhdGVTY29wZURpcmVjdGl2ZS50ZW1wbGF0ZVVybCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICBzY29wZVRvQ2hpbGQgPSBpc29sYXRlU2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRMaW5rRm4gJiYgY2hpbGRMaW5rRm4oc2NvcGVUb0NoaWxkLCBsaW5rTm9kZS5jaGlsZE5vZGVzLCB1bmRlZmluZWQsIGJvdW5kVHJhbnNjbHVkZUZuKTtcblxuICAgICAgICAvLyBQT1NUTElOS0lOR1xuICAgICAgICBmb3IoaSA9IHBvc3RMaW5rRm5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxpbmtGbiA9IHBvc3RMaW5rRm5zW2ldO1xuICAgICAgICAgICAgbGlua0ZuKGxpbmtGbi5pc29sYXRlU2NvcGUgPyBpc29sYXRlU2NvcGUgOiBzY29wZSwgJGVsZW1lbnQsIGF0dHJzLFxuICAgICAgICAgICAgICAgIGxpbmtGbi5yZXF1aXJlICYmIGdldENvbnRyb2xsZXJzKGxpbmtGbi5yZXF1aXJlLCAkZWxlbWVudCwgZWxlbWVudENvbnRyb2xsZXJzKSwgdHJhbnNjbHVkZUZuKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlLCBzdGFydGluZ1RhZygkZWxlbWVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgaW5qZWN0ZWQgYXMgYCR0cmFuc2NsdWRlYC5cbiAgICAgICAgZnVuY3Rpb24gY29udHJvbGxlcnNCb3VuZFRyYW5zY2x1ZGUoc2NvcGUsIGNsb25lQXR0YWNoRm4pIHtcbiAgICAgICAgICB2YXIgdHJhbnNjbHVkZUNvbnRyb2xsZXJzO1xuXG4gICAgICAgICAgLy8gbm8gc2NvcGUgcGFzc2VkXG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjbG9uZUF0dGFjaEZuID0gc2NvcGU7XG4gICAgICAgICAgICBzY29wZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzRWxlbWVudFRyYW5zY2x1ZGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHRyYW5zY2x1ZGVDb250cm9sbGVycyA9IGVsZW1lbnRDb250cm9sbGVycztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYm91bmRUcmFuc2NsdWRlRm4oc2NvcGUsIGNsb25lQXR0YWNoRm4sIHRyYW5zY2x1ZGVDb250cm9sbGVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXJrRGlyZWN0aXZlc0FzSXNvbGF0ZShkaXJlY3RpdmVzKSB7XG4gICAgICAvLyBtYXJrIGFsbCBkaXJlY3RpdmVzIGFzIG5lZWRpbmcgaXNvbGF0ZSBzY29wZS5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IGRpcmVjdGl2ZXMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBkaXJlY3RpdmVzW2pdID0gaW5oZXJpdChkaXJlY3RpdmVzW2pdLCB7JCRpc29sYXRlU2NvcGU6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb29rcyB1cCB0aGUgZGlyZWN0aXZlIGFuZCBkZWNvcmF0ZXMgaXQgd2l0aCBleGNlcHRpb24gaGFuZGxpbmcgYW5kIHByb3BlciBwYXJhbWV0ZXJzLiBXZVxuICAgICAqIGNhbGwgdGhpcyB0aGUgYm91bmREaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBkaXJlY3RpdmUgdG8gbG9vayB1cC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gVGhlIGRpcmVjdGl2ZSBtdXN0IGJlIGZvdW5kIGluIHNwZWNpZmljIGZvcm1hdC5cbiAgICAgKiAgIFN0cmluZyBjb250YWluaW5nIGFueSBvZiB0aGVzZXMgY2hhcmFjdGVyczpcbiAgICAgKlxuICAgICAqICAgKiBgRWA6IGVsZW1lbnQgbmFtZVxuICAgICAqICAgKiBgQSc6IGF0dHJpYnV0ZVxuICAgICAqICAgKiBgQ2A6IGNsYXNzXG4gICAgICogICAqIGBNYDogY29tbWVudFxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZGlyZWN0aXZlIHdhcyBhZGRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGREaXJlY3RpdmUodERpcmVjdGl2ZXMsIG5hbWUsIGxvY2F0aW9uLCBtYXhQcmlvcml0eSwgaWdub3JlRGlyZWN0aXZlLCBzdGFydEF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRBdHRyTmFtZSkge1xuICAgICAgaWYgKG5hbWUgPT09IGlnbm9yZURpcmVjdGl2ZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbWF0Y2ggPSBudWxsO1xuICAgICAgaWYgKGhhc0RpcmVjdGl2ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgZm9yKHZhciBkaXJlY3RpdmUsIGRpcmVjdGl2ZXMgPSAkaW5qZWN0b3IuZ2V0KG5hbWUgKyBTdWZmaXgpLFxuICAgICAgICAgICAgaSA9IDAsIGlpID0gZGlyZWN0aXZlcy5sZW5ndGg7IGk8aWk7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBkaXJlY3RpdmVzW2ldO1xuICAgICAgICAgICAgaWYgKCAobWF4UHJpb3JpdHkgPT09IHVuZGVmaW5lZCB8fCBtYXhQcmlvcml0eSA+IGRpcmVjdGl2ZS5wcmlvcml0eSkgJiZcbiAgICAgICAgICAgICAgICAgZGlyZWN0aXZlLnJlc3RyaWN0LmluZGV4T2YobG9jYXRpb24pICE9IC0xKSB7XG4gICAgICAgICAgICAgIGlmIChzdGFydEF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlID0gaW5oZXJpdChkaXJlY3RpdmUsIHskJHN0YXJ0OiBzdGFydEF0dHJOYW1lLCAkJGVuZDogZW5kQXR0ck5hbWV9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0RGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICAgIG1hdGNoID0gZGlyZWN0aXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2goZSkgeyAkZXhjZXB0aW9uSGFuZGxlcihlKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBlbGVtZW50IGlzIHJlcGxhY2VkIHdpdGggSFRNTCB0ZW1wbGF0ZSB0aGVuIHRoZSBuZXcgYXR0cmlidXRlc1xuICAgICAqIG9uIHRoZSB0ZW1wbGF0ZSBuZWVkIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBhdHRyaWJ1dGVzIGluIHRoZSBET00uXG4gICAgICogVGhlIGRlc2lyZWQgZWZmZWN0IGlzIHRvIGhhdmUgYm90aCBvZiB0aGUgYXR0cmlidXRlcyBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRzdCBkZXN0aW5hdGlvbiBhdHRyaWJ1dGVzIChvcmlnaW5hbCBET00pXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNyYyBzb3VyY2UgYXR0cmlidXRlcyAoZnJvbSB0aGUgZGlyZWN0aXZlIHRlbXBsYXRlKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlVGVtcGxhdGVBdHRyaWJ1dGVzKGRzdCwgc3JjKSB7XG4gICAgICB2YXIgc3JjQXR0ciA9IHNyYy4kYXR0cixcbiAgICAgICAgICBkc3RBdHRyID0gZHN0LiRhdHRyLFxuICAgICAgICAgICRlbGVtZW50ID0gZHN0LiQkZWxlbWVudDtcblxuICAgICAgLy8gcmVhcHBseSB0aGUgb2xkIGF0dHJpYnV0ZXMgdG8gdGhlIG5ldyBlbGVtZW50XG4gICAgICBmb3JFYWNoKGRzdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSAhPSAnJCcpIHtcbiAgICAgICAgICBpZiAoc3JjW2tleV0pIHtcbiAgICAgICAgICAgIHZhbHVlICs9IChrZXkgPT09ICdzdHlsZScgPyAnOycgOiAnICcpICsgc3JjW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRzdC4kc2V0KGtleSwgdmFsdWUsIHRydWUsIHNyY0F0dHJba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb3B5IHRoZSBuZXcgYXR0cmlidXRlcyBvbiB0aGUgb2xkIGF0dHJzIG9iamVjdFxuICAgICAgZm9yRWFjaChzcmMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSAnY2xhc3MnKSB7XG4gICAgICAgICAgc2FmZUFkZENsYXNzKCRlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgICAgZHN0WydjbGFzcyddID0gKGRzdFsnY2xhc3MnXSA/IGRzdFsnY2xhc3MnXSArICcgJyA6ICcnKSArIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSAnc3R5bGUnKSB7XG4gICAgICAgICAgJGVsZW1lbnQuYXR0cignc3R5bGUnLCAkZWxlbWVudC5hdHRyKCdzdHlsZScpICsgJzsnICsgdmFsdWUpO1xuICAgICAgICAgIGRzdFsnc3R5bGUnXSA9IChkc3RbJ3N0eWxlJ10gPyBkc3RbJ3N0eWxlJ10gKyAnOycgOiAnJykgKyB2YWx1ZTtcbiAgICAgICAgICAvLyBgZHN0YCB3aWxsIG5ldmVyIGNvbnRhaW4gaGFzT3duUHJvcGVydHkgYXMgRE9NIHBhcnNlciB3b24ndCBsZXQgaXQuXG4gICAgICAgICAgLy8gWW91IHdpbGwgZ2V0IGFuIFwiSW52YWxpZENoYXJhY3RlckVycm9yOiBET00gRXhjZXB0aW9uIDVcIiBlcnJvciBpZiB5b3VcbiAgICAgICAgICAvLyBoYXZlIGFuIGF0dHJpYnV0ZSBsaWtlIFwiaGFzLW93bi1wcm9wZXJ0eVwiIG9yIFwiZGF0YS1oYXMtb3duLXByb3BlcnR5XCIsIGV0Yy5cbiAgICAgICAgfSBlbHNlIGlmIChrZXkuY2hhckF0KDApICE9ICckJyAmJiAhZHN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBkc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIGRzdEF0dHJba2V5XSA9IHNyY0F0dHJba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21waWxlVGVtcGxhdGVVcmwoZGlyZWN0aXZlcywgJGNvbXBpbGVOb2RlLCB0QXR0cnMsXG4gICAgICAgICRyb290RWxlbWVudCwgY2hpbGRUcmFuc2NsdWRlRm4sIHByZUxpbmtGbnMsIHBvc3RMaW5rRm5zLCBwcmV2aW91c0NvbXBpbGVDb250ZXh0KSB7XG4gICAgICB2YXIgbGlua1F1ZXVlID0gW10sXG4gICAgICAgICAgYWZ0ZXJUZW1wbGF0ZU5vZGVMaW5rRm4sXG4gICAgICAgICAgYWZ0ZXJUZW1wbGF0ZUNoaWxkTGlua0ZuLFxuICAgICAgICAgIGJlZm9yZVRlbXBsYXRlQ29tcGlsZU5vZGUgPSAkY29tcGlsZU5vZGVbMF0sXG4gICAgICAgICAgb3JpZ0FzeW5jRGlyZWN0aXZlID0gZGlyZWN0aXZlcy5zaGlmdCgpLFxuICAgICAgICAgIC8vIFRoZSBmYWN0IHRoYXQgd2UgaGF2ZSB0byBjb3B5IGFuZCBwYXRjaCB0aGUgZGlyZWN0aXZlIHNlZW1zIHdyb25nIVxuICAgICAgICAgIGRlcml2ZWRTeW5jRGlyZWN0aXZlID0gZXh0ZW5kKHt9LCBvcmlnQXN5bmNEaXJlY3RpdmUsIHtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBudWxsLCB0cmFuc2NsdWRlOiBudWxsLCByZXBsYWNlOiBudWxsLCAkJG9yaWdpbmFsRGlyZWN0aXZlOiBvcmlnQXN5bmNEaXJlY3RpdmVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0ZW1wbGF0ZVVybCA9IChpc0Z1bmN0aW9uKG9yaWdBc3luY0RpcmVjdGl2ZS50ZW1wbGF0ZVVybCkpXG4gICAgICAgICAgICAgID8gb3JpZ0FzeW5jRGlyZWN0aXZlLnRlbXBsYXRlVXJsKCRjb21waWxlTm9kZSwgdEF0dHJzKVxuICAgICAgICAgICAgICA6IG9yaWdBc3luY0RpcmVjdGl2ZS50ZW1wbGF0ZVVybDtcblxuICAgICAgJGNvbXBpbGVOb2RlLmVtcHR5KCk7XG5cbiAgICAgICRodHRwLmdldCgkc2NlLmdldFRydXN0ZWRSZXNvdXJjZVVybCh0ZW1wbGF0ZVVybCksIHtjYWNoZTogJHRlbXBsYXRlQ2FjaGV9KS5cbiAgICAgICAgc3VjY2VzcyhmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICAgICAgdmFyIGNvbXBpbGVOb2RlLCB0ZW1wVGVtcGxhdGVBdHRycywgJHRlbXBsYXRlLCBjaGlsZEJvdW5kVHJhbnNjbHVkZUZuO1xuXG4gICAgICAgICAgY29udGVudCA9IGRlbm9ybWFsaXplVGVtcGxhdGUoY29udGVudCk7XG5cbiAgICAgICAgICBpZiAob3JpZ0FzeW5jRGlyZWN0aXZlLnJlcGxhY2UpIHtcbiAgICAgICAgICAgICR0ZW1wbGF0ZSA9IGpxTGl0ZSgnPGRpdj4nICsgdHJpbShjb250ZW50KSArICc8L2Rpdj4nKS5jb250ZW50cygpO1xuICAgICAgICAgICAgY29tcGlsZU5vZGUgPSAkdGVtcGxhdGVbMF07XG5cbiAgICAgICAgICAgIGlmICgkdGVtcGxhdGUubGVuZ3RoICE9IDEgfHwgY29tcGlsZU5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ3RwbHJ0JyxcbiAgICAgICAgICAgICAgICAgIFwiVGVtcGxhdGUgZm9yIGRpcmVjdGl2ZSAnezB9JyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiB7MX1cIixcbiAgICAgICAgICAgICAgICAgIG9yaWdBc3luY0RpcmVjdGl2ZS5uYW1lLCB0ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlbXBUZW1wbGF0ZUF0dHJzID0geyRhdHRyOiB7fX07XG4gICAgICAgICAgICByZXBsYWNlV2l0aCgkcm9vdEVsZW1lbnQsICRjb21waWxlTm9kZSwgY29tcGlsZU5vZGUpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlRGlyZWN0aXZlcyA9IGNvbGxlY3REaXJlY3RpdmVzKGNvbXBpbGVOb2RlLCBbXSwgdGVtcFRlbXBsYXRlQXR0cnMpO1xuXG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3JpZ0FzeW5jRGlyZWN0aXZlLnNjb3BlKSkge1xuICAgICAgICAgICAgICBtYXJrRGlyZWN0aXZlc0FzSXNvbGF0ZSh0ZW1wbGF0ZURpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyZWN0aXZlcyA9IHRlbXBsYXRlRGlyZWN0aXZlcy5jb25jYXQoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICBtZXJnZVRlbXBsYXRlQXR0cmlidXRlcyh0QXR0cnMsIHRlbXBUZW1wbGF0ZUF0dHJzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZU5vZGUgPSBiZWZvcmVUZW1wbGF0ZUNvbXBpbGVOb2RlO1xuICAgICAgICAgICAgJGNvbXBpbGVOb2RlLmh0bWwoY29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlyZWN0aXZlcy51bnNoaWZ0KGRlcml2ZWRTeW5jRGlyZWN0aXZlKTtcblxuICAgICAgICAgIGFmdGVyVGVtcGxhdGVOb2RlTGlua0ZuID0gYXBwbHlEaXJlY3RpdmVzVG9Ob2RlKGRpcmVjdGl2ZXMsIGNvbXBpbGVOb2RlLCB0QXR0cnMsXG4gICAgICAgICAgICAgIGNoaWxkVHJhbnNjbHVkZUZuLCAkY29tcGlsZU5vZGUsIG9yaWdBc3luY0RpcmVjdGl2ZSwgcHJlTGlua0ZucywgcG9zdExpbmtGbnMsXG4gICAgICAgICAgICAgIHByZXZpb3VzQ29tcGlsZUNvbnRleHQpO1xuICAgICAgICAgIGZvckVhY2goJHJvb3RFbGVtZW50LCBmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PSBjb21waWxlTm9kZSkge1xuICAgICAgICAgICAgICAkcm9vdEVsZW1lbnRbaV0gPSAkY29tcGlsZU5vZGVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWZ0ZXJUZW1wbGF0ZUNoaWxkTGlua0ZuID0gY29tcGlsZU5vZGVzKCRjb21waWxlTm9kZVswXS5jaGlsZE5vZGVzLCBjaGlsZFRyYW5zY2x1ZGVGbik7XG5cblxuICAgICAgICAgIHdoaWxlKGxpbmtRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IGxpbmtRdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIGJlZm9yZVRlbXBsYXRlTGlua05vZGUgPSBsaW5rUXVldWUuc2hpZnQoKSxcbiAgICAgICAgICAgICAgICBsaW5rUm9vdEVsZW1lbnQgPSBsaW5rUXVldWUuc2hpZnQoKSxcbiAgICAgICAgICAgICAgICBib3VuZFRyYW5zY2x1ZGVGbiA9IGxpbmtRdWV1ZS5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIGxpbmtOb2RlID0gJGNvbXBpbGVOb2RlWzBdO1xuXG4gICAgICAgICAgICBpZiAoYmVmb3JlVGVtcGxhdGVMaW5rTm9kZSAhPT0gYmVmb3JlVGVtcGxhdGVDb21waWxlTm9kZSkge1xuICAgICAgICAgICAgICAvLyBpdCB3YXMgY2xvbmVkIHRoZXJlZm9yZSB3ZSBoYXZlIHRvIGNsb25lIGFzIHdlbGwuXG4gICAgICAgICAgICAgIGxpbmtOb2RlID0ganFMaXRlQ2xvbmUoY29tcGlsZU5vZGUpO1xuICAgICAgICAgICAgICByZXBsYWNlV2l0aChsaW5rUm9vdEVsZW1lbnQsIGpxTGl0ZShiZWZvcmVUZW1wbGF0ZUxpbmtOb2RlKSwgbGlua05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFmdGVyVGVtcGxhdGVOb2RlTGlua0ZuLnRyYW5zY2x1ZGUpIHtcbiAgICAgICAgICAgICAgY2hpbGRCb3VuZFRyYW5zY2x1ZGVGbiA9IGNyZWF0ZUJvdW5kVHJhbnNjbHVkZUZuKHNjb3BlLCBhZnRlclRlbXBsYXRlTm9kZUxpbmtGbi50cmFuc2NsdWRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoaWxkQm91bmRUcmFuc2NsdWRlRm4gPSBib3VuZFRyYW5zY2x1ZGVGbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyVGVtcGxhdGVOb2RlTGlua0ZuKGFmdGVyVGVtcGxhdGVDaGlsZExpbmtGbiwgc2NvcGUsIGxpbmtOb2RlLCAkcm9vdEVsZW1lbnQsXG4gICAgICAgICAgICAgIGNoaWxkQm91bmRUcmFuc2NsdWRlRm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5rUXVldWUgPSBudWxsO1xuICAgICAgICB9KS5cbiAgICAgICAgZXJyb3IoZnVuY3Rpb24ocmVzcG9uc2UsIGNvZGUsIGhlYWRlcnMsIGNvbmZpZykge1xuICAgICAgICAgIHRocm93ICRjb21waWxlTWluRXJyKCd0cGxvYWQnLCAnRmFpbGVkIHRvIGxvYWQgdGVtcGxhdGU6IHswfScsIGNvbmZpZy51cmwpO1xuICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5ZWROb2RlTGlua0ZuKGlnbm9yZUNoaWxkTGlua0ZuLCBzY29wZSwgbm9kZSwgcm9vdEVsZW1lbnQsIGJvdW5kVHJhbnNjbHVkZUZuKSB7XG4gICAgICAgIGlmIChsaW5rUXVldWUpIHtcbiAgICAgICAgICBsaW5rUXVldWUucHVzaChzY29wZSk7XG4gICAgICAgICAgbGlua1F1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgbGlua1F1ZXVlLnB1c2gocm9vdEVsZW1lbnQpO1xuICAgICAgICAgIGxpbmtRdWV1ZS5wdXNoKGJvdW5kVHJhbnNjbHVkZUZuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZnRlclRlbXBsYXRlTm9kZUxpbmtGbihhZnRlclRlbXBsYXRlQ2hpbGRMaW5rRm4sIHNjb3BlLCBub2RlLCByb290RWxlbWVudCwgYm91bmRUcmFuc2NsdWRlRm4pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU29ydGluZyBmdW5jdGlvbiBmb3IgYm91bmQgZGlyZWN0aXZlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBieVByaW9yaXR5KGEsIGIpIHtcbiAgICAgIHZhciBkaWZmID0gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG4gICAgICBpZiAoZGlmZiAhPT0gMCkgcmV0dXJuIGRpZmY7XG4gICAgICBpZiAoYS5uYW1lICE9PSBiLm5hbWUpIHJldHVybiAoYS5uYW1lIDwgYi5uYW1lKSA/IC0xIDogMTtcbiAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFzc2VydE5vRHVwbGljYXRlKHdoYXQsIHByZXZpb3VzRGlyZWN0aXZlLCBkaXJlY3RpdmUsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChwcmV2aW91c0RpcmVjdGl2ZSkge1xuICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycignbXVsdGlkaXInLCAnTXVsdGlwbGUgZGlyZWN0aXZlcyBbezB9LCB7MX1dIGFza2luZyBmb3IgezJ9IG9uOiB7M30nLFxuICAgICAgICAgICAgcHJldmlvdXNEaXJlY3RpdmUubmFtZSwgZGlyZWN0aXZlLm5hbWUsIHdoYXQsIHN0YXJ0aW5nVGFnKGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFRleHRJbnRlcnBvbGF0ZURpcmVjdGl2ZShkaXJlY3RpdmVzLCB0ZXh0KSB7XG4gICAgICB2YXIgaW50ZXJwb2xhdGVGbiA9ICRpbnRlcnBvbGF0ZSh0ZXh0LCB0cnVlKTtcbiAgICAgIGlmIChpbnRlcnBvbGF0ZUZuKSB7XG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaCh7XG4gICAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgICAgY29tcGlsZTogdmFsdWVGbihmdW5jdGlvbiB0ZXh0SW50ZXJwb2xhdGVMaW5rRm4oc2NvcGUsIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudCgpLFxuICAgICAgICAgICAgICAgIGJpbmRpbmdzID0gcGFyZW50LmRhdGEoJyRiaW5kaW5nJykgfHwgW107XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKGludGVycG9sYXRlRm4pO1xuICAgICAgICAgICAgc2FmZUFkZENsYXNzKHBhcmVudC5kYXRhKCckYmluZGluZycsIGJpbmRpbmdzKSwgJ25nLWJpbmRpbmcnKTtcbiAgICAgICAgICAgIHNjb3BlLiR3YXRjaChpbnRlcnBvbGF0ZUZuLCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUZuV2F0Y2hBY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgbm9kZVswXS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZ2V0VHJ1c3RlZENvbnRleHQobm9kZSwgYXR0ck5vcm1hbGl6ZWROYW1lKSB7XG4gICAgICBpZiAoYXR0ck5vcm1hbGl6ZWROYW1lID09IFwic3JjZG9jXCIpIHtcbiAgICAgICAgcmV0dXJuICRzY2UuSFRNTDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBub2RlTmFtZV8obm9kZSk7XG4gICAgICAvLyBtYWN0aW9uW3hsaW5rOmhyZWZdIGNhbiBzb3VyY2UgU1ZHLiAgSXQncyBub3QgbGltaXRlZCB0byA8bWFjdGlvbj4uXG4gICAgICBpZiAoYXR0ck5vcm1hbGl6ZWROYW1lID09IFwieGxpbmtIcmVmXCIgfHxcbiAgICAgICAgICAodGFnID09IFwiRk9STVwiICYmIGF0dHJOb3JtYWxpemVkTmFtZSA9PSBcImFjdGlvblwiKSB8fFxuICAgICAgICAgICh0YWcgIT0gXCJJTUdcIiAmJiAoYXR0ck5vcm1hbGl6ZWROYW1lID09IFwic3JjXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyTm9ybWFsaXplZE5hbWUgPT0gXCJuZ1NyY1wiKSkpIHtcbiAgICAgICAgcmV0dXJuICRzY2UuUkVTT1VSQ0VfVVJMO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkQXR0ckludGVycG9sYXRlRGlyZWN0aXZlKG5vZGUsIGRpcmVjdGl2ZXMsIHZhbHVlLCBuYW1lKSB7XG4gICAgICB2YXIgaW50ZXJwb2xhdGVGbiA9ICRpbnRlcnBvbGF0ZSh2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIC8vIG5vIGludGVycG9sYXRpb24gZm91bmQgLT4gaWdub3JlXG4gICAgICBpZiAoIWludGVycG9sYXRlRm4pIHJldHVybjtcblxuXG4gICAgICBpZiAobmFtZSA9PT0gXCJtdWx0aXBsZVwiICYmIG5vZGVOYW1lXyhub2RlKSA9PT0gXCJTRUxFQ1RcIikge1xuICAgICAgICB0aHJvdyAkY29tcGlsZU1pbkVycihcInNlbG11bHRpXCIsXG4gICAgICAgICAgICBcIkJpbmRpbmcgdG8gdGhlICdtdWx0aXBsZScgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQuIEVsZW1lbnQ6IHswfVwiLFxuICAgICAgICAgICAgc3RhcnRpbmdUYWcobm9kZSkpO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RpdmVzLnB1c2goe1xuICAgICAgICBwcmlvcml0eTogMTAwLFxuICAgICAgICBjb21waWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHByZTogZnVuY3Rpb24gYXR0ckludGVycG9sYXRlUHJlTGlua0ZuKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgICAgICAgICAgICAgdmFyICQkb2JzZXJ2ZXJzID0gKGF0dHIuJCRvYnNlcnZlcnMgfHwgKGF0dHIuJCRvYnNlcnZlcnMgPSB7fSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKEVWRU5UX0hBTkRMRVJfQVRUUl9SRUdFWFAudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgJGNvbXBpbGVNaW5FcnIoJ25vZG9tZXZlbnRzJyxcbiAgICAgICAgICAgICAgICAgICAgICBcIkludGVycG9sYXRpb25zIGZvciBIVE1MIERPTSBldmVudCBhdHRyaWJ1dGVzIGFyZSBkaXNhbGxvd2VkLiAgUGxlYXNlIHVzZSB0aGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5nLSB2ZXJzaW9ucyAoc3VjaCBhcyBuZy1jbGljayBpbnN0ZWFkIG9mIG9uY2xpY2spIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaW50ZXJwb2xhdGUgYWdhaW4sIGluIGNhc2UgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gYnkgYW5vdGhlciBkaXJlY3RpdmUncyBjb21waWxlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUoYXR0cltuYW1lXSwgdHJ1ZSwgZ2V0VHJ1c3RlZENvbnRleHQobm9kZSwgbmFtZSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYXR0cmlidXRlIHdhcyB1cGRhdGVkIHNvIHRoYXQgdGhlcmUgaXMgbm8gaW50ZXJwb2xhdGlvbiBnb2luZyBvbiB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgYW55IG9ic2VydmVyc1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJwb2xhdGVGbikgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhpKTogdGhpcyBzaG91bGQgbGlrZWx5IGJlIGF0dHIuJHNldChuYW1lLCBpdGVycG9sYXRlRm4oc2NvcGUpIHNvIHRoYXQgd2UgcmVzZXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIGF0dHIgdmFsdWVcbiAgICAgICAgICAgICAgICBhdHRyW25hbWVdID0gaW50ZXJwb2xhdGVGbihzY29wZSk7XG4gICAgICAgICAgICAgICAgKCQkb2JzZXJ2ZXJzW25hbWVdIHx8ICgkJG9ic2VydmVyc1tuYW1lXSA9IFtdKSkuJCRpbnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgKGF0dHIuJCRvYnNlcnZlcnMgJiYgYXR0ci4kJG9ic2VydmVyc1tuYW1lXS4kJHNjb3BlIHx8IHNjb3BlKS5cbiAgICAgICAgICAgICAgICAgICR3YXRjaChpbnRlcnBvbGF0ZUZuLCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUZuV2F0Y2hBY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciBjbGFzcyBhdHRyaWJ1dGUgYWRkaXRpb24gKyByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgIC8vc28gdGhhdCBjbGFzcyBjaGFuZ2VzIGNhbiB0YXAgaW50byB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vaG9va3MgcHJvdmlkZWQgYnkgdGhlICRhbmltYXRlIHNlcnZpY2UuIEJlIHN1cmUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIGFuaW1hdGlvbnMgd2hlbiB0aGUgZmlyc3QgZGlnZXN0IG9jY3VycyAod2hlblxuICAgICAgICAgICAgICAgICAgICAvL2JvdGggdGhlIG5ldyBhbmQgdGhlIG9sZCB2YWx1ZXMgYXJlIHRoZSBzYW1lKSBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBDU1MgY2xhc3NlcyBhcmUgdGhlIG5vbi1pbnRlcnBvbGF0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGlmKG5hbWUgPT09ICdjbGFzcycgJiYgbmV3VmFsdWUgIT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyLiR1cGRhdGVDbGFzcyhuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHIuJHNldChuYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHNwZWNpYWwganFMaXRlLnJlcGxhY2VXaXRoLCB3aGljaCBjYW4gcmVwbGFjZSBpdGVtcyB3aGljaFxuICAgICAqIGhhdmUgbm8gcGFyZW50cywgcHJvdmlkZWQgdGhhdCB0aGUgY29udGFpbmluZyBqcUxpdGUgY29sbGVjdGlvbiBpcyBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SnFMaXRlPX0gJHJvb3RFbGVtZW50IFRoZSByb290IG9mIHRoZSBjb21waWxlIHRyZWUuIFVzZWQgc28gdGhhdCB3ZSBjYW4gcmVwbGFjZSBub2Rlc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgICAqIEBwYXJhbSB7SnFMaXRlfSBlbGVtZW50c1RvUmVtb3ZlIFRoZSBqcUxpdGUgZWxlbWVudCB3aGljaCB3ZSBhcmUgZ29pbmcgdG8gcmVwbGFjZS4gV2Uga2VlcFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzaGVsbCwgYnV0IHJlcGxhY2UgaXRzIERPTSBub2RlIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgVGhlIG5ldyBET00gbm9kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlV2l0aCgkcm9vdEVsZW1lbnQsIGVsZW1lbnRzVG9SZW1vdmUsIG5ld05vZGUpIHtcbiAgICAgIHZhciBmaXJzdEVsZW1lbnRUb1JlbW92ZSA9IGVsZW1lbnRzVG9SZW1vdmVbMF0sXG4gICAgICAgICAgcmVtb3ZlQ291bnQgPSBlbGVtZW50c1RvUmVtb3ZlLmxlbmd0aCxcbiAgICAgICAgICBwYXJlbnQgPSBmaXJzdEVsZW1lbnRUb1JlbW92ZS5wYXJlbnROb2RlLFxuICAgICAgICAgIGksIGlpO1xuXG4gICAgICBpZiAoJHJvb3RFbGVtZW50KSB7XG4gICAgICAgIGZvcihpID0gMCwgaWkgPSAkcm9vdEVsZW1lbnQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGlmICgkcm9vdEVsZW1lbnRbaV0gPT0gZmlyc3RFbGVtZW50VG9SZW1vdmUpIHtcbiAgICAgICAgICAgICRyb290RWxlbWVudFtpKytdID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpLCBqMiA9IGogKyByZW1vdmVDb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICBqaiA9ICRyb290RWxlbWVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgIGogPCBqajsgaisrLCBqMisrKSB7XG4gICAgICAgICAgICAgIGlmIChqMiA8IGpqKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RFbGVtZW50W2pdID0gJHJvb3RFbGVtZW50W2oyXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgJHJvb3RFbGVtZW50W2pdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcm9vdEVsZW1lbnQubGVuZ3RoIC09IHJlbW92ZUNvdW50IC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgZmlyc3RFbGVtZW50VG9SZW1vdmUpO1xuICAgICAgfVxuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZmlyc3RFbGVtZW50VG9SZW1vdmUpO1xuICAgICAgbmV3Tm9kZVtqcUxpdGUuZXhwYW5kb10gPSBmaXJzdEVsZW1lbnRUb1JlbW92ZVtqcUxpdGUuZXhwYW5kb107XG4gICAgICBmb3IgKHZhciBrID0gMSwga2sgPSBlbGVtZW50c1RvUmVtb3ZlLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1RvUmVtb3ZlW2tdO1xuICAgICAgICBqcUxpdGUoZWxlbWVudCkucmVtb3ZlKCk7IC8vIG11c3QgZG8gdGhpcyB3YXkgdG8gY2xlYW4gdXAgZXhwYW5kb1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgZGVsZXRlIGVsZW1lbnRzVG9SZW1vdmVba107XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzVG9SZW1vdmVbMF0gPSBuZXdOb2RlO1xuICAgICAgZWxlbWVudHNUb1JlbW92ZS5sZW5ndGggPSAxO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY2xvbmVBbmRBbm5vdGF0ZUZuKGZuLCBhbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uKCkgeyByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfSwgZm4sIGFubm90YXRpb24pO1xuICAgIH1cbiAgfV07XG59XG5cbnZhciBQUkVGSVhfUkVHRVhQID0gL14oeFtcXDpcXC1fXXxkYXRhW1xcOlxcLV9dKS9pO1xuLyoqXG4gKiBDb252ZXJ0cyBhbGwgYWNjZXB0ZWQgZGlyZWN0aXZlcyBmb3JtYXQgaW50byBwcm9wZXIgZGlyZWN0aXZlIG5hbWUuXG4gKiBBbGwgb2YgdGhlc2Ugd2lsbCBiZWNvbWUgJ215RGlyZWN0aXZlJzpcbiAqICAgbXk6RGlyZWN0aXZlXG4gKiAgIG15LWRpcmVjdGl2ZVxuICogICB4LW15LWRpcmVjdGl2ZVxuICogICBkYXRhLW15OmRpcmVjdGl2ZVxuICpcbiAqIEFsc28gdGhlcmUgaXMgc3BlY2lhbCBjYXNlIGZvciBNb3ogcHJlZml4IHN0YXJ0aW5nIHdpdGggdXBwZXIgY2FzZSBsZXR0ZXIuXG4gKiBAcGFyYW0gbmFtZSBOYW1lIHRvIG5vcm1hbGl6ZVxuICovXG5mdW5jdGlvbiBkaXJlY3RpdmVOb3JtYWxpemUobmFtZSkge1xuICByZXR1cm4gY2FtZWxDYXNlKG5hbWUucmVwbGFjZShQUkVGSVhfUkVHRVhQLCAnJykpO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHNoYXJlZCBvYmplY3QgYmV0d2VlbiBkaXJlY3RpdmUgY29tcGlsZSAvIGxpbmtpbmcgZnVuY3Rpb25zIHdoaWNoIGNvbnRhaW5zIG5vcm1hbGl6ZWQgRE9NXG4gKiBlbGVtZW50IGF0dHJpYnV0ZXMuIFRoZSB2YWx1ZXMgcmVmbGVjdCBjdXJyZW50IGJpbmRpbmcgc3RhdGUgYHt7IH19YC4gVGhlIG5vcm1hbGl6YXRpb24gaXNcbiAqIG5lZWRlZCBzaW5jZSBhbGwgb2YgdGhlc2UgYXJlIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCBpbiBBbmd1bGFyOlxuICpcbiAqICAgIDxzcGFuIG5nOmJpbmQ9XCJhXCIgbmctYmluZD1cImFcIiBkYXRhLW5nLWJpbmQ9XCJhXCIgeC1uZy1iaW5kPVwiYVwiPlxuICovXG5cbi8qKlxuICogQG5nZG9jIHByb3BlcnR5XG4gKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkYXR0clxuICogQHByb3BlcnR5T2YgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IEEgbWFwIG9mIERPTSBlbGVtZW50IGF0dHJpYnV0ZSBuYW1lcyB0byB0aGUgbm9ybWFsaXplZCBuYW1lLiBUaGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgICBuZWVkZWQgdG8gZG8gcmV2ZXJzZSBsb29rdXAgZnJvbSBub3JtYWxpemVkIG5hbWUgYmFjayB0byBhY3R1YWwgbmFtZS5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBuZy4kY29tcGlsZS5kaXJlY3RpdmUuQXR0cmlidXRlcyMkc2V0XG4gKiBAbWV0aG9kT2YgbmcuJGNvbXBpbGUuZGlyZWN0aXZlLkF0dHJpYnV0ZXNcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2V0IERPTSBlbGVtZW50IGF0dHJpYnV0ZSB2YWx1ZS5cbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTm9ybWFsaXplZCBlbGVtZW50IGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBtb2RpZnkuIFRoZSBuYW1lIGlzXG4gKiAgICAgICAgICByZXZlcnMgdHJhbnNsYXRlZCB1c2luZyB0aGUge0BsaW5rIG5nLiRjb21waWxlLmRpcmVjdGl2ZS5BdHRyaWJ1dGVzIyRhdHRyICRhdHRyfVxuICogICAgICAgICAgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG8uIFRoZSB2YWx1ZSBjYW4gYmUgYW4gaW50ZXJwb2xhdGVkIHN0cmluZy5cbiAqL1xuXG5cblxuLyoqXG4gKiBDbG9zdXJlIGNvbXBpbGVyIHR5cGUgaW5mb3JtYXRpb25cbiAqL1xuXG5mdW5jdGlvbiBub2Rlc2V0TGlua2luZ0ZuKFxuICAvKiBhbmd1bGFyLlNjb3BlICovIHNjb3BlLFxuICAvKiBOb2RlTGlzdCAqLyBub2RlTGlzdCxcbiAgLyogRWxlbWVudCAqLyByb290RWxlbWVudCxcbiAgLyogZnVuY3Rpb24oRnVuY3Rpb24pICovIGJvdW5kVHJhbnNjbHVkZUZuXG4pe31cblxuZnVuY3Rpb24gZGlyZWN0aXZlTGlua2luZ0ZuKFxuICAvKiBub2Rlc2V0TGlua2luZ0ZuICovIG5vZGVzZXRMaW5raW5nRm4sXG4gIC8qIGFuZ3VsYXIuU2NvcGUgKi8gc2NvcGUsXG4gIC8qIE5vZGUgKi8gbm9kZSxcbiAgLyogRWxlbWVudCAqLyByb290RWxlbWVudCxcbiAgLyogZnVuY3Rpb24oRnVuY3Rpb24pICovIGJvdW5kVHJhbnNjbHVkZUZuXG4pe31cblxuZnVuY3Rpb24gdG9rZW5EaWZmZXJlbmNlKHN0cjEsIHN0cjIpIHtcbiAgdmFyIHZhbHVlcyA9ICcnLFxuICAgICAgdG9rZW5zMSA9IHN0cjEuc3BsaXQoL1xccysvKSxcbiAgICAgIHRva2VuczIgPSBzdHIyLnNwbGl0KC9cXHMrLyk7XG5cbiAgb3V0ZXI6XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0b2tlbnMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zMVtpXTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgdG9rZW5zMi5sZW5ndGg7IGorKykge1xuICAgICAgaWYodG9rZW4gPT0gdG9rZW5zMltqXSkgY29udGludWUgb3V0ZXI7XG4gICAgfVxuICAgIHZhbHVlcyArPSAodmFsdWVzLmxlbmd0aCA+IDAgPyAnICcgOiAnJykgKyB0b2tlbjtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRjb250cm9sbGVyUHJvdmlkZXJcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIHtAbGluayBuZy4kY29udHJvbGxlciAkY29udHJvbGxlciBzZXJ2aWNlfSBpcyB1c2VkIGJ5IEFuZ3VsYXIgdG8gY3JlYXRlIG5ld1xuICogY29udHJvbGxlcnMuXG4gKlxuICogVGhpcyBwcm92aWRlciBhbGxvd3MgY29udHJvbGxlciByZWdpc3RyYXRpb24gdmlhIHRoZVxuICoge0BsaW5rIG5nLiRjb250cm9sbGVyUHJvdmlkZXIjbWV0aG9kc19yZWdpc3RlciByZWdpc3Rlcn0gbWV0aG9kLlxuICovXG5mdW5jdGlvbiAkQ29udHJvbGxlclByb3ZpZGVyKCkge1xuICB2YXIgY29udHJvbGxlcnMgPSB7fSxcbiAgICAgIENOVFJMX1JFRyA9IC9eKFxcUyspKFxccythc1xccysoXFx3KykpPyQvO1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy4kY29udHJvbGxlclByb3ZpZGVyI3JlZ2lzdGVyXG4gICAqIEBtZXRob2RPZiBuZy4kY29udHJvbGxlclByb3ZpZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gbmFtZSBDb250cm9sbGVyIG5hbWUsIG9yIGFuIG9iamVjdCBtYXAgb2YgY29udHJvbGxlcnMgd2hlcmUgdGhlIGtleXMgYXJlXG4gICAqICAgIHRoZSBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIGNvbnN0cnVjdG9ycy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheX0gY29uc3RydWN0b3IgQ29udHJvbGxlciBjb25zdHJ1Y3RvciBmbiAob3B0aW9uYWxseSBkZWNvcmF0ZWQgd2l0aCBESVxuICAgKiAgICBhbm5vdGF0aW9ucyBpbiB0aGUgYXJyYXkgbm90YXRpb24pLlxuICAgKi9cbiAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIGNvbnN0cnVjdG9yKSB7XG4gICAgYXNzZXJ0Tm90SGFzT3duUHJvcGVydHkobmFtZSwgJ2NvbnRyb2xsZXInKTtcbiAgICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgIGV4dGVuZChjb250cm9sbGVycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRyb2xsZXJzW25hbWVdID0gY29uc3RydWN0b3I7XG4gICAgfVxuICB9O1xuXG5cbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRpbmplY3RvciwgJHdpbmRvdykge1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgbmcuJGNvbnRyb2xsZXJcbiAgICAgKiBAcmVxdWlyZXMgJGluamVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gY29uc3RydWN0b3IgSWYgY2FsbGVkIHdpdGggYSBmdW5jdGlvbiB0aGVuIGl0J3MgY29uc2lkZXJlZCB0byBiZSB0aGVcbiAgICAgKiAgICBjb250cm9sbGVyIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBPdGhlcndpc2UgaXQncyBjb25zaWRlcmVkIHRvIGJlIGEgc3RyaW5nIHdoaWNoIGlzIHVzZWRcbiAgICAgKiAgICB0byByZXRyaWV2ZSB0aGUgY29udHJvbGxlciBjb25zdHJ1Y3RvciB1c2luZyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAqXG4gICAgICogICAgKiBjaGVjayBpZiBhIGNvbnRyb2xsZXIgd2l0aCBnaXZlbiBuYW1lIGlzIHJlZ2lzdGVyZWQgdmlhIGAkY29udHJvbGxlclByb3ZpZGVyYFxuICAgICAqICAgICogY2hlY2sgaWYgZXZhbHVhdGluZyB0aGUgc3RyaW5nIG9uIHRoZSBjdXJyZW50IHNjb3BlIHJldHVybnMgYSBjb25zdHJ1Y3RvclxuICAgICAqICAgICogY2hlY2sgYHdpbmRvd1tjb25zdHJ1Y3Rvcl1gIG9uIHRoZSBnbG9iYWwgYHdpbmRvd2Agb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jYWxzIEluamVjdGlvbiBsb2NhbHMgZm9yIENvbnRyb2xsZXIuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBJbnN0YW5jZSBvZiBnaXZlbiBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogYCRjb250cm9sbGVyYCBzZXJ2aWNlIGlzIHJlc3BvbnNpYmxlIGZvciBpbnN0YW50aWF0aW5nIGNvbnRyb2xsZXJzLlxuICAgICAqXG4gICAgICogSXQncyBqdXN0IGEgc2ltcGxlIGNhbGwgdG8ge0BsaW5rIEFVVE8uJGluamVjdG9yICRpbmplY3Rvcn0sIGJ1dCBleHRyYWN0ZWQgaW50b1xuICAgICAqIGEgc2VydmljZSwgc28gdGhhdCBvbmUgY2FuIG92ZXJyaWRlIHRoaXMgc2VydmljZSB3aXRoIHtAbGluayBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xNjQ5Nzg4XG4gICAgICogQkMgdmVyc2lvbn0uXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV4cHJlc3Npb24sIGxvY2Fscykge1xuICAgICAgdmFyIGluc3RhbmNlLCBtYXRjaCwgY29uc3RydWN0b3IsIGlkZW50aWZpZXI7XG5cbiAgICAgIGlmKGlzU3RyaW5nKGV4cHJlc3Npb24pKSB7XG4gICAgICAgIG1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChDTlRSTF9SRUcpLFxuICAgICAgICBjb25zdHJ1Y3RvciA9IG1hdGNoWzFdLFxuICAgICAgICBpZGVudGlmaWVyID0gbWF0Y2hbM107XG4gICAgICAgIGV4cHJlc3Npb24gPSBjb250cm9sbGVycy5oYXNPd25Qcm9wZXJ0eShjb25zdHJ1Y3RvcilcbiAgICAgICAgICAgID8gY29udHJvbGxlcnNbY29uc3RydWN0b3JdXG4gICAgICAgICAgICA6IGdldHRlcihsb2NhbHMuJHNjb3BlLCBjb25zdHJ1Y3RvciwgdHJ1ZSkgfHwgZ2V0dGVyKCR3aW5kb3csIGNvbnN0cnVjdG9yLCB0cnVlKTtcblxuICAgICAgICBhc3NlcnRBcmdGbihleHByZXNzaW9uLCBjb25zdHJ1Y3RvciwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlID0gJGluamVjdG9yLmluc3RhbnRpYXRlKGV4cHJlc3Npb24sIGxvY2Fscyk7XG5cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghKGxvY2FscyAmJiB0eXBlb2YgbG9jYWxzLiRzY29wZSA9PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICB0aHJvdyBtaW5FcnIoJyRjb250cm9sbGVyJykoJ25vc2NwJyxcbiAgICAgICAgICAgICAgXCJDYW5ub3QgZXhwb3J0IGNvbnRyb2xsZXIgJ3swfScgYXMgJ3sxfSchIE5vICRzY29wZSBvYmplY3QgcHJvdmlkZWQgdmlhIGBsb2NhbHNgLlwiLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RvciB8fCBleHByZXNzaW9uLm5hbWUsIGlkZW50aWZpZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxzLiRzY29wZVtpZGVudGlmaWVyXSA9IGluc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfV07XG59XG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgbmcuJGRvY3VtZW50XG4gKiBAcmVxdWlyZXMgJHdpbmRvd1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSB7QGxpbmsgYW5ndWxhci5lbGVtZW50IGpRdWVyeSAobGl0ZSl9LXdyYXBwZWQgcmVmZXJlbmNlIHRvIHRoZSBicm93c2VyJ3MgYHdpbmRvdy5kb2N1bWVudGBcbiAqIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uICREb2N1bWVudFByb3ZpZGVyKCl7XG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsIGZ1bmN0aW9uKHdpbmRvdyl7XG4gICAgcmV0dXJuIGpxTGl0ZSh3aW5kb3cuZG9jdW1lbnQpO1xuICB9XTtcbn1cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIG5nLiRleGNlcHRpb25IYW5kbGVyXG4gKiBAcmVxdWlyZXMgJGxvZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW55IHVuY2F1Z2h0IGV4Y2VwdGlvbiBpbiBhbmd1bGFyIGV4cHJlc3Npb25zIGlzIGRlbGVnYXRlZCB0byB0aGlzIHNlcnZpY2UuXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgZGVsZWdhdGVzIHRvIGAkbG9nLmVycm9yYCB3aGljaCBsb2dzIGl0IGludG9cbiAqIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gKiBcbiAqIEluIHVuaXQgdGVzdHMsIGlmIGBhbmd1bGFyLW1vY2tzLmpzYCBpcyBsb2FkZWQsIHRoaXMgc2VydmljZSBpcyBvdmVycmlkZGVuIGJ5XG4gKiB7QGxpbmsgbmdNb2NrLiRleGNlcHRpb25IYW5kbGVyIG1vY2sgJGV4Y2VwdGlvbkhhbmRsZXJ9IHdoaWNoIGFpZHMgaW4gdGVzdGluZy5cbiAqXG4gKiAjIyBFeGFtcGxlOlxuICogXG4gKiA8cHJlPlxuICogICBhbmd1bGFyLm1vZHVsZSgnZXhjZXB0aW9uT3ZlcnJpZGUnLCBbXSkuZmFjdG9yeSgnJGV4Y2VwdGlvbkhhbmRsZXInLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgcmV0dXJuIGZ1bmN0aW9uIChleGNlcHRpb24sIGNhdXNlKSB7XG4gKiAgICAgICBleGNlcHRpb24ubWVzc2FnZSArPSAnIChjYXVzZWQgYnkgXCInICsgY2F1c2UgKyAnXCIpJztcbiAqICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAqICAgICB9O1xuICogICB9KTtcbiAqIDwvcHJlPlxuICogXG4gKiBUaGlzIGV4YW1wbGUgd2lsbCBvdmVycmlkZSB0aGUgbm9ybWFsIGFjdGlvbiBvZiBgJGV4Y2VwdGlvbkhhbmRsZXJgLCB0byBtYWtlIGFuZ3VsYXJcbiAqIGV4Y2VwdGlvbnMgZmFpbCBoYXJkIHdoZW4gdGhleSBoYXBwZW4sIGluc3RlYWQgb2YganVzdCBsb2dnaW5nIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGV4Y2VwdGlvbiBFeGNlcHRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gY2F1c2Ugb3B0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNvbnRleHQgaW4gd2hpY2hcbiAqICAgICAgIHRoZSBlcnJvciB3YXMgdGhyb3duLlxuICpcbiAqL1xuZnVuY3Rpb24gJEV4Y2VwdGlvbkhhbmRsZXJQcm92aWRlcigpIHtcbiAgdGhpcy4kZ2V0ID0gWyckbG9nJywgZnVuY3Rpb24oJGxvZykge1xuICAgIHJldHVybiBmdW5jdGlvbihleGNlcHRpb24sIGNhdXNlKSB7XG4gICAgICAkbG9nLmVycm9yLmFwcGx5KCRsb2csIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfV07XG59XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGtleSB2YWx1ZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVycyBSYXcgaGVhZGVycyBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge09iamVjdH0gUGFyc2VkIGhlYWRlcnMgYXMga2V5IHZhbHVlIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge30sIGtleSwgdmFsLCBpO1xuXG4gIGlmICghaGVhZGVycykgcmV0dXJuIHBhcnNlZDtcblxuICBmb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxvd2VyY2FzZSh0cmltKGxpbmUuc3Vic3RyKDAsIGkpKSk7XG4gICAgdmFsID0gdHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldICs9ICcsICcgKyB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gcGFyc2VkIGhlYWRlcnMuXG4gKlxuICogSGVhZGVycyBhcmUgbGF6eSBwYXJzZWQgd2hlbiBmaXJzdCByZXF1ZXN0ZWQuXG4gKiBAc2VlIHBhcnNlSGVhZGVyc1xuICpcbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpfSBoZWFkZXJzIEhlYWRlcnMgdG8gcHJvdmlkZSBhY2Nlc3MgdG8uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nPSl9IFJldHVybnMgYSBnZXR0ZXIgZnVuY3Rpb24gd2hpY2ggaWYgY2FsbGVkIHdpdGg6XG4gKlxuICogICAtIGlmIGNhbGxlZCB3aXRoIHNpbmdsZSBhbiBhcmd1bWVudCByZXR1cm5zIGEgc2luZ2xlIGhlYWRlciB2YWx1ZSBvciBudWxsXG4gKiAgIC0gaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGhlYWRlcnMuXG4gKi9cbmZ1bmN0aW9uIGhlYWRlcnNHZXR0ZXIoaGVhZGVycykge1xuICB2YXIgaGVhZGVyc09iaiA9IGlzT2JqZWN0KGhlYWRlcnMpID8gaGVhZGVycyA6IHVuZGVmaW5lZDtcblxuICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghaGVhZGVyc09iaikgaGVhZGVyc09iaiA9ICBwYXJzZUhlYWRlcnMoaGVhZGVycyk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGhlYWRlcnNPYmpbbG93ZXJjYXNlKG5hbWUpXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzT2JqO1xuICB9O1xufVxuXG5cbi8qKlxuICogQ2hhaW4gYWxsIGdpdmVuIGZ1bmN0aW9uc1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgYm90aCByZXF1ZXN0IGFuZCByZXNwb25zZSB0cmFuc2Zvcm1pbmdcbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgRGF0YSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZz0pfSBoZWFkZXJzIEh0dHAgaGVhZGVycyBnZXR0ZXIgZm4uXG4gKiBAcGFyYW0geyhmdW5jdGlvbnxBcnJheS48ZnVuY3Rpb24+KX0gZm5zIEZ1bmN0aW9uIG9yIGFuIGFycmF5IG9mIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm5zIHsqfSBUcmFuc2Zvcm1lZCBkYXRhLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICBpZiAoaXNGdW5jdGlvbihmbnMpKVxuICAgIHJldHVybiBmbnMoZGF0YSwgaGVhZGVycyk7XG5cbiAgZm9yRWFjaChmbnMsIGZ1bmN0aW9uKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuXG5mdW5jdGlvbiBpc1N1Y2Nlc3Moc3RhdHVzKSB7XG4gIHJldHVybiAyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8IDMwMDtcbn1cblxuXG5mdW5jdGlvbiAkSHR0cFByb3ZpZGVyKCkge1xuICB2YXIgSlNPTl9TVEFSVCA9IC9eXFxzKihcXFt8XFx7W15cXHtdKS8sXG4gICAgICBKU09OX0VORCA9IC9bXFx9XFxdXVxccyokLyxcbiAgICAgIFBST1RFQ1RJT05fUFJFRklYID0gL15cXClcXF1cXH0nLD9cXG4vLFxuICAgICAgQ09OVEVOVF9UWVBFX0FQUExJQ0FUSU9OX0pTT04gPSB7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnfTtcblxuICB2YXIgZGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzID0ge1xuICAgIC8vIHRyYW5zZm9ybSBpbmNvbWluZyByZXNwb25zZSBkYXRhXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbihkYXRhKSB7XG4gICAgICBpZiAoaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgLy8gc3RyaXAganNvbiB2dWxuZXJhYmlsaXR5IHByb3RlY3Rpb24gcHJlZml4XG4gICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoUFJPVEVDVElPTl9QUkVGSVgsICcnKTtcbiAgICAgICAgaWYgKEpTT05fU1RBUlQudGVzdChkYXRhKSAmJiBKU09OX0VORC50ZXN0KGRhdGEpKVxuICAgICAgICAgIGRhdGEgPSBmcm9tSnNvbihkYXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1dLFxuXG4gICAgLy8gdHJhbnNmb3JtIG91dGdvaW5nIHJlcXVlc3QgZGF0YVxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QoZCkgJiYgIWlzRmlsZShkKSA/IHRvSnNvbihkKSA6IGQ7XG4gICAgfV0sXG5cbiAgICAvLyBkZWZhdWx0IGhlYWRlcnNcbiAgICBoZWFkZXJzOiB7XG4gICAgICBjb21tb246IHtcbiAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgICB9LFxuICAgICAgcG9zdDogICBDT05URU5UX1RZUEVfQVBQTElDQVRJT05fSlNPTixcbiAgICAgIHB1dDogICAgQ09OVEVOVF9UWVBFX0FQUExJQ0FUSU9OX0pTT04sXG4gICAgICBwYXRjaDogIENPTlRFTlRfVFlQRV9BUFBMSUNBVElPTl9KU09OXG4gICAgfSxcblxuICAgIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gICAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nXG4gIH07XG5cbiAgLyoqXG4gICAqIEFyZSBvcmRlcmVkIGJ5IHJlcXVlc3QsIGkuZS4gdGhleSBhcmUgYXBwbGllZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbiAgICogYXJyYXksIG9uIHJlcXVlc3QsIGJ1dCByZXZlcnNlIG9yZGVyLCBvbiByZXNwb25zZS5cbiAgICovXG4gIHZhciBpbnRlcmNlcHRvckZhY3RvcmllcyA9IHRoaXMuaW50ZXJjZXB0b3JzID0gW107XG5cbiAgLyoqXG4gICAqIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHJlc3BvbnNlIGludGVyY2VwdG9ycyBhcmUgb3JkZXJlZCBieSB0aGUgb3JkZXIgaW4gd2hpY2hcbiAgICogdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcmVzcG9uc2UuIChUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBpbnRlcmNlcHRvckZhY3RvcmllcylcbiAgICovXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yRmFjdG9yaWVzID0gdGhpcy5yZXNwb25zZUludGVyY2VwdG9ycyA9IFtdO1xuXG4gIHRoaXMuJGdldCA9IFsnJGh0dHBCYWNrZW5kJywgJyRicm93c2VyJywgJyRjYWNoZUZhY3RvcnknLCAnJHJvb3RTY29wZScsICckcScsICckaW5qZWN0b3InLFxuICAgICAgZnVuY3Rpb24oJGh0dHBCYWNrZW5kLCAkYnJvd3NlciwgJGNhY2hlRmFjdG9yeSwgJHJvb3RTY29wZSwgJHEsICRpbmplY3Rvcikge1xuXG4gICAgdmFyIGRlZmF1bHRDYWNoZSA9ICRjYWNoZUZhY3RvcnkoJyRodHRwJyk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcmNlcHRvcnMgc3RvcmVkIGluIHJldmVyc2Ugb3JkZXIuIElubmVyIGludGVyY2VwdG9ycyBiZWZvcmUgb3V0ZXIgaW50ZXJjZXB0b3JzLlxuICAgICAqIFRoZSByZXZlcnNhbCBpcyBuZWVkZWQgc28gdGhhdCB3ZSBjYW4gYnVpbGQgdXAgdGhlIGludGVyY2VwdGlvbiBjaGFpbiBhcm91bmQgdGhlXG4gICAgICogc2VydmVyIHJlcXVlc3QuXG4gICAgICovXG4gICAgdmFyIHJldmVyc2VkSW50ZXJjZXB0b3JzID0gW107XG5cbiAgICBmb3JFYWNoKGludGVyY2VwdG9yRmFjdG9yaWVzLCBmdW5jdGlvbihpbnRlcmNlcHRvckZhY3RvcnkpIHtcbiAgICAgIHJldmVyc2VkSW50ZXJjZXB0b3JzLnVuc2hpZnQoaXNTdHJpbmcoaW50ZXJjZXB0b3JGYWN0b3J5KVxuICAgICAgICAgID8gJGluamVjdG9yLmdldChpbnRlcmNlcHRvckZhY3RvcnkpIDogJGluamVjdG9yLmludm9rZShpbnRlcmNlcHRvckZhY3RvcnkpKTtcbiAgICB9KTtcblxuICAgIGZvckVhY2gocmVzcG9uc2VJbnRlcmNlcHRvckZhY3RvcmllcywgZnVuY3Rpb24oaW50ZXJjZXB0b3JGYWN0b3J5LCBpbmRleCkge1xuICAgICAgdmFyIHJlc3BvbnNlRm4gPSBpc1N0cmluZyhpbnRlcmNlcHRvckZhY3RvcnkpXG4gICAgICAgICAgPyAkaW5qZWN0b3IuZ2V0KGludGVyY2VwdG9yRmFjdG9yeSlcbiAgICAgICAgICA6ICRpbmplY3Rvci5pbnZva2UoaW50ZXJjZXB0b3JGYWN0b3J5KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNwb25zZSBpbnRlcmNlcHRvcnMgZ28gYmVmb3JlIFwiYXJvdW5kXCIgaW50ZXJjZXB0b3JzIChubyByZWFsIHJlYXNvbiwganVzdFxuICAgICAgICogaGFkIHRvIHBpY2sgb25lLikgQnV0IHRoZXkgYXJlIGFscmVhZHkgcmV2ZXJzZWQsIHNvIHdlIGNhbid0IHVzZSB1bnNoaWZ0LCBoZW5jZVxuICAgICAgICogdGhlIHNwbGljZS5cbiAgICAgICAqL1xuICAgICAgcmV2ZXJzZWRJbnRlcmNlcHRvcnMuc3BsaWNlKGluZGV4LCAwLCB7XG4gICAgICAgIHJlc3BvbnNlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZUZuKCRxLndoZW4ocmVzcG9uc2UpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzcG9uc2VFcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VGbigkcS5yZWplY3QocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIG5nLiRodHRwXG4gICAgICogQHJlcXVpcmVzICRodHRwQmFja2VuZFxuICAgICAqIEByZXF1aXJlcyAkYnJvd3NlclxuICAgICAqIEByZXF1aXJlcyAkY2FjaGVGYWN0b3J5XG4gICAgICogQHJlcXVpcmVzICRyb290U2NvcGVcbiAgICAgKiBAcmVxdWlyZXMgJHFcbiAgICAgKiBAcmVxdWlyZXMgJGluamVjdG9yXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgYCRodHRwYCBzZXJ2aWNlIGlzIGEgY29yZSBBbmd1bGFyIHNlcnZpY2UgdGhhdCBmYWNpbGl0YXRlcyBjb21tdW5pY2F0aW9uIHdpdGggdGhlIHJlbW90ZVxuICAgICAqIEhUVFAgc2VydmVycyB2aWEgdGhlIGJyb3dzZXIncyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4veG1saHR0cHJlcXVlc3RcbiAgICAgKiBYTUxIdHRwUmVxdWVzdH0gb2JqZWN0IG9yIHZpYSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9KU09OUCBKU09OUH0uXG4gICAgICpcbiAgICAgKiBGb3IgdW5pdCB0ZXN0aW5nIGFwcGxpY2F0aW9ucyB0aGF0IHVzZSBgJGh0dHBgIHNlcnZpY2UsIHNlZVxuICAgICAqIHtAbGluayBuZ01vY2suJGh0dHBCYWNrZW5kICRodHRwQmFja2VuZCBtb2NrfS5cbiAgICAgKlxuICAgICAqIEZvciBhIGhpZ2hlciBsZXZlbCBvZiBhYnN0cmFjdGlvbiwgcGxlYXNlIGNoZWNrIG91dCB0aGUge0BsaW5rIG5nUmVzb3VyY2UuJHJlc291cmNlXG4gICAgICogJHJlc291cmNlfSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogVGhlICRodHRwIEFQSSBpcyBiYXNlZCBvbiB0aGUge0BsaW5rIG5nLiRxIGRlZmVycmVkL3Byb21pc2UgQVBJc30gZXhwb3NlZCBieVxuICAgICAqIHRoZSAkcSBzZXJ2aWNlLiBXaGlsZSBmb3Igc2ltcGxlIHVzYWdlIHBhdHRlcm5zIHRoaXMgZG9lc24ndCBtYXR0ZXIgbXVjaCwgZm9yIGFkdmFuY2VkIHVzYWdlXG4gICAgICogaXQgaXMgaW1wb3J0YW50IHRvIGZhbWlsaWFyaXplIHlvdXJzZWxmIHdpdGggdGhlc2UgQVBJcyBhbmQgdGhlIGd1YXJhbnRlZXMgdGhleSBwcm92aWRlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiAjIEdlbmVyYWwgdXNhZ2VcbiAgICAgKiBUaGUgYCRodHRwYCBzZXJ2aWNlIGlzIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQg4oCUIGEgY29uZmlndXJhdGlvbiBvYmplY3Qg4oCUXG4gICAgICogdGhhdCBpcyB1c2VkIHRvIGdlbmVyYXRlIGFuIEhUVFAgcmVxdWVzdCBhbmQgcmV0dXJucyAgYSB7QGxpbmsgbmcuJHEgcHJvbWlzZX1cbiAgICAgKiB3aXRoIHR3byAkaHR0cCBzcGVjaWZpYyBtZXRob2RzOiBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAuXG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqICAgJGh0dHAoe21ldGhvZDogJ0dFVCcsIHVybDogJy9zb21lVXJsJ30pLlxuICAgICAqICAgICBzdWNjZXNzKGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywgaGVhZGVycywgY29uZmlnKSB7XG4gICAgICogICAgICAgLy8gdGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseVxuICAgICAqICAgICAgIC8vIHdoZW4gdGhlIHJlc3BvbnNlIGlzIGF2YWlsYWJsZVxuICAgICAqICAgICB9KS5cbiAgICAgKiAgICAgZXJyb3IoZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcbiAgICAgKiAgICAgICAvLyBjYWxsZWQgYXN5bmNocm9ub3VzbHkgaWYgYW4gZXJyb3Igb2NjdXJzXG4gICAgICogICAgICAgLy8gb3Igc2VydmVyIHJldHVybnMgcmVzcG9uc2Ugd2l0aCBhbiBlcnJvciBzdGF0dXMuXG4gICAgICogICAgIH0pO1xuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogU2luY2UgdGhlIHJldHVybmVkIHZhbHVlIG9mIGNhbGxpbmcgdGhlICRodHRwIGZ1bmN0aW9uIGlzIGEgYHByb21pc2VgLCB5b3UgY2FuIGFsc28gdXNlXG4gICAgICogdGhlIGB0aGVuYCBtZXRob2QgdG8gcmVnaXN0ZXIgY2FsbGJhY2tzLCBhbmQgdGhlc2UgY2FsbGJhY2tzIHdpbGwgcmVjZWl2ZSBhIHNpbmdsZSBhcmd1bWVudCDigJNcbiAgICAgKiBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXNwb25zZS4gU2VlIHRoZSBBUEkgc2lnbmF0dXJlIGFuZCB0eXBlIGluZm8gYmVsb3cgZm9yIG1vcmVcbiAgICAgKiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQSByZXNwb25zZSBzdGF0dXMgY29kZSBiZXR3ZWVuIDIwMCBhbmQgMjk5IGlzIGNvbnNpZGVyZWQgYSBzdWNjZXNzIHN0YXR1cyBhbmRcbiAgICAgKiB3aWxsIHJlc3VsdCBpbiB0aGUgc3VjY2VzcyBjYWxsYmFjayBiZWluZyBjYWxsZWQuIE5vdGUgdGhhdCBpZiB0aGUgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCxcbiAgICAgKiBYTUxIdHRwUmVxdWVzdCB3aWxsIHRyYW5zcGFyZW50bHkgZm9sbG93IGl0LCBtZWFuaW5nIHRoYXQgdGhlIGVycm9yIGNhbGxiYWNrIHdpbGwgbm90IGJlXG4gICAgICogY2FsbGVkIGZvciBzdWNoIHJlc3BvbnNlcy5cbiAgICAgKiBcbiAgICAgKiAjIENhbGxpbmcgJGh0dHAgZnJvbSBvdXRzaWRlIEFuZ3VsYXJKU1xuICAgICAqIFRoZSBgJGh0dHBgIHNlcnZpY2Ugd2lsbCBub3QgYWN0dWFsbHkgc2VuZCB0aGUgcmVxdWVzdCB1bnRpbCB0aGUgbmV4dCBgJGRpZ2VzdCgpYCBpc1xuICAgICAqIGV4ZWN1dGVkLiBOb3JtYWxseSB0aGlzIGlzIG5vdCBhbiBpc3N1ZSwgc2luY2UgYWxtb3N0IGFsbCB0aGUgdGltZSB5b3VyIGNhbGwgdG8gYCRodHRwYCB3aWxsXG4gICAgICogYmUgZnJvbSB3aXRoaW4gYSBgJGFwcGx5KClgIGJsb2NrLlxuICAgICAqIElmIHlvdSBhcmUgY2FsbGluZyBgJGh0dHBgIGZyb20gb3V0c2lkZSBBbmd1bGFyLCB0aGVuIHlvdSBzaG91bGQgd3JhcCBpdCBpbiBhIGNhbGwgdG9cbiAgICAgKiBgJGFwcGx5YCB0byBjYXVzZSBhICRkaWdlc3QgdG8gb2NjdXIgYW5kIGFsc28gdG8gaGFuZGxlIGVycm9ycyBpbiB0aGUgYmxvY2sgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgKiAgICRodHRwKC4uLik7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIFdyaXRpbmcgVW5pdCBUZXN0cyB0aGF0IHVzZSAkaHR0cFxuICAgICAqIFdoZW4gdW5pdCB0ZXN0aW5nIHlvdSBhcmUgbW9zdGx5IHJlc3BvbnNpYmxlIGZvciBzY2hlZHVsaW5nIHRoZSBgJGRpZ2VzdGAgY3ljbGUuIElmIHlvdSBkb1xuICAgICAqIG5vdCB0cmlnZ2VyIGEgYCRkaWdlc3RgIGJlZm9yZSBjYWxsaW5nIGAkaHR0cEJhY2tlbmQuZmx1c2goKWAgdGhlbiB0aGUgcmVxdWVzdCB3aWxsIG5vdCBoYXZlXG4gICAgICogYmVlbiBtYWRlIGFuZCBgJGh0dHBCYWNrZW5kLmV4cGVjdCguLi4pYCBleHBlY3RhdGlvbnMgd2lsbCBmYWlsLiAgVGhlIHNvbHV0aW9uIGlzIHRvIHJ1biB0aGVcbiAgICAgKiBjb2RlIHRoYXQgY2FsbHMgdGhlIGAkaHR0cCgpYCBtZXRob2QgaW5zaWRlIGEgJGFwcGx5IGJsb2NrIGFzIGV4cGxhaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgICAgKiBzZWN0aW9uLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogJGh0dHBCYWNrZW5kLmV4cGVjdEdFVCguLi4pO1xuICAgICAqICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICogICAkaHR0cC5nZXQoLi4uKTtcbiAgICAgKiB9KTtcbiAgICAgKiAkaHR0cEJhY2tlbmQuZmx1c2goKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMgU2hvcnRjdXQgbWV0aG9kc1xuICAgICAqXG4gICAgICogU2luY2UgYWxsIGludm9jYXRpb25zIG9mIHRoZSAkaHR0cCBzZXJ2aWNlIHJlcXVpcmUgcGFzc2luZyBpbiBhbiBIVFRQIG1ldGhvZCBhbmQgVVJMLCBhbmRcbiAgICAgKiBQT1NUL1BVVCByZXF1ZXN0cyByZXF1aXJlIHJlcXVlc3QgZGF0YSB0byBiZSBwcm92aWRlZCBhcyB3ZWxsLCBzaG9ydGN1dCBtZXRob2RzXG4gICAgICogd2VyZSBjcmVhdGVkOlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiAgICRodHRwLmdldCgnL3NvbWVVcmwnKS5zdWNjZXNzKHN1Y2Nlc3NDYWxsYmFjayk7XG4gICAgICogICAkaHR0cC5wb3N0KCcvc29tZVVybCcsIGRhdGEpLnN1Y2Nlc3Moc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqIENvbXBsZXRlIGxpc3Qgb2Ygc2hvcnRjdXQgbWV0aG9kczpcbiAgICAgKlxuICAgICAqIC0ge0BsaW5rIG5nLiRodHRwI21ldGhvZHNfZ2V0ICRodHRwLmdldH1cbiAgICAgKiAtIHtAbGluayBuZy4kaHR0cCNtZXRob2RzX2hlYWQgJGh0dHAuaGVhZH1cbiAgICAgKiAtIHtAbGluayBuZy4kaHR0cCNtZXRob2RzX3Bvc3QgJGh0dHAucG9zdH1cbiAgICAgKiAtIHtAbGluayBuZy4kaHR0cCNtZXRob2RzX3B1dCAkaHR0cC5wdXR9XG4gICAgICogLSB7QGxpbmsgbmcuJGh0dHAjbWV0aG9kc19kZWxldGUgJGh0dHAuZGVsZXRlfVxuICAgICAqIC0ge0BsaW5rIG5nLiRodHRwI21ldGhvZHNfanNvbnAgJGh0dHAuanNvbnB9XG4gICAgICpcbiAgICAgKlxuICAgICAqICMgU2V0dGluZyBIVFRQIEhlYWRlcnNcbiAgICAgKlxuICAgICAqIFRoZSAkaHR0cCBzZXJ2aWNlIHdpbGwgYXV0b21hdGljYWxseSBhZGQgY2VydGFpbiBIVFRQIGhlYWRlcnMgdG8gYWxsIHJlcXVlc3RzLiBUaGVzZSBkZWZhdWx0c1xuICAgICAqIGNhbiBiZSBmdWxseSBjb25maWd1cmVkIGJ5IGFjY2Vzc2luZyB0aGUgYCRodHRwUHJvdmlkZXIuZGVmYXVsdHMuaGVhZGVyc2AgY29uZmlndXJhdGlvblxuICAgICAqIG9iamVjdCwgd2hpY2ggY3VycmVudGx5IGNvbnRhaW5zIHRoaXMgZGVmYXVsdCBjb25maWd1cmF0aW9uOlxuICAgICAqXG4gICAgICogLSBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vbmAgKGhlYWRlcnMgdGhhdCBhcmUgY29tbW9uIGZvciBhbGwgcmVxdWVzdHMpOlxuICAgICAqICAgLSBgQWNjZXB0OiBhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqIC8gKmBcbiAgICAgKiAtIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMucG9zdGA6IChoZWFkZXIgZGVmYXVsdHMgZm9yIFBPU1QgcmVxdWVzdHMpXG4gICAgICogICAtIGBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25gXG4gICAgICogLSBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy5oZWFkZXJzLnB1dGAgKGhlYWRlciBkZWZhdWx0cyBmb3IgUFVUIHJlcXVlc3RzKVxuICAgICAqICAgLSBgQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uYFxuICAgICAqXG4gICAgICogVG8gYWRkIG9yIG92ZXJ3cml0ZSB0aGVzZSBkZWZhdWx0cywgc2ltcGx5IGFkZCBvciByZW1vdmUgYSBwcm9wZXJ0eSBmcm9tIHRoZXNlIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBvYmplY3RzLiBUbyBhZGQgaGVhZGVycyBmb3IgYW4gSFRUUCBtZXRob2Qgb3RoZXIgdGhhbiBQT1NUIG9yIFBVVCwgc2ltcGx5IGFkZCBhIG5ldyBvYmplY3RcbiAgICAgKiB3aXRoIHRoZSBsb3dlcmNhc2VkIEhUVFAgbWV0aG9kIG5hbWUgYXMgdGhlIGtleSwgZS5nLlxuICAgICAqIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLmhlYWRlcnMuZ2V0ID0geyAnTXktSGVhZGVyJyA6ICd2YWx1ZScgfS5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0cyBjYW4gYWxzbyBiZSBzZXQgYXQgcnVudGltZSB2aWEgdGhlIGAkaHR0cC5kZWZhdWx0c2Agb2JqZWN0IGluIHRoZSBzYW1lXG4gICAgICogZmFzaGlvbi4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3VwcGx5IGEgYGhlYWRlcnNgIHByb3BlcnR5IGluIHRoZSBjb25maWcgb2JqZWN0IHBhc3NlZCB3aGVuXG4gICAgICogY2FsbGluZyBgJGh0dHAoY29uZmlnKWAsIHdoaWNoIG92ZXJyaWRlcyB0aGUgZGVmYXVsdHMgd2l0aG91dCBjaGFuZ2luZyB0aGVtIGdsb2JhbGx5LlxuICAgICAqXG4gICAgICpcbiAgICAgKiAjIFRyYW5zZm9ybWluZyBSZXF1ZXN0cyBhbmQgUmVzcG9uc2VzXG4gICAgICpcbiAgICAgKiBCb3RoIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgY2FuIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRyYW5zZm9ybSBmdW5jdGlvbnMuIEJ5IGRlZmF1bHQsIEFuZ3VsYXJcbiAgICAgKiBhcHBsaWVzIHRoZXNlIHRyYW5zZm9ybWF0aW9uczpcbiAgICAgKlxuICAgICAqIFJlcXVlc3QgdHJhbnNmb3JtYXRpb25zOlxuICAgICAqXG4gICAgICogLSBJZiB0aGUgYGRhdGFgIHByb3BlcnR5IG9mIHRoZSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb2JqZWN0IGNvbnRhaW5zIGFuIG9iamVjdCwgc2VyaWFsaXplIGl0XG4gICAgICogICBpbnRvIEpTT04gZm9ybWF0LlxuICAgICAqXG4gICAgICogUmVzcG9uc2UgdHJhbnNmb3JtYXRpb25zOlxuICAgICAqXG4gICAgICogIC0gSWYgWFNSRiBwcmVmaXggaXMgZGV0ZWN0ZWQsIHN0cmlwIGl0IChzZWUgU2VjdXJpdHkgQ29uc2lkZXJhdGlvbnMgc2VjdGlvbiBiZWxvdykuXG4gICAgICogIC0gSWYgSlNPTiByZXNwb25zZSBpcyBkZXRlY3RlZCwgZGVzZXJpYWxpemUgaXQgdXNpbmcgYSBKU09OIHBhcnNlci5cbiAgICAgKlxuICAgICAqIFRvIGdsb2JhbGx5IGF1Z21lbnQgb3Igb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdHJhbnNmb3JtcywgbW9kaWZ5IHRoZVxuICAgICAqIGAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLnRyYW5zZm9ybVJlcXVlc3RgIGFuZCBgJGh0dHBQcm92aWRlci5kZWZhdWx0cy50cmFuc2Zvcm1SZXNwb25zZWBcbiAgICAgKiBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBieSBkZWZhdWx0IGFuIGFycmF5IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMsIHdoaWNoIGFsbG93cyB5b3VcbiAgICAgKiB0byBgcHVzaGAgb3IgYHVuc2hpZnRgIGEgbmV3IHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIGludG8gdGhlIHRyYW5zZm9ybWF0aW9uIGNoYWluLiBZb3UgY2FuXG4gICAgICogYWxzbyBkZWNpZGUgdG8gY29tcGxldGVseSBvdmVycmlkZSBhbnkgZGVmYXVsdCB0cmFuc2Zvcm1hdGlvbnMgYnkgYXNzaWduaW5nIHlvdXJcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gdGhlc2UgcHJvcGVydGllcyBkaXJlY3RseSB3aXRob3V0IHRoZSBhcnJheSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogU2ltaWxhcmx5LCB0byBsb2NhbGx5IG92ZXJyaWRlIHRoZSByZXF1ZXN0L3Jlc3BvbnNlIHRyYW5zZm9ybXMsIGF1Z21lbnQgdGhlXG4gICAgICogYHRyYW5zZm9ybVJlcXVlc3RgIGFuZC9vciBgdHJhbnNmb3JtUmVzcG9uc2VgIHByb3BlcnRpZXMgb2YgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHBhc3NlZFxuICAgICAqIGludG8gYCRodHRwYC5cbiAgICAgKlxuICAgICAqXG4gICAgICogIyBDYWNoaW5nXG4gICAgICpcbiAgICAgKiBUbyBlbmFibGUgY2FjaGluZywgc2V0IHRoZSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gYGNhY2hlYCBwcm9wZXJ0eSB0byBgdHJ1ZWAgKHRvIHVzZSBkZWZhdWx0XG4gICAgICogY2FjaGUpIG9yIHRvIGEgY3VzdG9tIGNhY2hlIG9iamVjdCAoYnVpbHQgd2l0aCB7QGxpbmsgbmcuJGNhY2hlRmFjdG9yeSBgJGNhY2hlRmFjdG9yeWB9KS5cbiAgICAgKiBXaGVuIHRoZSBjYWNoZSBpcyBlbmFibGVkLCBgJGh0dHBgIHN0b3JlcyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBjYWNoZS4gVGhlIG5leHQgdGltZSB0aGUgc2FtZSByZXF1ZXN0IGlzIG1hZGUsIHRoZSByZXNwb25zZSBpcyBzZXJ2ZWQgZnJvbSB0aGUgY2FjaGUgd2l0aG91dFxuICAgICAqIHNlbmRpbmcgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgZXZlbiBpZiB0aGUgcmVzcG9uc2UgaXMgc2VydmVkIGZyb20gY2FjaGUsIGRlbGl2ZXJ5IG9mIHRoZSBkYXRhIGlzIGFzeW5jaHJvbm91cyBpblxuICAgICAqIHRoZSBzYW1lIHdheSB0aGF0IHJlYWwgcmVxdWVzdHMgYXJlLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIEdFVCByZXF1ZXN0cyBmb3IgdGhlIHNhbWUgVVJMIHRoYXQgc2hvdWxkIGJlIGNhY2hlZCB1c2luZyB0aGUgc2FtZVxuICAgICAqIGNhY2hlLCBidXQgdGhlIGNhY2hlIGlzIG5vdCBwb3B1bGF0ZWQgeWV0LCBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgd2lsbCBiZSBtYWRlIGFuZFxuICAgICAqIHRoZSByZW1haW5pbmcgcmVxdWVzdHMgd2lsbCBiZSBmdWxmaWxsZWQgdXNpbmcgdGhlIHJlc3BvbnNlIGZyb20gdGhlIGZpcnN0IHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGNoYW5nZSB0aGUgZGVmYXVsdCBjYWNoZSB0byBhIG5ldyBvYmplY3QgKGJ1aWx0IHdpdGhcbiAgICAgKiB7QGxpbmsgbmcuJGNhY2hlRmFjdG9yeSBgJGNhY2hlRmFjdG9yeWB9KSBieSB1cGRhdGluZyB0aGVcbiAgICAgKiB7QGxpbmsgbmcuJGh0dHAjcHJvcGVydGllc19kZWZhdWx0cyBgJGh0dHAuZGVmYXVsdHMuY2FjaGVgfSBwcm9wZXJ0eS4gQWxsIHJlcXVlc3RzIHdobyBzZXRcbiAgICAgKiB0aGVpciBgY2FjaGVgIHByb3BlcnR5IHRvIGB0cnVlYCB3aWxsIG5vdyB1c2UgdGhpcyBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugc2V0IHRoZSBkZWZhdWx0IGNhY2hlIHRvIGBmYWxzZWAgdGhlbiBvbmx5IHJlcXVlc3RzIHRoYXQgc3BlY2lmeSB0aGVpciBvd24gY3VzdG9tXG4gICAgICogY2FjaGUgb2JqZWN0IHdpbGwgYmUgY2FjaGVkLlxuICAgICAqXG4gICAgICogIyBJbnRlcmNlcHRvcnNcbiAgICAgKlxuICAgICAqIEJlZm9yZSB5b3Ugc3RhcnQgY3JlYXRpbmcgaW50ZXJjZXB0b3JzLCBiZSBzdXJlIHRvIHVuZGVyc3RhbmQgdGhlXG4gICAgICoge0BsaW5rIG5nLiRxICRxIGFuZCBkZWZlcnJlZC9wcm9taXNlIEFQSXN9LlxuICAgICAqXG4gICAgICogRm9yIHB1cnBvc2VzIG9mIGdsb2JhbCBlcnJvciBoYW5kbGluZywgYXV0aGVudGljYXRpb24sIG9yIGFueSBraW5kIG9mIHN5bmNocm9ub3VzIG9yXG4gICAgICogYXN5bmNocm9ub3VzIHByZS1wcm9jZXNzaW5nIG9mIHJlcXVlc3Qgb3IgcG9zdHByb2Nlc3Npbmcgb2YgcmVzcG9uc2VzLCBpdCBpcyBkZXNpcmFibGUgdG8gYmVcbiAgICAgKiBhYmxlIHRvIGludGVyY2VwdCByZXF1ZXN0cyBiZWZvcmUgdGhleSBhcmUgaGFuZGVkIHRvIHRoZSBzZXJ2ZXIgYW5kXG4gICAgICogcmVzcG9uc2VzIGJlZm9yZSB0aGV5IGFyZSBoYW5kZWQgb3ZlciB0byB0aGUgYXBwbGljYXRpb24gY29kZSB0aGF0XG4gICAgICogaW5pdGlhdGVkIHRoZXNlIHJlcXVlc3RzLiBUaGUgaW50ZXJjZXB0b3JzIGxldmVyYWdlIHRoZSB7QGxpbmsgbmcuJHFcbiAgICAgKiBwcm9taXNlIEFQSXN9IHRvIGZ1bGZpbGwgdGhpcyBuZWVkIGZvciBib3RoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcHJlLXByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgaW50ZXJjZXB0b3JzIGFyZSBzZXJ2aWNlIGZhY3RvcmllcyB0aGF0IGFyZSByZWdpc3RlcmVkIHdpdGggdGhlIGAkaHR0cFByb3ZpZGVyYCBieVxuICAgICAqIGFkZGluZyB0aGVtIHRvIHRoZSBgJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnNgIGFycmF5LiBUaGUgZmFjdG9yeSBpcyBjYWxsZWQgYW5kXG4gICAgICogaW5qZWN0ZWQgd2l0aCBkZXBlbmRlbmNpZXMgKGlmIHNwZWNpZmllZCkgYW5kIHJldHVybnMgdGhlIGludGVyY2VwdG9yLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byBraW5kcyBvZiBpbnRlcmNlcHRvcnMgKGFuZCB0d28ga2luZHMgb2YgcmVqZWN0aW9uIGludGVyY2VwdG9ycyk6XG4gICAgICpcbiAgICAgKiAgICogYHJlcXVlc3RgOiBpbnRlcmNlcHRvcnMgZ2V0IGNhbGxlZCB3aXRoIGh0dHAgYGNvbmZpZ2Agb2JqZWN0LiBUaGUgZnVuY3Rpb24gaXMgZnJlZSB0b1xuICAgICAqICAgICBtb2RpZnkgdGhlIGBjb25maWdgIG9yIGNyZWF0ZSBhIG5ldyBvbmUuIFRoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gdGhlIGBjb25maWdgXG4gICAgICogICAgIGRpcmVjdGx5IG9yIGFzIGEgcHJvbWlzZS5cbiAgICAgKiAgICogYHJlcXVlc3RFcnJvcmA6IGludGVyY2VwdG9yIGdldHMgY2FsbGVkIHdoZW4gYSBwcmV2aW91cyBpbnRlcmNlcHRvciB0aHJldyBhbiBlcnJvciBvclxuICAgICAqICAgICByZXNvbHZlZCB3aXRoIGEgcmVqZWN0aW9uLlxuICAgICAqICAgKiBgcmVzcG9uc2VgOiBpbnRlcmNlcHRvcnMgZ2V0IGNhbGxlZCB3aXRoIGh0dHAgYHJlc3BvbnNlYCBvYmplY3QuIFRoZSBmdW5jdGlvbiBpcyBmcmVlIHRvXG4gICAgICogICAgIG1vZGlmeSB0aGUgYHJlc3BvbnNlYCBvciBjcmVhdGUgYSBuZXcgb25lLiBUaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIHRoZSBgcmVzcG9uc2VgXG4gICAgICogICAgIGRpcmVjdGx5IG9yIGFzIGEgcHJvbWlzZS5cbiAgICAgKiAgICogYHJlc3BvbnNlRXJyb3JgOiBpbnRlcmNlcHRvciBnZXRzIGNhbGxlZCB3aGVuIGEgcHJldmlvdXMgaW50ZXJjZXB0b3IgdGhyZXcgYW4gZXJyb3Igb3JcbiAgICAgKiAgICAgcmVzb2x2ZWQgd2l0aCBhIHJlamVjdGlvbi5cbiAgICAgKlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiAgIC8vIHJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciBhcyBhIHNlcnZpY2VcbiAgICAgKiAgICRwcm92aWRlLmZhY3RvcnkoJ215SHR0cEludGVyY2VwdG9yJywgZnVuY3Rpb24oJHEsIGRlcGVuZGVuY3kxLCBkZXBlbmRlbmN5Mikge1xuICAgICAqICAgICByZXR1cm4ge1xuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxuICAgICAqICAgICAgICdyZXF1ZXN0JzogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gc3VjY2Vzc1xuICAgICAqICAgICAgICAgcmV0dXJuIGNvbmZpZyB8fCAkcS53aGVuKGNvbmZpZyk7XG4gICAgICogICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxuICAgICAqICAgICAgJ3JlcXVlc3RFcnJvcic6IGZ1bmN0aW9uKHJlamVjdGlvbikge1xuICAgICAqICAgICAgICAgLy8gZG8gc29tZXRoaW5nIG9uIGVycm9yXG4gICAgICogICAgICAgICBpZiAoY2FuUmVjb3ZlcihyZWplY3Rpb24pKSB7XG4gICAgICogICAgICAgICAgIHJldHVybiByZXNwb25zZU9yTmV3UHJvbWlzZVxuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgICAgcmV0dXJuICRxLnJlamVjdChyZWplY3Rpb24pO1xuICAgICAqICAgICAgIH0sXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgICAgLy8gb3B0aW9uYWwgbWV0aG9kXG4gICAgICogICAgICAgJ3Jlc3BvbnNlJzogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgKiAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBvbiBzdWNjZXNzXG4gICAgICogICAgICAgICByZXR1cm4gcmVzcG9uc2UgfHwgJHEud2hlbihyZXNwb25zZSk7XG4gICAgICogICAgICAgfSxcbiAgICAgKlxuICAgICAqICAgICAgIC8vIG9wdGlvbmFsIG1ldGhvZFxuICAgICAqICAgICAgJ3Jlc3BvbnNlRXJyb3InOiBmdW5jdGlvbihyZWplY3Rpb24pIHtcbiAgICAgKiAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBvbiBlcnJvclxuICAgICAqICAgICAgICAgaWYgKGNhblJlY292ZXIocmVqZWN0aW9uKSkge1xuICAgICAqICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VPck5ld1Byb21pc2VcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIHJldHVybiAkcS5yZWplY3QocmVqZWN0aW9uKTtcbiAgICAgKiAgICAgICB9O1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnMucHVzaCgnbXlIdHRwSW50ZXJjZXB0b3InKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogICAvLyByZWdpc3RlciB0aGUgaW50ZXJjZXB0b3IgdmlhIGFuIGFub255bW91cyBmYWN0b3J5XG4gICAgICogICAkaHR0cFByb3ZpZGVyLmludGVyY2VwdG9ycy5wdXNoKGZ1bmN0aW9uKCRxLCBkZXBlbmRlbmN5MSwgZGVwZW5kZW5jeTIpIHtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICdyZXF1ZXN0JzogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICogICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgJ3Jlc3BvbnNlJzogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgKiAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9O1xuICAgICAqICAgfSk7XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiAjIFJlc3BvbnNlIGludGVyY2VwdG9ycyAoREVQUkVDQVRFRClcbiAgICAgKlxuICAgICAqIEJlZm9yZSB5b3Ugc3RhcnQgY3JlYXRpbmcgaW50ZXJjZXB0b3JzLCBiZSBzdXJlIHRvIHVuZGVyc3RhbmQgdGhlXG4gICAgICoge0BsaW5rIG5nLiRxICRxIGFuZCBkZWZlcnJlZC9wcm9taXNlIEFQSXN9LlxuICAgICAqXG4gICAgICogRm9yIHB1cnBvc2VzIG9mIGdsb2JhbCBlcnJvciBoYW5kbGluZywgYXV0aGVudGljYXRpb24gb3IgYW55IGtpbmQgb2Ygc3luY2hyb25vdXMgb3JcbiAgICAgKiBhc3luY2hyb25vdXMgcHJlcHJvY2Vzc2luZyBvZiByZWNlaXZlZCByZXNwb25zZXMsIGl0IGlzIGRlc2lyYWJsZSB0byBiZSBhYmxlIHRvIGludGVyY2VwdFxuICAgICAqIHJlc3BvbnNlcyBmb3IgaHR0cCByZXF1ZXN0cyBiZWZvcmUgdGhleSBhcmUgaGFuZGVkIG92ZXIgdG8gdGhlIGFwcGxpY2F0aW9uIGNvZGUgdGhhdFxuICAgICAqIGluaXRpYXRlZCB0aGVzZSByZXF1ZXN0cy4gVGhlIHJlc3BvbnNlIGludGVyY2VwdG9ycyBsZXZlcmFnZSB0aGUge0BsaW5rIG5nLiRxXG4gICAgICogcHJvbWlzZSBhcGlzfSB0byBmdWxmaWwgdGhpcyBuZWVkIGZvciBib3RoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgcHJlcHJvY2Vzc2luZy5cbiAgICAgKlxuICAgICAqIFRoZSBpbnRlcmNlcHRvcnMgYXJlIHNlcnZpY2UgZmFjdG9yaWVzIHRoYXQgYXJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgJGh0dHBQcm92aWRlciBieVxuICAgICAqIGFkZGluZyB0aGVtIHRvIHRoZSBgJGh0dHBQcm92aWRlci5yZXNwb25zZUludGVyY2VwdG9yc2AgYXJyYXkuIFRoZSBmYWN0b3J5IGlzIGNhbGxlZCBhbmRcbiAgICAgKiBpbmplY3RlZCB3aXRoIGRlcGVuZGVuY2llcyAoaWYgc3BlY2lmaWVkKSBhbmQgcmV0dXJucyB0aGUgaW50ZXJjZXB0b3IgIOKAlCBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiB0YWtlcyBhIHtAbGluayBuZy4kcSBwcm9taXNlfSBhbmQgcmV0dXJucyB0aGUgb3JpZ2luYWwgb3IgYSBuZXcgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIDxwcmU+XG4gICAgICogICAvLyByZWdpc3RlciB0aGUgaW50ZXJjZXB0b3IgYXMgYSBzZXJ2aWNlXG4gICAgICogICAkcHJvdmlkZS5mYWN0b3J5KCdteUh0dHBJbnRlcmNlcHRvcicsIGZ1bmN0aW9uKCRxLCBkZXBlbmRlbmN5MSwgZGVwZW5kZW5jeTIpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgKiAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gc3VjY2Vzc1xuICAgICAqICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAqICAgICAgIH0sIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICogICAgICAgICAvLyBkbyBzb21ldGhpbmcgb24gZXJyb3JcbiAgICAgKiAgICAgICAgIGlmIChjYW5SZWNvdmVyKHJlc3BvbnNlKSkge1xuICAgICAqICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VPck5ld1Byb21pc2VcbiAgICAgKiAgICAgICAgIH1cbiAgICAgKiAgICAgICAgIHJldHVybiAkcS5yZWplY3QocmVzcG9uc2UpO1xuICAgICAqICAgICAgIH0pO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgJGh0dHBQcm92aWRlci5yZXNwb25zZUludGVyY2VwdG9ycy5wdXNoKCdteUh0dHBJbnRlcmNlcHRvcicpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiAgIC8vIHJlZ2lzdGVyIHRoZSBpbnRlcmNlcHRvciB2aWEgYW4gYW5vbnltb3VzIGZhY3RvcnlcbiAgICAgKiAgICRodHRwUHJvdmlkZXIucmVzcG9uc2VJbnRlcmNlcHRvcnMucHVzaChmdW5jdGlvbigkcSwgZGVwZW5kZW5jeTEsIGRlcGVuZGVuY3kyKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICogICAgICAgLy8gc2FtZSBhcyBhYm92ZVxuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqXG4gICAgICogIyBTZWN1cml0eSBDb25zaWRlcmF0aW9uc1xuICAgICAqXG4gICAgICogV2hlbiBkZXNpZ25pbmcgd2ViIGFwcGxpY2F0aW9ucywgY29uc2lkZXIgc2VjdXJpdHkgdGhyZWF0cyBmcm9tOlxuICAgICAqXG4gICAgICogLSB7QGxpbmsgaHR0cDovL2hhYWNrZWQuY29tL2FyY2hpdmUvMjAwOC8xMS8yMC9hbmF0b215LW9mLWEtc3VidGxlLWpzb24tdnVsbmVyYWJpbGl0eS5hc3B4XG4gICAgICogICBKU09OIHZ1bG5lcmFiaWxpdHl9XG4gICAgICogLSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Dcm9zcy1zaXRlX3JlcXVlc3RfZm9yZ2VyeSBYU1JGfVxuICAgICAqXG4gICAgICogQm90aCBzZXJ2ZXIgYW5kIHRoZSBjbGllbnQgbXVzdCBjb29wZXJhdGUgaW4gb3JkZXIgdG8gZWxpbWluYXRlIHRoZXNlIHRocmVhdHMuIEFuZ3VsYXIgY29tZXNcbiAgICAgKiBwcmUtY29uZmlndXJlZCB3aXRoIHN0cmF0ZWdpZXMgdGhhdCBhZGRyZXNzIHRoZXNlIGlzc3VlcywgYnV0IGZvciB0aGlzIHRvIHdvcmsgYmFja2VuZCBzZXJ2ZXJcbiAgICAgKiBjb29wZXJhdGlvbiBpcyByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqICMjIEpTT04gVnVsbmVyYWJpbGl0eSBQcm90ZWN0aW9uXG4gICAgICpcbiAgICAgKiBBIHtAbGluayBodHRwOi8vaGFhY2tlZC5jb20vYXJjaGl2ZS8yMDA4LzExLzIwL2FuYXRvbXktb2YtYS1zdWJ0bGUtanNvbi12dWxuZXJhYmlsaXR5LmFzcHhcbiAgICAgKiBKU09OIHZ1bG5lcmFiaWxpdHl9IGFsbG93cyB0aGlyZCBwYXJ0eSB3ZWJzaXRlIHRvIHR1cm4geW91ciBKU09OIHJlc291cmNlIFVSTCBpbnRvXG4gICAgICoge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSlNPTlAgSlNPTlB9IHJlcXVlc3QgdW5kZXIgc29tZSBjb25kaXRpb25zLiBUb1xuICAgICAqIGNvdW50ZXIgdGhpcyB5b3VyIHNlcnZlciBjYW4gcHJlZml4IGFsbCBKU09OIHJlcXVlc3RzIHdpdGggZm9sbG93aW5nIHN0cmluZyBgXCIpXX0nLFxcblwiYC5cbiAgICAgKiBBbmd1bGFyIHdpbGwgYXV0b21hdGljYWxseSBzdHJpcCB0aGUgcHJlZml4IGJlZm9yZSBwcm9jZXNzaW5nIGl0IGFzIEpTT04uXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSBpZiB5b3VyIHNlcnZlciBuZWVkcyB0byByZXR1cm46XG4gICAgICogPHByZT5cbiAgICAgKiBbJ29uZScsJ3R3byddXG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiB3aGljaCBpcyB2dWxuZXJhYmxlIHRvIGF0dGFjaywgeW91ciBzZXJ2ZXIgY2FuIHJldHVybjpcbiAgICAgKiA8cHJlPlxuICAgICAqICldfScsXG4gICAgICogWydvbmUnLCd0d28nXVxuICAgICAqIDwvcHJlPlxuICAgICAqXG4gICAgICogQW5ndWxhciB3aWxsIHN0cmlwIHRoZSBwcmVmaXgsIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSBKU09OLlxuICAgICAqXG4gICAgICpcbiAgICAgKiAjIyBDcm9zcyBTaXRlIFJlcXVlc3QgRm9yZ2VyeSAoWFNSRikgUHJvdGVjdGlvblxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3Mtc2l0ZV9yZXF1ZXN0X2ZvcmdlcnkgWFNSRn0gaXMgYSB0ZWNobmlxdWUgYnkgd2hpY2hcbiAgICAgKiBhbiB1bmF1dGhvcml6ZWQgc2l0ZSBjYW4gZ2FpbiB5b3VyIHVzZXIncyBwcml2YXRlIGRhdGEuIEFuZ3VsYXIgcHJvdmlkZXMgYSBtZWNoYW5pc21cbiAgICAgKiB0byBjb3VudGVyIFhTUkYuIFdoZW4gcGVyZm9ybWluZyBYSFIgcmVxdWVzdHMsIHRoZSAkaHR0cCBzZXJ2aWNlIHJlYWRzIGEgdG9rZW4gZnJvbSBhIGNvb2tpZVxuICAgICAqIChieSBkZWZhdWx0LCBgWFNSRi1UT0tFTmApIGFuZCBzZXRzIGl0IGFzIGFuIEhUVFAgaGVhZGVyIChgWC1YU1JGLVRPS0VOYCkuIFNpbmNlIG9ubHlcbiAgICAgKiBKYXZhU2NyaXB0IHRoYXQgcnVucyBvbiB5b3VyIGRvbWFpbiBjb3VsZCByZWFkIHRoZSBjb29raWUsIHlvdXIgc2VydmVyIGNhbiBiZSBhc3N1cmVkIHRoYXRcbiAgICAgKiB0aGUgWEhSIGNhbWUgZnJvbSBKYXZhU2NyaXB0IHJ1bm5pbmcgb24geW91ciBkb21haW4uIFRoZSBoZWFkZXIgd2lsbCBub3QgYmUgc2V0IGZvclxuICAgICAqIGNyb3NzLWRvbWFpbiByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIFRvIHRha2UgYWR2YW50YWdlIG9mIHRoaXMsIHlvdXIgc2VydmVyIG5lZWRzIHRvIHNldCBhIHRva2VuIGluIGEgSmF2YVNjcmlwdCByZWFkYWJsZSBzZXNzaW9uXG4gICAgICogY29va2llIGNhbGxlZCBgWFNSRi1UT0tFTmAgb24gdGhlIGZpcnN0IEhUVFAgR0VUIHJlcXVlc3QuIE9uIHN1YnNlcXVlbnQgWEhSIHJlcXVlc3RzIHRoZVxuICAgICAqIHNlcnZlciBjYW4gdmVyaWZ5IHRoYXQgdGhlIGNvb2tpZSBtYXRjaGVzIGBYLVhTUkYtVE9LRU5gIEhUVFAgaGVhZGVyLCBhbmQgdGhlcmVmb3JlIGJlIHN1cmVcbiAgICAgKiB0aGF0IG9ubHkgSmF2YVNjcmlwdCBydW5uaW5nIG9uIHlvdXIgZG9tYWluIGNvdWxkIGhhdmUgc2VudCB0aGUgcmVxdWVzdC4gVGhlIHRva2VuIG11c3QgYmVcbiAgICAgKiB1bmlxdWUgZm9yIGVhY2ggdXNlciBhbmQgbXVzdCBiZSB2ZXJpZmlhYmxlIGJ5IHRoZSBzZXJ2ZXIgKHRvIHByZXZlbnQgdGhlIEphdmFTY3JpcHQgZnJvbVxuICAgICAqIG1ha2luZyB1cCBpdHMgb3duIHRva2VucykuIFdlIHJlY29tbWVuZCB0aGF0IHRoZSB0b2tlbiBpcyBhIGRpZ2VzdCBvZiB5b3VyIHNpdGUnc1xuICAgICAqIGF1dGhlbnRpY2F0aW9uIGNvb2tpZSB3aXRoIGEge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NhbHRfKGNyeXB0b2dyYXBoeSkgc2FsdH1cbiAgICAgKiBmb3IgYWRkZWQgc2VjdXJpdHkuXG4gICAgICpcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgaGVhZGVycyBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIHRoZSB4c3JmSGVhZGVyTmFtZSBhbmQgeHNyZkNvb2tpZU5hbWVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGVpdGhlciAkaHR0cFByb3ZpZGVyLmRlZmF1bHRzLCBvciB0aGUgcGVyLXJlcXVlc3QgY29uZmlnIG9iamVjdC5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBPYmplY3QgZGVzY3JpYmluZyB0aGUgcmVxdWVzdCB0byBiZSBtYWRlIGFuZCBob3cgaXQgc2hvdWxkIGJlXG4gICAgICogICAgcHJvY2Vzc2VkLiBUaGUgb2JqZWN0IGhhcyBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKlxuICAgICAqICAgIC0gKiptZXRob2QqKiDigJMgYHtzdHJpbmd9YCDigJMgSFRUUCBtZXRob2QgKGUuZy4gJ0dFVCcsICdQT1NUJywgZXRjKVxuICAgICAqICAgIC0gKip1cmwqKiDigJMgYHtzdHJpbmd9YCDigJMgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIG9mIHRoZSByZXNvdXJjZSB0aGF0IGlzIGJlaW5nIHJlcXVlc3RlZC5cbiAgICAgKiAgICAtICoqcGFyYW1zKiog4oCTIGB7T2JqZWN0LjxzdHJpbmd8T2JqZWN0Pn1gIOKAkyBNYXAgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHdoaWNoIHdpbGwgYmUgdHVybmVkXG4gICAgICogICAgICB0byBgP2tleTE9dmFsdWUxJmtleTI9dmFsdWUyYCBhZnRlciB0aGUgdXJsLiBJZiB0aGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlXG4gICAgICogICAgICBKU09OaWZpZWQuXG4gICAgICogICAgLSAqKmRhdGEqKiDigJMgYHtzdHJpbmd8T2JqZWN0fWAg4oCTIERhdGEgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRhdGEuXG4gICAgICogICAgLSAqKmhlYWRlcnMqKiDigJMgYHtPYmplY3R9YCDigJMgTWFwIG9mIHN0cmluZ3Mgb3IgZnVuY3Rpb25zIHdoaWNoIHJldHVybiBzdHJpbmdzIHJlcHJlc2VudGluZ1xuICAgICAqICAgICAgSFRUUCBoZWFkZXJzIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gSWYgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIGlzIG51bGwsIHRoZVxuICAgICAqICAgICAgaGVhZGVyIHdpbGwgbm90IGJlIHNlbnQuXG4gICAgICogICAgLSAqKnhzcmZIZWFkZXJOYW1lKiog4oCTIGB7c3RyaW5nfWAg4oCTIE5hbWUgb2YgSFRUUCBoZWFkZXIgdG8gcG9wdWxhdGUgd2l0aCB0aGUgWFNSRiB0b2tlbi5cbiAgICAgKiAgICAtICoqeHNyZkNvb2tpZU5hbWUqKiDigJMgYHtzdHJpbmd9YCDigJMgTmFtZSBvZiBjb29raWUgY29udGFpbmluZyB0aGUgWFNSRiB0b2tlbi5cbiAgICAgKiAgICAtICoqdHJhbnNmb3JtUmVxdWVzdCoqIOKAk1xuICAgICAqICAgICAgYHtmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKXxBcnJheS48ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcik+fWAg4oCTXG4gICAgICogICAgICB0cmFuc2Zvcm0gZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMuIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGFrZXMgdGhlIGh0dHBcbiAgICAgKiAgICAgIHJlcXVlc3QgYm9keSBhbmQgaGVhZGVycyBhbmQgcmV0dXJucyBpdHMgdHJhbnNmb3JtZWQgKHR5cGljYWxseSBzZXJpYWxpemVkKSB2ZXJzaW9uLlxuICAgICAqICAgIC0gKip0cmFuc2Zvcm1SZXNwb25zZSoqIOKAk1xuICAgICAqICAgICAgYHtmdW5jdGlvbihkYXRhLCBoZWFkZXJzR2V0dGVyKXxBcnJheS48ZnVuY3Rpb24oZGF0YSwgaGVhZGVyc0dldHRlcik+fWAg4oCTXG4gICAgICogICAgICB0cmFuc2Zvcm0gZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMuIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gdGFrZXMgdGhlIGh0dHBcbiAgICAgKiAgICAgIHJlc3BvbnNlIGJvZHkgYW5kIGhlYWRlcnMgYW5kIHJldHVybnMgaXRzIHRyYW5zZm9ybWVkICh0eXBpY2FsbHkgZGVzZXJpYWxpemVkKSB2ZXJzaW9uLlxuICAgICAqICAgIC0gKipjYWNoZSoqIOKAkyBge2Jvb2xlYW58Q2FjaGV9YCDigJMgSWYgdHJ1ZSwgYSBkZWZhdWx0ICRodHRwIGNhY2hlIHdpbGwgYmUgdXNlZCB0byBjYWNoZSB0aGVcbiAgICAgKiAgICAgIEdFVCByZXF1ZXN0LCBvdGhlcndpc2UgaWYgYSBjYWNoZSBpbnN0YW5jZSBidWlsdCB3aXRoXG4gICAgICogICAgICB7QGxpbmsgbmcuJGNhY2hlRmFjdG9yeSAkY2FjaGVGYWN0b3J5fSwgdGhpcyBjYWNoZSB3aWxsIGJlIHVzZWQgZm9yXG4gICAgICogICAgICBjYWNoaW5nLlxuICAgICAqICAgIC0gKip0aW1lb3V0Kiog4oCTIGB7bnVtYmVyfFByb21pc2V9YCDigJMgdGltZW91dCBpbiBtaWxsaXNlY29uZHMsIG9yIHtAbGluayBuZy4kcSBwcm9taXNlfVxuICAgICAqICAgICAgdGhhdCBzaG91bGQgYWJvcnQgdGhlIHJlcXVlc3Qgd2hlbiByZXNvbHZlZC5cbiAgICAgKiAgICAtICoqd2l0aENyZWRlbnRpYWxzKiogLSBge2Jvb2xlYW59YCAtIHdoZXRoZXIgdG8gdG8gc2V0IHRoZSBgd2l0aENyZWRlbnRpYWxzYCBmbGFnIG9uIHRoZVxuICAgICAqICAgICAgWEhSIG9iamVjdC4gU2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9odHRwX2FjY2Vzc19jb250cm9sI3NlY3Rpb25fNVxuICAgICAqICAgICAgcmVxdWVzdHMgd2l0aCBjcmVkZW50aWFsc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogICAgLSAqKnJlc3BvbnNlVHlwZSoqIC0gYHtzdHJpbmd9YCAtIHNlZSB7QGxpbmtcbiAgICAgKiAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvRE9NL1hNTEh0dHBSZXF1ZXN0I3Jlc3BvbnNlVHlwZSByZXF1ZXN0VHlwZX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IFJldHVybnMgYSB7QGxpbmsgbmcuJHEgcHJvbWlzZX0gb2JqZWN0IHdpdGggdGhlXG4gICAgICogICBzdGFuZGFyZCBgdGhlbmAgbWV0aG9kIGFuZCB0d28gaHR0cCBzcGVjaWZpYyBtZXRob2RzOiBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAuIFRoZSBgdGhlbmBcbiAgICAgKiAgIG1ldGhvZCB0YWtlcyB0d28gYXJndW1lbnRzIGEgc3VjY2VzcyBhbmQgYW4gZXJyb3IgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgICogICByZXNwb25zZSBvYmplY3QuIFRoZSBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgbWV0aG9kcyB0YWtlIGEgc2luZ2xlIGFyZ3VtZW50IC0gYSBmdW5jdGlvbiB0aGF0XG4gICAgICogICB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHN1Y2NlZWRzIG9yIGZhaWxzIHJlc3BlY3RpdmVseS4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50b1xuICAgICAqICAgdGhlc2UgZnVuY3Rpb25zIGFyZSBkZXN0cnVjdHVyZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlc3BvbnNlIG9iamVjdCBwYXNzZWQgaW50byB0aGVcbiAgICAgKiAgIGB0aGVuYCBtZXRob2QuIFRoZSByZXNwb25zZSBvYmplY3QgaGFzIHRoZXNlIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgIC0gKipkYXRhKiog4oCTIGB7c3RyaW5nfE9iamVjdH1gIOKAkyBUaGUgcmVzcG9uc2UgYm9keSB0cmFuc2Zvcm1lZCB3aXRoIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiAgICAgZnVuY3Rpb25zLlxuICAgICAqICAgLSAqKnN0YXR1cyoqIOKAkyBge251bWJlcn1gIOKAkyBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZS5cbiAgICAgKiAgIC0gKipoZWFkZXJzKiog4oCTIGB7ZnVuY3Rpb24oW2hlYWRlck5hbWVdKX1gIOKAkyBIZWFkZXIgZ2V0dGVyIGZ1bmN0aW9uLlxuICAgICAqICAgLSAqKmNvbmZpZyoqIOKAkyBge09iamVjdH1gIOKAkyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPE9iamVjdD59IHBlbmRpbmdSZXF1ZXN0cyBBcnJheSBvZiBjb25maWcgb2JqZWN0cyBmb3IgY3VycmVudGx5IHBlbmRpbmdcbiAgICAgKiAgIHJlcXVlc3RzLiBUaGlzIGlzIHByaW1hcmlseSBtZWFudCB0byBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG48ZXhhbXBsZT5cbjxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gIDxkaXYgbmctY29udHJvbGxlcj1cIkZldGNoQ3RybFwiPlxuICAgIDxzZWxlY3QgbmctbW9kZWw9XCJtZXRob2RcIj5cbiAgICAgIDxvcHRpb24+R0VUPC9vcHRpb24+XG4gICAgICA8b3B0aW9uPkpTT05QPC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJ1cmxcIiBzaXplPVwiODBcIi8+XG4gICAgPGJ1dHRvbiBuZy1jbGljaz1cImZldGNoKClcIj5mZXRjaDwvYnV0dG9uPjxicj5cbiAgICA8YnV0dG9uIG5nLWNsaWNrPVwidXBkYXRlTW9kZWwoJ0dFVCcsICdodHRwLWhlbGxvLmh0bWwnKVwiPlNhbXBsZSBHRVQ8L2J1dHRvbj5cbiAgICA8YnV0dG9uXG4gICAgICBuZy1jbGljaz1cInVwZGF0ZU1vZGVsKCdKU09OUCcsXG4gICAgICAgICAgICAgICAgICAgICdodHRwOi8vYW5ndWxhcmpzLm9yZy9ncmVldC5waHA/Y2FsbGJhY2s9SlNPTl9DQUxMQkFDSyZuYW1lPVN1cGVyJTIwSGVybycpXCI+XG4gICAgICBTYW1wbGUgSlNPTlBcbiAgICA8L2J1dHRvbj5cbiAgICA8YnV0dG9uXG4gICAgICBuZy1jbGljaz1cInVwZGF0ZU1vZGVsKCdKU09OUCcsICdodHRwOi8vYW5ndWxhcmpzLm9yZy9kb2VzbnRleGlzdCZjYWxsYmFjaz1KU09OX0NBTExCQUNLJylcIj5cbiAgICAgICAgSW52YWxpZCBKU09OUFxuICAgICAgPC9idXR0b24+XG4gICAgPHByZT5odHRwIHN0YXR1cyBjb2RlOiB7e3N0YXR1c319PC9wcmU+XG4gICAgPHByZT5odHRwIHJlc3BvbnNlIGRhdGE6IHt7ZGF0YX19PC9wcmU+XG4gIDwvZGl2PlxuPC9maWxlPlxuPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICBmdW5jdGlvbiBGZXRjaEN0cmwoJHNjb3BlLCAkaHR0cCwgJHRlbXBsYXRlQ2FjaGUpIHtcbiAgICAkc2NvcGUubWV0aG9kID0gJ0dFVCc7XG4gICAgJHNjb3BlLnVybCA9ICdodHRwLWhlbGxvLmh0bWwnO1xuXG4gICAgJHNjb3BlLmZldGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUuY29kZSA9IG51bGw7XG4gICAgICAkc2NvcGUucmVzcG9uc2UgPSBudWxsO1xuXG4gICAgICAkaHR0cCh7bWV0aG9kOiAkc2NvcGUubWV0aG9kLCB1cmw6ICRzY29wZS51cmwsIGNhY2hlOiAkdGVtcGxhdGVDYWNoZX0pLlxuICAgICAgICBzdWNjZXNzKGZ1bmN0aW9uKGRhdGEsIHN0YXR1cykge1xuICAgICAgICAgICRzY29wZS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgJHNjb3BlLmRhdGEgPSBkYXRhO1xuICAgICAgICB9KS5cbiAgICAgICAgZXJyb3IoZnVuY3Rpb24oZGF0YSwgc3RhdHVzKSB7XG4gICAgICAgICAgJHNjb3BlLmRhdGEgPSBkYXRhIHx8IFwiUmVxdWVzdCBmYWlsZWRcIjtcbiAgICAgICAgICAkc2NvcGUuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS51cGRhdGVNb2RlbCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gICAgICAkc2NvcGUubWV0aG9kID0gbWV0aG9kO1xuICAgICAgJHNjb3BlLnVybCA9IHVybDtcbiAgICB9O1xuICB9XG48L2ZpbGU+XG48ZmlsZSBuYW1lPVwiaHR0cC1oZWxsby5odG1sXCI+XG4gIEhlbGxvLCAkaHR0cCFcbjwvZmlsZT5cbjxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxuICBpdCgnc2hvdWxkIG1ha2UgYW4geGhyIEdFVCByZXF1ZXN0JywgZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcIlNhbXBsZSBHRVRcIiknKS5jbGljaygpO1xuICAgIGVsZW1lbnQoJzpidXR0b246Y29udGFpbnMoXCJmZXRjaFwiKScpLmNsaWNrKCk7XG4gICAgZXhwZWN0KGJpbmRpbmcoJ3N0YXR1cycpKS50b0JlKCcyMDAnKTtcbiAgICBleHBlY3QoYmluZGluZygnZGF0YScpKS50b01hdGNoKC9IZWxsbywgXFwkaHR0cCEvKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBtYWtlIGEgSlNPTlAgcmVxdWVzdCB0byBhbmd1bGFyanMub3JnJywgZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcIlNhbXBsZSBKU09OUFwiKScpLmNsaWNrKCk7XG4gICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcImZldGNoXCIpJykuY2xpY2soKTtcbiAgICBleHBlY3QoYmluZGluZygnc3RhdHVzJykpLnRvQmUoJzIwMCcpO1xuICAgIGV4cGVjdChiaW5kaW5nKCdkYXRhJykpLnRvTWF0Y2goL1N1cGVyIEhlcm8hLyk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgbWFrZSBKU09OUCByZXF1ZXN0IHRvIGludmFsaWQgVVJMIGFuZCBpbnZva2UgdGhlIGVycm9yIGhhbmRsZXInLFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudCgnOmJ1dHRvbjpjb250YWlucyhcIkludmFsaWQgSlNPTlBcIiknKS5jbGljaygpO1xuICAgIGVsZW1lbnQoJzpidXR0b246Y29udGFpbnMoXCJmZXRjaFwiKScpLmNsaWNrKCk7XG4gICAgZXhwZWN0KGJpbmRpbmcoJ3N0YXR1cycpKS50b0JlKCcwJyk7XG4gICAgZXhwZWN0KGJpbmRpbmcoJ2RhdGEnKSkudG9CZSgnUmVxdWVzdCBmYWlsZWQnKTtcbiAgfSk7XG48L2ZpbGU+XG48L2V4YW1wbGU+XG4gICAgICovXG4gICAgZnVuY3Rpb24gJGh0dHAocmVxdWVzdENvbmZpZykge1xuICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgdHJhbnNmb3JtUmVxdWVzdDogZGVmYXVsdHMudHJhbnNmb3JtUmVxdWVzdCxcbiAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRzLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICB9O1xuICAgICAgdmFyIGhlYWRlcnMgPSBtZXJnZUhlYWRlcnMocmVxdWVzdENvbmZpZyk7XG5cbiAgICAgIGV4dGVuZChjb25maWcsIHJlcXVlc3RDb25maWcpO1xuICAgICAgY29uZmlnLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgY29uZmlnLm1ldGhvZCA9IHVwcGVyY2FzZShjb25maWcubWV0aG9kKTtcblxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IHVybElzU2FtZU9yaWdpbihjb25maWcudXJsKVxuICAgICAgICAgID8gJGJyb3dzZXIuY29va2llcygpW2NvbmZpZy54c3JmQ29va2llTmFtZSB8fCBkZWZhdWx0cy54c3JmQ29va2llTmFtZV1cbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgaGVhZGVyc1soY29uZmlnLnhzcmZIZWFkZXJOYW1lIHx8IGRlZmF1bHRzLnhzcmZIZWFkZXJOYW1lKV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG5cblxuICAgICAgdmFyIHNlcnZlclJlcXVlc3QgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgICAgICB2YXIgcmVxRGF0YSA9IHRyYW5zZm9ybURhdGEoY29uZmlnLmRhdGEsIGhlYWRlcnNHZXR0ZXIoaGVhZGVycyksIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0KTtcblxuICAgICAgICAvLyBzdHJpcCBjb250ZW50LXR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGNvbmZpZy5kYXRhKSkge1xuICAgICAgICAgIGZvckVhY2goaGVhZGVycywgZnVuY3Rpb24odmFsdWUsIGhlYWRlcikge1xuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZShoZWFkZXIpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykgJiYgIWlzVW5kZWZpbmVkKGRlZmF1bHRzLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgICAgICBjb25maWcud2l0aENyZWRlbnRpYWxzID0gZGVmYXVsdHMud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0XG4gICAgICAgIHJldHVybiBzZW5kUmVxKGNvbmZpZywgcmVxRGF0YSwgaGVhZGVycykudGhlbih0cmFuc2Zvcm1SZXNwb25zZSwgdHJhbnNmb3JtUmVzcG9uc2UpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNoYWluID0gW3NlcnZlclJlcXVlc3QsIHVuZGVmaW5lZF07XG4gICAgICB2YXIgcHJvbWlzZSA9ICRxLndoZW4oY29uZmlnKTtcblxuICAgICAgLy8gYXBwbHkgaW50ZXJjZXB0b3JzXG4gICAgICBmb3JFYWNoKHJldmVyc2VkSW50ZXJjZXB0b3JzLCBmdW5jdGlvbihpbnRlcmNlcHRvcikge1xuICAgICAgICBpZiAoaW50ZXJjZXB0b3IucmVxdWVzdCB8fCBpbnRlcmNlcHRvci5yZXF1ZXN0RXJyb3IpIHtcbiAgICAgICAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLnJlcXVlc3QsIGludGVyY2VwdG9yLnJlcXVlc3RFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVyY2VwdG9yLnJlc3BvbnNlIHx8IGludGVyY2VwdG9yLnJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLnJlc3BvbnNlLCBpbnRlcmNlcHRvci5yZXNwb25zZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlKGNoYWluLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGhlbkZuID0gY2hhaW4uc2hpZnQoKTtcbiAgICAgICAgdmFyIHJlamVjdEZuID0gY2hhaW4uc2hpZnQoKTtcblxuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHRoZW5GbiwgcmVqZWN0Rm4pO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlLnN1Y2Nlc3MgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICBmbihyZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMsIGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH07XG5cbiAgICAgIHByb21pc2UuZXJyb3IgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBwcm9taXNlLnRoZW4obnVsbCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICBmbihyZXNwb25zZS5kYXRhLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmhlYWRlcnMsIGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuXG4gICAgICBmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICAvLyBtYWtlIGEgY29weSBzaW5jZSB0aGUgcmVzcG9uc2UgbXVzdCBiZSBjYWNoZWFibGVcbiAgICAgICAgdmFyIHJlc3AgPSBleHRlbmQoe30sIHJlc3BvbnNlLCB7XG4gICAgICAgICAgZGF0YTogdHJhbnNmb3JtRGF0YShyZXNwb25zZS5kYXRhLCByZXNwb25zZS5oZWFkZXJzLCBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGlzU3VjY2VzcyhyZXNwb25zZS5zdGF0dXMpKVxuICAgICAgICAgID8gcmVzcFxuICAgICAgICAgIDogJHEucmVqZWN0KHJlc3ApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZXJnZUhlYWRlcnMoY29uZmlnKSB7XG4gICAgICAgIHZhciBkZWZIZWFkZXJzID0gZGVmYXVsdHMuaGVhZGVycyxcbiAgICAgICAgICAgIHJlcUhlYWRlcnMgPSBleHRlbmQoe30sIGNvbmZpZy5oZWFkZXJzKSxcbiAgICAgICAgICAgIGRlZkhlYWRlck5hbWUsIGxvd2VyY2FzZURlZkhlYWRlck5hbWUsIHJlcUhlYWRlck5hbWU7XG5cbiAgICAgICAgZGVmSGVhZGVycyA9IGV4dGVuZCh7fSwgZGVmSGVhZGVycy5jb21tb24sIGRlZkhlYWRlcnNbbG93ZXJjYXNlKGNvbmZpZy5tZXRob2QpXSk7XG5cbiAgICAgICAgLy8gZXhlY3V0ZSBpZiBoZWFkZXIgdmFsdWUgaXMgZnVuY3Rpb25cbiAgICAgICAgZXhlY0hlYWRlcnMoZGVmSGVhZGVycyk7XG4gICAgICAgIGV4ZWNIZWFkZXJzKHJlcUhlYWRlcnMpO1xuXG4gICAgICAgIC8vIHVzaW5nIGZvci1pbiBpbnN0ZWFkIG9mIGZvckVhY2ggdG8gYXZvaWQgdW5lY2Vzc2FyeSBpdGVyYXRpb24gYWZ0ZXIgaGVhZGVyIGhhcyBiZWVuIGZvdW5kXG4gICAgICAgIGRlZmF1bHRIZWFkZXJzSXRlcmF0aW9uOlxuICAgICAgICBmb3IgKGRlZkhlYWRlck5hbWUgaW4gZGVmSGVhZGVycykge1xuICAgICAgICAgIGxvd2VyY2FzZURlZkhlYWRlck5hbWUgPSBsb3dlcmNhc2UoZGVmSGVhZGVyTmFtZSk7XG5cbiAgICAgICAgICBmb3IgKHJlcUhlYWRlck5hbWUgaW4gcmVxSGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZShyZXFIZWFkZXJOYW1lKSA9PT0gbG93ZXJjYXNlRGVmSGVhZGVyTmFtZSkge1xuICAgICAgICAgICAgICBjb250aW51ZSBkZWZhdWx0SGVhZGVyc0l0ZXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXFIZWFkZXJzW2RlZkhlYWRlck5hbWVdID0gZGVmSGVhZGVyc1tkZWZIZWFkZXJOYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXFIZWFkZXJzO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWNIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgICB2YXIgaGVhZGVyQ29udGVudDtcblxuICAgICAgICAgIGZvckVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyRm4sIGhlYWRlcikge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGVhZGVyRm4pKSB7XG4gICAgICAgICAgICAgIGhlYWRlckNvbnRlbnQgPSBoZWFkZXJGbigpO1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1toZWFkZXJdID0gaGVhZGVyQ29udGVudDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAkaHR0cC5wZW5kaW5nUmVxdWVzdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNnZXRcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBHRVRgIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogQHJldHVybnMge0h0dHBQcm9taXNlfSBGdXR1cmUgb2JqZWN0XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJGh0dHAjZGVsZXRlXG4gICAgICogQG1ldGhvZE9mIG5nLiRodHRwXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgdG8gcGVyZm9ybSBgREVMRVRFYCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRodHRwI2hlYWRcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBIRUFEYCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRodHRwI2pzb25wXG4gICAgICogQG1ldGhvZE9mIG5nLiRodHRwXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgdG8gcGVyZm9ybSBgSlNPTlBgIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIFNob3VsZCBjb250YWluIGBKU09OX0NBTExCQUNLYCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVTaG9ydE1ldGhvZHMoJ2dldCcsICdkZWxldGUnLCAnaGVhZCcsICdqc29ucCcpO1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRodHRwI3Bvc3RcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBQT1NUYCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkwgc3BlY2lmeWluZyB0aGUgZGVzdGluYXRpb24gb2YgdGhlIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgUmVxdWVzdCBjb250ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7SHR0cFByb21pc2V9IEZ1dHVyZSBvYmplY3RcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBuZy4kaHR0cCNwdXRcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGh0dHBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCB0byBwZXJmb3JtIGBQVVRgIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFJlbGF0aXZlIG9yIGFic29sdXRlIFVSTCBzcGVjaWZ5aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBSZXF1ZXN0IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtIdHRwUHJvbWlzZX0gRnV0dXJlIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZVNob3J0TWV0aG9kc1dpdGhEYXRhKCdwb3N0JywgJ3B1dCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmdkb2MgcHJvcGVydHlcbiAgICAgICAgICogQG5hbWUgbmcuJGh0dHAjZGVmYXVsdHNcbiAgICAgICAgICogQHByb3BlcnR5T2YgbmcuJGh0dHBcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJ1bnRpbWUgZXF1aXZhbGVudCBvZiB0aGUgYCRodHRwUHJvdmlkZXIuZGVmYXVsdHNgIHByb3BlcnR5LiBBbGxvd3MgY29uZmlndXJhdGlvbiBvZlxuICAgICAgICAgKiBkZWZhdWx0IGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscyBhcyB3ZWxsIGFzIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIFwiU2V0dGluZyBIVFRQIEhlYWRlcnNcIiBhbmQgXCJUcmFuc2Zvcm1pbmcgUmVxdWVzdHMgYW5kIFJlc3BvbnNlc1wiIHNlY3Rpb25zIGFib3ZlLlxuICAgICAgICAgKi9cbiAgICAkaHR0cC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG5cbiAgICByZXR1cm4gJGh0dHA7XG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNob3J0TWV0aG9kcyhuYW1lcykge1xuICAgICAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgJGh0dHBbbmFtZV0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgICAgICAgIHJldHVybiAkaHR0cChleHRlbmQoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgICAgICBtZXRob2Q6IG5hbWUsXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2hvcnRNZXRob2RzV2l0aERhdGEobmFtZSkge1xuICAgICAgZm9yRWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgJGh0dHBbbmFtZV0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgICAgICAgIHJldHVybiAkaHR0cChleHRlbmQoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgICAgICBtZXRob2Q6IG5hbWUsXG4gICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogISEhIEFDQ0VTU0VTIENMT1NVUkUgVkFSUzpcbiAgICAgKiAkaHR0cEJhY2tlbmQsIGRlZmF1bHRzLCAkbG9nLCAkcm9vdFNjb3BlLCBkZWZhdWx0Q2FjaGUsICRodHRwLnBlbmRpbmdSZXF1ZXN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRSZXEoY29uZmlnLCByZXFEYXRhLCByZXFIZWFkZXJzKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpLFxuICAgICAgICAgIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIGNhY2hlZFJlc3AsXG4gICAgICAgICAgdXJsID0gYnVpbGRVcmwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcyk7XG5cbiAgICAgICRodHRwLnBlbmRpbmdSZXF1ZXN0cy5wdXNoKGNvbmZpZyk7XG4gICAgICBwcm9taXNlLnRoZW4ocmVtb3ZlUGVuZGluZ1JlcSwgcmVtb3ZlUGVuZGluZ1JlcSk7XG5cblxuICAgICAgaWYgKChjb25maWcuY2FjaGUgfHwgZGVmYXVsdHMuY2FjaGUpICYmIGNvbmZpZy5jYWNoZSAhPT0gZmFsc2UgJiYgY29uZmlnLm1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICBjYWNoZSA9IGlzT2JqZWN0KGNvbmZpZy5jYWNoZSkgPyBjb25maWcuY2FjaGVcbiAgICAgICAgICAgICAgOiBpc09iamVjdChkZWZhdWx0cy5jYWNoZSkgPyBkZWZhdWx0cy5jYWNoZVxuICAgICAgICAgICAgICA6IGRlZmF1bHRDYWNoZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlZFJlc3AgPSBjYWNoZS5nZXQodXJsKTtcbiAgICAgICAgaWYgKGlzRGVmaW5lZChjYWNoZWRSZXNwKSkge1xuICAgICAgICAgIGlmIChjYWNoZWRSZXNwLnRoZW4pIHtcbiAgICAgICAgICAgIC8vIGNhY2hlZCByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gc2VudCwgYnV0IHRoZXJlIGlzIG5vIHJlc3BvbnNlIHlldFxuICAgICAgICAgICAgY2FjaGVkUmVzcC50aGVuKHJlbW92ZVBlbmRpbmdSZXEsIHJlbW92ZVBlbmRpbmdSZXEpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNlcnZpbmcgZnJvbSBjYWNoZVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY2FjaGVkUmVzcCkpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoY2FjaGVkUmVzcFsxXSwgY2FjaGVkUmVzcFswXSwgY29weShjYWNoZWRSZXNwWzJdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShjYWNoZWRSZXNwLCAyMDAsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHV0IHRoZSBwcm9taXNlIGZvciB0aGUgbm9uLXRyYW5zZm9ybWVkIHJlc3BvbnNlIGludG8gY2FjaGUgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgIGNhY2hlLnB1dCh1cmwsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIHdvbid0IGhhdmUgdGhlIHJlc3BvbnNlIGluIGNhY2hlLCBzZW5kIHRoZSByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kXG4gICAgICBpZiAoaXNVbmRlZmluZWQoY2FjaGVkUmVzcCkpIHtcbiAgICAgICAgJGh0dHBCYWNrZW5kKGNvbmZpZy5tZXRob2QsIHVybCwgcmVxRGF0YSwgZG9uZSwgcmVxSGVhZGVycywgY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICBjb25maWcud2l0aENyZWRlbnRpYWxzLCBjb25maWcucmVzcG9uc2VUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG5cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHRvICRodHRwQmFja2VuZCgpOlxuICAgICAgICogIC0gY2FjaGVzIHRoZSByZXNwb25zZSBpZiBkZXNpcmVkXG4gICAgICAgKiAgLSByZXNvbHZlcyB0aGUgcmF3ICRodHRwIHByb21pc2VcbiAgICAgICAqICAtIGNhbGxzICRhcHBseVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgcmVzcG9uc2UsIGhlYWRlcnNTdHJpbmcpIHtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaWYgKGlzU3VjY2VzcyhzdGF0dXMpKSB7XG4gICAgICAgICAgICBjYWNoZS5wdXQodXJsLCBbc3RhdHVzLCByZXNwb25zZSwgcGFyc2VIZWFkZXJzKGhlYWRlcnNTdHJpbmcpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBwcm9taXNlIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICBjYWNoZS5yZW1vdmUodXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlUHJvbWlzZShyZXNwb25zZSwgc3RhdHVzLCBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG5cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNvbHZlcyB0aGUgcmF3ICRodHRwIHByb21pc2UuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHJlc3BvbnNlLCBzdGF0dXMsIGhlYWRlcnMpIHtcbiAgICAgICAgLy8gbm9ybWFsaXplIGludGVybmFsIHN0YXR1c2VzIHRvIDBcbiAgICAgICAgc3RhdHVzID0gTWF0aC5tYXgoc3RhdHVzLCAwKTtcblxuICAgICAgICAoaXNTdWNjZXNzKHN0YXR1cykgPyBkZWZlcnJlZC5yZXNvbHZlIDogZGVmZXJyZWQucmVqZWN0KSh7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2UsXG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVyc0dldHRlcihoZWFkZXJzKSxcbiAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuXG4gICAgICBmdW5jdGlvbiByZW1vdmVQZW5kaW5nUmVxKCkge1xuICAgICAgICB2YXIgaWR4ID0gaW5kZXhPZigkaHR0cC5wZW5kaW5nUmVxdWVzdHMsIGNvbmZpZyk7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSAkaHR0cC5wZW5kaW5nUmVxdWVzdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFVybCh1cmwsIHBhcmFtcykge1xuICAgICAgICAgIGlmICghcGFyYW1zKSByZXR1cm4gdXJsO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgIGZvckVhY2hTb3J0ZWQocGFyYW1zLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV07XG5cbiAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IHRvSnNvbih2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVyaVF1ZXJ5KGtleSkgKyAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVyaVF1ZXJ5KHYpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB1cmwgKyAoKHVybC5pbmRleE9mKCc/JykgPT0gLTEpID8gJz8nIDogJyYnKSArIHBhcnRzLmpvaW4oJyYnKTtcbiAgICAgICAgfVxuXG5cbiAgfV07XG59XG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgZnVuY3Rpb24oKSB7XG4gIC8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXG4gIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjYuMFwiKTsgfSBjYXRjaCAoZTEpIHt9XG4gIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjMuMFwiKTsgfSBjYXRjaCAoZTIpIHt9XG4gIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpOyB9IGNhdGNoIChlMykge31cbiAgdGhyb3cgbWluRXJyKCckaHR0cEJhY2tlbmQnKSgnbm94aHInLCBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LlwiKTtcbn07XG5cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kaHR0cEJhY2tlbmRcbiAqIEByZXF1aXJlcyAkYnJvd3NlclxuICogQHJlcXVpcmVzICR3aW5kb3dcbiAqIEByZXF1aXJlcyAkZG9jdW1lbnRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEhUVFAgYmFja2VuZCB1c2VkIGJ5IHRoZSB7QGxpbmsgbmcuJGh0dHAgc2VydmljZX0gdGhhdCBkZWxlZ2F0ZXMgdG9cbiAqIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCBvciBKU09OUCBhbmQgZGVhbHMgd2l0aCBicm93c2VyIGluY29tcGF0aWJpbGl0aWVzLlxuICpcbiAqIFlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byB1c2UgdGhpcyBzZXJ2aWNlIGRpcmVjdGx5LCBpbnN0ZWFkIHVzZSB0aGUgaGlnaGVyLWxldmVsIGFic3RyYWN0aW9uczpcbiAqIHtAbGluayBuZy4kaHR0cCAkaHR0cH0gb3Ige0BsaW5rIG5nUmVzb3VyY2UuJHJlc291cmNlICRyZXNvdXJjZX0uXG4gKlxuICogRHVyaW5nIHRlc3RpbmcgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBzd2FwcGVkIHdpdGgge0BsaW5rIG5nTW9jay4kaHR0cEJhY2tlbmQgbW9ja1xuICogJGh0dHBCYWNrZW5kfSB3aGljaCBjYW4gYmUgdHJhaW5lZCB3aXRoIHJlc3BvbnNlcy5cbiAqL1xuZnVuY3Rpb24gJEh0dHBCYWNrZW5kUHJvdmlkZXIoKSB7XG4gIHRoaXMuJGdldCA9IFsnJGJyb3dzZXInLCAnJHdpbmRvdycsICckZG9jdW1lbnQnLCBmdW5jdGlvbigkYnJvd3NlciwgJHdpbmRvdywgJGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUh0dHBCYWNrZW5kKCRicm93c2VyLCBYSFIsICRicm93c2VyLmRlZmVyLCAkd2luZG93LmFuZ3VsYXIuY2FsbGJhY2tzLCAkZG9jdW1lbnRbMF0pO1xuICB9XTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSHR0cEJhY2tlbmQoJGJyb3dzZXIsIFhIUiwgJGJyb3dzZXJEZWZlciwgY2FsbGJhY2tzLCByYXdEb2N1bWVudCkge1xuICB2YXIgQUJPUlRFRCA9IC0xO1xuXG4gIC8vIFRPRE8odm9qdGEpOiBmaXggdGhlIHNpZ25hdHVyZVxuICByZXR1cm4gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBvc3QsIGNhbGxiYWNrLCBoZWFkZXJzLCB0aW1lb3V0LCB3aXRoQ3JlZGVudGlhbHMsIHJlc3BvbnNlVHlwZSkge1xuICAgIHZhciBzdGF0dXM7XG4gICAgJGJyb3dzZXIuJCRpbmNPdXRzdGFuZGluZ1JlcXVlc3RDb3VudCgpO1xuICAgIHVybCA9IHVybCB8fCAkYnJvd3Nlci51cmwoKTtcblxuICAgIGlmIChsb3dlcmNhc2UobWV0aG9kKSA9PSAnanNvbnAnKSB7XG4gICAgICB2YXIgY2FsbGJhY2tJZCA9ICdfJyArIChjYWxsYmFja3MuY291bnRlcisrKS50b1N0cmluZygzNik7XG4gICAgICBjYWxsYmFja3NbY2FsbGJhY2tJZF0gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrc1tjYWxsYmFja0lkXS5kYXRhID0gZGF0YTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBqc29ucERvbmUgPSBqc29ucFJlcSh1cmwucmVwbGFjZSgnSlNPTl9DQUxMQkFDSycsICdhbmd1bGFyLmNhbGxiYWNrcy4nICsgY2FsbGJhY2tJZCksXG4gICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3NbY2FsbGJhY2tJZF0uZGF0YSkge1xuICAgICAgICAgIGNvbXBsZXRlUmVxdWVzdChjYWxsYmFjaywgMjAwLCBjYWxsYmFja3NbY2FsbGJhY2tJZF0uZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGxldGVSZXF1ZXN0KGNhbGxiYWNrLCBzdGF0dXMgfHwgLTIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjYWxsYmFja3NbY2FsbGJhY2tJZF07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhociA9IG5ldyBYSFIoKTtcbiAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgIGZvckVhY2goaGVhZGVycywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbiBJRTYgYW5kIDcsIHRoaXMgbWlnaHQgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgd2hlbiB4aHIuc2VuZCBiZWxvdyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgLy8gcmVzcG9uc2UgaXMgaW4gdGhlIGNhY2hlLiB0aGUgcHJvbWlzZSBhcGkgd2lsbCBlbnN1cmUgdGhhdCB0byB0aGUgYXBwIGNvZGUgdGhlIGFwaSBpc1xuICAgICAgLy8gYWx3YXlzIGFzeW5jXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9IG51bGwsXG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcblxuICAgICAgICAgIGlmKHN0YXR1cyAhPT0gQUJPUlRFRCkge1xuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgdGhlIG9sZC1zY2hvb2wgd2F5IG9mIHJldHJpZXZpbmcgcmVzcG9uc2UgKHN1cHBvcnRlZCBieSBJRTggJiA5KVxuICAgICAgICAgIC8vIHJlc3BvbnNlL3Jlc3BvbnNlVHlwZSBwcm9wZXJ0aWVzIHdlcmUgaW50cm9kdWNlZCBpbiBYSFIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZCBieSBJRTEwKVxuICAgICAgICAgIGNvbXBsZXRlUmVxdWVzdChjYWxsYmFjayxcbiAgICAgICAgICAgICAgc3RhdHVzIHx8IHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAod2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICB9XG5cbiAgICAgIHhoci5zZW5kKHBvc3QgfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICB2YXIgdGltZW91dElkID0gJGJyb3dzZXJEZWZlcih0aW1lb3V0UmVxdWVzdCwgdGltZW91dCk7XG4gICAgfSBlbHNlIGlmICh0aW1lb3V0ICYmIHRpbWVvdXQudGhlbikge1xuICAgICAgdGltZW91dC50aGVuKHRpbWVvdXRSZXF1ZXN0KTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHRpbWVvdXRSZXF1ZXN0KCkge1xuICAgICAgc3RhdHVzID0gQUJPUlRFRDtcbiAgICAgIGpzb25wRG9uZSAmJiBqc29ucERvbmUoKTtcbiAgICAgIHhociAmJiB4aHIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoY2FsbGJhY2ssIHN0YXR1cywgcmVzcG9uc2UsIGhlYWRlcnNTdHJpbmcpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHVybFJlc29sdmUodXJsKS5wcm90b2NvbDtcblxuICAgICAgLy8gY2FuY2VsIHRpbWVvdXQgYW5kIHN1YnNlcXVlbnQgdGltZW91dCBwcm9taXNlIHJlc29sdXRpb25cbiAgICAgIHRpbWVvdXRJZCAmJiAkYnJvd3NlckRlZmVyLmNhbmNlbCh0aW1lb3V0SWQpO1xuICAgICAganNvbnBEb25lID0geGhyID0gbnVsbDtcblxuICAgICAgLy8gZml4IHN0YXR1cyBjb2RlIGZvciBmaWxlIHByb3RvY29sIChpdCdzIGFsd2F5cyAwKVxuICAgICAgc3RhdHVzID0gKHByb3RvY29sID09ICdmaWxlJyAmJiBzdGF0dXMgPT09IDApID8gKHJlc3BvbnNlID8gMjAwIDogNDA0KSA6IHN0YXR1cztcblxuICAgICAgLy8gbm9ybWFsaXplIElFIGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcbiAgICAgIHN0YXR1cyA9IHN0YXR1cyA9PSAxMjIzID8gMjA0IDogc3RhdHVzO1xuXG4gICAgICBjYWxsYmFjayhzdGF0dXMsIHJlc3BvbnNlLCBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICRicm93c2VyLiQkY29tcGxldGVPdXRzdGFuZGluZ1JlcXVlc3Qobm9vcCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGpzb25wUmVxKHVybCwgZG9uZSkge1xuICAgIC8vIHdlIGNhbid0IHVzZSBqUXVlcnkvanFMaXRlIGhlcmUgYmVjYXVzZSBqUXVlcnkgZG9lcyBjcmF6eSBzaGl0IHdpdGggc2NyaXB0IGVsZW1lbnRzLCBlLmcuOlxuICAgIC8vIC0gZmV0Y2hlcyBsb2NhbCBzY3JpcHRzIHZpYSBYSFIgYW5kIGV2YWxzIHRoZW1cbiAgICAvLyAtIGFkZHMgYW5kIGltbWVkaWF0ZWx5IHJlbW92ZXMgc2NyaXB0IGVsZW1lbnRzIGZyb20gdGhlIGRvY3VtZW50XG4gICAgdmFyIHNjcmlwdCA9IHJhd0RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICBkb25lV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHJhd0RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICBpZiAoZG9uZSkgZG9uZSgpO1xuICAgICAgICB9O1xuXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQuc3JjID0gdXJsO1xuXG4gICAgaWYgKG1zaWUgJiYgbXNpZSA8PSA4KSB7XG4gICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgIGRvbmVXcmFwcGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb25lV3JhcHBlcigpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByYXdEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgcmV0dXJuIGRvbmVXcmFwcGVyO1xuICB9XG59XG5cbnZhciAkaW50ZXJwb2xhdGVNaW5FcnIgPSBtaW5FcnIoJyRpbnRlcnBvbGF0ZScpO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBVc2VkIGZvciBjb25maWd1cmluZyB0aGUgaW50ZXJwb2xhdGlvbiBtYXJrdXAuIERlZmF1bHRzIHRvIGB7e2AgYW5kIGB9fWAuXG4gKlxuICogQGV4YW1wbGVcbjxkb2M6ZXhhbXBsZSBtb2R1bGU9XCJjdXN0b21JbnRlcnBvbGF0aW9uQXBwXCI+XG48ZG9jOnNvdXJjZT5cbjxzY3JpcHQ+XG4gIHZhciBjdXN0b21JbnRlcnBvbGF0aW9uQXBwID0gYW5ndWxhci5tb2R1bGUoJ2N1c3RvbUludGVycG9sYXRpb25BcHAnLCBbXSk7XG5cbiAgY3VzdG9tSW50ZXJwb2xhdGlvbkFwcC5jb25maWcoZnVuY3Rpb24oJGludGVycG9sYXRlUHJvdmlkZXIpIHtcbiAgICAkaW50ZXJwb2xhdGVQcm92aWRlci5zdGFydFN5bWJvbCgnLy8nKTtcbiAgICAkaW50ZXJwb2xhdGVQcm92aWRlci5lbmRTeW1ib2woJy8vJyk7XG4gIH0pO1xuXG5cbiAgY3VzdG9tSW50ZXJwb2xhdGlvbkFwcC5jb250cm9sbGVyKCdEZW1vQ29udHJvbGxlcicsIGZ1bmN0aW9uIERlbW9Db250cm9sbGVyKCkge1xuICAgICAgdGhpcy5sYWJlbCA9IFwiVGhpcyBiaW5kaW5nIGlzIGJyb3VnaHQgeW91IGJ5IC8vIGludGVycG9sYXRpb24gc3ltYm9scy5cIjtcbiAgfSk7XG48L3NjcmlwdD5cbjxkaXYgbmctYXBwPVwiQXBwXCIgbmctY29udHJvbGxlcj1cIkRlbW9Db250cm9sbGVyIGFzIGRlbW9cIj5cbiAgICAvL2RlbW8ubGFiZWwvL1xuPC9kaXY+XG48L2RvYzpzb3VyY2U+XG48ZG9jOnNjZW5hcmlvPlxuIGl0KCdzaG91bGQgaW50ZXJwb2xhdGUgYmluZGluZyB3aXRoIGN1c3RvbSBzeW1ib2xzJywgZnVuY3Rpb24oKSB7XG4gIGV4cGVjdChiaW5kaW5nKCdkZW1vLmxhYmVsJykpLnRvQmUoJ1RoaXMgYmluZGluZyBpcyBicm91Z2h0IHlvdSBieSAvLyBpbnRlcnBvbGF0aW9uIHN5bWJvbHMuJyk7XG4gfSk7XG48L2RvYzpzY2VuYXJpbz5cbjwvZG9jOmV4YW1wbGU+XG4gKi9cbmZ1bmN0aW9uICRJbnRlcnBvbGF0ZVByb3ZpZGVyKCkge1xuICB2YXIgc3RhcnRTeW1ib2wgPSAne3snO1xuICB2YXIgZW5kU3ltYm9sID0gJ319JztcblxuICAvKipcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSBuZy4kaW50ZXJwb2xhdGVQcm92aWRlciNzdGFydFN5bWJvbFxuICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlUHJvdmlkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFN5bWJvbCB0byBkZW5vdGUgc3RhcnQgb2YgZXhwcmVzc2lvbiBpbiB0aGUgaW50ZXJwb2xhdGVkIHN0cmluZy4gRGVmYXVsdHMgdG8gYHt7YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB2YWx1ZSBuZXcgdmFsdWUgdG8gc2V0IHRoZSBzdGFydGluZyBzeW1ib2wgdG8uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8c2VsZn0gUmV0dXJucyB0aGUgc3ltYm9sIHdoZW4gdXNlZCBhcyBnZXR0ZXIgYW5kIHNlbGYgaWYgdXNlZCBhcyBzZXR0ZXIuXG4gICAqL1xuICB0aGlzLnN0YXJ0U3ltYm9sID0gZnVuY3Rpb24odmFsdWUpe1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3RhcnRTeW1ib2wgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhcnRTeW1ib2w7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyI2VuZFN5bWJvbFxuICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlUHJvdmlkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFN5bWJvbCB0byBkZW5vdGUgdGhlIGVuZCBvZiBleHByZXNzaW9uIGluIHRoZSBpbnRlcnBvbGF0ZWQgc3RyaW5nLiBEZWZhdWx0cyB0byBgfX1gLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHZhbHVlIG5ldyB2YWx1ZSB0byBzZXQgdGhlIGVuZGluZyBzeW1ib2wgdG8uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8c2VsZn0gUmV0dXJucyB0aGUgc3ltYm9sIHdoZW4gdXNlZCBhcyBnZXR0ZXIgYW5kIHNlbGYgaWYgdXNlZCBhcyBzZXR0ZXIuXG4gICAqL1xuICB0aGlzLmVuZFN5bWJvbCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVuZFN5bWJvbCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbmRTeW1ib2w7XG4gICAgfVxuICB9O1xuXG5cbiAgdGhpcy4kZ2V0ID0gWyckcGFyc2UnLCAnJGV4Y2VwdGlvbkhhbmRsZXInLCAnJHNjZScsIGZ1bmN0aW9uKCRwYXJzZSwgJGV4Y2VwdGlvbkhhbmRsZXIsICRzY2UpIHtcbiAgICB2YXIgc3RhcnRTeW1ib2xMZW5ndGggPSBzdGFydFN5bWJvbC5sZW5ndGgsXG4gICAgICAgIGVuZFN5bWJvbExlbmd0aCA9IGVuZFN5bWJvbC5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBuZy4kaW50ZXJwb2xhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXF1aXJlcyAkcGFyc2VcbiAgICAgKiBAcmVxdWlyZXMgJHNjZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb21waWxlcyBhIHN0cmluZyB3aXRoIG1hcmt1cCBpbnRvIGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24uIFRoaXMgc2VydmljZSBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIEhUTUwge0BsaW5rIG5nLiRjb21waWxlICRjb21waWxlfSBzZXJ2aWNlIGZvciBkYXRhIGJpbmRpbmcuIFNlZVxuICAgICAqIHtAbGluayBuZy4kaW50ZXJwb2xhdGVQcm92aWRlciAkaW50ZXJwb2xhdGVQcm92aWRlcn0gZm9yIGNvbmZpZ3VyaW5nIHRoZVxuICAgICAqIGludGVycG9sYXRpb24gbWFya3VwLlxuICAgICAqXG4gICAgICpcbiAgICAgICA8cHJlPlxuICAgICAgICAgdmFyICRpbnRlcnBvbGF0ZSA9IC4uLjsgLy8gaW5qZWN0ZWRcbiAgICAgICAgIHZhciBleHAgPSAkaW50ZXJwb2xhdGUoJ0hlbGxvIHt7bmFtZSB8IHVwcGVyY2FzZX19IScpO1xuICAgICAgICAgZXhwZWN0KGV4cCh7bmFtZTonQW5ndWxhcid9KS50b0VxdWFsKCdIZWxsbyBBTkdVTEFSIScpO1xuICAgICAgIDwvcHJlPlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB3aXRoIG1hcmt1cCB0byBpbnRlcnBvbGF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtdXN0SGF2ZUV4cHJlc3Npb24gaWYgc2V0IHRvIHRydWUgdGhlbiB0aGUgaW50ZXJwb2xhdGlvbiBzdHJpbmcgbXVzdCBoYXZlXG4gICAgICogICAgZW1iZWRkZWQgZXhwcmVzc2lvbiBpbiBvcmRlciB0byByZXR1cm4gYW4gaW50ZXJwb2xhdGlvbiBmdW5jdGlvbi4gU3RyaW5ncyB3aXRoIG5vXG4gICAgICogICAgZW1iZWRkZWQgZXhwcmVzc2lvbiB3aWxsIHJldHVybiBudWxsIGZvciB0aGUgaW50ZXJwb2xhdGlvbiBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRydXN0ZWRDb250ZXh0IHdoZW4gcHJvdmlkZWQsIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBwYXNzZXMgdGhlIGludGVycG9sYXRlZFxuICAgICAqICAgIHJlc3VsdCB0aHJvdWdoIHtAbGluayBuZy4kc2NlI21ldGhvZHNfZ2V0VHJ1c3RlZCAkc2NlLmdldFRydXN0ZWQoaW50ZXJwb2xhdGVkUmVzdWx0LFxuICAgICAqICAgIHRydXN0ZWRDb250ZXh0KX0gYmVmb3JlIHJldHVybmluZyBpdC4gIFJlZmVyIHRvIHRoZSB7QGxpbmsgbmcuJHNjZSAkc2NlfSBzZXJ2aWNlIHRoYXRcbiAgICAgKiAgICBwcm92aWRlcyBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyBmb3IgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCl9IGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24gd2hpY2ggaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICAgICAqICAgIGludGVycG9sYXRlZCBzdHJpbmcuIFRoZSBmdW5jdGlvbiBoYXMgdGhlc2UgcGFyYW1ldGVyczpcbiAgICAgKlxuICAgICAqICAgICogYGNvbnRleHRgOiBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3MgYXJlIGV2YWx1YXRlZFxuICAgICAqICAgICAgYWdhaW5zdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uICRpbnRlcnBvbGF0ZSh0ZXh0LCBtdXN0SGF2ZUV4cHJlc3Npb24sIHRydXN0ZWRDb250ZXh0KSB7XG4gICAgICB2YXIgc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleCxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgcGFydHMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgICBoYXNJbnRlcnBvbGF0aW9uID0gZmFsc2UsXG4gICAgICAgICAgZm4sXG4gICAgICAgICAgZXhwLFxuICAgICAgICAgIGNvbmNhdCA9IFtdO1xuXG4gICAgICB3aGlsZShpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoICgoc3RhcnRJbmRleCA9IHRleHQuaW5kZXhPZihzdGFydFN5bWJvbCwgaW5kZXgpKSAhPSAtMSkgJiZcbiAgICAgICAgICAgICAoKGVuZEluZGV4ID0gdGV4dC5pbmRleE9mKGVuZFN5bWJvbCwgc3RhcnRJbmRleCArIHN0YXJ0U3ltYm9sTGVuZ3RoKSkgIT0gLTEpICkge1xuICAgICAgICAgIChpbmRleCAhPSBzdGFydEluZGV4KSAmJiBwYXJ0cy5wdXNoKHRleHQuc3Vic3RyaW5nKGluZGV4LCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgcGFydHMucHVzaChmbiA9ICRwYXJzZShleHAgPSB0ZXh0LnN1YnN0cmluZyhzdGFydEluZGV4ICsgc3RhcnRTeW1ib2xMZW5ndGgsIGVuZEluZGV4KSkpO1xuICAgICAgICAgIGZuLmV4cCA9IGV4cDtcbiAgICAgICAgICBpbmRleCA9IGVuZEluZGV4ICsgZW5kU3ltYm9sTGVuZ3RoO1xuICAgICAgICAgIGhhc0ludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIGRpZCBub3QgZmluZCBhbnl0aGluZywgc28gd2UgaGF2ZSB0byBhZGQgdGhlIHJlbWFpbmRlciB0byB0aGUgcGFydHMgYXJyYXlcbiAgICAgICAgICAoaW5kZXggIT0gbGVuZ3RoKSAmJiBwYXJ0cy5wdXNoKHRleHQuc3Vic3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCEobGVuZ3RoID0gcGFydHMubGVuZ3RoKSkge1xuICAgICAgICAvLyB3ZSBhZGRlZCwgbm90aGluZywgbXVzdCBoYXZlIGJlZW4gYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29uY2F0ZW5hdGluZyBleHByZXNzaW9ucyBtYWtlcyBpdCBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGV0aGVyIHNvbWUgY29tYmluYXRpb24gb2ZcbiAgICAgIC8vIGNvbmNhdGVuYXRlZCB2YWx1ZXMgYXJlIHVuc2FmZSB0byB1c2UgYW5kIGNvdWxkIGVhc2lseSBsZWFkIHRvIFhTUy4gIEJ5IHJlcXVpcmluZyB0aGF0IGFcbiAgICAgIC8vIHNpbmdsZSBleHByZXNzaW9uIGJlIHVzZWQgZm9yIGlmcmFtZVtzcmNdLCBvYmplY3Rbc3JjXSwgZXRjLiwgd2UgZW5zdXJlIHRoYXQgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0J3MgdXNlZCBpcyBhc3NpZ25lZCBvciBjb25zdHJ1Y3RlZCBieSBzb21lIEpTIGNvZGUgc29tZXdoZXJlIHRoYXQgaXMgbW9yZSB0ZXN0YWJsZSBvclxuICAgICAgLy8gbWFrZSBpdCBvYnZpb3VzIHRoYXQgeW91IGJvdW5kIHRoZSB2YWx1ZSB0byBzb21lIHVzZXIgY29udHJvbGxlZCB2YWx1ZS4gIFRoaXMgaGVscHMgcmVkdWNlXG4gICAgICAvLyB0aGUgbG9hZCB3aGVuIGF1ZGl0aW5nIGZvciBYU1MgaXNzdWVzLlxuICAgICAgaWYgKHRydXN0ZWRDb250ZXh0ICYmIHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyAkaW50ZXJwb2xhdGVNaW5FcnIoJ25vY29uY2F0JyxcbiAgICAgICAgICAgICAgXCJFcnJvciB3aGlsZSBpbnRlcnBvbGF0aW5nOiB7MH1cXG5TdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyBkaXNhbGxvd3MgXCIgK1xuICAgICAgICAgICAgICBcImludGVycG9sYXRpb25zIHRoYXQgY29uY2F0ZW5hdGUgbXVsdGlwbGUgZXhwcmVzc2lvbnMgd2hlbiBhIHRydXN0ZWQgdmFsdWUgaXMgXCIgK1xuICAgICAgICAgICAgICBcInJlcXVpcmVkLiAgU2VlIGh0dHA6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nLiRzY2VcIiwgdGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbXVzdEhhdmVFeHByZXNzaW9uICB8fCBoYXNJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIGNvbmNhdC5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZuID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBpaSA9IGxlbmd0aCwgcGFydDsgaTxpaTsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgKHBhcnQgPSBwYXJ0c1tpXSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSBwYXJ0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh0cnVzdGVkQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgcGFydCA9ICRzY2UuZ2V0VHJ1c3RlZCh0cnVzdGVkQ29udGV4dCwgcGFydCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnQgPSAkc2NlLnZhbHVlT2YocGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFydCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcGFydCA9IHRvSnNvbihwYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uY2F0W2ldID0gcGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25jYXQuam9pbignJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoKGVycikge1xuICAgICAgICAgICAgdmFyIG5ld0VyciA9ICRpbnRlcnBvbGF0ZU1pbkVycignaW50ZXJyJywgXCJDYW4ndCBpbnRlcnBvbGF0ZTogezB9XFxuezF9XCIsIHRleHQsXG4gICAgICAgICAgICAgICAgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIobmV3RXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZuLmV4cCA9IHRleHQ7XG4gICAgICAgIGZuLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBuZy4kaW50ZXJwb2xhdGUjc3RhcnRTeW1ib2xcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU3ltYm9sIHRvIGRlbm90ZSB0aGUgc3RhcnQgb2YgZXhwcmVzc2lvbiBpbiB0aGUgaW50ZXJwb2xhdGVkIHN0cmluZy4gRGVmYXVsdHMgdG8gYHt7YC5cbiAgICAgKlxuICAgICAqIFVzZSB7QGxpbmsgbmcuJGludGVycG9sYXRlUHJvdmlkZXIjc3RhcnRTeW1ib2wgJGludGVycG9sYXRlUHJvdmlkZXIjc3RhcnRTeW1ib2x9IHRvIGNoYW5nZVxuICAgICAqIHRoZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdGFydCBzeW1ib2wuXG4gICAgICovXG4gICAgJGludGVycG9sYXRlLnN0YXJ0U3ltYm9sID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RhcnRTeW1ib2w7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRpbnRlcnBvbGF0ZSNlbmRTeW1ib2xcbiAgICAgKiBAbWV0aG9kT2YgbmcuJGludGVycG9sYXRlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU3ltYm9sIHRvIGRlbm90ZSB0aGUgZW5kIG9mIGV4cHJlc3Npb24gaW4gdGhlIGludGVycG9sYXRlZCBzdHJpbmcuIERlZmF1bHRzIHRvIGB9fWAuXG4gICAgICpcbiAgICAgKiBVc2Uge0BsaW5rIG5nLiRpbnRlcnBvbGF0ZVByb3ZpZGVyI2VuZFN5bWJvbCAkaW50ZXJwb2xhdGVQcm92aWRlciNlbmRTeW1ib2x9IHRvIGNoYW5nZVxuICAgICAqIHRoZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdGFydCBzeW1ib2wuXG4gICAgICovXG4gICAgJGludGVycG9sYXRlLmVuZFN5bWJvbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVuZFN5bWJvbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuICRpbnRlcnBvbGF0ZTtcbiAgfV07XG59XG5cbmZ1bmN0aW9uICRJbnRlcnZhbFByb3ZpZGVyKCkge1xuICB0aGlzLiRnZXQgPSBbJyRyb290U2NvcGUnLCAnJHdpbmRvdycsICckcScsXG4gICAgICAgZnVuY3Rpb24oJHJvb3RTY29wZSwgICAkd2luZG93LCAgICRxKSB7XG4gICAgdmFyIGludGVydmFscyA9IHt9O1xuXG5cbiAgICAgLyoqXG4gICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgKiBAbmFtZSBuZy4kaW50ZXJ2YWxcbiAgICAgICpcbiAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAqIEFuZ3VsYXIncyB3cmFwcGVyIGZvciBgd2luZG93LnNldEludGVydmFsYC4gVGhlIGBmbmAgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZXZlcnkgYGRlbGF5YFxuICAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICAqXG4gICAgICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgcmVnaXN0ZXJpbmcgYW4gaW50ZXJ2YWwgZnVuY3Rpb24gaXMgYSBwcm9taXNlLiBUaGlzIHByb21pc2Ugd2lsbCBiZVxuICAgICAgKiBub3RpZmllZCB1cG9uIGVhY2ggdGljayBvZiB0aGUgaW50ZXJ2YWwsIGFuZCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIGBjb3VudGAgaXRlcmF0aW9ucywgb3JcbiAgICAgICogcnVuIGluZGVmaW5pdGVseSBpZiBgY291bnRgIGlzIG5vdCBkZWZpbmVkLiBUaGUgdmFsdWUgb2YgdGhlIG5vdGlmaWNhdGlvbiB3aWxsIGJlIHRoZVxuICAgICAgKiBudW1iZXIgb2YgaXRlcmF0aW9ucyB0aGF0IGhhdmUgcnVuLlxuICAgICAgKiBUbyBjYW5jZWwgYW4gaW50ZXJ2YWwsIGNhbGwgYCRpbnRlcnZhbC5jYW5jZWwocHJvbWlzZSlgLlxuICAgICAgKlxuICAgICAgKiBJbiB0ZXN0cyB5b3UgY2FuIHVzZSB7QGxpbmsgbmdNb2NrLiRpbnRlcnZhbCNtZXRob2RzX2ZsdXNoIGAkaW50ZXJ2YWwuZmx1c2gobWlsbGlzKWB9IHRvXG4gICAgICAqIG1vdmUgZm9yd2FyZCBieSBgbWlsbGlzYCBtaWxsaXNlY29uZHMgYW5kIHRyaWdnZXIgYW55IGZ1bmN0aW9ucyBzY2hlZHVsZWQgdG8gcnVuIGluIHRoYXRcbiAgICAgICogdGltZS5cbiAgICAgICogXG4gICAgICAqIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC13YXJuaW5nXCI+XG4gICAgICAqICoqTm90ZSoqOiBJbnRlcnZhbHMgY3JlYXRlZCBieSB0aGlzIHNlcnZpY2UgbXVzdCBiZSBleHBsaWNpdGx5IGRlc3Ryb3llZCB3aGVuIHlvdSBhcmUgZmluaXNoZWRcbiAgICAgICogd2l0aCB0aGVtLiAgSW4gcGFydGljdWxhciB0aGV5IGFyZSBub3QgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgd2hlbiBhIGNvbnRyb2xsZXIncyBzY29wZSBvciBhXG4gICAgICAqIGRpcmVjdGl2ZSdzIGVsZW1lbnQgYXJlIGRlc3Ryb3llZC5cbiAgICAgICogWW91IHNob3VsZCB0YWtlIHRoaXMgaW50byBjb25zaWRlcmF0aW9uIGFuZCBtYWtlIHN1cmUgdG8gYWx3YXlzIGNhbmNlbCB0aGUgaW50ZXJ2YWwgYXQgdGhlXG4gICAgICAqIGFwcHJvcHJpYXRlIG1vbWVudC4gIFNlZSB0aGUgZXhhbXBsZSBiZWxvdyBmb3IgbW9yZSBkZXRhaWxzIG9uIGhvdyBhbmQgd2hlbiB0byBkbyB0aGlzLlxuICAgICAgKiA8L2Rpdj5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBmbiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCByZXBlYXRlZGx5LlxuICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGVhY2ggZnVuY3Rpb24gY2FsbC5cbiAgICAgICogQHBhcmFtIHtudW1iZXI9fSBbY291bnQ9MF0gTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdC4gSWYgbm90IHNldCwgb3IgMCwgd2lsbCByZXBlYXRcbiAgICAgICogICBpbmRlZmluaXRlbHkuXG4gICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbnZva2VBcHBseT10cnVlXSBJZiBzZXQgdG8gYGZhbHNlYCBza2lwcyBtb2RlbCBkaXJ0eSBjaGVja2luZywgb3RoZXJ3aXNlXG4gICAgICAqICAgd2lsbCBpbnZva2UgYGZuYCB3aXRoaW4gdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGFwcGx5ICRhcHBseX0gYmxvY2suXG4gICAgICAqIEByZXR1cm5zIHtwcm9taXNlfSBBIHByb21pc2Ugd2hpY2ggd2lsbCBiZSBub3RpZmllZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICpcbiAgICAgICogQGV4YW1wbGVcbiAgICAgIDxkb2M6ZXhhbXBsZSBtb2R1bGU9XCJ0aW1lXCI+XG4gICAgICAgIDxkb2M6c291cmNlPlxuICAgICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICAgICBmdW5jdGlvbiBDdHJsMigkc2NvcGUsJGludGVydmFsKSB7XG4gICAgICAgICAgICAgICRzY29wZS5mb3JtYXQgPSAnTS9kL3l5IGg6bW06c3MgYSc7XG4gICAgICAgICAgICAgICRzY29wZS5ibG9vZF8xID0gMTAwO1xuICAgICAgICAgICAgICAkc2NvcGUuYmxvb2RfMiA9IDEyMDtcblxuICAgICAgICAgICAgICB2YXIgc3RvcDtcbiAgICAgICAgICAgICAgJHNjb3BlLmZpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3RhcnQgYSBuZXcgZmlnaHQgaWYgd2UgYXJlIGFscmVhZHkgZmlnaHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoIGFuZ3VsYXIuaXNEZWZpbmVkKHN0b3ApICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgc3RvcCA9ICRpbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuYmxvb2RfMSA+IDAgJiYgJHNjb3BlLmJsb29kXzIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJsb29kXzEgPSAkc2NvcGUuYmxvb2RfMSAtIDM7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmJsb29kXzIgPSAkc2NvcGUuYmxvb2RfMiAtIDQ7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5zdG9wRmlnaHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICRzY29wZS5zdG9wRmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoc3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICRpbnRlcnZhbC5jYW5jZWwoc3RvcCk7XG4gICAgICAgICAgICAgICAgICBzdG9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAkc2NvcGUucmVzZXRGaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5ibG9vZF8xID0gMTAwO1xuICAgICAgICAgICAgICAgICRzY29wZS5ibG9vZF8yID0gMTIwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaW50ZXJ2YWwgaXMgZGVzdHJveWVkIHRvb1xuICAgICAgICAgICAgICAgICRzY29wZS5zdG9wRmlnaHQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuZ3VsYXIubW9kdWxlKCd0aW1lJywgW10pXG4gICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSAnbXlDdXJyZW50VGltZScgZGlyZWN0aXZlIGZhY3RvcnkgbWV0aG9kLlxuICAgICAgICAgICAgICAvLyBXZSBpbmplY3QgJGludGVydmFsIGFuZCBkYXRlRmlsdGVyIHNlcnZpY2Ugc2luY2UgdGhlIGZhY3RvcnkgbWV0aG9kIGlzIERJLlxuICAgICAgICAgICAgICAuZGlyZWN0aXZlKCdteUN1cnJlbnRUaW1lJywgZnVuY3Rpb24oJGludGVydmFsLCBkYXRlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBkaXJlY3RpdmUgbGluayBmdW5jdGlvbi4gKGNvbXBpbGUgZnVuY3Rpb24gbm90IG5lZWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0LCAgLy8gZGF0ZSBmb3JtYXRcbiAgICAgICAgICAgICAgICAgIHN0b3BUaW1lOyAvLyBzbyB0aGF0IHdlIGNhbiBjYW5jZWwgdGhlIHRpbWUgdXBkYXRlc1xuXG4gICAgICAgICAgICAgICAgICAvLyB1c2VkIHRvIHVwZGF0ZSB0aGUgVUlcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbWUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQudGV4dChkYXRlRmlsdGVyKG5ldyBEYXRlKCksIGZvcm1hdCkpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyB3YXRjaCB0aGUgZXhwcmVzc2lvbiwgYW5kIHVwZGF0ZSB0aGUgVUkgb24gY2hhbmdlLlxuICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKGF0dHJzLm15Q3VycmVudFRpbWUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgc3RvcFRpbWUgPSAkaW50ZXJ2YWwodXBkYXRlVGltZSwgMTAwMCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbiBvbiBET00gZGVzdHJveSAocmVtb3ZhbCkgZXZlbnQsIGFuZCBjYW5jZWwgdGhlIG5leHQgVUkgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAvLyB0byBwcmV2ZW50IHVwZGF0aW5nIHRpbWUgb2Z0ZXIgdGhlIERPTSBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5iaW5kKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkaW50ZXJ2YWwuY2FuY2VsKHN0b3BUaW1lKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgPC9zY3JpcHQ+XG5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybDJcIj5cbiAgICAgICAgICAgICAgRGF0ZSBmb3JtYXQ6IDxpbnB1dCBuZy1tb2RlbD1cImZvcm1hdFwiPiA8aHIvPlxuICAgICAgICAgICAgICBDdXJyZW50IHRpbWUgaXM6IDxzcGFuIG15LWN1cnJlbnQtdGltZT1cImZvcm1hdFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgPGhyLz5cbiAgICAgICAgICAgICAgQmxvb2QgMSA6IDxmb250IGNvbG9yPSdyZWQnPnt7Ymxvb2RfMX19PC9mb250PlxuICAgICAgICAgICAgICBCbG9vZCAyIDogPGZvbnQgY29sb3I9J3JlZCc+e3tibG9vZF8yfX08L2ZvbnQ+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtbmctY2xpY2s9XCJmaWdodCgpXCI+RmlnaHQ8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgZGF0YS1uZy1jbGljaz1cInN0b3BGaWdodCgpXCI+U3RvcEZpZ2h0PC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtbmctY2xpY2s9XCJyZXNldEZpZ2h0KClcIj5yZXNldEZpZ2h0PC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2RvYzpzb3VyY2U+XG4gICAgICA8L2RvYzpleGFtcGxlPlxuICAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnZhbChmbiwgZGVsYXksIGNvdW50LCBpbnZva2VBcHBseSkge1xuICAgICAgdmFyIHNldEludGVydmFsID0gJHdpbmRvdy5zZXRJbnRlcnZhbCxcbiAgICAgICAgICBjbGVhckludGVydmFsID0gJHdpbmRvdy5jbGVhckludGVydmFsLFxuICAgICAgICAgIGRlZmVycmVkID0gJHEuZGVmZXIoKSxcbiAgICAgICAgICBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICBpdGVyYXRpb24gPSAwLFxuICAgICAgICAgIHNraXBBcHBseSA9IChpc0RlZmluZWQoaW52b2tlQXBwbHkpICYmICFpbnZva2VBcHBseSk7XG4gICAgICBcbiAgICAgIGNvdW50ID0gaXNEZWZpbmVkKGNvdW50KSA/IGNvdW50IDogMCxcblxuICAgICAgcHJvbWlzZS50aGVuKG51bGwsIG51bGwsIGZuKTtcblxuICAgICAgcHJvbWlzZS4kJGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICBkZWZlcnJlZC5ub3RpZnkoaXRlcmF0aW9uKyspO1xuXG4gICAgICAgIGlmIChjb3VudCA+IDAgJiYgaXRlcmF0aW9uID49IGNvdW50KSB7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpdGVyYXRpb24pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvbWlzZS4kJGludGVydmFsSWQpO1xuICAgICAgICAgIGRlbGV0ZSBpbnRlcnZhbHNbcHJvbWlzZS4kJGludGVydmFsSWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwQXBwbHkpICRyb290U2NvcGUuJGFwcGx5KCk7XG5cbiAgICAgIH0sIGRlbGF5KTtcblxuICAgICAgaW50ZXJ2YWxzW3Byb21pc2UuJCRpbnRlcnZhbElkXSA9IGRlZmVycmVkO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cblxuICAgICAvKipcbiAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAqIEBuYW1lIG5nLiRpbnRlcnZhbCNjYW5jZWxcbiAgICAgICogQG1ldGhvZE9mIG5nLiRpbnRlcnZhbFxuICAgICAgKlxuICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICogQ2FuY2VscyBhIHRhc2sgYXNzb2NpYXRlZCB3aXRoIHRoZSBgcHJvbWlzZWAuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9taXNlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGAkaW50ZXJ2YWxgIGZ1bmN0aW9uLlxuICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhc2sgd2FzIHN1Y2Nlc3NmdWxseSBjYW5jZWxlZC5cbiAgICAgICovXG4gICAgaW50ZXJ2YWwuY2FuY2VsID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UgJiYgcHJvbWlzZS4kJGludGVydmFsSWQgaW4gaW50ZXJ2YWxzKSB7XG4gICAgICAgIGludGVydmFsc1twcm9taXNlLiQkaW50ZXJ2YWxJZF0ucmVqZWN0KCdjYW5jZWxlZCcpO1xuICAgICAgICBjbGVhckludGVydmFsKHByb21pc2UuJCRpbnRlcnZhbElkKTtcbiAgICAgICAgZGVsZXRlIGludGVydmFsc1twcm9taXNlLiQkaW50ZXJ2YWxJZF07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1dO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRsb2NhbGVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICRsb2NhbGUgc2VydmljZSBwcm92aWRlcyBsb2NhbGl6YXRpb24gcnVsZXMgZm9yIHZhcmlvdXMgQW5ndWxhciBjb21wb25lbnRzLiBBcyBvZiByaWdodCBub3cgdGhlXG4gKiBvbmx5IHB1YmxpYyBhcGkgaXM6XG4gKlxuICogKiBgaWRgIOKAkyBge3N0cmluZ31gIOKAkyBsb2NhbGUgaWQgZm9ybWF0dGVkIGFzIGBsYW5ndWFnZUlkLWNvdW50cnlJZGAgKGUuZy4gYGVuLXVzYClcbiAqL1xuZnVuY3Rpb24gJExvY2FsZVByb3ZpZGVyKCl7XG4gIHRoaXMuJGdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJ2VuLXVzJyxcblxuICAgICAgTlVNQkVSX0ZPUk1BVFM6IHtcbiAgICAgICAgREVDSU1BTF9TRVA6ICcuJyxcbiAgICAgICAgR1JPVVBfU0VQOiAnLCcsXG4gICAgICAgIFBBVFRFUk5TOiBbXG4gICAgICAgICAgeyAvLyBEZWNpbWFsIFBhdHRlcm5cbiAgICAgICAgICAgIG1pbkludDogMSxcbiAgICAgICAgICAgIG1pbkZyYWM6IDAsXG4gICAgICAgICAgICBtYXhGcmFjOiAzLFxuICAgICAgICAgICAgcG9zUHJlOiAnJyxcbiAgICAgICAgICAgIHBvc1N1ZjogJycsXG4gICAgICAgICAgICBuZWdQcmU6ICctJyxcbiAgICAgICAgICAgIG5lZ1N1ZjogJycsXG4gICAgICAgICAgICBnU2l6ZTogMyxcbiAgICAgICAgICAgIGxnU2l6ZTogM1xuICAgICAgICAgIH0seyAvL0N1cnJlbmN5IFBhdHRlcm5cbiAgICAgICAgICAgIG1pbkludDogMSxcbiAgICAgICAgICAgIG1pbkZyYWM6IDIsXG4gICAgICAgICAgICBtYXhGcmFjOiAyLFxuICAgICAgICAgICAgcG9zUHJlOiAnXFx1MDBBNCcsXG4gICAgICAgICAgICBwb3NTdWY6ICcnLFxuICAgICAgICAgICAgbmVnUHJlOiAnKFxcdTAwQTQnLFxuICAgICAgICAgICAgbmVnU3VmOiAnKScsXG4gICAgICAgICAgICBnU2l6ZTogMyxcbiAgICAgICAgICAgIGxnU2l6ZTogM1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgQ1VSUkVOQ1lfU1lNOiAnJCdcbiAgICAgIH0sXG5cbiAgICAgIERBVEVUSU1FX0ZPUk1BVFM6IHtcbiAgICAgICAgTU9OVEg6XG4gICAgICAgICAgICAnSmFudWFyeSxGZWJydWFyeSxNYXJjaCxBcHJpbCxNYXksSnVuZSxKdWx5LEF1Z3VzdCxTZXB0ZW1iZXIsT2N0b2JlcixOb3ZlbWJlcixEZWNlbWJlcidcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpLFxuICAgICAgICBTSE9SVE1PTlRIOiAgJ0phbixGZWIsTWFyLEFwcixNYXksSnVuLEp1bCxBdWcsU2VwLE9jdCxOb3YsRGVjJy5zcGxpdCgnLCcpLFxuICAgICAgICBEQVk6ICdTdW5kYXksTW9uZGF5LFR1ZXNkYXksV2VkbmVzZGF5LFRodXJzZGF5LEZyaWRheSxTYXR1cmRheScuc3BsaXQoJywnKSxcbiAgICAgICAgU0hPUlREQVk6ICdTdW4sTW9uLFR1ZSxXZWQsVGh1LEZyaSxTYXQnLnNwbGl0KCcsJyksXG4gICAgICAgIEFNUE1TOiBbJ0FNJywnUE0nXSxcbiAgICAgICAgbWVkaXVtOiAnTU1NIGQsIHkgaDptbTpzcyBhJyxcbiAgICAgICAgc2hvcnQ6ICdNL2QveXkgaDptbSBhJyxcbiAgICAgICAgZnVsbERhdGU6ICdFRUVFLCBNTU1NIGQsIHknLFxuICAgICAgICBsb25nRGF0ZTogJ01NTU0gZCwgeScsXG4gICAgICAgIG1lZGl1bURhdGU6ICdNTU0gZCwgeScsXG4gICAgICAgIHNob3J0RGF0ZTogJ00vZC95eScsXG4gICAgICAgIG1lZGl1bVRpbWU6ICdoOm1tOnNzIGEnLFxuICAgICAgICBzaG9ydFRpbWU6ICdoOm1tIGEnXG4gICAgICB9LFxuXG4gICAgICBwbHVyYWxDYXQ6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuICdvbmUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbnZhciBQQVRIX01BVENIID0gL14oW15cXD8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/JC8sXG4gICAgREVGQVVMVF9QT1JUUyA9IHsnaHR0cCc6IDgwLCAnaHR0cHMnOiA0NDMsICdmdHAnOiAyMX07XG52YXIgJGxvY2F0aW9uTWluRXJyID0gbWluRXJyKCckbG9jYXRpb24nKTtcblxuXG4vKipcbiAqIEVuY29kZSBwYXRoIHVzaW5nIGVuY29kZVVyaVNlZ21lbnQsIGlnbm9yaW5nIGZvcndhcmQgc2xhc2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdG8gZW5jb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpLFxuICAgICAgaSA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2VnbWVudHNbaV0gPSBlbmNvZGVVcmlTZWdtZW50KHNlZ21lbnRzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50cy5qb2luKCcvJyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQWJzb2x1dGVVcmwoYWJzb2x1dGVVcmwsIGxvY2F0aW9uT2JqLCBhcHBCYXNlKSB7XG4gIHZhciBwYXJzZWRVcmwgPSB1cmxSZXNvbHZlKGFic29sdXRlVXJsLCBhcHBCYXNlKTtcblxuICBsb2NhdGlvbk9iai4kJHByb3RvY29sID0gcGFyc2VkVXJsLnByb3RvY29sO1xuICBsb2NhdGlvbk9iai4kJGhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIGxvY2F0aW9uT2JqLiQkcG9ydCA9IGludChwYXJzZWRVcmwucG9ydCkgfHwgREVGQVVMVF9QT1JUU1twYXJzZWRVcmwucHJvdG9jb2xdIHx8IG51bGw7XG59XG5cblxuZnVuY3Rpb24gcGFyc2VBcHBVcmwocmVsYXRpdmVVcmwsIGxvY2F0aW9uT2JqLCBhcHBCYXNlKSB7XG4gIHZhciBwcmVmaXhlZCA9IChyZWxhdGl2ZVVybC5jaGFyQXQoMCkgIT09ICcvJyk7XG4gIGlmIChwcmVmaXhlZCkge1xuICAgIHJlbGF0aXZlVXJsID0gJy8nICsgcmVsYXRpdmVVcmw7XG4gIH1cbiAgdmFyIG1hdGNoID0gdXJsUmVzb2x2ZShyZWxhdGl2ZVVybCwgYXBwQmFzZSk7XG4gIGxvY2F0aW9uT2JqLiQkcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudChwcmVmaXhlZCAmJiBtYXRjaC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/XG4gICAgICBtYXRjaC5wYXRobmFtZS5zdWJzdHJpbmcoMSkgOiBtYXRjaC5wYXRobmFtZSk7XG4gIGxvY2F0aW9uT2JqLiQkc2VhcmNoID0gcGFyc2VLZXlWYWx1ZShtYXRjaC5zZWFyY2gpO1xuICBsb2NhdGlvbk9iai4kJGhhc2ggPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2guaGFzaCk7XG5cbiAgLy8gbWFrZSBzdXJlIHBhdGggc3RhcnRzIHdpdGggJy8nO1xuICBpZiAobG9jYXRpb25PYmouJCRwYXRoICYmIGxvY2F0aW9uT2JqLiQkcGF0aC5jaGFyQXQoMCkgIT0gJy8nKSB7XG4gICAgbG9jYXRpb25PYmouJCRwYXRoID0gJy8nICsgbG9jYXRpb25PYmouJCRwYXRoO1xuICB9XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJlZ2luXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHJldHVybnMgdGV4dCBmcm9tIHdob2xlIGFmdGVyIGJlZ2luIG9yIHVuZGVmaW5lZCBpZiBpdCBkb2VzIG5vdCBiZWdpbiB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICBleHBlY3RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJlZ2luc1dpdGgoYmVnaW4sIHdob2xlKSB7XG4gIGlmICh3aG9sZS5pbmRleE9mKGJlZ2luKSA9PT0gMCkge1xuICAgIHJldHVybiB3aG9sZS5zdWJzdHIoYmVnaW4ubGVuZ3RoKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0cmlwSGFzaCh1cmwpIHtcbiAgdmFyIGluZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09IC0xID8gdXJsIDogdXJsLnN1YnN0cigwLCBpbmRleCk7XG59XG5cblxuZnVuY3Rpb24gc3RyaXBGaWxlKHVybCkge1xuICByZXR1cm4gdXJsLnN1YnN0cigwLCBzdHJpcEhhc2godXJsKS5sYXN0SW5kZXhPZignLycpICsgMSk7XG59XG5cbi8qIHJldHVybiB0aGUgc2VydmVyIG9ubHkgKHNjaGVtZTovL2hvc3Q6cG9ydCkgKi9cbmZ1bmN0aW9uIHNlcnZlckJhc2UodXJsKSB7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5pbmRleE9mKCcvJywgdXJsLmluZGV4T2YoJy8vJykgKyAyKSk7XG59XG5cblxuLyoqXG4gKiBMb2NhdGlvbkh0bWw1VXJsIHJlcHJlc2VudHMgYW4gdXJsXG4gKiBUaGlzIG9iamVjdCBpcyBleHBvc2VkIGFzICRsb2NhdGlvbiBzZXJ2aWNlIHdoZW4gSFRNTDUgbW9kZSBpcyBlbmFibGVkIGFuZCBzdXBwb3J0ZWRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcHBCYXNlIGFwcGxpY2F0aW9uIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVByZWZpeCB1cmwgcGF0aCBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gTG9jYXRpb25IdG1sNVVybChhcHBCYXNlLCBiYXNlUHJlZml4KSB7XG4gIHRoaXMuJCRodG1sNSA9IHRydWU7XG4gIGJhc2VQcmVmaXggPSBiYXNlUHJlZml4IHx8ICcnO1xuICB2YXIgYXBwQmFzZU5vRmlsZSA9IHN0cmlwRmlsZShhcHBCYXNlKTtcbiAgcGFyc2VBYnNvbHV0ZVVybChhcHBCYXNlLCB0aGlzLCBhcHBCYXNlKTtcblxuXG4gIC8qKlxuICAgKiBQYXJzZSBnaXZlbiBodG1sNSAocmVndWxhcikgdXJsIHN0cmluZyBpbnRvIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0Fic29sdXRlVXJsIEhUTUw1IHVybFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy4kJHBhcnNlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIHBhdGhVcmwgPSBiZWdpbnNXaXRoKGFwcEJhc2VOb0ZpbGUsIHVybCk7XG4gICAgaWYgKCFpc1N0cmluZyhwYXRoVXJsKSkge1xuICAgICAgdGhyb3cgJGxvY2F0aW9uTWluRXJyKCdpcHRocHJmeCcsICdJbnZhbGlkIHVybCBcInswfVwiLCBtaXNzaW5nIHBhdGggcHJlZml4IFwiezF9XCIuJywgdXJsLFxuICAgICAgICAgIGFwcEJhc2VOb0ZpbGUpO1xuICAgIH1cblxuICAgIHBhcnNlQXBwVXJsKHBhdGhVcmwsIHRoaXMsIGFwcEJhc2UpO1xuXG4gICAgaWYgKCF0aGlzLiQkcGF0aCkge1xuICAgICAgdGhpcy4kJHBhdGggPSAnLyc7XG4gICAgfVxuXG4gICAgdGhpcy4kJGNvbXBvc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29tcG9zZSB1cmwgYW5kIHVwZGF0ZSBgYWJzVXJsYCBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy4kJGNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VhcmNoID0gdG9LZXlWYWx1ZSh0aGlzLiQkc2VhcmNoKSxcbiAgICAgICAgaGFzaCA9IHRoaXMuJCRoYXNoID8gJyMnICsgZW5jb2RlVXJpU2VnbWVudCh0aGlzLiQkaGFzaCkgOiAnJztcblxuICAgIHRoaXMuJCR1cmwgPSBlbmNvZGVQYXRoKHRoaXMuJCRwYXRoKSArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyBoYXNoO1xuICAgIHRoaXMuJCRhYnNVcmwgPSBhcHBCYXNlTm9GaWxlICsgdGhpcy4kJHVybC5zdWJzdHIoMSk7IC8vIGZpcnN0IGNoYXIgaXMgYWx3YXlzICcvJ1xuICB9O1xuXG4gIHRoaXMuJCRyZXdyaXRlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIGFwcFVybCwgcHJldkFwcFVybDtcblxuICAgIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZSwgdXJsKSkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHByZXZBcHBVcmwgPSBhcHBVcmw7XG4gICAgICBpZiAoIChhcHBVcmwgPSBiZWdpbnNXaXRoKGJhc2VQcmVmaXgsIGFwcFVybCkpICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHJldHVybiBhcHBCYXNlTm9GaWxlICsgKGJlZ2luc1dpdGgoJy8nLCBhcHBVcmwpIHx8IGFwcFVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXBwQmFzZSArIHByZXZBcHBVcmw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZU5vRmlsZSwgdXJsKSkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHJldHVybiBhcHBCYXNlTm9GaWxlICsgYXBwVXJsO1xuICAgIH0gZWxzZSBpZiAoYXBwQmFzZU5vRmlsZSA9PSB1cmwgKyAnLycpIHtcbiAgICAgIHJldHVybiBhcHBCYXNlTm9GaWxlO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vKipcbiAqIExvY2F0aW9uSGFzaGJhbmdVcmwgcmVwcmVzZW50cyB1cmxcbiAqIFRoaXMgb2JqZWN0IGlzIGV4cG9zZWQgYXMgJGxvY2F0aW9uIHNlcnZpY2Ugd2hlbiBkZXZlbG9wZXIgZG9lc24ndCBvcHQgaW50byBodG1sNSBtb2RlLlxuICogSXQgYWxzbyBzZXJ2ZXMgYXMgdGhlIGJhc2UgY2xhc3MgZm9yIGh0bWw1IG1vZGUgZmFsbGJhY2sgb24gbGVnYWN5IGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IGFwcEJhc2UgYXBwbGljYXRpb24gYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoUHJlZml4IGhhc2hiYW5nIHByZWZpeFxuICovXG5mdW5jdGlvbiBMb2NhdGlvbkhhc2hiYW5nVXJsKGFwcEJhc2UsIGhhc2hQcmVmaXgpIHtcbiAgdmFyIGFwcEJhc2VOb0ZpbGUgPSBzdHJpcEZpbGUoYXBwQmFzZSk7XG5cbiAgcGFyc2VBYnNvbHV0ZVVybChhcHBCYXNlLCB0aGlzLCBhcHBCYXNlKTtcblxuXG4gIC8qKlxuICAgKiBQYXJzZSBnaXZlbiBoYXNoYmFuZyB1cmwgaW50byBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSGFzaGJhbmcgdXJsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLiQkcGFyc2UgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgd2l0aG91dEJhc2VVcmwgPSBiZWdpbnNXaXRoKGFwcEJhc2UsIHVybCkgfHwgYmVnaW5zV2l0aChhcHBCYXNlTm9GaWxlLCB1cmwpO1xuICAgIHZhciB3aXRob3V0SGFzaFVybCA9IHdpdGhvdXRCYXNlVXJsLmNoYXJBdCgwKSA9PSAnIydcbiAgICAgICAgPyBiZWdpbnNXaXRoKGhhc2hQcmVmaXgsIHdpdGhvdXRCYXNlVXJsKVxuICAgICAgICA6ICh0aGlzLiQkaHRtbDUpXG4gICAgICAgICAgPyB3aXRob3V0QmFzZVVybFxuICAgICAgICAgIDogJyc7XG5cbiAgICBpZiAoIWlzU3RyaW5nKHdpdGhvdXRIYXNoVXJsKSkge1xuICAgICAgdGhyb3cgJGxvY2F0aW9uTWluRXJyKCdpaHNocHJmeCcsICdJbnZhbGlkIHVybCBcInswfVwiLCBtaXNzaW5nIGhhc2ggcHJlZml4IFwiezF9XCIuJywgdXJsLFxuICAgICAgICAgIGhhc2hQcmVmaXgpO1xuICAgIH1cbiAgICBwYXJzZUFwcFVybCh3aXRob3V0SGFzaFVybCwgdGhpcywgYXBwQmFzZSk7XG5cbiAgICB0aGlzLiQkcGF0aCA9IHJlbW92ZVdpbmRvd3NEcml2ZU5hbWUodGhpcy4kJHBhdGgsIHdpdGhvdXRIYXNoVXJsLCBhcHBCYXNlKTtcblxuICAgIHRoaXMuJCRjb21wb3NlKCk7XG5cbiAgICAvKlxuICAgICAqIEluIFdpbmRvd3MsIG9uIGFuIGFuY2hvciBub2RlIG9uIGRvY3VtZW50cyBsb2FkZWQgZnJvbVxuICAgICAqIHRoZSBmaWxlc3lzdGVtLCB0aGUgYnJvd3NlciB3aWxsIHJldHVybiBhIHBhdGhuYW1lXG4gICAgICogcHJlZml4ZWQgd2l0aCB0aGUgZHJpdmUgbmFtZSAoJy9DOi9wYXRoJykgd2hlbiBhXG4gICAgICogcGF0aG5hbWUgd2l0aG91dCBhIGRyaXZlIGlzIHNldDpcbiAgICAgKiAgKiBhLnNldEF0dHJpYnV0ZSgnaHJlZicsICcvZm9vJylcbiAgICAgKiAgICogYS5wYXRobmFtZSA9PT0gJy9DOi9mb28nIC8vdHJ1ZVxuICAgICAqXG4gICAgICogSW5zaWRlIG9mIEFuZ3VsYXIsIHdlJ3JlIGFsd2F5cyB1c2luZyBwYXRobmFtZXMgdGhhdFxuICAgICAqIGRvIG5vdCBpbmNsdWRlIGRyaXZlIG5hbWVzIGZvciByb3V0aW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZVdpbmRvd3NEcml2ZU5hbWUgKHBhdGgsIHVybCwgYmFzZSkge1xuICAgICAgLypcbiAgICAgIE1hdGNoZXMgcGF0aHMgZm9yIGZpbGUgcHJvdG9jb2wgb24gd2luZG93cyxcbiAgICAgIHN1Y2ggYXMgL0M6L2Zvby9iYXIsIGFuZCBjYXB0dXJlcyBvbmx5IC9mb28vYmFyLlxuICAgICAgKi9cbiAgICAgIHZhciB3aW5kb3dzRmlsZVBhdGhFeHAgPSAvXlxcLz8uKj86KFxcLy4qKS87XG5cbiAgICAgIHZhciBmaXJzdFBhdGhTZWdtZW50TWF0Y2g7XG5cbiAgICAgIC8vR2V0IHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGlucHV0IFVSTC5cbiAgICAgIGlmICh1cmwuaW5kZXhPZihiYXNlKSA9PT0gMCkge1xuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShiYXNlLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKiBUaGUgaW5wdXQgVVJMIGludGVudGlvbmFsbHkgY29udGFpbnMgYVxuICAgICAgICogZmlyc3QgcGF0aCBzZWdtZW50IHRoYXQgZW5kcyB3aXRoIGEgY29sb24uXG4gICAgICAgKi9cbiAgICAgIGlmICh3aW5kb3dzRmlsZVBhdGhFeHAuZXhlYyh1cmwpKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICBmaXJzdFBhdGhTZWdtZW50TWF0Y2ggPSB3aW5kb3dzRmlsZVBhdGhFeHAuZXhlYyhwYXRoKTtcbiAgICAgIHJldHVybiBmaXJzdFBhdGhTZWdtZW50TWF0Y2ggPyBmaXJzdFBhdGhTZWdtZW50TWF0Y2hbMV0gOiBwYXRoO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29tcG9zZSBoYXNoYmFuZyB1cmwgYW5kIHVwZGF0ZSBgYWJzVXJsYCBwcm9wZXJ0eVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy4kJGNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VhcmNoID0gdG9LZXlWYWx1ZSh0aGlzLiQkc2VhcmNoKSxcbiAgICAgICAgaGFzaCA9IHRoaXMuJCRoYXNoID8gJyMnICsgZW5jb2RlVXJpU2VnbWVudCh0aGlzLiQkaGFzaCkgOiAnJztcblxuICAgIHRoaXMuJCR1cmwgPSBlbmNvZGVQYXRoKHRoaXMuJCRwYXRoKSArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyBoYXNoO1xuICAgIHRoaXMuJCRhYnNVcmwgPSBhcHBCYXNlICsgKHRoaXMuJCR1cmwgPyBoYXNoUHJlZml4ICsgdGhpcy4kJHVybCA6ICcnKTtcbiAgfTtcblxuICB0aGlzLiQkcmV3cml0ZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgIGlmKHN0cmlwSGFzaChhcHBCYXNlKSA9PSBzdHJpcEhhc2godXJsKSkge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gIH07XG59XG5cblxuLyoqXG4gKiBMb2NhdGlvbkhhc2hiYW5nVXJsIHJlcHJlc2VudHMgdXJsXG4gKiBUaGlzIG9iamVjdCBpcyBleHBvc2VkIGFzICRsb2NhdGlvbiBzZXJ2aWNlIHdoZW4gaHRtbDUgaGlzdG9yeSBhcGkgaXMgZW5hYmxlZCBidXQgdGhlIGJyb3dzZXJcbiAqIGRvZXMgbm90IHN1cHBvcnQgaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwQmFzZSBhcHBsaWNhdGlvbiBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2hQcmVmaXggaGFzaGJhbmcgcHJlZml4XG4gKi9cbmZ1bmN0aW9uIExvY2F0aW9uSGFzaGJhbmdJbkh0bWw1VXJsKGFwcEJhc2UsIGhhc2hQcmVmaXgpIHtcbiAgdGhpcy4kJGh0bWw1ID0gdHJ1ZTtcbiAgTG9jYXRpb25IYXNoYmFuZ1VybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHZhciBhcHBCYXNlTm9GaWxlID0gc3RyaXBGaWxlKGFwcEJhc2UpO1xuXG4gIHRoaXMuJCRyZXdyaXRlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIGFwcFVybDtcblxuICAgIGlmICggYXBwQmFzZSA9PSBzdHJpcEhhc2godXJsKSApIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfSBlbHNlIGlmICggKGFwcFVybCA9IGJlZ2luc1dpdGgoYXBwQmFzZU5vRmlsZSwgdXJsKSkgKSB7XG4gICAgICByZXR1cm4gYXBwQmFzZSArIGhhc2hQcmVmaXggKyBhcHBVcmw7XG4gICAgfSBlbHNlIGlmICggYXBwQmFzZU5vRmlsZSA9PT0gdXJsICsgJy8nKSB7XG4gICAgICByZXR1cm4gYXBwQmFzZU5vRmlsZTtcbiAgICB9XG4gIH07XG59XG5cblxuTG9jYXRpb25IYXNoYmFuZ0luSHRtbDVVcmwucHJvdG90eXBlID1cbiAgTG9jYXRpb25IYXNoYmFuZ1VybC5wcm90b3R5cGUgPVxuICBMb2NhdGlvbkh0bWw1VXJsLnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQXJlIHdlIGluIGh0bWw1IG1vZGU/XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAkJGh0bWw1OiBmYWxzZSxcblxuICAvKipcbiAgICogSGFzIGFueSBjaGFuZ2UgYmVlbiByZXBsYWNpbmcgP1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgJCRyZXBsYWNlOiBmYWxzZSxcblxuICAvKipcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb24jYWJzVXJsXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxuICAgKlxuICAgKiBSZXR1cm4gZnVsbCB1cmwgcmVwcmVzZW50YXRpb24gd2l0aCBhbGwgc2VnbWVudHMgZW5jb2RlZCBhY2NvcmRpbmcgdG8gcnVsZXMgc3BlY2lmaWVkIGluXG4gICAqIHtAbGluayBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzOTg2LnR4dCBSRkMgMzk4Nn0uXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gZnVsbCB1cmxcbiAgICovXG4gIGFic1VybDogbG9jYXRpb25HZXR0ZXIoJyQkYWJzVXJsJyksXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3VybFxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgLyBzZXR0ZXIuXG4gICAqXG4gICAqIFJldHVybiB1cmwgKGUuZy4gYC9wYXRoP2E9YiNoYXNoYCkgd2hlbiBjYWxsZWQgd2l0aG91dCBhbnkgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBDaGFuZ2UgcGF0aCwgc2VhcmNoIGFuZCBoYXNoLCB3aGVuIGNhbGxlZCB3aXRoIHBhcmFtZXRlciBhbmQgcmV0dXJuIGAkbG9jYXRpb25gLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHVybCBOZXcgdXJsIHdpdGhvdXQgYmFzZSBwcmVmaXggKGUuZy4gYC9wYXRoP2E9YiNoYXNoYClcbiAgICogQHBhcmFtIHtzdHJpbmc9fSByZXBsYWNlIFRoZSBwYXRoIHRoYXQgd2lsbCBiZSBjaGFuZ2VkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdXJsXG4gICAqL1xuICB1cmw6IGZ1bmN0aW9uKHVybCwgcmVwbGFjZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh1cmwpKVxuICAgICAgcmV0dXJuIHRoaXMuJCR1cmw7XG5cbiAgICB2YXIgbWF0Y2ggPSBQQVRIX01BVENILmV4ZWModXJsKTtcbiAgICBpZiAobWF0Y2hbMV0pIHRoaXMucGF0aChkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pKTtcbiAgICBpZiAobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pIHRoaXMuc2VhcmNoKG1hdGNoWzNdIHx8ICcnKTtcbiAgICB0aGlzLmhhc2gobWF0Y2hbNV0gfHwgJycsIHJlcGxhY2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3Byb3RvY29sXG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxuICAgKlxuICAgKiBSZXR1cm4gcHJvdG9jb2wgb2YgY3VycmVudCB1cmwuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcHJvdG9jb2wgb2YgY3VycmVudCB1cmxcbiAgICovXG4gIHByb3RvY29sOiBsb2NhdGlvbkdldHRlcignJCRwcm90b2NvbCcpLFxuXG4gIC8qKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNob3N0XG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxuICAgKlxuICAgKiBSZXR1cm4gaG9zdCBvZiBjdXJyZW50IHVybC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBob3N0IG9mIGN1cnJlbnQgdXJsLlxuICAgKi9cbiAgaG9zdDogbG9jYXRpb25HZXR0ZXIoJyQkaG9zdCcpLFxuXG4gIC8qKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lIG5nLiRsb2NhdGlvbiNwb3J0XG4gICAqIEBtZXRob2RPZiBuZy4kbG9jYXRpb25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGdldHRlciBvbmx5LlxuICAgKlxuICAgKiBSZXR1cm4gcG9ydCBvZiBjdXJyZW50IHVybC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3J0XG4gICAqL1xuICBwb3J0OiBsb2NhdGlvbkdldHRlcignJCRwb3J0JyksXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3BhdGhcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIC8gc2V0dGVyLlxuICAgKlxuICAgKiBSZXR1cm4gcGF0aCBvZiBjdXJyZW50IHVybCB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIENoYW5nZSBwYXRoIHdoZW4gY2FsbGVkIHdpdGggcGFyYW1ldGVyIGFuZCByZXR1cm4gYCRsb2NhdGlvbmAuXG4gICAqXG4gICAqIE5vdGU6IFBhdGggc2hvdWxkIGFsd2F5cyBiZWdpbiB3aXRoIGZvcndhcmQgc2xhc2ggKC8pLCB0aGlzIG1ldGhvZCB3aWxsIGFkZCB0aGUgZm9yd2FyZCBzbGFzaFxuICAgKiBpZiBpdCBpcyBtaXNzaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhdGggTmV3IHBhdGhcbiAgICogQHJldHVybiB7c3RyaW5nfSBwYXRoXG4gICAqL1xuICBwYXRoOiBsb2NhdGlvbkdldHRlclNldHRlcignJCRwYXRoJywgZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbiAgfSksXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3NlYXJjaFxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGlzIG1ldGhvZCBpcyBnZXR0ZXIgLyBzZXR0ZXIuXG4gICAqXG4gICAqIFJldHVybiBzZWFyY2ggcGFydCAoYXMgb2JqZWN0KSBvZiBjdXJyZW50IHVybCB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIENoYW5nZSBzZWFyY2ggcGFydCB3aGVuIGNhbGxlZCB3aXRoIHBhcmFtZXRlciBhbmQgcmV0dXJuIGAkbG9jYXRpb25gLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZz58T2JqZWN0LjxBcnJheS48c3RyaW5nPj59IHNlYXJjaCBOZXcgc2VhcmNoIHBhcmFtcyAtIHN0cmluZyBvclxuICAgKiBoYXNoIG9iamVjdC4gSGFzaCBvYmplY3QgbWF5IGNvbnRhaW4gYW4gYXJyYXkgb2YgdmFsdWVzLCB3aGljaCB3aWxsIGJlIGRlY29kZWQgYXMgZHVwbGljYXRlcyBpblxuICAgKiB0aGUgdXJsLlxuICAgKlxuICAgKiBAcGFyYW0geyhzdHJpbmd8QXJyYXk8c3RyaW5nPik9fSBwYXJhbVZhbHVlIElmIGBzZWFyY2hgIGlzIGEgc3RyaW5nLCB0aGVuIGBwYXJhbVZhbHVlYCB3aWxsIG92ZXJyaWRlIG9ubHkgYVxuICAgKiBzaW5nbGUgc2VhcmNoIHBhcmFtZXRlci4gSWYgYHBhcmFtVmFsdWVgIGlzIGFuIGFycmF5LCBpdCB3aWxsIHNldCB0aGUgcGFyYW1ldGVyIGFzIGFcbiAgICogY29tbWEtc2VwYXJhdGVkIHZhbHVlLiBJZiBgcGFyYW1WYWx1ZWAgaXMgYG51bGxgLCB0aGUgcGFyYW1ldGVyIHdpbGwgYmUgZGVsZXRlZC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBzZWFyY2hcbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24oc2VhcmNoLCBwYXJhbVZhbHVlKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLiQkc2VhcmNoO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoaXNTdHJpbmcoc2VhcmNoKSkge1xuICAgICAgICAgIHRoaXMuJCRzZWFyY2ggPSBwYXJzZUtleVZhbHVlKHNlYXJjaCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qoc2VhcmNoKSkge1xuICAgICAgICAgIHRoaXMuJCRzZWFyY2ggPSBzZWFyY2g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJGxvY2F0aW9uTWluRXJyKCdpc3JjaGFyZycsXG4gICAgICAgICAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGAkbG9jYXRpb24jc2VhcmNoKClgIGNhbGwgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXNVbmRlZmluZWQocGFyYW1WYWx1ZSkgfHwgcGFyYW1WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLiQkc2VhcmNoW3NlYXJjaF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kJHNlYXJjaFtzZWFyY2hdID0gcGFyYW1WYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuJCRjb21wb3NlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI2hhc2hcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhpcyBtZXRob2QgaXMgZ2V0dGVyIC8gc2V0dGVyLlxuICAgKlxuICAgKiBSZXR1cm4gaGFzaCBmcmFnbWVudCB3aGVuIGNhbGxlZCB3aXRob3V0IGFueSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIENoYW5nZSBoYXNoIGZyYWdtZW50IHdoZW4gY2FsbGVkIHdpdGggcGFyYW1ldGVyIGFuZCByZXR1cm4gYCRsb2NhdGlvbmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaGFzaCBOZXcgaGFzaCBmcmFnbWVudFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGhhc2hcbiAgICovXG4gIGhhc2g6IGxvY2F0aW9uR2V0dGVyU2V0dGVyKCckJGhhc2gnLCBpZGVudGl0eSksXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBtZXRob2RcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uI3JlcGxhY2VcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSWYgY2FsbGVkLCBhbGwgY2hhbmdlcyB0byAkbG9jYXRpb24gZHVyaW5nIGN1cnJlbnQgYCRkaWdlc3RgIHdpbGwgYmUgcmVwbGFjaW5nIGN1cnJlbnQgaGlzdG9yeVxuICAgKiByZWNvcmQsIGluc3RlYWQgb2YgYWRkaW5nIG5ldyBvbmUuXG4gICAqL1xuICByZXBsYWNlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLiQkcmVwbGFjZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxvY2F0aW9uR2V0dGVyKHByb3BlcnR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XG4gIH07XG59XG5cblxuZnVuY3Rpb24gbG9jYXRpb25HZXR0ZXJTZXR0ZXIocHJvcGVydHksIHByZXByb2Nlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcblxuICAgIHRoaXNbcHJvcGVydHldID0gcHJlcHJvY2Vzcyh2YWx1ZSk7XG4gICAgdGhpcy4kJGNvbXBvc2UoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgbmcuJGxvY2F0aW9uXG4gKlxuICogQHJlcXVpcmVzICRicm93c2VyXG4gKiBAcmVxdWlyZXMgJHNuaWZmZXJcbiAqIEByZXF1aXJlcyAkcm9vdEVsZW1lbnRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSAkbG9jYXRpb24gc2VydmljZSBwYXJzZXMgdGhlIFVSTCBpbiB0aGUgYnJvd3NlciBhZGRyZXNzIGJhciAoYmFzZWQgb24gdGhlXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vd2luZG93LmxvY2F0aW9uIHdpbmRvdy5sb2NhdGlvbn0pIGFuZCBtYWtlcyB0aGUgVVJMXG4gKiBhdmFpbGFibGUgdG8geW91ciBhcHBsaWNhdGlvbi4gQ2hhbmdlcyB0byB0aGUgVVJMIGluIHRoZSBhZGRyZXNzIGJhciBhcmUgcmVmbGVjdGVkIGludG9cbiAqICRsb2NhdGlvbiBzZXJ2aWNlIGFuZCBjaGFuZ2VzIHRvICRsb2NhdGlvbiBhcmUgcmVmbGVjdGVkIGludG8gdGhlIGJyb3dzZXIgYWRkcmVzcyBiYXIuXG4gKlxuICogKipUaGUgJGxvY2F0aW9uIHNlcnZpY2U6KipcbiAqXG4gKiAtIEV4cG9zZXMgdGhlIGN1cnJlbnQgVVJMIGluIHRoZSBicm93c2VyIGFkZHJlc3MgYmFyLCBzbyB5b3UgY2FuXG4gKiAgIC0gV2F0Y2ggYW5kIG9ic2VydmUgdGhlIFVSTC5cbiAqICAgLSBDaGFuZ2UgdGhlIFVSTC5cbiAqIC0gU3luY2hyb25pemVzIHRoZSBVUkwgd2l0aCB0aGUgYnJvd3NlciB3aGVuIHRoZSB1c2VyXG4gKiAgIC0gQ2hhbmdlcyB0aGUgYWRkcmVzcyBiYXIuXG4gKiAgIC0gQ2xpY2tzIHRoZSBiYWNrIG9yIGZvcndhcmQgYnV0dG9uIChvciBjbGlja3MgYSBIaXN0b3J5IGxpbmspLlxuICogICAtIENsaWNrcyBvbiBhIGxpbmsuXG4gKiAtIFJlcHJlc2VudHMgdGhlIFVSTCBvYmplY3QgYXMgYSBzZXQgb2YgbWV0aG9kcyAocHJvdG9jb2wsIGhvc3QsIHBvcnQsIHBhdGgsIHNlYXJjaCwgaGFzaCkuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIHtAbGluayBndWlkZS9kZXZfZ3VpZGUuc2VydmljZXMuJGxvY2F0aW9uIERldmVsb3BlciBHdWlkZTogQW5ndWxhclxuICogU2VydmljZXM6IFVzaW5nICRsb2NhdGlvbn1cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRsb2NhdGlvblByb3ZpZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzZSB0aGUgYCRsb2NhdGlvblByb3ZpZGVyYCB0byBjb25maWd1cmUgaG93IHRoZSBhcHBsaWNhdGlvbiBkZWVwIGxpbmtpbmcgcGF0aHMgYXJlIHN0b3JlZC5cbiAqL1xuZnVuY3Rpb24gJExvY2F0aW9uUHJvdmlkZXIoKXtcbiAgdmFyIGhhc2hQcmVmaXggPSAnJyxcbiAgICAgIGh0bWw1TW9kZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgcHJvcGVydHlcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uUHJvdmlkZXIjaGFzaFByZWZpeFxuICAgKiBAbWV0aG9kT2YgbmcuJGxvY2F0aW9uUHJvdmlkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcHJlZml4IFByZWZpeCBmb3IgaGFzaCBwYXJ0IChjb250YWluaW5nIHBhdGggYW5kIHNlYXJjaClcbiAgICogQHJldHVybnMgeyp9IGN1cnJlbnQgdmFsdWUgaWYgdXNlZCBhcyBnZXR0ZXIgb3IgaXRzZWxmIChjaGFpbmluZykgaWYgdXNlZCBhcyBzZXR0ZXJcbiAgICovXG4gIHRoaXMuaGFzaFByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIGlmIChpc0RlZmluZWQocHJlZml4KSkge1xuICAgICAgaGFzaFByZWZpeCA9IHByZWZpeDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGFzaFByZWZpeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBwcm9wZXJ0eVxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb25Qcm92aWRlciNodG1sNU1vZGVcbiAgICogQG1ldGhvZE9mIG5nLiRsb2NhdGlvblByb3ZpZGVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBtb2RlIFVzZSBIVE1MNSBzdHJhdGVneSBpZiBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zIHsqfSBjdXJyZW50IHZhbHVlIGlmIHVzZWQgYXMgZ2V0dGVyIG9yIGl0c2VsZiAoY2hhaW5pbmcpIGlmIHVzZWQgYXMgc2V0dGVyXG4gICAqL1xuICB0aGlzLmh0bWw1TW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICBpZiAoaXNEZWZpbmVkKG1vZGUpKSB7XG4gICAgICBodG1sNU1vZGUgPSBtb2RlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBodG1sNU1vZGU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZXZlbnRcbiAgICogQG5hbWUgbmcuJGxvY2F0aW9uIyRsb2NhdGlvbkNoYW5nZVN0YXJ0XG4gICAqIEBldmVudE9mIG5nLiRsb2NhdGlvblxuICAgKiBAZXZlbnRUeXBlIGJyb2FkY2FzdCBvbiByb290IHNjb3BlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBCcm9hZGNhc3RlZCBiZWZvcmUgYSBVUkwgd2lsbCBjaGFuZ2UuIFRoaXMgY2hhbmdlIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgKiBgcHJldmVudERlZmF1bHRgIG1ldGhvZCBvZiB0aGUgZXZlbnQuIFNlZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSMkb259IGZvciBtb3JlXG4gICAqIGRldGFpbHMgYWJvdXQgZXZlbnQgb2JqZWN0LiBVcG9uIHN1Y2Nlc3NmdWwgY2hhbmdlXG4gICAqIHtAbGluayBuZy4kbG9jYXRpb24jJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcyAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzfSBpcyBmaXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFuZ3VsYXJFdmVudCBTeW50aGV0aWMgZXZlbnQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VXJsIE5ldyBVUkxcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvbGRVcmwgVVJMIHRoYXQgd2FzIGJlZm9yZSBpdCB3YXMgY2hhbmdlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBldmVudFxuICAgKiBAbmFtZSBuZy4kbG9jYXRpb24jJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc1xuICAgKiBAZXZlbnRPZiBuZy4kbG9jYXRpb25cbiAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gcm9vdCBzY29wZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQnJvYWRjYXN0ZWQgYWZ0ZXIgYSBVUkwgd2FzIGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhbmd1bGFyRXZlbnQgU3ludGhldGljIGV2ZW50IG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1VybCBOZXcgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb2xkVXJsIFVSTCB0aGF0IHdhcyBiZWZvcmUgaXQgd2FzIGNoYW5nZWQuXG4gICAqL1xuXG4gIHRoaXMuJGdldCA9IFsnJHJvb3RTY29wZScsICckYnJvd3NlcicsICckc25pZmZlcicsICckcm9vdEVsZW1lbnQnLFxuICAgICAgZnVuY3Rpb24oICRyb290U2NvcGUsICAgJGJyb3dzZXIsICAgJHNuaWZmZXIsICAgJHJvb3RFbGVtZW50KSB7XG4gICAgdmFyICRsb2NhdGlvbixcbiAgICAgICAgTG9jYXRpb25Nb2RlLFxuICAgICAgICBiYXNlSHJlZiA9ICRicm93c2VyLmJhc2VIcmVmKCksIC8vIGlmIGJhc2VbaHJlZl0gaXMgdW5kZWZpbmVkLCBpdCBkZWZhdWx0cyB0byAnJ1xuICAgICAgICBpbml0aWFsVXJsID0gJGJyb3dzZXIudXJsKCksXG4gICAgICAgIGFwcEJhc2U7XG5cbiAgICBpZiAoaHRtbDVNb2RlKSB7XG4gICAgICBhcHBCYXNlID0gc2VydmVyQmFzZShpbml0aWFsVXJsKSArIChiYXNlSHJlZiB8fCAnLycpO1xuICAgICAgTG9jYXRpb25Nb2RlID0gJHNuaWZmZXIuaGlzdG9yeSA/IExvY2F0aW9uSHRtbDVVcmwgOiBMb2NhdGlvbkhhc2hiYW5nSW5IdG1sNVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwQmFzZSA9IHN0cmlwSGFzaChpbml0aWFsVXJsKTtcbiAgICAgIExvY2F0aW9uTW9kZSA9IExvY2F0aW9uSGFzaGJhbmdVcmw7XG4gICAgfVxuICAgICRsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbk1vZGUoYXBwQmFzZSwgJyMnICsgaGFzaFByZWZpeCk7XG4gICAgJGxvY2F0aW9uLiQkcGFyc2UoJGxvY2F0aW9uLiQkcmV3cml0ZShpbml0aWFsVXJsKSk7XG5cbiAgICAkcm9vdEVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIC8vIFRPRE8odm9qdGEpOiByZXdyaXRlIGxpbmsgd2hlbiBvcGVuaW5nIGluIG5ldyB0YWIvd2luZG93IChpbiBsZWdhY3kgYnJvd3NlcilcbiAgICAgIC8vIGN1cnJlbnRseSB3ZSBvcGVuIG5pY2UgdXJsIGxpbmsgYW5kIHJlZGlyZWN0IHRoZW5cblxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC53aGljaCA9PSAyKSByZXR1cm47XG5cbiAgICAgIHZhciBlbG0gPSBqcUxpdGUoZXZlbnQudGFyZ2V0KTtcblxuICAgICAgLy8gdHJhdmVyc2UgdGhlIERPTSB1cCB0byBmaW5kIGZpcnN0IEEgdGFnXG4gICAgICB3aGlsZSAobG93ZXJjYXNlKGVsbVswXS5ub2RlTmFtZSkgIT09ICdhJykge1xuICAgICAgICAvLyBpZ25vcmUgcmV3cml0aW5nIGlmIG5vIEEgdGFnIChyZWFjaGVkIHJvb3QgZWxlbWVudCwgb3Igbm8gcGFyZW50IC0gcmVtb3ZlZCBmcm9tIGRvY3VtZW50KVxuICAgICAgICBpZiAoZWxtWzBdID09PSAkcm9vdEVsZW1lbnRbMF0gfHwgIShlbG0gPSBlbG0ucGFyZW50KCkpWzBdKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhYnNIcmVmID0gZWxtLnByb3AoJ2hyZWYnKTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGFic0hyZWYpICYmIGFic0hyZWYudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU1ZHQW5pbWF0ZWRTdHJpbmddJykge1xuICAgICAgICAvLyBTVkdBbmltYXRlZFN0cmluZy5hbmltVmFsIHNob3VsZCBiZSBpZGVudGljYWwgdG8gU1ZHQW5pbWF0ZWRTdHJpbmcuYmFzZVZhbCwgdW5sZXNzIGR1cmluZ1xuICAgICAgICAvLyBhbiBhbmltYXRpb24uXG4gICAgICAgIGFic0hyZWYgPSB1cmxSZXNvbHZlKGFic0hyZWYuYW5pbVZhbCkuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJld3JpdHRlblVybCA9ICRsb2NhdGlvbi4kJHJld3JpdGUoYWJzSHJlZik7XG5cbiAgICAgIGlmIChhYnNIcmVmICYmICFlbG0uYXR0cigndGFyZ2V0JykgJiYgcmV3cml0dGVuVXJsICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAocmV3cml0dGVuVXJsICE9ICRicm93c2VyLnVybCgpKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIGxvY2F0aW9uIG1hbnVhbGx5XG4gICAgICAgICAgJGxvY2F0aW9uLiQkcGFyc2UocmV3cml0dGVuVXJsKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIC8vIGhhY2sgdG8gd29yayBhcm91bmQgRkY2IGJ1ZyA2ODQyMDggd2hlbiBzY2VuYXJpbyBydW5uZXIgY2xpY2tzIG9uIGxpbmtzXG4gICAgICAgICAgd2luZG93LmFuZ3VsYXJbJ2ZmLTY4NDIwOC1wcmV2ZW50RGVmYXVsdCddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyByZXdyaXRlIGhhc2hiYW5nIHVybCA8PiBodG1sNSB1cmxcbiAgICBpZiAoJGxvY2F0aW9uLmFic1VybCgpICE9IGluaXRpYWxVcmwpIHtcbiAgICAgICRicm93c2VyLnVybCgkbG9jYXRpb24uYWJzVXJsKCksIHRydWUpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSAkbG9jYXRpb24gd2hlbiAkYnJvd3NlciB1cmwgY2hhbmdlc1xuICAgICRicm93c2VyLm9uVXJsQ2hhbmdlKGZ1bmN0aW9uKG5ld1VybCkge1xuICAgICAgaWYgKCRsb2NhdGlvbi5hYnNVcmwoKSAhPSBuZXdVcmwpIHtcbiAgICAgICAgaWYgKCRyb290U2NvcGUuJGJyb2FkY2FzdCgnJGxvY2F0aW9uQ2hhbmdlU3RhcnQnLCBuZXdVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGxvY2F0aW9uLmFic1VybCgpKS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgJGJyb3dzZXIudXJsKCRsb2NhdGlvbi5hYnNVcmwoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgICRyb290U2NvcGUuJGV2YWxBc3luYyhmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgb2xkVXJsID0gJGxvY2F0aW9uLmFic1VybCgpO1xuXG4gICAgICAgICAgJGxvY2F0aW9uLiQkcGFyc2UobmV3VXJsKTtcbiAgICAgICAgICBhZnRlckxvY2F0aW9uQ2hhbmdlKG9sZFVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkgJHJvb3RTY29wZS4kZGlnZXN0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgYnJvd3NlclxuICAgIHZhciBjaGFuZ2VDb3VudGVyID0gMDtcbiAgICAkcm9vdFNjb3BlLiR3YXRjaChmdW5jdGlvbiAkbG9jYXRpb25XYXRjaCgpIHtcbiAgICAgIHZhciBvbGRVcmwgPSAkYnJvd3Nlci51cmwoKTtcbiAgICAgIHZhciBjdXJyZW50UmVwbGFjZSA9ICRsb2NhdGlvbi4kJHJlcGxhY2U7XG5cbiAgICAgIGlmICghY2hhbmdlQ291bnRlciB8fCBvbGRVcmwgIT0gJGxvY2F0aW9uLmFic1VybCgpKSB7XG4gICAgICAgIGNoYW5nZUNvdW50ZXIrKztcbiAgICAgICAgJHJvb3RTY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRicm9hZGNhc3QoJyRsb2NhdGlvbkNoYW5nZVN0YXJ0JywgJGxvY2F0aW9uLmFic1VybCgpLCBvbGRVcmwpLlxuICAgICAgICAgICAgICBkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAkbG9jYXRpb24uJCRwYXJzZShvbGRVcmwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYnJvd3Nlci51cmwoJGxvY2F0aW9uLmFic1VybCgpLCBjdXJyZW50UmVwbGFjZSk7XG4gICAgICAgICAgICBhZnRlckxvY2F0aW9uQ2hhbmdlKG9sZFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgICRsb2NhdGlvbi4kJHJlcGxhY2UgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIGNoYW5nZUNvdW50ZXI7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJGxvY2F0aW9uO1xuXG4gICAgZnVuY3Rpb24gYWZ0ZXJMb2NhdGlvbkNoYW5nZShvbGRVcmwpIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnJGxvY2F0aW9uQ2hhbmdlU3VjY2VzcycsICRsb2NhdGlvbi5hYnNVcmwoKSwgb2xkVXJsKTtcbiAgICB9XG59XTtcbn1cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kbG9nXG4gKiBAcmVxdWlyZXMgJHdpbmRvd1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2ltcGxlIHNlcnZpY2UgZm9yIGxvZ2dpbmcuIERlZmF1bHQgaW1wbGVtZW50YXRpb24gc2FmZWx5IHdyaXRlcyB0aGUgbWVzc2FnZVxuICogaW50byB0aGUgYnJvd3NlcidzIGNvbnNvbGUgKGlmIHByZXNlbnQpLlxuICogXG4gKiBUaGUgbWFpbiBwdXJwb3NlIG9mIHRoaXMgc2VydmljZSBpcyB0byBzaW1wbGlmeSBkZWJ1Z2dpbmcgYW5kIHRyb3VibGVzaG9vdGluZy5cbiAqXG4gKiBUaGUgZGVmYXVsdCBpcyB0byBsb2cgYGRlYnVnYCBtZXNzYWdlcy4gWW91IGNhbiB1c2VcbiAqIHtAbGluayBuZy4kbG9nUHJvdmlkZXIgbmcuJGxvZ1Byb3ZpZGVyI2RlYnVnRW5hYmxlZH0gdG8gY2hhbmdlIHRoaXMuXG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlPlxuICAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICAgZnVuY3Rpb24gTG9nQ3RybCgkc2NvcGUsICRsb2cpIHtcbiAgICAgICAgICRzY29wZS4kbG9nID0gJGxvZztcbiAgICAgICAgICRzY29wZS5tZXNzYWdlID0gJ0hlbGxvIFdvcmxkISc7XG4gICAgICAgfVxuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiTG9nQ3RybFwiPlxuICAgICAgICAgPHA+UmVsb2FkIHRoaXMgcGFnZSB3aXRoIG9wZW4gY29uc29sZSwgZW50ZXIgdGV4dCBhbmQgaGl0IHRoZSBsb2cgYnV0dG9uLi4uPC9wPlxuICAgICAgICAgTWVzc2FnZTpcbiAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwibWVzc2FnZVwiLz5cbiAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCIkbG9nLmxvZyhtZXNzYWdlKVwiPmxvZzwvYnV0dG9uPlxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cIiRsb2cud2FybihtZXNzYWdlKVwiPndhcm48L2J1dHRvbj5cbiAgICAgICAgIDxidXR0b24gbmctY2xpY2s9XCIkbG9nLmluZm8obWVzc2FnZSlcIj5pbmZvPC9idXR0b24+XG4gICAgICAgICA8YnV0dG9uIG5nLWNsaWNrPVwiJGxvZy5lcnJvcihtZXNzYWdlKVwiPmVycm9yPC9idXR0b24+XG4gICAgICAgPC9kaXY+XG4gICAgIDwvZmlsZT5cbiAgIDwvZXhhbXBsZT5cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRsb2dQcm92aWRlclxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2UgdGhlIGAkbG9nUHJvdmlkZXJgIHRvIGNvbmZpZ3VyZSBob3cgdGhlIGFwcGxpY2F0aW9uIGxvZ3MgbWVzc2FnZXNcbiAqL1xuZnVuY3Rpb24gJExvZ1Byb3ZpZGVyKCl7XG4gIHZhciBkZWJ1ZyA9IHRydWUsXG4gICAgICBzZWxmID0gdGhpcztcbiAgXG4gIC8qKlxuICAgKiBAbmdkb2MgcHJvcGVydHlcbiAgICogQG5hbWUgbmcuJGxvZ1Byb3ZpZGVyI2RlYnVnRW5hYmxlZFxuICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1Byb3ZpZGVyXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZz19IGZsYWcgZW5hYmxlIG9yIGRpc2FibGUgZGVidWcgbGV2ZWwgbWVzc2FnZXNcbiAgICogQHJldHVybnMgeyp9IGN1cnJlbnQgdmFsdWUgaWYgdXNlZCBhcyBnZXR0ZXIgb3IgaXRzZWxmIChjaGFpbmluZykgaWYgdXNlZCBhcyBzZXR0ZXJcbiAgICovXG4gIHRoaXMuZGVidWdFbmFibGVkID0gZnVuY3Rpb24oZmxhZykge1xuICAgIGlmIChpc0RlZmluZWQoZmxhZykpIHtcbiAgICAgIGRlYnVnID0gZmxhZztcbiAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgfTtcbiAgXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsIGZ1bmN0aW9uKCR3aW5kb3cpe1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjbG9nXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1xuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogV3JpdGUgYSBsb2cgbWVzc2FnZVxuICAgICAgICovXG4gICAgICBsb2c6IGNvbnNvbGVMb2coJ2xvZycpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjaW5mb1xuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFdyaXRlIGFuIGluZm9ybWF0aW9uIG1lc3NhZ2VcbiAgICAgICAqL1xuICAgICAgaW5mbzogY29uc29sZUxvZygnaW5mbycpLFxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgICAqIEBuYW1lIG5nLiRsb2cjd2FyblxuICAgICAgICogQG1ldGhvZE9mIG5nLiRsb2dcbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlXG4gICAgICAgKi9cbiAgICAgIHdhcm46IGNvbnNvbGVMb2coJ3dhcm4nKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgKiBAbmFtZSBuZy4kbG9nI2Vycm9yXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1xuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogV3JpdGUgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICovXG4gICAgICBlcnJvcjogY29uc29sZUxvZygnZXJyb3InKSxcbiAgICAgIFxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICAgKiBAbmFtZSBuZy4kbG9nI2RlYnVnXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJGxvZ1xuICAgICAgICogXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFdyaXRlIGEgZGVidWcgbWVzc2FnZVxuICAgICAgICovXG4gICAgICBkZWJ1ZzogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZuID0gY29uc29sZUxvZygnZGVidWcnKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICBmbi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0oKSlcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0RXJyb3IoYXJnKSB7XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGFyZy5zdGFjaykge1xuICAgICAgICAgIGFyZyA9IChhcmcubWVzc2FnZSAmJiBhcmcuc3RhY2suaW5kZXhPZihhcmcubWVzc2FnZSkgPT09IC0xKVxuICAgICAgICAgICAgICA/ICdFcnJvcjogJyArIGFyZy5tZXNzYWdlICsgJ1xcbicgKyBhcmcuc3RhY2tcbiAgICAgICAgICAgICAgOiBhcmcuc3RhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnLnNvdXJjZVVSTCkge1xuICAgICAgICAgIGFyZyA9IGFyZy5tZXNzYWdlICsgJ1xcbicgKyBhcmcuc291cmNlVVJMICsgJzonICsgYXJnLmxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc29sZUxvZyh0eXBlKSB7XG4gICAgICB2YXIgY29uc29sZSA9ICR3aW5kb3cuY29uc29sZSB8fCB7fSxcbiAgICAgICAgICBsb2dGbiA9IGNvbnNvbGVbdHlwZV0gfHwgY29uc29sZS5sb2cgfHwgbm9vcCxcbiAgICAgICAgICBoYXNBcHBseSA9IGZhbHNlO1xuXG4gICAgICAvLyBOb3RlOiByZWFkaW5nIGxvZ0ZuLmFwcGx5IHRocm93cyBhbiBlcnJvciBpbiBJRTExIGluIElFOCBkb2N1bWVudCBtb2RlLlxuICAgICAgLy8gVGhlIHJlYXNvbiBiZWhpbmQgdGhpcyBpcyB0aGF0IGNvbnNvbGUubG9nIGhhcyB0eXBlIFwib2JqZWN0XCIgaW4gSUU4Li4uXG4gICAgICB0cnkge1xuICAgICAgICBoYXNBcHBseSA9ICEhIGxvZ0ZuLmFwcGx5O1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgaWYgKGhhc0FwcGx5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvckVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChmb3JtYXRFcnJvcihhcmcpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbG9nRm4uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGFyZSBJRSB3aGljaCBlaXRoZXIgZG9lc24ndCBoYXZlIHdpbmRvdy5jb25zb2xlID0+IHRoaXMgaXMgbm9vcCBhbmQgd2UgZG8gbm90aGluZyxcbiAgICAgIC8vIG9yIHdlIGFyZSBJRSB3aGVyZSBjb25zb2xlLmxvZyBkb2Vzbid0IGhhdmUgYXBwbHkgc28gd2UgbG9nIGF0IGxlYXN0IGZpcnN0IDIgYXJnc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgbG9nRm4oYXJnMSwgYXJnMiA9PSBudWxsID8gJycgOiBhcmcyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XTtcbn1cblxudmFyICRwYXJzZU1pbkVyciA9IG1pbkVycignJHBhcnNlJyk7XG52YXIgcHJvbWlzZVdhcm5pbmdDYWNoZSA9IHt9O1xudmFyIHByb21pc2VXYXJuaW5nO1xuXG4vLyBTYW5kYm94aW5nIEFuZ3VsYXIgRXhwcmVzc2lvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQW5ndWxhciBleHByZXNzaW9ucyBhcmUgZ2VuZXJhbGx5IGNvbnNpZGVyZWQgc2FmZSBiZWNhdXNlIHRoZXNlIGV4cHJlc3Npb25zIG9ubHkgaGF2ZSBkaXJlY3Rcbi8vIGFjY2VzcyB0byAkc2NvcGUgYW5kIGxvY2Fscy4gSG93ZXZlciwgb25lIGNhbiBvYnRhaW4gdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgSlMgY29kZSBieVxuLy8gb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIG5hdGl2ZSBKUyBmdW5jdGlvbnMgc3VjaCBhcyB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3IuXG4vL1xuLy8gQXMgYW4gZXhhbXBsZSwgY29uc2lkZXIgdGhlIGZvbGxvd2luZyBBbmd1bGFyIGV4cHJlc3Npb246XG4vL1xuLy8gICB7fS50b1N0cmluZy5jb25zdHJ1Y3RvcihhbGVydChcImV2aWwgSlMgY29kZVwiKSlcbi8vXG4vLyBXZSB3YW50IHRvIHByZXZlbnQgdGhpcyB0eXBlIG9mIGFjY2Vzcy4gRm9yIHRoZSBzYWtlIG9mIHBlcmZvcm1hbmNlLCBkdXJpbmcgdGhlIGxleGluZyBwaGFzZSB3ZVxuLy8gZGlzYWxsb3cgYW55IFwiZG90dGVkXCIgYWNjZXNzIHRvIGFueSBtZW1iZXIgbmFtZWQgXCJjb25zdHJ1Y3RvclwiLlxuLy9cbi8vIEZvciByZWZsZWN0aXZlIGNhbGxzIChhW2JdKSB3ZSBjaGVjayB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgbG9va3VwIGlzIG5vdCB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3Jcbi8vIHdoaWxlIGV2YWx1YXRpbmcgdGhlIGV4cHJlc3Npb24sIHdoaWNoIGlzIGEgc3Ryb25nZXIgYnV0IG1vcmUgZXhwZW5zaXZlIHRlc3QuIFNpbmNlIHJlZmxlY3RpdmVcbi8vIGNhbGxzIGFyZSBleHBlbnNpdmUgYW55d2F5LCB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwgY29tcGFyZWQgdG8gc3RhdGljIGRlcmVmZXJlbmNpbmcuXG4vL1xuLy8gVGhpcyBzYW5kYm94aW5nIHRlY2huaXF1ZSBpcyBub3QgcGVyZmVjdCBhbmQgZG9lc24ndCBhaW0gdG8gYmUuIFRoZSBnb2FsIGlzIHRvIHByZXZlbnQgZXhwbG9pdHNcbi8vIGFnYWluc3QgdGhlIGV4cHJlc3Npb24gbGFuZ3VhZ2UsIGJ1dCBub3QgdG8gcHJldmVudCBleHBsb2l0cyB0aGF0IHdlcmUgZW5hYmxlZCBieSBleHBvc2luZ1xuLy8gc2Vuc2l0aXZlIEphdmFTY3JpcHQgb3IgYnJvd3NlciBhcGlzIG9uIFNjb3BlLiBFeHBvc2luZyBzdWNoIG9iamVjdHMgb24gYSBTY29wZSBpcyBuZXZlciBhIGdvb2Rcbi8vIHByYWN0aWNlIGFuZCB0aGVyZWZvcmUgd2UgYXJlIG5vdCBldmVuIHRyeWluZyB0byBwcm90ZWN0IGFnYWluc3QgaW50ZXJhY3Rpb24gd2l0aCBhbiBvYmplY3Rcbi8vIGV4cGxpY2l0bHkgZXhwb3NlZCBpbiB0aGlzIHdheS5cbi8vXG4vLyBBIGRldmVsb3BlciBjb3VsZCBmb2lsIHRoZSBuYW1lIGNoZWNrIGJ5IGFsaWFzaW5nIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciB1bmRlciBhIGRpZmZlcmVudFxuLy8gbmFtZSBvbiB0aGUgc2NvcGUuXG4vL1xuLy8gSW4gZ2VuZXJhbCwgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGFjY2VzcyBhIFdpbmRvdyBvYmplY3QgZnJvbSBhbiBhbmd1bGFyIGV4cHJlc3Npb24gdW5sZXNzIGFcbi8vIHdpbmRvdyBvciBzb21lIERPTSBvYmplY3QgdGhhdCBoYXMgYSByZWZlcmVuY2UgdG8gd2luZG93IGlzIHB1Ymxpc2hlZCBvbnRvIGEgU2NvcGUuXG5cbmZ1bmN0aW9uIGVuc3VyZVNhZmVNZW1iZXJOYW1lKG5hbWUsIGZ1bGxFeHByZXNzaW9uKSB7XG4gIGlmIChuYW1lID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICB0aHJvdyAkcGFyc2VNaW5FcnIoJ2lzZWNmbGQnLFxuICAgICAgICAnUmVmZXJlbmNpbmcgXCJjb25zdHJ1Y3RvclwiIGZpZWxkIGluIEFuZ3VsYXIgZXhwcmVzc2lvbnMgaXMgZGlzYWxsb3dlZCEgRXhwcmVzc2lvbjogezB9JyxcbiAgICAgICAgZnVsbEV4cHJlc3Npb24pO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVTYWZlT2JqZWN0KG9iaiwgZnVsbEV4cHJlc3Npb24pIHtcbiAgLy8gbmlmdHkgY2hlY2sgaWYgb2JqIGlzIEZ1bmN0aW9uIHRoYXQgaXMgZmFzdCBhbmQgd29ya3MgYWNyb3NzIGlmcmFtZXMgYW5kIG90aGVyIGNvbnRleHRzXG4gIGlmIChvYmopIHtcbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yID09PSBvYmopIHtcbiAgICAgIHRocm93ICRwYXJzZU1pbkVycignaXNlY2ZuJyxcbiAgICAgICAgICAnUmVmZXJlbmNpbmcgRnVuY3Rpb24gaW4gQW5ndWxhciBleHByZXNzaW9ucyBpcyBkaXNhbGxvd2VkISBFeHByZXNzaW9uOiB7MH0nLFxuICAgICAgICAgIGZ1bGxFeHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKC8vIGlzV2luZG93KG9iailcbiAgICAgICAgb2JqLmRvY3VtZW50ICYmIG9iai5sb2NhdGlvbiAmJiBvYmouYWxlcnQgJiYgb2JqLnNldEludGVydmFsKSB7XG4gICAgICB0aHJvdyAkcGFyc2VNaW5FcnIoJ2lzZWN3aW5kb3cnLFxuICAgICAgICAgICdSZWZlcmVuY2luZyB0aGUgV2luZG93IGluIEFuZ3VsYXIgZXhwcmVzc2lvbnMgaXMgZGlzYWxsb3dlZCEgRXhwcmVzc2lvbjogezB9JyxcbiAgICAgICAgICBmdWxsRXhwcmVzc2lvbik7XG4gICAgfSBlbHNlIGlmICgvLyBpc0VsZW1lbnQob2JqKVxuICAgICAgICBvYmouY2hpbGRyZW4gJiYgKG9iai5ub2RlTmFtZSB8fCAob2JqLm9uICYmIG9iai5maW5kKSkpIHtcbiAgICAgIHRocm93ICRwYXJzZU1pbkVycignaXNlY2RvbScsXG4gICAgICAgICAgJ1JlZmVyZW5jaW5nIERPTSBub2RlcyBpbiBBbmd1bGFyIGV4cHJlc3Npb25zIGlzIGRpc2FsbG93ZWQhIEV4cHJlc3Npb246IHswfScsXG4gICAgICAgICAgZnVsbEV4cHJlc3Npb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgT1BFUkFUT1JTID0ge1xuICAgIC8qIGpzaGludCBiaXR3aXNlIDogZmFsc2UgKi9cbiAgICAnbnVsbCc6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbDt9LFxuICAgICd0cnVlJzpmdW5jdGlvbigpe3JldHVybiB0cnVlO30sXG4gICAgJ2ZhbHNlJzpmdW5jdGlvbigpe3JldHVybiBmYWxzZTt9LFxuICAgIHVuZGVmaW5lZDpub29wLFxuICAgICcrJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7XG4gICAgICBhPWEoc2VsZiwgbG9jYWxzKTsgYj1iKHNlbGYsIGxvY2Fscyk7XG4gICAgICBpZiAoaXNEZWZpbmVkKGEpKSB7XG4gICAgICAgIGlmIChpc0RlZmluZWQoYikpIHtcbiAgICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNEZWZpbmVkKGIpP2I6dW5kZWZpbmVkO30sXG4gICAgJy0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtcbiAgICAgICAgICBhPWEoc2VsZiwgbG9jYWxzKTsgYj1iKHNlbGYsIGxvY2Fscyk7XG4gICAgICAgICAgcmV0dXJuIChpc0RlZmluZWQoYSk/YTowKS0oaXNEZWZpbmVkKGIpP2I6MCk7XG4gICAgICAgIH0sXG4gICAgJyonOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpKmIoc2VsZiwgbG9jYWxzKTt9LFxuICAgICcvJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKS9iKHNlbGYsIGxvY2Fscyk7fSxcbiAgICAnJSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscyklYihzZWxmLCBsb2NhbHMpO30sXG4gICAgJ14nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpXmIoc2VsZiwgbG9jYWxzKTt9LFxuICAgICc9Jzpub29wLFxuICAgICc9PT0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSwgYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKT09PWIoc2VsZiwgbG9jYWxzKTt9LFxuICAgICchPT0nOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSwgYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKSE9PWIoc2VsZiwgbG9jYWxzKTt9LFxuICAgICc9PSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2Fscyk9PWIoc2VsZiwgbG9jYWxzKTt9LFxuICAgICchPSc6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2FscykhPWIoc2VsZiwgbG9jYWxzKTt9LFxuICAgICc8JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKTxiKHNlbGYsIGxvY2Fscyk7fSxcbiAgICAnPic6ZnVuY3Rpb24oc2VsZiwgbG9jYWxzLCBhLGIpe3JldHVybiBhKHNlbGYsIGxvY2Fscyk+YihzZWxmLCBsb2NhbHMpO30sXG4gICAgJzw9JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKTw9YihzZWxmLCBsb2NhbHMpO30sXG4gICAgJz49JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKT49YihzZWxmLCBsb2NhbHMpO30sXG4gICAgJyYmJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKSYmYihzZWxmLCBsb2NhbHMpO30sXG4gICAgJ3x8JzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEsYil7cmV0dXJuIGEoc2VsZiwgbG9jYWxzKXx8YihzZWxmLCBsb2NhbHMpO30sXG4gICAgJyYnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYShzZWxmLCBsb2NhbHMpJmIoc2VsZiwgbG9jYWxzKTt9LFxuLy8gICAgJ3wnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYXxiO30sXG4gICAgJ3wnOmZ1bmN0aW9uKHNlbGYsIGxvY2FscywgYSxiKXtyZXR1cm4gYihzZWxmLCBsb2NhbHMpKHNlbGYsIGxvY2FscywgYShzZWxmLCBsb2NhbHMpKTt9LFxuICAgICchJzpmdW5jdGlvbihzZWxmLCBsb2NhbHMsIGEpe3JldHVybiAhYShzZWxmLCBsb2NhbHMpO31cbn07XG4vKiBqc2hpbnQgYml0d2lzZTogdHJ1ZSAqL1xudmFyIEVTQ0FQRSA9IHtcIm5cIjpcIlxcblwiLCBcImZcIjpcIlxcZlwiLCBcInJcIjpcIlxcclwiLCBcInRcIjpcIlxcdFwiLCBcInZcIjpcIlxcdlwiLCBcIidcIjpcIidcIiwgJ1wiJzonXCInfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMZXhlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5MZXhlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMZXhlcixcblxuICBsZXg6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuY2ggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYXN0Q2ggPSAnOic7IC8vIGNhbiBzdGFydCByZWdleHBcblxuICAgIHRoaXMudG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW47XG4gICAgdmFyIGpzb24gPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5jaCA9IHRoaXMudGV4dC5jaGFyQXQodGhpcy5pbmRleCk7XG4gICAgICBpZiAodGhpcy5pcygnXCJcXCcnKSkge1xuICAgICAgICB0aGlzLnJlYWRTdHJpbmcodGhpcy5jaCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOdW1iZXIodGhpcy5jaCkgfHwgdGhpcy5pcygnLicpICYmIHRoaXMuaXNOdW1iZXIodGhpcy5wZWVrKCkpKSB7XG4gICAgICAgIHRoaXMucmVhZE51bWJlcigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSWRlbnQodGhpcy5jaCkpIHtcbiAgICAgICAgdGhpcy5yZWFkSWRlbnQoKTtcbiAgICAgICAgLy8gaWRlbnRpZmllcnMgY2FuIG9ubHkgYmUgaWYgdGhlIHByZWNlZGluZyBjaGFyIHdhcyBhIHsgb3IgLFxuICAgICAgICBpZiAodGhpcy53YXMoJ3ssJykgJiYganNvblswXSA9PT0gJ3snICYmXG4gICAgICAgICAgICAodG9rZW4gPSB0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICB0b2tlbi5qc29uID0gdG9rZW4udGV4dC5pbmRleE9mKCcuJykgPT09IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXMoJygpe31bXS4sOzo/JykpIHtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgdGV4dDogdGhpcy5jaCxcbiAgICAgICAgICBqc29uOiAodGhpcy53YXMoJzpbLCcpICYmIHRoaXMuaXMoJ3tbJykpIHx8IHRoaXMuaXMoJ31dOiwnKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuaXMoJ3tbJykpIGpzb24udW5zaGlmdCh0aGlzLmNoKTtcbiAgICAgICAgaWYgKHRoaXMuaXMoJ31dJykpIGpzb24uc2hpZnQoKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzV2hpdGVzcGFjZSh0aGlzLmNoKSkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoMiA9IHRoaXMuY2ggKyB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIGNoMyA9IGNoMiArIHRoaXMucGVlaygyKTtcbiAgICAgICAgdmFyIGZuID0gT1BFUkFUT1JTW3RoaXMuY2hdO1xuICAgICAgICB2YXIgZm4yID0gT1BFUkFUT1JTW2NoMl07XG4gICAgICAgIHZhciBmbjMgPSBPUEVSQVRPUlNbY2gzXTtcbiAgICAgICAgaWYgKGZuMykge1xuICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2goe2luZGV4OiB0aGlzLmluZGV4LCB0ZXh0OiBjaDMsIGZuOiBmbjN9KTtcbiAgICAgICAgICB0aGlzLmluZGV4ICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoZm4yKSB7XG4gICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7aW5kZXg6IHRoaXMuaW5kZXgsIHRleHQ6IGNoMiwgZm46IGZuMn0pO1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChmbikge1xuICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLmNoLFxuICAgICAgICAgICAgZm46IGZuLFxuICAgICAgICAgICAganNvbjogKHRoaXMud2FzKCdbLDonKSAmJiB0aGlzLmlzKCcrLScpKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ1VuZXhwZWN0ZWQgbmV4dCBjaGFyYWN0ZXIgJywgdGhpcy5pbmRleCwgdGhpcy5pbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RDaCA9IHRoaXMuY2g7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgfSxcblxuICBpczogZnVuY3Rpb24oY2hhcnMpIHtcbiAgICByZXR1cm4gY2hhcnMuaW5kZXhPZih0aGlzLmNoKSAhPT0gLTE7XG4gIH0sXG5cbiAgd2FzOiBmdW5jdGlvbihjaGFycykge1xuICAgIHJldHVybiBjaGFycy5pbmRleE9mKHRoaXMubGFzdENoKSAhPT0gLTE7XG4gIH0sXG5cbiAgcGVlazogZnVuY3Rpb24oaSkge1xuICAgIHZhciBudW0gPSBpIHx8IDE7XG4gICAgcmV0dXJuICh0aGlzLmluZGV4ICsgbnVtIDwgdGhpcy50ZXh0Lmxlbmd0aCkgPyB0aGlzLnRleHQuY2hhckF0KHRoaXMuaW5kZXggKyBudW0pIDogZmFsc2U7XG4gIH0sXG5cbiAgaXNOdW1iZXI6IGZ1bmN0aW9uKGNoKSB7XG4gICAgcmV0dXJuICgnMCcgPD0gY2ggJiYgY2ggPD0gJzknKTtcbiAgfSxcblxuICBpc1doaXRlc3BhY2U6IGZ1bmN0aW9uKGNoKSB7XG4gICAgLy8gSUUgdHJlYXRzIG5vbi1icmVha2luZyBzcGFjZSBhcyBcXHUwMEEwXG4gICAgcmV0dXJuIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcdCcgfHxcbiAgICAgICAgICAgIGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xcdicgfHwgY2ggPT09ICdcXHUwMEEwJyk7XG4gIH0sXG5cbiAgaXNJZGVudDogZnVuY3Rpb24oY2gpIHtcbiAgICByZXR1cm4gKCdhJyA8PSBjaCAmJiBjaCA8PSAneicgfHxcbiAgICAgICAgICAgICdBJyA8PSBjaCAmJiBjaCA8PSAnWicgfHxcbiAgICAgICAgICAgICdfJyA9PT0gY2ggfHwgY2ggPT09ICckJyk7XG4gIH0sXG5cbiAgaXNFeHBPcGVyYXRvcjogZnVuY3Rpb24oY2gpIHtcbiAgICByZXR1cm4gKGNoID09PSAnLScgfHwgY2ggPT09ICcrJyB8fCB0aGlzLmlzTnVtYmVyKGNoKSk7XG4gIH0sXG5cbiAgdGhyb3dFcnJvcjogZnVuY3Rpb24oZXJyb3IsIHN0YXJ0LCBlbmQpIHtcbiAgICBlbmQgPSBlbmQgfHwgdGhpcy5pbmRleDtcbiAgICB2YXIgY29sU3RyID0gKGlzRGVmaW5lZChzdGFydClcbiAgICAgICAgICAgID8gJ3MgJyArIHN0YXJ0ICsgICctJyArIHRoaXMuaW5kZXggKyAnIFsnICsgdGhpcy50ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKSArICddJ1xuICAgICAgICAgICAgOiAnICcgKyBlbmQpO1xuICAgIHRocm93ICRwYXJzZU1pbkVycignbGV4ZXJyJywgJ0xleGVyIEVycm9yOiB7MH0gYXQgY29sdW1uezF9IGluIGV4cHJlc3Npb24gW3syfV0uJyxcbiAgICAgICAgZXJyb3IsIGNvbFN0ciwgdGhpcy50ZXh0KTtcbiAgfSxcblxuICByZWFkTnVtYmVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVtYmVyID0gJyc7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IGxvd2VyY2FzZSh0aGlzLnRleHQuY2hhckF0KHRoaXMuaW5kZXgpKTtcbiAgICAgIGlmIChjaCA9PSAnLicgfHwgdGhpcy5pc051bWJlcihjaCkpIHtcbiAgICAgICAgbnVtYmVyICs9IGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBlZWtDaCA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoY2ggPT0gJ2UnICYmIHRoaXMuaXNFeHBPcGVyYXRvcihwZWVrQ2gpKSB7XG4gICAgICAgICAgbnVtYmVyICs9IGNoO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFeHBPcGVyYXRvcihjaCkgJiZcbiAgICAgICAgICAgIHBlZWtDaCAmJiB0aGlzLmlzTnVtYmVyKHBlZWtDaCkgJiZcbiAgICAgICAgICAgIG51bWJlci5jaGFyQXQobnVtYmVyLmxlbmd0aCAtIDEpID09ICdlJykge1xuICAgICAgICAgIG51bWJlciArPSBjaDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRXhwT3BlcmF0b3IoY2gpICYmXG4gICAgICAgICAgICAoIXBlZWtDaCB8fCAhdGhpcy5pc051bWJlcihwZWVrQ2gpKSAmJlxuICAgICAgICAgICAgbnVtYmVyLmNoYXJBdChudW1iZXIubGVuZ3RoIC0gMSkgPT0gJ2UnKSB7XG4gICAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdJbnZhbGlkIGV4cG9uZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICB9XG4gICAgbnVtYmVyID0gMSAqIG51bWJlcjtcbiAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgIGluZGV4OiBzdGFydCxcbiAgICAgIHRleHQ6IG51bWJlcixcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmbjogZnVuY3Rpb24oKSB7IHJldHVybiBudW1iZXI7IH1cbiAgICB9KTtcbiAgfSxcblxuICByZWFkSWRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJzZXIgPSB0aGlzO1xuXG4gICAgdmFyIGlkZW50ID0gJyc7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5pbmRleDtcblxuICAgIHZhciBsYXN0RG90LCBwZWVrSW5kZXgsIG1ldGhvZE5hbWUsIGNoO1xuXG4gICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICBjaCA9IHRoaXMudGV4dC5jaGFyQXQodGhpcy5pbmRleCk7XG4gICAgICBpZiAoY2ggPT09ICcuJyB8fCB0aGlzLmlzSWRlbnQoY2gpIHx8IHRoaXMuaXNOdW1iZXIoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSBsYXN0RG90ID0gdGhpcy5pbmRleDtcbiAgICAgICAgaWRlbnQgKz0gY2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICB9XG5cbiAgICAvL2NoZWNrIGlmIHRoaXMgaXMgbm90IGEgbWV0aG9kIGludm9jYXRpb24gYW5kIGlmIGl0IGlzIGJhY2sgb3V0IHRvIGxhc3QgZG90XG4gICAgaWYgKGxhc3REb3QpIHtcbiAgICAgIHBlZWtJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICB3aGlsZSAocGVla0luZGV4IDwgdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjaCA9IHRoaXMudGV4dC5jaGFyQXQocGVla0luZGV4KTtcbiAgICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICBtZXRob2ROYW1lID0gaWRlbnQuc3Vic3RyKGxhc3REb3QgLSBzdGFydCArIDEpO1xuICAgICAgICAgIGlkZW50ID0gaWRlbnQuc3Vic3RyKDAsIGxhc3REb3QgLSBzdGFydCk7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IHBlZWtJbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1doaXRlc3BhY2UoY2gpKSB7XG4gICAgICAgICAgcGVla0luZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgIGluZGV4OiBzdGFydCxcbiAgICAgIHRleHQ6IGlkZW50XG4gICAgfTtcblxuICAgIC8vIE9QRVJBVE9SUyBpcyBvdXIgb3duIG9iamVjdCBzbyB3ZSBkb24ndCBuZWVkIHRvIHVzZSBzcGVjaWFsIGhhc093blByb3BlcnR5Rm5cbiAgICBpZiAoT1BFUkFUT1JTLmhhc093blByb3BlcnR5KGlkZW50KSkge1xuICAgICAgdG9rZW4uZm4gPSBPUEVSQVRPUlNbaWRlbnRdO1xuICAgICAgdG9rZW4uanNvbiA9IE9QRVJBVE9SU1tpZGVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBnZXR0ZXJGbihpZGVudCwgdGhpcy5vcHRpb25zLCB0aGlzLnRleHQpO1xuICAgICAgdG9rZW4uZm4gPSBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKSB7XG4gICAgICAgIHJldHVybiAoZ2V0dGVyKHNlbGYsIGxvY2FscykpO1xuICAgICAgfSwge1xuICAgICAgICBhc3NpZ246IGZ1bmN0aW9uKHNlbGYsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcihzZWxmLCBpZGVudCwgdmFsdWUsIHBhcnNlci50ZXh0LCBwYXJzZXIub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgaWYgKG1ldGhvZE5hbWUpIHtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICBpbmRleDpsYXN0RG90LFxuICAgICAgICB0ZXh0OiAnLicsXG4gICAgICAgIGpzb246IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICBpbmRleDogbGFzdERvdCArIDEsXG4gICAgICAgIHRleHQ6IG1ldGhvZE5hbWUsXG4gICAgICAgIGpzb246IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVhZFN0cmluZzogZnVuY3Rpb24ocXVvdGUpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgIHRoaXMuaW5kZXgrKztcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdmFyIHJhd1N0cmluZyA9IHF1b3RlO1xuICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMudGV4dC5jaGFyQXQodGhpcy5pbmRleCk7XG4gICAgICByYXdTdHJpbmcgKz0gY2g7XG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgdmFyIGhleCA9IHRoaXMudGV4dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICBpZiAoIWhleC5tYXRjaCgvW1xcZGEtZl17NH0vaSkpXG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoJ0ludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1JyArIGhleCArICddJyk7XG4gICAgICAgICAgdGhpcy5pbmRleCArPSA0O1xuICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVwID0gRVNDQVBFW2NoXTtcbiAgICAgICAgICBpZiAocmVwKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gcmVwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIGluZGV4OiBzdGFydCxcbiAgICAgICAgICB0ZXh0OiByYXdTdHJpbmcsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICBmbjogZnVuY3Rpb24oKSB7IHJldHVybiBzdHJpbmc7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICB9XG4gICAgdGhpcy50aHJvd0Vycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnLCBzdGFydCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBhcnNlciA9IGZ1bmN0aW9uIChsZXhlciwgJGZpbHRlciwgb3B0aW9ucykge1xuICB0aGlzLmxleGVyID0gbGV4ZXI7XG4gIHRoaXMuJGZpbHRlciA9ICRmaWx0ZXI7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5QYXJzZXIuWkVSTyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG5cblBhcnNlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXJzZXIsXG5cbiAgcGFyc2U6IGZ1bmN0aW9uICh0ZXh0LCBqc29uKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgIC8vVE9ETyhpKTogc3RyaXAgYWxsIHRoZSBvYnNvbHRlIGpzb24gc3R1ZmYgZnJvbSB0aGlzIGZpbGVcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuXG4gICAgdGhpcy50b2tlbnMgPSB0aGlzLmxleGVyLmxleCh0ZXh0KTtcblxuICAgIGlmIChqc29uKSB7XG4gICAgICAvLyBUaGUgZXh0cmEgbGV2ZWwgb2YgYWxpYXNpbmcgaXMgaGVyZSwganVzdCBpbiBjYXNlIHRoZSBsZXhlciBtaXNzZXMgc29tZXRoaW5nLCBzbyB0aGF0XG4gICAgICAvLyB3ZSBwcmV2ZW50IGFueSBhY2NpZGVudGFsIGV4ZWN1dGlvbiBpbiBKU09OLlxuICAgICAgdGhpcy5hc3NpZ25tZW50ID0gdGhpcy5sb2dpY2FsT1I7XG5cbiAgICAgIHRoaXMuZnVuY3Rpb25DYWxsID1cbiAgICAgIHRoaXMuZmllbGRBY2Nlc3MgPVxuICAgICAgdGhpcy5vYmplY3RJbmRleCA9XG4gICAgICB0aGlzLmZpbHRlckNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignaXMgbm90IHZhbGlkIGpzb24nLCB7dGV4dDogdGV4dCwgaW5kZXg6IDB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0ganNvbiA/IHRoaXMucHJpbWFyeSgpIDogdGhpcy5zdGF0ZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLnRocm93RXJyb3IoJ2lzIGFuIHVuZXhwZWN0ZWQgdG9rZW4nLCB0aGlzLnRva2Vuc1swXSk7XG4gICAgfVxuXG4gICAgdmFsdWUubGl0ZXJhbCA9ICEhdmFsdWUubGl0ZXJhbDtcbiAgICB2YWx1ZS5jb25zdGFudCA9ICEhdmFsdWUuY29uc3RhbnQ7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgcHJpbWFyeTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmltYXJ5O1xuICAgIGlmICh0aGlzLmV4cGVjdCgnKCcpKSB7XG4gICAgICBwcmltYXJ5ID0gdGhpcy5maWx0ZXJDaGFpbigpO1xuICAgICAgdGhpcy5jb25zdW1lKCcpJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV4cGVjdCgnWycpKSB7XG4gICAgICBwcmltYXJ5ID0gdGhpcy5hcnJheURlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV4cGVjdCgneycpKSB7XG4gICAgICBwcmltYXJ5ID0gdGhpcy5vYmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRva2VuID0gdGhpcy5leHBlY3QoKTtcbiAgICAgIHByaW1hcnkgPSB0b2tlbi5mbjtcbiAgICAgIGlmICghcHJpbWFyeSkge1xuICAgICAgICB0aGlzLnRocm93RXJyb3IoJ25vdCBhIHByaW1hcnkgZXhwcmVzc2lvbicsIHRva2VuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5qc29uKSB7XG4gICAgICAgIHByaW1hcnkuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICBwcmltYXJ5LmxpdGVyYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0LCBjb250ZXh0O1xuICAgIHdoaWxlICgobmV4dCA9IHRoaXMuZXhwZWN0KCcoJywgJ1snLCAnLicpKSkge1xuICAgICAgaWYgKG5leHQudGV4dCA9PT0gJygnKSB7XG4gICAgICAgIHByaW1hcnkgPSB0aGlzLmZ1bmN0aW9uQ2FsbChwcmltYXJ5LCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5leHQudGV4dCA9PT0gJ1snKSB7XG4gICAgICAgIGNvbnRleHQgPSBwcmltYXJ5O1xuICAgICAgICBwcmltYXJ5ID0gdGhpcy5vYmplY3RJbmRleChwcmltYXJ5KTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dC50ZXh0ID09PSAnLicpIHtcbiAgICAgICAgY29udGV4dCA9IHByaW1hcnk7XG4gICAgICAgIHByaW1hcnkgPSB0aGlzLmZpZWxkQWNjZXNzKHByaW1hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdJTVBPU1NJQkxFJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmltYXJ5O1xuICB9LFxuXG4gIHRocm93RXJyb3I6IGZ1bmN0aW9uKG1zZywgdG9rZW4pIHtcbiAgICB0aHJvdyAkcGFyc2VNaW5FcnIoJ3N5bnRheCcsXG4gICAgICAgICdTeW50YXggRXJyb3I6IFRva2VuIFxcJ3swfVxcJyB7MX0gYXQgY29sdW1uIHsyfSBvZiB0aGUgZXhwcmVzc2lvbiBbezN9XSBzdGFydGluZyBhdCBbezR9XS4nLFxuICAgICAgICAgIHRva2VuLnRleHQsIG1zZywgKHRva2VuLmluZGV4ICsgMSksIHRoaXMudGV4dCwgdGhpcy50ZXh0LnN1YnN0cmluZyh0b2tlbi5pbmRleCkpO1xuICB9LFxuXG4gIHBlZWtUb2tlbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93ICRwYXJzZU1pbkVycigndWVvZScsICdVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiB7MH0nLCB0aGlzLnRleHQpO1xuICAgIHJldHVybiB0aGlzLnRva2Vuc1swXTtcbiAgfSxcblxuICBwZWVrOiBmdW5jdGlvbihlMSwgZTIsIGUzLCBlNCkge1xuICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2Vuc1swXTtcbiAgICAgIHZhciB0ID0gdG9rZW4udGV4dDtcbiAgICAgIGlmICh0ID09PSBlMSB8fCB0ID09PSBlMiB8fCB0ID09PSBlMyB8fCB0ID09PSBlNCB8fFxuICAgICAgICAgICghZTEgJiYgIWUyICYmICFlMyAmJiAhZTQpKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGV4cGVjdDogZnVuY3Rpb24oZTEsIGUyLCBlMywgZTQpe1xuICAgIHZhciB0b2tlbiA9IHRoaXMucGVlayhlMSwgZTIsIGUzLCBlNCk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBpZiAodGhpcy5qc29uICYmICF0b2tlbi5qc29uKSB7XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcignaXMgbm90IHZhbGlkIGpzb24nLCB0b2tlbik7XG4gICAgICB9XG4gICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgY29uc3VtZTogZnVuY3Rpb24oZTEpe1xuICAgIGlmICghdGhpcy5leHBlY3QoZTEpKSB7XG4gICAgICB0aGlzLnRocm93RXJyb3IoJ2lzIHVuZXhwZWN0ZWQsIGV4cGVjdGluZyBbJyArIGUxICsgJ10nLCB0aGlzLnBlZWsoKSk7XG4gICAgfVxuICB9LFxuXG4gIHVuYXJ5Rm46IGZ1bmN0aW9uKGZuLCByaWdodCkge1xuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKSB7XG4gICAgICByZXR1cm4gZm4oc2VsZiwgbG9jYWxzLCByaWdodCk7XG4gICAgfSwge1xuICAgICAgY29uc3RhbnQ6cmlnaHQuY29uc3RhbnRcbiAgICB9KTtcbiAgfSxcblxuICB0ZXJuYXJ5Rm46IGZ1bmN0aW9uKGxlZnQsIG1pZGRsZSwgcmlnaHQpe1xuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKXtcbiAgICAgIHJldHVybiBsZWZ0KHNlbGYsIGxvY2FscykgPyBtaWRkbGUoc2VsZiwgbG9jYWxzKSA6IHJpZ2h0KHNlbGYsIGxvY2Fscyk7XG4gICAgfSwge1xuICAgICAgY29uc3RhbnQ6IGxlZnQuY29uc3RhbnQgJiYgbWlkZGxlLmNvbnN0YW50ICYmIHJpZ2h0LmNvbnN0YW50XG4gICAgfSk7XG4gIH0sXG5cbiAgYmluYXJ5Rm46IGZ1bmN0aW9uKGxlZnQsIGZuLCByaWdodCkge1xuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24oc2VsZiwgbG9jYWxzKSB7XG4gICAgICByZXR1cm4gZm4oc2VsZiwgbG9jYWxzLCBsZWZ0LCByaWdodCk7XG4gICAgfSwge1xuICAgICAgY29uc3RhbnQ6bGVmdC5jb25zdGFudCAmJiByaWdodC5jb25zdGFudFxuICAgIH0pO1xuICB9LFxuXG4gIHN0YXRlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwICYmICF0aGlzLnBlZWsoJ30nLCAnKScsICc7JywgJ10nKSlcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKHRoaXMuZmlsdGVyQ2hhaW4oKSk7XG4gICAgICBpZiAoIXRoaXMuZXhwZWN0KCc7JykpIHtcbiAgICAgICAgLy8gb3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSB0aGVyZSBpcyBvbmx5IG9uZSBzdGF0ZW1lbnQuXG4gICAgICAgIC8vIFRPRE8oc2l6ZSk6IG1heWJlIHdlIHNob3VsZCBub3Qgc3VwcG9ydCBtdWx0aXBsZSBzdGF0ZW1lbnRzP1xuICAgICAgICByZXR1cm4gKHN0YXRlbWVudHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgPyBzdGF0ZW1lbnRzWzBdXG4gICAgICAgICAgICA6IGZ1bmN0aW9uKHNlbGYsIGxvY2Fscykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0YXRlbWVudChzZWxmLCBsb2NhbHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZpbHRlckNoYWluOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVmdCA9IHRoaXMuZXhwcmVzc2lvbigpO1xuICAgIHZhciB0b2tlbjtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCh0b2tlbiA9IHRoaXMuZXhwZWN0KCd8JykpKSB7XG4gICAgICAgIGxlZnQgPSB0aGlzLmJpbmFyeUZuKGxlZnQsIHRva2VuLmZuLCB0aGlzLmZpbHRlcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBmaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuZXhwZWN0KCk7XG4gICAgdmFyIGZuID0gdGhpcy4kZmlsdGVyKHRva2VuLnRleHQpO1xuICAgIHZhciBhcmdzRm4gPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCh0b2tlbiA9IHRoaXMuZXhwZWN0KCc6JykpKSB7XG4gICAgICAgIGFyZ3NGbi5wdXNoKHRoaXMuZXhwcmVzc2lvbigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmbkludm9rZSA9IGZ1bmN0aW9uKHNlbGYsIGxvY2FscywgaW5wdXQpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtpbnB1dF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzRm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmdzRm5baV0oc2VsZiwgbG9jYWxzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBmbkludm9rZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWdubWVudCgpO1xuICB9LFxuXG4gIGFzc2lnbm1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZWZ0ID0gdGhpcy50ZXJuYXJ5KCk7XG4gICAgdmFyIHJpZ2h0O1xuICAgIHZhciB0b2tlbjtcbiAgICBpZiAoKHRva2VuID0gdGhpcy5leHBlY3QoJz0nKSkpIHtcbiAgICAgIGlmICghbGVmdC5hc3NpZ24pIHtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdpbXBsaWVzIGFzc2lnbm1lbnQgYnV0IFsnICtcbiAgICAgICAgICAgIHRoaXMudGV4dC5zdWJzdHJpbmcoMCwgdG9rZW4uaW5kZXgpICsgJ10gY2FuIG5vdCBiZSBhc3NpZ25lZCB0bycsIHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJpZ2h0ID0gdGhpcy50ZXJuYXJ5KCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGxvY2Fscykge1xuICAgICAgICByZXR1cm4gbGVmdC5hc3NpZ24oc2NvcGUsIHJpZ2h0KHNjb3BlLCBsb2NhbHMpLCBsb2NhbHMpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH0sXG5cbiAgdGVybmFyeTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzLmxvZ2ljYWxPUigpO1xuICAgIHZhciBtaWRkbGU7XG4gICAgdmFyIHRva2VuO1xuICAgIGlmICgodG9rZW4gPSB0aGlzLmV4cGVjdCgnPycpKSkge1xuICAgICAgbWlkZGxlID0gdGhpcy50ZXJuYXJ5KCk7XG4gICAgICBpZiAoKHRva2VuID0gdGhpcy5leHBlY3QoJzonKSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybmFyeUZuKGxlZnQsIG1pZGRsZSwgdGhpcy50ZXJuYXJ5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKCdleHBlY3RlZCA6JywgdG9rZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gIH0sXG5cbiAgbG9naWNhbE9SOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVmdCA9IHRoaXMubG9naWNhbEFORCgpO1xuICAgIHZhciB0b2tlbjtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCh0b2tlbiA9IHRoaXMuZXhwZWN0KCd8fCcpKSkge1xuICAgICAgICBsZWZ0ID0gdGhpcy5iaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgdGhpcy5sb2dpY2FsQU5EKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGxvZ2ljYWxBTkQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZWZ0ID0gdGhpcy5lcXVhbGl0eSgpO1xuICAgIHZhciB0b2tlbjtcbiAgICBpZiAoKHRva2VuID0gdGhpcy5leHBlY3QoJyYmJykpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5iaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgdGhpcy5sb2dpY2FsQU5EKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfSxcblxuICBlcXVhbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzLnJlbGF0aW9uYWwoKTtcbiAgICB2YXIgdG9rZW47XG4gICAgaWYgKCh0b2tlbiA9IHRoaXMuZXhwZWN0KCc9PScsJyE9JywnPT09JywnIT09JykpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5iaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgdGhpcy5lcXVhbGl0eSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH0sXG5cbiAgcmVsYXRpb25hbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzLmFkZGl0aXZlKCk7XG4gICAgdmFyIHRva2VuO1xuICAgIGlmICgodG9rZW4gPSB0aGlzLmV4cGVjdCgnPCcsICc+JywgJzw9JywgJz49JykpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5iaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgdGhpcy5yZWxhdGlvbmFsKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfSxcblxuICBhZGRpdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzLm11bHRpcGxpY2F0aXZlKCk7XG4gICAgdmFyIHRva2VuO1xuICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLmV4cGVjdCgnKycsJy0nKSkpIHtcbiAgICAgIGxlZnQgPSB0aGlzLmJpbmFyeUZuKGxlZnQsIHRva2VuLmZuLCB0aGlzLm11bHRpcGxpY2F0aXZlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfSxcblxuICBtdWx0aXBsaWNhdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlZnQgPSB0aGlzLnVuYXJ5KCk7XG4gICAgdmFyIHRva2VuO1xuICAgIHdoaWxlICgodG9rZW4gPSB0aGlzLmV4cGVjdCgnKicsJy8nLCclJykpKSB7XG4gICAgICBsZWZ0ID0gdGhpcy5iaW5hcnlGbihsZWZ0LCB0b2tlbi5mbiwgdGhpcy51bmFyeSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH0sXG5cbiAgdW5hcnk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0b2tlbjtcbiAgICBpZiAodGhpcy5leHBlY3QoJysnKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeSgpO1xuICAgIH0gZWxzZSBpZiAoKHRva2VuID0gdGhpcy5leHBlY3QoJy0nKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeUZuKFBhcnNlci5aRVJPLCB0b2tlbi5mbiwgdGhpcy51bmFyeSgpKTtcbiAgICB9IGVsc2UgaWYgKCh0b2tlbiA9IHRoaXMuZXhwZWN0KCchJykpKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmFyeUZuKHRva2VuLmZuLCB0aGlzLnVuYXJ5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmltYXJ5KCk7XG4gICAgfVxuICB9LFxuXG4gIGZpZWxkQWNjZXNzOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgcGFyc2VyID0gdGhpcztcbiAgICB2YXIgZmllbGQgPSB0aGlzLmV4cGVjdCgpLnRleHQ7XG4gICAgdmFyIGdldHRlciA9IGdldHRlckZuKGZpZWxkLCB0aGlzLm9wdGlvbnMsIHRoaXMudGV4dCk7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uKHNjb3BlLCBsb2NhbHMsIHNlbGYpIHtcbiAgICAgIHJldHVybiBnZXR0ZXIoc2VsZiB8fCBvYmplY3Qoc2NvcGUsIGxvY2FscyksIGxvY2Fscyk7XG4gICAgfSwge1xuICAgICAgYXNzaWduOiBmdW5jdGlvbihzY29wZSwgdmFsdWUsIGxvY2Fscykge1xuICAgICAgICByZXR1cm4gc2V0dGVyKG9iamVjdChzY29wZSwgbG9jYWxzKSwgZmllbGQsIHZhbHVlLCBwYXJzZXIudGV4dCwgcGFyc2VyLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG9iamVjdEluZGV4OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcGFyc2VyID0gdGhpcztcblxuICAgIHZhciBpbmRleEZuID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgdGhpcy5jb25zdW1lKCddJyk7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uKHNlbGYsIGxvY2Fscykge1xuICAgICAgdmFyIG8gPSBvYmooc2VsZiwgbG9jYWxzKSxcbiAgICAgICAgICBpID0gaW5kZXhGbihzZWxmLCBsb2NhbHMpLFxuICAgICAgICAgIHYsIHA7XG5cbiAgICAgIGlmICghbykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHYgPSBlbnN1cmVTYWZlT2JqZWN0KG9baV0sIHBhcnNlci50ZXh0KTtcbiAgICAgIGlmICh2ICYmIHYudGhlbiAmJiBwYXJzZXIub3B0aW9ucy51bndyYXBQcm9taXNlcykge1xuICAgICAgICBwID0gdjtcbiAgICAgICAgaWYgKCEoJyQkdicgaW4gdikpIHtcbiAgICAgICAgICBwLiQkdiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24odmFsKSB7IHAuJCR2ID0gdmFsOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2ID0gdi4kJHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9LCB7XG4gICAgICBhc3NpZ246IGZ1bmN0aW9uKHNlbGYsIHZhbHVlLCBsb2NhbHMpIHtcbiAgICAgICAgdmFyIGtleSA9IGluZGV4Rm4oc2VsZiwgbG9jYWxzKTtcbiAgICAgICAgLy8gcHJldmVudCBvdmVyd3JpdGluZyBvZiBGdW5jdGlvbi5jb25zdHJ1Y3RvciB3aGljaCB3b3VsZCBicmVhayBlbnN1cmVTYWZlT2JqZWN0IGNoZWNrXG4gICAgICAgIHZhciBzYWZlID0gZW5zdXJlU2FmZU9iamVjdChvYmooc2VsZiwgbG9jYWxzKSwgcGFyc2VyLnRleHQpO1xuICAgICAgICByZXR1cm4gc2FmZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgZnVuY3Rpb25DYWxsOiBmdW5jdGlvbihmbiwgY29udGV4dEdldHRlcikge1xuICAgIHZhciBhcmdzRm4gPSBbXTtcbiAgICBpZiAodGhpcy5wZWVrVG9rZW4oKS50ZXh0ICE9PSAnKScpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgYXJnc0ZuLnB1c2godGhpcy5leHByZXNzaW9uKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5leHBlY3QoJywnKSk7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZSgnKScpO1xuXG4gICAgdmFyIHBhcnNlciA9IHRoaXM7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGxvY2Fscykge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dEdldHRlciA/IGNvbnRleHRHZXR0ZXIoc2NvcGUsIGxvY2FscykgOiBzY29wZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzRm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3NGbltpXShzY29wZSwgbG9jYWxzKSk7XG4gICAgICB9XG4gICAgICB2YXIgZm5QdHIgPSBmbihzY29wZSwgbG9jYWxzLCBjb250ZXh0KSB8fCBub29wO1xuXG4gICAgICBlbnN1cmVTYWZlT2JqZWN0KGNvbnRleHQsIHBhcnNlci50ZXh0KTtcbiAgICAgIGVuc3VyZVNhZmVPYmplY3QoZm5QdHIsIHBhcnNlci50ZXh0KTtcblxuICAgICAgLy8gSUUgc3R1cGlkaXR5ISAoSUUgZG9lc24ndCBoYXZlIGFwcGx5IGZvciBzb21lIG5hdGl2ZSBmdW5jdGlvbnMpXG4gICAgICB2YXIgdiA9IGZuUHRyLmFwcGx5XG4gICAgICAgICAgICA/IGZuUHRyLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICAgICAgICA6IGZuUHRyKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuXG4gICAgICByZXR1cm4gZW5zdXJlU2FmZU9iamVjdCh2LCBwYXJzZXIudGV4dCk7XG4gICAgfTtcbiAgfSxcblxuICAvLyBUaGlzIGlzIHVzZWQgd2l0aCBqc29uIGFycmF5IGRlY2xhcmF0aW9uXG4gIGFycmF5RGVjbGFyYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudEZucyA9IFtdO1xuICAgIHZhciBhbGxDb25zdGFudCA9IHRydWU7XG4gICAgaWYgKHRoaXMucGVla1Rva2VuKCkudGV4dCAhPT0gJ10nKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBlbGVtZW50Rm4gPSB0aGlzLmV4cHJlc3Npb24oKTtcbiAgICAgICAgZWxlbWVudEZucy5wdXNoKGVsZW1lbnRGbik7XG4gICAgICAgIGlmICghZWxlbWVudEZuLmNvbnN0YW50KSB7XG4gICAgICAgICAgYWxsQ29uc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodGhpcy5leHBlY3QoJywnKSk7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZSgnXScpO1xuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbihzZWxmLCBsb2NhbHMpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50Rm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5LnB1c2goZWxlbWVudEZuc1tpXShzZWxmLCBsb2NhbHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LCB7XG4gICAgICBsaXRlcmFsOiB0cnVlLFxuICAgICAgY29uc3RhbnQ6IGFsbENvbnN0YW50XG4gICAgfSk7XG4gIH0sXG5cbiAgb2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleVZhbHVlcyA9IFtdO1xuICAgIHZhciBhbGxDb25zdGFudCA9IHRydWU7XG4gICAgaWYgKHRoaXMucGVla1Rva2VuKCkudGV4dCAhPT0gJ30nKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuZXhwZWN0KCksXG4gICAgICAgIGtleSA9IHRva2VuLnN0cmluZyB8fCB0b2tlbi50ZXh0O1xuICAgICAgICB0aGlzLmNvbnN1bWUoJzonKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKHtrZXk6IGtleSwgdmFsdWU6IHZhbHVlfSk7XG4gICAgICAgIGlmICghdmFsdWUuY29uc3RhbnQpIHtcbiAgICAgICAgICBhbGxDb25zdGFudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICh0aGlzLmV4cGVjdCgnLCcpKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lKCd9Jyk7XG5cbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uKHNlbGYsIGxvY2Fscykge1xuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleVZhbHVlID0ga2V5VmFsdWVzW2ldO1xuICAgICAgICBvYmplY3Rba2V5VmFsdWUua2V5XSA9IGtleVZhbHVlLnZhbHVlKHNlbGYsIGxvY2Fscyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sIHtcbiAgICAgIGxpdGVyYWw6IHRydWUsXG4gICAgICBjb25zdGFudDogYWxsQ29uc3RhbnRcbiAgICB9KTtcbiAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIGhlbHBlciBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHNldHRlcihvYmosIHBhdGgsIHNldFZhbHVlLCBmdWxsRXhwLCBvcHRpb25zKSB7XG4gIC8vbmVlZGVkP1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudCA9IHBhdGguc3BsaXQoJy4nKSwga2V5O1xuICBmb3IgKHZhciBpID0gMDsgZWxlbWVudC5sZW5ndGggPiAxOyBpKyspIHtcbiAgICBrZXkgPSBlbnN1cmVTYWZlTWVtYmVyTmFtZShlbGVtZW50LnNoaWZ0KCksIGZ1bGxFeHApO1xuICAgIHZhciBwcm9wZXJ0eU9iaiA9IG9ialtrZXldO1xuICAgIGlmICghcHJvcGVydHlPYmopIHtcbiAgICAgIHByb3BlcnR5T2JqID0ge307XG4gICAgICBvYmpba2V5XSA9IHByb3BlcnR5T2JqO1xuICAgIH1cbiAgICBvYmogPSBwcm9wZXJ0eU9iajtcbiAgICBpZiAob2JqLnRoZW4gJiYgb3B0aW9ucy51bndyYXBQcm9taXNlcykge1xuICAgICAgcHJvbWlzZVdhcm5pbmcoZnVsbEV4cCk7XG4gICAgICBpZiAoIShcIiQkdlwiIGluIG9iaikpIHtcbiAgICAgICAgKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTsgfVxuICAgICAgICApKG9iaik7XG4gICAgICB9XG4gICAgICBpZiAob2JqLiQkdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iai4kJHYgPSB7fTtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9iai4kJHY7XG4gICAgfVxuICB9XG4gIGtleSA9IGVuc3VyZVNhZmVNZW1iZXJOYW1lKGVsZW1lbnQuc2hpZnQoKSwgZnVsbEV4cCk7XG4gIG9ialtrZXldID0gc2V0VmFsdWU7XG4gIHJldHVybiBzZXRWYWx1ZTtcbn1cblxudmFyIGdldHRlckZuQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgXCJCbGFjayBIb2xlXCIgdmFyaWFudCBmcm9tOlxuICogLSBodHRwOi8vanNwZXJmLmNvbS9hbmd1bGFyanMtcGFyc2UtZ2V0dGVyLzRcbiAqIC0gaHR0cDovL2pzcGVyZi5jb20vcGF0aC1ldmFsdWF0aW9uLXNpbXBsaWZpZWQvN1xuICovXG5mdW5jdGlvbiBjc3BTYWZlR2V0dGVyRm4oa2V5MCwga2V5MSwga2V5Miwga2V5Mywga2V5NCwgZnVsbEV4cCwgb3B0aW9ucykge1xuICBlbnN1cmVTYWZlTWVtYmVyTmFtZShrZXkwLCBmdWxsRXhwKTtcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5MSwgZnVsbEV4cCk7XG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTIsIGZ1bGxFeHApO1xuICBlbnN1cmVTYWZlTWVtYmVyTmFtZShrZXkzLCBmdWxsRXhwKTtcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5NCwgZnVsbEV4cCk7XG5cbiAgcmV0dXJuICFvcHRpb25zLnVud3JhcFByb21pc2VzXG4gICAgICA/IGZ1bmN0aW9uIGNzcFNhZmVHZXR0ZXIoc2NvcGUsIGxvY2Fscykge1xuICAgICAgICAgIHZhciBwYXRoVmFsID0gKGxvY2FscyAmJiBsb2NhbHMuaGFzT3duUHJvcGVydHkoa2V5MCkpID8gbG9jYWxzIDogc2NvcGU7XG5cbiAgICAgICAgICBpZiAocGF0aFZhbCA9PSBudWxsKSByZXR1cm4gcGF0aFZhbDtcbiAgICAgICAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkwXTtcblxuICAgICAgICAgIGlmIChwYXRoVmFsID09IG51bGwpIHJldHVybiBrZXkxID8gdW5kZWZpbmVkIDogcGF0aFZhbDtcbiAgICAgICAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkxXTtcblxuICAgICAgICAgIGlmIChwYXRoVmFsID09IG51bGwpIHJldHVybiBrZXkyID8gdW5kZWZpbmVkIDogcGF0aFZhbDtcbiAgICAgICAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkyXTtcblxuICAgICAgICAgIGlmIChwYXRoVmFsID09IG51bGwpIHJldHVybiBrZXkzID8gdW5kZWZpbmVkIDogcGF0aFZhbDtcbiAgICAgICAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXkzXTtcblxuICAgICAgICAgIGlmIChwYXRoVmFsID09IG51bGwpIHJldHVybiBrZXk0ID8gdW5kZWZpbmVkIDogcGF0aFZhbDtcbiAgICAgICAgICBwYXRoVmFsID0gcGF0aFZhbFtrZXk0XTtcblxuICAgICAgICAgIHJldHVybiBwYXRoVmFsO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uIGNzcFNhZmVQcm9taXNlRW5hYmxlZEdldHRlcihzY29wZSwgbG9jYWxzKSB7XG4gICAgICAgICAgdmFyIHBhdGhWYWwgPSAobG9jYWxzICYmIGxvY2Fscy5oYXNPd25Qcm9wZXJ0eShrZXkwKSkgPyBsb2NhbHMgOiBzY29wZSxcbiAgICAgICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgICAgIGlmIChwYXRoVmFsID09IG51bGwpIHJldHVybiBwYXRoVmFsO1xuXG4gICAgICAgICAgcGF0aFZhbCA9IHBhdGhWYWxba2V5MF07XG4gICAgICAgICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlV2FybmluZyhmdWxsRXhwKTtcbiAgICAgICAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XG4gICAgICAgICAgICAgIHByb21pc2UuJCR2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhWYWwgPSBwYXRoVmFsLiQkdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhdGhWYWwgPT0gbnVsbCkgcmV0dXJuIGtleTEgPyB1bmRlZmluZWQgOiBwYXRoVmFsO1xuXG4gICAgICAgICAgcGF0aFZhbCA9IHBhdGhWYWxba2V5MV07XG4gICAgICAgICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlV2FybmluZyhmdWxsRXhwKTtcbiAgICAgICAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XG4gICAgICAgICAgICAgIHByb21pc2UuJCR2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhWYWwgPSBwYXRoVmFsLiQkdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhdGhWYWwgPT0gbnVsbCkgcmV0dXJuIGtleTIgPyB1bmRlZmluZWQgOiBwYXRoVmFsO1xuXG4gICAgICAgICAgcGF0aFZhbCA9IHBhdGhWYWxba2V5Ml07XG4gICAgICAgICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlV2FybmluZyhmdWxsRXhwKTtcbiAgICAgICAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XG4gICAgICAgICAgICAgIHByb21pc2UuJCR2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhWYWwgPSBwYXRoVmFsLiQkdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhdGhWYWwgPT0gbnVsbCkgcmV0dXJuIGtleTMgPyB1bmRlZmluZWQgOiBwYXRoVmFsO1xuXG4gICAgICAgICAgcGF0aFZhbCA9IHBhdGhWYWxba2V5M107XG4gICAgICAgICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlV2FybmluZyhmdWxsRXhwKTtcbiAgICAgICAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XG4gICAgICAgICAgICAgIHByb21pc2UuJCR2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhWYWwgPSBwYXRoVmFsLiQkdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhdGhWYWwgPT0gbnVsbCkgcmV0dXJuIGtleTQgPyB1bmRlZmluZWQgOiBwYXRoVmFsO1xuXG4gICAgICAgICAgcGF0aFZhbCA9IHBhdGhWYWxba2V5NF07XG4gICAgICAgICAgaWYgKHBhdGhWYWwgJiYgcGF0aFZhbC50aGVuKSB7XG4gICAgICAgICAgICBwcm9taXNlV2FybmluZyhmdWxsRXhwKTtcbiAgICAgICAgICAgIGlmICghKFwiJCR2XCIgaW4gcGF0aFZhbCkpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZSA9IHBhdGhWYWw7XG4gICAgICAgICAgICAgIHByb21pc2UuJCR2ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsKSB7IHByb21pc2UuJCR2ID0gdmFsOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGhWYWwgPSBwYXRoVmFsLiQkdjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhdGhWYWw7XG4gICAgICAgIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUdldHRlckZuMShrZXkwLCBmdWxsRXhwKSB7XG4gIGVuc3VyZVNhZmVNZW1iZXJOYW1lKGtleTAsIGZ1bGxFeHApO1xuXG4gIHJldHVybiBmdW5jdGlvbiBzaW1wbGVHZXR0ZXJGbjEoc2NvcGUsIGxvY2Fscykge1xuICAgIGlmIChzY29wZSA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiAoKGxvY2FscyAmJiBsb2NhbHMuaGFzT3duUHJvcGVydHkoa2V5MCkpID8gbG9jYWxzIDogc2NvcGUpW2tleTBdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaW1wbGVHZXR0ZXJGbjIoa2V5MCwga2V5MSwgZnVsbEV4cCkge1xuICBlbnN1cmVTYWZlTWVtYmVyTmFtZShrZXkwLCBmdWxsRXhwKTtcbiAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5MSwgZnVsbEV4cCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHNpbXBsZUdldHRlckZuMihzY29wZSwgbG9jYWxzKSB7XG4gICAgaWYgKHNjb3BlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgc2NvcGUgPSAoKGxvY2FscyAmJiBsb2NhbHMuaGFzT3duUHJvcGVydHkoa2V5MCkpID8gbG9jYWxzIDogc2NvcGUpW2tleTBdO1xuICAgIHJldHVybiBzY29wZSA9PSBudWxsID8gdW5kZWZpbmVkIDogc2NvcGVba2V5MV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldHRlckZuKHBhdGgsIG9wdGlvbnMsIGZ1bGxFeHApIHtcbiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgY2FjaGUgaGFzIHRoaXMgZ2V0dGVyIGFscmVhZHkuXG4gIC8vIFdlIGNhbiB1c2UgaGFzT3duUHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIGNhY2hlIGJlY2F1c2Ugd2UgZW5zdXJlLFxuICAvLyBzZWUgYmVsb3csIHRoYXQgdGhlIGNhY2hlIG5ldmVyIHN0b3JlcyBhIHBhdGggY2FsbGVkICdoYXNPd25Qcm9wZXJ0eSdcbiAgaWYgKGdldHRlckZuQ2FjaGUuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gZ2V0dGVyRm5DYWNoZVtwYXRoXTtcbiAgfVxuXG4gIHZhciBwYXRoS2V5cyA9IHBhdGguc3BsaXQoJy4nKSxcbiAgICAgIHBhdGhLZXlzTGVuZ3RoID0gcGF0aEtleXMubGVuZ3RoLFxuICAgICAgZm47XG5cbiAgLy8gV2hlbiB3ZSBoYXZlIG9ubHkgMSBvciAyIHRva2VucywgdXNlIG9wdGltaXplZCBzcGVjaWFsIGNhc2UgY2xvc3VyZXMuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2FuZ3VsYXJqcy1wYXJzZS1nZXR0ZXIvNlxuICBpZiAoIW9wdGlvbnMudW53cmFwUHJvbWlzZXMgJiYgcGF0aEtleXNMZW5ndGggPT09IDEpIHtcbiAgICBmbiA9IHNpbXBsZUdldHRlckZuMShwYXRoS2V5c1swXSwgZnVsbEV4cCk7XG4gIH0gZWxzZSBpZiAoIW9wdGlvbnMudW53cmFwUHJvbWlzZXMgJiYgcGF0aEtleXNMZW5ndGggPT09IDIpIHtcbiAgICBmbiA9IHNpbXBsZUdldHRlckZuMihwYXRoS2V5c1swXSwgcGF0aEtleXNbMV0sIGZ1bGxFeHApO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuY3NwKSB7XG4gICAgaWYgKHBhdGhLZXlzTGVuZ3RoIDwgNikge1xuICAgICAgZm4gPSBjc3BTYWZlR2V0dGVyRm4ocGF0aEtleXNbMF0sIHBhdGhLZXlzWzFdLCBwYXRoS2V5c1syXSwgcGF0aEtleXNbM10sIHBhdGhLZXlzWzRdLCBmdWxsRXhwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4gPSBmdW5jdGlvbihzY29wZSwgbG9jYWxzKSB7XG4gICAgICAgIHZhciBpID0gMCwgdmFsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFsID0gY3NwU2FmZUdldHRlckZuKHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sIHBhdGhLZXlzW2krK10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhLZXlzW2krK10sIGZ1bGxFeHAsIG9wdGlvbnMpKHNjb3BlLCBsb2NhbHMpO1xuXG4gICAgICAgICAgbG9jYWxzID0gdW5kZWZpbmVkOyAvLyBjbGVhciBhZnRlciBmaXJzdCBpdGVyYXRpb25cbiAgICAgICAgICBzY29wZSA9IHZhbDtcbiAgICAgICAgfSB3aGlsZSAoaSA8IHBhdGhLZXlzTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJ3ZhciBwO1xcbic7XG4gICAgZm9yRWFjaChwYXRoS2V5cywgZnVuY3Rpb24oa2V5LCBpbmRleCkge1xuICAgICAgZW5zdXJlU2FmZU1lbWJlck5hbWUoa2V5LCBmdWxsRXhwKTtcbiAgICAgIGNvZGUgKz0gJ2lmKHMgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcXG4nICtcbiAgICAgICAgICAgICAgJ3M9JysgKGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2ltcGx5IGRlcmVmZXJlbmNlICdzJyBvbiBhbnkgLmRvdCBub3RhdGlvblxuICAgICAgICAgICAgICAgICAgICAgID8gJ3MnXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlmIHdlIGFyZSBmaXJzdCB0aGVuIHdlIGNoZWNrIGxvY2FscyBmaXJzdCwgYW5kIGlmIHNvIHJlYWQgaXQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICA6ICcoKGsmJmsuaGFzT3duUHJvcGVydHkoXCInICsga2V5ICsgJ1wiKSk/azpzKScpICsgJ1tcIicgKyBrZXkgKyAnXCJdJyArICc7XFxuJyArXG4gICAgICAgICAgICAgIChvcHRpb25zLnVud3JhcFByb21pc2VzXG4gICAgICAgICAgICAgICAgPyAnaWYgKHMgJiYgcy50aGVuKSB7XFxuJyArXG4gICAgICAgICAgICAgICAgICAnIHB3KFwiJyArIGZ1bGxFeHAucmVwbGFjZSgvKFtcIlxcclxcbl0pL2csICdcXFxcJDEnKSArICdcIik7XFxuJyArXG4gICAgICAgICAgICAgICAgICAnIGlmICghKFwiJCR2XCIgaW4gcykpIHtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgJyBwPXM7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICcgcC4kJHYgPSB1bmRlZmluZWQ7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICcgcC50aGVuKGZ1bmN0aW9uKHYpIHtwLiQkdj12O30pO1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICAgICAgICAgJyBzPXMuJCR2XFxuJyArXG4gICAgICAgICAgICAgICAgJ31cXG4nXG4gICAgICAgICAgICAgICAgOiAnJyk7XG4gICAgfSk7XG4gICAgY29kZSArPSAncmV0dXJuIHM7JztcblxuICAgIC8qIGpzaGludCAtVzA1NCAqL1xuICAgIHZhciBldmFsZWRGbkdldHRlciA9IG5ldyBGdW5jdGlvbigncycsICdrJywgJ3B3JywgY29kZSk7IC8vIHM9c2NvcGUsIGs9bG9jYWxzLCBwdz1wcm9taXNlV2FybmluZ1xuICAgIC8qIGpzaGludCArVzA1NCAqL1xuICAgIGV2YWxlZEZuR2V0dGVyLnRvU3RyaW5nID0gdmFsdWVGbihjb2RlKTtcbiAgICBmbiA9IG9wdGlvbnMudW53cmFwUHJvbWlzZXMgPyBmdW5jdGlvbihzY29wZSwgbG9jYWxzKSB7XG4gICAgICByZXR1cm4gZXZhbGVkRm5HZXR0ZXIoc2NvcGUsIGxvY2FscywgcHJvbWlzZVdhcm5pbmcpO1xuICAgIH0gOiBldmFsZWRGbkdldHRlcjtcbiAgfVxuXG4gIC8vIE9ubHkgY2FjaGUgdGhlIHZhbHVlIGlmIGl0J3Mgbm90IGdvaW5nIHRvIG1lc3MgdXAgdGhlIGNhY2hlIG9iamVjdFxuICAvLyBUaGlzIGlzIG1vcmUgcGVyZm9ybWFudCB0aGF0IHVzaW5nIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuICBpZiAocGF0aCAhPT0gJ2hhc093blByb3BlcnR5Jykge1xuICAgIGdldHRlckZuQ2FjaGVbcGF0aF0gPSBmbjtcbiAgfVxuICByZXR1cm4gZm47XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBuZy4kcGFyc2VcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIENvbnZlcnRzIEFuZ3VsYXIge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gaW50byBhIGZ1bmN0aW9uLlxuICpcbiAqIDxwcmU+XG4gKiAgIHZhciBnZXR0ZXIgPSAkcGFyc2UoJ3VzZXIubmFtZScpO1xuICogICB2YXIgc2V0dGVyID0gZ2V0dGVyLmFzc2lnbjtcbiAqICAgdmFyIGNvbnRleHQgPSB7dXNlcjp7bmFtZTonYW5ndWxhcid9fTtcbiAqICAgdmFyIGxvY2FscyA9IHt1c2VyOntuYW1lOidsb2NhbCd9fTtcbiAqXG4gKiAgIGV4cGVjdChnZXR0ZXIoY29udGV4dCkpLnRvRXF1YWwoJ2FuZ3VsYXInKTtcbiAqICAgc2V0dGVyKGNvbnRleHQsICduZXdWYWx1ZScpO1xuICogICBleHBlY3QoY29udGV4dC51c2VyLm5hbWUpLnRvRXF1YWwoJ25ld1ZhbHVlJyk7XG4gKiAgIGV4cGVjdChnZXR0ZXIoY29udGV4dCwgbG9jYWxzKSkudG9FcXVhbCgnbG9jYWwnKTtcbiAqIDwvcHJlPlxuICpcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxuICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcbiAqXG4gKiAgICAqIGBjb250ZXh0YCDigJMgYHtvYmplY3R9YCDigJMgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXG4gKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cbiAqICAgICogYGxvY2Fsc2Ag4oCTIGB7b2JqZWN0PX1gIOKAkyBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cbiAqICAgICAgYGNvbnRleHRgLlxuICpcbiAqICAgIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBhbHNvIGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgICAgICogYGxpdGVyYWxgIOKAkyBge2Jvb2xlYW59YCDigJMgd2hldGhlciB0aGUgZXhwcmVzc2lvbidzIHRvcC1sZXZlbCBub2RlIGlzIGEgSmF2YVNjcmlwdFxuICogICAgICAgIGxpdGVyYWwuXG4gKiAgICAgICogYGNvbnN0YW50YCDigJMgYHtib29sZWFufWAg4oCTIHdoZXRoZXIgdGhlIGV4cHJlc3Npb24gaXMgbWFkZSBlbnRpcmVseSBvZiBKYXZhU2NyaXB0XG4gKiAgICAgICAgY29uc3RhbnQgbGl0ZXJhbHMuXG4gKiAgICAgICogYGFzc2lnbmAg4oCTIGB7P2Z1bmN0aW9uKGNvbnRleHQsIHZhbHVlKX1gIOKAkyBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhc3NpZ25hYmxlLCB0aGlzIHdpbGwgYmVcbiAqICAgICAgICBzZXQgdG8gYSBmdW5jdGlvbiB0byBjaGFuZ2UgaXRzIHZhbHVlIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxuICpcbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgbmcuJHBhcnNlUHJvdmlkZXJcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogYCRwYXJzZVByb3ZpZGVyYCBjYW4gYmUgdXNlZCBmb3IgY29uZmlndXJpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdGhlIHtAbGluayBuZy4kcGFyc2UgJHBhcnNlfVxuICogIHNlcnZpY2UuXG4gKi9cbmZ1bmN0aW9uICRQYXJzZVByb3ZpZGVyKCkge1xuICB2YXIgY2FjaGUgPSB7fTtcblxuICB2YXIgJHBhcnNlT3B0aW9ucyA9IHtcbiAgICBjc3A6IGZhbHNlLFxuICAgIHVud3JhcFByb21pc2VzOiBmYWxzZSxcbiAgICBsb2dQcm9taXNlV2FybmluZ3M6IHRydWVcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBQcm9taXNlIHVud3JhcHBpbmcgdmlhICRwYXJzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICpcbiAgICogQG5nZG9jIG1ldGhvZFxuICAgKiBAbmFtZSBuZy4kcGFyc2VQcm92aWRlciN1bndyYXBQcm9taXNlc1xuICAgKiBAbWV0aG9kT2YgbmcuJHBhcnNlUHJvdmlkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqICoqVGhpcyBmZWF0dXJlIGlzIGRlcHJlY2F0ZWQsIHNlZSBkZXByZWNhdGlvbiBub3RlcyBiZWxvdyBmb3IgbW9yZSBpbmZvKipcbiAgICpcbiAgICogSWYgc2V0IHRvIHRydWUgKGRlZmF1bHQgaXMgZmFsc2UpLCAkcGFyc2Ugd2lsbCB1bndyYXAgcHJvbWlzZXMgYXV0b21hdGljYWxseSB3aGVuIGEgcHJvbWlzZSBpc1xuICAgKiBmb3VuZCBhdCBhbnkgcGFydCBvZiB0aGUgZXhwcmVzc2lvbi4gSW4gb3RoZXIgd29yZHMsIGlmIHNldCB0byB0cnVlLCB0aGUgZXhwcmVzc2lvbiB3aWxsIGFsd2F5c1xuICAgKiByZXN1bHQgaW4gYSBub24tcHJvbWlzZSB2YWx1ZS5cbiAgICpcbiAgICogV2hpbGUgdGhlIHByb21pc2UgaXMgdW5yZXNvbHZlZCwgaXQncyB0cmVhdGVkIGFzIHVuZGVmaW5lZCwgYnV0IG9uY2UgcmVzb2x2ZWQgYW5kIGZ1bGZpbGxlZCxcbiAgICogdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIHByb21pc2Ugd2hpbGUgZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogKipEZXByZWNhdGlvbiBub3RpY2UqKlxuICAgKlxuICAgKiBUaGlzIGlzIGEgZmVhdHVyZSB0aGF0IGRpZG4ndCBwcm92ZSB0byBiZSB3aWxkbHkgdXNlZnVsIG9yIHBvcHVsYXIsIHByaW1hcmlseSBiZWNhdXNlIG9mIHRoZVxuICAgKiBkaWNob3RvbXkgYmV0d2VlbiBkYXRhIGFjY2VzcyBpbiB0ZW1wbGF0ZXMgKGFjY2Vzc2VkIGFzIHJhdyB2YWx1ZXMpIGFuZCBjb250cm9sbGVyIGNvZGVcbiAgICogKGFjY2Vzc2VkIGFzIHByb21pc2VzKS5cbiAgICpcbiAgICogSW4gbW9zdCBjb2RlIHdlIGVuZGVkIHVwIHJlc29sdmluZyBwcm9taXNlcyBtYW51YWxseSBpbiBjb250cm9sbGVycyBhbnl3YXkgYW5kIHRodXMgdW5pZnlpbmdcbiAgICogdGhlIG1vZGVsIGFjY2VzcyB0aGVyZS5cbiAgICpcbiAgICogT3RoZXIgZG93bnNpZGVzIG9mIGF1dG9tYXRpYyBwcm9taXNlIHVud3JhcHBpbmc6XG4gICAqXG4gICAqIC0gd2hlbiBidWlsZGluZyBjb21wb25lbnRzIGl0J3Mgb2Z0ZW4gZGVzaXJhYmxlIHRvIHJlY2VpdmUgdGhlIHJhdyBwcm9taXNlc1xuICAgKiAtIGFkZHMgY29tcGxleGl0eSBhbmQgc2xvd3MgZG93biBleHByZXNzaW9uIGV2YWx1YXRpb25cbiAgICogLSBtYWtlcyBleHByZXNzaW9uIGNvZGUgcHJlLWdlbmVyYXRpb24gdW5hdHRyYWN0aXZlIGR1ZSB0byB0aGUgYW1vdW50IG9mIGNvZGUgdGhhdCBuZWVkcyB0byBiZVxuICAgKiAgIGdlbmVyYXRlZFxuICAgKiAtIG1ha2VzIElERSBhdXRvLWNvbXBsZXRpb24gYW5kIHRvb2wgc3VwcG9ydCBoYXJkXG4gICAqXG4gICAqICoqV2FybmluZyBMb2dzKipcbiAgICpcbiAgICogSWYgdGhlIHVud3JhcHBpbmcgaXMgZW5hYmxlZCwgQW5ndWxhciB3aWxsIGxvZyBhIHdhcm5pbmcgYWJvdXQgZWFjaCBleHByZXNzaW9uIHRoYXQgdW53cmFwcyBhXG4gICAqIHByb21pc2UgKHRvIHJlZHVjZSB0aGUgbm9pc2UsIGVhY2ggZXhwcmVzc2lvbiBpcyBsb2dnZWQgb25seSBvbmNlKS4gVG8gZGlzYWJsZSB0aGlzIGxvZ2dpbmcgdXNlXG4gICAqIGAkcGFyc2VQcm92aWRlci5sb2dQcm9taXNlV2FybmluZ3MoZmFsc2UpYCBhcGkuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZhbHVlIE5ldyB2YWx1ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW58c2VsZn0gUmV0dXJucyB0aGUgY3VycmVudCBzZXR0aW5nIHdoZW4gdXNlZCBhcyBnZXR0ZXIgYW5kIHNlbGYgaWYgdXNlZCBhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIuXG4gICAqL1xuICB0aGlzLnVud3JhcFByb21pc2VzID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgJHBhcnNlT3B0aW9ucy51bndyYXBQcm9taXNlcyA9ICEhdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICRwYXJzZU9wdGlvbnMudW53cmFwUHJvbWlzZXM7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFByb21pc2UgdW53cmFwcGluZyB2aWEgJHBhcnNlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgKlxuICAgKiBAbmdkb2MgbWV0aG9kXG4gICAqIEBuYW1lIG5nLiRwYXJzZVByb3ZpZGVyI2xvZ1Byb21pc2VXYXJuaW5nc1xuICAgKiBAbWV0aG9kT2YgbmcuJHBhcnNlUHJvdmlkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIENvbnRyb2xzIHdoZXRoZXIgQW5ndWxhciBzaG91bGQgbG9nIGEgd2FybmluZyBvbiBhbnkgZW5jb3VudGVyIG9mIGEgcHJvbWlzZSBpbiBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBpcyBzZXQgdG8gYHRydWVgLlxuICAgKlxuICAgKiBUaGlzIHNldHRpbmcgYXBwbGllcyBvbmx5IGlmIGAkcGFyc2VQcm92aWRlci51bndyYXBQcm9taXNlc2Agc2V0dGluZyBpcyBzZXQgdG8gdHJ1ZSBhcyB3ZWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB2YWx1ZSBOZXcgdmFsdWUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufHNlbGZ9IFJldHVybnMgdGhlIGN1cnJlbnQgc2V0dGluZyB3aGVuIHVzZWQgYXMgZ2V0dGVyIGFuZCBzZWxmIGlmIHVzZWQgYXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyLlxuICAgKi9cbiB0aGlzLmxvZ1Byb21pc2VXYXJuaW5ncyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICRwYXJzZU9wdGlvbnMubG9nUHJvbWlzZVdhcm5pbmdzID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICRwYXJzZU9wdGlvbnMubG9nUHJvbWlzZVdhcm5pbmdzO1xuICAgIH1cbiAgfTtcblxuXG4gIHRoaXMuJGdldCA9IFsnJGZpbHRlcicsICckc25pZmZlcicsICckbG9nJywgZnVuY3Rpb24oJGZpbHRlciwgJHNuaWZmZXIsICRsb2cpIHtcbiAgICAkcGFyc2VPcHRpb25zLmNzcCA9ICRzbmlmZmVyLmNzcDtcblxuICAgIHByb21pc2VXYXJuaW5nID0gZnVuY3Rpb24gcHJvbWlzZVdhcm5pbmdGbihmdWxsRXhwKSB7XG4gICAgICBpZiAoISRwYXJzZU9wdGlvbnMubG9nUHJvbWlzZVdhcm5pbmdzIHx8IHByb21pc2VXYXJuaW5nQ2FjaGUuaGFzT3duUHJvcGVydHkoZnVsbEV4cCkpIHJldHVybjtcbiAgICAgIHByb21pc2VXYXJuaW5nQ2FjaGVbZnVsbEV4cF0gPSB0cnVlO1xuICAgICAgJGxvZy53YXJuKCdbJHBhcnNlXSBQcm9taXNlIGZvdW5kIGluIHRoZSBleHByZXNzaW9uIGAnICsgZnVsbEV4cCArICdgLiAnICtcbiAgICAgICAgICAnQXV0b21hdGljIHVud3JhcHBpbmcgb2YgcHJvbWlzZXMgaW4gQW5ndWxhciBleHByZXNzaW9ucyBpcyBkZXByZWNhdGVkLicpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZXhwKSB7XG4gICAgICB2YXIgcGFyc2VkRXhwcmVzc2lvbjtcblxuICAgICAgc3dpdGNoICh0eXBlb2YgZXhwKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG5cbiAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoZXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2V4cF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxleGVyID0gbmV3IExleGVyKCRwYXJzZU9wdGlvbnMpO1xuICAgICAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKGxleGVyLCAkZmlsdGVyLCAkcGFyc2VPcHRpb25zKTtcbiAgICAgICAgICBwYXJzZWRFeHByZXNzaW9uID0gcGFyc2VyLnBhcnNlKGV4cCwgZmFsc2UpO1xuXG4gICAgICAgICAgaWYgKGV4cCAhPT0gJ2hhc093blByb3BlcnR5Jykge1xuICAgICAgICAgICAgLy8gT25seSBjYWNoZSB0aGUgdmFsdWUgaWYgaXQncyBub3QgZ29pbmcgdG8gbWVzcyB1cCB0aGUgY2FjaGUgb2JqZWN0XG4gICAgICAgICAgICAvLyBUaGlzIGlzIG1vcmUgcGVyZm9ybWFudCB0aGF0IHVzaW5nIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuICAgICAgICAgICAgY2FjaGVbZXhwXSA9IHBhcnNlZEV4cHJlc3Npb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnNlZEV4cHJlc3Npb247XG5cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgIHJldHVybiBleHA7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cbiAgICB9O1xuICB9XTtcbn1cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgbmcuJHFcbiAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHByb21pc2UvZGVmZXJyZWQgaW1wbGVtZW50YXRpb24gaW5zcGlyZWQgYnkgW0tyaXMgS293YWwncyBRXShodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EpLlxuICpcbiAqIFtUaGUgQ29tbW9uSlMgUHJvbWlzZSBwcm9wb3NhbF0oaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvUHJvbWlzZXMpIGRlc2NyaWJlcyBhIHByb21pc2UgYXMgYW5cbiAqIGludGVyZmFjZSBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgYW4gYWN0aW9uIHRoYXQgaXNcbiAqIHBlcmZvcm1lZCBhc3luY2hyb25vdXNseSwgYW5kIG1heSBvciBtYXkgbm90IGJlIGZpbmlzaGVkIGF0IGFueSBnaXZlbiBwb2ludCBpbiB0aW1lLlxuICpcbiAqIEZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIGRlYWxpbmcgd2l0aCBlcnJvciBoYW5kbGluZywgZGVmZXJyZWQgYW5kIHByb21pc2UgQVBJcyBhcmUgdG9cbiAqIGFzeW5jaHJvbm91cyBwcm9ncmFtbWluZyB3aGF0IGB0cnlgLCBgY2F0Y2hgIGFuZCBgdGhyb3dgIGtleXdvcmRzIGFyZSB0byBzeW5jaHJvbm91cyBwcm9ncmFtbWluZy5cbiAqXG4gKiA8cHJlPlxuICogICAvLyBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBleGFtcGxlIGxldCdzIGFzc3VtZSB0aGF0IHZhcmlhYmxlcyBgJHFgIGFuZCBgc2NvcGVgIGFyZVxuICogICAvLyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSAodGhleSBjb3VsZCBoYXZlIGJlZW4gaW5qZWN0ZWQgb3IgcGFzc2VkIGluKS5cbiAqXG4gKiAgIGZ1bmN0aW9uIGFzeW5jR3JlZXQobmFtZSkge1xuICogICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gKlxuICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAvLyBzaW5jZSB0aGlzIGZuIGV4ZWN1dGVzIGFzeW5jIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AsIHdlIG5lZWQgdG8gd3JhcFxuICogICAgICAgLy8gb3VyIGNvZGUgaW50byBhbiAkYXBwbHkgY2FsbCBzbyB0aGF0IHRoZSBtb2RlbCBjaGFuZ2VzIGFyZSBwcm9wZXJseSBvYnNlcnZlZC5cbiAqICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAqICAgICAgICAgZGVmZXJyZWQubm90aWZ5KCdBYm91dCB0byBncmVldCAnICsgbmFtZSArICcuJyk7XG4gKlxuICogICAgICAgICBpZiAob2tUb0dyZWV0KG5hbWUpKSB7XG4gKiAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgnSGVsbG8sICcgKyBuYW1lICsgJyEnKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoJ0dyZWV0aW5nICcgKyBuYW1lICsgJyBpcyBub3QgYWxsb3dlZC4nKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfSk7XG4gKiAgICAgfSwgMTAwMCk7XG4gKlxuICogICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICogICB9XG4gKlxuICogICB2YXIgcHJvbWlzZSA9IGFzeW5jR3JlZXQoJ1JvYmluIEhvb2QnKTtcbiAqICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gKiAgICAgYWxlcnQoJ1N1Y2Nlc3M6ICcgKyBncmVldGluZyk7XG4gKiAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICogICAgIGFsZXJ0KCdGYWlsZWQ6ICcgKyByZWFzb24pO1xuICogICB9LCBmdW5jdGlvbih1cGRhdGUpIHtcbiAqICAgICBhbGVydCgnR290IG5vdGlmaWNhdGlvbjogJyArIHVwZGF0ZSk7XG4gKiAgIH0pO1xuICogPC9wcmU+XG4gKlxuICogQXQgZmlyc3QgaXQgbWlnaHQgbm90IGJlIG9idmlvdXMgd2h5IHRoaXMgZXh0cmEgY29tcGxleGl0eSBpcyB3b3J0aCB0aGUgdHJvdWJsZS4gVGhlIHBheW9mZlxuICogY29tZXMgaW4gdGhlIHdheSBvZiBndWFyYW50ZWVzIHRoYXQgcHJvbWlzZSBhbmQgZGVmZXJyZWQgQVBJcyBtYWtlLCBzZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvdW5jb21tb25qcy9ibG9iL21hc3Rlci9wcm9taXNlcy9zcGVjaWZpY2F0aW9uLm1kLlxuICpcbiAqIEFkZGl0aW9uYWxseSB0aGUgcHJvbWlzZSBhcGkgYWxsb3dzIGZvciBjb21wb3NpdGlvbiB0aGF0IGlzIHZlcnkgaGFyZCB0byBkbyB3aXRoIHRoZVxuICogdHJhZGl0aW9uYWwgY2FsbGJhY2sgKFtDUFNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udGludWF0aW9uLXBhc3Npbmdfc3R5bGUpKSBhcHByb2FjaC5cbiAqIEZvciBtb3JlIG9uIHRoaXMgcGxlYXNlIHNlZSB0aGUgW1EgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xKSBlc3BlY2lhbGx5IHRoZVxuICogc2VjdGlvbiBvbiBzZXJpYWwgb3IgcGFyYWxsZWwgam9pbmluZyBvZiBwcm9taXNlcy5cbiAqXG4gKlxuICogIyBUaGUgRGVmZXJyZWQgQVBJXG4gKlxuICogQSBuZXcgaW5zdGFuY2Ugb2YgZGVmZXJyZWQgaXMgY29uc3RydWN0ZWQgYnkgY2FsbGluZyBgJHEuZGVmZXIoKWAuXG4gKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhlIGRlZmVycmVkIG9iamVjdCBpcyB0byBleHBvc2UgdGhlIGFzc29jaWF0ZWQgUHJvbWlzZSBpbnN0YW5jZSBhcyB3ZWxsIGFzIEFQSXNcbiAqIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHNpZ25hbGluZyB0aGUgc3VjY2Vzc2Z1bCBvciB1bnN1Y2Nlc3NmdWwgY29tcGxldGlvbiwgYXMgd2VsbCBhcyB0aGUgc3RhdHVzXG4gKiBvZiB0aGUgdGFzay5cbiAqXG4gKiAqKk1ldGhvZHMqKlxuICpcbiAqIC0gYHJlc29sdmUodmFsdWUpYCDigJMgcmVzb2x2ZXMgdGhlIGRlcml2ZWQgcHJvbWlzZSB3aXRoIHRoZSBgdmFsdWVgLiBJZiB0aGUgdmFsdWUgaXMgYSByZWplY3Rpb25cbiAqICAgY29uc3RydWN0ZWQgdmlhIGAkcS5yZWplY3RgLCB0aGUgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIGluc3RlYWQuXG4gKiAtIGByZWplY3QocmVhc29uKWAg4oCTIHJlamVjdHMgdGhlIGRlcml2ZWQgcHJvbWlzZSB3aXRoIHRoZSBgcmVhc29uYC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gKiAgIHJlc29sdmluZyBpdCB3aXRoIGEgcmVqZWN0aW9uIGNvbnN0cnVjdGVkIHZpYSBgJHEucmVqZWN0YC5cbiAqIC0gYG5vdGlmeSh2YWx1ZSlgIC0gcHJvdmlkZXMgdXBkYXRlcyBvbiB0aGUgc3RhdHVzIG9mIHRoZSBwcm9taXNlcyBleGVjdXRpb24uIFRoaXMgbWF5IGJlIGNhbGxlZFxuICogICBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgdGhlIHByb21pc2UgaXMgZWl0aGVyIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuICpcbiAqICoqUHJvcGVydGllcyoqXG4gKlxuICogLSBwcm9taXNlIOKAkyBge1Byb21pc2V9YCDigJMgcHJvbWlzZSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGVmZXJyZWQuXG4gKlxuICpcbiAqICMgVGhlIFByb21pc2UgQVBJXG4gKlxuICogQSBuZXcgcHJvbWlzZSBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoZW4gYSBkZWZlcnJlZCBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBjYW4gYmUgcmV0cmlldmVkIGJ5XG4gKiBjYWxsaW5nIGBkZWZlcnJlZC5wcm9taXNlYC5cbiAqXG4gKiBUaGUgcHVycG9zZSBvZiB0aGUgcHJvbWlzZSBvYmplY3QgaXMgdG8gYWxsb3cgZm9yIGludGVyZXN0ZWQgcGFydGllcyB0byBnZXQgYWNjZXNzIHRvIHRoZSByZXN1bHRcbiAqIG9mIHRoZSBkZWZlcnJlZCB0YXNrIHdoZW4gaXQgY29tcGxldGVzLlxuICpcbiAqICoqTWV0aG9kcyoqXG4gKlxuICogLSBgdGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2ssIG5vdGlmeUNhbGxiYWNrKWAg4oCTIHJlZ2FyZGxlc3Mgb2Ygd2hlbiB0aGUgcHJvbWlzZSB3YXMgb3JcbiAqICAgd2lsbCBiZSByZXNvbHZlZCBvciByZWplY3RlZCwgYHRoZW5gIGNhbGxzIG9uZSBvZiB0aGUgc3VjY2VzcyBvciBlcnJvciBjYWxsYmFja3MgYXN5bmNocm9ub3VzbHlcbiAqICAgYXMgc29vbiBhcyB0aGUgcmVzdWx0IGlzIGF2YWlsYWJsZS4gVGhlIGNhbGxiYWNrcyBhcmUgY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQ6IHRoZSByZXN1bHRcbiAqICAgb3IgcmVqZWN0aW9uIHJlYXNvbi4gQWRkaXRpb25hbGx5LCB0aGUgbm90aWZ5IGNhbGxiYWNrIG1heSBiZSBjYWxsZWQgemVybyBvciBtb3JlIHRpbWVzIHRvXG4gKiAgIHByb3ZpZGUgYSBwcm9ncmVzcyBpbmRpY2F0aW9uLCBiZWZvcmUgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQuXG4gKlxuICogICBUaGlzIG1ldGhvZCAqcmV0dXJucyBhIG5ldyBwcm9taXNlKiB3aGljaCBpcyByZXNvbHZlZCBvciByZWplY3RlZCB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAqICAgYHN1Y2Nlc3NDYWxsYmFja2AsIGBlcnJvckNhbGxiYWNrYC4gSXQgYWxzbyBub3RpZmllcyB2aWEgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAqICAgYG5vdGlmeUNhbGxiYWNrYCBtZXRob2QuIFRoZSBwcm9taXNlIGNhbiBub3QgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgZnJvbSB0aGUgbm90aWZ5Q2FsbGJhY2tcbiAqICAgbWV0aG9kLlxuICpcbiAqIC0gYGNhdGNoKGVycm9yQ2FsbGJhY2spYCDigJMgc2hvcnRoYW5kIGZvciBgcHJvbWlzZS50aGVuKG51bGwsIGVycm9yQ2FsbGJhY2spYFxuICpcbiAqIC0gYGZpbmFsbHkoY2FsbGJhY2spYCDigJMgYWxsb3dzIHlvdSB0byBvYnNlcnZlIGVpdGhlciB0aGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIG9mIGEgcHJvbWlzZSxcbiAqICAgYnV0IHRvIGRvIHNvIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBmaW5hbCB2YWx1ZS4gVGhpcyBpcyB1c2VmdWwgdG8gcmVsZWFzZSByZXNvdXJjZXMgb3IgZG8gc29tZVxuICogICBjbGVhbi11cCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgd2hldGhlciB0aGUgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgb3IgcmVzb2x2ZWQuIFNlZSB0aGUgW2Z1bGxcbiAqICAgc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL3dpa2kvQVBJLVJlZmVyZW5jZSNwcm9taXNlZmluYWxseWNhbGxiYWNrKSBmb3JcbiAqICAgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAgIEJlY2F1c2UgYGZpbmFsbHlgIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKYXZhU2NyaXB0IGFuZCByZXNlcnZlZCBrZXl3b3JkcyBhcmUgbm90IHN1cHBvcnRlZCBhc1xuICogICBwcm9wZXJ0eSBuYW1lcyBieSBFUzMsIHlvdSdsbCBuZWVkIHRvIGludm9rZSB0aGUgbWV0aG9kIGxpa2UgYHByb21pc2VbJ2ZpbmFsbHknXShjYWxsYmFjaylgIHRvXG4gKiAgIG1ha2UgeW91ciBjb2RlIElFOCBjb21wYXRpYmxlLlxuICpcbiAqICMgQ2hhaW5pbmcgcHJvbWlzZXNcbiAqXG4gKiBCZWNhdXNlIGNhbGxpbmcgdGhlIGB0aGVuYCBtZXRob2Qgb2YgYSBwcm9taXNlIHJldHVybnMgYSBuZXcgZGVyaXZlZCBwcm9taXNlLCBpdCBpcyBlYXNpbHlcbiAqIHBvc3NpYmxlIHRvIGNyZWF0ZSBhIGNoYWluIG9mIHByb21pc2VzOlxuICpcbiAqIDxwcmU+XG4gKiAgIHByb21pc2VCID0gcHJvbWlzZUEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAqICAgICByZXR1cm4gcmVzdWx0ICsgMTtcbiAqICAgfSk7XG4gKlxuICogICAvLyBwcm9taXNlQiB3aWxsIGJlIHJlc29sdmVkIGltbWVkaWF0ZWx5IGFmdGVyIHByb21pc2VBIGlzIHJlc29sdmVkIGFuZCBpdHMgdmFsdWVcbiAqICAgLy8gd2lsbCBiZSB0aGUgcmVzdWx0IG9mIHByb21pc2VBIGluY3JlbWVudGVkIGJ5IDFcbiAqIDwvcHJlPlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGNyZWF0ZSBjaGFpbnMgb2YgYW55IGxlbmd0aCBhbmQgc2luY2UgYSBwcm9taXNlIGNhbiBiZSByZXNvbHZlZCB3aXRoIGFub3RoZXJcbiAqIHByb21pc2UgKHdoaWNoIHdpbGwgZGVmZXIgaXRzIHJlc29sdXRpb24gZnVydGhlciksIGl0IGlzIHBvc3NpYmxlIHRvIHBhdXNlL2RlZmVyIHJlc29sdXRpb24gb2ZcbiAqIHRoZSBwcm9taXNlcyBhdCBhbnkgcG9pbnQgaW4gdGhlIGNoYWluLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIGltcGxlbWVudCBwb3dlcmZ1bCBBUElzIGxpa2VcbiAqICRodHRwJ3MgcmVzcG9uc2UgaW50ZXJjZXB0b3JzLlxuICpcbiAqXG4gKiAjIERpZmZlcmVuY2VzIGJldHdlZW4gS3JpcyBLb3dhbCdzIFEgYW5kICRxXG4gKlxuICogIFRoZXJlIGFyZSB0d28gbWFpbiBkaWZmZXJlbmNlczpcbiAqXG4gKiAtICRxIGlzIGludGVncmF0ZWQgd2l0aCB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGV9IFNjb3BlIG1vZGVsIG9ic2VydmF0aW9uXG4gKiAgIG1lY2hhbmlzbSBpbiBhbmd1bGFyLCB3aGljaCBtZWFucyBmYXN0ZXIgcHJvcGFnYXRpb24gb2YgcmVzb2x1dGlvbiBvciByZWplY3Rpb24gaW50byB5b3VyXG4gKiAgIG1vZGVscyBhbmQgYXZvaWRpbmcgdW5uZWNlc3NhcnkgYnJvd3NlciByZXBhaW50cywgd2hpY2ggd291bGQgcmVzdWx0IGluIGZsaWNrZXJpbmcgVUkuXG4gKiAtIFEgaGFzIG1hbnkgbW9yZSBmZWF0dXJlcyB0aGFuICRxLCBidXQgdGhhdCBjb21lcyBhdCBhIGNvc3Qgb2YgYnl0ZXMuICRxIGlzIHRpbnksIGJ1dCBjb250YWluc1xuICogICBhbGwgdGhlIGltcG9ydGFudCBmdW5jdGlvbmFsaXR5IG5lZWRlZCBmb3IgY29tbW9uIGFzeW5jIHRhc2tzLlxuICpcbiAqICAjIFRlc3RpbmdcbiAqXG4gKiAgPHByZT5cbiAqICAgIGl0KCdzaG91bGQgc2ltdWxhdGUgcHJvbWlzZScsIGluamVjdChmdW5jdGlvbigkcSwgJHJvb3RTY29wZSkge1xuICogICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICogICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2U7XG4gKiAgICAgIHZhciByZXNvbHZlZFZhbHVlO1xuICpcbiAqICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7IHJlc29sdmVkVmFsdWUgPSB2YWx1ZTsgfSk7XG4gKiAgICAgIGV4cGVjdChyZXNvbHZlZFZhbHVlKS50b0JlVW5kZWZpbmVkKCk7XG4gKlxuICogICAgICAvLyBTaW11bGF0ZSByZXNvbHZpbmcgb2YgcHJvbWlzZVxuICogICAgICBkZWZlcnJlZC5yZXNvbHZlKDEyMyk7XG4gKiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgJ3RoZW4nIGZ1bmN0aW9uIGRvZXMgbm90IGdldCBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAqICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIHdhbnQgdGhlIHByb21pc2UgQVBJIHRvIGFsd2F5cyBiZSBhc3luYywgd2hldGhlciBvciBub3RcbiAqICAgICAgLy8gaXQgZ290IGNhbGxlZCBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5LlxuICogICAgICBleHBlY3QocmVzb2x2ZWRWYWx1ZSkudG9CZVVuZGVmaW5lZCgpO1xuICpcbiAqICAgICAgLy8gUHJvcGFnYXRlIHByb21pc2UgcmVzb2x1dGlvbiB0byAndGhlbicgZnVuY3Rpb25zIHVzaW5nICRhcHBseSgpLlxuICogICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICogICAgICBleHBlY3QocmVzb2x2ZWRWYWx1ZSkudG9FcXVhbCgxMjMpO1xuICogICAgfSkpO1xuICogIDwvcHJlPlxuICovXG5mdW5jdGlvbiAkUVByb3ZpZGVyKCkge1xuXG4gIHRoaXMuJGdldCA9IFsnJHJvb3RTY29wZScsICckZXhjZXB0aW9uSGFuZGxlcicsIGZ1bmN0aW9uKCRyb290U2NvcGUsICRleGNlcHRpb25IYW5kbGVyKSB7XG4gICAgcmV0dXJuIHFGYWN0b3J5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAkcm9vdFNjb3BlLiRldmFsQXN5bmMoY2FsbGJhY2spO1xuICAgIH0sICRleGNlcHRpb25IYW5kbGVyKTtcbiAgfV07XG59XG5cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcHJvbWlzZSBtYW5hZ2VyLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZnVuY3Rpb24pfSBuZXh0VGljayBGdW5jdGlvbiBmb3IgZXhlY3V0aW5nIGZ1bmN0aW9ucyBpbiB0aGUgbmV4dCB0dXJuLlxuICogQHBhcmFtIHtmdW5jdGlvbiguLi4qKX0gZXhjZXB0aW9uSGFuZGxlciBGdW5jdGlvbiBpbnRvIHdoaWNoIHVuZXhwZWN0ZWQgZXhjZXB0aW9ucyBhcmUgcGFzc2VkIGZvclxuICogICAgIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFByb21pc2UgbWFuYWdlci5cbiAqL1xuZnVuY3Rpb24gcUZhY3RvcnkobmV4dFRpY2ssIGV4Y2VwdGlvbkhhbmRsZXIpIHtcblxuICAvKipcbiAgICogQG5nZG9jXG4gICAqIEBuYW1lIG5nLiRxI2RlZmVyXG4gICAqIEBtZXRob2RPZiBuZy4kcVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhIGBEZWZlcnJlZGAgb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgYSB0YXNrIHdoaWNoIHdpbGwgZmluaXNoIGluIHRoZSBmdXR1cmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBkZWZlcnJlZC5cbiAgICovXG4gIHZhciBkZWZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nID0gW10sXG4gICAgICAgIHZhbHVlLCBkZWZlcnJlZDtcblxuICAgIGRlZmVycmVkID0ge1xuXG4gICAgICByZXNvbHZlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gcGVuZGluZztcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHZhbHVlID0gcmVmKHZhbCk7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKGNhbGxiYWNrWzBdLCBjYWxsYmFja1sxXSwgY2FsbGJhY2tbMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cblxuICAgICAgcmVqZWN0OiBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZWplY3QocmVhc29uKSk7XG4gICAgICB9LFxuXG5cbiAgICAgIG5vdGlmeTogZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gcGVuZGluZztcblxuICAgICAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1syXShwcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICBwcm9taXNlOiB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uKGNhbGxiYWNrLCBlcnJiYWNrLCBwcm9ncmVzc2JhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKTtcblxuICAgICAgICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoKGlzRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiBkZWZhdWx0Q2FsbGJhY2spKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChlKTtcbiAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHdyYXBwZWRFcnJiYWNrID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZSgoaXNGdW5jdGlvbihlcnJiYWNrKSA/IGVycmJhY2sgOiBkZWZhdWx0RXJyYmFjaykocmVhc29uKSk7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChlKTtcbiAgICAgICAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHdyYXBwZWRQcm9ncmVzc2JhY2sgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzdWx0Lm5vdGlmeSgoaXNGdW5jdGlvbihwcm9ncmVzc2JhY2spID8gcHJvZ3Jlc3NiYWNrIDogZGVmYXVsdENhbGxiYWNrKShwcm9ncmVzcykpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIGV4Y2VwdGlvbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nLnB1c2goW3dyYXBwZWRDYWxsYmFjaywgd3JhcHBlZEVycmJhY2ssIHdyYXBwZWRQcm9ncmVzc2JhY2tdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUudGhlbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRFcnJiYWNrLCB3cmFwcGVkUHJvZ3Jlc3NiYWNrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnByb21pc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJjYXRjaFwiOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiZmluYWxseVwiOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXG4gICAgICAgICAgZnVuY3Rpb24gbWFrZVByb21pc2UodmFsdWUsIHJlc29sdmVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVDYWxsYmFjayh2YWx1ZSwgaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrT3V0cHV0ID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrT3V0cHV0ID0gKGNhbGxiYWNrIHx8ZGVmYXVsdENhbGxiYWNrKSgpO1xuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZShlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tPdXRwdXQgJiYgaXNGdW5jdGlvbihjYWxsYmFja091dHB1dC50aGVuKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tPdXRwdXQudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVByb21pc2UodmFsdWUsIGlzUmVzb2x2ZWQpO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZShlcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBtYWtlUHJvbWlzZSh2YWx1ZSwgaXNSZXNvbHZlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKGVycm9yLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9O1xuXG5cbiAgdmFyIHJlZiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUudGhlbikpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhlbjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRlZmVyKCk7XG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKGNhbGxiYWNrKHZhbHVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnByb21pc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAbmdkb2NcbiAgICogQG5hbWUgbmcuJHEjcmVqZWN0XG4gICAqIEBtZXRob2RPZiBuZy4kcVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBhcyByZWplY3RlZCB3aXRoIHRoZSBzcGVjaWZpZWQgYHJlYXNvbmAuIFRoaXMgYXBpIHNob3VsZCBiZVxuICAgKiB1c2VkIHRvIGZvcndhcmQgcmVqZWN0aW9uIGluIGEgY2hhaW4gb2YgcHJvbWlzZXMuIElmIHlvdSBhcmUgZGVhbGluZyB3aXRoIHRoZSBsYXN0IHByb21pc2UgaW5cbiAgICogYSBwcm9taXNlIGNoYWluLCB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBpdC5cbiAgICpcbiAgICogV2hlbiBjb21wYXJpbmcgZGVmZXJyZWRzL3Byb21pc2VzIHRvIHRoZSBmYW1pbGlhciBiZWhhdmlvciBvZiB0cnkvY2F0Y2gvdGhyb3csIHRoaW5rIG9mXG4gICAqIGByZWplY3RgIGFzIHRoZSBgdGhyb3dgIGtleXdvcmQgaW4gSmF2YVNjcmlwdC4gVGhpcyBhbHNvIG1lYW5zIHRoYXQgaWYgeW91IFwiY2F0Y2hcIiBhbiBlcnJvciB2aWFcbiAgICogYSBwcm9taXNlIGVycm9yIGNhbGxiYWNrIGFuZCB5b3Ugd2FudCB0byBmb3J3YXJkIHRoZSBlcnJvciB0byB0aGUgcHJvbWlzZSBkZXJpdmVkIGZyb20gdGhlXG4gICAqIGN1cnJlbnQgcHJvbWlzZSwgeW91IGhhdmUgdG8gXCJyZXRocm93XCIgdGhlIGVycm9yIGJ5IHJldHVybmluZyBhIHJlamVjdGlvbiBjb25zdHJ1Y3RlZCB2aWFcbiAgICogYHJlamVjdGAuXG4gICAqXG4gICAqIDxwcmU+XG4gICAqICAgcHJvbWlzZUIgPSBwcm9taXNlQS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgKiAgICAgLy8gc3VjY2VzczogZG8gc29tZXRoaW5nIGFuZCByZXNvbHZlIHByb21pc2VCXG4gICAqICAgICAvLyAgICAgICAgICB3aXRoIHRoZSBvbGQgb3IgYSBuZXcgcmVzdWx0XG4gICAqICAgICByZXR1cm4gcmVzdWx0O1xuICAgKiAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgKiAgICAgLy8gZXJyb3I6IGhhbmRsZSB0aGUgZXJyb3IgaWYgcG9zc2libGUgYW5kXG4gICAqICAgICAvLyAgICAgICAgcmVzb2x2ZSBwcm9taXNlQiB3aXRoIG5ld1Byb21pc2VPclZhbHVlLFxuICAgKiAgICAgLy8gICAgICAgIG90aGVyd2lzZSBmb3J3YXJkIHRoZSByZWplY3Rpb24gdG8gcHJvbWlzZUJcbiAgICogICAgIGlmIChjYW5IYW5kbGUocmVhc29uKSkge1xuICAgKiAgICAgIC8vIGhhbmRsZSB0aGUgZXJyb3IgYW5kIHJlY292ZXJcbiAgICogICAgICByZXR1cm4gbmV3UHJvbWlzZU9yVmFsdWU7XG4gICAqICAgICB9XG4gICAqICAgICByZXR1cm4gJHEucmVqZWN0KHJlYXNvbik7XG4gICAqICAgfSk7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHJlYXNvbiBDb25zdGFudCwgbWVzc2FnZSwgZXhjZXB0aW9uIG9yIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlamVjdGlvbiByZWFzb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdhcyBhbHJlYWR5IHJlc29sdmVkIGFzIHJlamVjdGVkIHdpdGggdGhlIGByZWFzb25gLlxuICAgKi9cbiAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIHJldHVybiB7XG4gICAgICB0aGVuOiBmdW5jdGlvbihjYWxsYmFjaywgZXJyYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZGVmZXIoKTtcbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKChpc0Z1bmN0aW9uKGVycmJhY2spID8gZXJyYmFjayA6IGRlZmF1bHRFcnJiYWNrKShyZWFzb24pKTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZSk7XG4gICAgICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBuZ2RvY1xuICAgKiBAbmFtZSBuZy4kcSN3aGVuXG4gICAqIEBtZXRob2RPZiBuZy4kcVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogV3JhcHMgYW4gb2JqZWN0IHRoYXQgbWlnaHQgYmUgYSB2YWx1ZSBvciBhICgzcmQgcGFydHkpIHRoZW4tYWJsZSBwcm9taXNlIGludG8gYSAkcSBwcm9taXNlLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCB0aGF0IG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBhIHByb21pc2UsIG9yIGlmXG4gICAqIHRoZSBwcm9taXNlIGNvbWVzIGZyb20gYSBzb3VyY2UgdGhhdCBjYW4ndCBiZSB0cnVzdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9yIGEgcHJvbWlzZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2Ugb2YgdGhlIHBhc3NlZCB2YWx1ZSBvciBwcm9taXNlXG4gICAqL1xuICB2YXIgd2hlbiA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaywgZXJyYmFjaywgcHJvZ3Jlc3NiYWNrKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRlZmVyKCksXG4gICAgICAgIGRvbmU7XG5cbiAgICB2YXIgd3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihjYWxsYmFjaykgPyBjYWxsYmFjayA6IGRlZmF1bHRDYWxsYmFjaykodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBleGNlcHRpb25IYW5kbGVyKGUpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd3JhcHBlZEVycmJhY2sgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihlcnJiYWNrKSA/IGVycmJhY2sgOiBkZWZhdWx0RXJyYmFjaykocmVhc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHdyYXBwZWRQcm9ncmVzc2JhY2sgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKHByb2dyZXNzYmFjaykgPyBwcm9ncmVzc2JhY2sgOiBkZWZhdWx0Q2FsbGJhY2spKHByb2dyZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZWYodmFsdWUpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHJlZih2YWx1ZSkudGhlbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRFcnJiYWNrLCB3cmFwcGVkUHJvZ3Jlc3NiYWNrKSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5yZXNvbHZlKHdyYXBwZWRFcnJiYWNrKHJlYXNvbikpO1xuICAgICAgfSwgZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgcmVzdWx0Lm5vdGlmeSh3cmFwcGVkUHJvZ3Jlc3NiYWNrKHByb2dyZXNzKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gZGVmYXVsdEVycmJhY2socmVhc29uKSB7XG4gICAgcmV0dXJuIHJlamVjdChyZWFzb24pO1xuICB9XG5cblxuICAvKipcbiAgICogQG5nZG9jXG4gICAqIEBuYW1lIG5nLiRxI2FsbFxuICAgKiBAbWV0aG9kT2YgbmcuJHFcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvbWJpbmVzIG11bHRpcGxlIHByb21pc2VzIGludG8gYSBzaW5nbGUgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYWxsIG9mIHRoZSBpbnB1dFxuICAgKiBwcm9taXNlcyBhcmUgcmVzb2x2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXkuPFByb21pc2U+fE9iamVjdC48UHJvbWlzZT59IHByb21pc2VzIEFuIGFycmF5IG9yIGhhc2ggb2YgcHJvbWlzZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBSZXR1cm5zIGEgc2luZ2xlIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYW4gYXJyYXkvaGFzaCBvZiB2YWx1ZXMsXG4gICAqICAgZWFjaCB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9taXNlIGF0IHRoZSBzYW1lIGluZGV4L2tleSBpbiB0aGUgYHByb21pc2VzYCBhcnJheS9oYXNoLlxuICAgKiAgIElmIGFueSBvZiB0aGUgcHJvbWlzZXMgaXMgcmVzb2x2ZWQgd2l0aCBhIHJlamVjdGlvbiwgdGhpcyByZXN1bHRpbmcgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkXG4gICAqICAgd2l0aCB0aGUgc2FtZSByZWplY3Rpb24gdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpLFxuICAgICAgICBjb3VudGVyID0gMCxcbiAgICAgICAgcmVzdWx0cyA9IGlzQXJyYXkocHJvbWlzZXMpID8gW10gOiB7fTtcblxuICAgIGZvckVhY2gocHJvbWlzZXMsIGZ1bmN0aW9uKHByb21pc2UsIGtleSkge1xuICAgICAgY291bnRlcisrO1xuICAgICAgcmVmKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc3VsdHMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xuICAgICAgICByZXN1bHRzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKCEoLS1jb3VudGVyKSkgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZiAocmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm47XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoY291bnRlciA9PT0gMCkge1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGVmZXI6IGRlZmVyLFxuICAgIHJlamVjdDogcmVqZWN0LFxuICAgIHdoZW46IHdoZW4sXG4gICAgYWxsOiBhbGxcbiAgfTtcbn1cblxuLyoqXG4gKiBERVNJR04gTk9URVNcbiAqXG4gKiBUaGUgZGVzaWduIGRlY2lzaW9ucyBiZWhpbmQgdGhlIHNjb3BlIGFyZSBoZWF2aWx5IGZhdm9yZWQgZm9yIHNwZWVkIGFuZCBtZW1vcnkgY29uc3VtcHRpb24uXG4gKlxuICogVGhlIHR5cGljYWwgdXNlIG9mIHNjb3BlIGlzIHRvIHdhdGNoIHRoZSBleHByZXNzaW9ucywgd2hpY2ggbW9zdCBvZiB0aGUgdGltZSByZXR1cm4gdGhlIHNhbWVcbiAqIHZhbHVlIGFzIGxhc3QgdGltZSBzbyB3ZSBvcHRpbWl6ZSB0aGUgb3BlcmF0aW9uLlxuICpcbiAqIENsb3N1cmVzIGNvbnN0cnVjdGlvbiBpcyBleHBlbnNpdmUgaW4gdGVybXMgb2Ygc3BlZWQgYXMgd2VsbCBhcyBtZW1vcnk6XG4gKiAgIC0gTm8gY2xvc3VyZXMsIGluc3RlYWQgdXNlIHByb3RvdHlwaWNhbCBpbmhlcml0YW5jZSBmb3IgQVBJXG4gKiAgIC0gSW50ZXJuYWwgc3RhdGUgbmVlZHMgdG8gYmUgc3RvcmVkIG9uIHNjb3BlIGRpcmVjdGx5LCB3aGljaCBtZWFucyB0aGF0IHByaXZhdGUgc3RhdGUgaXNcbiAqICAgICBleHBvc2VkIGFzICQkX19fXyBwcm9wZXJ0aWVzXG4gKlxuICogTG9vcCBvcGVyYXRpb25zIGFyZSBvcHRpbWl6ZWQgYnkgdXNpbmcgd2hpbGUoY291bnQtLSkgeyAuLi4gfVxuICogICAtIHRoaXMgbWVhbnMgdGhhdCBpbiBvcmRlciB0byBrZWVwIHRoZSBzYW1lIG9yZGVyIG9mIGV4ZWN1dGlvbiBhcyBhZGRpdGlvbiB3ZSBoYXZlIHRvIGFkZFxuICogICAgIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgYmVnaW5uaW5nIChzaGlmdCkgaW5zdGVhZCBvZiBhdCB0aGUgZW5kIChwdXNoKVxuICpcbiAqIENoaWxkIHNjb3BlcyBhcmUgY3JlYXRlZCBhbmQgcmVtb3ZlZCBvZnRlblxuICogICAtIFVzaW5nIGFuIGFycmF5IHdvdWxkIGJlIHNsb3cgc2luY2UgaW5zZXJ0cyBpbiBtaWRkbGUgYXJlIGV4cGVuc2l2ZSBzbyB3ZSB1c2UgbGlua2VkIGxpc3RcbiAqXG4gKiBUaGVyZSBhcmUgZmV3IHdhdGNoZXMgdGhlbiBhIGxvdCBvZiBvYnNlcnZlcnMuIFRoaXMgaXMgd2h5IHlvdSBkb24ndCB3YW50IHRoZSBvYnNlcnZlciB0byBiZVxuICogaW1wbGVtZW50ZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHdhdGNoLiBXYXRjaCByZXF1aXJlcyByZXR1cm4gb2YgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gd2hpY2hcbiAqIGFyZSBleHBlbnNpdmUgdG8gY29uc3RydWN0LlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kcm9vdFNjb3BlUHJvdmlkZXJcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFByb3ZpZGVyIGZvciB0aGUgJHJvb3RTY29wZSBzZXJ2aWNlLlxuICovXG5cbi8qKlxuICogQG5nZG9jIGZ1bmN0aW9uXG4gKiBAbmFtZSBuZy4kcm9vdFNjb3BlUHJvdmlkZXIjZGlnZXN0VHRsXG4gKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZVByb3ZpZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBTZXRzIHRoZSBudW1iZXIgb2YgYCRkaWdlc3RgIGl0ZXJhdGlvbnMgdGhlIHNjb3BlIHNob3VsZCBhdHRlbXB0IHRvIGV4ZWN1dGUgYmVmb3JlIGdpdmluZyB1cCBhbmRcbiAqIGFzc3VtaW5nIHRoYXQgdGhlIG1vZGVsIGlzIHVuc3RhYmxlLlxuICpcbiAqIFRoZSBjdXJyZW50IGRlZmF1bHQgaXMgMTAgaXRlcmF0aW9ucy5cbiAqXG4gKiBJbiBjb21wbGV4IGFwcGxpY2F0aW9ucyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGRlcGVuZGVuY2llcyBiZXR3ZWVuIGAkd2F0Y2hgcyB3aWxsIHJlc3VsdCBpblxuICogc2V2ZXJhbCBkaWdlc3QgaXRlcmF0aW9ucy4gSG93ZXZlciBpZiBhbiBhcHBsaWNhdGlvbiBuZWVkcyBtb3JlIHRoYW4gdGhlIGRlZmF1bHQgMTAgZGlnZXN0XG4gKiBpdGVyYXRpb25zIGZvciBpdHMgbW9kZWwgdG8gc3RhYmlsaXplIHRoZW4geW91IHNob3VsZCBpbnZlc3RpZ2F0ZSB3aGF0IGlzIGNhdXNpbmcgdGhlIG1vZGVsIHRvXG4gKiBjb250aW51b3VzbHkgY2hhbmdlIGR1cmluZyB0aGUgZGlnZXN0LlxuICpcbiAqIEluY3JlYXNpbmcgdGhlIFRUTCBjb3VsZCBoYXZlIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucywgc28geW91IHNob3VsZCBub3QgY2hhbmdlIGl0IHdpdGhvdXRcbiAqIHByb3BlciBqdXN0aWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbnVtYmVyIG9mIGRpZ2VzdCBpdGVyYXRpb25zLlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kcm9vdFNjb3BlXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBFdmVyeSBhcHBsaWNhdGlvbiBoYXMgYSBzaW5nbGUgcm9vdCB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSBzY29wZX0uXG4gKiBBbGwgb3RoZXIgc2NvcGVzIGFyZSBkZXNjZW5kYW50IHNjb3BlcyBvZiB0aGUgcm9vdCBzY29wZS4gU2NvcGVzIHByb3ZpZGUgc2VwYXJhdGlvblxuICogYmV0d2VlbiB0aGUgbW9kZWwgYW5kIHRoZSB2aWV3LCB2aWEgYSBtZWNoYW5pc20gZm9yIHdhdGNoaW5nIHRoZSBtb2RlbCBmb3IgY2hhbmdlcy5cbiAqIFRoZXkgYWxzbyBwcm92aWRlIGFuIGV2ZW50IGVtaXNzaW9uL2Jyb2FkY2FzdCBhbmQgc3Vic2NyaXB0aW9uIGZhY2lsaXR5LiBTZWUgdGhlXG4gKiB7QGxpbmsgZ3VpZGUvc2NvcGUgZGV2ZWxvcGVyIGd1aWRlIG9uIHNjb3Blc30uXG4gKi9cbmZ1bmN0aW9uICRSb290U2NvcGVQcm92aWRlcigpe1xuICB2YXIgVFRMID0gMTA7XG4gIHZhciAkcm9vdFNjb3BlTWluRXJyID0gbWluRXJyKCckcm9vdFNjb3BlJyk7XG4gIHZhciBsYXN0RGlydHlXYXRjaCA9IG51bGw7XG5cbiAgdGhpcy5kaWdlc3RUdGwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBUVEwgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFRUTDtcbiAgfTtcblxuICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsICckZXhjZXB0aW9uSGFuZGxlcicsICckcGFyc2UnLCAnJGJyb3dzZXInLFxuICAgICAgZnVuY3Rpb24oICRpbmplY3RvciwgICAkZXhjZXB0aW9uSGFuZGxlciwgICAkcGFyc2UsICAgJGJyb3dzZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEEgcm9vdCBzY29wZSBjYW4gYmUgcmV0cmlldmVkIHVzaW5nIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZSAkcm9vdFNjb3BlfSBrZXkgZnJvbSB0aGVcbiAgICAgKiB7QGxpbmsgQVVUTy4kaW5qZWN0b3IgJGluamVjdG9yfS4gQ2hpbGQgc2NvcGVzIGFyZSBjcmVhdGVkIHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJG5ldyAkbmV3KCl9IG1ldGhvZC4gKE1vc3Qgc2NvcGVzIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlblxuICAgICAqIGNvbXBpbGVkIEhUTUwgdGVtcGxhdGUgaXMgZXhlY3V0ZWQuKVxuICAgICAqXG4gICAgICogSGVyZSBpcyBhIHNpbXBsZSBzY29wZSBzbmlwcGV0IHRvIHNob3cgaG93IHlvdSBjYW4gaW50ZXJhY3Qgd2l0aCB0aGUgc2NvcGUuXG4gICAgICogPHByZT5cbiAgICAgKiA8ZmlsZSBzcmM9XCIuL3Rlc3Qvbmcvcm9vdFNjb3BlU3BlYy5qc1wiIHRhZz1cImRvY3MxXCIgLz5cbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqICMgSW5oZXJpdGFuY2VcbiAgICAgKiBBIHNjb3BlIGNhbiBpbmhlcml0IGZyb20gYSBwYXJlbnQgc2NvcGUsIGFzIGluIHRoaXMgZXhhbXBsZTpcbiAgICAgKiA8cHJlPlxuICAgICAgICAgdmFyIHBhcmVudCA9ICRyb290U2NvcGU7XG4gICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuJG5ldygpO1xuXG4gICAgICAgICBwYXJlbnQuc2FsdXRhdGlvbiA9IFwiSGVsbG9cIjtcbiAgICAgICAgIGNoaWxkLm5hbWUgPSBcIldvcmxkXCI7XG4gICAgICAgICBleHBlY3QoY2hpbGQuc2FsdXRhdGlvbikudG9FcXVhbCgnSGVsbG8nKTtcblxuICAgICAgICAgY2hpbGQuc2FsdXRhdGlvbiA9IFwiV2VsY29tZVwiO1xuICAgICAgICAgZXhwZWN0KGNoaWxkLnNhbHV0YXRpb24pLnRvRXF1YWwoJ1dlbGNvbWUnKTtcbiAgICAgICAgIGV4cGVjdChwYXJlbnQuc2FsdXRhdGlvbikudG9FcXVhbCgnSGVsbG8nKTtcbiAgICAgKiA8L3ByZT5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oKT49fSBwcm92aWRlcnMgTWFwIG9mIHNlcnZpY2UgZmFjdG9yeSB3aGljaCBuZWVkIHRvIGJlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZCBmb3IgdGhlIGN1cnJlbnQgc2NvcGUuIERlZmF1bHRzIHRvIHtAbGluayBuZ30uXG4gICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj49fSBpbnN0YW5jZUNhY2hlIFByb3ZpZGVzIHByZS1pbnN0YW50aWF0ZWQgc2VydmljZXMgd2hpY2ggc2hvdWxkXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmQvb3ZlcnJpZGUgc2VydmljZXMgcHJvdmlkZWQgYnkgYHByb3ZpZGVyc2AuIFRoaXMgaXMgaGFuZHlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdW5pdC10ZXN0aW5nIGFuZCBoYXZpbmcgdGhlIG5lZWQgdG8gb3ZlcnJpZGUgYSBkZWZhdWx0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IE5ld2x5IGNyZWF0ZWQgc2NvcGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTY29wZSgpIHtcbiAgICAgIHRoaXMuJGlkID0gbmV4dFVpZCgpO1xuICAgICAgdGhpcy4kJHBoYXNlID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kJHdhdGNoZXJzID1cbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuJCRuZXh0U2libGluZyA9IHRoaXMuJCRwcmV2U2libGluZyA9XG4gICAgICAgICAgICAgICAgICAgICB0aGlzLiQkY2hpbGRIZWFkID0gdGhpcy4kJGNoaWxkVGFpbCA9IG51bGw7XG4gICAgICB0aGlzWyd0aGlzJ10gPSB0aGlzLiRyb290ID0gIHRoaXM7XG4gICAgICB0aGlzLiQkZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB0aGlzLiQkYXN5bmNRdWV1ZSA9IFtdO1xuICAgICAgdGhpcy4kJHBvc3REaWdlc3RRdWV1ZSA9IFtdO1xuICAgICAgdGhpcy4kJGxpc3RlbmVycyA9IHt9O1xuICAgICAgdGhpcy4kJGlzb2xhdGVCaW5kaW5ncyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBwcm9wZXJ0eVxuICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGlkXG4gICAgICogQHByb3BlcnR5T2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuaXF1ZSBzY29wZSBJRCAobW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIGFscGhhbnVtZXJpYyBzZXF1ZW5jZSkgdXNlZnVsIGZvclxuICAgICAqICAgZGVidWdnaW5nLlxuICAgICAqL1xuXG5cbiAgICBTY29wZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogU2NvcGUsXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkbmV3XG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBDcmVhdGVzIGEgbmV3IGNoaWxkIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlIHNjb3BlfS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgcGFyZW50IHNjb3BlIHdpbGwgcHJvcGFnYXRlIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRkaWdlc3QgJGRpZ2VzdCgpfSBhbmRcbiAgICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGRpZ2VzdCAkZGlnZXN0KCl9IGV2ZW50cy4gVGhlIHNjb3BlIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgKiBzY29wZSBoaWVyYXJjaHkgdXNpbmcge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kZGVzdHJveSAkZGVzdHJveSgpfS5cbiAgICAgICAqXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRkZXN0cm95ICRkZXN0cm95KCl9IG11c3QgYmUgY2FsbGVkIG9uIGEgc2NvcGUgd2hlbiBpdCBpc1xuICAgICAgICogZGVzaXJlZCBmb3IgdGhlIHNjb3BlIGFuZCBpdHMgY2hpbGQgc2NvcGVzIHRvIGJlIHBlcm1hbmVudGx5IGRldGFjaGVkIGZyb20gdGhlIHBhcmVudCBhbmRcbiAgICAgICAqIHRodXMgc3RvcCBwYXJ0aWNpcGF0aW5nIGluIG1vZGVsIGNoYW5nZSBkZXRlY3Rpb24gYW5kIGxpc3RlbmVyIG5vdGlmaWNhdGlvbiBieSBpbnZva2luZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzb2xhdGUgSWYgdHJ1ZSwgdGhlbiB0aGUgc2NvcGUgZG9lcyBub3QgcHJvdG90eXBpY2FsbHkgaW5oZXJpdCBmcm9tIHRoZVxuICAgICAgICogICAgICAgICBwYXJlbnQgc2NvcGUuIFRoZSBzY29wZSBpcyBpc29sYXRlZCwgYXMgaXQgY2FuIG5vdCBzZWUgcGFyZW50IHNjb3BlIHByb3BlcnRpZXMuXG4gICAgICAgKiAgICAgICAgIFdoZW4gY3JlYXRpbmcgd2lkZ2V0cywgaXQgaXMgdXNlZnVsIGZvciB0aGUgd2lkZ2V0IHRvIG5vdCBhY2NpZGVudGFsbHkgcmVhZCBwYXJlbnRcbiAgICAgICAqICAgICAgICAgc3RhdGUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG5ld2x5IGNyZWF0ZWQgY2hpbGQgc2NvcGUuXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICAkbmV3OiBmdW5jdGlvbihpc29sYXRlKSB7XG4gICAgICAgIHZhciBDaGlsZFNjb3BlLFxuICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgaWYgKGlzb2xhdGUpIHtcbiAgICAgICAgICBjaGlsZCA9IG5ldyBTY29wZSgpO1xuICAgICAgICAgIGNoaWxkLiRyb290ID0gdGhpcy4kcm9vdDtcbiAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGVyZSBpcyBqdXN0IG9uZSBhc3luYyBxdWV1ZSBwZXIgJHJvb3RTY29wZSBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgY2hpbGQuJCRhc3luY1F1ZXVlID0gdGhpcy4kJGFzeW5jUXVldWU7XG4gICAgICAgICAgY2hpbGQuJCRwb3N0RGlnZXN0UXVldWUgPSB0aGlzLiQkcG9zdERpZ2VzdFF1ZXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIENoaWxkU2NvcGUgPSBmdW5jdGlvbigpIHt9OyAvLyBzaG91bGQgYmUgYW5vbnltb3VzOyBUaGlzIGlzIHNvIHRoYXQgd2hlbiB0aGUgbWluaWZpZXIgbXVuZ2VzXG4gICAgICAgICAgICAvLyB0aGUgbmFtZSBpdCBkb2VzIG5vdCBiZWNvbWUgcmFuZG9tIHNldCBvZiBjaGFycy4gVGhpcyB3aWxsIHRoZW4gc2hvdyB1cCBhcyBjbGFzc1xuICAgICAgICAgICAgLy8gbmFtZSBpbiB0aGUgZGVidWdnZXIuXG4gICAgICAgICAgQ2hpbGRTY29wZS5wcm90b3R5cGUgPSB0aGlzO1xuICAgICAgICAgIGNoaWxkID0gbmV3IENoaWxkU2NvcGUoKTtcbiAgICAgICAgICBjaGlsZC4kaWQgPSBuZXh0VWlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbJ3RoaXMnXSA9IGNoaWxkO1xuICAgICAgICBjaGlsZC4kJGxpc3RlbmVycyA9IHt9O1xuICAgICAgICBjaGlsZC4kcGFyZW50ID0gdGhpcztcbiAgICAgICAgY2hpbGQuJCR3YXRjaGVycyA9IGNoaWxkLiQkbmV4dFNpYmxpbmcgPSBjaGlsZC4kJGNoaWxkSGVhZCA9IGNoaWxkLiQkY2hpbGRUYWlsID0gbnVsbDtcbiAgICAgICAgY2hpbGQuJCRwcmV2U2libGluZyA9IHRoaXMuJCRjaGlsZFRhaWw7XG4gICAgICAgIGlmICh0aGlzLiQkY2hpbGRIZWFkKSB7XG4gICAgICAgICAgdGhpcy4kJGNoaWxkVGFpbC4kJG5leHRTaWJsaW5nID0gY2hpbGQ7XG4gICAgICAgICAgdGhpcy4kJGNoaWxkVGFpbCA9IGNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJCRjaGlsZEhlYWQgPSB0aGlzLiQkY2hpbGRUYWlsID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJHdhdGNoXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBSZWdpc3RlcnMgYSBgbGlzdGVuZXJgIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIHRoZSBgd2F0Y2hFeHByZXNzaW9uYCBjaGFuZ2VzLlxuICAgICAgICpcbiAgICAgICAqIC0gVGhlIGB3YXRjaEV4cHJlc3Npb25gIGlzIGNhbGxlZCBvbiBldmVyeSBjYWxsIHRvIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGRpZ2VzdFxuICAgICAgICogICAkZGlnZXN0KCl9IGFuZCBzaG91bGQgcmV0dXJuIHRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgd2F0Y2hlZC4gKFNpbmNlXG4gICAgICAgKiAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGRpZ2VzdCAkZGlnZXN0KCl9IHJlcnVucyB3aGVuIGl0IGRldGVjdHMgY2hhbmdlcyB0aGVcbiAgICAgICAqICAgYHdhdGNoRXhwcmVzc2lvbmAgY2FuIGV4ZWN1dGUgbXVsdGlwbGUgdGltZXMgcGVyXG4gICAgICAgKiAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGRpZ2VzdCAkZGlnZXN0KCl9IGFuZCBzaG91bGQgYmUgaWRlbXBvdGVudC4pXG4gICAgICAgKiAtIFRoZSBgbGlzdGVuZXJgIGlzIGNhbGxlZCBvbmx5IHdoZW4gdGhlIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgYHdhdGNoRXhwcmVzc2lvbmAgYW5kIHRoZVxuICAgICAgICogICBwcmV2aW91cyBjYWxsIHRvIGB3YXRjaEV4cHJlc3Npb25gIGFyZSBub3QgZXF1YWwgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgaW5pdGlhbCBydW4sXG4gICAgICAgKiAgIHNlZSBiZWxvdykuIFRoZSBpbmVxdWFsaXR5IGlzIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4gICAgICAgKiAgIHtAbGluayBhbmd1bGFyLmVxdWFsc30gZnVuY3Rpb24uIFRvIHNhdmUgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QgZm9yIGxhdGVyIGNvbXBhcmlzb24sXG4gICAgICAgKiAgIHRoZSB7QGxpbmsgYW5ndWxhci5jb3B5fSBmdW5jdGlvbiBpcyB1c2VkLiBJdCBhbHNvIG1lYW5zIHRoYXQgd2F0Y2hpbmcgY29tcGxleCBvcHRpb25zXG4gICAgICAgKiAgIHdpbGwgaGF2ZSBhZHZlcnNlIG1lbW9yeSBhbmQgcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zLlxuICAgICAgICogLSBUaGUgd2F0Y2ggYGxpc3RlbmVyYCBtYXkgY2hhbmdlIHRoZSBtb2RlbCwgd2hpY2ggbWF5IHRyaWdnZXIgb3RoZXIgYGxpc3RlbmVyYHMgdG8gZmlyZS5cbiAgICAgICAqICAgVGhpcyBpcyBhY2hpZXZlZCBieSByZXJ1bm5pbmcgdGhlIHdhdGNoZXJzIHVudGlsIG5vIGNoYW5nZXMgYXJlIGRldGVjdGVkLiBUaGUgcmVydW5cbiAgICAgICAqICAgaXRlcmF0aW9uIGxpbWl0IGlzIDEwIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBkZWFkbG9jay5cbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogSWYgeW91IHdhbnQgdG8gYmUgbm90aWZpZWQgd2hlbmV2ZXIge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kZGlnZXN0ICRkaWdlc3R9IGlzIGNhbGxlZCxcbiAgICAgICAqIHlvdSBjYW4gcmVnaXN0ZXIgYSBgd2F0Y2hFeHByZXNzaW9uYCBmdW5jdGlvbiB3aXRoIG5vIGBsaXN0ZW5lcmAuIChTaW5jZSBgd2F0Y2hFeHByZXNzaW9uYFxuICAgICAgICogY2FuIGV4ZWN1dGUgbXVsdGlwbGUgdGltZXMgcGVyIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGRpZ2VzdCAkZGlnZXN0fSBjeWNsZSB3aGVuIGFcbiAgICAgICAqIGNoYW5nZSBpcyBkZXRlY3RlZCwgYmUgcHJlcGFyZWQgZm9yIG11bHRpcGxlIGNhbGxzIHRvIHlvdXIgbGlzdGVuZXIuKVxuICAgICAgICpcbiAgICAgICAqIEFmdGVyIGEgd2F0Y2hlciBpcyByZWdpc3RlcmVkIHdpdGggdGhlIHNjb3BlLCB0aGUgYGxpc3RlbmVyYCBmbiBpcyBjYWxsZWQgYXN5bmNocm9ub3VzbHlcbiAgICAgICAqICh2aWEge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kZXZhbEFzeW5jICRldmFsQXN5bmN9KSB0byBpbml0aWFsaXplIHRoZVxuICAgICAgICogd2F0Y2hlci4gSW4gcmFyZSBjYXNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQgd2hlbiB0aGUgcmVzdWx0XG4gICAgICAgKiBvZiBgd2F0Y2hFeHByZXNzaW9uYCBkaWRuJ3QgY2hhbmdlLiBUbyBkZXRlY3QgdGhpcyBzY2VuYXJpbyB3aXRoaW4gdGhlIGBsaXN0ZW5lcmAgZm4sIHlvdVxuICAgICAgICogY2FuIGNvbXBhcmUgdGhlIGBuZXdWYWxgIGFuZCBgb2xkVmFsYC4gSWYgdGhlc2UgdHdvIHZhbHVlcyBhcmUgaWRlbnRpY2FsIChgPT09YCkgdGhlbiB0aGVcbiAgICAgICAqIGxpc3RlbmVyIHdhcyBjYWxsZWQgZHVlIHRvIGluaXRpYWxpemF0aW9uLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBleGFtcGxlIGJlbG93IGNvbnRhaW5zIGFuIGlsbHVzdHJhdGlvbiBvZiB1c2luZyBhIGZ1bmN0aW9uIGFzIHlvdXIgJHdhdGNoIGxpc3RlbmVyXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqICMgRXhhbXBsZVxuICAgICAgICogPHByZT5cbiAgICAgICAgICAgLy8gbGV0J3MgYXNzdW1lIHRoYXQgc2NvcGUgd2FzIGRlcGVuZGVuY3kgaW5qZWN0ZWQgYXMgdGhlICRyb290U2NvcGVcbiAgICAgICAgICAgdmFyIHNjb3BlID0gJHJvb3RTY29wZTtcbiAgICAgICAgICAgc2NvcGUubmFtZSA9ICdtaXNrbyc7XG4gICAgICAgICAgIHNjb3BlLmNvdW50ZXIgPSAwO1xuXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xuICAgICAgICAgICBzY29wZS4kd2F0Y2goJ25hbWUnLCBmdW5jdGlvbihuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICBzY29wZS5jb3VudGVyID0gc2NvcGUuY291bnRlciArIDE7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBleHBlY3Qoc2NvcGUuY291bnRlcikudG9FcXVhbCgwKTtcblxuICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgIC8vIG5vIHZhcmlhYmxlIGNoYW5nZVxuICAgICAgICAgICBleHBlY3Qoc2NvcGUuY291bnRlcikudG9FcXVhbCgwKTtcblxuICAgICAgICAgICBzY29wZS5uYW1lID0gJ2FkYW0nO1xuICAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDEpO1xuXG5cblxuICAgICAgICAgICAvLyBVc2luZyBhIGxpc3RlbmVyIGZ1bmN0aW9uXG4gICAgICAgICAgIHZhciBmb29kO1xuICAgICAgICAgICBzY29wZS5mb29kQ291bnRlciA9IDA7XG4gICAgICAgICAgIGV4cGVjdChzY29wZS5mb29kQ291bnRlcikudG9FcXVhbCgwKTtcbiAgICAgICAgICAgc2NvcGUuJHdhdGNoKFxuICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBmb29kOyB9LFxuICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNoYW5nZSBoYW5kbGVyXG4gICAgICAgICAgICAgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICBpZiAoIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgLy8gT25seSBpbmNyZW1lbnQgdGhlIGNvdW50ZXIgaWYgdGhlIHZhbHVlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgc2NvcGUuZm9vZENvdW50ZXIgPSBzY29wZS5mb29kQ291bnRlciArIDE7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICApO1xuICAgICAgICAgICAvLyBObyBkaWdlc3QgaGFzIGJlZW4gcnVuIHNvIHRoZSBjb3VudGVyIHdpbGwgYmUgemVyb1xuICAgICAgICAgICBleHBlY3Qoc2NvcGUuZm9vZENvdW50ZXIpLnRvRXF1YWwoMCk7XG5cbiAgICAgICAgICAgLy8gUnVuIHRoZSBkaWdlc3QgYnV0IHNpbmNlIGZvb2QgaGFzIG5vdCBjaGFuZ2VkIGNvdXQgd2lsbCBzdGlsbCBiZSB6ZXJvXG4gICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmZvb2RDb3VudGVyKS50b0VxdWFsKDApO1xuXG4gICAgICAgICAgIC8vIFVwZGF0ZSBmb29kIGFuZCBydW4gZGlnZXN0LiAgTm93IHRoZSBjb3VudGVyIHdpbGwgaW5jcmVtZW50XG4gICAgICAgICAgIGZvb2QgPSAnY2hlZXNlYnVyZ2VyJztcbiAgICAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgICBleHBlY3Qoc2NvcGUuZm9vZENvdW50ZXIpLnRvRXF1YWwoMSk7XG5cbiAgICAgICAqIDwvcHJlPlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsoZnVuY3Rpb24oKXxzdHJpbmcpfSB3YXRjaEV4cHJlc3Npb24gRXhwcmVzc2lvbiB0aGF0IGlzIGV2YWx1YXRlZCBvbiBlYWNoXG4gICAgICAgKiAgICB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRkaWdlc3QgJGRpZ2VzdH0gY3ljbGUuIEEgY2hhbmdlIGluIHRoZSByZXR1cm4gdmFsdWUgdHJpZ2dlcnNcbiAgICAgICAqICAgIGEgY2FsbCB0byB0aGUgYGxpc3RlbmVyYC5cbiAgICAgICAqXG4gICAgICAgKiAgICAtIGBzdHJpbmdgOiBFdmFsdWF0ZWQgYXMge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn1cbiAgICAgICAqICAgIC0gYGZ1bmN0aW9uKHNjb3BlKWA6IGNhbGxlZCB3aXRoIGN1cnJlbnQgYHNjb3BlYCBhcyBhIHBhcmFtZXRlci5cbiAgICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uKCl8c3RyaW5nKT19IGxpc3RlbmVyIENhbGxiYWNrIGNhbGxlZCB3aGVuZXZlciB0aGUgcmV0dXJuIHZhbHVlIG9mXG4gICAgICAgKiAgIHRoZSBgd2F0Y2hFeHByZXNzaW9uYCBjaGFuZ2VzLlxuICAgICAgICpcbiAgICAgICAqICAgIC0gYHN0cmluZ2A6IEV2YWx1YXRlZCBhcyB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufVxuICAgICAgICogICAgLSBgZnVuY3Rpb24obmV3VmFsdWUsIG9sZFZhbHVlLCBzY29wZSlgOiBjYWxsZWQgd2l0aCBjdXJyZW50IGFuZCBwcmV2aW91cyB2YWx1ZXMgYXNcbiAgICAgICAqICAgICAgcGFyYW1ldGVycy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvYmplY3RFcXVhbGl0eSBDb21wYXJlIG9iamVjdCBmb3IgZXF1YWxpdHkgcmF0aGVyIHRoYW4gZm9yIHJlZmVyZW5jZS5cbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSBSZXR1cm5zIGEgZGVyZWdpc3RyYXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgbGlzdGVuZXIuXG4gICAgICAgKi9cbiAgICAgICR3YXRjaDogZnVuY3Rpb24od2F0Y2hFeHAsIGxpc3RlbmVyLCBvYmplY3RFcXVhbGl0eSkge1xuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLFxuICAgICAgICAgICAgZ2V0ID0gY29tcGlsZVRvRm4od2F0Y2hFeHAsICd3YXRjaCcpLFxuICAgICAgICAgICAgYXJyYXkgPSBzY29wZS4kJHdhdGNoZXJzLFxuICAgICAgICAgICAgd2F0Y2hlciA9IHtcbiAgICAgICAgICAgICAgZm46IGxpc3RlbmVyLFxuICAgICAgICAgICAgICBsYXN0OiBpbml0V2F0Y2hWYWwsXG4gICAgICAgICAgICAgIGdldDogZ2V0LFxuICAgICAgICAgICAgICBleHA6IHdhdGNoRXhwLFxuICAgICAgICAgICAgICBlcTogISFvYmplY3RFcXVhbGl0eVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBsYXN0RGlydHlXYXRjaCA9IG51bGw7XG5cbiAgICAgICAgLy8gaW4gdGhlIGNhc2UgdXNlciBwYXNzIHN0cmluZywgd2UgbmVlZCB0byBjb21waWxlIGl0LCBkbyB3ZSByZWFsbHkgbmVlZCB0aGlzID9cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkge1xuICAgICAgICAgIHZhciBsaXN0ZW5GbiA9IGNvbXBpbGVUb0ZuKGxpc3RlbmVyIHx8IG5vb3AsICdsaXN0ZW5lcicpO1xuICAgICAgICAgIHdhdGNoZXIuZm4gPSBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCwgc2NvcGUpIHtsaXN0ZW5GbihzY29wZSk7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2F0Y2hFeHAgPT0gJ3N0cmluZycgJiYgZ2V0LmNvbnN0YW50KSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsRm4gPSB3YXRjaGVyLmZuO1xuICAgICAgICAgIHdhdGNoZXIuZm4gPSBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCwgc2NvcGUpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRm4uY2FsbCh0aGlzLCBuZXdWYWwsIG9sZFZhbCwgc2NvcGUpO1xuICAgICAgICAgICAgYXJyYXlSZW1vdmUoYXJyYXksIHdhdGNoZXIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgICAgYXJyYXkgPSBzY29wZS4kJHdhdGNoZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgdXNlIHVuc2hpZnQgc2luY2Ugd2UgdXNlIGEgd2hpbGUgbG9vcCBpbiAkZGlnZXN0IGZvciBzcGVlZC5cbiAgICAgICAgLy8gdGhlIHdoaWxlIGxvb3AgcmVhZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgICAgYXJyYXkudW5zaGlmdCh3YXRjaGVyKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXJyYXlSZW1vdmUoYXJyYXksIHdhdGNoZXIpO1xuICAgICAgICB9O1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkd2F0Y2hDb2xsZWN0aW9uXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBTaGFsbG93IHdhdGNoZXMgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZCBmaXJlcyB3aGVuZXZlciBhbnkgb2YgdGhlIHByb3BlcnRpZXMgY2hhbmdlXG4gICAgICAgKiAoZm9yIGFycmF5cywgdGhpcyBpbXBsaWVzIHdhdGNoaW5nIHRoZSBhcnJheSBpdGVtczsgZm9yIG9iamVjdCBtYXBzLCB0aGlzIGltcGxpZXMgd2F0Y2hpbmdcbiAgICAgICAqIHRoZSBwcm9wZXJ0aWVzKS4gSWYgYSBjaGFuZ2UgaXMgZGV0ZWN0ZWQsIHRoZSBgbGlzdGVuZXJgIGNhbGxiYWNrIGlzIGZpcmVkLlxuICAgICAgICpcbiAgICAgICAqIC0gVGhlIGBvYmpgIGNvbGxlY3Rpb24gaXMgb2JzZXJ2ZWQgdmlhIHN0YW5kYXJkICR3YXRjaCBvcGVyYXRpb24gYW5kIGlzIGV4YW1pbmVkIG9uIGV2ZXJ5XG4gICAgICAgKiAgIGNhbGwgdG8gJGRpZ2VzdCgpIHRvIHNlZSBpZiBhbnkgaXRlbXMgaGF2ZSBiZWVuIGFkZGVkLCByZW1vdmVkLCBvciBtb3ZlZC5cbiAgICAgICAqIC0gVGhlIGBsaXN0ZW5lcmAgaXMgY2FsbGVkIHdoZW5ldmVyIGFueXRoaW5nIHdpdGhpbiB0aGUgYG9iamAgaGFzIGNoYW5nZWQuIEV4YW1wbGVzIGluY2x1ZGVcbiAgICAgICAqICAgYWRkaW5nLCByZW1vdmluZywgYW5kIG1vdmluZyBpdGVtcyBiZWxvbmdpbmcgdG8gYW4gb2JqZWN0IG9yIGFycmF5LlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiAjIEV4YW1wbGVcbiAgICAgICAqIDxwcmU+XG4gICAgICAgICAgJHNjb3BlLm5hbWVzID0gWydpZ29yJywgJ21hdGlhcycsICdtaXNrbycsICdqYW1lcyddO1xuICAgICAgICAgICRzY29wZS5kYXRhQ291bnQgPSA0O1xuXG4gICAgICAgICAgJHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oJ25hbWVzJywgZnVuY3Rpb24obmV3TmFtZXMsIG9sZE5hbWVzKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YUNvdW50ID0gbmV3TmFtZXMubGVuZ3RoO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZXhwZWN0KCRzY29wZS5kYXRhQ291bnQpLnRvRXF1YWwoNCk7XG4gICAgICAgICAgJHNjb3BlLiRkaWdlc3QoKTtcblxuICAgICAgICAgIC8vc3RpbGwgYXQgNCAuLi4gbm8gY2hhbmdlc1xuICAgICAgICAgIGV4cGVjdCgkc2NvcGUuZGF0YUNvdW50KS50b0VxdWFsKDQpO1xuXG4gICAgICAgICAgJHNjb3BlLm5hbWVzLnBvcCgpO1xuICAgICAgICAgICRzY29wZS4kZGlnZXN0KCk7XG5cbiAgICAgICAgICAvL25vdyB0aGVyZSdzIGJlZW4gYSBjaGFuZ2VcbiAgICAgICAgICBleHBlY3QoJHNjb3BlLmRhdGFDb3VudCkudG9FcXVhbCgzKTtcbiAgICAgICAqIDwvcHJlPlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbihzY29wZSl9IG9iaiBFdmFsdWF0ZWQgYXMge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0uIFRoZVxuICAgICAgICogICAgZXhwcmVzc2lvbiB2YWx1ZSBzaG91bGQgZXZhbHVhdGUgdG8gYW4gb2JqZWN0IG9yIGFuIGFycmF5IHdoaWNoIGlzIG9ic2VydmVkIG9uIGVhY2hcbiAgICAgICAqICAgIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGRpZ2VzdCAkZGlnZXN0fSBjeWNsZS4gQW55IHNoYWxsb3cgY2hhbmdlIHdpdGhpbiB0aGVcbiAgICAgICAqICAgIGNvbGxlY3Rpb24gd2lsbCB0cmlnZ2VyIGEgY2FsbCB0byB0aGUgYGxpc3RlbmVyYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ld0NvbGxlY3Rpb24sIG9sZENvbGxlY3Rpb24sIHNjb3BlKX0gbGlzdGVuZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzXG4gICAgICAgKiAgICBmaXJlZCB3aXRoIGJvdGggdGhlIGBuZXdDb2xsZWN0aW9uYCBhbmQgYG9sZENvbGxlY3Rpb25gIGFzIHBhcmFtZXRlcnMuXG4gICAgICAgKiAgICBUaGUgYG5ld0NvbGxlY3Rpb25gIG9iamVjdCBpcyB0aGUgbmV3bHkgbW9kaWZpZWQgZGF0YSBvYnRhaW5lZCBmcm9tIHRoZSBgb2JqYCBleHByZXNzaW9uXG4gICAgICAgKiAgICBhbmQgdGhlIGBvbGRDb2xsZWN0aW9uYCBvYmplY3QgaXMgYSBjb3B5IG9mIHRoZSBmb3JtZXIgY29sbGVjdGlvbiBkYXRhLlxuICAgICAgICogICAgVGhlIGBzY29wZWAgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpfSBSZXR1cm5zIGEgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIGZvciB0aGlzIGxpc3RlbmVyLiBXaGVuIHRoZVxuICAgICAgICogICAgZGUtcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLCB0aGUgaW50ZXJuYWwgd2F0Y2ggb3BlcmF0aW9uIGlzIHRlcm1pbmF0ZWQuXG4gICAgICAgKi9cbiAgICAgICR3YXRjaENvbGxlY3Rpb246IGZ1bmN0aW9uKG9iaiwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb2xkVmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZURldGVjdGVkID0gMDtcbiAgICAgICAgdmFyIG9iakdldHRlciA9ICRwYXJzZShvYmopO1xuICAgICAgICB2YXIgaW50ZXJuYWxBcnJheSA9IFtdO1xuICAgICAgICB2YXIgaW50ZXJuYWxPYmplY3QgPSB7fTtcbiAgICAgICAgdmFyIG9sZExlbmd0aCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gJHdhdGNoQ29sbGVjdGlvbldhdGNoKCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqR2V0dGVyKHNlbGYpO1xuICAgICAgICAgIHZhciBuZXdMZW5ndGgsIGtleTtcblxuICAgICAgICAgIGlmICghaXNPYmplY3QobmV3VmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIGNoYW5nZURldGVjdGVkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gaW50ZXJuYWxBcnJheSkge1xuICAgICAgICAgICAgICAvLyB3ZSBhcmUgdHJhbnNpdGlvbmluZyBmcm9tIHNvbWV0aGluZyB3aGljaCB3YXMgbm90IGFuIGFycmF5IGludG8gYXJyYXkuXG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gaW50ZXJuYWxBcnJheTtcbiAgICAgICAgICAgICAgb2xkTGVuZ3RoID0gb2xkVmFsdWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3TGVuZ3RoID0gbmV3VmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAob2xkTGVuZ3RoICE9PSBuZXdMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gaWYgbGVuZ3RocyBkbyBub3QgbWF0Y2ggd2UgbmVlZCB0byB0cmlnZ2VyIGNoYW5nZSBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcbiAgICAgICAgICAgICAgb2xkVmFsdWUubGVuZ3RoID0gb2xkTGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSB0aGUgaXRlbXMgdG8gb2xkVmFsdWUgYW5kIGxvb2sgZm9yIGNoYW5nZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChvbGRWYWx1ZVtpXSAhPT0gbmV3VmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlW2ldID0gbmV3VmFsdWVbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSBpbnRlcm5hbE9iamVjdCkge1xuICAgICAgICAgICAgICAvLyB3ZSBhcmUgdHJhbnNpdGlvbmluZyBmcm9tIHNvbWV0aGluZyB3aGljaCB3YXMgbm90IGFuIG9iamVjdCBpbnRvIG9iamVjdC5cbiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBpbnRlcm5hbE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICBvbGRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29weSB0aGUgaXRlbXMgdG8gb2xkVmFsdWUgYW5kIGxvb2sgZm9yIGNoYW5nZXMuXG4gICAgICAgICAgICBuZXdMZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBuZXdMZW5ndGgrKztcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlW2tleV0gIT09IG5ld1ZhbHVlW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0ZWQrKztcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWVba2V5XSA9IG5ld1ZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG9sZExlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgb2xkVmFsdWVba2V5XSA9IG5ld1ZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9sZExlbmd0aCA+IG5ld0xlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB3ZSB1c2VkIHRvIGhhdmUgbW9yZSBrZXlzLCBuZWVkIHRvIGZpbmQgdGhlbSBhbmQgZGVzdHJveSB0aGVtLlxuICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCsrO1xuICAgICAgICAgICAgICBmb3Ioa2V5IGluIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlLmhhc093blByb3BlcnR5KGtleSkgJiYgIW5ld1ZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIG9sZExlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG9sZFZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjaGFuZ2VEZXRlY3RlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uICR3YXRjaENvbGxlY3Rpb25BY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIobmV3VmFsdWUsIG9sZFZhbHVlLCBzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiR3YXRjaCgkd2F0Y2hDb2xsZWN0aW9uV2F0Y2gsICR3YXRjaENvbGxlY3Rpb25BY3Rpb24pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGRpZ2VzdFxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogUHJvY2Vzc2VzIGFsbCBvZiB0aGUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kd2F0Y2ggd2F0Y2hlcnN9IG9mIHRoZSBjdXJyZW50IHNjb3BlIGFuZFxuICAgICAgICogaXRzIGNoaWxkcmVuLiBCZWNhdXNlIGEge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kd2F0Y2ggd2F0Y2hlcn0ncyBsaXN0ZW5lciBjYW4gY2hhbmdlXG4gICAgICAgKiB0aGUgbW9kZWwsIHRoZSBgJGRpZ2VzdCgpYCBrZWVwcyBjYWxsaW5nIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyR3YXRjaCB3YXRjaGVyc31cbiAgICAgICAqIHVudGlsIG5vIG1vcmUgbGlzdGVuZXJzIGFyZSBmaXJpbmcuIFRoaXMgbWVhbnMgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgICAgICogbG9vcC4gVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGAnTWF4aW11bSBpdGVyYXRpb24gbGltaXQgZXhjZWVkZWQuJ2AgaWYgdGhlIG51bWJlciBvZlxuICAgICAgICogaXRlcmF0aW9ucyBleGNlZWRzIDEwLlxuICAgICAgICpcbiAgICAgICAqIFVzdWFsbHksIHlvdSBkb24ndCBjYWxsIGAkZGlnZXN0KClgIGRpcmVjdGx5IGluXG4gICAgICAgKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ29udHJvbGxlciBjb250cm9sbGVyc30gb3IgaW5cbiAgICAgICAqIHtAbGluayBuZy4kY29tcGlsZVByb3ZpZGVyI21ldGhvZHNfZGlyZWN0aXZlIGRpcmVjdGl2ZXN9LlxuICAgICAgICogSW5zdGVhZCwgeW91IHNob3VsZCBjYWxsIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJGFwcGx5ICRhcHBseSgpfSAodHlwaWNhbGx5IGZyb20gd2l0aGluXG4gICAgICAgKiBhIHtAbGluayBuZy4kY29tcGlsZVByb3ZpZGVyI21ldGhvZHNfZGlyZWN0aXZlIGRpcmVjdGl2ZXN9KSwgd2hpY2ggd2lsbCBmb3JjZSBhIGAkZGlnZXN0KClgLlxuICAgICAgICpcbiAgICAgICAqIElmIHlvdSB3YW50IHRvIGJlIG5vdGlmaWVkIHdoZW5ldmVyIGAkZGlnZXN0KClgIGlzIGNhbGxlZCxcbiAgICAgICAqIHlvdSBjYW4gcmVnaXN0ZXIgYSBgd2F0Y2hFeHByZXNzaW9uYCBmdW5jdGlvbiB3aXRoXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyR3YXRjaCAkd2F0Y2goKX0gd2l0aCBubyBgbGlzdGVuZXJgLlxuICAgICAgICpcbiAgICAgICAqIEluIHVuaXQgdGVzdHMsIHlvdSBtYXkgbmVlZCB0byBjYWxsIGAkZGlnZXN0KClgIHRvIHNpbXVsYXRlIHRoZSBzY29wZSBsaWZlIGN5Y2xlLlxuICAgICAgICpcbiAgICAgICAqICMgRXhhbXBsZVxuICAgICAgICogPHByZT5cbiAgICAgICAgICAgdmFyIHNjb3BlID0gLi4uO1xuICAgICAgICAgICBzY29wZS5uYW1lID0gJ21pc2tvJztcbiAgICAgICAgICAgc2NvcGUuY291bnRlciA9IDA7XG5cbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMCk7XG4gICAgICAgICAgIHNjb3BlLiR3YXRjaCgnbmFtZScsIGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgIHNjb3BlLmNvdW50ZXIgPSBzY29wZS5jb3VudGVyICsgMTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xuXG4gICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICAgLy8gbm8gdmFyaWFibGUgY2hhbmdlXG4gICAgICAgICAgIGV4cGVjdChzY29wZS5jb3VudGVyKS50b0VxdWFsKDApO1xuXG4gICAgICAgICAgIHNjb3BlLm5hbWUgPSAnYWRhbSc7XG4gICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICAgZXhwZWN0KHNjb3BlLmNvdW50ZXIpLnRvRXF1YWwoMSk7XG4gICAgICAgKiA8L3ByZT5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgICRkaWdlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2F0Y2gsIHZhbHVlLCBsYXN0LFxuICAgICAgICAgICAgd2F0Y2hlcnMsXG4gICAgICAgICAgICBhc3luY1F1ZXVlID0gdGhpcy4kJGFzeW5jUXVldWUsXG4gICAgICAgICAgICBwb3N0RGlnZXN0UXVldWUgPSB0aGlzLiQkcG9zdERpZ2VzdFF1ZXVlLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgZGlydHksIHR0bCA9IFRUTCxcbiAgICAgICAgICAgIG5leHQsIGN1cnJlbnQsIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICB3YXRjaExvZyA9IFtdLFxuICAgICAgICAgICAgbG9nSWR4LCBsb2dNc2csIGFzeW5jVGFzaztcblxuICAgICAgICBiZWdpblBoYXNlKCckZGlnZXN0Jyk7XG5cbiAgICAgICAgbGFzdERpcnR5V2F0Y2ggPSBudWxsO1xuXG4gICAgICAgIGRvIHsgLy8gXCJ3aGlsZSBkaXJ0eVwiIGxvb3BcbiAgICAgICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgIGN1cnJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgICAgICB3aGlsZShhc3luY1F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXN5bmNUYXNrID0gYXN5bmNRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICBhc3luY1Rhc2suc2NvcGUuJGV2YWwoYXN5bmNUYXNrLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjbGVhclBoYXNlKCk7XG4gICAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdERpcnR5V2F0Y2ggPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyYXZlcnNlU2NvcGVzTG9vcDpcbiAgICAgICAgICBkbyB7IC8vIFwidHJhdmVyc2UgdGhlIHNjb3Blc1wiIGxvb3BcbiAgICAgICAgICAgIGlmICgod2F0Y2hlcnMgPSBjdXJyZW50LiQkd2F0Y2hlcnMpKSB7XG4gICAgICAgICAgICAgIC8vIHByb2Nlc3Mgb3VyIHdhdGNoZXNcbiAgICAgICAgICAgICAgbGVuZ3RoID0gd2F0Y2hlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgd2F0Y2ggPSB3YXRjaGVyc1tsZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgLy8gTW9zdCBjb21tb24gd2F0Y2hlcyBhcmUgb24gcHJpbWl0aXZlcywgaW4gd2hpY2ggY2FzZSB3ZSBjYW4gc2hvcnRcbiAgICAgICAgICAgICAgICAgIC8vIGNpcmN1aXQgaXQgd2l0aCA9PT0gb3BlcmF0b3IsIG9ubHkgd2hlbiA9PT0gZmFpbHMgZG8gd2UgdXNlIC5lcXVhbHNcbiAgICAgICAgICAgICAgICAgIGlmICh3YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gd2F0Y2guZ2V0KGN1cnJlbnQpKSAhPT0gKGxhc3QgPSB3YXRjaC5sYXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgISh3YXRjaC5lcVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXF1YWxzKHZhbHVlLCBsYXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFzdCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGlzTmFOKHZhbHVlKSAmJiBpc05hTihsYXN0KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIGxhc3REaXJ0eVdhdGNoID0gd2F0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgd2F0Y2gubGFzdCA9IHdhdGNoLmVxID8gY29weSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB3YXRjaC5mbih2YWx1ZSwgKChsYXN0ID09PSBpbml0V2F0Y2hWYWwpID8gdmFsdWUgOiBsYXN0KSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHR0bCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0lkeCA9IDQgLSB0dGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhdGNoTG9nW2xvZ0lkeF0pIHdhdGNoTG9nW2xvZ0lkeF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ01zZyA9IChpc0Z1bmN0aW9uKHdhdGNoLmV4cCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnZm46ICcgKyAod2F0Y2guZXhwLm5hbWUgfHwgd2F0Y2guZXhwLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB3YXRjaC5leHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dNc2cgKz0gJzsgbmV3VmFsOiAnICsgdG9Kc29uKHZhbHVlKSArICc7IG9sZFZhbDogJyArIHRvSnNvbihsYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoTG9nW2xvZ0lkeF0ucHVzaChsb2dNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YXRjaCA9PT0gbGFzdERpcnR5V2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbW9zdCByZWNlbnRseSBkaXJ0eSB3YXRjaGVyIGlzIG5vdyBjbGVhbiwgc2hvcnQgY2lyY3VpdCBzaW5jZSB0aGUgcmVtYWluaW5nIHdhdGNoZXJzXG4gICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSBhbHJlYWR5IGJlZW4gdGVzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgdHJhdmVyc2VTY29wZXNMb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJQaGFzZSgpO1xuICAgICAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2FuaXR5IFdhcm5pbmc6IHNjb3BlIGRlcHRoLWZpcnN0IHRyYXZlcnNhbFxuICAgICAgICAgICAgLy8geWVzLCB0aGlzIGNvZGUgaXMgYSBiaXQgY3JhenksIGJ1dCBpdCB3b3JrcyBhbmQgd2UgaGF2ZSB0ZXN0cyB0byBwcm92ZSBpdCFcbiAgICAgICAgICAgIC8vIHRoaXMgcGllY2Ugc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0cmF2ZXJzYWwgaW4gJGJyb2FkY2FzdFxuICAgICAgICAgICAgaWYgKCEobmV4dCA9IChjdXJyZW50LiQkY2hpbGRIZWFkIHx8XG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgIT09IHRhcmdldCAmJiBjdXJyZW50LiQkbmV4dFNpYmxpbmcpKSkpIHtcbiAgICAgICAgICAgICAgd2hpbGUoY3VycmVudCAhPT0gdGFyZ2V0ICYmICEobmV4dCA9IGN1cnJlbnQuJCRuZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC4kcGFyZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoKGN1cnJlbnQgPSBuZXh0KSk7XG5cbiAgICAgICAgICAvLyBgYnJlYWsgdHJhdmVyc2VTY29wZXNMb29wO2AgdGFrZXMgdXMgdG8gaGVyZVxuXG4gICAgICAgICAgaWYoZGlydHkgJiYgISh0dGwtLSkpIHtcbiAgICAgICAgICAgIGNsZWFyUGhhc2UoKTtcbiAgICAgICAgICAgIHRocm93ICRyb290U2NvcGVNaW5FcnIoJ2luZmRpZycsXG4gICAgICAgICAgICAgICAgJ3swfSAkZGlnZXN0KCkgaXRlcmF0aW9ucyByZWFjaGVkLiBBYm9ydGluZyFcXG4nICtcbiAgICAgICAgICAgICAgICAnV2F0Y2hlcnMgZmlyZWQgaW4gdGhlIGxhc3QgNSBpdGVyYXRpb25zOiB7MX0nLFxuICAgICAgICAgICAgICAgIFRUTCwgdG9Kc29uKHdhdGNoTG9nKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gd2hpbGUgKGRpcnR5IHx8IGFzeW5jUXVldWUubGVuZ3RoKTtcblxuICAgICAgICBjbGVhclBoYXNlKCk7XG5cbiAgICAgICAgd2hpbGUocG9zdERpZ2VzdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwb3N0RGlnZXN0UXVldWUuc2hpZnQoKSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkZGVzdHJveVxuICAgICAgICogQGV2ZW50T2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGV2ZW50VHlwZSBicm9hZGNhc3Qgb24gc2NvcGUgYmVpbmcgZGVzdHJveWVkXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBCcm9hZGNhc3RlZCB3aGVuIGEgc2NvcGUgYW5kIGl0cyBjaGlsZHJlbiBhcmUgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCwgaW4gQW5ndWxhckpTLCB0aGVyZSBpcyBhbHNvIGEgYCRkZXN0cm95YCBqUXVlcnkgZXZlbnQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgKiBjbGVhbiB1cCBET00gYmluZGluZ3MgYmVmb3JlIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGRlc3Ryb3lcbiAgICAgICAqIEBtZXRob2RPZiBuZy4kcm9vdFNjb3BlLlNjb3BlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAqIFJlbW92ZXMgdGhlIGN1cnJlbnQgc2NvcGUgKGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuKSBmcm9tIHRoZSBwYXJlbnQgc2NvcGUuIFJlbW92YWwgaW1wbGllc1xuICAgICAgICogdGhhdCBjYWxscyB0byB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRkaWdlc3QgJGRpZ2VzdCgpfSB3aWxsIG5vIGxvbmdlclxuICAgICAgICogcHJvcGFnYXRlIHRvIHRoZSBjdXJyZW50IHNjb3BlIGFuZCBpdHMgY2hpbGRyZW4uIFJlbW92YWwgYWxzbyBpbXBsaWVzIHRoYXQgdGhlIGN1cnJlbnRcbiAgICAgICAqIHNjb3BlIGlzIGVsaWdpYmxlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogVGhlIGAkZGVzdHJveSgpYCBpcyB1c3VhbGx5IHVzZWQgYnkgZGlyZWN0aXZlcyBzdWNoIGFzXG4gICAgICAgKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IG5nUmVwZWF0fSBmb3IgbWFuYWdpbmcgdGhlXG4gICAgICAgKiB1bnJvbGxpbmcgb2YgdGhlIGxvb3AuXG4gICAgICAgKlxuICAgICAgICogSnVzdCBiZWZvcmUgYSBzY29wZSBpcyBkZXN0cm95ZWQsIGEgYCRkZXN0cm95YCBldmVudCBpcyBicm9hZGNhc3RlZCBvbiB0aGlzIHNjb3BlLlxuICAgICAgICogQXBwbGljYXRpb24gY29kZSBjYW4gcmVnaXN0ZXIgYSBgJGRlc3Ryb3lgIGV2ZW50IGhhbmRsZXIgdGhhdCB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG9cbiAgICAgICAqIHBlcmZvcm0gYW55IG5lY2Vzc2FyeSBjbGVhbnVwLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCwgaW4gQW5ndWxhckpTLCB0aGVyZSBpcyBhbHNvIGEgYCRkZXN0cm95YCBqUXVlcnkgZXZlbnQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgKiBjbGVhbiB1cCBET00gYmluZGluZ3MgYmVmb3JlIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00uXG4gICAgICAgKi9cbiAgICAgICRkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gd2UgY2FuJ3QgZGVzdHJveSB0aGUgcm9vdCBzY29wZSBvciBhIHNjb3BlIHRoYXQgaGFzIGJlZW4gYWxyZWFkeSBkZXN0cm95ZWRcbiAgICAgICAgaWYgKHRoaXMuJCRkZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcblxuICAgICAgICB0aGlzLiRicm9hZGNhc3QoJyRkZXN0cm95Jyk7XG4gICAgICAgIHRoaXMuJCRkZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcyA9PT0gJHJvb3RTY29wZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChwYXJlbnQuJCRjaGlsZEhlYWQgPT0gdGhpcykgcGFyZW50LiQkY2hpbGRIZWFkID0gdGhpcy4kJG5leHRTaWJsaW5nO1xuICAgICAgICBpZiAocGFyZW50LiQkY2hpbGRUYWlsID09IHRoaXMpIHBhcmVudC4kJGNoaWxkVGFpbCA9IHRoaXMuJCRwcmV2U2libGluZztcbiAgICAgICAgaWYgKHRoaXMuJCRwcmV2U2libGluZykgdGhpcy4kJHByZXZTaWJsaW5nLiQkbmV4dFNpYmxpbmcgPSB0aGlzLiQkbmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICh0aGlzLiQkbmV4dFNpYmxpbmcpIHRoaXMuJCRuZXh0U2libGluZy4kJHByZXZTaWJsaW5nID0gdGhpcy4kJHByZXZTaWJsaW5nO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgYm9ndXMgY29kZSB0aGF0IHdvcmtzIGFyb3VuZCBDaHJvbWUncyBHQyBsZWFrXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvMTMxMyNpc3N1ZWNvbW1lbnQtMTAzNzg0NTFcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy4kJG5leHRTaWJsaW5nID0gdGhpcy4kJHByZXZTaWJsaW5nID0gdGhpcy4kJGNoaWxkSGVhZCA9XG4gICAgICAgICAgICB0aGlzLiQkY2hpbGRUYWlsID0gbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRldmFsXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBFeGVjdXRlcyB0aGUgYGV4cHJlc3Npb25gIG9uIHRoZSBjdXJyZW50IHNjb3BlIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuIEFueSBleGNlcHRpb25zIGluXG4gICAgICAgKiB0aGUgZXhwcmVzc2lvbiBhcmUgcHJvcGFnYXRlZCAodW5jYXVnaHQpLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGV2YWx1YXRpbmcgQW5ndWxhclxuICAgICAgICogZXhwcmVzc2lvbnMuXG4gICAgICAgKlxuICAgICAgICogIyBFeGFtcGxlXG4gICAgICAgKiA8cHJlPlxuICAgICAgICAgICB2YXIgc2NvcGUgPSBuZy4kcm9vdFNjb3BlLlNjb3BlKCk7XG4gICAgICAgICAgIHNjb3BlLmEgPSAxO1xuICAgICAgICAgICBzY29wZS5iID0gMjtcblxuICAgICAgICAgICBleHBlY3Qoc2NvcGUuJGV2YWwoJ2ErYicpKS50b0VxdWFsKDMpO1xuICAgICAgICAgICBleHBlY3Qoc2NvcGUuJGV2YWwoZnVuY3Rpb24oc2NvcGUpeyByZXR1cm4gc2NvcGUuYSArIHNjb3BlLmI7IH0pKS50b0VxdWFsKDMpO1xuICAgICAgICogPC9wcmU+XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKCkpPX0gZXhwcmVzc2lvbiBBbiBhbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICAgKlxuICAgICAgICogICAgLSBgc3RyaW5nYDogZXhlY3V0ZSB1c2luZyB0aGUgcnVsZXMgYXMgZGVmaW5lZCBpbiAge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0uXG4gICAgICAgKiAgICAtIGBmdW5jdGlvbihzY29wZSlgOiBleGVjdXRlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBjdXJyZW50IGBzY29wZWAgcGFyYW1ldGVyLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KG9iamVjdCk9fSBsb2NhbHMgTG9jYWwgdmFyaWFibGVzIG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpbiBzY29wZS5cbiAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIGV4cHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgICRldmFsOiBmdW5jdGlvbihleHByLCBsb2NhbHMpIHtcbiAgICAgICAgcmV0dXJuICRwYXJzZShleHByKSh0aGlzLCBsb2NhbHMpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJGV2YWxBc3luY1xuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogRXhlY3V0ZXMgdGhlIGV4cHJlc3Npb24gb24gdGhlIGN1cnJlbnQgc2NvcGUgYXQgYSBsYXRlciBwb2ludCBpbiB0aW1lLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBgJGV2YWxBc3luY2AgbWFrZXMgbm8gZ3VhcmFudGVlcyBhcyB0byB3aGVuIHRoZSBgZXhwcmVzc2lvbmAgd2lsbCBiZSBleGVjdXRlZCwgb25seVxuICAgICAgICogdGhhdDpcbiAgICAgICAqXG4gICAgICAgKiAgIC0gaXQgd2lsbCBleGVjdXRlIGFmdGVyIHRoZSBmdW5jdGlvbiB0aGF0IHNjaGVkdWxlZCB0aGUgZXZhbHVhdGlvbiAocHJlZmVyYWJseSBiZWZvcmUgRE9NXG4gICAgICAgKiAgICAgcmVuZGVyaW5nKS5cbiAgICAgICAqICAgLSBhdCBsZWFzdCBvbmUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kZGlnZXN0ICRkaWdlc3QgY3ljbGV9IHdpbGwgYmUgcGVyZm9ybWVkIGFmdGVyXG4gICAgICAgKiAgICAgYGV4cHJlc3Npb25gIGV4ZWN1dGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBBbnkgZXhjZXB0aW9ucyBmcm9tIHRoZSBleGVjdXRpb24gb2YgdGhlIGV4cHJlc3Npb24gYXJlIGZvcndhcmRlZCB0byB0aGVcbiAgICAgICAqIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cbiAgICAgICAqXG4gICAgICAgKiBfX05vdGU6X18gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGAkZGlnZXN0YCBjeWNsZSwgYSBuZXcgYCRkaWdlc3RgIGN5Y2xlXG4gICAgICAgKiB3aWxsIGJlIHNjaGVkdWxlZC4gSG93ZXZlciwgaXQgaXMgZW5jb3VyYWdlZCB0byBhbHdheXMgY2FsbCBjb2RlIHRoYXQgY2hhbmdlcyB0aGUgbW9kZWxcbiAgICAgICAqIGZyb20gd2l0aGluIGFuIGAkYXBwbHlgIGNhbGwuIFRoYXQgaW5jbHVkZXMgY29kZSBldmFsdWF0ZWQgdmlhIGAkZXZhbEFzeW5jYC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8ZnVuY3Rpb24oKSk9fSBleHByZXNzaW9uIEFuIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZC5cbiAgICAgICAqXG4gICAgICAgKiAgICAtIGBzdHJpbmdgOiBleGVjdXRlIHVzaW5nIHRoZSBydWxlcyBhcyBkZWZpbmVkIGluIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259LlxuICAgICAgICogICAgLSBgZnVuY3Rpb24oc2NvcGUpYDogZXhlY3V0ZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgY3VycmVudCBgc2NvcGVgIHBhcmFtZXRlci5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgICRldmFsQXN5bmM6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG91dHNpZGUgb2YgYW4gJGRpZ2VzdCBsb29wIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlIGFyZSBzY2hlZHVsaW5nIGFzeW5jXG4gICAgICAgIC8vIHRhc2sgYWxzbyBzY2hlZHVsZSBhc3luYyBhdXRvLWZsdXNoXG4gICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlICYmICEkcm9vdFNjb3BlLiQkYXN5bmNRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAkYnJvd3Nlci5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiQkYXN5bmNRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiQkYXN5bmNRdWV1ZS5wdXNoKHtzY29wZTogdGhpcywgZXhwcmVzc2lvbjogZXhwcn0pO1xuICAgICAgfSxcblxuICAgICAgJCRwb3N0RGlnZXN0IDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdGhpcy4kJHBvc3REaWdlc3RRdWV1ZS5wdXNoKGZuKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAgKiBAbmFtZSBuZy4kcm9vdFNjb3BlLlNjb3BlIyRhcHBseVxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogYCRhcHBseSgpYCBpcyB1c2VkIHRvIGV4ZWN1dGUgYW4gZXhwcmVzc2lvbiBpbiBhbmd1bGFyIGZyb20gb3V0c2lkZSBvZiB0aGUgYW5ndWxhclxuICAgICAgICogZnJhbWV3b3JrLiAoRm9yIGV4YW1wbGUgZnJvbSBicm93c2VyIERPTSBldmVudHMsIHNldFRpbWVvdXQsIFhIUiBvciB0aGlyZCBwYXJ0eSBsaWJyYXJpZXMpLlxuICAgICAgICogQmVjYXVzZSB3ZSBhcmUgY2FsbGluZyBpbnRvIHRoZSBhbmd1bGFyIGZyYW1ld29yayB3ZSBuZWVkIHRvIHBlcmZvcm0gcHJvcGVyIHNjb3BlIGxpZmVcbiAgICAgICAqIGN5Y2xlIG9mIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciBleGNlcHRpb24gaGFuZGxpbmd9LFxuICAgICAgICoge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kZGlnZXN0IGV4ZWN1dGluZyB3YXRjaGVzfS5cbiAgICAgICAqXG4gICAgICAgKiAjIyBMaWZlIGN5Y2xlXG4gICAgICAgKlxuICAgICAgICogIyBQc2V1ZG8tQ29kZSBvZiBgJGFwcGx5KClgXG4gICAgICAgKiA8cHJlPlxuICAgICAgICAgICBmdW5jdGlvbiAkYXBwbHkoZXhwcikge1xuICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICByZXR1cm4gJGV2YWwoZXhwcik7XG4gICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICRyb290LiRkaWdlc3QoKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAqIDwvcHJlPlxuICAgICAgICpcbiAgICAgICAqXG4gICAgICAgKiBTY29wZSdzIGAkYXBwbHkoKWAgbWV0aG9kIHRyYW5zaXRpb25zIHRocm91Z2ggdGhlIGZvbGxvd2luZyBzdGFnZXM6XG4gICAgICAgKlxuICAgICAgICogMS4gVGhlIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGlzIGV4ZWN1dGVkIHVzaW5nIHRoZVxuICAgICAgICogICAge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kZXZhbCAkZXZhbCgpfSBtZXRob2QuXG4gICAgICAgKiAyLiBBbnkgZXhjZXB0aW9ucyBmcm9tIHRoZSBleGVjdXRpb24gb2YgdGhlIGV4cHJlc3Npb24gYXJlIGZvcndhcmRlZCB0byB0aGVcbiAgICAgICAqICAgIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cbiAgICAgICAqIDMuIFRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyR3YXRjaCB3YXRjaH0gbGlzdGVuZXJzIGFyZSBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAgICAgICAqICAgIGV4cHJlc3Npb24gd2FzIGV4ZWN1dGVkIHVzaW5nIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRkaWdlc3QgJGRpZ2VzdCgpfSBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xmdW5jdGlvbigpKT19IGV4cCBBbiBhbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQuXG4gICAgICAgKlxuICAgICAgICogICAgLSBgc3RyaW5nYDogZXhlY3V0ZSB1c2luZyB0aGUgcnVsZXMgYXMgZGVmaW5lZCBpbiB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufS5cbiAgICAgICAqICAgIC0gYGZ1bmN0aW9uKHNjb3BlKWA6IGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIHdpdGggY3VycmVudCBgc2NvcGVgIHBhcmFtZXRlci5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBleHByZXNzaW9uLlxuICAgICAgICovXG4gICAgICAkYXBwbHk6IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiZWdpblBoYXNlKCckYXBwbHknKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kZXZhbChleHByKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGNsZWFyUGhhc2UoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgJGV4Y2VwdGlvbkhhbmRsZXIoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICAqIEBuYW1lIG5nLiRyb290U2NvcGUuU2NvcGUjJG9uXG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBMaXN0ZW5zIG9uIGV2ZW50cyBvZiBhIGdpdmVuIHR5cGUuIFNlZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRlbWl0ICRlbWl0fSBmb3JcbiAgICAgICAqIGRpc2N1c3Npb24gb2YgZXZlbnQgbGlmZSBjeWNsZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb24gZm9ybWF0IGlzOiBgZnVuY3Rpb24oZXZlbnQsIGFyZ3MuLi4pYC4gVGhlIGBldmVudGAgb2JqZWN0XG4gICAgICAgKiBwYXNzZWQgaW50byB0aGUgbGlzdGVuZXIgaGFzIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICAgICAqXG4gICAgICAgKiAgIC0gYHRhcmdldFNjb3BlYCAtIGB7U2NvcGV9YDogdGhlIHNjb3BlIG9uIHdoaWNoIHRoZSBldmVudCB3YXMgYCRlbWl0YC1lZCBvclxuICAgICAgICogICAgIGAkYnJvYWRjYXN0YC1lZC5cbiAgICAgICAqICAgLSBgY3VycmVudFNjb3BlYCAtIGB7U2NvcGV9YDogdGhlIGN1cnJlbnQgc2NvcGUgd2hpY2ggaXMgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICogICAtIGBuYW1lYCAtIGB7c3RyaW5nfWA6IG5hbWUgb2YgdGhlIGV2ZW50LlxuICAgICAgICogICAtIGBzdG9wUHJvcGFnYXRpb25gIC0gYHtmdW5jdGlvbj19YDogY2FsbGluZyBgc3RvcFByb3BhZ2F0aW9uYCBmdW5jdGlvbiB3aWxsIGNhbmNlbFxuICAgICAgICogICAgIGZ1cnRoZXIgZXZlbnQgcHJvcGFnYXRpb24gKGF2YWlsYWJsZSBvbmx5IGZvciBldmVudHMgdGhhdCB3ZXJlIGAkZW1pdGAtZWQpLlxuICAgICAgICogICAtIGBwcmV2ZW50RGVmYXVsdGAgLSBge2Z1bmN0aW9ufWA6IGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBzZXRzIGBkZWZhdWx0UHJldmVudGVkYCBmbGFnXG4gICAgICAgKiAgICAgdG8gdHJ1ZS5cbiAgICAgICAqICAgLSBgZGVmYXVsdFByZXZlbnRlZGAgLSBge2Jvb2xlYW59YDogdHJ1ZSBpZiBgcHJldmVudERlZmF1bHRgIHdhcyBjYWxsZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZSB0byBsaXN0ZW4gb24uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGV2ZW50LCBhcmdzLi4uKX0gbGlzdGVuZXIgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKCl9IFJldHVybnMgYSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBmb3IgdGhpcyBsaXN0ZW5lci5cbiAgICAgICAqL1xuICAgICAgJG9uOiBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbmFtZWRMaXN0ZW5lcnMgPSB0aGlzLiQkbGlzdGVuZXJzW25hbWVdO1xuICAgICAgICBpZiAoIW5hbWVkTGlzdGVuZXJzKSB7XG4gICAgICAgICAgdGhpcy4kJGxpc3RlbmVyc1tuYW1lXSA9IG5hbWVkTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbmFtZWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5hbWVkTGlzdGVuZXJzW2luZGV4T2YobmFtZWRMaXN0ZW5lcnMsIGxpc3RlbmVyKV0gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkZW1pdFxuICAgICAgICogQG1ldGhvZE9mIG5nLiRyb290U2NvcGUuU2NvcGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICpcbiAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBgbmFtZWAgdXB3YXJkcyB0aHJvdWdoIHRoZSBzY29wZSBoaWVyYXJjaHkgbm90aWZ5aW5nIHRoZVxuICAgICAgICogcmVnaXN0ZXJlZCB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRvbn0gbGlzdGVuZXJzLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBldmVudCBsaWZlIGN5Y2xlIHN0YXJ0cyBhdCB0aGUgc2NvcGUgb24gd2hpY2ggYCRlbWl0YCB3YXMgY2FsbGVkLiBBbGxcbiAgICAgICAqIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJG9uIGxpc3RlbmVyc30gbGlzdGVuaW5nIGZvciBgbmFtZWAgZXZlbnQgb24gdGhpcyBzY29wZSBnZXRcbiAgICAgICAqIG5vdGlmaWVkLiBBZnRlcndhcmRzLCB0aGUgZXZlbnQgdHJhdmVyc2VzIHVwd2FyZHMgdG93YXJkIHRoZSByb290IHNjb3BlIGFuZCBjYWxscyBhbGxcbiAgICAgICAqIHJlZ2lzdGVyZWQgbGlzdGVuZXJzIGFsb25nIHRoZSB3YXkuIFRoZSBldmVudCB3aWxsIHN0b3AgcHJvcGFnYXRpbmcgaWYgb25lIG9mIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAqIGNhbmNlbHMgaXQuXG4gICAgICAgKlxuICAgICAgICogQW55IGV4Y2VwdGlvbiBlbWl0dGVkIGZyb20gdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJG9uIGxpc3RlbmVyc30gd2lsbCBiZSBwYXNzZWRcbiAgICAgICAqIG9udG8gdGhlIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lIHRvIGVtaXQuXG4gICAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgT3B0aW9uYWwgc2V0IG9mIGFyZ3VtZW50cyB3aGljaCB3aWxsIGJlIHBhc3NlZCBvbnRvIHRoZSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEV2ZW50IG9iamVjdCAoc2VlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJG9ufSkuXG4gICAgICAgKi9cbiAgICAgICRlbWl0OiBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IFtdLFxuICAgICAgICAgICAgbmFtZWRMaXN0ZW5lcnMsXG4gICAgICAgICAgICBzY29wZSA9IHRoaXMsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb24gPSBmYWxzZSxcbiAgICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB0YXJnZXRTY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7c3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTt9LFxuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdGVuZXJBcmdzID0gY29uY2F0KFtldmVudF0sIGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBpLCBsZW5ndGg7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5hbWVkTGlzdGVuZXJzID0gc2NvcGUuJCRsaXN0ZW5lcnNbbmFtZV0gfHwgZW1wdHk7XG4gICAgICAgICAgZXZlbnQuY3VycmVudFNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgZm9yIChpPTAsIGxlbmd0aD1uYW1lZExpc3RlbmVycy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgLy8gaWYgbGlzdGVuZXJzIHdlcmUgZGVyZWdpc3RlcmVkLCBkZWZyYWdtZW50IHRoZSBhcnJheVxuICAgICAgICAgICAgaWYgKCFuYW1lZExpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICBuYW1lZExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy9hbGxvdyBhbGwgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IHNjb3BlIHRvIHJ1blxuICAgICAgICAgICAgICBuYW1lZExpc3RlbmVyc1tpXS5hcHBseShudWxsLCBsaXN0ZW5lckFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy9pZiBhbnkgbGlzdGVuZXIgb24gdGhlIGN1cnJlbnQgc2NvcGUgc3RvcHMgcHJvcGFnYXRpb24sIHByZXZlbnQgYnViYmxpbmdcbiAgICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKSByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgLy90cmF2ZXJzZSB1cHdhcmRzXG4gICAgICAgICAgc2NvcGUgPSBzY29wZS4kcGFyZW50O1xuICAgICAgICB9IHdoaWxlIChzY29wZSk7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfSxcblxuXG4gICAgICAvKipcbiAgICAgICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgICAgICogQG5hbWUgbmcuJHJvb3RTY29wZS5TY29wZSMkYnJvYWRjYXN0XG4gICAgICAgKiBAbWV0aG9kT2YgbmcuJHJvb3RTY29wZS5TY29wZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKlxuICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGBuYW1lYCBkb3dud2FyZHMgdG8gYWxsIGNoaWxkIHNjb3BlcyAoYW5kIHRoZWlyIGNoaWxkcmVuKSBub3RpZnlpbmcgdGhlXG4gICAgICAgKiByZWdpc3RlcmVkIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJG9ufSBsaXN0ZW5lcnMuXG4gICAgICAgKlxuICAgICAgICogVGhlIGV2ZW50IGxpZmUgY3ljbGUgc3RhcnRzIGF0IHRoZSBzY29wZSBvbiB3aGljaCBgJGJyb2FkY2FzdGAgd2FzIGNhbGxlZC4gQWxsXG4gICAgICAgKiB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRvbiBsaXN0ZW5lcnN9IGxpc3RlbmluZyBmb3IgYG5hbWVgIGV2ZW50IG9uIHRoaXMgc2NvcGUgZ2V0XG4gICAgICAgKiBub3RpZmllZC4gQWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHByb3BhZ2F0ZXMgdG8gYWxsIGRpcmVjdCBhbmQgaW5kaXJlY3Qgc2NvcGVzIG9mIHRoZSBjdXJyZW50XG4gICAgICAgKiBzY29wZSBhbmQgY2FsbHMgYWxsIHJlZ2lzdGVyZWQgbGlzdGVuZXJzIGFsb25nIHRoZSB3YXkuIFRoZSBldmVudCBjYW5ub3QgYmUgY2FuY2VsZWQuXG4gICAgICAgKlxuICAgICAgICogQW55IGV4Y2VwdGlvbiBlbWl0dGVkIGZyb20gdGhlIHtAbGluayBuZy4kcm9vdFNjb3BlLlNjb3BlI21ldGhvZHNfJG9uIGxpc3RlbmVyc30gd2lsbCBiZSBwYXNzZWRcbiAgICAgICAqIG9udG8gdGhlIHtAbGluayBuZy4kZXhjZXB0aW9uSGFuZGxlciAkZXhjZXB0aW9uSGFuZGxlcn0gc2VydmljZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lIHRvIGJyb2FkY2FzdC5cbiAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBPcHRpb25hbCBzZXQgb2YgYXJndW1lbnRzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIG9udG8gdGhlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAqIEByZXR1cm4ge09iamVjdH0gRXZlbnQgb2JqZWN0LCBzZWUge0BsaW5rIG5nLiRyb290U2NvcGUuU2NvcGUjbWV0aG9kc18kb259XG4gICAgICAgKi9cbiAgICAgICRicm9hZGNhc3Q6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50ID0gdGFyZ2V0LFxuICAgICAgICAgICAgbmV4dCA9IHRhcmdldCxcbiAgICAgICAgICAgIGV2ZW50ID0ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB0YXJnZXRTY29wZTogdGFyZ2V0LFxuICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdGVuZXJBcmdzID0gY29uY2F0KFtldmVudF0sIGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBsaXN0ZW5lcnMsIGksIGxlbmd0aDtcblxuICAgICAgICAvL2Rvd24gd2hpbGUgeW91IGNhbiwgdGhlbiB1cCBhbmQgbmV4dCBzaWJsaW5nIG9yIHVwIGFuZCBuZXh0IHNpYmxpbmcgdW50aWwgYmFjayBhdCByb290XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICBldmVudC5jdXJyZW50U2NvcGUgPSBjdXJyZW50O1xuICAgICAgICAgIGxpc3RlbmVycyA9IGN1cnJlbnQuJCRsaXN0ZW5lcnNbbmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChpPTAsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGlmIGxpc3RlbmVycyB3ZXJlIGRlcmVnaXN0ZXJlZCwgZGVmcmFnbWVudCB0aGUgYXJyYXlcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgbGlzdGVuZXJBcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJbnNhbml0eSBXYXJuaW5nOiBzY29wZSBkZXB0aC1maXJzdCB0cmF2ZXJzYWxcbiAgICAgICAgICAvLyB5ZXMsIHRoaXMgY29kZSBpcyBhIGJpdCBjcmF6eSwgYnV0IGl0IHdvcmtzIGFuZCB3ZSBoYXZlIHRlc3RzIHRvIHByb3ZlIGl0IVxuICAgICAgICAgIC8vIHRoaXMgcGllY2Ugc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0cmF2ZXJzYWwgaW4gJGRpZ2VzdFxuICAgICAgICAgIGlmICghKG5leHQgPSAoY3VycmVudC4kJGNoaWxkSGVhZCB8fCAoY3VycmVudCAhPT0gdGFyZ2V0ICYmIGN1cnJlbnQuJCRuZXh0U2libGluZykpKSkge1xuICAgICAgICAgICAgd2hpbGUoY3VycmVudCAhPT0gdGFyZ2V0ICYmICEobmV4dCA9IGN1cnJlbnQuJCRuZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuJHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKChjdXJyZW50ID0gbmV4dCkpO1xuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyICRyb290U2NvcGUgPSBuZXcgU2NvcGUoKTtcblxuICAgIHJldHVybiAkcm9vdFNjb3BlO1xuXG5cbiAgICBmdW5jdGlvbiBiZWdpblBoYXNlKHBoYXNlKSB7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgIHRocm93ICRyb290U2NvcGVNaW5FcnIoJ2lucHJvZycsICd7MH0gYWxyZWFkeSBpbiBwcm9ncmVzcycsICRyb290U2NvcGUuJCRwaGFzZSk7XG4gICAgICB9XG5cbiAgICAgICRyb290U2NvcGUuJCRwaGFzZSA9IHBoYXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyUGhhc2UoKSB7XG4gICAgICAkcm9vdFNjb3BlLiQkcGhhc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBpbGVUb0ZuKGV4cCwgbmFtZSkge1xuICAgICAgdmFyIGZuID0gJHBhcnNlKGV4cCk7XG4gICAgICBhc3NlcnRBcmdGbihmbiwgbmFtZSk7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdXNlZCBhcyBhbiBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycy5cbiAgICAgKiBiZWNhdXNlIGl0J3MgdW5pcXVlIHdlIGNhbiBlYXNpbHkgdGVsbCBpdCBhcGFydCBmcm9tIG90aGVyIHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRXYXRjaFZhbCgpIHt9XG4gIH1dO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJpdmF0ZSBzZXJ2aWNlIHRvIHNhbml0aXplIHVyaXMgZm9yIGxpbmtzIGFuZCBpbWFnZXMuIFVzZWQgYnkgJGNvbXBpbGUgYW5kICRzYW5pdGl6ZS5cbiAqL1xuZnVuY3Rpb24gJCRTYW5pdGl6ZVVyaVByb3ZpZGVyKCkge1xuICB2YXIgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QgPSAvXlxccyooaHR0cHM/fGZ0cHxtYWlsdG98dGVsfGZpbGUpOi8sXG4gICAgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gL15cXHMqKGh0dHBzP3xmdHB8ZmlsZSk6fGRhdGE6aW1hZ2VcXC8vO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0cmlldmVzIG9yIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBpcyB1c2VkIGZvciB3aGl0ZWxpc3Rpbmcgb2Ygc2FmZVxuICAgKiB1cmxzIGR1cmluZyBhW2hyZWZdIHNhbml0aXphdGlvbi5cbiAgICpcbiAgICogVGhlIHNhbml0aXphdGlvbiBpcyBhIHNlY3VyaXR5IG1lYXN1cmUgYWltZWQgYXQgcHJldmVudCBYU1MgYXR0YWNrcyB2aWEgaHRtbCBsaW5rcy5cbiAgICpcbiAgICogQW55IHVybCBhYm91dCB0byBiZSBhc3NpZ25lZCB0byBhW2hyZWZdIHZpYSBkYXRhLWJpbmRpbmcgaXMgZmlyc3Qgbm9ybWFsaXplZCBhbmQgdHVybmVkIGludG9cbiAgICogYW4gYWJzb2x1dGUgdXJsLiBBZnRlcndhcmRzLCB0aGUgdXJsIGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgYGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0YFxuICAgKiByZWd1bGFyIGV4cHJlc3Npb24uIElmIGEgbWF0Y2ggaXMgZm91bmQsIHRoZSBvcmlnaW5hbCB1cmwgaXMgd3JpdHRlbiBpbnRvIHRoZSBkb20uIE90aGVyd2lzZSxcbiAgICogdGhlIGFic29sdXRlIHVybCBpcyBwcmVmaXhlZCB3aXRoIGAndW5zYWZlOidgIHN0cmluZyBhbmQgb25seSB0aGVuIGlzIGl0IHdyaXR0ZW4gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cD19IHJlZ2V4cCBOZXcgcmVnZXhwIHRvIHdoaXRlbGlzdCB1cmxzIHdpdGguXG4gICAqIEByZXR1cm5zIHtSZWdFeHB8bmcuJGNvbXBpbGVQcm92aWRlcn0gQ3VycmVudCBSZWdFeHAgaWYgY2FsbGVkIHdpdGhvdXQgdmFsdWUgb3Igc2VsZiBmb3JcbiAgICogICAgY2hhaW5pbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgdGhpcy5hSHJlZlNhbml0aXphdGlvbldoaXRlbGlzdCA9IGZ1bmN0aW9uKHJlZ2V4cCkge1xuICAgIGlmIChpc0RlZmluZWQocmVnZXhwKSkge1xuICAgICAgYUhyZWZTYW5pdGl6YXRpb25XaGl0ZWxpc3QgPSByZWdleHA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgb3Igb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgZm9yIHdoaXRlbGlzdGluZyBvZiBzYWZlXG4gICAqIHVybHMgZHVyaW5nIGltZ1tzcmNdIHNhbml0aXphdGlvbi5cbiAgICpcbiAgICogVGhlIHNhbml0aXphdGlvbiBpcyBhIHNlY3VyaXR5IG1lYXN1cmUgYWltZWQgYXQgcHJldmVudCBYU1MgYXR0YWNrcyB2aWEgaHRtbCBsaW5rcy5cbiAgICpcbiAgICogQW55IHVybCBhYm91dCB0byBiZSBhc3NpZ25lZCB0byBpbWdbc3JjXSB2aWEgZGF0YS1iaW5kaW5nIGlzIGZpcnN0IG5vcm1hbGl6ZWQgYW5kIHR1cm5lZCBpbnRvXG4gICAqIGFuIGFic29sdXRlIHVybC4gQWZ0ZXJ3YXJkcywgdGhlIHVybCBpcyBtYXRjaGVkIGFnYWluc3QgdGhlIGBpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3RgXG4gICAqIHJlZ3VsYXIgZXhwcmVzc2lvbi4gSWYgYSBtYXRjaCBpcyBmb3VuZCwgdGhlIG9yaWdpbmFsIHVybCBpcyB3cml0dGVuIGludG8gdGhlIGRvbS4gT3RoZXJ3aXNlLFxuICAgKiB0aGUgYWJzb2x1dGUgdXJsIGlzIHByZWZpeGVkIHdpdGggYCd1bnNhZmU6J2Agc3RyaW5nIGFuZCBvbmx5IHRoZW4gaXMgaXQgd3JpdHRlbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwPX0gcmVnZXhwIE5ldyByZWdleHAgdG8gd2hpdGVsaXN0IHVybHMgd2l0aC5cbiAgICogQHJldHVybnMge1JlZ0V4cHxuZy4kY29tcGlsZVByb3ZpZGVyfSBDdXJyZW50IFJlZ0V4cCBpZiBjYWxsZWQgd2l0aG91dCB2YWx1ZSBvciBzZWxmIGZvclxuICAgKiAgICBjaGFpbmluZyBvdGhlcndpc2UuXG4gICAqL1xuICB0aGlzLmltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCA9IGZ1bmN0aW9uKHJlZ2V4cCkge1xuICAgIGlmIChpc0RlZmluZWQocmVnZXhwKSkge1xuICAgICAgaW1nU3JjU2FuaXRpemF0aW9uV2hpdGVsaXN0ID0gcmVnZXhwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpbWdTcmNTYW5pdGl6YXRpb25XaGl0ZWxpc3Q7XG4gIH07XG5cbiAgdGhpcy4kZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNhbml0aXplVXJpKHVyaSwgaXNJbWFnZSkge1xuICAgICAgdmFyIHJlZ2V4ID0gaXNJbWFnZSA/IGltZ1NyY1Nhbml0aXphdGlvbldoaXRlbGlzdCA6IGFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0O1xuICAgICAgdmFyIG5vcm1hbGl6ZWRWYWw7XG4gICAgICAvLyBOT1RFOiB1cmxSZXNvbHZlKCkgZG9lc24ndCBzdXBwb3J0IElFIDwgOCBzbyB3ZSBkb24ndCBzYW5pdGl6ZSBmb3IgdGhhdCBjYXNlLlxuICAgICAgaWYgKCFtc2llIHx8IG1zaWUgPj0gOCApIHtcbiAgICAgICAgbm9ybWFsaXplZFZhbCA9IHVybFJlc29sdmUodXJpKS5ocmVmO1xuICAgICAgICBpZiAobm9ybWFsaXplZFZhbCAhPT0gJycgJiYgIW5vcm1hbGl6ZWRWYWwubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgcmV0dXJuICd1bnNhZmU6Jytub3JtYWxpemVkVmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJpO1xuICAgIH07XG4gIH07XG59XG5cbnZhciAkc2NlTWluRXJyID0gbWluRXJyKCckc2NlJyk7XG5cbnZhciBTQ0VfQ09OVEVYVFMgPSB7XG4gIEhUTUw6ICdodG1sJyxcbiAgQ1NTOiAnY3NzJyxcbiAgVVJMOiAndXJsJyxcbiAgLy8gUkVTT1VSQ0VfVVJMIGlzIGEgc3VidHlwZSBvZiBVUkwgdXNlZCBpbiBjb250ZXh0cyB3aGVyZSBhIHByaXZpbGVnZWQgcmVzb3VyY2UgaXMgc291cmNlZCBmcm9tIGFcbiAgLy8gdXJsLiAgKGUuZy4gbmctaW5jbHVkZSwgc2NyaXB0IHNyYywgdGVtcGxhdGVVcmwpXG4gIFJFU09VUkNFX1VSTDogJ3Jlc291cmNlVXJsJyxcbiAgSlM6ICdqcydcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnMgZm9sbG93LlxuXG4vLyBDb3BpZWQgZnJvbTpcbi8vIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX3N0cmluZ19zdHJpbmcuanMuc291cmNlLmh0bWwjbGluZTk2MlxuLy8gUHJlcmVxOiBzIGlzIGEgc3RyaW5nLlxuZnVuY3Rpb24gZXNjYXBlRm9yUmVnZXhwKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKS5cbiAgICAgICAgICAgcmVwbGFjZSgvXFx4MDgvZywgJ1xcXFx4MDgnKTtcbn1cblxuXG5mdW5jdGlvbiBhZGp1c3RNYXRjaGVyKG1hdGNoZXIpIHtcbiAgaWYgKG1hdGNoZXIgPT09ICdzZWxmJykge1xuICAgIHJldHVybiBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKG1hdGNoZXIpKSB7XG4gICAgLy8gU3RyaW5ncyBtYXRjaCBleGFjdGx5IGV4Y2VwdCBmb3IgMiB3aWxkY2FyZHMgLSAnKicgYW5kICcqKicuXG4gICAgLy8gJyonIG1hdGNoZXMgYW55IGNoYXJhY3RlciBleGNlcHQgdGhvc2UgZnJvbSB0aGUgc2V0ICc6Ly4/JicuXG4gICAgLy8gJyoqJyBtYXRjaGVzIGFueSBjaGFyYWN0ZXIgKGxpa2UgLiogaW4gYSBSZWdFeHApLlxuICAgIC8vIE1vcmUgdGhhbiAyIConcyByYWlzZXMgYW4gZXJyb3IgYXMgaXQncyBpbGwgZGVmaW5lZC5cbiAgICBpZiAobWF0Y2hlci5pbmRleE9mKCcqKionKSA+IC0xKSB7XG4gICAgICB0aHJvdyAkc2NlTWluRXJyKCdpd2NhcmQnLFxuICAgICAgICAgICdJbGxlZ2FsIHNlcXVlbmNlICoqKiBpbiBzdHJpbmcgbWF0Y2hlci4gIFN0cmluZzogezB9JywgbWF0Y2hlcik7XG4gICAgfVxuICAgIG1hdGNoZXIgPSBlc2NhcGVGb3JSZWdleHAobWF0Y2hlcikuXG4gICAgICAgICAgICAgICAgICByZXBsYWNlKCdcXFxcKlxcXFwqJywgJy4qJykuXG4gICAgICAgICAgICAgICAgICByZXBsYWNlKCdcXFxcKicsICdbXjovLj8mO10qJyk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgbWF0Y2hlciArICckJyk7XG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAobWF0Y2hlcikpIHtcbiAgICAvLyBUaGUgb25seSBvdGhlciB0eXBlIG9mIG1hdGNoZXIgYWxsb3dlZCBpcyBhIFJlZ2V4cC5cbiAgICAvLyBNYXRjaCBlbnRpcmUgVVJMIC8gZGlzYWxsb3cgcGFydGlhbCBtYXRjaGVzLlxuICAgIC8vIEZsYWdzIGFyZSByZXNldCAoaS5lLiBubyBnbG9iYWwsIGlnbm9yZUNhc2Ugb3IgbXVsdGlsaW5lKVxuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIG1hdGNoZXIuc291cmNlICsgJyQnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAkc2NlTWluRXJyKCdpbWF0Y2hlcicsXG4gICAgICAgICdNYXRjaGVycyBtYXkgb25seSBiZSBcInNlbGZcIiwgc3RyaW5nIHBhdHRlcm5zIG9yIFJlZ0V4cCBvYmplY3RzJyk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBhZGp1c3RNYXRjaGVycyhtYXRjaGVycykge1xuICB2YXIgYWRqdXN0ZWRNYXRjaGVycyA9IFtdO1xuICBpZiAoaXNEZWZpbmVkKG1hdGNoZXJzKSkge1xuICAgIGZvckVhY2gobWF0Y2hlcnMsIGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgIGFkanVzdGVkTWF0Y2hlcnMucHVzaChhZGp1c3RNYXRjaGVyKG1hdGNoZXIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWRqdXN0ZWRNYXRjaGVycztcbn1cblxuXG4vKipcbiAqIEBuZ2RvYyBzZXJ2aWNlXG4gKiBAbmFtZSBuZy4kc2NlRGVsZWdhdGVcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIGAkc2NlRGVsZWdhdGVgIGlzIGEgc2VydmljZSB0aGF0IGlzIHVzZWQgYnkgdGhlIGAkc2NlYCBzZXJ2aWNlIHRvIHByb3ZpZGUge0BsaW5rIG5nLiRzY2UgU3RyaWN0XG4gKiBDb250ZXh0dWFsIEVzY2FwaW5nIChTQ0UpfSBzZXJ2aWNlcyB0byBBbmd1bGFySlMuXG4gKlxuICogVHlwaWNhbGx5LCB5b3Ugd291bGQgY29uZmlndXJlIG9yIG92ZXJyaWRlIHRoZSB7QGxpbmsgbmcuJHNjZURlbGVnYXRlICRzY2VEZWxlZ2F0ZX0gaW5zdGVhZCBvZlxuICogdGhlIGAkc2NlYCBzZXJ2aWNlIHRvIGN1c3RvbWl6ZSB0aGUgd2F5IFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIHdvcmtzIGluIEFuZ3VsYXJKUy4gIFRoaXMgaXNcbiAqIGJlY2F1c2UsIHdoaWxlIHRoZSBgJHNjZWAgcHJvdmlkZXMgbnVtZXJvdXMgc2hvcnRoYW5kIG1ldGhvZHMsIGV0Yy4sIHlvdSByZWFsbHkgb25seSBuZWVkIHRvXG4gKiBvdmVycmlkZSAzIGNvcmUgZnVuY3Rpb25zIChgdHJ1c3RBc2AsIGBnZXRUcnVzdGVkYCBhbmQgYHZhbHVlT2ZgKSB0byByZXBsYWNlIHRoZSB3YXkgdGhpbmdzXG4gKiB3b3JrIGJlY2F1c2UgYCRzY2VgIGRlbGVnYXRlcyB0byBgJHNjZURlbGVnYXRlYCBmb3IgdGhlc2Ugb3BlcmF0aW9ucy5cbiAqXG4gKiBSZWZlciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIgJHNjZURlbGVnYXRlUHJvdmlkZXJ9IHRvIGNvbmZpZ3VyZSB0aGlzIHNlcnZpY2UuXG4gKlxuICogVGhlIGRlZmF1bHQgaW5zdGFuY2Ugb2YgYCRzY2VEZWxlZ2F0ZWAgc2hvdWxkIHdvcmsgb3V0IG9mIHRoZSBib3ggd2l0aCBsaXR0bGUgcGFpbi4gIFdoaWxlIHlvdVxuICogY2FuIG92ZXJyaWRlIGl0IGNvbXBsZXRlbHkgdG8gY2hhbmdlIHRoZSBiZWhhdmlvciBvZiBgJHNjZWAsIHRoZSBjb21tb24gY2FzZSB3b3VsZFxuICogaW52b2x2ZSBjb25maWd1cmluZyB0aGUge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyICRzY2VEZWxlZ2F0ZVByb3ZpZGVyfSBpbnN0ZWFkIGJ5IHNldHRpbmdcbiAqIHlvdXIgb3duIHdoaXRlbGlzdHMgYW5kIGJsYWNrbGlzdHMgZm9yIHRydXN0aW5nIFVSTHMgdXNlZCBmb3IgbG9hZGluZyBBbmd1bGFySlMgcmVzb3VyY2VzIHN1Y2ggYXNcbiAqIHRlbXBsYXRlcy4gIFJlZmVyIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNtZXRob2RzX3Jlc291cmNlVXJsV2hpdGVsaXN0XG4gKiAkc2NlRGVsZWdhdGVQcm92aWRlci5yZXNvdXJjZVVybFdoaXRlbGlzdH0gYW5kIHtAbGlua1xuICogbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjbWV0aG9kc19yZXNvdXJjZVVybEJsYWNrbGlzdCAkc2NlRGVsZWdhdGVQcm92aWRlci5yZXNvdXJjZVVybEJsYWNrbGlzdH1cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGUgYCRzY2VEZWxlZ2F0ZVByb3ZpZGVyYCBwcm92aWRlciBhbGxvd3MgZGV2ZWxvcGVycyB0byBjb25maWd1cmUgdGhlIHtAbGluayBuZy4kc2NlRGVsZWdhdGVcbiAqICRzY2VEZWxlZ2F0ZX0gc2VydmljZS4gIFRoaXMgYWxsb3dzIG9uZSB0byBnZXQvc2V0IHRoZSB3aGl0ZWxpc3RzIGFuZCBibGFja2xpc3RzIHVzZWQgdG8gZW5zdXJlXG4gKiB0aGF0IHRoZSBVUkxzIHVzZWQgZm9yIHNvdXJjaW5nIEFuZ3VsYXIgdGVtcGxhdGVzIGFyZSBzYWZlLiAgUmVmZXIge0BsaW5rXG4gKiBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNtZXRob2RzX3Jlc291cmNlVXJsV2hpdGVsaXN0ICRzY2VEZWxlZ2F0ZVByb3ZpZGVyLnJlc291cmNlVXJsV2hpdGVsaXN0fSBhbmRcbiAqIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNtZXRob2RzX3Jlc291cmNlVXJsQmxhY2tsaXN0ICRzY2VEZWxlZ2F0ZVByb3ZpZGVyLnJlc291cmNlVXJsQmxhY2tsaXN0fVxuICpcbiAqIEZvciB0aGUgZ2VuZXJhbCBkZXRhaWxzIGFib3V0IHRoaXMgc2VydmljZSBpbiBBbmd1bGFyLCByZWFkIHRoZSBtYWluIHBhZ2UgZm9yIHtAbGluayBuZy4kc2NlXG4gKiBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyAoU0NFKX0uXG4gKlxuICogKipFeGFtcGxlKio6ICBDb25zaWRlciB0aGUgZm9sbG93aW5nIGNhc2UuIDxhIG5hbWU9XCJleGFtcGxlXCI+PC9hPlxuICpcbiAqIC0geW91ciBhcHAgaXMgaG9zdGVkIGF0IHVybCBgaHR0cDovL215YXBwLmV4YW1wbGUuY29tL2BcbiAqIC0gYnV0IHNvbWUgb2YgeW91ciB0ZW1wbGF0ZXMgYXJlIGhvc3RlZCBvbiBvdGhlciBkb21haW5zIHlvdSBjb250cm9sIHN1Y2ggYXNcbiAqICAgYGh0dHA6Ly9zcnYwMS5hc3NldHMuZXhhbXBsZS5jb20vYCzCoCBgaHR0cDovL3NydjAyLmFzc2V0cy5leGFtcGxlLmNvbS9gLCBldGMuXG4gKiAtIGFuZCB5b3UgaGF2ZSBhbiBvcGVuIHJlZGlyZWN0IGF0IGBodHRwOi8vbXlhcHAuZXhhbXBsZS5jb20vY2xpY2tUaHJ1Py4uLmAuXG4gKlxuICogSGVyZSBpcyB3aGF0IGEgc2VjdXJlIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc2NlbmFyaW8gbWlnaHQgbG9vayBsaWtlOlxuICpcbiAqIDxwcmUgY2xhc3M9XCJwcmV0dHlwcmludFwiPlxuICogICAgYW5ndWxhci5tb2R1bGUoJ215QXBwJywgW10pLmNvbmZpZyhmdW5jdGlvbigkc2NlRGVsZWdhdGVQcm92aWRlcikge1xuICogICAgICAkc2NlRGVsZWdhdGVQcm92aWRlci5yZXNvdXJjZVVybFdoaXRlbGlzdChbXG4gKiAgICAgICAgLy8gQWxsb3cgc2FtZSBvcmlnaW4gcmVzb3VyY2UgbG9hZHMuXG4gKiAgICAgICAgJ3NlbGYnLFxuICogICAgICAgIC8vIEFsbG93IGxvYWRpbmcgZnJvbSBvdXIgYXNzZXRzIGRvbWFpbi4gIE5vdGljZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuICogYW5kICoqLlxuICogICAgICAgICdodHRwOi8vc3J2Ki5hc3NldHMuZXhhbXBsZS5jb20vKionXSk7XG4gKlxuICogICAgICAvLyBUaGUgYmxhY2tsaXN0IG92ZXJyaWRlcyB0aGUgd2hpdGVsaXN0IHNvIHRoZSBvcGVuIHJlZGlyZWN0IGhlcmUgaXMgYmxvY2tlZC5cbiAqICAgICAgJHNjZURlbGVnYXRlUHJvdmlkZXIucmVzb3VyY2VVcmxCbGFja2xpc3QoW1xuICogICAgICAgICdodHRwOi8vbXlhcHAuZXhhbXBsZS5jb20vY2xpY2tUaHJ1KionXSk7XG4gKiAgICAgIH0pO1xuICogPC9wcmU+XG4gKi9cblxuZnVuY3Rpb24gJFNjZURlbGVnYXRlUHJvdmlkZXIoKSB7XG4gIHRoaXMuU0NFX0NPTlRFWFRTID0gU0NFX0NPTlRFWFRTO1xuXG4gIC8vIFJlc291cmNlIFVSTHMgY2FuIGFsc28gYmUgdHJ1c3RlZCBieSBwb2xpY3kuXG4gIHZhciByZXNvdXJjZVVybFdoaXRlbGlzdCA9IFsnc2VsZiddLFxuICAgICAgcmVzb3VyY2VVcmxCbGFja2xpc3QgPSBbXTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLnNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxXaGl0ZWxpc3RcbiAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyXG4gICAqIEBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PX0gd2hpdGVsaXN0IFdoZW4gcHJvdmlkZWQsIHJlcGxhY2VzIHRoZSByZXNvdXJjZVVybFdoaXRlbGlzdCB3aXRoIHRoZSB2YWx1ZVxuICAgKiAgICAgcHJvdmlkZWQuICBUaGlzIG11c3QgYmUgYW4gYXJyYXkgb3IgbnVsbC4gIEEgc25hcHNob3Qgb2YgdGhpcyBhcnJheSBpcyB1c2VkIHNvIGZ1cnRoZXJcbiAgICogICAgIGNoYW5nZXMgdG8gdGhlIGFycmF5IGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgRm9sbG93IHtAbGluayBuZy4kc2NlI3Jlc291cmNlVXJsUGF0dGVybkl0ZW0gdGhpcyBsaW5rfSBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaXRlbXNcbiAgICogICAgIGFsbG93ZWQgaW4gdGhpcyBhcnJheS5cbiAgICpcbiAgICogICAgIE5vdGU6ICoqYW4gZW1wdHkgd2hpdGVsaXN0IGFycmF5IHdpbGwgYmxvY2sgYWxsIFVSTHMqKiFcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IHRoZSBjdXJyZW50bHkgc2V0IHdoaXRlbGlzdCBhcnJheS5cbiAgICpcbiAgICogVGhlICoqZGVmYXVsdCB2YWx1ZSoqIHdoZW4gbm8gd2hpdGVsaXN0IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0IGlzIGBbJ3NlbGYnXWAgYWxsb3dpbmcgb25seVxuICAgKiBzYW1lIG9yaWdpbiByZXNvdXJjZSByZXF1ZXN0cy5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldHMvR2V0cyB0aGUgd2hpdGVsaXN0IG9mIHRydXN0ZWQgcmVzb3VyY2UgVVJMcy5cbiAgICovXG4gIHRoaXMucmVzb3VyY2VVcmxXaGl0ZWxpc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmVzb3VyY2VVcmxXaGl0ZWxpc3QgPSBhZGp1c3RNYXRjaGVycyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZVVybFdoaXRlbGlzdDtcbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLnNjZURlbGVnYXRlUHJvdmlkZXIjcmVzb3VyY2VVcmxCbGFja2xpc3RcbiAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyXG4gICAqIEBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PX0gYmxhY2tsaXN0IFdoZW4gcHJvdmlkZWQsIHJlcGxhY2VzIHRoZSByZXNvdXJjZVVybEJsYWNrbGlzdCB3aXRoIHRoZSB2YWx1ZVxuICAgKiAgICAgcHJvdmlkZWQuICBUaGlzIG11c3QgYmUgYW4gYXJyYXkgb3IgbnVsbC4gIEEgc25hcHNob3Qgb2YgdGhpcyBhcnJheSBpcyB1c2VkIHNvIGZ1cnRoZXJcbiAgICogICAgIGNoYW5nZXMgdG8gdGhlIGFycmF5IGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgRm9sbG93IHtAbGluayBuZy4kc2NlI3Jlc291cmNlVXJsUGF0dGVybkl0ZW0gdGhpcyBsaW5rfSBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaXRlbXNcbiAgICogICAgIGFsbG93ZWQgaW4gdGhpcyBhcnJheS5cbiAgICpcbiAgICogICAgIFRoZSB0eXBpY2FsIHVzYWdlIGZvciB0aGUgYmxhY2tsaXN0IGlzIHRvICoqYmxvY2tcbiAgICogICAgIFtvcGVuIHJlZGlyZWN0c10oaHR0cDovL2N3ZS5taXRyZS5vcmcvZGF0YS9kZWZpbml0aW9ucy82MDEuaHRtbCkqKiBzZXJ2ZWQgYnkgeW91ciBkb21haW4gYXNcbiAgICogICAgIHRoZXNlIHdvdWxkIG90aGVyd2lzZSBiZSB0cnVzdGVkIGJ1dCBhY3R1YWxseSByZXR1cm4gY29udGVudCBmcm9tIHRoZSByZWRpcmVjdGVkIGRvbWFpbi5cbiAgICpcbiAgICogICAgIEZpbmFsbHksICoqdGhlIGJsYWNrbGlzdCBvdmVycmlkZXMgdGhlIHdoaXRlbGlzdCoqIGFuZCBoYXMgdGhlIGZpbmFsIHNheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IHRoZSBjdXJyZW50bHkgc2V0IGJsYWNrbGlzdCBhcnJheS5cbiAgICpcbiAgICogVGhlICoqZGVmYXVsdCB2YWx1ZSoqIHdoZW4gbm8gd2hpdGVsaXN0IGhhcyBiZWVuIGV4cGxpY2l0bHkgc2V0IGlzIHRoZSBlbXB0eSBhcnJheSAoaS5lLiB0aGVyZVxuICAgKiBpcyBubyBibGFja2xpc3QuKVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU2V0cy9HZXRzIHRoZSBibGFja2xpc3Qgb2YgdHJ1c3RlZCByZXNvdXJjZSBVUkxzLlxuICAgKi9cblxuICB0aGlzLnJlc291cmNlVXJsQmxhY2tsaXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJlc291cmNlVXJsQmxhY2tsaXN0ID0gYWRqdXN0TWF0Y2hlcnModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VVcmxCbGFja2xpc3Q7XG4gIH07XG5cbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCBmdW5jdGlvbigkaW5qZWN0b3IpIHtcblxuICAgIHZhciBodG1sU2FuaXRpemVyID0gZnVuY3Rpb24gaHRtbFNhbml0aXplcihodG1sKSB7XG4gICAgICB0aHJvdyAkc2NlTWluRXJyKCd1bnNhZmUnLCAnQXR0ZW1wdGluZyB0byB1c2UgYW4gdW5zYWZlIHZhbHVlIGluIGEgc2FmZSBjb250ZXh0LicpO1xuICAgIH07XG5cbiAgICBpZiAoJGluamVjdG9yLmhhcygnJHNhbml0aXplJykpIHtcbiAgICAgIGh0bWxTYW5pdGl6ZXIgPSAkaW5qZWN0b3IuZ2V0KCckc2FuaXRpemUnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1hdGNoVXJsKG1hdGNoZXIsIHBhcnNlZFVybCkge1xuICAgICAgaWYgKG1hdGNoZXIgPT09ICdzZWxmJykge1xuICAgICAgICByZXR1cm4gdXJsSXNTYW1lT3JpZ2luKHBhcnNlZFVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZpbml0ZWx5IGEgcmVnZXguICBTZWUgYWRqdXN0TWF0Y2hlcnMoKVxuICAgICAgICByZXR1cm4gISFtYXRjaGVyLmV4ZWMocGFyc2VkVXJsLmhyZWYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzb3VyY2VVcmxBbGxvd2VkQnlQb2xpY3kodXJsKSB7XG4gICAgICB2YXIgcGFyc2VkVXJsID0gdXJsUmVzb2x2ZSh1cmwudG9TdHJpbmcoKSk7XG4gICAgICB2YXIgaSwgbiwgYWxsb3dlZCA9IGZhbHNlO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYXQgbGVhc3Qgb25lIGl0ZW0gZnJvbSB0aGUgd2hpdGVsaXN0IGFsbG93cyB0aGlzIHVybC5cbiAgICAgIGZvciAoaSA9IDAsIG4gPSByZXNvdXJjZVVybFdoaXRlbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKG1hdGNoVXJsKHJlc291cmNlVXJsV2hpdGVsaXN0W2ldLCBwYXJzZWRVcmwpKSB7XG4gICAgICAgICAgYWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIGl0ZW0gZnJvbSB0aGUgYmxhY2tsaXN0IGJsb2NrZWQgdGhpcyB1cmwuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSByZXNvdXJjZVVybEJsYWNrbGlzdC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWF0Y2hVcmwocmVzb3VyY2VVcmxCbGFja2xpc3RbaV0sIHBhcnNlZFVybCkpIHtcbiAgICAgICAgICAgIGFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbG93ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVIb2xkZXJUeXBlKEJhc2UpIHtcbiAgICAgIHZhciBob2xkZXJUeXBlID0gZnVuY3Rpb24gVHJ1c3RlZFZhbHVlSG9sZGVyVHlwZSh0cnVzdGVkVmFsdWUpIHtcbiAgICAgICAgdGhpcy4kJHVud3JhcFRydXN0ZWRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0cnVzdGVkVmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgaWYgKEJhc2UpIHtcbiAgICAgICAgaG9sZGVyVHlwZS5wcm90b3R5cGUgPSBuZXcgQmFzZSgpO1xuICAgICAgfVxuICAgICAgaG9sZGVyVHlwZS5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uIHNjZVZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiQkdW53cmFwVHJ1c3RlZFZhbHVlKCk7XG4gICAgICB9O1xuICAgICAgaG9sZGVyVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBzY2VUb1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCR1bndyYXBUcnVzdGVkVmFsdWUoKS50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBob2xkZXJUeXBlO1xuICAgIH1cblxuICAgIHZhciB0cnVzdGVkVmFsdWVIb2xkZXJCYXNlID0gZ2VuZXJhdGVIb2xkZXJUeXBlKCksXG4gICAgICAgIGJ5VHlwZSA9IHt9O1xuXG4gICAgYnlUeXBlW1NDRV9DT05URVhUUy5IVE1MXSA9IGdlbmVyYXRlSG9sZGVyVHlwZSh0cnVzdGVkVmFsdWVIb2xkZXJCYXNlKTtcbiAgICBieVR5cGVbU0NFX0NPTlRFWFRTLkNTU10gPSBnZW5lcmF0ZUhvbGRlclR5cGUodHJ1c3RlZFZhbHVlSG9sZGVyQmFzZSk7XG4gICAgYnlUeXBlW1NDRV9DT05URVhUUy5VUkxdID0gZ2VuZXJhdGVIb2xkZXJUeXBlKHRydXN0ZWRWYWx1ZUhvbGRlckJhc2UpO1xuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuSlNdID0gZ2VuZXJhdGVIb2xkZXJUeXBlKHRydXN0ZWRWYWx1ZUhvbGRlckJhc2UpO1xuICAgIGJ5VHlwZVtTQ0VfQ09OVEVYVFMuUkVTT1VSQ0VfVVJMXSA9IGdlbmVyYXRlSG9sZGVyVHlwZShieVR5cGVbU0NFX0NPTlRFWFRTLlVSTF0pO1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2VEZWxlZ2F0ZSN0cnVzdEFzXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBpcyB0cnVzdGVkIGJ5IGFuZ3VsYXIgZm9yIHVzZSBpbiBzcGVjaWZpZWQgc3RyaWN0XG4gICAgICogY29udGV4dHVhbCBlc2NhcGluZyBjb250ZXh0cyAoc3VjaCBhcyBuZy1odG1sLWJpbmQtdW5zYWZlLCBuZy1pbmNsdWRlLCBhbnkgc3JjXG4gICAgICogYXR0cmlidXRlIGludGVycG9sYXRpb24sIGFueSBkb20gZXZlbnQgYmluZGluZyBhdHRyaWJ1dGUgaW50ZXJwb2xhdGlvblxuICAgICAqIHN1Y2ggYXMgZm9yIG9uY2xpY2ssICBldGMuKSB0aGF0IHVzZXMgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqIFNlZSB7QGxpbmsgbmcuJHNjZSAkc2NlfSBmb3IgZW5hYmxpbmcgc3RyaWN0IGNvbnRleHR1YWwgZXNjYXBpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUga2luZCBvZiBjb250ZXh0IGluIHdoaWNoIHRoaXMgdmFsdWUgaXMgc2FmZSBmb3IgdXNlLiAgZS5nLiB1cmwsXG4gICAgICogICByZXNvdXJjZVVybCwgaHRtbCwganMgYW5kIGNzcy5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdHJ1c3RlZC9zYWZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBBIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RhbmQgaW4gZm9yIHRoZSBwcm92aWRlZCBgdmFsdWVgIGluIHBsYWNlc1xuICAgICAqIHdoZXJlIEFuZ3VsYXIgZXhwZWN0cyBhICRzY2UudHJ1c3RBcygpIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVzdEFzKHR5cGUsIHRydXN0ZWRWYWx1ZSkge1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gKGJ5VHlwZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IGJ5VHlwZVt0eXBlXSA6IG51bGwpO1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyAkc2NlTWluRXJyKCdpY29udGV4dCcsXG4gICAgICAgICAgICAnQXR0ZW1wdGVkIHRvIHRydXN0IGEgdmFsdWUgaW4gaW52YWxpZCBjb250ZXh0LiBDb250ZXh0OiB7MH07IFZhbHVlOiB7MX0nLFxuICAgICAgICAgICAgdHlwZSwgdHJ1c3RlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cnVzdGVkVmFsdWUgPT09IG51bGwgfHwgdHJ1c3RlZFZhbHVlID09PSB1bmRlZmluZWQgfHwgdHJ1c3RlZFZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gQWxsIHRoZSBjdXJyZW50IGNvbnRleHRzIGluIFNDRV9DT05URVhUUyBoYXBwZW4gdG8gYmUgc3RyaW5ncy4gIEluIG9yZGVyIHRvIGF2b2lkIHRydXN0aW5nXG4gICAgICAvLyBtdXRhYmxlIG9iamVjdHMsIHdlIGVuc3VyZSBoZXJlIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbiBpcyBhY3R1YWxseSBhIHN0cmluZy5cbiAgICAgIGlmICh0eXBlb2YgdHJ1c3RlZFZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyAkc2NlTWluRXJyKCdpdHlwZScsXG4gICAgICAgICAgICAnQXR0ZW1wdGVkIHRvIHRydXN0IGEgbm9uLXN0cmluZyB2YWx1ZSBpbiBhIGNvbnRlbnQgcmVxdWlyaW5nIGEgc3RyaW5nOiBDb250ZXh0OiB7MH0nLFxuICAgICAgICAgICAgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRydXN0ZWRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2VEZWxlZ2F0ZSN2YWx1ZU9mXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VEZWxlZ2F0ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogSWYgdGhlIHBhc3NlZCBwYXJhbWV0ZXIgaGFkIGJlZW4gcmV0dXJuZWQgYnkgYSBwcmlvciBjYWxsIHRvIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjbWV0aG9kc190cnVzdEFzXG4gICAgICogYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0sIHJldHVybnMgdGhlIHZhbHVlIHRoYXQgaGFkIGJlZW4gcGFzc2VkIHRvIHtAbGlua1xuICAgICAqIG5nLiRzY2VEZWxlZ2F0ZSNtZXRob2RzX3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcGFzc2VkIHBhcmFtZXRlciBpcyBub3QgYSB2YWx1ZSB0aGF0IGhhZCBiZWVuIHJldHVybmVkIGJ5IHtAbGlua1xuICAgICAqIG5nLiRzY2VEZWxlZ2F0ZSNtZXRob2RzX3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0sIHJldHVybnMgaXQgYXMtaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSByZXN1bHQgb2YgYSBwcmlvciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXNgfVxuICAgICAqICAgICAgY2FsbCBvciBhbnl0aGluZyBlbHNlLlxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhlIHdhcyBvcmlnaW5hbGx5IHByb3ZpZGVkIHRvIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjbWV0aG9kc190cnVzdEFzXG4gICAgICogICAgIGAkc2NlRGVsZWdhdGUudHJ1c3RBc2B9IGlmIGB2YWx1ZWAgaXMgdGhlIHJlc3VsdCBvZiBzdWNoIGEgY2FsbC4gIE90aGVyd2lzZSwgcmV0dXJuc1xuICAgICAqICAgICBgdmFsdWVgIHVuY2hhbmdlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG1heWJlVHJ1c3RlZCkge1xuICAgICAgaWYgKG1heWJlVHJ1c3RlZCBpbnN0YW5jZW9mIHRydXN0ZWRWYWx1ZUhvbGRlckJhc2UpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlVHJ1c3RlZC4kJHVud3JhcFRydXN0ZWRWYWx1ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1heWJlVHJ1c3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZURlbGVnYXRlI2dldFRydXN0ZWRcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZURlbGVnYXRlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUYWtlcyB0aGUgcmVzdWx0IG9mIGEge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNtZXRob2RzX3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0gY2FsbCBhbmRcbiAgICAgKiByZXR1cm5zIHRoZSBvcmlnaW5hbGx5IHN1cHBsaWVkIHZhbHVlIGlmIHRoZSBxdWVyaWVkIGNvbnRleHQgdHlwZSBpcyBhIHN1cGVydHlwZSBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIHR5cGUuICBJZiB0aGlzIGNvbmRpdGlvbiBpc24ndCBzYXRpc2ZpZWQsIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUga2luZCBvZiBjb250ZXh0IGluIHdoaWNoIHRoaXMgdmFsdWUgaXMgdG8gYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0geyp9IG1heWJlVHJ1c3RlZCBUaGUgcmVzdWx0IG9mIGEgcHJpb3Ige0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNtZXRob2RzX3RydXN0QXNcbiAgICAgKiAgICAgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzYH0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoZSB3YXMgb3JpZ2luYWxseSBwcm92aWRlZCB0byB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfdHJ1c3RBc1xuICAgICAqICAgICBgJHNjZURlbGVnYXRlLnRydXN0QXNgfSBpZiB2YWxpZCBpbiB0aGlzIGNvbnRleHQuICBPdGhlcndpc2UsIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHJ1c3RlZCh0eXBlLCBtYXliZVRydXN0ZWQpIHtcbiAgICAgIGlmIChtYXliZVRydXN0ZWQgPT09IG51bGwgfHwgbWF5YmVUcnVzdGVkID09PSB1bmRlZmluZWQgfHwgbWF5YmVUcnVzdGVkID09PSAnJykge1xuICAgICAgICByZXR1cm4gbWF5YmVUcnVzdGVkO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gKGJ5VHlwZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSA/IGJ5VHlwZVt0eXBlXSA6IG51bGwpO1xuICAgICAgaWYgKGNvbnN0cnVjdG9yICYmIG1heWJlVHJ1c3RlZCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBtYXliZVRydXN0ZWQuJCR1bndyYXBUcnVzdGVkVmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB0aGVuIHdlIG1heSBvbmx5IHRha2Ugb25lIG9mIHR3byBhY3Rpb25zLlxuICAgICAgLy8gMS4gc2FuaXRpemUgdGhlIHZhbHVlIGZvciB0aGUgcmVxdWVzdGVkIHR5cGUsIG9yXG4gICAgICAvLyAyLiB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodHlwZSA9PT0gU0NFX0NPTlRFWFRTLlJFU09VUkNFX1VSTCkge1xuICAgICAgICBpZiAoaXNSZXNvdXJjZVVybEFsbG93ZWRCeVBvbGljeShtYXliZVRydXN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG1heWJlVHJ1c3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyAkc2NlTWluRXJyKCdpbnNlY3VybCcsXG4gICAgICAgICAgICAgICdCbG9ja2VkIGxvYWRpbmcgcmVzb3VyY2UgZnJvbSB1cmwgbm90IGFsbG93ZWQgYnkgJHNjZURlbGVnYXRlIHBvbGljeS4gIFVSTDogezB9JyxcbiAgICAgICAgICAgICAgbWF5YmVUcnVzdGVkLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFNDRV9DT05URVhUUy5IVE1MKSB7XG4gICAgICAgIHJldHVybiBodG1sU2FuaXRpemVyKG1heWJlVHJ1c3RlZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyAkc2NlTWluRXJyKCd1bnNhZmUnLCAnQXR0ZW1wdGluZyB0byB1c2UgYW4gdW5zYWZlIHZhbHVlIGluIGEgc2FmZSBjb250ZXh0LicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHRydXN0QXM6IHRydXN0QXMsXG4gICAgICAgICAgICAgZ2V0VHJ1c3RlZDogZ2V0VHJ1c3RlZCxcbiAgICAgICAgICAgICB2YWx1ZU9mOiB2YWx1ZU9mIH07XG4gIH1dO1xufVxuXG5cbi8qKlxuICogQG5nZG9jIG9iamVjdFxuICogQG5hbWUgbmcuJHNjZVByb3ZpZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGUgJHNjZVByb3ZpZGVyIHByb3ZpZGVyIGFsbG93cyBkZXZlbG9wZXJzIHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIG5nLiRzY2UgJHNjZX0gc2VydmljZS5cbiAqIC0gICBlbmFibGUvZGlzYWJsZSBTdHJpY3QgQ29udGV4dHVhbCBFc2NhcGluZyAoU0NFKSBpbiBhIG1vZHVsZVxuICogLSAgIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpdGggYSBjdXN0b20gZGVsZWdhdGVcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQge0BsaW5rIG5nLiRzY2UgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSl9LlxuICovXG5cbi8qIGpzaGludCBtYXhsZW46IGZhbHNlKi9cblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgbmcuJHNjZVxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogYCRzY2VgIGlzIGEgc2VydmljZSB0aGF0IHByb3ZpZGVzIFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nIHNlcnZpY2VzIHRvIEFuZ3VsYXJKUy5cbiAqXG4gKiAjIFN0cmljdCBDb250ZXh0dWFsIEVzY2FwaW5nXG4gKlxuICogU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSkgaXMgYSBtb2RlIGluIHdoaWNoIEFuZ3VsYXJKUyByZXF1aXJlcyBiaW5kaW5ncyBpbiBjZXJ0YWluXG4gKiBjb250ZXh0cyB0byByZXN1bHQgaW4gYSB2YWx1ZSB0aGF0IGlzIG1hcmtlZCBhcyBzYWZlIHRvIHVzZSBmb3IgdGhhdCBjb250ZXh0LiAgT25lIGV4YW1wbGUgb2ZcbiAqIHN1Y2ggYSBjb250ZXh0IGlzIGJpbmRpbmcgYXJiaXRyYXJ5IGh0bWwgY29udHJvbGxlZCBieSB0aGUgdXNlciB2aWEgYG5nLWJpbmQtaHRtbGAuICBXZSByZWZlclxuICogdG8gdGhlc2UgY29udGV4dHMgYXMgcHJpdmlsZWdlZCBvciBTQ0UgY29udGV4dHMuXG4gKlxuICogQXMgb2YgdmVyc2lvbiAxLjIsIEFuZ3VsYXIgc2hpcHMgd2l0aCBTQ0UgZW5hYmxlZCBieSBkZWZhdWx0LlxuICpcbiAqIE5vdGU6ICBXaGVuIGVuYWJsZWQgKHRoZSBkZWZhdWx0KSwgSUU4IGluIHF1aXJrcyBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQuICBJbiB0aGlzIG1vZGUsIElFOCBhbGxvd3NcbiAqIG9uZSB0byBleGVjdXRlIGFyYml0cmFyeSBqYXZhc2NyaXB0IGJ5IHRoZSB1c2Ugb2YgdGhlIGV4cHJlc3Npb24oKSBzeW50YXguICBSZWZlclxuICogPGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAwOC8xMC8xNi9lbmRpbmctZXhwcmVzc2lvbnMuYXNweD4gdG8gbGVhcm4gbW9yZSBhYm91dCB0aGVtLlxuICogWW91IGNhbiBlbnN1cmUgeW91ciBkb2N1bWVudCBpcyBpbiBzdGFuZGFyZHMgbW9kZSBhbmQgbm90IHF1aXJrcyBtb2RlIGJ5IGFkZGluZyBgPCFkb2N0eXBlIGh0bWw+YFxuICogdG8gdGhlIHRvcCBvZiB5b3VyIEhUTUwgZG9jdW1lbnQuXG4gKlxuICogU0NFIGFzc2lzdHMgaW4gd3JpdGluZyBjb2RlIGluIHdheSB0aGF0IChhKSBpcyBzZWN1cmUgYnkgZGVmYXVsdCBhbmQgKGIpIG1ha2VzIGF1ZGl0aW5nIGZvclxuICogc2VjdXJpdHkgdnVsbmVyYWJpbGl0aWVzIHN1Y2ggYXMgWFNTLCBjbGlja2phY2tpbmcsIGV0Yy4gYSBsb3QgZWFzaWVyLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIG9mIGEgYmluZGluZyBpbiBhIHByaXZpbGVnZWQgY29udGV4dDpcbiAqXG4gKiA8cHJlIGNsYXNzPVwicHJldHR5cHJpbnRcIj5cbiAqICAgICA8aW5wdXQgbmctbW9kZWw9XCJ1c2VySHRtbFwiPlxuICogICAgIDxkaXYgbmctYmluZC1odG1sPVwidXNlckh0bWxcIj5cbiAqIDwvcHJlPlxuICpcbiAqIE5vdGljZSB0aGF0IGBuZy1iaW5kLWh0bWxgIGlzIGJvdW5kIHRvIGB1c2VySHRtbGAgY29udHJvbGxlZCBieSB0aGUgdXNlci4gIFdpdGggU0NFXG4gKiBkaXNhYmxlZCwgdGhpcyBhcHBsaWNhdGlvbiBhbGxvd3MgdGhlIHVzZXIgdG8gcmVuZGVyIGFyYml0cmFyeSBIVE1MIGludG8gdGhlIERJVi5cbiAqIEluIGEgbW9yZSByZWFsaXN0aWMgZXhhbXBsZSwgb25lIG1heSBiZSByZW5kZXJpbmcgdXNlciBjb21tZW50cywgYmxvZyBhcnRpY2xlcywgZXRjLiB2aWFcbiAqIGJpbmRpbmdzLiAgKEhUTUwgaXMganVzdCBvbmUgZXhhbXBsZSBvZiBhIGNvbnRleHQgd2hlcmUgcmVuZGVyaW5nIHVzZXIgY29udHJvbGxlZCBpbnB1dCBjcmVhdGVzXG4gKiBzZWN1cml0eSB2dWxuZXJhYmlsaXRpZXMuKVxuICpcbiAqIEZvciB0aGUgY2FzZSBvZiBIVE1MLCB5b3UgbWlnaHQgdXNlIGEgbGlicmFyeSwgZWl0aGVyIG9uIHRoZSBjbGllbnQgc2lkZSwgb3Igb24gdGhlIHNlcnZlciBzaWRlLFxuICogdG8gc2FuaXRpemUgdW5zYWZlIEhUTUwgYmVmb3JlIGJpbmRpbmcgdG8gdGhlIHZhbHVlIGFuZCByZW5kZXJpbmcgaXQgaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIEhvdyB3b3VsZCB5b3UgZW5zdXJlIHRoYXQgZXZlcnkgcGxhY2UgdGhhdCB1c2VkIHRoZXNlIHR5cGVzIG9mIGJpbmRpbmdzIHdhcyBib3VuZCB0byBhIHZhbHVlIHRoYXRcbiAqIHdhcyBzYW5pdGl6ZWQgYnkgeW91ciBsaWJyYXJ5IChvciByZXR1cm5lZCBhcyBzYWZlIGZvciByZW5kZXJpbmcgYnkgeW91ciBzZXJ2ZXI/KSAgSG93IGNhbiB5b3VcbiAqIGVuc3VyZSB0aGF0IHlvdSBkaWRuJ3QgYWNjaWRlbnRhbGx5IGRlbGV0ZSB0aGUgbGluZSB0aGF0IHNhbml0aXplZCB0aGUgdmFsdWUsIG9yIHJlbmFtZWQgc29tZVxuICogcHJvcGVydGllcy9maWVsZHMgYW5kIGZvcmdvdCB0byB1cGRhdGUgdGhlIGJpbmRpbmcgdG8gdGhlIHNhbml0aXplZCB2YWx1ZT9cbiAqXG4gKiBUbyBiZSBzZWN1cmUgYnkgZGVmYXVsdCwgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgYW55IHN1Y2ggYmluZGluZ3MgYXJlIGRpc2FsbG93ZWQgdW5sZXNzIHlvdSBjYW5cbiAqIGRldGVybWluZSB0aGF0IHNvbWV0aGluZyBleHBsaWNpdGx5IHNheXMgaXQncyBzYWZlIHRvIHVzZSBhIHZhbHVlIGZvciBiaW5kaW5nIGluIHRoYXRcbiAqIGNvbnRleHQuICBZb3UgY2FuIHRoZW4gYXVkaXQgeW91ciBjb2RlIChhIHNpbXBsZSBncmVwIHdvdWxkIGRvKSB0byBlbnN1cmUgdGhhdCB0aGlzIGlzIG9ubHkgZG9uZVxuICogZm9yIHRob3NlIHZhbHVlcyB0aGF0IHlvdSBjYW4gZWFzaWx5IHRlbGwgYXJlIHNhZmUgLSBiZWNhdXNlIHRoZXkgd2VyZSByZWNlaXZlZCBmcm9tIHlvdXIgc2VydmVyLFxuICogc2FuaXRpemVkIGJ5IHlvdXIgbGlicmFyeSwgZXRjLiAgWW91IGNhbiBvcmdhbml6ZSB5b3VyIGNvZGViYXNlIHRvIGhlbHAgd2l0aCB0aGlzIC0gcGVyaGFwc1xuICogYWxsb3dpbmcgb25seSB0aGUgZmlsZXMgaW4gYSBzcGVjaWZpYyBkaXJlY3RvcnkgdG8gZG8gdGhpcy4gIEVuc3VyaW5nIHRoYXQgdGhlIGludGVybmFsIEFQSVxuICogZXhwb3NlZCBieSB0aGF0IGNvZGUgZG9lc24ndCBtYXJrdXAgYXJiaXRyYXJ5IHZhbHVlcyBhcyBzYWZlIHRoZW4gYmVjb21lcyBhIG1vcmUgbWFuYWdlYWJsZSB0YXNrLlxuICpcbiAqIEluIHRoZSBjYXNlIG9mIEFuZ3VsYXJKUycgU0NFIHNlcnZpY2UsIG9uZSB1c2VzIHtAbGluayBuZy4kc2NlI21ldGhvZHNfdHJ1c3RBcyAkc2NlLnRydXN0QXN9IFxuICogKGFuZCBzaG9ydGhhbmQgbWV0aG9kcyBzdWNoIGFzIHtAbGluayBuZy4kc2NlI21ldGhvZHNfdHJ1c3RBc0h0bWwgJHNjZS50cnVzdEFzSHRtbH0sIGV0Yy4pIHRvXG4gKiBvYnRhaW4gdmFsdWVzIHRoYXQgd2lsbCBiZSBhY2NlcHRlZCBieSBTQ0UgLyBwcml2aWxlZ2VkIGNvbnRleHRzLlxuICpcbiAqXG4gKiAjIyBIb3cgZG9lcyBpdCB3b3JrP1xuICpcbiAqIEluIHByaXZpbGVnZWQgY29udGV4dHMsIGRpcmVjdGl2ZXMgYW5kIGNvZGUgd2lsbCBiaW5kIHRvIHRoZSByZXN1bHQgb2Yge0BsaW5rIG5nLiRzY2UjbWV0aG9kc19nZXRUcnVzdGVkXG4gKiAkc2NlLmdldFRydXN0ZWQoY29udGV4dCwgdmFsdWUpfSByYXRoZXIgdGhhbiB0byB0aGUgdmFsdWUgZGlyZWN0bHkuICBEaXJlY3RpdmVzIHVzZSB7QGxpbmtcbiAqIG5nLiRzY2UjbWV0aG9kc19wYXJzZSAkc2NlLnBhcnNlQXN9IHJhdGhlciB0aGFuIGAkcGFyc2VgIHRvIHdhdGNoIGF0dHJpYnV0ZSBiaW5kaW5ncywgd2hpY2ggcGVyZm9ybXMgdGhlXG4gKiB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX2dldFRydXN0ZWQgJHNjZS5nZXRUcnVzdGVkfSBiZWhpbmQgdGhlIHNjZW5lcyBvbiBub24tY29uc3RhbnQgbGl0ZXJhbHMuXG4gKlxuICogQXMgYW4gZXhhbXBsZSwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0JpbmRIdG1sIG5nQmluZEh0bWx9IHVzZXMge0BsaW5rXG4gKiBuZy4kc2NlI21ldGhvZHNfcGFyc2VBc0h0bWwgJHNjZS5wYXJzZUFzSHRtbChiaW5kaW5nIGV4cHJlc3Npb24pfS4gIEhlcmUncyB0aGUgYWN0dWFsIGNvZGUgKHNsaWdodGx5XG4gKiBzaW1wbGlmaWVkKTpcbiAqXG4gKiA8cHJlIGNsYXNzPVwicHJldHR5cHJpbnRcIj5cbiAqICAgdmFyIG5nQmluZEh0bWxEaXJlY3RpdmUgPSBbJyRzY2UnLCBmdW5jdGlvbigkc2NlKSB7XG4gKiAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gKiAgICAgICBzY29wZS4kd2F0Y2goJHNjZS5wYXJzZUFzSHRtbChhdHRyLm5nQmluZEh0bWwpLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICAgICAgICBlbGVtZW50Lmh0bWwodmFsdWUgfHwgJycpO1xuICogICAgICAgfSk7XG4gKiAgICAgfTtcbiAqICAgfV07XG4gKiA8L3ByZT5cbiAqXG4gKiAjIyBJbXBhY3Qgb24gbG9hZGluZyB0ZW1wbGF0ZXNcbiAqXG4gKiBUaGlzIGFwcGxpZXMgYm90aCB0byB0aGUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGUgYG5nLWluY2x1ZGVgfSBkaXJlY3RpdmUgYXMgd2VsbCBhc1xuICogYHRlbXBsYXRlVXJsYCdzIHNwZWNpZmllZCBieSB7QGxpbmsgZ3VpZGUvZGlyZWN0aXZlIGRpcmVjdGl2ZXN9LlxuICpcbiAqIEJ5IGRlZmF1bHQsIEFuZ3VsYXIgb25seSBsb2FkcyB0ZW1wbGF0ZXMgZnJvbSB0aGUgc2FtZSBkb21haW4gYW5kIHByb3RvY29sIGFzIHRoZSBhcHBsaWNhdGlvblxuICogZG9jdW1lbnQuICBUaGlzIGlzIGRvbmUgYnkgY2FsbGluZyB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX2dldFRydXN0ZWRSZXNvdXJjZVVybFxuICogJHNjZS5nZXRUcnVzdGVkUmVzb3VyY2VVcmx9IG9uIHRoZSB0ZW1wbGF0ZSBVUkwuICBUbyBsb2FkIHRlbXBsYXRlcyBmcm9tIG90aGVyIGRvbWFpbnMgYW5kL29yXG4gKiBwcm90b2NvbHMsIHlvdSBtYXkgZWl0aGVyIGVpdGhlciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjbWV0aG9kc19yZXNvdXJjZVVybFdoaXRlbGlzdCB3aGl0ZWxpc3RcbiAqIHRoZW19IG9yIHtAbGluayBuZy4kc2NlI21ldGhvZHNfdHJ1c3RBc1Jlc291cmNlVXJsIHdyYXAgaXR9IGludG8gYSB0cnVzdGVkIHZhbHVlLlxuICpcbiAqICpQbGVhc2Ugbm90ZSo6XG4gKiBUaGUgYnJvd3NlcidzXG4gKiB7QGxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9icm93c2Vyc2VjL3dpa2kvUGFydDIjU2FtZS1vcmlnaW5fcG9saWN5X2Zvcl9YTUxIdHRwUmVxdWVzdFxuICogU2FtZSBPcmlnaW4gUG9saWN5fSBhbmQge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL2NvcnMvIENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nIChDT1JTKX1cbiAqIHBvbGljeSBhcHBseSBpbiBhZGRpdGlvbiB0byB0aGlzIGFuZCBtYXkgZnVydGhlciByZXN0cmljdCB3aGV0aGVyIHRoZSB0ZW1wbGF0ZSBpcyBzdWNjZXNzZnVsbHlcbiAqIGxvYWRlZC4gIFRoaXMgbWVhbnMgdGhhdCB3aXRob3V0IHRoZSByaWdodCBDT1JTIHBvbGljeSwgbG9hZGluZyB0ZW1wbGF0ZXMgZnJvbSBhIGRpZmZlcmVudCBkb21haW5cbiAqIHdvbid0IHdvcmsgb24gYWxsIGJyb3dzZXJzLiAgQWxzbywgbG9hZGluZyB0ZW1wbGF0ZXMgZnJvbSBgZmlsZTovL2AgVVJMIGRvZXMgbm90IHdvcmsgb24gc29tZVxuICogYnJvd3NlcnMuXG4gKlxuICogIyMgVGhpcyBmZWVscyBsaWtlIHRvbyBtdWNoIG92ZXJoZWFkIGZvciB0aGUgZGV2ZWxvcGVyP1xuICpcbiAqIEl0J3MgaW1wb3J0YW50IHRvIHJlbWVtYmVyIHRoYXQgU0NFIG9ubHkgYXBwbGllcyB0byBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb25zLlxuICpcbiAqIElmIHlvdXIgZXhwcmVzc2lvbnMgYXJlIGNvbnN0YW50IGxpdGVyYWxzLCB0aGV5J3JlIGF1dG9tYXRpY2FsbHkgdHJ1c3RlZCBhbmQgeW91IGRvbid0IG5lZWQgdG9cbiAqIGNhbGwgYCRzY2UudHJ1c3RBc2Agb24gdGhlbS4gIChlLmcuXG4gKiBgPGRpdiBuZy1odG1sLWJpbmQtdW5zYWZlPVwiJzxiPmltcGxpY2l0bHkgdHJ1c3RlZDwvYj4nXCI+PC9kaXY+YCkganVzdCB3b3Jrcy5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIGBhW2hyZWZdYCBhbmQgYGltZ1tzcmNdYCBhdXRvbWF0aWNhbGx5IHNhbml0aXplIHRoZWlyIFVSTHMgYW5kIGRvIG5vdCBwYXNzIHRoZW1cbiAqIHRocm91Z2gge0BsaW5rIG5nLiRzY2UjbWV0aG9kc19nZXRUcnVzdGVkICRzY2UuZ2V0VHJ1c3RlZH0uICBTQ0UgZG9lc24ndCBwbGF5IGEgcm9sZSBoZXJlLlxuICpcbiAqIFRoZSBpbmNsdWRlZCB7QGxpbmsgbmcuJHNjZURlbGVnYXRlICRzY2VEZWxlZ2F0ZX0gY29tZXMgd2l0aCBzYW5lIGRlZmF1bHRzIHRvIGFsbG93IHlvdSB0byBsb2FkXG4gKiB0ZW1wbGF0ZXMgaW4gYG5nLWluY2x1ZGVgIGZyb20geW91ciBhcHBsaWNhdGlvbidzIGRvbWFpbiB3aXRob3V0IGhhdmluZyB0byBldmVuIGtub3cgYWJvdXQgU0NFLlxuICogSXQgYmxvY2tzIGxvYWRpbmcgdGVtcGxhdGVzIGZyb20gb3RoZXIgZG9tYWlucyBvciBsb2FkaW5nIHRlbXBsYXRlcyBvdmVyIGh0dHAgZnJvbSBhbiBodHRwc1xuICogc2VydmVkIGRvY3VtZW50LiAgWW91IGNhbiBjaGFuZ2UgdGhlc2UgYnkgc2V0dGluZyB5b3VyIG93biBjdXN0b20ge0BsaW5rXG4gKiBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciNtZXRob2RzX3Jlc291cmNlVXJsV2hpdGVsaXN0IHdoaXRlbGlzdHN9IGFuZCB7QGxpbmtcbiAqIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI21ldGhvZHNfcmVzb3VyY2VVcmxCbGFja2xpc3QgYmxhY2tsaXN0c30gZm9yIG1hdGNoaW5nIHN1Y2ggVVJMcy5cbiAqXG4gKiBUaGlzIHNpZ25pZmljYW50bHkgcmVkdWNlcyB0aGUgb3ZlcmhlYWQuICBJdCBpcyBmYXIgZWFzaWVyIHRvIHBheSB0aGUgc21hbGwgb3ZlcmhlYWQgYW5kIGhhdmUgYW5cbiAqIGFwcGxpY2F0aW9uIHRoYXQncyBzZWN1cmUgYW5kIGNhbiBiZSBhdWRpdGVkIHRvIHZlcmlmeSB0aGF0IHdpdGggbXVjaCBtb3JlIGVhc2UgdGhhbiBib2x0aW5nXG4gKiBzZWN1cml0eSBvbnRvIGFuIGFwcGxpY2F0aW9uIGxhdGVyLlxuICpcbiAqIDxhIG5hbWU9XCJjb250ZXh0c1wiPjwvYT5cbiAqICMjIFdoYXQgdHJ1c3RlZCBjb250ZXh0IHR5cGVzIGFyZSBzdXBwb3J0ZWQ/XG4gKlxuICogfCBDb250ZXh0ICAgICAgICAgICAgIHwgTm90ZXMgICAgICAgICAgfFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJHNjZS5IVE1MYCAgICAgICAgIHwgRm9yIEhUTUwgdGhhdCdzIHNhZmUgdG8gc291cmNlIGludG8gdGhlIGFwcGxpY2F0aW9uLiAgVGhlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdCaW5kSHRtbCBuZ0JpbmRIdG1sfSBkaXJlY3RpdmUgdXNlcyB0aGlzIGNvbnRleHQgZm9yIGJpbmRpbmdzLiB8XG4gKiB8IGAkc2NlLkNTU2AgICAgICAgICAgfCBGb3IgQ1NTIHRoYXQncyBzYWZlIHRvIHNvdXJjZSBpbnRvIHRoZSBhcHBsaWNhdGlvbi4gIEN1cnJlbnRseSB1bnVzZWQuICBGZWVsIGZyZWUgdG8gdXNlIGl0IGluIHlvdXIgb3duIGRpcmVjdGl2ZXMuIHxcbiAqIHwgYCRzY2UuVVJMYCAgICAgICAgICB8IEZvciBVUkxzIHRoYXQgYXJlIHNhZmUgdG8gZm9sbG93IGFzIGxpbmtzLiAgQ3VycmVudGx5IHVudXNlZCAoYDxhIGhyZWY9YCBhbmQgYDxpbWcgc3JjPWAgc2FuaXRpemUgdGhlaXIgdXJscyBhbmQgZG9uJ3QgY29uc2l0aXR1dGUgYW4gU0NFIGNvbnRleHQuIHxcbiAqIHwgYCRzY2UuUkVTT1VSQ0VfVVJMYCB8IEZvciBVUkxzIHRoYXQgYXJlIG5vdCBvbmx5IHNhZmUgdG8gZm9sbG93IGFzIGxpbmtzLCBidXQgd2hvc2UgY29udGVucyBhcmUgYWxzbyBzYWZlIHRvIGluY2x1ZGUgaW4geW91ciBhcHBsaWNhdGlvbi4gIEV4YW1wbGVzIGluY2x1ZGUgYG5nLWluY2x1ZGVgLCBgc3JjYCAvIGBuZ1NyY2AgYmluZGluZ3MgZm9yIHRhZ3Mgb3RoZXIgdGhhbiBgSU1HYCAoZS5nLiBgSUZSQU1FYCwgYE9CSkVDVGAsIGV0Yy4pICA8YnI+PGJyPk5vdGUgdGhhdCBgJHNjZS5SRVNPVVJDRV9VUkxgIG1ha2VzIGEgc3Ryb25nZXIgc3RhdGVtZW50IGFib3V0IHRoZSBVUkwgdGhhbiBgJHNjZS5VUkxgIGRvZXMgYW5kIHRoZXJlZm9yZSBjb250ZXh0cyByZXF1aXJpbmcgdmFsdWVzIHRydXN0ZWQgZm9yIGAkc2NlLlJFU09VUkNFX1VSTGAgY2FuIGJlIHVzZWQgYW55d2hlcmUgdGhhdCB2YWx1ZXMgdHJ1c3RlZCBmb3IgYCRzY2UuVVJMYCBhcmUgcmVxdWlyZWQuIHxcbiAqIHwgYCRzY2UuSlNgICAgICAgICAgICB8IEZvciBKYXZhU2NyaXB0IHRoYXQgaXMgc2FmZSB0byBleGVjdXRlIGluIHlvdXIgYXBwbGljYXRpb24ncyBjb250ZXh0LiAgQ3VycmVudGx5IHVudXNlZC4gIEZlZWwgZnJlZSB0byB1c2UgaXQgaW4geW91ciBvd24gZGlyZWN0aXZlcy4gfFxuICpcbiAqICMjIEZvcm1hdCBvZiBpdGVtcyBpbiB7QGxpbmsgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjbWV0aG9kc19yZXNvdXJjZVVybFdoaXRlbGlzdCByZXNvdXJjZVVybFdoaXRlbGlzdH0ve0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZVByb3ZpZGVyI21ldGhvZHNfcmVzb3VyY2VVcmxCbGFja2xpc3QgQmxhY2tsaXN0fSA8YSBuYW1lPVwicmVzb3VyY2VVcmxQYXR0ZXJuSXRlbVwiPjwvYT5cbiAqXG4gKiAgRWFjaCBlbGVtZW50IGluIHRoZXNlIGFycmF5cyBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtICoqJ3NlbGYnKipcbiAqICAgIC0gVGhlIHNwZWNpYWwgKipzdHJpbmcqKiwgYCdzZWxmJ2AsIGNhbiBiZSB1c2VkIHRvIG1hdGNoIGFnYWluc3QgYWxsIFVSTHMgb2YgdGhlICoqc2FtZVxuICogICAgICBkb21haW4qKiBhcyB0aGUgYXBwbGljYXRpb24gZG9jdW1lbnQgdXNpbmcgdGhlICoqc2FtZSBwcm90b2NvbCoqLlxuICogIC0gKipTdHJpbmcqKiAoZXhjZXB0IHRoZSBzcGVjaWFsIHZhbHVlIGAnc2VsZidgKVxuICogICAgLSBUaGUgc3RyaW5nIGlzIG1hdGNoZWQgYWdhaW5zdCB0aGUgZnVsbCAqbm9ybWFsaXplZCAvIGFic29sdXRlIFVSTCogb2YgdGhlIHJlc291cmNlXG4gKiAgICAgIGJlaW5nIHRlc3RlZCAoc3Vic3RyaW5nIG1hdGNoZXMgYXJlIG5vdCBnb29kIGVub3VnaC4pXG4gKiAgICAtIFRoZXJlIGFyZSBleGFjdGx5ICoqdHdvIHdpbGRjYXJkIHNlcXVlbmNlcyoqIC0gYCpgIGFuZCBgKipgLiAgQWxsIG90aGVyIGNoYXJhY3RlcnNcbiAqICAgICAgbWF0Y2ggdGhlbXNlbHZlcy5cbiAqICAgIC0gYCpgOiBtYXRjaGVzIHplcm8gb3IgbW9yZSBvY2N1cmFuY2VzIG9mIGFueSBjaGFyYWN0ZXIgb3RoZXIgdGhhbiBvbmUgb2YgdGhlIGZvbGxvd2luZyA2XG4gKiAgICAgIGNoYXJhY3RlcnM6ICdgOmAnLCAnYC9gJywgJ2AuYCcsICdgP2AnLCAnYCZgJyBhbmQgJzsnLiAgSXQncyBhIHVzZWZ1bCB3aWxkY2FyZCBmb3IgdXNlXG4gKiAgICAgIGluIGEgd2hpdGVsaXN0LlxuICogICAgLSBgKipgOiBtYXRjaGVzIHplcm8gb3IgbW9yZSBvY2N1cmFuY2VzIG9mICphbnkqIGNoYXJhY3Rlci4gIEFzIHN1Y2gsIGl0J3Mgbm90XG4gKiAgICAgIG5vdCBhcHByb3ByaWF0ZSB0byB1c2UgaW4gZm9yIGEgc2NoZW1lLCBkb21haW4sIGV0Yy4gYXMgaXQgd291bGQgbWF0Y2ggdG9vIG11Y2guICAoZS5nLlxuICogICAgICBodHRwOi8vKiouZXhhbXBsZS5jb20vIHdvdWxkIG1hdGNoIGh0dHA6Ly9ldmlsLmNvbS8/aWdub3JlPS5leGFtcGxlLmNvbS8gYW5kIHRoYXQgbWlnaHRcbiAqICAgICAgbm90IGhhdmUgYmVlbiB0aGUgaW50ZW50aW9uLikgIEl0J3MgdXNhZ2UgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBwYXRoIGlzIG9rLiAgKGUuZy5cbiAqICAgICAgaHR0cDovL2Zvby5leGFtcGxlLmNvbS90ZW1wbGF0ZXMvKiopLlxuICogIC0gKipSZWdFeHAqKiAoKnNlZSBjYXZlYXQgYmVsb3cqKVxuICogICAgLSAqQ2F2ZWF0KjogIFdoaWxlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYXJlIHBvd2VyZnVsIGFuZCBvZmZlciBncmVhdCBmbGV4aWJpbGl0eSwgIHRoZWlyIHN5bnRheFxuICogICAgICAoYW5kIGFsbCB0aGUgaW5ldml0YWJsZSBlc2NhcGluZykgbWFrZXMgdGhlbSAqaGFyZGVyIHRvIG1haW50YWluKi4gIEl0J3MgZWFzeSB0b1xuICogICAgICBhY2NpZGVudGFsbHkgaW50cm9kdWNlIGEgYnVnIHdoZW4gb25lIHVwZGF0ZXMgYSBjb21wbGV4IGV4cHJlc3Npb24gKGltaG8sIGFsbCByZWdleGVzIHNob3VsZFxuICogICAgICBoYXZlIGdvb2QgdGVzdCBjb3ZlcmFnZS4pLiAgRm9yIGluc3RhbmNlLCB0aGUgdXNlIG9mIGAuYCBpbiB0aGUgcmVnZXggaXMgY29ycmVjdCBvbmx5IGluIGFcbiAqICAgICAgc21hbGwgbnVtYmVyIG9mIGNhc2VzLiAgQSBgLmAgY2hhcmFjdGVyIGluIHRoZSByZWdleCB1c2VkIHdoZW4gbWF0Y2hpbmcgdGhlIHNjaGVtZSBvciBhXG4gKiAgICAgIHN1YmRvbWFpbiBjb3VsZCBiZSBtYXRjaGVkIGFnYWluc3QgYSBgOmAgb3IgbGl0ZXJhbCBgLmAgdGhhdCB3YXMgbGlrZWx5IG5vdCBpbnRlbmRlZC4gICBJdFxuICogICAgICBpcyBoaWdobHkgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBzdHJpbmcgcGF0dGVybnMgYW5kIG9ubHkgZmFsbCBiYWNrIHRvIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAqICAgICAgaWYgdGhleSBhcyBhIGxhc3QgcmVzb3J0LlxuICogICAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUmVnRXhwIChpLmUuIG5vdCBhIHN0cmluZy4pICBJdCBpc1xuICogICAgICBtYXRjaGVkIGFnYWluc3QgdGhlICoqZW50aXJlKiogKm5vcm1hbGl6ZWQgLyBhYnNvbHV0ZSBVUkwqIG9mIHRoZSByZXNvdXJjZSBiZWluZyB0ZXN0ZWRcbiAqICAgICAgKGV2ZW4gd2hlbiB0aGUgUmVnRXhwIGRpZCBub3QgaGF2ZSB0aGUgYF5gIGFuZCBgJGAgY29kZXMuKSAgSW4gYWRkaXRpb24sIGFueSBmbGFnc1xuICogICAgICBwcmVzZW50IG9uIHRoZSBSZWdFeHAgKHN1Y2ggYXMgbXVsdGlsaW5lLCBnbG9iYWwsIGlnbm9yZUNhc2UpIGFyZSBpZ25vcmVkLlxuICogICAgLSBJZiB5b3UgYXJlIGdlbmVyYXRpbmcgeW91ciBKYXZhc2NyaXB0IGZyb20gc29tZSBvdGhlciB0ZW1wbGF0aW5nIGVuZ2luZSAobm90XG4gKiAgICAgIHJlY29tbWVuZGVkLCBlLmcuIGluIGlzc3VlIFsjNDAwNl0oaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvNDAwNikpLFxuICogICAgICByZW1lbWJlciB0byBlc2NhcGUgeW91ciByZWd1bGFyIGV4cHJlc3Npb24gKGFuZCBiZSBhd2FyZSB0aGF0IHlvdSBtaWdodCBuZWVkIG1vcmUgdGhhblxuICogICAgICBvbmUgbGV2ZWwgb2YgZXNjYXBpbmcgZGVwZW5kaW5nIG9uIHlvdXIgdGVtcGxhdGluZyBlbmdpbmUgYW5kIHRoZSB3YXkgeW91IGludGVycG9sYXRlZFxuICogICAgICB0aGUgdmFsdWUuKSAgRG8gbWFrZSB1c2Ugb2YgeW91ciBwbGF0Zm9ybSdzIGVzY2FwaW5nIG1lY2hhbmlzbSBhcyBpdCBtaWdodCBiZSBnb29kXG4gKiAgICAgIGVub3VnaCBiZWZvcmUgY29kaW5nIHlvdXIgb3duLiAgZS5nLiBSdWJ5IGhhc1xuICogICAgICBbUmVnZXhwLmVzY2FwZShzdHIpXShodHRwOi8vd3d3LnJ1YnktZG9jLm9yZy9jb3JlLTIuMC4wL1JlZ2V4cC5odG1sI21ldGhvZC1jLWVzY2FwZSlcbiAqICAgICAgYW5kIFB5dGhvbiBoYXMgW3JlLmVzY2FwZV0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3JlLmh0bWwjcmUuZXNjYXBlKS5cbiAqICAgICAgSmF2YXNjcmlwdCBsYWNrcyBhIHNpbWlsYXIgYnVpbHQgaW4gZnVuY3Rpb24gZm9yIGVzY2FwaW5nLiAgVGFrZSBhIGxvb2sgYXQgR29vZ2xlXG4gKiAgICAgIENsb3N1cmUgbGlicmFyeSdzIFtnb29nLnN0cmluZy5yZWdFeHBFc2NhcGUocyldKFxuICogICAgICBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19zdHJpbmdfc3RyaW5nLmpzLnNvdXJjZS5odG1sI2xpbmU5NjIpLlxuICpcbiAqIFJlZmVyIHtAbGluayBuZy4kc2NlRGVsZWdhdGVQcm92aWRlciAkc2NlRGVsZWdhdGVQcm92aWRlcn0gZm9yIGFuIGV4YW1wbGUuXG4gKlxuICogIyMgU2hvdyBtZSBhbiBleGFtcGxlIHVzaW5nIFNDRS5cbiAqXG4gKiBAZXhhbXBsZVxuPGV4YW1wbGUgbW9kdWxlPVwibXlTY2VBcHBcIj5cbjxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gIDxkaXYgbmctY29udHJvbGxlcj1cIm15QXBwQ29udHJvbGxlciBhcyBteUN0cmxcIj5cbiAgICA8aSBuZy1iaW5kLWh0bWw9XCJteUN0cmwuZXhwbGljaXRseVRydXN0ZWRIdG1sXCIgaWQ9XCJleHBsaWNpdGx5VHJ1c3RlZEh0bWxcIj48L2k+PGJyPjxicj5cbiAgICA8Yj5Vc2VyIGNvbW1lbnRzPC9iPjxicj5cbiAgICBCeSBkZWZhdWx0LCBIVE1MIHRoYXQgaXNuJ3QgZXhwbGljaXRseSB0cnVzdGVkIChlLmcuIEFsaWNlJ3MgY29tbWVudCkgaXMgc2FuaXRpemVkIHdoZW5cbiAgICAkc2FuaXRpemUgaXMgYXZhaWxhYmxlLiAgSWYgJHNhbml0aXplIGlzbid0IGF2YWlsYWJsZSwgdGhpcyByZXN1bHRzIGluIGFuIGVycm9yIGluc3RlYWQgb2YgYW5cbiAgICBleHBsb2l0LlxuICAgIDxkaXYgY2xhc3M9XCJ3ZWxsXCI+XG4gICAgICA8ZGl2IG5nLXJlcGVhdD1cInVzZXJDb21tZW50IGluIG15Q3RybC51c2VyQ29tbWVudHNcIj5cbiAgICAgICAgPGI+e3t1c2VyQ29tbWVudC5uYW1lfX08L2I+OlxuICAgICAgICA8c3BhbiBuZy1iaW5kLWh0bWw9XCJ1c2VyQ29tbWVudC5odG1sQ29tbWVudFwiIGNsYXNzPVwiaHRtbENvbW1lbnRcIj48L3NwYW4+XG4gICAgICAgIDxicj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZmlsZT5cblxuPGZpbGUgbmFtZT1cInNjcmlwdC5qc1wiPlxuICB2YXIgbXlTY2VBcHAgPSBhbmd1bGFyLm1vZHVsZSgnbXlTY2VBcHAnLCBbJ25nU2FuaXRpemUnXSk7XG5cbiAgbXlTY2VBcHAuY29udHJvbGxlcihcIm15QXBwQ29udHJvbGxlclwiLCBmdW5jdGlvbiBteUFwcENvbnRyb2xsZXIoJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkc2NlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICRodHRwLmdldChcInRlc3RfZGF0YS5qc29uXCIsIHtjYWNoZTogJHRlbXBsYXRlQ2FjaGV9KS5zdWNjZXNzKGZ1bmN0aW9uKHVzZXJDb21tZW50cykge1xuICAgICAgc2VsZi51c2VyQ29tbWVudHMgPSB1c2VyQ29tbWVudHM7XG4gICAgfSk7XG4gICAgc2VsZi5leHBsaWNpdGx5VHJ1c3RlZEh0bWwgPSAkc2NlLnRydXN0QXNIdG1sKFxuICAgICAgICAnPHNwYW4gb25tb3VzZW92ZXI9XCJ0aGlzLnRleHRDb250ZW50PSZxdW90O0V4cGxpY2l0bHkgdHJ1c3RlZCBIVE1MIGJ5cGFzc2VzICcgK1xuICAgICAgICAnc2FuaXRpemF0aW9uLiZxdW90O1wiPkhvdmVyIG92ZXIgdGhpcyB0ZXh0Ljwvc3Bhbj4nKTtcbiAgfSk7XG48L2ZpbGU+XG5cbjxmaWxlIG5hbWU9XCJ0ZXN0X2RhdGEuanNvblwiPlxuW1xuICB7IFwibmFtZVwiOiBcIkFsaWNlXCIsXG4gICAgXCJodG1sQ29tbWVudFwiOlxuICAgICAgICBcIjxzcGFuIG9ubW91c2VvdmVyPSd0aGlzLnRleHRDb250ZW50PVxcXCJQV04zRCFcXFwiJz5JcyA8aT5hbnlvbmU8L2k+IHJlYWRpbmcgdGhpcz88L3NwYW4+XCJcbiAgfSxcbiAgeyBcIm5hbWVcIjogXCJCb2JcIixcbiAgICBcImh0bWxDb21tZW50XCI6IFwiPGk+WWVzITwvaT4gIEFtIEkgdGhlIG9ubHkgb3RoZXIgb25lP1wiXG4gIH1cbl1cbjwvZmlsZT5cblxuPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gIGRlc2NyaWJlKCdTQ0UgZG9jIGRlbW8nLCBmdW5jdGlvbigpIHtcbiAgICBpdCgnc2hvdWxkIHNhbml0aXplIHVudHJ1c3RlZCB2YWx1ZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIGV4cGVjdChlbGVtZW50KCcuaHRtbENvbW1lbnQnKS5odG1sKCkpLnRvQmUoJzxzcGFuPklzIDxpPmFueW9uZTwvaT4gcmVhZGluZyB0aGlzPzwvc3Bhbj4nKTtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIE5PVCBzYW5pdGl6ZSBleHBsaWNpdGx5IHRydXN0ZWQgdmFsdWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICBleHBlY3QoZWxlbWVudCgnI2V4cGxpY2l0bHlUcnVzdGVkSHRtbCcpLmh0bWwoKSkudG9CZShcbiAgICAgICAgICAnPHNwYW4gb25tb3VzZW92ZXI9XCJ0aGlzLnRleHRDb250ZW50PSZxdW90O0V4cGxpY2l0bHkgdHJ1c3RlZCBIVE1MIGJ5cGFzc2VzICcgK1xuICAgICAgICAgICdzYW5pdGl6YXRpb24uJnF1b3Q7XCI+SG92ZXIgb3ZlciB0aGlzIHRleHQuPC9zcGFuPicpO1xuICAgIH0pO1xuICB9KTtcbjwvZmlsZT5cbjwvZXhhbXBsZT5cbiAqXG4gKlxuICpcbiAqICMjIENhbiBJIGRpc2FibGUgU0NFIGNvbXBsZXRlbHk/XG4gKlxuICogWWVzLCB5b3UgY2FuLiAgSG93ZXZlciwgdGhpcyBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gIFNDRSBnaXZlcyB5b3UgYSBsb3Qgb2Ygc2VjdXJpdHkgYmVuZWZpdHNcbiAqIGZvciBsaXR0bGUgY29kaW5nIG92ZXJoZWFkLiAgSXQgd2lsbCBiZSBtdWNoIGhhcmRlciB0byB0YWtlIGFuIFNDRSBkaXNhYmxlZCBhcHBsaWNhdGlvbiBhbmRcbiAqIGVpdGhlciBzZWN1cmUgaXQgb24geW91ciBvd24gb3IgZW5hYmxlIFNDRSBhdCBhIGxhdGVyIHN0YWdlLiAgSXQgbWlnaHQgbWFrZSBzZW5zZSB0byBkaXNhYmxlIFNDRVxuICogZm9yIGNhc2VzIHdoZXJlIHlvdSBoYXZlIGEgbG90IG9mIGV4aXN0aW5nIGNvZGUgdGhhdCB3YXMgd3JpdHRlbiBiZWZvcmUgU0NFIHdhcyBpbnRyb2R1Y2VkIGFuZFxuICogeW91J3JlIG1pZ3JhdGluZyB0aGVtIGEgbW9kdWxlIGF0IGEgdGltZS5cbiAqXG4gKiBUaGF0IHNhaWQsIGhlcmUncyBob3cgeW91IGNhbiBjb21wbGV0ZWx5IGRpc2FibGUgU0NFOlxuICpcbiAqIDxwcmUgY2xhc3M9XCJwcmV0dHlwcmludFwiPlxuICogICBhbmd1bGFyLm1vZHVsZSgnbXlBcHBXaXRoU2NlRGlzYWJsZWRteUFwcCcsIFtdKS5jb25maWcoZnVuY3Rpb24oJHNjZVByb3ZpZGVyKSB7XG4gKiAgICAgLy8gQ29tcGxldGVseSBkaXNhYmxlIFNDRS4gIEZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIG9ubHkhXG4gKiAgICAgLy8gRG8gbm90IHVzZSBpbiBuZXcgcHJvamVjdHMuXG4gKiAgICAgJHNjZVByb3ZpZGVyLmVuYWJsZWQoZmFsc2UpO1xuICogICB9KTtcbiAqIDwvcHJlPlxuICpcbiAqL1xuLyoganNoaW50IG1heGxlbjogMTAwICovXG5cbmZ1bmN0aW9uICRTY2VQcm92aWRlcigpIHtcbiAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgbmcuc2NlUHJvdmlkZXIjZW5hYmxlZFxuICAgKiBAbWV0aG9kT2YgbmcuJHNjZVByb3ZpZGVyXG4gICAqIEBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB2YWx1ZSBJZiBwcm92aWRlZCwgdGhlbiBlbmFibGVzL2Rpc2FibGVzIFNDRS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBTQ0UgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRW5hYmxlcy9kaXNhYmxlcyBTQ0UgYW5kIHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZW5hYmxlZCA9ICEhdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBlbmFibGVkO1xuICB9O1xuXG5cbiAgLyogRGVzaWduIG5vdGVzIG9uIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBTQ0UuXG4gICAqXG4gICAqIFRoZSBBUEkgY29udHJhY3QgZm9yIHRoZSBTQ0UgZGVsZWdhdGVcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBUaGUgU0NFIGRlbGVnYXRlIG9iamVjdCBtdXN0IHByb3ZpZGUgdGhlIGZvbGxvd2luZyAzIG1ldGhvZHM6XG4gICAqXG4gICAqIC0gdHJ1c3RBcyhjb250ZXh0RW51bSwgdmFsdWUpXG4gICAqICAgICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHRlbGwgdGhlIFNDRSBzZXJ2aWNlIHRoYXQgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIE9LIHRvIHVzZSBpbiB0aGVcbiAgICogICAgIGNvbnRleHRzIHNwZWNpZmllZCBieSBjb250ZXh0RW51bS4gIEl0IG11c3QgcmV0dXJuIGFuIG9iamVjdCB0aGF0IHdpbGwgYmUgYWNjZXB0ZWQgYnlcbiAgICogICAgIGdldFRydXN0ZWQoKSBmb3IgYSBjb21wYXRpYmxlIGNvbnRleHRFbnVtIGFuZCByZXR1cm4gdGhpcyB2YWx1ZS5cbiAgICpcbiAgICogLSB2YWx1ZU9mKHZhbHVlKVxuICAgKiAgICAgRm9yIHZhbHVlcyB0aGF0IHdlcmUgbm90IHByb2R1Y2VkIGJ5IHRydXN0QXMoKSwgcmV0dXJuIHRoZW0gYXMgaXMuICBGb3IgdmFsdWVzIHRoYXQgd2VyZVxuICAgKiAgICAgcHJvZHVjZWQgYnkgdHJ1c3RBcygpLCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQgdmFsdWUgdG8gdHJ1c3RBcy4gIEJhc2ljYWxseSwgaWZcbiAgICogICAgIHRydXN0QXMgaXMgd3JhcHBpbmcgdGhlIGdpdmVuIHZhbHVlcyBpbnRvIHNvbWUgdHlwZSwgdGhpcyBvcGVyYXRpb24gdW53cmFwcyBpdCB3aGVuIGdpdmVuXG4gICAqICAgICBzdWNoIGEgdmFsdWUuXG4gICAqXG4gICAqIC0gZ2V0VHJ1c3RlZChjb250ZXh0RW51bSwgdmFsdWUpXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIGEgdmFsdWUgdGhhdCBpcyBzYWZlIHRvIHVzZSBpbiB0aGUgY29udGV4dCBzcGVjaWZpZWQgYnlcbiAgICogICAgIGNvbnRleHRFbnVtIG9yIHRocm93IGFuZCBleGNlcHRpb24gb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIGNvbnRyYWN0IGRlbGliZXJhdGVseSBkb2VzIE5PVCBzdGF0ZSB0aGF0IHZhbHVlcyByZXR1cm5lZCBieSB0cnVzdEFzKCkgbXVzdCBiZVxuICAgKiBvcGFxdWUgb3Igd3JhcHBlZCBpbiBzb21lIGhvbGRlciBvYmplY3QuICBUaGF0IGhhcHBlbnMgdG8gYmUgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLiAgRm9yXG4gICAqIGluc3RhbmNlLCBhbiBpbXBsZW1lbnRhdGlvbiBjb3VsZCBtYWludGFpbiBhIHJlZ2lzdHJ5IG9mIGFsbCB0cnVzdGVkIG9iamVjdHMgYnkgY29udGV4dC4gIEluXG4gICAqIHN1Y2ggYSBjYXNlLCB0cnVzdEFzKCkgd291bGQgcmV0dXJuIHRoZSBzYW1lIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4uICBnZXRUcnVzdGVkKCkgd291bGRcbiAgICogcmV0dXJuIHRoZSBzYW1lIG9iamVjdCBwYXNzZWQgaW4gaWYgaXQgd2FzIGZvdW5kIGluIHRoZSByZWdpc3RyeSB1bmRlciBhIGNvbXBhdGlibGUgY29udGV4dCBvclxuICAgKiB0aHJvdyBhbiBleGNlcHRpb24gb3RoZXJ3aXNlLiAgQW4gaW1wbGVtZW50YXRpb24gbWlnaHQgb25seSB3cmFwIHZhbHVlcyBzb21lIG9mIHRoZSB0aW1lIGJhc2VkXG4gICAqIG9uIHNvbWUgY3JpdGVyaWEuICBnZXRUcnVzdGVkKCkgbWlnaHQgcmV0dXJuIGEgdmFsdWUgYW5kIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gZm9yIHNwZWNpYWxcbiAgICogY29uc3RhbnRzIG9yIG9iamVjdHMgZXZlbiBpZiBub3Qgd3JhcHBlZC4gIEFsbCBzdWNoIGltcGxlbWVudGF0aW9ucyBmdWxmaWxsIHRoaXMgY29udHJhY3QuXG4gICAqXG4gICAqXG4gICAqIEEgbm90ZSBvbiB0aGUgaW5oZXJpdGFuY2UgbW9kZWwgZm9yIFNDRSBjb250ZXh0c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogSSd2ZSB1c2VkIGluaGVyaXRhbmNlIGFuZCBtYWRlIFJFU09VUkNFX1VSTCB3cmFwcGVkIHR5cGVzIGEgc3VidHlwZSBvZiBVUkwgd3JhcHBlZCB0eXBlcy4gIFRoaXNcbiAgICogaXMgcHVyZWx5IGFuIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gICAqXG4gICAqIFRoZSBjb250cmFjdCBpcyBzaW1wbHkgdGhpczpcbiAgICpcbiAgICogICAgIGdldFRydXN0ZWQoJHNjZS5SRVNPVVJDRV9VUkwsIHZhbHVlKSBzdWNjZWVkaW5nIGltcGxpZXMgdGhhdCBnZXRUcnVzdGVkKCRzY2UuVVJMLCB2YWx1ZSlcbiAgICogICAgIHdpbGwgYWxzbyBzdWNjZWVkLlxuICAgKlxuICAgKiBJbmhlcml0YW5jZSBoYXBwZW5zIHRvIGNhcHR1cmUgdGhpcyBpbiBhIG5hdHVyYWwgd2F5LiAgSW4gc29tZSBmdXR1cmUsIHdlXG4gICAqIG1heSBub3QgdXNlIGluaGVyaXRhbmNlIGFueW1vcmUuICBUaGF0IGlzIE9LIGJlY2F1c2Ugbm8gY29kZSBvdXRzaWRlIG9mXG4gICAqIHNjZS5qcyBhbmQgc2NlU3BlY3MuanMgd291bGQgbmVlZCB0byBiZSBhd2FyZSBvZiB0aGlzIGRldGFpbC5cbiAgICovXG5cbiAgdGhpcy4kZ2V0ID0gWyckcGFyc2UnLCAnJHNuaWZmZXInLCAnJHNjZURlbGVnYXRlJywgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgJHBhcnNlLCAgICRzbmlmZmVyLCAgICRzY2VEZWxlZ2F0ZSkge1xuICAgIC8vIFByZXJlcTogRW5zdXJlIHRoYXQgd2UncmUgbm90IHJ1bm5pbmcgaW4gSUU4IHF1aXJrcyBtb2RlLiAgSW4gdGhhdCBtb2RlLCBJRSBhbGxvd3NcbiAgICAvLyB0aGUgXCJleHByZXNzaW9uKGphdmFzY3JpcHQgZXhwcmVzc2lvbilcIiBzeW50YXggd2hpY2ggaXMgaW5zZWN1cmUuXG4gICAgaWYgKGVuYWJsZWQgJiYgJHNuaWZmZXIubXNpZSAmJiAkc25pZmZlci5tc2llRG9jdW1lbnRNb2RlIDwgOCkge1xuICAgICAgdGhyb3cgJHNjZU1pbkVycignaWVxdWlya3MnLFxuICAgICAgICAnU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgZG9lcyBub3Qgc3VwcG9ydCBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9uIDwgOSBpbiBxdWlya3MgJyArXG4gICAgICAgICdtb2RlLiAgWW91IGNhbiBmaXggdGhpcyBieSBhZGRpbmcgdGhlIHRleHQgPCFkb2N0eXBlIGh0bWw+IHRvIHRoZSB0b3Agb2YgeW91ciBIVE1MICcgK1xuICAgICAgICAnZG9jdW1lbnQuICBTZWUgaHR0cDovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcuJHNjZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2NlID0gY29weShTQ0VfQ09OVEVYVFMpO1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICogQG5hbWUgbmcuc2NlI2lzRW5hYmxlZFxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIFNDRSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuICBJZiB5b3Ugd2FudCB0byBzZXQgdGhlIHZhbHVlLCB5b3VcbiAgICAgKiBoYXZlIHRvIGRvIGl0IGF0IG1vZHVsZSBjb25maWcgdGltZSBvbiB7QGxpbmsgbmcuJHNjZVByb3ZpZGVyICRzY2VQcm92aWRlcn0uXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIFNDRSBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIHNjZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlZDtcbiAgICB9O1xuICAgIHNjZS50cnVzdEFzID0gJHNjZURlbGVnYXRlLnRydXN0QXM7XG4gICAgc2NlLmdldFRydXN0ZWQgPSAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZDtcbiAgICBzY2UudmFsdWVPZiA9ICRzY2VEZWxlZ2F0ZS52YWx1ZU9mO1xuXG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICBzY2UudHJ1c3RBcyA9IHNjZS5nZXRUcnVzdGVkID0gZnVuY3Rpb24odHlwZSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgc2NlLnZhbHVlT2YgPSBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZVxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBDb252ZXJ0cyBBbmd1bGFyIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGludG8gYSBmdW5jdGlvbi4gIFRoaXMgaXMgbGlrZSB7QGxpbmtcbiAgICAgKiBuZy4kcGFyc2UgJHBhcnNlfSBhbmQgaXMgaWRlbnRpY2FsIHdoZW4gdGhlIGV4cHJlc3Npb24gaXMgYSBsaXRlcmFsIGNvbnN0YW50LiAgT3RoZXJ3aXNlLCBpdFxuICAgICAqIHdyYXBzIHRoZSBleHByZXNzaW9uIGluIGEgY2FsbCB0byB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX2dldFRydXN0ZWQgJHNjZS5nZXRUcnVzdGVkKCp0eXBlKixcbiAgICAgKiAqcmVzdWx0Kil9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUga2luZCBvZiBTQ0UgY29udGV4dCBpbiB3aGljaCB0aGlzIHJlc3VsdCB3aWxsIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gU3RyaW5nIGV4cHJlc3Npb24gdG8gY29tcGlsZS5cbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oY29udGV4dCwgbG9jYWxzKX0gYSBmdW5jdGlvbiB3aGljaCByZXByZXNlbnRzIHRoZSBjb21waWxlZCBleHByZXNzaW9uOlxuICAgICAqXG4gICAgICogICAgKiBgY29udGV4dGAg4oCTIGB7b2JqZWN0fWAg4oCTIGFuIG9iamVjdCBhZ2FpbnN0IHdoaWNoIGFueSBleHByZXNzaW9ucyBlbWJlZGRlZCBpbiB0aGUgc3RyaW5nc1xuICAgICAqICAgICAgYXJlIGV2YWx1YXRlZCBhZ2FpbnN0ICh0eXBpY2FsbHkgYSBzY29wZSBvYmplY3QpLlxuICAgICAqICAgICogYGxvY2Fsc2Ag4oCTIGB7b2JqZWN0PX1gIOKAkyBsb2NhbCB2YXJpYWJsZXMgY29udGV4dCBvYmplY3QsIHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyB2YWx1ZXMgaW5cbiAgICAgKiAgICAgIGBjb250ZXh0YC5cbiAgICAgKi9cbiAgICBzY2UucGFyc2VBcyA9IGZ1bmN0aW9uIHNjZVBhcnNlQXModHlwZSwgZXhwcikge1xuICAgICAgdmFyIHBhcnNlZCA9ICRwYXJzZShleHByKTtcbiAgICAgIGlmIChwYXJzZWQubGl0ZXJhbCAmJiBwYXJzZWQuY29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzY2VQYXJzZUFzVHJ1c3RlZChzZWxmLCBsb2NhbHMpIHtcbiAgICAgICAgICByZXR1cm4gc2NlLmdldFRydXN0ZWQodHlwZSwgcGFyc2VkKHNlbGYsIGxvY2FscykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSN0cnVzdEFzXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIERlbGVnYXRlcyB0byB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXNgfS4gIEFzIHN1Y2gsXG4gICAgICogcmV0dXJucyBhbiBvYmplY3R0aGF0IGlzIHRydXN0ZWQgYnkgYW5ndWxhciBmb3IgdXNlIGluIHNwZWNpZmllZCBzdHJpY3QgY29udGV4dHVhbFxuICAgICAqIGVzY2FwaW5nIGNvbnRleHRzIChzdWNoIGFzIG5nLWh0bWwtYmluZC11bnNhZmUsIG5nLWluY2x1ZGUsIGFueSBzcmMgYXR0cmlidXRlXG4gICAgICogaW50ZXJwb2xhdGlvbiwgYW55IGRvbSBldmVudCBiaW5kaW5nIGF0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIHN1Y2ggYXMgZm9yIG9uY2xpY2ssICBldGMuKVxuICAgICAqIHRoYXQgdXNlcyB0aGUgcHJvdmlkZWQgdmFsdWUuICBTZWUgKiB7QGxpbmsgbmcuJHNjZSAkc2NlfSBmb3IgZW5hYmxpbmcgc3RyaWN0IGNvbnRleHR1YWxcbiAgICAgKiBlc2NhcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBraW5kIG9mIGNvbnRleHQgaW4gd2hpY2ggdGhpcyB2YWx1ZSBpcyBzYWZlIGZvciB1c2UuICBlLmcuIHVybCxcbiAgICAgKiAgIHJlc291cmNlX3VybCwgaHRtbCwganMgYW5kIGNzcy5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdHJ1c3RlZC9zYWZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBBIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RhbmQgaW4gZm9yIHRoZSBwcm92aWRlZCBgdmFsdWVgIGluIHBsYWNlc1xuICAgICAqIHdoZXJlIEFuZ3VsYXIgZXhwZWN0cyBhICRzY2UudHJ1c3RBcygpIHJldHVybiB2YWx1ZS5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBuZy4kc2NlI3RydXN0QXNIdG1sXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS50cnVzdEFzSHRtbCh2YWx1ZSlgIOKGklxuICAgICAqICAgICB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXMoJHNjZS5IVE1MLCB2YWx1ZSlgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdHJ1c3RBcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX2dldFRydXN0ZWRIdG1sXG4gICAgICogICAgICRzY2UuZ2V0VHJ1c3RlZEh0bWwodmFsdWUpfSB0byBvYnRhaW4gdGhlIG9yaWdpbmFsIHZhbHVlLiAgKHByaXZpbGVnZWQgZGlyZWN0aXZlc1xuICAgICAqICAgICBvbmx5IGFjY2VwdCBleHByZXNzaW9ucyB0aGF0IGFyZSBlaXRoZXIgbGl0ZXJhbCBjb25zdGFudHMgb3IgYXJlIHRoZVxuICAgICAqICAgICByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjbWV0aG9kc190cnVzdEFzICRzY2UudHJ1c3RBc30uKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2UjdHJ1c3RBc1VybFxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UudHJ1c3RBc1VybCh2YWx1ZSlgIOKGklxuICAgICAqICAgICB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXMoJHNjZS5VUkwsIHZhbHVlKWB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0cnVzdEFzLlxuICAgICAqIEByZXR1cm5zIHsqfSBBbiBvYmplY3QgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHtAbGluayBuZy4kc2NlI21ldGhvZHNfZ2V0VHJ1c3RlZFVybFxuICAgICAqICAgICAkc2NlLmdldFRydXN0ZWRVcmwodmFsdWUpfSB0byBvYnRhaW4gdGhlIG9yaWdpbmFsIHZhbHVlLiAgKHByaXZpbGVnZWQgZGlyZWN0aXZlc1xuICAgICAqICAgICBvbmx5IGFjY2VwdCBleHByZXNzaW9ucyB0aGF0IGFyZSBlaXRoZXIgbGl0ZXJhbCBjb25zdGFudHMgb3IgYXJlIHRoZVxuICAgICAqICAgICByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjbWV0aG9kc190cnVzdEFzICRzY2UudHJ1c3RBc30uKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2UjdHJ1c3RBc1Jlc291cmNlVXJsXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS50cnVzdEFzUmVzb3VyY2VVcmwodmFsdWUpYCDihpJcbiAgICAgKiAgICAge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNtZXRob2RzX3RydXN0QXMgYCRzY2VEZWxlZ2F0ZS50cnVzdEFzKCRzY2UuUkVTT1VSQ0VfVVJMLCB2YWx1ZSlgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdHJ1c3RBcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX2dldFRydXN0ZWRSZXNvdXJjZVVybFxuICAgICAqICAgICAkc2NlLmdldFRydXN0ZWRSZXNvdXJjZVVybCh2YWx1ZSl9IHRvIG9idGFpbiB0aGUgb3JpZ2luYWwgdmFsdWUuICAocHJpdmlsZWdlZCBkaXJlY3RpdmVzXG4gICAgICogICAgIG9ubHkgYWNjZXB0IGV4cHJlc3Npb25zIHRoYXQgYXJlIGVpdGhlciBsaXRlcmFsIGNvbnN0YW50cyBvciBhcmUgdGhlIHJldHVyblxuICAgICAqICAgICB2YWx1ZSBvZiB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX3RydXN0QXMgJHNjZS50cnVzdEFzfS4pXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSN0cnVzdEFzSnNcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnRydXN0QXNKcyh2YWx1ZSlgIOKGklxuICAgICAqICAgICB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfdHJ1c3RBcyBgJHNjZURlbGVnYXRlLnRydXN0QXMoJHNjZS5KUywgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRydXN0QXMuXG4gICAgICogQHJldHVybnMgeyp9IEFuIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8ge0BsaW5rIG5nLiRzY2UjbWV0aG9kc19nZXRUcnVzdGVkSnNcbiAgICAgKiAgICAgJHNjZS5nZXRUcnVzdGVkSnModmFsdWUpfSB0byBvYnRhaW4gdGhlIG9yaWdpbmFsIHZhbHVlLiAgKHByaXZpbGVnZWQgZGlyZWN0aXZlc1xuICAgICAqICAgICBvbmx5IGFjY2VwdCBleHByZXNzaW9ucyB0aGF0IGFyZSBlaXRoZXIgbGl0ZXJhbCBjb25zdGFudHMgb3IgYXJlIHRoZVxuICAgICAqICAgICByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIG5nLiRzY2UjbWV0aG9kc190cnVzdEFzICRzY2UudHJ1c3RBc30uKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZFxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBEZWxlZ2F0ZXMgdG8ge0BsaW5rIG5nLiRzY2VEZWxlZ2F0ZSNtZXRob2RzX2dldFRydXN0ZWQgYCRzY2VEZWxlZ2F0ZS5nZXRUcnVzdGVkYH0uICBBcyBzdWNoLFxuICAgICAqIHRha2VzIHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX3RydXN0QXMgYCRzY2UudHJ1c3RBc2B9KCkgY2FsbCBhbmQgcmV0dXJucyB0aGVcbiAgICAgKiBvcmlnaW5hbGx5IHN1cHBsaWVkIHZhbHVlIGlmIHRoZSBxdWVyaWVkIGNvbnRleHQgdHlwZSBpcyBhIHN1cGVydHlwZSBvZiB0aGUgY3JlYXRlZCB0eXBlLlxuICAgICAqIElmIHRoaXMgY29uZGl0aW9uIGlzbid0IHNhdGlzZmllZCwgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBraW5kIG9mIGNvbnRleHQgaW4gd2hpY2ggdGhpcyB2YWx1ZSBpcyB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7Kn0gbWF5YmVUcnVzdGVkIFRoZSByZXN1bHQgb2YgYSBwcmlvciB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX3RydXN0QXMgYCRzY2UudHJ1c3RBc2B9XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgY2FsbC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoZSB3YXMgb3JpZ2luYWxseSBwcm92aWRlZCB0b1xuICAgICAqICAgICAgICAgICAgICB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX3RydXN0QXMgYCRzY2UudHJ1c3RBc2B9IGlmIHZhbGlkIGluIHRoaXMgY29udGV4dC5cbiAgICAgKiAgICAgICAgICAgICAgT3RoZXJ3aXNlLCB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZEh0bWxcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLmdldFRydXN0ZWRIdG1sKHZhbHVlKWAg4oaSXG4gICAgICogICAgIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjbWV0aG9kc19nZXRUcnVzdGVkIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZCgkc2NlLkhUTUwsIHZhbHVlKWB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXNzIHRvIGAkc2NlLmdldFRydXN0ZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkc2NlLmdldFRydXN0ZWQoJHNjZS5IVE1MLCB2YWx1ZSlgXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNnZXRUcnVzdGVkQ3NzXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5nZXRUcnVzdGVkQ3NzKHZhbHVlKWAg4oaSXG4gICAgICogICAgIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjbWV0aG9kc19nZXRUcnVzdGVkIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZCgkc2NlLkNTUywgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYCRzY2UuZ2V0VHJ1c3RlZGAuXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgYCRzY2UuZ2V0VHJ1c3RlZCgkc2NlLkNTUywgdmFsdWUpYFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2UjZ2V0VHJ1c3RlZFVybFxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UuZ2V0VHJ1c3RlZFVybCh2YWx1ZSlgIOKGklxuICAgICAqICAgICB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5VUkwsIHZhbHVlKWB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXNzIHRvIGAkc2NlLmdldFRydXN0ZWRgLlxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGAkc2NlLmdldFRydXN0ZWQoJHNjZS5VUkwsIHZhbHVlKWBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuZ2RvYyBtZXRob2RcbiAgICAgKiBAbmFtZSBuZy4kc2NlI2dldFRydXN0ZWRSZXNvdXJjZVVybFxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UuZ2V0VHJ1c3RlZFJlc291cmNlVXJsKHZhbHVlKWAg4oaSXG4gICAgICogICAgIHtAbGluayBuZy4kc2NlRGVsZWdhdGUjbWV0aG9kc19nZXRUcnVzdGVkIGAkc2NlRGVsZWdhdGUuZ2V0VHJ1c3RlZCgkc2NlLlJFU09VUkNFX1VSTCwgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYCRzY2VEZWxlZ2F0ZS5nZXRUcnVzdGVkYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBgJHNjZS5nZXRUcnVzdGVkKCRzY2UuUkVTT1VSQ0VfVVJMLCB2YWx1ZSlgXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNnZXRUcnVzdGVkSnNcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLmdldFRydXN0ZWRKcyh2YWx1ZSlgIOKGklxuICAgICAqICAgICB7QGxpbmsgbmcuJHNjZURlbGVnYXRlI21ldGhvZHNfZ2V0VHJ1c3RlZCBgJHNjZURlbGVnYXRlLmdldFRydXN0ZWQoJHNjZS5KUywgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYCRzY2UuZ2V0VHJ1c3RlZGAuXG4gICAgICogQHJldHVybnMgeyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgYCRzY2UuZ2V0VHJ1c3RlZCgkc2NlLkpTLCB2YWx1ZSlgXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZUFzSHRtbFxuICAgICAqIEBtZXRob2RPZiBuZy4kc2NlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTaG9ydGhhbmQgbWV0aG9kLiAgYCRzY2UucGFyc2VBc0h0bWwoZXhwcmVzc2lvbiBzdHJpbmcpYCDihpJcbiAgICAgKiAgICAge0BsaW5rIG5nLiRzY2UjbWV0aG9kc19wYXJzZSBgJHNjZS5wYXJzZUFzKCRzY2UuSFRNTCwgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcbiAgICAgKlxuICAgICAqICAgICogYGNvbnRleHRgIOKAkyBge29iamVjdH1gIOKAkyBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcbiAgICAgKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cbiAgICAgKiAgICAqIGBsb2NhbHNgIOKAkyBge29iamVjdD19YCDigJMgbG9jYWwgdmFyaWFibGVzIGNvbnRleHQgb2JqZWN0LCB1c2VmdWwgZm9yIG92ZXJyaWRpbmcgdmFsdWVzIGluXG4gICAgICogICAgICBgY29udGV4dGAuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZUFzQ3NzXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzQ3NzKHZhbHVlKWAg4oaSXG4gICAgICogICAgIHtAbGluayBuZy4kc2NlI21ldGhvZHNfcGFyc2UgYCRzY2UucGFyc2VBcygkc2NlLkNTUywgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcbiAgICAgKlxuICAgICAqICAgICogYGNvbnRleHRgIOKAkyBge29iamVjdH1gIOKAkyBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcbiAgICAgKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cbiAgICAgKiAgICAqIGBsb2NhbHNgIOKAkyBge29iamVjdD19YCDigJMgbG9jYWwgdmFyaWFibGVzIGNvbnRleHQgb2JqZWN0LCB1c2VmdWwgZm9yIG92ZXJyaWRpbmcgdmFsdWVzIGluXG4gICAgICogICAgICBgY29udGV4dGAuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZUFzVXJsXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzVXJsKHZhbHVlKWAg4oaSXG4gICAgICogICAgIHtAbGluayBuZy4kc2NlI21ldGhvZHNfcGFyc2UgYCRzY2UucGFyc2VBcygkc2NlLlVSTCwgdmFsdWUpYH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFN0cmluZyBleHByZXNzaW9uIHRvIGNvbXBpbGUuXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKGNvbnRleHQsIGxvY2Fscyl9IGEgZnVuY3Rpb24gd2hpY2ggcmVwcmVzZW50cyB0aGUgY29tcGlsZWQgZXhwcmVzc2lvbjpcbiAgICAgKlxuICAgICAqICAgICogYGNvbnRleHRgIOKAkyBge29iamVjdH1gIOKAkyBhbiBvYmplY3QgYWdhaW5zdCB3aGljaCBhbnkgZXhwcmVzc2lvbnMgZW1iZWRkZWQgaW4gdGhlIHN0cmluZ3NcbiAgICAgKiAgICAgIGFyZSBldmFsdWF0ZWQgYWdhaW5zdCAodHlwaWNhbGx5IGEgc2NvcGUgb2JqZWN0KS5cbiAgICAgKiAgICAqIGBsb2NhbHNgIOKAkyBge29iamVjdD19YCDigJMgbG9jYWwgdmFyaWFibGVzIGNvbnRleHQgb2JqZWN0LCB1c2VmdWwgZm9yIG92ZXJyaWRpbmcgdmFsdWVzIGluXG4gICAgICogICAgICBgY29udGV4dGAuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2MgbWV0aG9kXG4gICAgICogQG5hbWUgbmcuJHNjZSNwYXJzZUFzUmVzb3VyY2VVcmxcbiAgICAgKiBAbWV0aG9kT2YgbmcuJHNjZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2hvcnRoYW5kIG1ldGhvZC4gIGAkc2NlLnBhcnNlQXNSZXNvdXJjZVVybCh2YWx1ZSlgIOKGklxuICAgICAqICAgICB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX3BhcnNlIGAkc2NlLnBhcnNlQXMoJHNjZS5SRVNPVVJDRV9VUkwsIHZhbHVlKWB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XG4gICAgICpcbiAgICAgKiAgICAqIGBjb250ZXh0YCDigJMgYHtvYmplY3R9YCDigJMgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXG4gICAgICogICAgICBhcmUgZXZhbHVhdGVkIGFnYWluc3QgKHR5cGljYWxseSBhIHNjb3BlIG9iamVjdCkuXG4gICAgICogICAgKiBgbG9jYWxzYCDigJMgYHtvYmplY3Q9fWAg4oCTIGxvY2FsIHZhcmlhYmxlcyBjb250ZXh0IG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpblxuICAgICAqICAgICAgYGNvbnRleHRgLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG1ldGhvZFxuICAgICAqIEBuYW1lIG5nLiRzY2UjcGFyc2VBc0pzXG4gICAgICogQG1ldGhvZE9mIG5nLiRzY2VcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNob3J0aGFuZCBtZXRob2QuICBgJHNjZS5wYXJzZUFzSnModmFsdWUpYCDihpJcbiAgICAgKiAgICAge0BsaW5rIG5nLiRzY2UjbWV0aG9kc19wYXJzZSBgJHNjZS5wYXJzZUFzKCRzY2UuSlMsIHZhbHVlKWB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBTdHJpbmcgZXhwcmVzc2lvbiB0byBjb21waWxlLlxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihjb250ZXh0LCBsb2NhbHMpfSBhIGZ1bmN0aW9uIHdoaWNoIHJlcHJlc2VudHMgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb246XG4gICAgICpcbiAgICAgKiAgICAqIGBjb250ZXh0YCDigJMgYHtvYmplY3R9YCDigJMgYW4gb2JqZWN0IGFnYWluc3Qgd2hpY2ggYW55IGV4cHJlc3Npb25zIGVtYmVkZGVkIGluIHRoZSBzdHJpbmdzXG4gICAgICogICAgICBhcmUgZXZhbHVhdGVkIGFnYWluc3QgKHR5cGljYWxseSBhIHNjb3BlIG9iamVjdCkuXG4gICAgICogICAgKiBgbG9jYWxzYCDigJMgYHtvYmplY3Q9fWAg4oCTIGxvY2FsIHZhcmlhYmxlcyBjb250ZXh0IG9iamVjdCwgdXNlZnVsIGZvciBvdmVycmlkaW5nIHZhbHVlcyBpblxuICAgICAqICAgICAgYGNvbnRleHRgLlxuICAgICAqL1xuXG4gICAgLy8gU2hvcnRoYW5kIGRlbGVnYXRpb25zLlxuICAgIHZhciBwYXJzZSA9IHNjZS5wYXJzZUFzLFxuICAgICAgICBnZXRUcnVzdGVkID0gc2NlLmdldFRydXN0ZWQsXG4gICAgICAgIHRydXN0QXMgPSBzY2UudHJ1c3RBcztcblxuICAgIGZvckVhY2goU0NFX0NPTlRFWFRTLCBmdW5jdGlvbiAoZW51bVZhbHVlLCBuYW1lKSB7XG4gICAgICB2YXIgbE5hbWUgPSBsb3dlcmNhc2UobmFtZSk7XG4gICAgICBzY2VbY2FtZWxDYXNlKFwicGFyc2VfYXNfXCIgKyBsTmFtZSldID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlKGVudW1WYWx1ZSwgZXhwcik7XG4gICAgICB9O1xuICAgICAgc2NlW2NhbWVsQ2FzZShcImdldF90cnVzdGVkX1wiICsgbE5hbWUpXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0VHJ1c3RlZChlbnVtVmFsdWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBzY2VbY2FtZWxDYXNlKFwidHJ1c3RfYXNfXCIgKyBsTmFtZSldID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVzdEFzKGVudW1WYWx1ZSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzY2U7XG4gIH1dO1xufVxuXG4vKipcbiAqICEhISBUaGlzIGlzIGFuIHVuZG9jdW1lbnRlZCBcInByaXZhdGVcIiBzZXJ2aWNlICEhIVxuICpcbiAqIEBuYW1lIG5nLiRzbmlmZmVyXG4gKiBAcmVxdWlyZXMgJHdpbmRvd1xuICogQHJlcXVpcmVzICRkb2N1bWVudFxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGlzdG9yeSBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgaHRtbDUgaGlzdG9yeSBhcGkgP1xuICogQHByb3BlcnR5IHtib29sZWFufSBoYXNoY2hhbmdlIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBoYXNoY2hhbmdlIGV2ZW50ID9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdHJhbnNpdGlvbnMgRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IENTUyB0cmFuc2l0aW9uIGV2ZW50cyA/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFuaW1hdGlvbnMgRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IENTUyBhbmltYXRpb24gZXZlbnRzID9cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgaXMgdmVyeSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGVzdGluZyBicm93c2VyJ3MgZmVhdHVyZXMuXG4gKi9cbmZ1bmN0aW9uICRTbmlmZmVyUHJvdmlkZXIoKSB7XG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckZG9jdW1lbnQnLCBmdW5jdGlvbigkd2luZG93LCAkZG9jdW1lbnQpIHtcbiAgICB2YXIgZXZlbnRTdXBwb3J0ID0ge30sXG4gICAgICAgIGFuZHJvaWQgPVxuICAgICAgICAgIGludCgoL2FuZHJvaWQgKFxcZCspLy5leGVjKGxvd2VyY2FzZSgoJHdpbmRvdy5uYXZpZ2F0b3IgfHwge30pLnVzZXJBZ2VudCkpIHx8IFtdKVsxXSksXG4gICAgICAgIGJveGVlID0gL0JveGVlL2kudGVzdCgoJHdpbmRvdy5uYXZpZ2F0b3IgfHwge30pLnVzZXJBZ2VudCksXG4gICAgICAgIGRvY3VtZW50ID0gJGRvY3VtZW50WzBdIHx8IHt9LFxuICAgICAgICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUsXG4gICAgICAgIHZlbmRvclByZWZpeCxcbiAgICAgICAgdmVuZG9yUmVnZXggPSAvXihNb3p8d2Via2l0fE98bXMpKD89W0EtWl0pLyxcbiAgICAgICAgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LnN0eWxlLFxuICAgICAgICB0cmFuc2l0aW9ucyA9IGZhbHNlLFxuICAgICAgICBhbmltYXRpb25zID0gZmFsc2UsXG4gICAgICAgIG1hdGNoO1xuXG4gICAgaWYgKGJvZHlTdHlsZSkge1xuICAgICAgZm9yKHZhciBwcm9wIGluIGJvZHlTdHlsZSkge1xuICAgICAgICBpZihtYXRjaCA9IHZlbmRvclJlZ2V4LmV4ZWMocHJvcCkpIHtcbiAgICAgICAgICB2ZW5kb3JQcmVmaXggPSBtYXRjaFswXTtcbiAgICAgICAgICB2ZW5kb3JQcmVmaXggPSB2ZW5kb3JQcmVmaXguc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyB2ZW5kb3JQcmVmaXguc3Vic3RyKDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCF2ZW5kb3JQcmVmaXgpIHtcbiAgICAgICAgdmVuZG9yUHJlZml4ID0gKCdXZWJraXRPcGFjaXR5JyBpbiBib2R5U3R5bGUpICYmICd3ZWJraXQnO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2l0aW9ucyA9ICEhKCgndHJhbnNpdGlvbicgaW4gYm9keVN0eWxlKSB8fCAodmVuZG9yUHJlZml4ICsgJ1RyYW5zaXRpb24nIGluIGJvZHlTdHlsZSkpO1xuICAgICAgYW5pbWF0aW9ucyAgPSAhISgoJ2FuaW1hdGlvbicgaW4gYm9keVN0eWxlKSB8fCAodmVuZG9yUHJlZml4ICsgJ0FuaW1hdGlvbicgaW4gYm9keVN0eWxlKSk7XG5cbiAgICAgIGlmIChhbmRyb2lkICYmICghdHJhbnNpdGlvbnN8fCFhbmltYXRpb25zKSkge1xuICAgICAgICB0cmFuc2l0aW9ucyA9IGlzU3RyaW5nKGRvY3VtZW50LmJvZHkuc3R5bGUud2Via2l0VHJhbnNpdGlvbik7XG4gICAgICAgIGFuaW1hdGlvbnMgPSBpc1N0cmluZyhkb2N1bWVudC5ib2R5LnN0eWxlLndlYmtpdEFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgLy8gQW5kcm9pZCBoYXMgaGlzdG9yeS5wdXNoU3RhdGUsIGJ1dCBpdCBkb2VzIG5vdCB1cGRhdGUgbG9jYXRpb24gY29ycmVjdGx5XG4gICAgICAvLyBzbyBsZXQncyBub3QgdXNlIHRoZSBoaXN0b3J5IEFQSSBhdCBhbGwuXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTE3NDcxXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2lzc3Vlcy85MDRcblxuICAgICAgLy8gb2xkZXIgd2ViaXQgYnJvd3NlciAoNTMzLjkpIG9uIEJveGVlIGJveCBoYXMgZXhhY3RseSB0aGUgc2FtZSBwcm9ibGVtIGFzIEFuZHJvaWQgaGFzXG4gICAgICAvLyBzbyBsZXQncyBub3QgdXNlIHRoZSBoaXN0b3J5IEFQSSBhbHNvXG4gICAgICAvLyBXZSBhcmUgcHVycG9zZWZ1bGx5IHVzaW5nIGAhKGFuZHJvaWQgPCA0KWAgdG8gY292ZXIgdGhlIGNhc2Ugd2hlbiBgYW5kcm9pZGAgaXMgdW5kZWZpbmVkXG4gICAgICAvLyBqc2hpbnQgLVcwMThcbiAgICAgIGhpc3Rvcnk6ICEhKCR3aW5kb3cuaGlzdG9yeSAmJiAkd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlICYmICEoYW5kcm9pZCA8IDQpICYmICFib3hlZSksXG4gICAgICAvLyBqc2hpbnQgK1cwMThcbiAgICAgIGhhc2hjaGFuZ2U6ICdvbmhhc2hjaGFuZ2UnIGluICR3aW5kb3cgJiZcbiAgICAgICAgICAgICAgICAgIC8vIElFOCBjb21wYXRpYmxlIG1vZGUgbGllc1xuICAgICAgICAgICAgICAgICAgKCFkb2N1bWVudE1vZGUgfHwgZG9jdW1lbnRNb2RlID4gNyksXG4gICAgICBoYXNFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gSUU5IGltcGxlbWVudHMgJ2lucHV0JyBldmVudCBpdCdzIHNvIGZ1YmFyZWQgdGhhdCB3ZSByYXRoZXIgcHJldGVuZCB0aGF0IGl0IGRvZXNuJ3QgaGF2ZVxuICAgICAgICAvLyBpdC4gSW4gcGFydGljdWxhciB0aGUgZXZlbnQgaXMgbm90IGZpcmVkIHdoZW4gYmFja3NwYWNlIG9yIGRlbGV0ZSBrZXkgYXJlIHByZXNzZWQgb3JcbiAgICAgICAgLy8gd2hlbiBjdXQgb3BlcmF0aW9uIGlzIHBlcmZvcm1lZC5cbiAgICAgICAgaWYgKGV2ZW50ID09ICdpbnB1dCcgJiYgbXNpZSA9PSA5KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGV2ZW50U3VwcG9ydFtldmVudF0pKSB7XG4gICAgICAgICAgdmFyIGRpdkVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGV2ZW50U3VwcG9ydFtldmVudF0gPSAnb24nICsgZXZlbnQgaW4gZGl2RWxtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50U3VwcG9ydFtldmVudF07XG4gICAgICB9LFxuICAgICAgY3NwOiBjc3AoKSxcbiAgICAgIHZlbmRvclByZWZpeDogdmVuZG9yUHJlZml4LFxuICAgICAgdHJhbnNpdGlvbnMgOiB0cmFuc2l0aW9ucyxcbiAgICAgIGFuaW1hdGlvbnMgOiBhbmltYXRpb25zLFxuICAgICAgYW5kcm9pZDogYW5kcm9pZCxcbiAgICAgIG1zaWUgOiBtc2llLFxuICAgICAgbXNpZURvY3VtZW50TW9kZTogZG9jdW1lbnRNb2RlXG4gICAgfTtcbiAgfV07XG59XG5cbmZ1bmN0aW9uICRUaW1lb3V0UHJvdmlkZXIoKSB7XG4gIHRoaXMuJGdldCA9IFsnJHJvb3RTY29wZScsICckYnJvd3NlcicsICckcScsICckZXhjZXB0aW9uSGFuZGxlcicsXG4gICAgICAgZnVuY3Rpb24oJHJvb3RTY29wZSwgICAkYnJvd3NlciwgICAkcSwgICAkZXhjZXB0aW9uSGFuZGxlcikge1xuICAgIHZhciBkZWZlcnJlZHMgPSB7fTtcblxuXG4gICAgIC8qKlxuICAgICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICAgICogQG5hbWUgbmcuJHRpbWVvdXRcbiAgICAgICogQHJlcXVpcmVzICRicm93c2VyXG4gICAgICAqXG4gICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgKiBBbmd1bGFyJ3Mgd3JhcHBlciBmb3IgYHdpbmRvdy5zZXRUaW1lb3V0YC4gVGhlIGBmbmAgZnVuY3Rpb24gaXMgd3JhcHBlZCBpbnRvIGEgdHJ5L2NhdGNoXG4gICAgICAqIGJsb2NrIGFuZCBkZWxlZ2F0ZXMgYW55IGV4Y2VwdGlvbnMgdG9cbiAgICAgICoge0BsaW5rIG5nLiRleGNlcHRpb25IYW5kbGVyICRleGNlcHRpb25IYW5kbGVyfSBzZXJ2aWNlLlxuICAgICAgKlxuICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHJlZ2lzdGVyaW5nIGEgdGltZW91dCBmdW5jdGlvbiBpcyBhIHByb21pc2UsIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgd2hlblxuICAgICAgKiB0aGUgdGltZW91dCBpcyByZWFjaGVkIGFuZCB0aGUgdGltZW91dCBmdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAgICAgICpcbiAgICAgICogVG8gY2FuY2VsIGEgdGltZW91dCByZXF1ZXN0LCBjYWxsIGAkdGltZW91dC5jYW5jZWwocHJvbWlzZSlgLlxuICAgICAgKlxuICAgICAgKiBJbiB0ZXN0cyB5b3UgY2FuIHVzZSB7QGxpbmsgbmdNb2NrLiR0aW1lb3V0IGAkdGltZW91dC5mbHVzaCgpYH0gdG9cbiAgICAgICogc3luY2hyb25vdXNseSBmbHVzaCB0aGUgcXVldWUgb2YgZGVmZXJyZWQgZnVuY3Rpb25zLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuIEEgZnVuY3Rpb24sIHdob3NlIGV4ZWN1dGlvbiBzaG91bGQgYmUgZGVsYXllZC5cbiAgICAgICogQHBhcmFtIHtudW1iZXI9fSBbZGVsYXk9MF0gRGVsYXkgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbaW52b2tlQXBwbHk9dHJ1ZV0gSWYgc2V0IHRvIGBmYWxzZWAgc2tpcHMgbW9kZWwgZGlydHkgY2hlY2tpbmcsIG90aGVyd2lzZVxuICAgICAgKiAgIHdpbGwgaW52b2tlIGBmbmAgd2l0aGluIHRoZSB7QGxpbmsgbmcuJHJvb3RTY29wZS5TY29wZSNtZXRob2RzXyRhcHBseSAkYXBwbHl9IGJsb2NrLlxuICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2hlbiB0aGUgdGltZW91dCBpcyByZWFjaGVkLiBUaGUgdmFsdWUgdGhpc1xuICAgICAgKiAgIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoIGlzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGBmbmAgZnVuY3Rpb24uXG4gICAgICAqIFxuICAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lb3V0KGZuLCBkZWxheSwgaW52b2tlQXBwbHkpIHtcbiAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCksXG4gICAgICAgICAgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgc2tpcEFwcGx5ID0gKGlzRGVmaW5lZChpbnZva2VBcHBseSkgJiYgIWludm9rZUFwcGx5KSxcbiAgICAgICAgICB0aW1lb3V0SWQ7XG5cbiAgICAgIHRpbWVvdXRJZCA9ICRicm93c2VyLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlKTtcbiAgICAgICAgICAkZXhjZXB0aW9uSGFuZGxlcihlKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBkZWxldGUgZGVmZXJyZWRzW3Byb21pc2UuJCR0aW1lb3V0SWRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFza2lwQXBwbHkpICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICB9LCBkZWxheSk7XG5cbiAgICAgIHByb21pc2UuJCR0aW1lb3V0SWQgPSB0aW1lb3V0SWQ7XG4gICAgICBkZWZlcnJlZHNbdGltZW91dElkXSA9IGRlZmVycmVkO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cblxuICAgICAvKipcbiAgICAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAgICAqIEBuYW1lIG5nLiR0aW1lb3V0I2NhbmNlbFxuICAgICAgKiBAbWV0aG9kT2YgbmcuJHRpbWVvdXRcbiAgICAgICpcbiAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAqIENhbmNlbHMgYSB0YXNrIGFzc29jaWF0ZWQgd2l0aCB0aGUgYHByb21pc2VgLiBBcyBhIHJlc3VsdCBvZiB0aGlzLCB0aGUgcHJvbWlzZSB3aWxsIGJlXG4gICAgICAqIHJlc29sdmVkIHdpdGggYSByZWplY3Rpb24uXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7UHJvbWlzZT19IHByb21pc2UgUHJvbWlzZSByZXR1cm5lZCBieSB0aGUgYCR0aW1lb3V0YCBmdW5jdGlvbi5cbiAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0YXNrIGhhc24ndCBleGVjdXRlZCB5ZXQgYW5kIHdhcyBzdWNjZXNzZnVsbHlcbiAgICAgICogICBjYW5jZWxlZC5cbiAgICAgICovXG4gICAgdGltZW91dC5jYW5jZWwgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZSAmJiBwcm9taXNlLiQkdGltZW91dElkIGluIGRlZmVycmVkcykge1xuICAgICAgICBkZWZlcnJlZHNbcHJvbWlzZS4kJHRpbWVvdXRJZF0ucmVqZWN0KCdjYW5jZWxlZCcpO1xuICAgICAgICBkZWxldGUgZGVmZXJyZWRzW3Byb21pc2UuJCR0aW1lb3V0SWRdO1xuICAgICAgICByZXR1cm4gJGJyb3dzZXIuZGVmZXIuY2FuY2VsKHByb21pc2UuJCR0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGltZW91dDtcbiAgfV07XG59XG5cbi8vIE5PVEU6ICBUaGUgdXNhZ2Ugb2Ygd2luZG93IGFuZCBkb2N1bWVudCBpbnN0ZWFkIG9mICR3aW5kb3cgYW5kICRkb2N1bWVudCBoZXJlIGlzXG4vLyBkZWxpYmVyYXRlLiAgVGhpcyBzZXJ2aWNlIGRlcGVuZHMgb24gdGhlIHNwZWNpZmljIGJlaGF2aW9yIG9mIGFuY2hvciBub2RlcyBjcmVhdGVkIGJ5IHRoZVxuLy8gYnJvd3NlciAocmVzb2x2aW5nIGFuZCBwYXJzaW5nIFVSTHMpIHRoYXQgaXMgdW5saWtlbHkgdG8gYmUgcHJvdmlkZWQgYnkgbW9jayBvYmplY3RzIGFuZFxuLy8gY2F1c2UgdXMgdG8gYnJlYWsgdGVzdHMuICBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgYnJvd3NlciByZXNvbHZlcyBhIFVSTCBmb3IgWEhSLCBpdFxuLy8gZG9lc24ndCBrbm93IGFib3V0IG1vY2tlZCBsb2NhdGlvbnMgYW5kIHJlc29sdmVzIFVSTHMgdG8gdGhlIHJlYWwgZG9jdW1lbnQgLSB3aGljaCBpc1xuLy8gZXhhY3RseSB0aGUgYmVoYXZpb3IgbmVlZGVkIGhlcmUuICBUaGVyZSBpcyBsaXR0bGUgdmFsdWUgaXMgbW9ja2luZyB0aGVzZSBvdXQgZm9yIHRoaXNcbi8vIHNlcnZpY2UuXG52YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbnZhciBvcmlnaW5VcmwgPSB1cmxSZXNvbHZlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cnVlKTtcblxuXG4vKipcbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBOb3RlcyBmb3Igbm9uLUlFIGJyb3dzZXJzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBc3NpZ25pbmcgYSBVUkwgdG8gdGhlIGhyZWYgcHJvcGVydHkgb2YgYW4gYW5jaG9yIERPTSBub2RlLCBldmVuIG9uZSBhdHRhY2hlZCB0byB0aGUgRE9NLFxuICogcmVzdWx0cyBib3RoIGluIHRoZSBub3JtYWxpemluZyBhbmQgcGFyc2luZyBvZiB0aGUgVVJMLiAgTm9ybWFsaXppbmcgbWVhbnMgdGhhdCBhIHJlbGF0aXZlXG4gKiBVUkwgd2lsbCBiZSByZXNvbHZlZCBpbnRvIGFuIGFic29sdXRlIFVSTCBpbiB0aGUgY29udGV4dCBvZiB0aGUgYXBwbGljYXRpb24gZG9jdW1lbnQuXG4gKiBQYXJzaW5nIG1lYW5zIHRoYXQgdGhlIGFuY2hvciBub2RlJ3MgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0LCBwYXRobmFtZSBhbmQgcmVsYXRlZFxuICogcHJvcGVydGllcyBhcmUgYWxsIHBvcHVsYXRlZCB0byByZWZsZWN0IHRoZSBub3JtYWxpemVkIFVSTC4gIFRoaXMgYXBwcm9hY2ggaGFzIHdpZGVcbiAqIGNvbXBhdGliaWxpdHkgLSBTYWZhcmkgMSssIE1vemlsbGEgMSssIE9wZXJhIDcrLGUgZXRjLiAgU2VlXG4gKiBodHRwOi8vd3d3LmFwdGFuYS5jb20vcmVmZXJlbmNlL2h0bWwvYXBpL0hUTUxBbmNob3JFbGVtZW50Lmh0bWxcbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBOb3RlcyBmb3IgSUVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogSUUgPj0gOCBhbmQgPD0gMTAgbm9ybWFsaXplcyB0aGUgVVJMIHdoZW4gYXNzaWduZWQgdG8gdGhlIGFuY2hvciBub2RlIHNpbWlsYXIgdG8gdGhlIG90aGVyXG4gKiBicm93c2Vycy4gIEhvd2V2ZXIsIHRoZSBwYXJzZWQgY29tcG9uZW50cyB3aWxsIG5vdCBiZSBzZXQgaWYgdGhlIFVSTCBhc3NpZ25lZCBkaWQgbm90IHNwZWNpZnlcbiAqIHRoZW0uICAoZS5nLiBpZiB5b3UgYXNzaWduIGEuaHJlZiA9IFwiZm9vXCIsIHRoZW4gYS5wcm90b2NvbCwgYS5ob3N0LCBldGMuIHdpbGwgYmUgZW1wdHkuKSAgV2VcbiAqIHdvcmsgYXJvdW5kIHRoYXQgYnkgcGVyZm9ybWluZyB0aGUgcGFyc2luZyBpbiBhIDJuZCBzdGVwIGJ5IHRha2luZyBhIHByZXZpb3VzbHkgbm9ybWFsaXplZFxuICogVVJMIChlLmcuIGJ5IGFzc2lnbmluZyB0byBhLmhyZWYpIGFuZCBhc3NpZ25pbmcgaXQgYS5ocmVmIGFnYWluLiAgVGhpcyBjb3JyZWN0bHkgcG9wdWxhdGVzIHRoZVxuICogcHJvcGVydGllcyBzdWNoIGFzIHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCwgZXRjLlxuICpcbiAqIElFNyBkb2VzIG5vdCBub3JtYWxpemUgdGhlIFVSTCB3aGVuIGFzc2lnbmVkIHRvIGFuIGFuY2hvciBub2RlLiAgKEFwcGFyZW50bHksIGl0IGRvZXMsIGlmIG9uZVxuICogdXNlcyB0aGUgaW5uZXIgSFRNTCBhcHByb2FjaCB0byBhc3NpZ24gdGhlIFVSTCBhcyBwYXJ0IG9mIGFuIEhUTUwgc25pcHBldCAtXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NzI3MjkpICBIb3dldmVyLCBzZXR0aW5nIGltZ1tzcmNdIGRvZXMgbm9ybWFsaXplIHRoZSBVUkwuXG4gKiBVbmZvcnR1bmF0ZWx5LCBzZXR0aW5nIGltZ1tzcmNdIHRvIHNvbWV0aGluZyBsaWtlIFwiamF2YXNjcmlwdDpmb29cIiBvbiBJRSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICogU2luY2UgdGhlIHByaW1hcnkgdXNhZ2UgZm9yIG5vcm1hbGl6aW5nIFVSTHMgaXMgdG8gc2FuaXRpemUgc3VjaCBVUkxzLCB3ZSBjYW4ndCB1c2UgdGhhdFxuICogbWV0aG9kIGFuZCBJRSA8IDggaXMgdW5zdXBwb3J0ZWQuXG4gKlxuICogUmVmZXJlbmNlczpcbiAqICAgaHR0cDovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEFuY2hvckVsZW1lbnRcbiAqICAgaHR0cDovL3d3dy5hcHRhbmEuY29tL3JlZmVyZW5jZS9odG1sL2FwaS9IVE1MQW5jaG9yRWxlbWVudC5odG1sXG4gKiAgIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMjkwMlxuICogICBodHRwOi8vamFtZXMucGFkb2xzZXkuY29tL2phdmFzY3JpcHQvcGFyc2luZy11cmxzLXdpdGgtdGhlLWRvbS9cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWQuXG4gKiBAZGVzY3JpcHRpb24gTm9ybWFsaXplcyBhbmQgcGFyc2VzIGEgVVJMLlxuICogQHJldHVybnMge29iamVjdH0gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBVUkwgYXMgYSBkaWN0aW9uYXJ5LlxuICpcbiAqICAgfCBtZW1iZXIgbmFtZSAgIHwgRGVzY3JpcHRpb24gICAgfFxuICogICB8LS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS18XG4gKiAgIHwgaHJlZiAgICAgICAgICB8IEEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBwcm92aWRlZCBVUkwgaWYgaXQgd2FzIG5vdCBhbiBhYnNvbHV0ZSBVUkwgfFxuICogICB8IHByb3RvY29sICAgICAgfCBUaGUgcHJvdG9jb2wgaW5jbHVkaW5nIHRoZSB0cmFpbGluZyBjb2xvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgfCBob3N0ICAgICAgICAgIHwgVGhlIGhvc3QgYW5kIHBvcnQgKGlmIHRoZSBwb3J0IGlzIG5vbi1kZWZhdWx0KSBvZiB0aGUgbm9ybWFsaXplZFVybCAgICB8XG4gKiAgIHwgc2VhcmNoICAgICAgICB8IFRoZSBzZWFyY2ggcGFyYW1zLCBtaW51cyB0aGUgcXVlc3Rpb24gbWFyayAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICB8IGhhc2ggICAgICAgICAgfCBUaGUgaGFzaCBzdHJpbmcsIG1pbnVzIHRoZSBoYXNoIHN5bWJvbFxuICogICB8IGhvc3RuYW1lICAgICAgfCBUaGUgaG9zdG5hbWVcbiAqICAgfCBwb3J0ICAgICAgICAgIHwgVGhlIHBvcnQsIHdpdGhvdXQgXCI6XCJcbiAqICAgfCBwYXRobmFtZSAgICAgIHwgVGhlIHBhdGhuYW1lLCBiZWdpbm5pbmcgd2l0aCBcIi9cIlxuICpcbiAqL1xuZnVuY3Rpb24gdXJsUmVzb2x2ZSh1cmwsIGJhc2UpIHtcbiAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgaWYgKG1zaWUpIHtcbiAgICAvLyBOb3JtYWxpemUgYmVmb3JlIHBhcnNlLiAgUmVmZXIgSW1wbGVtZW50YXRpb24gTm90ZXMgb24gd2h5IHRoaXMgaXNcbiAgICAvLyBkb25lIGluIHR3byBzdGVwcyBvbiBJRS5cbiAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGhyZWYpO1xuICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICB9XG5cbiAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICByZXR1cm4ge1xuICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpXG4gICAgICA/IHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICA6ICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gIH07XG59XG5cbi8qKlxuICogUGFyc2UgYSByZXF1ZXN0IFVSTCBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHNhbWUtb3JpZ2luIHJlcXVlc3QgYXMgdGhlIGFwcGxpY2F0aW9uIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVxdWVzdFVybCBUaGUgdXJsIG9mIHRoZSByZXF1ZXN0IGFzIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSByZXNvbHZlZFxuICogb3IgYSBwYXJzZWQgVVJMIG9iamVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGZvciB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGFwcGxpY2F0aW9uIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiB1cmxJc1NhbWVPcmlnaW4ocmVxdWVzdFVybCkge1xuICB2YXIgcGFyc2VkID0gKGlzU3RyaW5nKHJlcXVlc3RVcmwpKSA/IHVybFJlc29sdmUocmVxdWVzdFVybCkgOiByZXF1ZXN0VXJsO1xuICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVXJsLnByb3RvY29sICYmXG4gICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVybC5ob3N0KTtcbn1cblxuLyoqXG4gKiBAbmdkb2Mgb2JqZWN0XG4gKiBAbmFtZSBuZy4kd2luZG93XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHJlZmVyZW5jZSB0byB0aGUgYnJvd3NlcidzIGB3aW5kb3dgIG9iamVjdC4gV2hpbGUgYHdpbmRvd2BcbiAqIGlzIGdsb2JhbGx5IGF2YWlsYWJsZSBpbiBKYXZhU2NyaXB0LCBpdCBjYXVzZXMgdGVzdGFiaWxpdHkgcHJvYmxlbXMsIGJlY2F1c2VcbiAqIGl0IGlzIGEgZ2xvYmFsIHZhcmlhYmxlLiBJbiBhbmd1bGFyIHdlIGFsd2F5cyByZWZlciB0byBpdCB0aHJvdWdoIHRoZVxuICogYCR3aW5kb3dgIHNlcnZpY2UsIHNvIGl0IG1heSBiZSBvdmVycmlkZGVuLCByZW1vdmVkIG9yIG1vY2tlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBFeHByZXNzaW9ucywgbGlrZSB0aGUgb25lIGRlZmluZWQgZm9yIHRoZSBgbmdDbGlja2AgZGlyZWN0aXZlIGluIHRoZSBleGFtcGxlXG4gKiBiZWxvdywgYXJlIGV2YWx1YXRlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgc2NvcGUuICBUaGVyZWZvcmUsIHRoZXJlIGlzXG4gKiBubyByaXNrIG9mIGluYWR2ZXJ0ZW50bHkgY29kaW5nIGluIGEgZGVwZW5kZW5jeSBvbiBhIGdsb2JhbCB2YWx1ZSBpbiBzdWNoIGFuXG4gKiBleHByZXNzaW9uLlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSwgJHdpbmRvdykge1xuICAgICAgICAgICAkc2NvcGUuZ3JlZXRpbmcgPSAnSGVsbG8sIFdvcmxkISc7XG4gICAgICAgICAgICRzY29wZS5kb0dyZWV0aW5nID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgICAgICAgICAgICR3aW5kb3cuYWxlcnQoZ3JlZXRpbmcpO1xuICAgICAgICAgICB9O1xuICAgICAgICAgfVxuICAgICAgIDwvc2NyaXB0PlxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwiZ3JlZXRpbmdcIiAvPlxuICAgICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cImRvR3JlZXRpbmcoZ3JlZXRpbmcpXCI+QUxFUlQ8L2J1dHRvbj5cbiAgICAgICA8L2Rpdj5cbiAgICAgPC9kb2M6c291cmNlPlxuICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgaXQoJ3Nob3VsZCBkaXNwbGF5IHRoZSBncmVldGluZyBpbiB0aGUgaW5wdXQgYm94JywgZnVuY3Rpb24oKSB7XG4gICAgICAgaW5wdXQoJ2dyZWV0aW5nJykuZW50ZXIoJ0hlbGxvLCBFMkUgVGVzdHMnKTtcbiAgICAgICAvLyBJZiB3ZSBjbGljayB0aGUgYnV0dG9uIGl0IHdpbGwgYmxvY2sgdGhlIHRlc3QgcnVubmVyXG4gICAgICAgLy8gZWxlbWVudCgnOmJ1dHRvbicpLmNsaWNrKCk7XG4gICAgICB9KTtcbiAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5mdW5jdGlvbiAkV2luZG93UHJvdmlkZXIoKXtcbiAgdGhpcy4kZ2V0ID0gdmFsdWVGbih3aW5kb3cpO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLiRmaWx0ZXJQcm92aWRlclxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogRmlsdGVycyBhcmUganVzdCBmdW5jdGlvbnMgd2hpY2ggdHJhbnNmb3JtIGlucHV0IHRvIGFuIG91dHB1dC4gSG93ZXZlciBmaWx0ZXJzIG5lZWQgdG8gYmVcbiAqIERlcGVuZGVuY3kgSW5qZWN0ZWQuIFRvIGFjaGlldmUgdGhpcyBhIGZpbHRlciBkZWZpbml0aW9uIGNvbnNpc3RzIG9mIGEgZmFjdG9yeSBmdW5jdGlvbiB3aGljaCBpc1xuICogYW5ub3RhdGVkIHdpdGggZGVwZW5kZW5jaWVzIGFuZCBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYSBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogPHByZT5cbiAqICAgLy8gRmlsdGVyIHJlZ2lzdHJhdGlvblxuICogICBmdW5jdGlvbiBNeU1vZHVsZSgkcHJvdmlkZSwgJGZpbHRlclByb3ZpZGVyKSB7XG4gKiAgICAgLy8gY3JlYXRlIGEgc2VydmljZSB0byBkZW1vbnN0cmF0ZSBpbmplY3Rpb24gKG5vdCBhbHdheXMgbmVlZGVkKVxuICogICAgICRwcm92aWRlLnZhbHVlKCdncmVldCcsIGZ1bmN0aW9uKG5hbWUpe1xuICogICAgICAgcmV0dXJuICdIZWxsbyAnICsgbmFtZSArICchJztcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgYSBmaWx0ZXIgZmFjdG9yeSB3aGljaCB1c2VzIHRoZVxuICogICAgIC8vIGdyZWV0IHNlcnZpY2UgdG8gZGVtb25zdHJhdGUgREkuXG4gKiAgICAgJGZpbHRlclByb3ZpZGVyLnJlZ2lzdGVyKCdncmVldCcsIGZ1bmN0aW9uKGdyZWV0KXtcbiAqICAgICAgIC8vIHJldHVybiB0aGUgZmlsdGVyIGZ1bmN0aW9uIHdoaWNoIHVzZXMgdGhlIGdyZWV0IHNlcnZpY2VcbiAqICAgICAgIC8vIHRvIGdlbmVyYXRlIHNhbHV0YXRpb25cbiAqICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gKiAgICAgICAgIC8vIGZpbHRlcnMgbmVlZCB0byBiZSBmb3JnaXZpbmcgc28gY2hlY2sgaW5wdXQgdmFsaWRpdHlcbiAqICAgICAgICAgcmV0dXJuIHRleHQgJiYgZ3JlZXQodGV4dCkgfHwgdGV4dDtcbiAqICAgICAgIH07XG4gKiAgICAgfSk7XG4gKiAgIH1cbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBmaWx0ZXIgZnVuY3Rpb24gaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBgJGluamVjdG9yYCB1bmRlciB0aGUgZmlsdGVyIG5hbWUgc3VmZml4IHdpdGhcbiAqIGBGaWx0ZXJgLlxuICogXG4gKiA8cHJlPlxuICogICBpdCgnc2hvdWxkIGJlIHRoZSBzYW1lIGluc3RhbmNlJywgaW5qZWN0KFxuICogICAgIGZ1bmN0aW9uKCRmaWx0ZXJQcm92aWRlcikge1xuICogICAgICAgJGZpbHRlclByb3ZpZGVyLnJlZ2lzdGVyKCdyZXZlcnNlJywgZnVuY3Rpb24oKXtcbiAqICAgICAgICAgcmV0dXJuIC4uLjtcbiAqICAgICAgIH0pO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oJGZpbHRlciwgcmV2ZXJzZUZpbHRlcikge1xuICogICAgICAgZXhwZWN0KCRmaWx0ZXIoJ3JldmVyc2UnKSkudG9CZShyZXZlcnNlRmlsdGVyKTtcbiAqICAgICB9KTtcbiAqIDwvcHJlPlxuICpcbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgYW5ndWxhciBmaWx0ZXJzIHdvcmssIGFuZCBob3cgdG8gY3JlYXRlIHlvdXIgb3duIGZpbHRlcnMsIHNlZVxuICoge0BsaW5rIGd1aWRlL2ZpbHRlciBGaWx0ZXJzfSBpbiB0aGUgQW5ndWxhciBEZXZlbG9wZXIgR3VpZGUuXG4gKi9cbi8qKlxuICogQG5nZG9jIG1ldGhvZFxuICogQG5hbWUgbmcuJGZpbHRlclByb3ZpZGVyI3JlZ2lzdGVyXG4gKiBAbWV0aG9kT2YgbmcuJGZpbHRlclByb3ZpZGVyXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlZ2lzdGVyIGZpbHRlciBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGZpbHRlci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmaWx0ZXIgZmFjdG9yeSBmdW5jdGlvbiB3aGljaCBpcyBpbmplY3RhYmxlLlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2MgZnVuY3Rpb25cbiAqIEBuYW1lIG5nLiRmaWx0ZXJcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBGaWx0ZXJzIGFyZSB1c2VkIGZvciBmb3JtYXR0aW5nIGRhdGEgZGlzcGxheWVkIHRvIHRoZSB1c2VyLlxuICpcbiAqIFRoZSBnZW5lcmFsIHN5bnRheCBpbiB0ZW1wbGF0ZXMgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAgICAgICAgIHt7IGV4cHJlc3Npb24gW3wgZmlsdGVyX25hbWVbOnBhcmFtZXRlcl92YWx1ZV0gLi4uIF0gfX1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWx0ZXIgZnVuY3Rpb24gdG8gcmV0cmlldmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gKi9cbiRGaWx0ZXJQcm92aWRlci4kaW5qZWN0ID0gWyckcHJvdmlkZSddO1xuZnVuY3Rpb24gJEZpbHRlclByb3ZpZGVyKCRwcm92aWRlKSB7XG4gIHZhciBzdWZmaXggPSAnRmlsdGVyJztcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLiRjb250cm9sbGVyUHJvdmlkZXIjcmVnaXN0ZXJcbiAgICogQG1ldGhvZE9mIG5nLiRjb250cm9sbGVyUHJvdmlkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBuYW1lIE5hbWUgb2YgdGhlIGZpbHRlciBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0IG1hcCBvZiBmaWx0ZXJzIHdoZXJlXG4gICAqICAgIHRoZSBrZXlzIGFyZSB0aGUgZmlsdGVyIG5hbWVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgZmlsdGVyIGZhY3Rvcmllcy5cbiAgICogQHJldHVybnMge09iamVjdH0gUmVnaXN0ZXJlZCBmaWx0ZXIgaW5zdGFuY2UsIG9yIGlmIGEgbWFwIG9mIGZpbHRlcnMgd2FzIHByb3ZpZGVkIHRoZW4gYSBtYXBcbiAgICogICAgb2YgdGhlIHJlZ2lzdGVyZWQgZmlsdGVyIGluc3RhbmNlcy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKG5hbWUsIGZhY3RvcnkpIHtcbiAgICBpZihpc09iamVjdChuYW1lKSkge1xuICAgICAgdmFyIGZpbHRlcnMgPSB7fTtcbiAgICAgIGZvckVhY2gobmFtZSwgZnVuY3Rpb24oZmlsdGVyLCBrZXkpIHtcbiAgICAgICAgZmlsdGVyc1trZXldID0gcmVnaXN0ZXIoa2V5LCBmaWx0ZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlsdGVycztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICRwcm92aWRlLmZhY3RvcnkobmFtZSArIHN1ZmZpeCwgZmFjdG9yeSk7XG4gICAgfVxuICB9XG4gIHRoaXMucmVnaXN0ZXIgPSByZWdpc3RlcjtcblxuICB0aGlzLiRnZXQgPSBbJyRpbmplY3RvcicsIGZ1bmN0aW9uKCRpbmplY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gJGluamVjdG9yLmdldChuYW1lICsgc3VmZml4KTtcbiAgICB9O1xuICB9XTtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvKiBnbG9iYWxcbiAgICBjdXJyZW5jeUZpbHRlcjogZmFsc2UsXG4gICAgZGF0ZUZpbHRlcjogZmFsc2UsXG4gICAgZmlsdGVyRmlsdGVyOiBmYWxzZSxcbiAgICBqc29uRmlsdGVyOiBmYWxzZSxcbiAgICBsaW1pdFRvRmlsdGVyOiBmYWxzZSxcbiAgICBsb3dlcmNhc2VGaWx0ZXI6IGZhbHNlLFxuICAgIG51bWJlckZpbHRlcjogZmFsc2UsXG4gICAgb3JkZXJCeUZpbHRlcjogZmFsc2UsXG4gICAgdXBwZXJjYXNlRmlsdGVyOiBmYWxzZSxcbiAgKi9cblxuICByZWdpc3RlcignY3VycmVuY3knLCBjdXJyZW5jeUZpbHRlcik7XG4gIHJlZ2lzdGVyKCdkYXRlJywgZGF0ZUZpbHRlcik7XG4gIHJlZ2lzdGVyKCdmaWx0ZXInLCBmaWx0ZXJGaWx0ZXIpO1xuICByZWdpc3RlcignanNvbicsIGpzb25GaWx0ZXIpO1xuICByZWdpc3RlcignbGltaXRUbycsIGxpbWl0VG9GaWx0ZXIpO1xuICByZWdpc3RlcignbG93ZXJjYXNlJywgbG93ZXJjYXNlRmlsdGVyKTtcbiAgcmVnaXN0ZXIoJ251bWJlcicsIG51bWJlckZpbHRlcik7XG4gIHJlZ2lzdGVyKCdvcmRlckJ5Jywgb3JkZXJCeUZpbHRlcik7XG4gIHJlZ2lzdGVyKCd1cHBlcmNhc2UnLCB1cHBlcmNhc2VGaWx0ZXIpO1xufVxuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG5nLmZpbHRlcjpmaWx0ZXJcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU2VsZWN0cyBhIHN1YnNldCBvZiBpdGVtcyBmcm9tIGBhcnJheWAgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvdXJjZSBhcnJheS5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdHxmdW5jdGlvbigpfSBleHByZXNzaW9uIFRoZSBwcmVkaWNhdGUgdG8gYmUgdXNlZCBmb3Igc2VsZWN0aW5nIGl0ZW1zIGZyb21cbiAqICAgYGFycmF5YC5cbiAqXG4gKiAgIENhbiBiZSBvbmUgb2Y6XG4gKlxuICogICAtIGBzdHJpbmdgOiBQcmVkaWNhdGUgdGhhdCByZXN1bHRzIGluIGEgc3Vic3RyaW5nIG1hdGNoIHVzaW5nIHRoZSB2YWx1ZSBvZiBgZXhwcmVzc2lvbmBcbiAqICAgICBzdHJpbmcuIEFsbCBzdHJpbmdzIG9yIG9iamVjdHMgd2l0aCBzdHJpbmcgcHJvcGVydGllcyBpbiBgYXJyYXlgIHRoYXQgY29udGFpbiB0aGlzIHN0cmluZ1xuICogICAgIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBwcmVkaWNhdGUgY2FuIGJlIG5lZ2F0ZWQgYnkgcHJlZml4aW5nIHRoZSBzdHJpbmcgd2l0aCBgIWAuXG4gKlxuICogICAtIGBPYmplY3RgOiBBIHBhdHRlcm4gb2JqZWN0IGNhbiBiZSB1c2VkIHRvIGZpbHRlciBzcGVjaWZpYyBwcm9wZXJ0aWVzIG9uIG9iamVjdHMgY29udGFpbmVkXG4gKiAgICAgYnkgYGFycmF5YC4gRm9yIGV4YW1wbGUgYHtuYW1lOlwiTVwiLCBwaG9uZTpcIjFcIn1gIHByZWRpY2F0ZSB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBpdGVtc1xuICogICAgIHdoaWNoIGhhdmUgcHJvcGVydHkgYG5hbWVgIGNvbnRhaW5pbmcgXCJNXCIgYW5kIHByb3BlcnR5IGBwaG9uZWAgY29udGFpbmluZyBcIjFcIi4gQSBzcGVjaWFsXG4gKiAgICAgcHJvcGVydHkgbmFtZSBgJGAgY2FuIGJlIHVzZWQgKGFzIGluIGB7JDpcInRleHRcIn1gKSB0byBhY2NlcHQgYSBtYXRjaCBhZ2FpbnN0IGFueVxuICogICAgIHByb3BlcnR5IG9mIHRoZSBvYmplY3QuIFRoYXQncyBlcXVpdmFsZW50IHRvIHRoZSBzaW1wbGUgc3Vic3RyaW5nIG1hdGNoIHdpdGggYSBgc3RyaW5nYFxuICogICAgIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAqXG4gKiAgIC0gYGZ1bmN0aW9uYDogQSBwcmVkaWNhdGUgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gd3JpdGUgYXJiaXRyYXJ5IGZpbHRlcnMuIFRoZSBmdW5jdGlvbiBpc1xuICogICAgIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAuIFRoZSBmaW5hbCByZXN1bHQgaXMgYW4gYXJyYXkgb2YgdGhvc2UgZWxlbWVudHMgdGhhdFxuICogICAgIHRoZSBwcmVkaWNhdGUgcmV0dXJuZWQgdHJ1ZSBmb3IuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKXx0cnVlfHVuZGVmaW5lZH0gY29tcGFyYXRvciBDb21wYXJhdG9yIHdoaWNoIGlzIHVzZWQgaW5cbiAqICAgICBkZXRlcm1pbmluZyBpZiB0aGUgZXhwZWN0ZWQgdmFsdWUgKGZyb20gdGhlIGZpbHRlciBleHByZXNzaW9uKSBhbmQgYWN0dWFsIHZhbHVlIChmcm9tXG4gKiAgICAgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXkpIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbWF0Y2guXG4gKlxuICogICBDYW4gYmUgb25lIG9mOlxuICpcbiAqICAgICAtIGBmdW5jdGlvbihleHBlY3RlZCwgYWN0dWFsKWA6XG4gKiAgICAgICBUaGUgZnVuY3Rpb24gd2lsbCBiZSBnaXZlbiB0aGUgb2JqZWN0IHZhbHVlIGFuZCB0aGUgcHJlZGljYXRlIHZhbHVlIHRvIGNvbXBhcmUgYW5kXG4gKiAgICAgICBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGluY2x1ZGVkIGluIGZpbHRlcmVkIHJlc3VsdC5cbiAqXG4gKiAgICAgLSBgdHJ1ZWA6IEEgc2hvcnRoYW5kIGZvciBgZnVuY3Rpb24oZXhwZWN0ZWQsIGFjdHVhbCkgeyByZXR1cm4gYW5ndWxhci5lcXVhbHMoZXhwZWN0ZWQsIGFjdHVhbCl9YC5cbiAqICAgICAgIHRoaXMgaXMgZXNzZW50aWFsbHkgc3RyaWN0IGNvbXBhcmlzb24gb2YgZXhwZWN0ZWQgYW5kIGFjdHVhbC5cbiAqXG4gKiAgICAgLSBgZmFsc2V8dW5kZWZpbmVkYDogQSBzaG9ydCBoYW5kIGZvciBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgbG9vayBmb3IgYSBzdWJzdHJpbmcgbWF0Y2ggaW4gY2FzZVxuICogICAgICAgaW5zZW5zaXRpdmUgd2F5LlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxkaXYgbmctaW5pdD1cImZyaWVuZHMgPSBbe25hbWU6J0pvaG4nLCBwaG9uZTonNTU1LTEyNzYnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6J01hcnknLCBwaG9uZTonODAwLUJJRy1NQVJZJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidNaWtlJywgcGhvbmU6JzU1NS00MzIxJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidBZGFtJywgcGhvbmU6JzU1NS01Njc4J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOidKdWxpZScsIHBob25lOic1NTUtODc2NSd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTonSnVsaWV0dGUnLCBwaG9uZTonNTU1LTU2NzgnfV1cIj48L2Rpdj5cblxuICAgICAgIFNlYXJjaDogPGlucHV0IG5nLW1vZGVsPVwic2VhcmNoVGV4dFwiPlxuICAgICAgIDx0YWJsZSBpZD1cInNlYXJjaFRleHRSZXN1bHRzXCI+XG4gICAgICAgICA8dHI+PHRoPk5hbWU8L3RoPjx0aD5QaG9uZTwvdGg+PC90cj5cbiAgICAgICAgIDx0ciBuZy1yZXBlYXQ9XCJmcmllbmQgaW4gZnJpZW5kcyB8IGZpbHRlcjpzZWFyY2hUZXh0XCI+XG4gICAgICAgICAgIDx0ZD57e2ZyaWVuZC5uYW1lfX08L3RkPlxuICAgICAgICAgICA8dGQ+e3tmcmllbmQucGhvbmV9fTwvdGQ+XG4gICAgICAgICA8L3RyPlxuICAgICAgIDwvdGFibGU+XG4gICAgICAgPGhyPlxuICAgICAgIEFueTogPGlucHV0IG5nLW1vZGVsPVwic2VhcmNoLiRcIj4gPGJyPlxuICAgICAgIE5hbWUgb25seSA8aW5wdXQgbmctbW9kZWw9XCJzZWFyY2gubmFtZVwiPjxicj5cbiAgICAgICBQaG9uZSBvbmx5IDxpbnB1dCBuZy1tb2RlbD1cInNlYXJjaC5waG9uZVwiPjxicj5cbiAgICAgICBFcXVhbGl0eSA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJzdHJpY3RcIj48YnI+XG4gICAgICAgPHRhYmxlIGlkPVwic2VhcmNoT2JqUmVzdWx0c1wiPlxuICAgICAgICAgPHRyPjx0aD5OYW1lPC90aD48dGg+UGhvbmU8L3RoPjwvdHI+XG4gICAgICAgICA8dHIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBmaWx0ZXI6c2VhcmNoOnN0cmljdFwiPlxuICAgICAgICAgICA8dGQ+e3tmcmllbmQubmFtZX19PC90ZD5cbiAgICAgICAgICAgPHRkPnt7ZnJpZW5kLnBob25lfX08L3RkPlxuICAgICAgICAgPC90cj5cbiAgICAgICA8L3RhYmxlPlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBzZWFyY2ggYWNyb3NzIGFsbCBmaWVsZHMgd2hlbiBmaWx0ZXJpbmcgd2l0aCBhIHN0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgaW5wdXQoJ3NlYXJjaFRleHQnKS5lbnRlcignbScpO1xuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCcjc2VhcmNoVGV4dFJlc3VsdHMgdHInLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5uYW1lJykpLlxuICAgICAgICAgICB0b0VxdWFsKFsnTWFyeScsICdNaWtlJywgJ0FkYW0nXSk7XG5cbiAgICAgICAgIGlucHV0KCdzZWFyY2hUZXh0JykuZW50ZXIoJzc2Jyk7XG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJyNzZWFyY2hUZXh0UmVzdWx0cyB0cicsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXG4gICAgICAgICAgIHRvRXF1YWwoWydKb2huJywgJ0p1bGllJ10pO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCBzZWFyY2ggaW4gc3BlY2lmaWMgZmllbGRzIHdoZW4gZmlsdGVyaW5nIHdpdGggYSBwcmVkaWNhdGUgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBpbnB1dCgnc2VhcmNoLiQnKS5lbnRlcignaScpO1xuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCcjc2VhcmNoT2JqUmVzdWx0cyB0cicsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXG4gICAgICAgICAgIHRvRXF1YWwoWydNYXJ5JywgJ01pa2UnLCAnSnVsaWUnLCAnSnVsaWV0dGUnXSk7XG4gICAgICAgfSk7XG4gICAgICAgaXQoJ3Nob3VsZCB1c2UgYSBlcXVhbCBjb21wYXJpc29uIHdoZW4gY29tcGFyYXRvciBpcyB0cnVlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBpbnB1dCgnc2VhcmNoLm5hbWUnKS5lbnRlcignSnVsaWUnKTtcbiAgICAgICAgIGlucHV0KCdzdHJpY3QnKS5jaGVjaygpO1xuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCcjc2VhcmNoT2JqUmVzdWx0cyB0cicsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXG4gICAgICAgICAgIHRvRXF1YWwoWydKdWxpZSddKTtcbiAgICAgICB9KTtcbiAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5mdW5jdGlvbiBmaWx0ZXJGaWx0ZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcnJheSwgZXhwcmVzc2lvbiwgY29tcGFyYXRvcikge1xuICAgIGlmICghaXNBcnJheShhcnJheSkpIHJldHVybiBhcnJheTtcblxuICAgIHZhciBjb21wYXJhdG9yVHlwZSA9IHR5cGVvZihjb21wYXJhdG9yKSxcbiAgICAgICAgcHJlZGljYXRlcyA9IFtdO1xuXG4gICAgcHJlZGljYXRlcy5jaGVjayA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByZWRpY2F0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYoIXByZWRpY2F0ZXNbal0odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgaWYgKGNvbXBhcmF0b3JUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGFyYXRvclR5cGUgPT09ICdib29sZWFuJyAmJiBjb21wYXJhdG9yKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbihvYmosIHRleHQpIHtcbiAgICAgICAgICByZXR1cm4gYW5ndWxhci5lcXVhbHMob2JqLCB0ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBmdW5jdGlvbihvYmosIHRleHQpIHtcbiAgICAgICAgICB0ZXh0ID0gKCcnK3RleHQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuICgnJytvYmopLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0ZXh0KSA+IC0xO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzZWFyY2ggPSBmdW5jdGlvbihvYmosIHRleHQpe1xuICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09ICdzdHJpbmcnICYmIHRleHQuY2hhckF0KDApID09PSAnIScpIHtcbiAgICAgICAgcmV0dXJuICFzZWFyY2gob2JqLCB0ZXh0LnN1YnN0cigxKSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBvYmopIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3Iob2JqLCB0ZXh0KTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHRleHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3Iob2JqLCB0ZXh0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGZvciAoIHZhciBvYmpLZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaktleS5jaGFyQXQoMCkgIT09ICckJyAmJiBzZWFyY2gob2JqW29iaktleV0sIHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoKG9ialtpXSwgdGV4dCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBleHByZXNzaW9uKSB7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAvLyBTZXQgdXAgZXhwcmVzc2lvbiBvYmplY3QgYW5kIGZhbGwgdGhyb3VnaFxuICAgICAgICBleHByZXNzaW9uID0geyQ6ZXhwcmVzc2lvbn07XG4gICAgICAgIC8vIGpzaGludCAtVzA4NlxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAvLyBqc2hpbnQgK1cwODZcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV4cHJlc3Npb24pIHtcbiAgICAgICAgICBpZiAoa2V5ID09ICckJykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIWV4cHJlc3Npb25ba2V5XSkgcmV0dXJuO1xuICAgICAgICAgICAgICB2YXIgcGF0aCA9IGtleTtcbiAgICAgICAgICAgICAgcHJlZGljYXRlcy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaCh2YWx1ZSwgZXhwcmVzc2lvbltwYXRoXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mKGV4cHJlc3Npb25ba2V5XSkgPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIHZhciBwYXRoID0ga2V5O1xuICAgICAgICAgICAgICBwcmVkaWNhdGVzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoKGdldHRlcih2YWx1ZSxwYXRoKSwgZXhwcmVzc2lvbltwYXRoXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHByZWRpY2F0ZXMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtqXTtcbiAgICAgIGlmIChwcmVkaWNhdGVzLmNoZWNrKHZhbHVlKSkge1xuICAgICAgICBmaWx0ZXJlZC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xuICB9O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG5nLmZpbHRlcjpjdXJyZW5jeVxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGb3JtYXRzIGEgbnVtYmVyIGFzIGEgY3VycmVuY3kgKGllICQxLDIzNC41NikuIFdoZW4gbm8gY3VycmVuY3kgc3ltYm9sIGlzIHByb3ZpZGVkLCBkZWZhdWx0XG4gKiBzeW1ib2wgZm9yIGN1cnJlbnQgbG9jYWxlIGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBJbnB1dCB0byBmaWx0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZz19IHN5bWJvbCBDdXJyZW5jeSBzeW1ib2wgb3IgaWRlbnRpZmllciB0byBiZSBkaXNwbGF5ZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgbnVtYmVyLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICA8c2NyaXB0PlxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgJHNjb3BlLmFtb3VudCA9IDEyMzQuNTY7XG4gICAgICAgICB9XG4gICAgICAgPC9zY3JpcHQ+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuZy1tb2RlbD1cImFtb3VudFwiPiA8YnI+XG4gICAgICAgICBkZWZhdWx0IGN1cnJlbmN5IHN5bWJvbCAoJCk6IHt7YW1vdW50IHwgY3VycmVuY3l9fTxicj5cbiAgICAgICAgIGN1c3RvbSBjdXJyZW5jeSBpZGVudGlmaWVyIChVU0QkKToge3thbW91bnQgfCBjdXJyZW5jeTpcIlVTRCRcIn19XG4gICAgICAgPC9kaXY+XG4gICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICBpdCgnc2hvdWxkIGluaXQgd2l0aCAxMjM0LjU2JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnYW1vdW50IHwgY3VycmVuY3knKSkudG9CZSgnJDEsMjM0LjU2Jyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnYW1vdW50IHwgY3VycmVuY3k6XCJVU0QkXCInKSkudG9CZSgnVVNEJDEsMjM0LjU2Jyk7XG4gICAgICAgfSk7XG4gICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGlucHV0KCdhbW91bnQnKS5lbnRlcignLTEyMzQnKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdhbW91bnQgfCBjdXJyZW5jeScpKS50b0JlKCcoJDEsMjM0LjAwKScpO1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2Ftb3VudCB8IGN1cnJlbmN5OlwiVVNEJFwiJykpLnRvQmUoJyhVU0QkMSwyMzQuMDApJyk7XG4gICAgICAgfSk7XG4gICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuY3VycmVuY3lGaWx0ZXIuJGluamVjdCA9IFsnJGxvY2FsZSddO1xuZnVuY3Rpb24gY3VycmVuY3lGaWx0ZXIoJGxvY2FsZSkge1xuICB2YXIgZm9ybWF0cyA9ICRsb2NhbGUuTlVNQkVSX0ZPUk1BVFM7XG4gIHJldHVybiBmdW5jdGlvbihhbW91bnQsIGN1cnJlbmN5U3ltYm9sKXtcbiAgICBpZiAoaXNVbmRlZmluZWQoY3VycmVuY3lTeW1ib2wpKSBjdXJyZW5jeVN5bWJvbCA9IGZvcm1hdHMuQ1VSUkVOQ1lfU1lNO1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIoYW1vdW50LCBmb3JtYXRzLlBBVFRFUk5TWzFdLCBmb3JtYXRzLkdST1VQX1NFUCwgZm9ybWF0cy5ERUNJTUFMX1NFUCwgMikuXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvXFx1MDBBNC9nLCBjdXJyZW5jeVN5bWJvbCk7XG4gIH07XG59XG5cbi8qKlxuICogQG5nZG9jIGZpbHRlclxuICogQG5hbWUgbmcuZmlsdGVyOm51bWJlclxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGb3JtYXRzIGEgbnVtYmVyIGFzIHRleHQuXG4gKlxuICogSWYgdGhlIGlucHV0IGlzIG5vdCBhIG51bWJlciBhbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgTnVtYmVyIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gZnJhY3Rpb25TaXplIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0aGUgbnVtYmVyIHRvLlxuICogSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQgdGhlbiB0aGUgZnJhY3Rpb24gc2l6ZSBpcyBjb21wdXRlZCBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSdzIG51bWJlclxuICogZm9ybWF0dGluZyBwYXR0ZXJuLiBJbiB0aGUgY2FzZSBvZiB0aGUgZGVmYXVsdCBsb2NhbGUsIGl0IHdpbGwgYmUgMy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IE51bWJlciByb3VuZGVkIHRvIGRlY2ltYWxQbGFjZXMgYW5kIHBsYWNlcyBhIOKAnCzigJ0gYWZ0ZXIgZWFjaCB0aGlyZCBkaWdpdC5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICA8c2NyaXB0PlxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgJHNjb3BlLnZhbCA9IDEyMzQuNTY3ODk7XG4gICAgICAgICB9XG4gICAgICAgPC9zY3JpcHQ+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgRW50ZXIgbnVtYmVyOiA8aW5wdXQgbmctbW9kZWw9J3ZhbCc+PGJyPlxuICAgICAgICAgRGVmYXVsdCBmb3JtYXR0aW5nOiB7e3ZhbCB8IG51bWJlcn19PGJyPlxuICAgICAgICAgTm8gZnJhY3Rpb25zOiB7e3ZhbCB8IG51bWJlcjowfX08YnI+XG4gICAgICAgICBOZWdhdGl2ZSBudW1iZXI6IHt7LXZhbCB8IG51bWJlcjo0fX1cbiAgICAgICA8L2Rpdj5cbiAgICAgPC9kb2M6c291cmNlPlxuICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgIGl0KCdzaG91bGQgZm9ybWF0IG51bWJlcnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWwgfCBudW1iZXInKSkudG9CZSgnMSwyMzQuNTY4Jyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygndmFsIHwgbnVtYmVyOjAnKSkudG9CZSgnMSwyMzUnKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCctdmFsIHwgbnVtYmVyOjQnKSkudG9CZSgnLTEsMjM0LjU2NzknKTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgdXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBpbnB1dCgndmFsJykuZW50ZXIoJzMzNzQuMzMzJyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygndmFsIHwgbnVtYmVyJykpLnRvQmUoJzMsMzc0LjMzMycpO1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbCB8IG51bWJlcjowJykpLnRvQmUoJzMsMzc0Jyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnLXZhbCB8IG51bWJlcjo0JykpLnRvQmUoJy0zLDM3NC4zMzMwJyk7XG4gICAgICAgfSk7XG4gICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG5cbm51bWJlckZpbHRlci4kaW5qZWN0ID0gWyckbG9jYWxlJ107XG5mdW5jdGlvbiBudW1iZXJGaWx0ZXIoJGxvY2FsZSkge1xuICB2YXIgZm9ybWF0cyA9ICRsb2NhbGUuTlVNQkVSX0ZPUk1BVFM7XG4gIHJldHVybiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uU2l6ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIobnVtYmVyLCBmb3JtYXRzLlBBVFRFUk5TWzBdLCBmb3JtYXRzLkdST1VQX1NFUCwgZm9ybWF0cy5ERUNJTUFMX1NFUCxcbiAgICAgIGZyYWN0aW9uU2l6ZSk7XG4gIH07XG59XG5cbnZhciBERUNJTUFMX1NFUCA9ICcuJztcbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIHBhdHRlcm4sIGdyb3VwU2VwLCBkZWNpbWFsU2VwLCBmcmFjdGlvblNpemUpIHtcbiAgaWYgKGlzTmFOKG51bWJlcikgfHwgIWlzRmluaXRlKG51bWJlcikpIHJldHVybiAnJztcblxuICB2YXIgaXNOZWdhdGl2ZSA9IG51bWJlciA8IDA7XG4gIG51bWJlciA9IE1hdGguYWJzKG51bWJlcik7XG4gIHZhciBudW1TdHIgPSBudW1iZXIgKyAnJyxcbiAgICAgIGZvcm1hdGVkVGV4dCA9ICcnLFxuICAgICAgcGFydHMgPSBbXTtcblxuICB2YXIgaGFzRXhwb25lbnQgPSBmYWxzZTtcbiAgaWYgKG51bVN0ci5pbmRleE9mKCdlJykgIT09IC0xKSB7XG4gICAgdmFyIG1hdGNoID0gbnVtU3RyLm1hdGNoKC8oW1xcZFxcLl0rKWUoLT8pKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoWzJdID09ICctJyAmJiBtYXRjaFszXSA+IGZyYWN0aW9uU2l6ZSArIDEpIHtcbiAgICAgIG51bVN0ciA9ICcwJztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0ZWRUZXh0ID0gbnVtU3RyO1xuICAgICAgaGFzRXhwb25lbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzRXhwb25lbnQpIHtcbiAgICB2YXIgZnJhY3Rpb25MZW4gPSAobnVtU3RyLnNwbGl0KERFQ0lNQUxfU0VQKVsxXSB8fCAnJykubGVuZ3RoO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGZyYWN0aW9uU2l6ZSBpZiBpdCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgaWYgKGlzVW5kZWZpbmVkKGZyYWN0aW9uU2l6ZSkpIHtcbiAgICAgIGZyYWN0aW9uU2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KHBhdHRlcm4ubWluRnJhYywgZnJhY3Rpb25MZW4pLCBwYXR0ZXJuLm1heEZyYWMpO1xuICAgIH1cblxuICAgIHZhciBwb3cgPSBNYXRoLnBvdygxMCwgZnJhY3Rpb25TaXplKTtcbiAgICBudW1iZXIgPSBNYXRoLnJvdW5kKG51bWJlciAqIHBvdykgLyBwb3c7XG4gICAgdmFyIGZyYWN0aW9uID0gKCcnICsgbnVtYmVyKS5zcGxpdChERUNJTUFMX1NFUCk7XG4gICAgdmFyIHdob2xlID0gZnJhY3Rpb25bMF07XG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvblsxXSB8fCAnJztcblxuICAgIHZhciBpLCBwb3MgPSAwLFxuICAgICAgICBsZ3JvdXAgPSBwYXR0ZXJuLmxnU2l6ZSxcbiAgICAgICAgZ3JvdXAgPSBwYXR0ZXJuLmdTaXplO1xuXG4gICAgaWYgKHdob2xlLmxlbmd0aCA+PSAobGdyb3VwICsgZ3JvdXApKSB7XG4gICAgICBwb3MgPSB3aG9sZS5sZW5ndGggLSBsZ3JvdXA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zOyBpKyspIHtcbiAgICAgICAgaWYgKChwb3MgLSBpKSVncm91cCA9PT0gMCAmJiBpICE9PSAwKSB7XG4gICAgICAgICAgZm9ybWF0ZWRUZXh0ICs9IGdyb3VwU2VwO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdGVkVGV4dCArPSB3aG9sZS5jaGFyQXQoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gcG9zOyBpIDwgd2hvbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgod2hvbGUubGVuZ3RoIC0gaSklbGdyb3VwID09PSAwICYmIGkgIT09IDApIHtcbiAgICAgICAgZm9ybWF0ZWRUZXh0ICs9IGdyb3VwU2VwO1xuICAgICAgfVxuICAgICAgZm9ybWF0ZWRUZXh0ICs9IHdob2xlLmNoYXJBdChpKTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZnJhY3Rpb24gcGFydC5cbiAgICB3aGlsZShmcmFjdGlvbi5sZW5ndGggPCBmcmFjdGlvblNpemUpIHtcbiAgICAgIGZyYWN0aW9uICs9ICcwJztcbiAgICB9XG5cbiAgICBpZiAoZnJhY3Rpb25TaXplICYmIGZyYWN0aW9uU2l6ZSAhPT0gXCIwXCIpIGZvcm1hdGVkVGV4dCArPSBkZWNpbWFsU2VwICsgZnJhY3Rpb24uc3Vic3RyKDAsIGZyYWN0aW9uU2l6ZSk7XG4gIH0gZWxzZSB7XG5cbiAgICBpZiAoZnJhY3Rpb25TaXplID4gMCAmJiBudW1iZXIgPiAtMSAmJiBudW1iZXIgPCAxKSB7XG4gICAgICBmb3JtYXRlZFRleHQgPSBudW1iZXIudG9GaXhlZChmcmFjdGlvblNpemUpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnRzLnB1c2goaXNOZWdhdGl2ZSA/IHBhdHRlcm4ubmVnUHJlIDogcGF0dGVybi5wb3NQcmUpO1xuICBwYXJ0cy5wdXNoKGZvcm1hdGVkVGV4dCk7XG4gIHBhcnRzLnB1c2goaXNOZWdhdGl2ZSA/IHBhdHRlcm4ubmVnU3VmIDogcGF0dGVybi5wb3NTdWYpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIHBhZE51bWJlcihudW0sIGRpZ2l0cywgdHJpbSkge1xuICB2YXIgbmVnID0gJyc7XG4gIGlmIChudW0gPCAwKSB7XG4gICAgbmVnID0gICctJztcbiAgICBudW0gPSAtbnVtO1xuICB9XG4gIG51bSA9ICcnICsgbnVtO1xuICB3aGlsZShudW0ubGVuZ3RoIDwgZGlnaXRzKSBudW0gPSAnMCcgKyBudW07XG4gIGlmICh0cmltKVxuICAgIG51bSA9IG51bS5zdWJzdHIobnVtLmxlbmd0aCAtIGRpZ2l0cyk7XG4gIHJldHVybiBuZWcgKyBudW07XG59XG5cblxuZnVuY3Rpb24gZGF0ZUdldHRlcihuYW1lLCBzaXplLCBvZmZzZXQsIHRyaW0pIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIHZhbHVlID0gZGF0ZVsnZ2V0JyArIG5hbWVdKCk7XG4gICAgaWYgKG9mZnNldCA+IDAgfHwgdmFsdWUgPiAtb2Zmc2V0KVxuICAgICAgdmFsdWUgKz0gb2Zmc2V0O1xuICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBvZmZzZXQgPT0gLTEyICkgdmFsdWUgPSAxMjtcbiAgICByZXR1cm4gcGFkTnVtYmVyKHZhbHVlLCBzaXplLCB0cmltKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGF0ZVN0ckdldHRlcihuYW1lLCBzaG9ydEZvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUsIGZvcm1hdHMpIHtcbiAgICB2YXIgdmFsdWUgPSBkYXRlWydnZXQnICsgbmFtZV0oKTtcbiAgICB2YXIgZ2V0ID0gdXBwZXJjYXNlKHNob3J0Rm9ybSA/ICgnU0hPUlQnICsgbmFtZSkgOiBuYW1lKTtcblxuICAgIHJldHVybiBmb3JtYXRzW2dldF1bdmFsdWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0aW1lWm9uZUdldHRlcihkYXRlKSB7XG4gIHZhciB6b25lID0gLTEgKiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIHZhciBwYWRkZWRab25lID0gKHpvbmUgPj0gMCkgPyBcIitcIiA6IFwiXCI7XG5cbiAgcGFkZGVkWm9uZSArPSBwYWROdW1iZXIoTWF0aFt6b25lID4gMCA/ICdmbG9vcicgOiAnY2VpbCddKHpvbmUgLyA2MCksIDIpICtcbiAgICAgICAgICAgICAgICBwYWROdW1iZXIoTWF0aC5hYnMoem9uZSAlIDYwKSwgMik7XG5cbiAgcmV0dXJuIHBhZGRlZFpvbmU7XG59XG5cbmZ1bmN0aW9uIGFtcG1HZXR0ZXIoZGF0ZSwgZm9ybWF0cykge1xuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBmb3JtYXRzLkFNUE1TWzBdIDogZm9ybWF0cy5BTVBNU1sxXTtcbn1cblxudmFyIERBVEVfRk9STUFUUyA9IHtcbiAgeXl5eTogZGF0ZUdldHRlcignRnVsbFllYXInLCA0KSxcbiAgICB5eTogZGF0ZUdldHRlcignRnVsbFllYXInLCAyLCAwLCB0cnVlKSxcbiAgICAgeTogZGF0ZUdldHRlcignRnVsbFllYXInLCAxKSxcbiAgTU1NTTogZGF0ZVN0ckdldHRlcignTW9udGgnKSxcbiAgIE1NTTogZGF0ZVN0ckdldHRlcignTW9udGgnLCB0cnVlKSxcbiAgICBNTTogZGF0ZUdldHRlcignTW9udGgnLCAyLCAxKSxcbiAgICAgTTogZGF0ZUdldHRlcignTW9udGgnLCAxLCAxKSxcbiAgICBkZDogZGF0ZUdldHRlcignRGF0ZScsIDIpLFxuICAgICBkOiBkYXRlR2V0dGVyKCdEYXRlJywgMSksXG4gICAgSEg6IGRhdGVHZXR0ZXIoJ0hvdXJzJywgMiksXG4gICAgIEg6IGRhdGVHZXR0ZXIoJ0hvdXJzJywgMSksXG4gICAgaGg6IGRhdGVHZXR0ZXIoJ0hvdXJzJywgMiwgLTEyKSxcbiAgICAgaDogZGF0ZUdldHRlcignSG91cnMnLCAxLCAtMTIpLFxuICAgIG1tOiBkYXRlR2V0dGVyKCdNaW51dGVzJywgMiksXG4gICAgIG06IGRhdGVHZXR0ZXIoJ01pbnV0ZXMnLCAxKSxcbiAgICBzczogZGF0ZUdldHRlcignU2Vjb25kcycsIDIpLFxuICAgICBzOiBkYXRlR2V0dGVyKCdTZWNvbmRzJywgMSksXG4gICAgIC8vIHdoaWxlIElTTyA4NjAxIHJlcXVpcmVzIGZyYWN0aW9ucyB0byBiZSBwcmVmaXhlZCB3aXRoIGAuYCBvciBgLGBcbiAgICAgLy8gd2UgY2FuIGJlIGp1c3Qgc2FmZWx5IHJlbHkgb24gdXNpbmcgYHNzc2Agc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgc2luZ2xlIG9yIHR3byBkaWdpdCBmcmFjdGlvbnNcbiAgIHNzczogZGF0ZUdldHRlcignTWlsbGlzZWNvbmRzJywgMyksXG4gIEVFRUU6IGRhdGVTdHJHZXR0ZXIoJ0RheScpLFxuICAgRUVFOiBkYXRlU3RyR2V0dGVyKCdEYXknLCB0cnVlKSxcbiAgICAgYTogYW1wbUdldHRlcixcbiAgICAgWjogdGltZVpvbmVHZXR0ZXJcbn07XG5cbnZhciBEQVRFX0ZPUk1BVFNfU1BMSVQgPSAvKCg/OlteeU1kSGhtc2FaRSddKyl8KD86Jyg/OlteJ118JycpKicpfCg/OkUrfHkrfE0rfGQrfEgrfGgrfG0rfHMrfGF8WikpKC4qKS8sXG4gICAgTlVNQkVSX1NUUklORyA9IC9eXFwtP1xcZCskLztcblxuLyoqXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBuZy5maWx0ZXI6ZGF0ZVxuICogQGZ1bmN0aW9uXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAgIEZvcm1hdHMgYGRhdGVgIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgYGZvcm1hdGAuXG4gKlxuICogICBgZm9ybWF0YCBzdHJpbmcgY2FuIGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZWxlbWVudHM6XG4gKlxuICogICAqIGAneXl5eSdgOiA0IGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHllYXIgKGUuZy4gQUQgMSA9PiAwMDAxLCBBRCAyMDEwID0+IDIwMTApXG4gKiAgICogYCd5eSdgOiAyIGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHllYXIsIHBhZGRlZCAoMDAtOTkpLiAoZS5nLiBBRCAyMDAxID0+IDAxLCBBRCAyMDEwID0+IDEwKVxuICogICAqIGAneSdgOiAxIGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHllYXIsIGUuZy4gKEFEIDEgPT4gMSwgQUQgMTk5ID0+IDE5OSlcbiAqICAgKiBgJ01NTU0nYDogTW9udGggaW4geWVhciAoSmFudWFyeS1EZWNlbWJlcilcbiAqICAgKiBgJ01NTSdgOiBNb250aCBpbiB5ZWFyIChKYW4tRGVjKVxuICogICAqIGAnTU0nYDogTW9udGggaW4geWVhciwgcGFkZGVkICgwMS0xMilcbiAqICAgKiBgJ00nYDogTW9udGggaW4geWVhciAoMS0xMilcbiAqICAgKiBgJ2RkJ2A6IERheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMSlcbiAqICAgKiBgJ2QnYDogRGF5IGluIG1vbnRoICgxLTMxKVxuICogICAqIGAnRUVFRSdgOiBEYXkgaW4gV2VlaywoU3VuZGF5LVNhdHVyZGF5KVxuICogICAqIGAnRUVFJ2A6IERheSBpbiBXZWVrLCAoU3VuLVNhdClcbiAqICAgKiBgJ0hIJ2A6IEhvdXIgaW4gZGF5LCBwYWRkZWQgKDAwLTIzKVxuICogICAqIGAnSCdgOiBIb3VyIGluIGRheSAoMC0yMylcbiAqICAgKiBgJ2hoJ2A6IEhvdXIgaW4gYW0vcG0sIHBhZGRlZCAoMDEtMTIpXG4gKiAgICogYCdoJ2A6IEhvdXIgaW4gYW0vcG0sICgxLTEyKVxuICogICAqIGAnbW0nYDogTWludXRlIGluIGhvdXIsIHBhZGRlZCAoMDAtNTkpXG4gKiAgICogYCdtJ2A6IE1pbnV0ZSBpbiBob3VyICgwLTU5KVxuICogICAqIGAnc3MnYDogU2Vjb25kIGluIG1pbnV0ZSwgcGFkZGVkICgwMC01OSlcbiAqICAgKiBgJ3MnYDogU2Vjb25kIGluIG1pbnV0ZSAoMC01OSlcbiAqICAgKiBgJy5zc3MnIG9yICcsc3NzJ2A6IE1pbGxpc2Vjb25kIGluIHNlY29uZCwgcGFkZGVkICgwMDAtOTk5KVxuICogICAqIGAnYSdgOiBhbS9wbSBtYXJrZXJcbiAqICAgKiBgJ1onYDogNCBkaWdpdCAoK3NpZ24pIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aW1lem9uZSBvZmZzZXQgKC0xMjAwLSsxMjAwKVxuICpcbiAqICAgYGZvcm1hdGAgc3RyaW5nIGNhbiBhbHNvIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHByZWRlZmluZWRcbiAqICAge0BsaW5rIGd1aWRlL2kxOG4gbG9jYWxpemFibGUgZm9ybWF0c306XG4gKlxuICogICAqIGAnbWVkaXVtJ2A6IGVxdWl2YWxlbnQgdG8gYCdNTU0gZCwgeSBoOm1tOnNzIGEnYCBmb3IgZW5fVVMgbG9jYWxlXG4gKiAgICAgKGUuZy4gU2VwIDMsIDIwMTAgMTI6MDU6MDggcG0pXG4gKiAgICogYCdzaG9ydCdgOiBlcXVpdmFsZW50IHRvIGAnTS9kL3l5IGg6bW0gYSdgIGZvciBlbl9VUyAgbG9jYWxlIChlLmcuIDkvMy8xMCAxMjowNSBwbSlcbiAqICAgKiBgJ2Z1bGxEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCdFRUVFLCBNTU1NIGQseSdgIGZvciBlbl9VUyAgbG9jYWxlXG4gKiAgICAgKGUuZy4gRnJpZGF5LCBTZXB0ZW1iZXIgMywgMjAxMClcbiAqICAgKiBgJ2xvbmdEYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCdNTU1NIGQsIHknYCBmb3IgZW5fVVMgIGxvY2FsZSAoZS5nLiBTZXB0ZW1iZXIgMywgMjAxMClcbiAqICAgKiBgJ21lZGl1bURhdGUnYDogZXF1aXZhbGVudCB0byBgJ01NTSBkLCB5J2AgZm9yIGVuX1VTICBsb2NhbGUgKGUuZy4gU2VwIDMsIDIwMTApXG4gKiAgICogYCdzaG9ydERhdGUnYDogZXF1aXZhbGVudCB0byBgJ00vZC95eSdgIGZvciBlbl9VUyBsb2NhbGUgKGUuZy4gOS8zLzEwKVxuICogICAqIGAnbWVkaXVtVGltZSdgOiBlcXVpdmFsZW50IHRvIGAnaDptbTpzcyBhJ2AgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiAxMjowNTowOCBwbSlcbiAqICAgKiBgJ3Nob3J0VGltZSdgOiBlcXVpdmFsZW50IHRvIGAnaDptbSBhJ2AgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiAxMjowNSBwbSlcbiAqXG4gKiAgIGBmb3JtYXRgIHN0cmluZyBjYW4gY29udGFpbiBsaXRlcmFsIHZhbHVlcy4gVGhlc2UgbmVlZCB0byBiZSBxdW90ZWQgd2l0aCBzaW5nbGUgcXVvdGVzIChlLmcuXG4gKiAgIGBcImggJ2luIHRoZSBtb3JuaW5nJ1wiYCkuIEluIG9yZGVyIHRvIG91dHB1dCBzaW5nbGUgcXVvdGUsIHVzZSB0d28gc2luZ2xlIHF1b3RlcyBpbiBhIHNlcXVlbmNlXG4gKiAgIChlLmcuIGBcImggJ28nJ2Nsb2NrJ1wiYCkuXG4gKlxuICogQHBhcmFtIHsoRGF0ZXxudW1iZXJ8c3RyaW5nKX0gZGF0ZSBEYXRlIHRvIGZvcm1hdCBlaXRoZXIgYXMgRGF0ZSBvYmplY3QsIG1pbGxpc2Vjb25kcyAoc3RyaW5nIG9yXG4gKiAgICBudW1iZXIpIG9yIHZhcmlvdXMgSVNPIDg2MDEgZGF0ZXRpbWUgc3RyaW5nIGZvcm1hdHMgKGUuZy4geXl5eS1NTS1kZFRISDptbTpzcy5TU1NaIGFuZCBpdHNcbiAqICAgIHNob3J0ZXIgdmVyc2lvbnMgbGlrZSB5eXl5LU1NLWRkVEhIOm1tWiwgeXl5eS1NTS1kZCBvciB5eXl5TU1kZFRISG1tc3NaKS4gSWYgbm8gdGltZXpvbmUgaXNcbiAqICAgIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGlucHV0LCB0aGUgdGltZSBpcyBjb25zaWRlcmVkIHRvIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gZm9ybWF0IEZvcm1hdHRpbmcgcnVsZXMgKHNlZSBEZXNjcmlwdGlvbikuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiAgICBgbWVkaXVtRGF0ZWAgaXMgdXNlZC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmcgb3IgdGhlIGlucHV0IGlmIGlucHV0IGlzIG5vdCByZWNvZ25pemVkIGFzIGRhdGUvbWlsbGlzLlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT57ezEyODgzMjM2MjMwMDYgfCBkYXRlOidtZWRpdW0nfX08L3NwYW4+OlxuICAgICAgICAgICB7ezEyODgzMjM2MjMwMDYgfCBkYXRlOidtZWRpdW0nfX08YnI+XG4gICAgICAgPHNwYW4gbmctbm9uLWJpbmRhYmxlPnt7MTI4ODMyMzYyMzAwNiB8IGRhdGU6J3l5eXktTU0tZGQgSEg6bW06c3MgWid9fTwvc3Bhbj46XG4gICAgICAgICAge3sxMjg4MzIzNjIzMDA2IHwgZGF0ZToneXl5eS1NTS1kZCBISDptbTpzcyBaJ319PGJyPlxuICAgICAgIDxzcGFuIG5nLW5vbi1iaW5kYWJsZT57ezEyODgzMjM2MjMwMDYgfCBkYXRlOidNTS9kZC95eXl5IEAgaDptbWEnfX08L3NwYW4+OlxuICAgICAgICAgIHt7JzEyODgzMjM2MjMwMDYnIHwgZGF0ZTonTU0vZGQveXl5eSBAIGg6bW1hJ319PGJyPlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBmb3JtYXQgZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoXCIxMjg4MzIzNjIzMDA2IHwgZGF0ZTonbWVkaXVtJ1wiKSkuXG4gICAgICAgICAgICB0b01hdGNoKC9PY3QgMlxcZCwgMjAxMCBcXGR7MSwyfTpcXGR7Mn06XFxkezJ9IChBTXxQTSkvKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKFwiMTI4ODMyMzYyMzAwNiB8IGRhdGU6J3l5eXktTU0tZGQgSEg6bW06c3MgWidcIikpLlxuICAgICAgICAgICAgdG9NYXRjaCgvMjAxMFxcLTEwXFwtMlxcZCBcXGR7Mn06XFxkezJ9OlxcZHsyfSAoXFwtfFxcKyk/XFxkezR9Lyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZyhcIicxMjg4MzIzNjIzMDA2JyB8IGRhdGU6J01NL2RkL3l5eXkgQCBoOm1tYSdcIikpLlxuICAgICAgICAgICAgdG9NYXRjaCgvMTBcXC8yXFxkXFwvMjAxMCBAIFxcZHsxLDJ9OlxcZHsyfShBTXxQTSkvKTtcbiAgICAgICB9KTtcbiAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5kYXRlRmlsdGVyLiRpbmplY3QgPSBbJyRsb2NhbGUnXTtcbmZ1bmN0aW9uIGRhdGVGaWx0ZXIoJGxvY2FsZSkge1xuXG5cbiAgdmFyIFJfSVNPODYwMV9TVFIgPSAvXihcXGR7NH0pLT8oXFxkXFxkKS0/KFxcZFxcZCkoPzpUKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlxcLihcXGQrKSk/KT8pPyhafChbKy1dKShcXGRcXGQpOj8oXFxkXFxkKSk/KT8kLztcbiAgICAgICAgICAgICAgICAgICAgIC8vIDEgICAgICAgIDIgICAgICAgMyAgICAgICAgIDQgICAgICAgICAgNSAgICAgICAgICA2ICAgICAgICAgIDcgICAgICAgICAgOCAgOSAgICAgMTAgICAgICAxMVxuICBmdW5jdGlvbiBqc29uU3RyaW5nVG9EYXRlKHN0cmluZykge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goUl9JU084NjAxX1NUUikpIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoMCksXG4gICAgICAgICAgdHpIb3VyID0gMCxcbiAgICAgICAgICB0ek1pbiAgPSAwLFxuICAgICAgICAgIGRhdGVTZXR0ZXIgPSBtYXRjaFs4XSA/IGRhdGUuc2V0VVRDRnVsbFllYXIgOiBkYXRlLnNldEZ1bGxZZWFyLFxuICAgICAgICAgIHRpbWVTZXR0ZXIgPSBtYXRjaFs4XSA/IGRhdGUuc2V0VVRDSG91cnMgOiBkYXRlLnNldEhvdXJzO1xuXG4gICAgICBpZiAobWF0Y2hbOV0pIHtcbiAgICAgICAgdHpIb3VyID0gaW50KG1hdGNoWzldICsgbWF0Y2hbMTBdKTtcbiAgICAgICAgdHpNaW4gPSBpbnQobWF0Y2hbOV0gKyBtYXRjaFsxMV0pO1xuICAgICAgfVxuICAgICAgZGF0ZVNldHRlci5jYWxsKGRhdGUsIGludChtYXRjaFsxXSksIGludChtYXRjaFsyXSkgLSAxLCBpbnQobWF0Y2hbM10pKTtcbiAgICAgIHZhciBoID0gaW50KG1hdGNoWzRdfHwwKSAtIHR6SG91cjtcbiAgICAgIHZhciBtID0gaW50KG1hdGNoWzVdfHwwKSAtIHR6TWluO1xuICAgICAgdmFyIHMgPSBpbnQobWF0Y2hbNl18fDApO1xuICAgICAgdmFyIG1zID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KCcwLicgKyAobWF0Y2hbN118fDApKSAqIDEwMDApO1xuICAgICAgdGltZVNldHRlci5jYWxsKGRhdGUsIGgsIG0sIHMsIG1zKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KSB7XG4gICAgdmFyIHRleHQgPSAnJyxcbiAgICAgICAgcGFydHMgPSBbXSxcbiAgICAgICAgZm4sIG1hdGNoO1xuXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICdtZWRpdW1EYXRlJztcbiAgICBmb3JtYXQgPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFNbZm9ybWF0XSB8fCBmb3JtYXQ7XG4gICAgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XG4gICAgICBpZiAoTlVNQkVSX1NUUklORy50ZXN0KGRhdGUpKSB7XG4gICAgICAgIGRhdGUgPSBpbnQoZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlID0ganNvblN0cmluZ1RvRGF0ZShkYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIoZGF0ZSkpIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRGF0ZShkYXRlKSkge1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgd2hpbGUoZm9ybWF0KSB7XG4gICAgICBtYXRjaCA9IERBVEVfRk9STUFUU19TUExJVC5leGVjKGZvcm1hdCk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcGFydHMgPSBjb25jYXQocGFydHMsIG1hdGNoLCAxKTtcbiAgICAgICAgZm9ybWF0ID0gcGFydHMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdCk7XG4gICAgICAgIGZvcm1hdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yRWFjaChwYXJ0cywgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgZm4gPSBEQVRFX0ZPUk1BVFNbdmFsdWVdO1xuICAgICAgdGV4dCArPSBmbiA/IGZuKGRhdGUsICRsb2NhbGUuREFURVRJTUVfRk9STUFUUylcbiAgICAgICAgICAgICAgICAgOiB2YWx1ZS5yZXBsYWNlKC8oXid8JyQpL2csICcnKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cblxuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG5nLmZpbHRlcjpqc29uXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgQWxsb3dzIHlvdSB0byBjb252ZXJ0IGEgSmF2YVNjcmlwdCBvYmplY3QgaW50byBKU09OIHN0cmluZy5cbiAqXG4gKiAgIFRoaXMgZmlsdGVyIGlzIG1vc3RseSB1c2VmdWwgZm9yIGRlYnVnZ2luZy4gV2hlbiB1c2luZyB0aGUgZG91YmxlIGN1cmx5IHt7dmFsdWV9fSBub3RhdGlvblxuICogICB0aGUgYmluZGluZyBpcyBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IEFueSBKYXZhU2NyaXB0IG9iamVjdCAoaW5jbHVkaW5nIGFycmF5cyBhbmQgcHJpbWl0aXZlIHR5cGVzKSB0byBmaWx0ZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBKU09OIHN0cmluZy5cbiAqXG4gKlxuICogQGV4YW1wbGU6XG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxwcmU+e3sgeyduYW1lJzondmFsdWUnfSB8IGpzb24gfX08L3ByZT5cbiAgICAgPC9kb2M6c291cmNlPlxuICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgIGl0KCdzaG91bGQganNvbmlmeSBmaWx0ZXJlZCBvYmplY3RzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoYmluZGluZyhcInsnbmFtZSc6J3ZhbHVlJ31cIikpLnRvTWF0Y2goL1xce1xcbiAgXCJuYW1lXCI6ID9cInZhbHVlXCJcXG59Lyk7XG4gICAgICAgfSk7XG4gICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqXG4gKi9cbmZ1bmN0aW9uIGpzb25GaWx0ZXIoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdG9Kc29uKG9iamVjdCwgdHJ1ZSk7XG4gIH07XG59XG5cblxuLyoqXG4gKiBAbmdkb2MgZmlsdGVyXG4gKiBAbmFtZSBuZy5maWx0ZXI6bG93ZXJjYXNlXG4gKiBAZnVuY3Rpb25cbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydHMgc3RyaW5nIHRvIGxvd2VyY2FzZS5cbiAqIEBzZWUgYW5ndWxhci5sb3dlcmNhc2VcbiAqL1xudmFyIGxvd2VyY2FzZUZpbHRlciA9IHZhbHVlRm4obG93ZXJjYXNlKTtcblxuXG4vKipcbiAqIEBuZ2RvYyBmaWx0ZXJcbiAqIEBuYW1lIG5nLmZpbHRlcjp1cHBlcmNhc2VcbiAqIEBmdW5jdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gdXBwZXJjYXNlLlxuICogQHNlZSBhbmd1bGFyLnVwcGVyY2FzZVxuICovXG52YXIgdXBwZXJjYXNlRmlsdGVyID0gdmFsdWVGbih1cHBlcmNhc2UpO1xuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgbmcuZmlsdGVyOmxpbWl0VG9cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSBvciBzdHJpbmcgY29udGFpbmluZyBvbmx5IGEgc3BlY2lmaWVkIG51bWJlciBvZiBlbGVtZW50cy4gVGhlIGVsZW1lbnRzXG4gKiBhcmUgdGFrZW4gZnJvbSBlaXRoZXIgdGhlIGJlZ2lubmluZyBvciB0aGUgZW5kIG9mIHRoZSBzb3VyY2UgYXJyYXkgb3Igc3RyaW5nLCBhcyBzcGVjaWZpZWQgYnlcbiAqIHRoZSB2YWx1ZSBhbmQgc2lnbiAocG9zaXRpdmUgb3IgbmVnYXRpdmUpIG9mIGBsaW1pdGAuXG4gKlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGlucHV0IFNvdXJjZSBhcnJheSBvciBzdHJpbmcgdG8gYmUgbGltaXRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbGltaXQgVGhlIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQgYXJyYXkgb3Igc3RyaW5nLiBJZiB0aGUgYGxpbWl0YCBudW1iZXIgXG4gKiAgICAgaXMgcG9zaXRpdmUsIGBsaW1pdGAgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGFycmF5L3N0cmluZyBhcmUgY29waWVkLlxuICogICAgIElmIHRoZSBudW1iZXIgaXMgbmVnYXRpdmUsIGBsaW1pdGAgbnVtYmVyICBvZiBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBhcnJheS9zdHJpbmcgXG4gKiAgICAgYXJlIGNvcGllZC4gVGhlIGBsaW1pdGAgd2lsbCBiZSB0cmltbWVkIGlmIGl0IGV4Y2VlZHMgYGFycmF5Lmxlbmd0aGBcbiAqIEByZXR1cm5zIHtBcnJheXxzdHJpbmd9IEEgbmV3IHN1Yi1hcnJheSBvciBzdWJzdHJpbmcgb2YgbGVuZ3RoIGBsaW1pdGAgb3IgbGVzcyBpZiBpbnB1dCBhcnJheVxuICogICAgIGhhZCBsZXNzIHRoYW4gYGxpbWl0YCBlbGVtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICA8c2NyaXB0PlxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgJHNjb3BlLm51bWJlcnMgPSBbMSwyLDMsNCw1LDYsNyw4LDldO1xuICAgICAgICAgICAkc2NvcGUubGV0dGVycyA9IFwiYWJjZGVmZ2hpXCI7XG4gICAgICAgICAgICRzY29wZS5udW1MaW1pdCA9IDM7XG4gICAgICAgICAgICRzY29wZS5sZXR0ZXJMaW1pdCA9IDM7XG4gICAgICAgICB9XG4gICAgICAgPC9zY3JpcHQ+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgTGltaXQge3tudW1iZXJzfX0gdG86IDxpbnB1dCB0eXBlPVwiaW50ZWdlclwiIG5nLW1vZGVsPVwibnVtTGltaXRcIj5cbiAgICAgICAgIDxwPk91dHB1dCBudW1iZXJzOiB7eyBudW1iZXJzIHwgbGltaXRUbzpudW1MaW1pdCB9fTwvcD5cbiAgICAgICAgIExpbWl0IHt7bGV0dGVyc319IHRvOiA8aW5wdXQgdHlwZT1cImludGVnZXJcIiBuZy1tb2RlbD1cImxldHRlckxpbWl0XCI+XG4gICAgICAgICA8cD5PdXRwdXQgbGV0dGVyczoge3sgbGV0dGVycyB8IGxpbWl0VG86bGV0dGVyTGltaXQgfX08L3A+XG4gICAgICAgPC9kaXY+XG4gICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICBpdCgnc2hvdWxkIGxpbWl0IHRoZSBudW1iZXIgYXJyYXkgdG8gZmlyc3QgdGhyZWUgaXRlbXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBpbnB1dFtuZy1tb2RlbD1udW1MaW1pdF0nKS52YWwoKSkudG9CZSgnMycpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGlucHV0W25nLW1vZGVsPWxldHRlckxpbWl0XScpLnZhbCgpKS50b0JlKCczJyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnbnVtYmVycyB8IGxpbWl0VG86bnVtTGltaXQnKSkudG9FcXVhbCgnWzEsMiwzXScpO1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xldHRlcnMgfCBsaW1pdFRvOmxldHRlckxpbWl0JykpLnRvRXF1YWwoJ2FiYycpO1xuICAgICAgIH0pO1xuXG4gICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgdGhlIG91dHB1dCB3aGVuIC0zIGlzIGVudGVyZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGlucHV0KCdudW1MaW1pdCcpLmVudGVyKC0zKTtcbiAgICAgICAgIGlucHV0KCdsZXR0ZXJMaW1pdCcpLmVudGVyKC0zKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdudW1iZXJzIHwgbGltaXRUbzpudW1MaW1pdCcpKS50b0VxdWFsKCdbNyw4LDldJyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGV0dGVycyB8IGxpbWl0VG86bGV0dGVyTGltaXQnKSkudG9FcXVhbCgnZ2hpJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIG5vdCBleGNlZWQgdGhlIG1heGltdW0gc2l6ZSBvZiBpbnB1dCBhcnJheScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgaW5wdXQoJ251bUxpbWl0JykuZW50ZXIoMTAwKTtcbiAgICAgICAgIGlucHV0KCdsZXR0ZXJMaW1pdCcpLmVudGVyKDEwMCk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnbnVtYmVycyB8IGxpbWl0VG86bnVtTGltaXQnKSkudG9FcXVhbCgnWzEsMiwzLDQsNSw2LDcsOCw5XScpO1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xldHRlcnMgfCBsaW1pdFRvOmxldHRlckxpbWl0JykpLnRvRXF1YWwoJ2FiY2RlZmdoaScpO1xuICAgICAgIH0pO1xuICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cbmZ1bmN0aW9uIGxpbWl0VG9GaWx0ZXIoKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBsaW1pdCkge1xuICAgIGlmICghaXNBcnJheShpbnB1dCkgJiYgIWlzU3RyaW5nKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICAgIFxuICAgIGxpbWl0ID0gaW50KGxpbWl0KTtcblxuICAgIGlmIChpc1N0cmluZyhpbnB1dCkpIHtcbiAgICAgIC8vTmFOIGNoZWNrIG9uIGxpbWl0XG4gICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGxpbWl0ID49IDAgPyBpbnB1dC5zbGljZSgwLCBsaW1pdCkgOiBpbnB1dC5zbGljZShsaW1pdCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvdXQgPSBbXSxcbiAgICAgIGksIG47XG5cbiAgICAvLyBpZiBhYnMobGltaXQpIGV4Y2VlZHMgbWF4aW11bSBsZW5ndGgsIHRyaW0gaXRcbiAgICBpZiAobGltaXQgPiBpbnB1dC5sZW5ndGgpXG4gICAgICBsaW1pdCA9IGlucHV0Lmxlbmd0aDtcbiAgICBlbHNlIGlmIChsaW1pdCA8IC1pbnB1dC5sZW5ndGgpXG4gICAgICBsaW1pdCA9IC1pbnB1dC5sZW5ndGg7XG5cbiAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICBpID0gMDtcbiAgICAgIG4gPSBsaW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IGlucHV0Lmxlbmd0aCArIGxpbWl0O1xuICAgICAgbiA9IGlucHV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKDsgaTxuOyBpKyspIHtcbiAgICAgIG91dC5wdXNoKGlucHV0W2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufVxuXG4vKipcbiAqIEBuZ2RvYyBmdW5jdGlvblxuICogQG5hbWUgbmcuZmlsdGVyOm9yZGVyQnlcbiAqIEBmdW5jdGlvblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogT3JkZXJzIGEgc3BlY2lmaWVkIGBhcnJheWAgYnkgdGhlIGBleHByZXNzaW9uYCBwcmVkaWNhdGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfHN0cmluZ3xBcnJheS48KGZ1bmN0aW9uKCopfHN0cmluZyk+fSBleHByZXNzaW9uIEEgcHJlZGljYXRlIHRvIGJlXG4gKiAgICB1c2VkIGJ5IHRoZSBjb21wYXJhdG9yIHRvIGRldGVybWluZSB0aGUgb3JkZXIgb2YgZWxlbWVudHMuXG4gKlxuICogICAgQ2FuIGJlIG9uZSBvZjpcbiAqXG4gKiAgICAtIGBmdW5jdGlvbmA6IEdldHRlciBmdW5jdGlvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgc29ydGVkIHVzaW5nIHRoZVxuICogICAgICBgPGAsIGA9YCwgYD5gIG9wZXJhdG9yLlxuICogICAgLSBgc3RyaW5nYDogQW4gQW5ndWxhciBleHByZXNzaW9uIHdoaWNoIGV2YWx1YXRlcyB0byBhbiBvYmplY3QgdG8gb3JkZXIgYnksIHN1Y2ggYXMgJ25hbWUnXG4gKiAgICAgIHRvIHNvcnQgYnkgYSBwcm9wZXJ0eSBjYWxsZWQgJ25hbWUnLiBPcHRpb25hbGx5IHByZWZpeGVkIHdpdGggYCtgIG9yIGAtYCB0byBjb250cm9sXG4gKiAgICAgIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIHNvcnQgb3JkZXIgKGZvciBleGFtcGxlLCArbmFtZSBvciAtbmFtZSkuXG4gKiAgICAtIGBBcnJheWA6IEFuIGFycmF5IG9mIGZ1bmN0aW9uIG9yIHN0cmluZyBwcmVkaWNhdGVzLiBUaGUgZmlyc3QgcHJlZGljYXRlIGluIHRoZSBhcnJheVxuICogICAgICBpcyB1c2VkIGZvciBzb3J0aW5nLCBidXQgd2hlbiB0d28gaXRlbXMgYXJlIGVxdWl2YWxlbnQsIHRoZSBuZXh0IHByZWRpY2F0ZSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHJldmVyc2UgUmV2ZXJzZSB0aGUgb3JkZXIgdGhlIGFycmF5LlxuICogQHJldHVybnMge0FycmF5fSBTb3J0ZWQgY29weSBvZiB0aGUgc291cmNlIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAgICAkc2NvcGUuZnJpZW5kcyA9XG4gICAgICAgICAgICAgICBbe25hbWU6J0pvaG4nLCBwaG9uZTonNTU1LTEyMTInLCBhZ2U6MTB9LFxuICAgICAgICAgICAgICAgIHtuYW1lOidNYXJ5JywgcGhvbmU6JzU1NS05ODc2JywgYWdlOjE5fSxcbiAgICAgICAgICAgICAgICB7bmFtZTonTWlrZScsIHBob25lOic1NTUtNDMyMScsIGFnZToyMX0sXG4gICAgICAgICAgICAgICAge25hbWU6J0FkYW0nLCBwaG9uZTonNTU1LTU2NzgnLCBhZ2U6MzV9LFxuICAgICAgICAgICAgICAgIHtuYW1lOidKdWxpZScsIHBob25lOic1NTUtODc2NScsIGFnZToyOX1dXG4gICAgICAgICAgICRzY29wZS5wcmVkaWNhdGUgPSAnLWFnZSc7XG4gICAgICAgICB9XG4gICAgICAgPC9zY3JpcHQ+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgPHByZT5Tb3J0aW5nIHByZWRpY2F0ZSA9IHt7cHJlZGljYXRlfX07IHJldmVyc2UgPSB7e3JldmVyc2V9fTwvcHJlPlxuICAgICAgICAgPGhyLz5cbiAgICAgICAgIFsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicHJlZGljYXRlPScnXCI+dW5zb3J0ZWQ8L2E+IF1cbiAgICAgICAgIDx0YWJsZSBjbGFzcz1cImZyaWVuZFwiPlxuICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgPHRoPjxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInByZWRpY2F0ZSA9ICduYW1lJzsgcmV2ZXJzZT1mYWxzZVwiPk5hbWU8L2E+XG4gICAgICAgICAgICAgICAgICg8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJwcmVkaWNhdGUgPSAnLW5hbWUnOyByZXZlcnNlPWZhbHNlXCI+XjwvYT4pPC90aD5cbiAgICAgICAgICAgICA8dGg+PGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicHJlZGljYXRlID0gJ3Bob25lJzsgcmV2ZXJzZT0hcmV2ZXJzZVwiPlBob25lIE51bWJlcjwvYT48L3RoPlxuICAgICAgICAgICAgIDx0aD48YSBocmVmPVwiXCIgbmctY2xpY2s9XCJwcmVkaWNhdGUgPSAnYWdlJzsgcmV2ZXJzZT0hcmV2ZXJzZVwiPkFnZTwvYT48L3RoPlxuICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICA8dHIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBvcmRlckJ5OnByZWRpY2F0ZTpyZXZlcnNlXCI+XG4gICAgICAgICAgICAgPHRkPnt7ZnJpZW5kLm5hbWV9fTwvdGQ+XG4gICAgICAgICAgICAgPHRkPnt7ZnJpZW5kLnBob25lfX08L3RkPlxuICAgICAgICAgICAgIDx0ZD57e2ZyaWVuZC5hZ2V9fTwvdGQ+XG4gICAgICAgICAgIDwvdHI+XG4gICAgICAgICA8L3RhYmxlPlxuICAgICAgIDwvZGl2PlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBiZSByZXZlcnNlIG9yZGVyZWQgYnkgYWdlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ByZWRpY2F0ZScpKS50b0JlKCctYWdlJyk7XG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLmFnZScpKS5cbiAgICAgICAgICAgdG9FcXVhbChbJzM1JywgJzI5JywgJzIxJywgJzE5JywgJzEwJ10pO1xuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCd0YWJsZS5mcmllbmQnLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5uYW1lJykpLlxuICAgICAgICAgICB0b0VxdWFsKFsnQWRhbScsICdKdWxpZScsICdNaWtlJywgJ01hcnknLCAnSm9obiddKTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgcmVvcmRlciB0aGUgdGFibGUgd2hlbiB1c2VyIHNlbGVjdHMgZGlmZmVyZW50IHByZWRpY2F0ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgYTpjb250YWlucyhcIk5hbWVcIiknKS5jbGljaygpO1xuICAgICAgICAgZXhwZWN0KHJlcGVhdGVyKCd0YWJsZS5mcmllbmQnLCAnZnJpZW5kIGluIGZyaWVuZHMnKS5jb2x1bW4oJ2ZyaWVuZC5uYW1lJykpLlxuICAgICAgICAgICB0b0VxdWFsKFsnQWRhbScsICdKb2huJywgJ0p1bGllJywgJ01hcnknLCAnTWlrZSddKTtcbiAgICAgICAgIGV4cGVjdChyZXBlYXRlcigndGFibGUuZnJpZW5kJywgJ2ZyaWVuZCBpbiBmcmllbmRzJykuY29sdW1uKCdmcmllbmQuYWdlJykpLlxuICAgICAgICAgICB0b0VxdWFsKFsnMzUnLCAnMTAnLCAnMjknLCAnMTknLCAnMjEnXSk7XG5cbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIGE6Y29udGFpbnMoXCJQaG9uZVwiKScpLmNsaWNrKCk7XG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLnBob25lJykpLlxuICAgICAgICAgICB0b0VxdWFsKFsnNTU1LTk4NzYnLCAnNTU1LTg3NjUnLCAnNTU1LTU2NzgnLCAnNTU1LTQzMjEnLCAnNTU1LTEyMTInXSk7XG4gICAgICAgICBleHBlY3QocmVwZWF0ZXIoJ3RhYmxlLmZyaWVuZCcsICdmcmllbmQgaW4gZnJpZW5kcycpLmNvbHVtbignZnJpZW5kLm5hbWUnKSkuXG4gICAgICAgICAgIHRvRXF1YWwoWydNYXJ5JywgJ0p1bGllJywgJ0FkYW0nLCAnTWlrZScsICdKb2huJ10pO1xuICAgICAgIH0pO1xuICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cbm9yZGVyQnlGaWx0ZXIuJGluamVjdCA9IFsnJHBhcnNlJ107XG5mdW5jdGlvbiBvcmRlckJ5RmlsdGVyKCRwYXJzZSl7XG4gIHJldHVybiBmdW5jdGlvbihhcnJheSwgc29ydFByZWRpY2F0ZSwgcmV2ZXJzZU9yZGVyKSB7XG4gICAgaWYgKCFpc0FycmF5KGFycmF5KSkgcmV0dXJuIGFycmF5O1xuICAgIGlmICghc29ydFByZWRpY2F0ZSkgcmV0dXJuIGFycmF5O1xuICAgIHNvcnRQcmVkaWNhdGUgPSBpc0FycmF5KHNvcnRQcmVkaWNhdGUpID8gc29ydFByZWRpY2F0ZTogW3NvcnRQcmVkaWNhdGVdO1xuICAgIHNvcnRQcmVkaWNhdGUgPSBtYXAoc29ydFByZWRpY2F0ZSwgZnVuY3Rpb24ocHJlZGljYXRlKXtcbiAgICAgIHZhciBkZXNjZW5kaW5nID0gZmFsc2UsIGdldCA9IHByZWRpY2F0ZSB8fCBpZGVudGl0eTtcbiAgICAgIGlmIChpc1N0cmluZyhwcmVkaWNhdGUpKSB7XG4gICAgICAgIGlmICgocHJlZGljYXRlLmNoYXJBdCgwKSA9PSAnKycgfHwgcHJlZGljYXRlLmNoYXJBdCgwKSA9PSAnLScpKSB7XG4gICAgICAgICAgZGVzY2VuZGluZyA9IHByZWRpY2F0ZS5jaGFyQXQoMCkgPT0gJy0nO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ID0gJHBhcnNlKHByZWRpY2F0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV2ZXJzZUNvbXBhcmF0b3IoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUoZ2V0KGEpLGdldChiKSk7XG4gICAgICB9LCBkZXNjZW5kaW5nKTtcbiAgICB9KTtcbiAgICB2YXIgYXJyYXlDb3B5ID0gW107XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgYXJyYXlDb3B5LnB1c2goYXJyYXlbaV0pOyB9XG4gICAgcmV0dXJuIGFycmF5Q29weS5zb3J0KHJldmVyc2VDb21wYXJhdG9yKGNvbXBhcmF0b3IsIHJldmVyc2VPcmRlcikpO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRvcihvMSwgbzIpe1xuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc29ydFByZWRpY2F0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29tcCA9IHNvcnRQcmVkaWNhdGVbaV0obzEsIG8yKTtcbiAgICAgICAgaWYgKGNvbXAgIT09IDApIHJldHVybiBjb21wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldmVyc2VDb21wYXJhdG9yKGNvbXAsIGRlc2NlbmRpbmcpIHtcbiAgICAgIHJldHVybiB0b0Jvb2xlYW4oZGVzY2VuZGluZylcbiAgICAgICAgICA/IGZ1bmN0aW9uKGEsYil7cmV0dXJuIGNvbXAoYixhKTt9XG4gICAgICAgICAgOiBjb21wO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKHYxLCB2Mil7XG4gICAgICB2YXIgdDEgPSB0eXBlb2YgdjE7XG4gICAgICB2YXIgdDIgPSB0eXBlb2YgdjI7XG4gICAgICBpZiAodDEgPT0gdDIpIHtcbiAgICAgICAgaWYgKHQxID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgdjEgPSB2MS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICB2MiA9IHYyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYxID09PSB2MikgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiB2MSA8IHYyID8gLTEgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHQxIDwgdDIgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBuZ0RpcmVjdGl2ZShkaXJlY3RpdmUpIHtcbiAgaWYgKGlzRnVuY3Rpb24oZGlyZWN0aXZlKSkge1xuICAgIGRpcmVjdGl2ZSA9IHtcbiAgICAgIGxpbms6IGRpcmVjdGl2ZVxuICAgIH07XG4gIH1cbiAgZGlyZWN0aXZlLnJlc3RyaWN0ID0gZGlyZWN0aXZlLnJlc3RyaWN0IHx8ICdBQyc7XG4gIHJldHVybiB2YWx1ZUZuKGRpcmVjdGl2ZSk7XG59XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOmFcbiAqIEByZXN0cmljdCBFXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNb2RpZmllcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgaHRtbCBBIHRhZyBzbyB0aGF0IHRoZSBkZWZhdWx0IGFjdGlvbiBpcyBwcmV2ZW50ZWQgd2hlblxuICogdGhlIGhyZWYgYXR0cmlidXRlIGlzIGVtcHR5LlxuICpcbiAqIFRoaXMgY2hhbmdlIHBlcm1pdHMgdGhlIGVhc3kgY3JlYXRpb24gb2YgYWN0aW9uIGxpbmtzIHdpdGggdGhlIGBuZ0NsaWNrYCBkaXJlY3RpdmVcbiAqIHdpdGhvdXQgY2hhbmdpbmcgdGhlIGxvY2F0aW9uIG9yIGNhdXNpbmcgcGFnZSByZWxvYWRzLCBlLmcuOlxuICogYDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cImxpc3QuYWRkSXRlbSgpXCI+QWRkIEl0ZW08L2E+YFxuICovXG52YXIgaHRtbEFuY2hvckRpcmVjdGl2ZSA9IHZhbHVlRm4oe1xuICByZXN0cmljdDogJ0UnLFxuICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG5cbiAgICBpZiAobXNpZSA8PSA4KSB7XG5cbiAgICAgIC8vIHR1cm4gPGEgaHJlZiBuZy1jbGljaz1cIi4uXCI+bGluazwvYT4gaW50byBhIHN0eWxhYmxlIGxpbmsgaW4gSUVcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIGl0IGRvZXNuJ3QgaGF2ZSBuYW1lIGF0dHJpYnV0ZSwgaW4gd2hpY2ggY2FzZSBpdCdzIGFuIGFuY2hvclxuICAgICAgaWYgKCFhdHRyLmhyZWYgJiYgIWF0dHIubmFtZSkge1xuICAgICAgICBhdHRyLiRzZXQoJ2hyZWYnLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBhIGNvbW1lbnQgbm9kZSB0byBhbmNob3JzIHRvIHdvcmthcm91bmQgSUUgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnQgY29udGVudCB0byBiZSByZXNldFxuICAgICAgLy8gdG8gbmV3IGF0dHJpYnV0ZSBjb250ZW50IGlmIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIHdpdGggdmFsdWUgY29udGFpbmluZyBAIGFuZCBlbGVtZW50IGFsc29cbiAgICAgIC8vIGNvbnRhaW5zIHZhbHVlIHdpdGggQFxuICAgICAgLy8gc2VlIGlzc3VlICMxOTQ5XG4gICAgICBlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVDb21tZW50KCdJRSBmaXgnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRyLmhyZWYgJiYgIWF0dHIubmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gaHJlZiB1cmwsIHRoZW4gZG9uJ3QgbmF2aWdhdGUgYW55d2hlcmUuXG4gICAgICAgICAgaWYgKCFlbGVtZW50LmF0dHIoJ2hyZWYnKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0hyZWZcbiAqIEByZXN0cmljdCBBXG4gKiBAcHJpb3JpdHkgOTlcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFVzaW5nIEFuZ3VsYXIgbWFya3VwIGxpa2UgYHt7aGFzaH19YCBpbiBhbiBocmVmIGF0dHJpYnV0ZSB3aWxsXG4gKiBtYWtlIHRoZSBsaW5rIGdvIHRvIHRoZSB3cm9uZyBVUkwgaWYgdGhlIHVzZXIgY2xpY2tzIGl0IGJlZm9yZVxuICogQW5ndWxhciBoYXMgYSBjaGFuY2UgdG8gcmVwbGFjZSB0aGUgYHt7aGFzaH19YCBtYXJrdXAgd2l0aCBpdHNcbiAqIHZhbHVlLiBVbnRpbCBBbmd1bGFyIHJlcGxhY2VzIHRoZSBtYXJrdXAgdGhlIGxpbmsgd2lsbCBiZSBicm9rZW5cbiAqIGFuZCB3aWxsIG1vc3QgbGlrZWx5IHJldHVybiBhIDQwNCBlcnJvci5cbiAqXG4gKiBUaGUgYG5nSHJlZmAgZGlyZWN0aXZlIHNvbHZlcyB0aGlzIHByb2JsZW0uXG4gKlxuICogVGhlIHdyb25nIHdheSB0byB3cml0ZSBpdDpcbiAqIDxwcmU+XG4gKiA8YSBocmVmPVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19XCIvPlxuICogPC9wcmU+XG4gKlxuICogVGhlIGNvcnJlY3Qgd2F5IHRvIHdyaXRlIGl0OlxuICogPHByZT5cbiAqIDxhIG5nLWhyZWY9XCJodHRwOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIve3toYXNofX1cIi8+XG4gKiA8L3ByZT5cbiAqXG4gKiBAZWxlbWVudCBBXG4gKiBAcGFyYW0ge3RlbXBsYXRlfSBuZ0hyZWYgYW55IHN0cmluZyB3aGljaCBjYW4gY29udGFpbiBge3t9fWAgbWFya3VwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBUaGlzIGV4YW1wbGUgc2hvd3MgdmFyaW91cyBjb21iaW5hdGlvbnMgb2YgYGhyZWZgLCBgbmctaHJlZmAgYW5kIGBuZy1jbGlja2AgYXR0cmlidXRlc1xuICogaW4gbGlua3MgYW5kIHRoZWlyIGRpZmZlcmVudCBiZWhhdmlvcnM6XG4gICAgPGRvYzpleGFtcGxlPlxuICAgICAgPGRvYzpzb3VyY2U+XG4gICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInZhbHVlXCIgLz48YnIgLz5cbiAgICAgICAgPGEgaWQ9XCJsaW5rLTFcIiBocmVmIG5nLWNsaWNrPVwidmFsdWUgPSAxXCI+bGluayAxPC9hPiAobGluaywgZG9uJ3QgcmVsb2FkKTxiciAvPlxuICAgICAgICA8YSBpZD1cImxpbmstMlwiIGhyZWY9XCJcIiBuZy1jbGljaz1cInZhbHVlID0gMlwiPmxpbmsgMjwvYT4gKGxpbmssIGRvbid0IHJlbG9hZCk8YnIgLz5cbiAgICAgICAgPGEgaWQ9XCJsaW5rLTNcIiBuZy1ocmVmPVwiL3t7JzEyMyd9fVwiPmxpbmsgMzwvYT4gKGxpbmssIHJlbG9hZCEpPGJyIC8+XG4gICAgICAgIDxhIGlkPVwibGluay00XCIgaHJlZj1cIlwiIG5hbWU9XCJ4eFwiIG5nLWNsaWNrPVwidmFsdWUgPSA0XCI+YW5jaG9yPC9hPiAobGluaywgZG9uJ3QgcmVsb2FkKTxiciAvPlxuICAgICAgICA8YSBpZD1cImxpbmstNVwiIG5hbWU9XCJ4eHhcIiBuZy1jbGljaz1cInZhbHVlID0gNVwiPmFuY2hvcjwvYT4gKG5vIGxpbmspPGJyIC8+XG4gICAgICAgIDxhIGlkPVwibGluay02XCIgbmctaHJlZj1cInt7dmFsdWV9fVwiPmxpbms8L2E+IChsaW5rLCBjaGFuZ2UgbG9jYXRpb24pXG4gICAgICA8L2RvYzpzb3VyY2U+XG4gICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgbmctY2xpY2sgYnV0IG5vdCByZWxvYWQgd2hlbiBocmVmIHdpdGhvdXQgdmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50KCcjbGluay0xJykuY2xpY2soKTtcbiAgICAgICAgICBleHBlY3QoaW5wdXQoJ3ZhbHVlJykudmFsKCkpLnRvRXF1YWwoJzEnKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstMScpLmF0dHIoJ2hyZWYnKSkudG9CZShcIlwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIG5nLWNsaWNrIGJ1dCBub3QgcmVsb2FkIHdoZW4gaHJlZiBlbXB0eSBzdHJpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50KCcjbGluay0yJykuY2xpY2soKTtcbiAgICAgICAgICBleHBlY3QoaW5wdXQoJ3ZhbHVlJykudmFsKCkpLnRvRXF1YWwoJzInKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstMicpLmF0dHIoJ2hyZWYnKSkudG9CZShcIlwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIG5nLWNsaWNrIGFuZCBjaGFuZ2UgdXJsIHdoZW4gbmctaHJlZiBzcGVjaWZpZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstMycpLmF0dHIoJ2hyZWYnKSkudG9CZShcIi8xMjNcIik7XG5cbiAgICAgICAgICBlbGVtZW50KCcjbGluay0zJykuY2xpY2soKTtcbiAgICAgICAgICBleHBlY3QoYnJvd3NlcigpLndpbmRvdygpLnBhdGgoKSkudG9FcXVhbCgnLzEyMycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgbmctY2xpY2sgYnV0IG5vdCByZWxvYWQgd2hlbiBocmVmIGVtcHR5IHN0cmluZyBhbmQgbmFtZSBzcGVjaWZpZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50KCcjbGluay00JykuY2xpY2soKTtcbiAgICAgICAgICBleHBlY3QoaW5wdXQoJ3ZhbHVlJykudmFsKCkpLnRvRXF1YWwoJzQnKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2xpbmstNCcpLmF0dHIoJ2hyZWYnKSkudG9CZSgnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBuZy1jbGljayBidXQgbm90IHJlbG9hZCB3aGVuIG5vIGhyZWYgYnV0IG5hbWUgc3BlY2lmaWVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZWxlbWVudCgnI2xpbmstNScpLmNsaWNrKCk7XG4gICAgICAgICAgZXhwZWN0KGlucHV0KCd2YWx1ZScpLnZhbCgpKS50b0VxdWFsKCc1Jyk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNsaW5rLTUnKS5hdHRyKCdocmVmJykpLnRvQmUodW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBvbmx5IGNoYW5nZSB1cmwgd2hlbiBvbmx5IG5nLWhyZWYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpbnB1dCgndmFsdWUnKS5lbnRlcignNicpO1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjbGluay02JykuYXR0cignaHJlZicpKS50b0JlKCc2Jyk7XG5cbiAgICAgICAgICBlbGVtZW50KCcjbGluay02JykuY2xpY2soKTtcbiAgICAgICAgICBleHBlY3QoYnJvd3NlcigpLmxvY2F0aW9uKCkudXJsKCkpLnRvRXF1YWwoJy82Jyk7XG4gICAgICAgIH0pO1xuICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1NyY1xuICogQHJlc3RyaWN0IEFcbiAqIEBwcmlvcml0eSA5OVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVXNpbmcgQW5ndWxhciBtYXJrdXAgbGlrZSBge3toYXNofX1gIGluIGEgYHNyY2AgYXR0cmlidXRlIGRvZXNuJ3RcbiAqIHdvcmsgcmlnaHQ6IFRoZSBicm93c2VyIHdpbGwgZmV0Y2ggZnJvbSB0aGUgVVJMIHdpdGggdGhlIGxpdGVyYWxcbiAqIHRleHQgYHt7aGFzaH19YCB1bnRpbCBBbmd1bGFyIHJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluc2lkZVxuICogYHt7aGFzaH19YC4gVGhlIGBuZ1NyY2AgZGlyZWN0aXZlIHNvbHZlcyB0aGlzIHByb2JsZW0uXG4gKlxuICogVGhlIGJ1Z2d5IHdheSB0byB3cml0ZSBpdDpcbiAqIDxwcmU+XG4gKiA8aW1nIHNyYz1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fVwiLz5cbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBjb3JyZWN0IHdheSB0byB3cml0ZSBpdDpcbiAqIDxwcmU+XG4gKiA8aW1nIG5nLXNyYz1cImh0dHA6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci97e2hhc2h9fVwiLz5cbiAqIDwvcHJlPlxuICpcbiAqIEBlbGVtZW50IElNR1xuICogQHBhcmFtIHt0ZW1wbGF0ZX0gbmdTcmMgYW55IHN0cmluZyB3aGljaCBjYW4gY29udGFpbiBge3t9fWAgbWFya3VwLlxuICovXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU3Jjc2V0XG4gKiBAcmVzdHJpY3QgQVxuICogQHByaW9yaXR5IDk5XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2luZyBBbmd1bGFyIG1hcmt1cCBsaWtlIGB7e2hhc2h9fWAgaW4gYSBgc3Jjc2V0YCBhdHRyaWJ1dGUgZG9lc24ndFxuICogd29yayByaWdodDogVGhlIGJyb3dzZXIgd2lsbCBmZXRjaCBmcm9tIHRoZSBVUkwgd2l0aCB0aGUgbGl0ZXJhbFxuICogdGV4dCBge3toYXNofX1gIHVudGlsIEFuZ3VsYXIgcmVwbGFjZXMgdGhlIGV4cHJlc3Npb24gaW5zaWRlXG4gKiBge3toYXNofX1gLiBUaGUgYG5nU3Jjc2V0YCBkaXJlY3RpdmUgc29sdmVzIHRoaXMgcHJvYmxlbS5cbiAqXG4gKiBUaGUgYnVnZ3kgd2F5IHRvIHdyaXRlIGl0OlxuICogPHByZT5cbiAqIDxpbWcgc3Jjc2V0PVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19IDJ4XCIvPlxuICogPC9wcmU+XG4gKlxuICogVGhlIGNvcnJlY3Qgd2F5IHRvIHdyaXRlIGl0OlxuICogPHByZT5cbiAqIDxpbWcgbmctc3Jjc2V0PVwiaHR0cDovL3d3dy5ncmF2YXRhci5jb20vYXZhdGFyL3t7aGFzaH19IDJ4XCIvPlxuICogPC9wcmU+XG4gKlxuICogQGVsZW1lbnQgSU1HXG4gKiBAcGFyYW0ge3RlbXBsYXRlfSBuZ1NyY3NldCBhbnkgc3RyaW5nIHdoaWNoIGNhbiBjb250YWluIGB7e319YCBtYXJrdXAuXG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdEaXNhYmxlZFxuICogQHJlc3RyaWN0IEFcbiAqIEBwcmlvcml0eSAxMDBcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBUaGUgZm9sbG93aW5nIG1hcmt1cCB3aWxsIG1ha2UgdGhlIGJ1dHRvbiBlbmFibGVkIG9uIENocm9tZS9GaXJlZm94IGJ1dCBub3Qgb24gSUU4IGFuZCBvbGRlciBJRXM6XG4gKiA8cHJlPlxuICogPGRpdiBuZy1pbml0PVwic2NvcGUgPSB7IGlzRGlzYWJsZWQ6IGZhbHNlIH1cIj5cbiAqICA8YnV0dG9uIGRpc2FibGVkPVwie3tzY29wZS5pc0Rpc2FibGVkfX1cIj5EaXNhYmxlZDwvYnV0dG9uPlxuICogPC9kaXY+XG4gKiA8L3ByZT5cbiAqXG4gKiBUaGUgSFRNTCBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHZhbHVlcyBvZiBib29sZWFuIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGlzYWJsZWQuIChUaGVpciBwcmVzZW5jZSBtZWFucyB0cnVlIGFuZCB0aGVpciBhYnNlbmNlIG1lYW5zIGZhbHNlLilcbiAqIElmIHdlIHB1dCBhbiBBbmd1bGFyIGludGVycG9sYXRpb24gZXhwcmVzc2lvbiBpbnRvIHN1Y2ggYW4gYXR0cmlidXRlIHRoZW4gdGhlXG4gKiBiaW5kaW5nIGluZm9ybWF0aW9uIHdvdWxkIGJlIGxvc3Qgd2hlbiB0aGUgYnJvd3NlciByZW1vdmVzIHRoZSBhdHRyaWJ1dGUuXG4gKiBUaGUgYG5nRGlzYWJsZWRgIGRpcmVjdGl2ZSBzb2x2ZXMgdGhpcyBwcm9ibGVtIGZvciB0aGUgYGRpc2FibGVkYCBhdHRyaWJ1dGUuXG4gKiBUaGlzIGNvbXBsZW1lbnRhcnkgZGlyZWN0aXZlIGlzIG5vdCByZW1vdmVkIGJ5IHRoZSBicm93c2VyIGFuZCBzbyBwcm92aWRlc1xuICogYSBwZXJtYW5lbnQgcmVsaWFibGUgcGxhY2UgdG8gc3RvcmUgdGhlIGJpbmRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgQ2xpY2sgbWUgdG8gdG9nZ2xlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjaGVja2VkXCI+PGJyLz5cbiAgICAgICAgPGJ1dHRvbiBuZy1tb2RlbD1cImJ1dHRvblwiIG5nLWRpc2FibGVkPVwiY2hlY2tlZFwiPkJ1dHRvbjwvYnV0dG9uPlxuICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICAgaXQoJ3Nob3VsZCB0b2dnbGUgYnV0dG9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b24nKS5wcm9wKCdkaXNhYmxlZCcpKS50b0JlRmFsc3koKTtcbiAgICAgICAgICBpbnB1dCgnY2hlY2tlZCcpLmNoZWNrKCk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b24nKS5wcm9wKCdkaXNhYmxlZCcpKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIH0pO1xuICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgPC9kb2M6ZXhhbXBsZT5cbiAqXG4gKiBAZWxlbWVudCBJTlBVVFxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0Rpc2FibGVkIElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHksIFxuICogICAgIHRoZW4gc3BlY2lhbCBhdHRyaWJ1dGUgXCJkaXNhYmxlZFwiIHdpbGwgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NoZWNrZWRcbiAqIEByZXN0cmljdCBBXG4gKiBAcHJpb3JpdHkgMTAwXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgSFRNTCBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHZhbHVlcyBvZiBib29sZWFuIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgY2hlY2tlZC4gKFRoZWlyIHByZXNlbmNlIG1lYW5zIHRydWUgYW5kIHRoZWlyIGFic2VuY2UgbWVhbnMgZmFsc2UuKVxuICogSWYgd2UgcHV0IGFuIEFuZ3VsYXIgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uIGludG8gc3VjaCBhbiBhdHRyaWJ1dGUgdGhlbiB0aGVcbiAqIGJpbmRpbmcgaW5mb3JtYXRpb24gd291bGQgYmUgbG9zdCB3aGVuIHRoZSBicm93c2VyIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZS5cbiAqIFRoZSBgbmdDaGVja2VkYCBkaXJlY3RpdmUgc29sdmVzIHRoaXMgcHJvYmxlbSBmb3IgdGhlIGBjaGVja2VkYCBhdHRyaWJ1dGUuXG4gKiBUaGlzIGNvbXBsZW1lbnRhcnkgZGlyZWN0aXZlIGlzIG5vdCByZW1vdmVkIGJ5IHRoZSBicm93c2VyIGFuZCBzbyBwcm92aWRlc1xuICogYSBwZXJtYW5lbnQgcmVsaWFibGUgcGxhY2UgdG8gc3RvcmUgdGhlIGJpbmRpbmcgaW5mb3JtYXRpb24uXG4gKiBAZXhhbXBsZVxuICAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgIDxkb2M6c291cmNlPlxuICAgICAgICBDaGVjayBtZSB0byBjaGVjayBib3RoOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJtYXN0ZXJcIj48YnIvPlxuICAgICAgICA8aW5wdXQgaWQ9XCJjaGVja1NsYXZlXCIgdHlwZT1cImNoZWNrYm94XCIgbmctY2hlY2tlZD1cIm1hc3RlclwiPlxuICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICAgaXQoJ3Nob3VsZCBjaGVjayBib3RoIGNoZWNrQm94ZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2NoZWNrU2xhdmUnKS5wcm9wKCdjaGVja2VkJykpLnRvQmVGYWxzeSgpO1xuICAgICAgICAgIGlucHV0KCdtYXN0ZXInKS5jaGVjaygpO1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjY2hlY2tTbGF2ZScpLnByb3AoJ2NoZWNrZWQnKSkudG9CZVRydXRoeSgpO1xuICAgICAgICB9KTtcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgIDwvZG9jOmV4YW1wbGU+XG4gKlxuICogQGVsZW1lbnQgSU5QVVRcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDaGVja2VkIElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHksIFxuICogICAgIHRoZW4gc3BlY2lhbCBhdHRyaWJ1dGUgXCJjaGVja2VkXCIgd2lsbCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nUmVhZG9ubHlcbiAqIEByZXN0cmljdCBBXG4gKiBAcHJpb3JpdHkgMTAwXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgSFRNTCBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHZhbHVlcyBvZiBib29sZWFuIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgcmVhZG9ubHkuIChUaGVpciBwcmVzZW5jZSBtZWFucyB0cnVlIGFuZCB0aGVpciBhYnNlbmNlIG1lYW5zIGZhbHNlLilcbiAqIElmIHdlIHB1dCBhbiBBbmd1bGFyIGludGVycG9sYXRpb24gZXhwcmVzc2lvbiBpbnRvIHN1Y2ggYW4gYXR0cmlidXRlIHRoZW4gdGhlXG4gKiBiaW5kaW5nIGluZm9ybWF0aW9uIHdvdWxkIGJlIGxvc3Qgd2hlbiB0aGUgYnJvd3NlciByZW1vdmVzIHRoZSBhdHRyaWJ1dGUuXG4gKiBUaGUgYG5nUmVhZG9ubHlgIGRpcmVjdGl2ZSBzb2x2ZXMgdGhpcyBwcm9ibGVtIGZvciB0aGUgYHJlYWRvbmx5YCBhdHRyaWJ1dGUuXG4gKiBUaGlzIGNvbXBsZW1lbnRhcnkgZGlyZWN0aXZlIGlzIG5vdCByZW1vdmVkIGJ5IHRoZSBicm93c2VyIGFuZCBzbyBwcm92aWRlc1xuICogYSBwZXJtYW5lbnQgcmVsaWFibGUgcGxhY2UgdG8gc3RvcmUgdGhlIGJpbmRpbmcgaW5mb3JtYXRpb24uXG4gKiBAZXhhbXBsZVxuICAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgIDxkb2M6c291cmNlPlxuICAgICAgICBDaGVjayBtZSB0byBtYWtlIHRleHQgcmVhZG9ubHk6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1yZWFkb25seT1cImNoZWNrZWRcIiB2YWx1ZT1cIkknbSBBbmd1bGFyXCIvPlxuICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICAgaXQoJ3Nob3VsZCB0b2dnbGUgcmVhZG9ubHkgYXR0cicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6dGV4dCcpLnByb3AoJ3JlYWRvbmx5JykpLnRvQmVGYWxzeSgpO1xuICAgICAgICAgIGlucHV0KCdjaGVja2VkJykuY2hlY2soKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgOnRleHQnKS5wcm9wKCdyZWFkb25seScpKS50b0JlVHJ1dGh5KCk7XG4gICAgICAgIH0pO1xuICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgPC9kb2M6ZXhhbXBsZT5cbiAqXG4gKiBAZWxlbWVudCBJTlBVVFxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ1JlYWRvbmx5IElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHksIFxuICogICAgIHRoZW4gc3BlY2lhbCBhdHRyaWJ1dGUgXCJyZWFkb25seVwiIHdpbGwgYmUgc2V0IG9uIHRoZSBlbGVtZW50XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1NlbGVjdGVkXG4gKiBAcmVzdHJpY3QgQVxuICogQHByaW9yaXR5IDEwMFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIEhUTUwgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCByZXF1aXJlIGJyb3dzZXJzIHRvIHByZXNlcnZlIHRoZSB2YWx1ZXMgb2YgYm9vbGVhbiBhdHRyaWJ1dGVzXG4gKiBzdWNoIGFzIHNlbGVjdGVkLiAoVGhlaXIgcHJlc2VuY2UgbWVhbnMgdHJ1ZSBhbmQgdGhlaXIgYWJzZW5jZSBtZWFucyBmYWxzZS4pXG4gKiBJZiB3ZSBwdXQgYW4gQW5ndWxhciBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24gaW50byBzdWNoIGFuIGF0dHJpYnV0ZSB0aGVuIHRoZVxuICogYmluZGluZyBpbmZvcm1hdGlvbiB3b3VsZCBiZSBsb3N0IHdoZW4gdGhlIGJyb3dzZXIgcmVtb3ZlcyB0aGUgYXR0cmlidXRlLlxuICogVGhlIGBuZ1NlbGVjdGVkYCBkaXJlY3RpdmUgc29sdmVzIHRoaXMgcHJvYmxlbSBmb3IgdGhlIGBzZWxlY3RlZGAgYXR0dHJpYnV0ZS5cbiAqIFRoaXMgY29tcGxlbWVudGFyeSBkaXJlY3RpdmUgaXMgbm90IHJlbW92ZWQgYnkgdGhlIGJyb3dzZXIgYW5kIHNvIHByb3ZpZGVzXG4gKiBhIHBlcm1hbmVudCByZWxpYWJsZSBwbGFjZSB0byBzdG9yZSB0aGUgYmluZGluZyBpbmZvcm1hdGlvbi5cbiAqIFxuICogQGV4YW1wbGVcbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgQ2hlY2sgbWUgdG8gc2VsZWN0OiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJzZWxlY3RlZFwiPjxici8+XG4gICAgICAgIDxzZWxlY3Q+XG4gICAgICAgICAgPG9wdGlvbj5IZWxsbyE8L29wdGlvbj5cbiAgICAgICAgICA8b3B0aW9uIGlkPVwiZ3JlZXRcIiBuZy1zZWxlY3RlZD1cInNlbGVjdGVkXCI+R3JlZXRpbmdzITwvb3B0aW9uPlxuICAgICAgICA8L3NlbGVjdD5cbiAgICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgIGl0KCdzaG91bGQgc2VsZWN0IEdyZWV0aW5ncyEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2dyZWV0JykucHJvcCgnc2VsZWN0ZWQnKSkudG9CZUZhbHN5KCk7XG4gICAgICAgICAgaW5wdXQoJ3NlbGVjdGVkJykuY2hlY2soKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI2dyZWV0JykucHJvcCgnc2VsZWN0ZWQnKSkudG9CZVRydXRoeSgpO1xuICAgICAgICB9KTtcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgIDwvZG9jOmV4YW1wbGU+XG4gKlxuICogQGVsZW1lbnQgT1BUSU9OXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nU2VsZWN0ZWQgSWYgdGhlIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGlzIHRydXRoeSwgXG4gKiAgICAgdGhlbiBzcGVjaWFsIGF0dHJpYnV0ZSBcInNlbGVjdGVkXCIgd2lsbCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ09wZW5cbiAqIEByZXN0cmljdCBBXG4gKiBAcHJpb3JpdHkgMTAwXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgSFRNTCBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHJlcXVpcmUgYnJvd3NlcnMgdG8gcHJlc2VydmUgdGhlIHZhbHVlcyBvZiBib29sZWFuIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgb3Blbi4gKFRoZWlyIHByZXNlbmNlIG1lYW5zIHRydWUgYW5kIHRoZWlyIGFic2VuY2UgbWVhbnMgZmFsc2UuKVxuICogSWYgd2UgcHV0IGFuIEFuZ3VsYXIgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uIGludG8gc3VjaCBhbiBhdHRyaWJ1dGUgdGhlbiB0aGVcbiAqIGJpbmRpbmcgaW5mb3JtYXRpb24gd291bGQgYmUgbG9zdCB3aGVuIHRoZSBicm93c2VyIHJlbW92ZXMgdGhlIGF0dHJpYnV0ZS5cbiAqIFRoZSBgbmdPcGVuYCBkaXJlY3RpdmUgc29sdmVzIHRoaXMgcHJvYmxlbSBmb3IgdGhlIGBvcGVuYCBhdHRyaWJ1dGUuXG4gKiBUaGlzIGNvbXBsZW1lbnRhcnkgZGlyZWN0aXZlIGlzIG5vdCByZW1vdmVkIGJ5IHRoZSBicm93c2VyIGFuZCBzbyBwcm92aWRlc1xuICogYSBwZXJtYW5lbnQgcmVsaWFibGUgcGxhY2UgdG8gc3RvcmUgdGhlIGJpbmRpbmcgaW5mb3JtYXRpb24uXG4gKiBAZXhhbXBsZVxuICAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICAgPGRvYzpzb3VyY2U+XG4gICAgICAgICBDaGVjayBtZSBjaGVjayBtdWx0aXBsZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwib3BlblwiPjxici8+XG4gICAgICAgICA8ZGV0YWlscyBpZD1cImRldGFpbHNcIiBuZy1vcGVuPVwib3BlblwiPlxuICAgICAgICAgICAgPHN1bW1hcnk+U2hvdy9IaWRlIG1lPC9zdW1tYXJ5PlxuICAgICAgICAgPC9kZXRhaWxzPlxuICAgICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICAgaXQoJ3Nob3VsZCB0b2dnbGUgb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBleHBlY3QoZWxlbWVudCgnI2RldGFpbHMnKS5wcm9wKCdvcGVuJykpLnRvQmVGYWxzeSgpO1xuICAgICAgICAgICBpbnB1dCgnb3BlbicpLmNoZWNrKCk7XG4gICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjZGV0YWlscycpLnByb3AoJ29wZW4nKSkudG9CZVRydXRoeSgpO1xuICAgICAgICAgfSk7XG4gICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgIDwvZG9jOmV4YW1wbGU+XG4gKlxuICogQGVsZW1lbnQgREVUQUlMU1xuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ09wZW4gSWYgdGhlIHtAbGluayBndWlkZS9leHByZXNzaW9uIGV4cHJlc3Npb259IGlzIHRydXRoeSwgXG4gKiAgICAgdGhlbiBzcGVjaWFsIGF0dHJpYnV0ZSBcIm9wZW5cIiB3aWxsIGJlIHNldCBvbiB0aGUgZWxlbWVudFxuICovXG5cbnZhciBuZ0F0dHJpYnV0ZUFsaWFzRGlyZWN0aXZlcyA9IHt9O1xuXG5cbi8vIGJvb2xlYW4gYXR0cnMgYXJlIGV2YWx1YXRlZFxuZm9yRWFjaChCT09MRUFOX0FUVFIsIGZ1bmN0aW9uKHByb3BOYW1lLCBhdHRyTmFtZSkge1xuICAvLyBiaW5kaW5nIHRvIG11bHRpcGxlIGlzIG5vdCBzdXBwb3J0ZWRcbiAgaWYgKHByb3BOYW1lID09IFwibXVsdGlwbGVcIikgcmV0dXJuO1xuXG4gIHZhciBub3JtYWxpemVkID0gZGlyZWN0aXZlTm9ybWFsaXplKCduZy0nICsgYXR0ck5hbWUpO1xuICBuZ0F0dHJpYnV0ZUFsaWFzRGlyZWN0aXZlc1tub3JtYWxpemVkXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmlvcml0eTogMTAwLFxuICAgICAgY29tcGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRyW25vcm1hbGl6ZWRdLCBmdW5jdGlvbiBuZ0Jvb2xlYW5BdHRyV2F0Y2hBY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHIuJHNldChhdHRyTmFtZSwgISF2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pO1xuXG5cbi8vIG5nLXNyYywgbmctc3Jjc2V0LCBuZy1ocmVmIGFyZSBpbnRlcnBvbGF0ZWRcbmZvckVhY2goWydzcmMnLCAnc3Jjc2V0JywgJ2hyZWYnXSwgZnVuY3Rpb24oYXR0ck5hbWUpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSBkaXJlY3RpdmVOb3JtYWxpemUoJ25nLScgKyBhdHRyTmFtZSk7XG4gIG5nQXR0cmlidXRlQWxpYXNEaXJlY3RpdmVzW25vcm1hbGl6ZWRdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW9yaXR5OiA5OSwgLy8gaXQgbmVlZHMgdG8gcnVuIGFmdGVyIHRoZSBhdHRyaWJ1dGVzIGFyZSBpbnRlcnBvbGF0ZWRcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgICAgIGF0dHIuJG9ic2VydmUobm9ybWFsaXplZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIGF0dHIuJHNldChhdHRyTmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgLy8gb24gSUUsIGlmIFwibmc6c3JjXCIgZGlyZWN0aXZlIGRlY2xhcmF0aW9uIGlzIHVzZWQgYW5kIFwic3JjXCIgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAvLyB0aGVuIGNhbGxpbmcgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsICdmb28nKSBkb2Vzbid0IGRvIGFueXRoaW5nLCBzbyB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2V0IHRoZSBwcm9wZXJ0eSBhcyB3ZWxsIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgICAgICAgIC8vIHdlIHVzZSBhdHRyW2F0dHJOYW1lXSB2YWx1ZSBzaW5jZSAkc2V0IGNhbiBzYW5pdGl6ZSB0aGUgdXJsLlxuICAgICAgICAgIGlmIChtc2llKSBlbGVtZW50LnByb3AoYXR0ck5hbWUsIGF0dHJbYXR0ck5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pO1xuXG4vKiBnbG9iYWwgLW51bGxGb3JtQ3RybCAqL1xudmFyIG51bGxGb3JtQ3RybCA9IHtcbiAgJGFkZENvbnRyb2w6IG5vb3AsXG4gICRyZW1vdmVDb250cm9sOiBub29wLFxuICAkc2V0VmFsaWRpdHk6IG5vb3AsXG4gICRzZXREaXJ0eTogbm9vcCxcbiAgJHNldFByaXN0aW5lOiBub29wXG59O1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSAkcHJpc3RpbmUgVHJ1ZSBpZiB1c2VyIGhhcyBub3QgaW50ZXJhY3RlZCB3aXRoIHRoZSBmb3JtIHlldC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJGRpcnR5IFRydWUgaWYgdXNlciBoYXMgYWxyZWFkeSBpbnRlcmFjdGVkIHdpdGggdGhlIGZvcm0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICR2YWxpZCBUcnVlIGlmIGFsbCBvZiB0aGUgY29udGFpbmluZyBmb3JtcyBhbmQgY29udHJvbHMgYXJlIHZhbGlkLlxuICogQHByb3BlcnR5IHtib29sZWFufSAkaW52YWxpZCBUcnVlIGlmIGF0IGxlYXN0IG9uZSBjb250YWluaW5nIGNvbnRyb2wgb3IgZm9ybSBpcyBpbnZhbGlkLlxuICpcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkZXJyb3IgSXMgYW4gb2JqZWN0IGhhc2gsIGNvbnRhaW5pbmcgcmVmZXJlbmNlcyB0byBhbGwgaW52YWxpZCBjb250cm9scyBvclxuICogIGZvcm1zLCB3aGVyZTpcbiAqXG4gKiAgLSBrZXlzIGFyZSB2YWxpZGF0aW9uIHRva2VucyAoZXJyb3IgbmFtZXMpLFxuICogIC0gdmFsdWVzIGFyZSBhcnJheXMgb2YgY29udHJvbHMgb3IgZm9ybXMgdGhhdCBhcmUgaW52YWxpZCBmb3IgZ2l2ZW4gZXJyb3IgbmFtZS5cbiAqXG4gKlxuICogIEJ1aWx0LWluIHZhbGlkYXRpb24gdG9rZW5zOlxuICpcbiAqICAtIGBlbWFpbGBcbiAqICAtIGBtYXhgXG4gKiAgLSBgbWF4bGVuZ3RoYFxuICogIC0gYG1pbmBcbiAqICAtIGBtaW5sZW5ndGhgXG4gKiAgLSBgbnVtYmVyYFxuICogIC0gYHBhdHRlcm5gXG4gKiAgLSBgcmVxdWlyZWRgXG4gKiAgLSBgdXJsYFxuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIGBGb3JtQ29udHJvbGxlcmAga2VlcHMgdHJhY2sgb2YgYWxsIGl0cyBjb250cm9scyBhbmQgbmVzdGVkIGZvcm1zIGFzIHdlbGwgYXMgc3RhdGUgb2YgdGhlbSxcbiAqIHN1Y2ggYXMgYmVpbmcgdmFsaWQvaW52YWxpZCBvciBkaXJ0eS9wcmlzdGluZS5cbiAqXG4gKiBFYWNoIHtAbGluayBuZy5kaXJlY3RpdmU6Zm9ybSBmb3JtfSBkaXJlY3RpdmUgY3JlYXRlcyBhbiBpbnN0YW5jZVxuICogb2YgYEZvcm1Db250cm9sbGVyYC5cbiAqXG4gKi9cbi8vYXNrcyBmb3IgJHNjb3BlIHRvIGZvb2wgdGhlIEJDIGNvbnRyb2xsZXIgbW9kdWxlXG5Gb3JtQ29udHJvbGxlci4kaW5qZWN0ID0gWyckZWxlbWVudCcsICckYXR0cnMnLCAnJHNjb3BlJ107XG5mdW5jdGlvbiBGb3JtQ29udHJvbGxlcihlbGVtZW50LCBhdHRycykge1xuICB2YXIgZm9ybSA9IHRoaXMsXG4gICAgICBwYXJlbnRGb3JtID0gZWxlbWVudC5wYXJlbnQoKS5jb250cm9sbGVyKCdmb3JtJykgfHwgbnVsbEZvcm1DdHJsLFxuICAgICAgaW52YWxpZENvdW50ID0gMCwgLy8gdXNlZCB0byBlYXNpbHkgZGV0ZXJtaW5lIGlmIHdlIGFyZSB2YWxpZFxuICAgICAgZXJyb3JzID0gZm9ybS4kZXJyb3IgPSB7fSxcbiAgICAgIGNvbnRyb2xzID0gW107XG5cbiAgLy8gaW5pdCBzdGF0ZVxuICBmb3JtLiRuYW1lID0gYXR0cnMubmFtZSB8fCBhdHRycy5uZ0Zvcm07XG4gIGZvcm0uJGRpcnR5ID0gZmFsc2U7XG4gIGZvcm0uJHByaXN0aW5lID0gdHJ1ZTtcbiAgZm9ybS4kdmFsaWQgPSB0cnVlO1xuICBmb3JtLiRpbnZhbGlkID0gZmFsc2U7XG5cbiAgcGFyZW50Rm9ybS4kYWRkQ29udHJvbChmb3JtKTtcblxuICAvLyBTZXR1cCBpbml0aWFsIHN0YXRlIG9mIHRoZSBjb250cm9sXG4gIGVsZW1lbnQuYWRkQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpO1xuICB0b2dnbGVWYWxpZENzcyh0cnVlKTtcblxuICAvLyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGVhc3kgdG9nZ2xpbmcgb2YgY2xhc3Nlc1xuICBmdW5jdGlvbiB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3JLZXkpIHtcbiAgICB2YWxpZGF0aW9uRXJyb3JLZXkgPSB2YWxpZGF0aW9uRXJyb3JLZXkgPyAnLScgKyBzbmFrZV9jYXNlKHZhbGlkYXRpb25FcnJvcktleSwgJy0nKSA6ICcnO1xuICAgIGVsZW1lbnQuXG4gICAgICByZW1vdmVDbGFzcygoaXNWYWxpZCA/IElOVkFMSURfQ0xBU1MgOiBWQUxJRF9DTEFTUykgKyB2YWxpZGF0aW9uRXJyb3JLZXkpLlxuICAgICAgYWRkQ2xhc3MoKGlzVmFsaWQgPyBWQUxJRF9DTEFTUyA6IElOVkFMSURfQ0xBU1MpICsgdmFsaWRhdGlvbkVycm9yS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXIjJGFkZENvbnRyb2xcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZWdpc3RlciBhIGNvbnRyb2wgd2l0aCB0aGUgZm9ybS5cbiAgICpcbiAgICogSW5wdXQgZWxlbWVudHMgdXNpbmcgbmdNb2RlbENvbnRyb2xsZXIgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IHdoZW4gdGhleSBhcmUgbGlua2VkLlxuICAgKi9cbiAgZm9ybS4kYWRkQ29udHJvbCA9IGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAvLyBCcmVha2luZyBjaGFuZ2UgLSBiZWZvcmUsIGlucHV0cyB3aG9zZSBuYW1lIHdhcyBcImhhc093blByb3BlcnR5XCIgd2VyZSBxdWlldGx5IGlnbm9yZWRcbiAgICAvLyBhbmQgbm90IGFkZGVkIHRvIHRoZSBzY29wZS4gIE5vdyB3ZSB0aHJvdyBhbiBlcnJvci5cbiAgICBhc3NlcnROb3RIYXNPd25Qcm9wZXJ0eShjb250cm9sLiRuYW1lLCAnaW5wdXQnKTtcbiAgICBjb250cm9scy5wdXNoKGNvbnRyb2wpO1xuXG4gICAgaWYgKGNvbnRyb2wuJG5hbWUpIHtcbiAgICAgIGZvcm1bY29udHJvbC4kbmFtZV0gPSBjb250cm9sO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyIyRyZW1vdmVDb250cm9sXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGVyZWdpc3RlciBhIGNvbnRyb2wgZnJvbSB0aGUgZm9ybS5cbiAgICpcbiAgICogSW5wdXQgZWxlbWVudHMgdXNpbmcgbmdNb2RlbENvbnRyb2xsZXIgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IHdoZW4gdGhleSBhcmUgZGVzdHJveWVkLlxuICAgKi9cbiAgZm9ybS4kcmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICBpZiAoY29udHJvbC4kbmFtZSAmJiBmb3JtW2NvbnRyb2wuJG5hbWVdID09PSBjb250cm9sKSB7XG4gICAgICBkZWxldGUgZm9ybVtjb250cm9sLiRuYW1lXTtcbiAgICB9XG4gICAgZm9yRWFjaChlcnJvcnMsIGZ1bmN0aW9uKHF1ZXVlLCB2YWxpZGF0aW9uVG9rZW4pIHtcbiAgICAgIGZvcm0uJHNldFZhbGlkaXR5KHZhbGlkYXRpb25Ub2tlbiwgdHJ1ZSwgY29udHJvbCk7XG4gICAgfSk7XG5cbiAgICBhcnJheVJlbW92ZShjb250cm9scywgY29udHJvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkc2V0VmFsaWRpdHlcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSB2YWxpZGl0eSBvZiBhIGZvcm0gY29udHJvbC5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIHByb3BhZ2F0ZSB0byBwYXJlbnQgZm9ybXMuXG4gICAqL1xuICBmb3JtLiRzZXRWYWxpZGl0eSA9IGZ1bmN0aW9uKHZhbGlkYXRpb25Ub2tlbiwgaXNWYWxpZCwgY29udHJvbCkge1xuICAgIHZhciBxdWV1ZSA9IGVycm9yc1t2YWxpZGF0aW9uVG9rZW5dO1xuXG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIGlmIChxdWV1ZSkge1xuICAgICAgICBhcnJheVJlbW92ZShxdWV1ZSwgY29udHJvbCk7XG4gICAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgaW52YWxpZENvdW50LS07XG4gICAgICAgICAgaWYgKCFpbnZhbGlkQ291bnQpIHtcbiAgICAgICAgICAgIHRvZ2dsZVZhbGlkQ3NzKGlzVmFsaWQpO1xuICAgICAgICAgICAgZm9ybS4kdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9ybS4kaW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvcnNbdmFsaWRhdGlvblRva2VuXSA9IGZhbHNlO1xuICAgICAgICAgIHRvZ2dsZVZhbGlkQ3NzKHRydWUsIHZhbGlkYXRpb25Ub2tlbik7XG4gICAgICAgICAgcGFyZW50Rm9ybS4kc2V0VmFsaWRpdHkodmFsaWRhdGlvblRva2VuLCB0cnVlLCBmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW52YWxpZENvdW50KSB7XG4gICAgICAgIHRvZ2dsZVZhbGlkQ3NzKGlzVmFsaWQpO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXVlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlcyhxdWV1ZSwgY29udHJvbCkpIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yc1t2YWxpZGF0aW9uVG9rZW5dID0gcXVldWUgPSBbXTtcbiAgICAgICAgaW52YWxpZENvdW50Kys7XG4gICAgICAgIHRvZ2dsZVZhbGlkQ3NzKGZhbHNlLCB2YWxpZGF0aW9uVG9rZW4pO1xuICAgICAgICBwYXJlbnRGb3JtLiRzZXRWYWxpZGl0eSh2YWxpZGF0aW9uVG9rZW4sIGZhbHNlLCBmb3JtKTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnB1c2goY29udHJvbCk7XG5cbiAgICAgIGZvcm0uJHZhbGlkID0gZmFsc2U7XG4gICAgICBmb3JtLiRpbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkc2V0RGlydHlcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSBmb3JtIHRvIGEgZGlydHkgc3RhdGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gYWRkIHRoZSAnbmctZGlydHknIGNsYXNzIGFuZCBzZXQgdGhlIGZvcm0gdG8gYSBkaXJ0eVxuICAgKiBzdGF0ZSAobmctZGlydHkgY2xhc3MpLiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gcHJvcGFnYXRlIHRvIHBhcmVudCBmb3Jtcy5cbiAgICovXG4gIGZvcm0uJHNldERpcnR5ID0gZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcyhQUklTVElORV9DTEFTUykuYWRkQ2xhc3MoRElSVFlfQ0xBU1MpO1xuICAgIGZvcm0uJGRpcnR5ID0gdHJ1ZTtcbiAgICBmb3JtLiRwcmlzdGluZSA9IGZhbHNlO1xuICAgIHBhcmVudEZvcm0uJHNldERpcnR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6Zm9ybS5Gb3JtQ29udHJvbGxlciMkc2V0UHJpc3RpbmVcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpmb3JtLkZvcm1Db250cm9sbGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSBmb3JtIHRvIGl0cyBwcmlzdGluZSBzdGF0ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlICduZy1kaXJ0eScgY2xhc3MgYW5kIHNldCB0aGUgZm9ybSB0byBpdHMgcHJpc3RpbmVcbiAgICogc3RhdGUgKG5nLXByaXN0aW5lIGNsYXNzKS4gVGhpcyBtZXRob2Qgd2lsbCBhbHNvIHByb3BhZ2F0ZSB0byBhbGwgdGhlIGNvbnRyb2xzIGNvbnRhaW5lZFxuICAgKiBpbiB0aGlzIGZvcm0uXG4gICAqXG4gICAqIFNldHRpbmcgYSBmb3JtIGJhY2sgdG8gYSBwcmlzdGluZSBzdGF0ZSBpcyBvZnRlbiB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvICdyZXVzZScgYSBmb3JtIGFmdGVyXG4gICAqIHNhdmluZyBvciByZXNldHRpbmcgaXQuXG4gICAqL1xuICBmb3JtLiRzZXRQcmlzdGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKERJUlRZX0NMQVNTKS5hZGRDbGFzcyhQUklTVElORV9DTEFTUyk7XG4gICAgZm9ybS4kZGlydHkgPSBmYWxzZTtcbiAgICBmb3JtLiRwcmlzdGluZSA9IHRydWU7XG4gICAgZm9yRWFjaChjb250cm9scywgZnVuY3Rpb24oY29udHJvbCkge1xuICAgICAgY29udHJvbC4kc2V0UHJpc3RpbmUoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0Zvcm1cbiAqIEByZXN0cmljdCBFQUNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE5lc3RhYmxlIGFsaWFzIG9mIHtAbGluayBuZy5kaXJlY3RpdmU6Zm9ybSBgZm9ybWB9IGRpcmVjdGl2ZS4gSFRNTFxuICogZG9lcyBub3QgYWxsb3cgbmVzdGluZyBvZiBmb3JtIGVsZW1lbnRzLiBJdCBpcyB1c2VmdWwgdG8gbmVzdCBmb3JtcywgZm9yIGV4YW1wbGUgaWYgdGhlIHZhbGlkaXR5IG9mIGFcbiAqIHN1Yi1ncm91cCBvZiBjb250cm9scyBuZWVkcyB0byBiZSBkZXRlcm1pbmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdGb3JtfG5hbWUgTmFtZSBvZiB0aGUgZm9ybS4gSWYgc3BlY2lmaWVkLCB0aGUgZm9ybSBjb250cm9sbGVyIHdpbGwgYmUgcHVibGlzaGVkIGludG9cbiAqICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkIHNjb3BlLCB1bmRlciB0aGlzIG5hbWUuXG4gKlxuICovXG5cbiAvKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpmb3JtXG4gKiBAcmVzdHJpY3QgRVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIHRoYXQgaW5zdGFudGlhdGVzXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOmZvcm0uRm9ybUNvbnRyb2xsZXIgRm9ybUNvbnRyb2xsZXJ9LlxuICpcbiAqIElmIHRoZSBgbmFtZWAgYXR0cmlidXRlIGlzIHNwZWNpZmllZCwgdGhlIGZvcm0gY29udHJvbGxlciBpcyBwdWJsaXNoZWQgb250byB0aGUgY3VycmVudCBzY29wZSB1bmRlclxuICogdGhpcyBuYW1lLlxuICpcbiAqICMgQWxpYXM6IHtAbGluayBuZy5kaXJlY3RpdmU6bmdGb3JtIGBuZ0Zvcm1gfVxuICpcbiAqIEluIEFuZ3VsYXIgZm9ybXMgY2FuIGJlIG5lc3RlZC4gVGhpcyBtZWFucyB0aGF0IHRoZSBvdXRlciBmb3JtIGlzIHZhbGlkIHdoZW4gYWxsIG9mIHRoZSBjaGlsZFxuICogZm9ybXMgYXJlIHZhbGlkIGFzIHdlbGwuIEhvd2V2ZXIsIGJyb3dzZXJzIGRvIG5vdCBhbGxvdyBuZXN0aW5nIG9mIGA8Zm9ybT5gIGVsZW1lbnRzLCBzb1xuICogQW5ndWxhciBwcm92aWRlcyB0aGUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0Zvcm0gYG5nRm9ybWB9IGRpcmVjdGl2ZSB3aGljaCBiZWhhdmVzIGlkZW50aWNhbGx5IHRvXG4gKiBgPGZvcm0+YCBidXQgY2FuIGJlIG5lc3RlZC4gIFRoaXMgYWxsb3dzIHlvdSB0byBoYXZlIG5lc3RlZCBmb3Jtcywgd2hpY2ggaXMgdmVyeSB1c2VmdWwgd2hlblxuICogdXNpbmcgQW5ndWxhciB2YWxpZGF0aW9uIGRpcmVjdGl2ZXMgaW4gZm9ybXMgdGhhdCBhcmUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIHVzaW5nIHRoZVxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCBgbmdSZXBlYXRgfSBkaXJlY3RpdmUuIFNpbmNlIHlvdSBjYW5ub3QgZHluYW1pY2FsbHkgZ2VuZXJhdGUgdGhlIGBuYW1lYFxuICogYXR0cmlidXRlIG9mIGlucHV0IGVsZW1lbnRzIHVzaW5nIGludGVycG9sYXRpb24sIHlvdSBoYXZlIHRvIHdyYXAgZWFjaCBzZXQgb2YgcmVwZWF0ZWQgaW5wdXRzIGluIGFuXG4gKiBgbmdGb3JtYCBkaXJlY3RpdmUgYW5kIG5lc3QgdGhlc2UgaW4gYW4gb3V0ZXIgYGZvcm1gIGVsZW1lbnQuXG4gKlxuICpcbiAqICMgQ1NTIGNsYXNzZXNcbiAqICAtIGBuZy12YWxpZGAgSXMgc2V0IGlmIHRoZSBmb3JtIGlzIHZhbGlkLlxuICogIC0gYG5nLWludmFsaWRgIElzIHNldCBpZiB0aGUgZm9ybSBpcyBpbnZhbGlkLlxuICogIC0gYG5nLXByaXN0aW5lYCBJcyBzZXQgaWYgdGhlIGZvcm0gaXMgcHJpc3RpbmUuXG4gKiAgLSBgbmctZGlydHlgIElzIHNldCBpZiB0aGUgZm9ybSBpcyBkaXJ0eS5cbiAqXG4gKlxuICogIyBTdWJtaXR0aW5nIGEgZm9ybSBhbmQgcHJldmVudGluZyB0aGUgZGVmYXVsdCBhY3Rpb25cbiAqXG4gKiBTaW5jZSB0aGUgcm9sZSBvZiBmb3JtcyBpbiBjbGllbnQtc2lkZSBBbmd1bGFyIGFwcGxpY2F0aW9ucyBpcyBkaWZmZXJlbnQgdGhhbiBpbiBjbGFzc2ljYWxcbiAqIHJvdW5kdHJpcCBhcHBzLCBpdCBpcyBkZXNpcmFibGUgZm9yIHRoZSBicm93c2VyIG5vdCB0byB0cmFuc2xhdGUgdGhlIGZvcm0gc3VibWlzc2lvbiBpbnRvIGEgZnVsbFxuICogcGFnZSByZWxvYWQgdGhhdCBzZW5kcyB0aGUgZGF0YSB0byB0aGUgc2VydmVyLiBJbnN0ZWFkIHNvbWUgamF2YXNjcmlwdCBsb2dpYyBzaG91bGQgYmUgdHJpZ2dlcmVkXG4gKiB0byBoYW5kbGUgdGhlIGZvcm0gc3VibWlzc2lvbiBpbiBhbiBhcHBsaWNhdGlvbi1zcGVjaWZpYyB3YXkuXG4gKlxuICogRm9yIHRoaXMgcmVhc29uLCBBbmd1bGFyIHByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiAoZm9ybSBzdWJtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIpIHVubGVzcyB0aGVcbiAqIGA8Zm9ybT5gIGVsZW1lbnQgaGFzIGFuIGBhY3Rpb25gIGF0dHJpYnV0ZSBzcGVjaWZpZWQuXG4gKlxuICogWW91IGNhbiB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgdHdvIHdheXMgdG8gc3BlY2lmeSB3aGF0IGphdmFzY3JpcHQgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgd2hlblxuICogYSBmb3JtIGlzIHN1Ym1pdHRlZDpcbiAqXG4gKiAtIHtAbGluayBuZy5kaXJlY3RpdmU6bmdTdWJtaXQgbmdTdWJtaXR9IGRpcmVjdGl2ZSBvbiB0aGUgZm9ybSBlbGVtZW50XG4gKiAtIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfSBkaXJlY3RpdmUgb24gdGhlIGZpcnN0XG4gICogIGJ1dHRvbiBvciBpbnB1dCBmaWVsZCBvZiB0eXBlIHN1Ym1pdCAoaW5wdXRbdHlwZT1zdWJtaXRdKVxuICpcbiAqIFRvIHByZXZlbnQgZG91YmxlIGV4ZWN1dGlvbiBvZiB0aGUgaGFuZGxlciwgdXNlIG9ubHkgb25lIG9mIHRoZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nU3VibWl0IG5nU3VibWl0fVxuICogb3Ige0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrIG5nQ2xpY2t9IGRpcmVjdGl2ZXMuXG4gKiBUaGlzIGlzIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBmb3JtIHN1Ym1pc3Npb24gcnVsZXMgaW4gdGhlIEhUTUwgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAtIElmIGEgZm9ybSBoYXMgb25seSBvbmUgaW5wdXQgZmllbGQgdGhlbiBoaXR0aW5nIGVudGVyIGluIHRoaXMgZmllbGQgdHJpZ2dlcnMgZm9ybSBzdWJtaXRcbiAqIChgbmdTdWJtaXRgKVxuICogLSBpZiBhIGZvcm0gaGFzIDIrIGlucHV0IGZpZWxkcyBhbmQgbm8gYnV0dG9ucyBvciBpbnB1dFt0eXBlPXN1Ym1pdF0gdGhlbiBoaXR0aW5nIGVudGVyXG4gKiBkb2Vzbid0IHRyaWdnZXIgc3VibWl0XG4gKiAtIGlmIGEgZm9ybSBoYXMgb25lIG9yIG1vcmUgaW5wdXQgZmllbGRzIGFuZCBvbmUgb3IgbW9yZSBidXR0b25zIG9yIGlucHV0W3R5cGU9c3VibWl0XSB0aGVuXG4gKiBoaXR0aW5nIGVudGVyIGluIGFueSBvZiB0aGUgaW5wdXQgZmllbGRzIHdpbGwgdHJpZ2dlciB0aGUgY2xpY2sgaGFuZGxlciBvbiB0aGUgKmZpcnN0KiBidXR0b24gb3JcbiAqIGlucHV0W3R5cGU9c3VibWl0XSAoYG5nQ2xpY2tgKSAqYW5kKiBhIHN1Ym1pdCBoYW5kbGVyIG9uIHRoZSBlbmNsb3NpbmcgZm9ybSAoYG5nU3VibWl0YClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgTmFtZSBvZiB0aGUgZm9ybS4gSWYgc3BlY2lmaWVkLCB0aGUgZm9ybSBjb250cm9sbGVyIHdpbGwgYmUgcHVibGlzaGVkIGludG9cbiAqICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkIHNjb3BlLCB1bmRlciB0aGlzIG5hbWUuXG4gKlxuICogQGV4YW1wbGVcbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICA8c2NyaXB0PlxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgJHNjb3BlLnVzZXJUeXBlID0gJ2d1ZXN0JztcbiAgICAgICAgIH1cbiAgICAgICA8L3NjcmlwdD5cbiAgICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCIgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgIHVzZXJUeXBlOiA8aW5wdXQgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ1c2VyVHlwZVwiIHJlcXVpcmVkPlxuICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+UmVxdWlyZWQhPC9zcGFuPjxicj5cbiAgICAgICAgIDx0dD51c2VyVHlwZSA9IHt7dXNlclR5cGV9fTwvdHQ+PGJyPlxuICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyPlxuICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kZXJyb3IgPSB7e215Rm9ybS5pbnB1dC4kZXJyb3J9fTwvdHQ+PGJyPlxuICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyPlxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnI+XG4gICAgICAgIDwvZm9ybT5cbiAgICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXJUeXBlJykpLnRvRXF1YWwoJ2d1ZXN0Jyk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgaW5wdXQoJ3VzZXJUeXBlJykuZW50ZXIoJycpO1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXJUeXBlJykpLnRvRXF1YWwoJycpO1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcbiAgICAgICAgfSk7XG4gICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgICA8L2RvYzpleGFtcGxlPlxuICovXG52YXIgZm9ybURpcmVjdGl2ZUZhY3RvcnkgPSBmdW5jdGlvbihpc05nRm9ybSkge1xuICByZXR1cm4gWyckdGltZW91dCcsIGZ1bmN0aW9uKCR0aW1lb3V0KSB7XG4gICAgdmFyIGZvcm1EaXJlY3RpdmUgPSB7XG4gICAgICBuYW1lOiAnZm9ybScsXG4gICAgICByZXN0cmljdDogaXNOZ0Zvcm0gPyAnRUFDJyA6ICdFJyxcbiAgICAgIGNvbnRyb2xsZXI6IEZvcm1Db250cm9sbGVyLFxuICAgICAgY29tcGlsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJlOiBmdW5jdGlvbihzY29wZSwgZm9ybUVsZW1lbnQsIGF0dHIsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmICghYXR0ci5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIGpxIGV2ZW50cyBiZWNhdXNlIGlmIGEgZm9ybSBpcyBkZXN0cm95ZWQgZHVyaW5nIHN1Ym1pc3Npb24gdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgLy8gYWN0aW9uIGlzIG5vdCBwcmV2ZW50ZWQuIHNlZSAjMTIzOFxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBJRSA5IGlzIG5vdCBhZmZlY3RlZCBiZWNhdXNlIGl0IGRvZXNuJ3QgZmlyZSBhIHN1Ym1pdCBldmVudCBhbmQgdHJ5IHRvIGRvIGEgZnVsbFxuICAgICAgICAgICAgICAvLyBwYWdlIHJlbG9hZCBpZiB0aGUgZm9ybSB3YXMgZGVzdHJveWVkIGJ5IHN1Ym1pc3Npb24gb2YgdGhlIGZvcm0gdmlhIGEgY2xpY2sgaGFuZGxlclxuICAgICAgICAgICAgICAvLyBvbiBhIGJ1dHRvbiBpbiB0aGUgZm9ybS4gTG9va3MgbGlrZSBhbiBJRTkgc3BlY2lmaWMgYnVnLlxuICAgICAgICAgICAgICB2YXIgcHJldmVudERlZmF1bHRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHRcbiAgICAgICAgICAgICAgICAgID8gZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgOiBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlOyAvLyBJRVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXJGbihmb3JtRWxlbWVudFswXSwgJ3N1Ym1pdCcsIHByZXZlbnREZWZhdWx0TGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgIC8vIHVucmVnaXN0ZXIgdGhlIHByZXZlbnREZWZhdWx0IGxpc3RlbmVyIHNvIHRoYXQgd2UgZG9uJ3Qgbm90IGxlYWsgbWVtb3J5IGJ1dCBpbiBhXG4gICAgICAgICAgICAgIC8vIHdheSB0aGF0IHdpbGwgYWNoaWV2ZSB0aGUgcHJldmVudGlvbiBvZiB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gICAgICAgICAgICAgIGZvcm1FbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckZuKGZvcm1FbGVtZW50WzBdLCAnc3VibWl0JywgcHJldmVudERlZmF1bHRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudEZvcm1DdHJsID0gZm9ybUVsZW1lbnQucGFyZW50KCkuY29udHJvbGxlcignZm9ybScpLFxuICAgICAgICAgICAgICAgIGFsaWFzID0gYXR0ci5uYW1lIHx8IGF0dHIubmdGb3JtO1xuXG4gICAgICAgICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgICAgICAgc2V0dGVyKHNjb3BlLCBhbGlhcywgY29udHJvbGxlciwgYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudEZvcm1DdHJsKSB7XG4gICAgICAgICAgICAgIGZvcm1FbGVtZW50Lm9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBhcmVudEZvcm1DdHJsLiRyZW1vdmVDb250cm9sKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIGlmIChhbGlhcykge1xuICAgICAgICAgICAgICAgICAgc2V0dGVyKHNjb3BlLCBhbGlhcywgdW5kZWZpbmVkLCBhbGlhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dGVuZChjb250cm9sbGVyLCBudWxsRm9ybUN0cmwpOyAvL3N0b3AgcHJvcGFnYXRpbmcgY2hpbGQgZGVzdHJ1Y3Rpb24gaGFuZGxlcnMgdXB3YXJkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtRGlyZWN0aXZlO1xuICB9XTtcbn07XG5cbnZhciBmb3JtRGlyZWN0aXZlID0gZm9ybURpcmVjdGl2ZUZhY3RvcnkoKTtcbnZhciBuZ0Zvcm1EaXJlY3RpdmUgPSBmb3JtRGlyZWN0aXZlRmFjdG9yeSh0cnVlKTtcblxuLyogZ2xvYmFsXG5cbiAgICAtVkFMSURfQ0xBU1MsXG4gICAgLUlOVkFMSURfQ0xBU1MsXG4gICAgLVBSSVNUSU5FX0NMQVNTLFxuICAgIC1ESVJUWV9DTEFTU1xuKi9cblxudmFyIFVSTF9SRUdFWFAgPSAvXihmdHB8aHR0cHxodHRwcyk6XFwvXFwvKFxcdys6ezAsMX1cXHcqQCk/KFxcUyspKDpbMC05XSspPyhcXC98XFwvKFtcXHcjITouPys9JiVAIVxcLVxcL10pKT8kLztcbnZhciBFTUFJTF9SRUdFWFAgPSAvXltBLVphLXowLTkuXyUrLV0rQFtBLVphLXowLTkuLV0rXFwuW0EtWmEtel17Miw2fSQvO1xudmFyIE5VTUJFUl9SRUdFWFAgPSAvXlxccyooXFwtfFxcKyk/KFxcZCt8KFxcZCooXFwuXFxkKikpKVxccyokLztcblxudmFyIGlucHV0VHlwZSA9IHtcblxuICAvKipcbiAgICogQG5nZG9jIGlucHV0VHlwZVxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQudGV4dFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU3RhbmRhcmQgSFRNTCB0ZXh0IGlucHV0IHdpdGggYW5ndWxhciBkYXRhIGJpbmRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHJlcXVpcmVkIEFkZHMgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbm90IGVudGVyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xuICAgKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxuICAgKiAgICBgcmVxdWlyZWRgIHdoZW4geW91IHdhbnQgdG8gZGF0YS1iaW5kIHRvIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cbiAgICogICAgbWlubGVuZ3RoLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWF4bGVuZ3RoIFNldHMgYG1heGxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuXG4gICAqICAgIG1heGxlbmd0aC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxuICAgKiAgICBSZWdFeHAgcGF0dGVybiBleHByZXNzaW9uLiBFeHBlY3RlZCB2YWx1ZSBpcyBgL3JlZ2V4cC9gIGZvciBpbmxpbmUgcGF0dGVybnMgb3IgYHJlZ2V4cGAgZm9yXG4gICAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbbmdUcmltPXRydWVdIElmIHNldCB0byBmYWxzZSBBbmd1bGFyIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgdHJpbSB0aGUgaW5wdXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICAgIDxkb2M6c291cmNlPlxuICAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgICAkc2NvcGUudGV4dCA9ICdndWVzdCc7XG4gICAgICAgICAgICAgJHNjb3BlLndvcmQgPSAvXlxccypcXHcqXFxzKiQvO1xuICAgICAgICAgICB9XG4gICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgICBTaW5nbGUgd29yZDogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZy1wYXR0ZXJuPVwid29yZFwiIHJlcXVpcmVkIG5nLXRyaW09XCJmYWxzZVwiPlxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IucmVxdWlyZWRcIj5cbiAgICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5wYXR0ZXJuXCI+XG4gICAgICAgICAgICAgU2luZ2xlIHdvcmQgb25seSE8L3NwYW4+XG5cbiAgICAgICAgICAgPHR0PnRleHQgPSB7e3RleHR9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kZXJyb3IgPSB7e215Rm9ybS5pbnB1dC4kZXJyb3J9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxuICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnZ3Vlc3QnKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcignJyk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbXVsdGkgd29yZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcignaGVsbG8gd29ybGQnKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpdCgnc2hvdWxkIG5vdCBiZSB0cmltbWVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCd1bnRyaW1tZWQgJyk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCd1bnRyaW1tZWQgJyk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgICAgPC9kb2M6ZXhhbXBsZT5cbiAgICovXG4gICd0ZXh0JzogdGV4dElucHV0VHlwZSxcblxuXG4gIC8qKlxuICAgKiBAbmdkb2MgaW5wdXRUeXBlXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTppbnB1dC5udW1iZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRleHQgaW5wdXQgd2l0aCBudW1iZXIgdmFsaWRhdGlvbiBhbmQgdHJhbnNmb3JtYXRpb24uIFNldHMgdGhlIGBudW1iZXJgIHZhbGlkYXRpb25cbiAgICogZXJyb3IgaWYgbm90IGEgdmFsaWQgbnVtYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBtaW4gU2V0cyB0aGUgYG1pbmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGVudGVyZWQgaXMgbGVzcyB0aGFuIGBtaW5gLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1heCBTZXRzIHRoZSBgbWF4YCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZW50ZXJlZCBpcyBncmVhdGVyIHRoYW4gYG1heGAuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBub3QgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1JlcXVpcmVkIEFkZHMgYHJlcXVpcmVkYCBhdHRyaWJ1dGUgYW5kIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBjb25zdHJhaW50IHRvXG4gICAqICAgIHRoZSBlbGVtZW50IHdoZW4gdGhlIG5nUmVxdWlyZWQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gVXNlIGBuZ1JlcXVpcmVkYCBpbnN0ZWFkIG9mXG4gICAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWlubGVuZ3RoIFNldHMgYG1pbmxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIHNob3J0ZXIgdGhhblxuICAgKiAgICBtaW5sZW5ndGguXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNYXhsZW5ndGggU2V0cyBgbWF4bGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbG9uZ2VyIHRoYW5cbiAgICogICAgbWF4bGVuZ3RoLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUGF0dGVybiBTZXRzIGBwYXR0ZXJuYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlXG4gICAqICAgIFJlZ0V4cCBwYXR0ZXJuIGV4cHJlc3Npb24uIEV4cGVjdGVkIHZhbHVlIGlzIGAvcmVnZXhwL2AgZm9yIGlubGluZSBwYXR0ZXJucyBvciBgcmVnZXhwYCBmb3JcbiAgICogICAgcGF0dGVybnMgZGVmaW5lZCBhcyBzY29wZSBleHByZXNzaW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0NoYW5nZSBBbmd1bGFyIGV4cHJlc3Npb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyXG4gICAqICAgIGludGVyYWN0aW9uIHdpdGggdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICAgIDxkb2M6c291cmNlPlxuICAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgICAkc2NvcGUudmFsdWUgPSAxMjtcbiAgICAgICAgICAgfVxuICAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCIgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgICAgTnVtYmVyOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5hbWU9XCJpbnB1dFwiIG5nLW1vZGVsPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW49XCIwXCIgbWF4PVwiOTlcIiByZXF1aXJlZD5cbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+XG4gICAgICAgICAgICAgUmVxdWlyZWQhPC9zcGFuPlxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS5pbnB1dC4kZXJyb3IubnVtYmVyXCI+XG4gICAgICAgICAgICAgTm90IHZhbGlkIG51bWJlciE8L3NwYW4+XG4gICAgICAgICAgIDx0dD52YWx1ZSA9IHt7dmFsdWV9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kZXJyb3IgPSB7e215Rm9ybS5pbnB1dC4kZXJyb3J9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kdmFsaWQgPSB7e215Rm9ybS4kdmFsaWR9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxuICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUnKSkudG9FcXVhbCgnMTInKTtcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIGVtcHR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlucHV0KCd2YWx1ZScpLmVudGVyKCcnKTtcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlJykpLnRvRXF1YWwoJycpO1xuICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIG92ZXIgbWF4JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlucHV0KCd2YWx1ZScpLmVudGVyKCcxMjMnKTtcbiAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3ZhbHVlJykpLnRvRXF1YWwoJycpO1xuICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgICAgIDwvZG9jOmV4YW1wbGU+XG4gICAqL1xuICAnbnVtYmVyJzogbnVtYmVySW5wdXRUeXBlLFxuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0LnVybFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGV4dCBpbnB1dCB3aXRoIFVSTCB2YWxpZGF0aW9uLiBTZXRzIHRoZSBgdXJsYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgY29udGVudCBpcyBub3QgYVxuICAgKiB2YWxpZCBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHJlcXVpcmVkIFNldHMgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbm90IGVudGVyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xuICAgKiAgICB0aGUgZWxlbWVudCB3aGVuIHRoZSBuZ1JlcXVpcmVkIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuIFVzZSBgbmdSZXF1aXJlZGAgaW5zdGVhZCBvZlxuICAgKiAgICBgcmVxdWlyZWRgIHdoZW4geW91IHdhbnQgdG8gZGF0YS1iaW5kIHRvIHRoZSBgcmVxdWlyZWRgIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cbiAgICogICAgbWlubGVuZ3RoLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG5nTWF4bGVuZ3RoIFNldHMgYG1heGxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuXG4gICAqICAgIG1heGxlbmd0aC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxuICAgKiAgICBSZWdFeHAgcGF0dGVybiBleHByZXNzaW9uLiBFeHBlY3RlZCB2YWx1ZSBpcyBgL3JlZ2V4cC9gIGZvciBpbmxpbmUgcGF0dGVybnMgb3IgYHJlZ2V4cGAgZm9yXG4gICAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgICAgPGRvYzpleGFtcGxlPlxuICAgICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnRleHQgPSAnaHR0cDovL2dvb2dsZS5jb20nO1xuICAgICAgICAgICB9XG4gICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgICBVUkw6IDxpbnB1dCB0eXBlPVwidXJsXCIgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ0ZXh0XCIgcmVxdWlyZWQ+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmlucHV0LiRlcnJvci5yZXF1aXJlZFwiPlxuICAgICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj5cbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnVybFwiPlxuICAgICAgICAgICAgIE5vdCB2YWxpZCB1cmwhPC9zcGFuPlxuICAgICAgICAgICA8dHQ+dGV4dCA9IHt7dGV4dH19PC90dD48YnIvPlxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiR2YWxpZCA9IHt7bXlGb3JtLmlucHV0LiR2YWxpZH19PC90dD48YnIvPlxuICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnIvPlxuICAgICAgICAgICA8dHQ+bXlGb3JtLiR2YWxpZCA9IHt7bXlGb3JtLiR2YWxpZH19PC90dD48YnIvPlxuICAgICAgICAgICA8dHQ+bXlGb3JtLiRlcnJvci5yZXF1aXJlZCA9IHt7ISFteUZvcm0uJGVycm9yLnJlcXVpcmVkfX08L3R0Pjxici8+XG4gICAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnVybCA9IHt7ISFteUZvcm0uJGVycm9yLnVybH19PC90dD48YnIvPlxuICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB0byBtb2RlbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3RleHQnKSkudG9FcXVhbCgnaHR0cDovL2dvb2dsZS5jb20nKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcignJyk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uaW5wdXQuJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbm90IHVybCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5wdXQoJ3RleHQnKS5lbnRlcigneHh4Jyk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmlucHV0LiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgICAgIDwvZG9jOmV4YW1wbGU+XG4gICAqL1xuICAndXJsJzogdXJsSW5wdXRUeXBlLFxuXG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBpbnB1dFR5cGVcbiAgICogQG5hbWUgbmcuZGlyZWN0aXZlOmlucHV0LmVtYWlsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUZXh0IGlucHV0IHdpdGggZW1haWwgdmFsaWRhdGlvbi4gU2V0cyB0aGUgYGVtYWlsYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiBub3QgYSB2YWxpZCBlbWFpbFxuICAgKiBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIG5vdCBlbnRlcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nUmVxdWlyZWQgQWRkcyBgcmVxdWlyZWRgIGF0dHJpYnV0ZSBhbmQgYHJlcXVpcmVkYCB2YWxpZGF0aW9uIGNvbnN0cmFpbnQgdG9cbiAgICogICAgdGhlIGVsZW1lbnQgd2hlbiB0aGUgbmdSZXF1aXJlZCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLiBVc2UgYG5nUmVxdWlyZWRgIGluc3RlYWQgb2ZcbiAgICogICAgYHJlcXVpcmVkYCB3aGVuIHlvdSB3YW50IHRvIGRhdGEtYmluZCB0byB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNaW5sZW5ndGggU2V0cyBgbWlubGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgc2hvcnRlciB0aGFuXG4gICAqICAgIG1pbmxlbmd0aC5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxuICAgKiAgICBtYXhsZW5ndGguXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdQYXR0ZXJuIFNldHMgYHBhdHRlcm5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGVcbiAgICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxuICAgKiAgICBwYXR0ZXJucyBkZWZpbmVkIGFzIHNjb3BlIGV4cHJlc3Npb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcbiAgICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgICAgPGRvYzpzb3VyY2U+XG4gICAgICAgICA8c2NyaXB0PlxuICAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAgICAgICRzY29wZS50ZXh0ID0gJ21lQGV4YW1wbGUuY29tJztcbiAgICAgICAgICAgfVxuICAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgICAgIEVtYWlsOiA8aW5wdXQgdHlwZT1cImVtYWlsXCIgbmFtZT1cImlucHV0XCIgbmctbW9kZWw9XCJ0ZXh0XCIgcmVxdWlyZWQ+XG4gICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+XG4gICAgICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+XG4gICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0uaW5wdXQuJGVycm9yLmVtYWlsXCI+XG4gICAgICAgICAgICAgICBOb3QgdmFsaWQgZW1haWwhPC9zcGFuPlxuICAgICAgICAgICAgIDx0dD50ZXh0ID0ge3t0ZXh0fX08L3R0Pjxici8+XG4gICAgICAgICAgICAgPHR0Pm15Rm9ybS5pbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5pbnB1dC4kdmFsaWR9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgICA8dHQ+bXlGb3JtLmlucHV0LiRlcnJvciA9IHt7bXlGb3JtLmlucHV0LiRlcnJvcn19PC90dD48YnIvPlxuICAgICAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxici8+XG4gICAgICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxuICAgICAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLmVtYWlsID0ge3shIW15Rm9ybS4kZXJyb3IuZW1haWx9fTwvdHQ+PGJyLz5cbiAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICA8L2RvYzpzb3VyY2U+XG4gICAgICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCdtZUBleGFtcGxlLmNvbScpO1xuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaXQoJ3Nob3VsZCBiZSBpbnZhbGlkIGlmIGVtcHR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbnB1dCgndGV4dCcpLmVudGVyKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd0ZXh0JykpLnRvRXF1YWwoJycpO1xuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBub3QgZW1haWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJ3h4eCcpO1xuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5pbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgICA8L2RvYzpleGFtcGxlPlxuICAgKi9cbiAgJ2VtYWlsJzogZW1haWxJbnB1dFR5cGUsXG5cblxuICAvKipcbiAgICogQG5nZG9jIGlucHV0VHlwZVxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6aW5wdXQucmFkaW9cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEhUTUwgcmFkaW8gYnV0dG9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmdNb2RlbCBBc3NpZ25hYmxlIGFuZ3VsYXIgZXhwcmVzc2lvbiB0byBkYXRhLWJpbmQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd2hpY2ggdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHNldCB3aGVuIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgICAgPGRvYzpleGFtcGxlPlxuICAgICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLmNvbG9yID0gJ2JsdWUnO1xuICAgICAgICAgICB9XG4gICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmctbW9kZWw9XCJjb2xvclwiIHZhbHVlPVwicmVkXCI+ICBSZWQgPGJyLz5cbiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5nLW1vZGVsPVwiY29sb3JcIiB2YWx1ZT1cImdyZWVuXCI+IEdyZWVuIDxici8+XG4gICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuZy1tb2RlbD1cImNvbG9yXCIgdmFsdWU9XCJibHVlXCI+IEJsdWUgPGJyLz5cbiAgICAgICAgICAgPHR0PmNvbG9yID0ge3tjb2xvcn19PC90dD48YnIvPlxuICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICAgIGl0KCdzaG91bGQgY2hhbmdlIHN0YXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygnY29sb3InKSkudG9FcXVhbCgnYmx1ZScpO1xuXG4gICAgICAgICAgICBpbnB1dCgnY29sb3InKS5zZWxlY3QoJ3JlZCcpO1xuICAgICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2NvbG9yJykpLnRvRXF1YWwoJ3JlZCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgICAgIDwvZG9jOmV4YW1wbGU+XG4gICAqL1xuICAncmFkaW8nOiByYWRpb0lucHV0VHlwZSxcblxuXG4gIC8qKlxuICAgKiBAbmdkb2MgaW5wdXRUeXBlXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTppbnB1dC5jaGVja2JveFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSFRNTCBjaGVja2JveC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUgZm9ybSB1bmRlciB3aGljaCB0aGUgY29udHJvbCBpcyBwdWJsaXNoZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdUcnVlVmFsdWUgVGhlIHZhbHVlIHRvIHdoaWNoIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzZXQgd2hlbiBzZWxlY3RlZC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuZ0ZhbHNlVmFsdWUgVGhlIHZhbHVlIHRvIHdoaWNoIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzZXQgd2hlbiBub3Qgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxuICAgKiAgICBpbnRlcmFjdGlvbiB3aXRoIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgICAgPGRvYzpleGFtcGxlPlxuICAgICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAgICAgJHNjb3BlLnZhbHVlMSA9IHRydWU7XG4gICAgICAgICAgICAgJHNjb3BlLnZhbHVlMiA9ICdZRVMnXG4gICAgICAgICAgIH1cbiAgICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgICAgICAgIFZhbHVlMTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwidmFsdWUxXCI+IDxici8+XG4gICAgICAgICAgIFZhbHVlMjogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwidmFsdWUyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmctdHJ1ZS12YWx1ZT1cIllFU1wiIG5nLWZhbHNlLXZhbHVlPVwiTk9cIj4gPGJyLz5cbiAgICAgICAgICAgPHR0PnZhbHVlMSA9IHt7dmFsdWUxfX08L3R0Pjxici8+XG4gICAgICAgICAgIDx0dD52YWx1ZTIgPSB7e3ZhbHVlMn19PC90dD48YnIvPlxuICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICAgIGl0KCdzaG91bGQgY2hhbmdlIHN0YXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUxJykpLnRvRXF1YWwoJ3RydWUnKTtcbiAgICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd2YWx1ZTInKSkudG9FcXVhbCgnWUVTJyk7XG5cbiAgICAgICAgICAgIGlucHV0KCd2YWx1ZTEnKS5jaGVjaygpO1xuICAgICAgICAgICAgaW5wdXQoJ3ZhbHVlMicpLmNoZWNrKCk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUxJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XG4gICAgICAgICAgICBleHBlY3QoYmluZGluZygndmFsdWUyJykpLnRvRXF1YWwoJ05PJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgICAgPC9kb2M6ZXhhbXBsZT5cbiAgICovXG4gICdjaGVja2JveCc6IGNoZWNrYm94SW5wdXRUeXBlLFxuXG4gICdoaWRkZW4nOiBub29wLFxuICAnYnV0dG9uJzogbm9vcCxcbiAgJ3N1Ym1pdCc6IG5vb3AsXG4gICdyZXNldCc6IG5vb3Bcbn07XG5cblxuZnVuY3Rpb24gdGV4dElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKSB7XG4gIC8vIEluIGNvbXBvc2l0aW9uIG1vZGUsIHVzZXJzIGFyZSBzdGlsbCBpbnB1dGluZyBpbnRlcm1lZGlhdGUgdGV4dCBidWZmZXIsXG4gIC8vIGhvbGQgdGhlIGxpc3RlbmVyIHVudGlsIGNvbXBvc2l0aW9uIGlzIGRvbmUuXG4gIC8vIE1vcmUgYWJvdXQgY29tcG9zaXRpb24gZXZlbnRzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ29tcG9zaXRpb25FdmVudFxuICBpZiAoISRzbmlmZmVyLmFuZHJvaWQpIHtcbiAgICB2YXIgY29tcG9zaW5nID0gZmFsc2U7XG5cbiAgICBlbGVtZW50Lm9uKCdjb21wb3NpdGlvbnN0YXJ0JywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGVsZW1lbnQub24oJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChjb21wb3NpbmcpIHJldHVybjtcbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnZhbCgpO1xuXG4gICAgLy8gQnkgZGVmYXVsdCB3ZSB3aWxsIHRyaW0gdGhlIHZhbHVlXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBuZy10cmltIGV4aXN0cyB3ZSB3aWxsIGF2b2lkIHRyaW1taW5nXG4gICAgLy8gZS5nLiA8aW5wdXQgbmctbW9kZWw9XCJmb29cIiBuZy10cmltPVwiZmFsc2VcIj5cbiAgICBpZiAodG9Cb29sZWFuKGF0dHIubmdUcmltIHx8ICdUJykpIHtcbiAgICAgIHZhbHVlID0gdHJpbSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0cmwuJHZpZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgY3RybC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBpZiB0aGUgYnJvd3NlciBkb2VzIHN1cHBvcnQgXCJpbnB1dFwiIGV2ZW50LCB3ZSBhcmUgZmluZSAtIGV4Y2VwdCBvbiBJRTkgd2hpY2ggZG9lc24ndCBmaXJlIHRoZVxuICAvLyBpbnB1dCBldmVudCBvbiBiYWNrc3BhY2UsIGRlbGV0ZSBvciBjdXRcbiAgaWYgKCRzbmlmZmVyLmhhc0V2ZW50KCdpbnB1dCcpKSB7XG4gICAgZWxlbWVudC5vbignaW5wdXQnLCBsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRpbWVvdXQ7XG5cbiAgICB2YXIgZGVmZXJMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSAkYnJvd3Nlci5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlbWVudC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZTtcblxuICAgICAgLy8gaWdub3JlXG4gICAgICAvLyAgICBjb21tYW5kICAgICAgICAgICAgbW9kaWZpZXJzICAgICAgICAgICAgICAgICAgIGFycm93c1xuICAgICAgaWYgKGtleSA9PT0gOTEgfHwgKDE1IDwga2V5ICYmIGtleSA8IDE5KSB8fCAoMzcgPD0ga2V5ICYmIGtleSA8PSA0MCkpIHJldHVybjtcblxuICAgICAgZGVmZXJMaXN0ZW5lcigpO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgdXNlciBtb2RpZmllcyBpbnB1dCB2YWx1ZSB1c2luZyBjb250ZXh0IG1lbnUgaW4gSUUsIHdlIG5lZWQgXCJwYXN0ZVwiIGFuZCBcImN1dFwiIGV2ZW50cyB0byBjYXRjaCBpdFxuICAgIGlmICgkc25pZmZlci5oYXNFdmVudCgncGFzdGUnKSkge1xuICAgICAgZWxlbWVudC5vbigncGFzdGUgY3V0JywgZGVmZXJMaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdXNlciBwYXN0ZSBpbnRvIGlucHV0IHVzaW5nIG1vdXNlIG9uIG9sZGVyIGJyb3dzZXJcbiAgLy8gb3IgZm9ybSBhdXRvY29tcGxldGUgb24gbmV3ZXIgYnJvd3Nlciwgd2UgbmVlZCBcImNoYW5nZVwiIGV2ZW50IHRvIGNhdGNoIGl0XG4gIGVsZW1lbnQub24oJ2NoYW5nZScsIGxpc3RlbmVyKTtcblxuICBjdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50LnZhbChjdHJsLiRpc0VtcHR5KGN0cmwuJHZpZXdWYWx1ZSkgPyAnJyA6IGN0cmwuJHZpZXdWYWx1ZSk7XG4gIH07XG5cbiAgLy8gcGF0dGVybiB2YWxpZGF0b3JcbiAgdmFyIHBhdHRlcm4gPSBhdHRyLm5nUGF0dGVybixcbiAgICAgIHBhdHRlcm5WYWxpZGF0b3IsXG4gICAgICBtYXRjaDtcblxuICB2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbihyZWdleHAsIHZhbHVlKSB7XG4gICAgaWYgKGN0cmwuJGlzRW1wdHkodmFsdWUpIHx8IHJlZ2V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3BhdHRlcm4nLCB0cnVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3BhdHRlcm4nLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBpZiAocGF0dGVybikge1xuICAgIG1hdGNoID0gcGF0dGVybi5tYXRjaCgvXlxcLyguKilcXC8oW2dpbV0qKSQvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKG1hdGNoWzFdLCBtYXRjaFsyXSk7XG4gICAgICBwYXR0ZXJuVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHBhdHRlcm4sIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcGF0dGVybk9iaiA9IHNjb3BlLiRldmFsKHBhdHRlcm4pO1xuXG4gICAgICAgIGlmICghcGF0dGVybk9iaiB8fCAhcGF0dGVybk9iai50ZXN0KSB7XG4gICAgICAgICAgdGhyb3cgbWluRXJyKCduZ1BhdHRlcm4nKSgnbm9yZWdleHAnLFxuICAgICAgICAgICAgJ0V4cGVjdGVkIHswfSB0byBiZSBhIFJlZ0V4cCBidXQgd2FzIHsxfS4gRWxlbWVudDogezJ9JywgcGF0dGVybixcbiAgICAgICAgICAgIHBhdHRlcm5PYmosIHN0YXJ0aW5nVGFnKGVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGUocGF0dGVybk9iaiwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2gocGF0dGVyblZhbGlkYXRvcik7XG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKHBhdHRlcm5WYWxpZGF0b3IpO1xuICB9XG5cbiAgLy8gbWluIGxlbmd0aCB2YWxpZGF0b3JcbiAgaWYgKGF0dHIubmdNaW5sZW5ndGgpIHtcbiAgICB2YXIgbWlubGVuZ3RoID0gaW50KGF0dHIubmdNaW5sZW5ndGgpO1xuICAgIHZhciBtaW5MZW5ndGhWYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFjdHJsLiRpc0VtcHR5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPCBtaW5sZW5ndGgpIHtcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21pbmxlbmd0aCcsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtaW5sZW5ndGgnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjdHJsLiRwYXJzZXJzLnB1c2gobWluTGVuZ3RoVmFsaWRhdG9yKTtcbiAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2gobWluTGVuZ3RoVmFsaWRhdG9yKTtcbiAgfVxuXG4gIC8vIG1heCBsZW5ndGggdmFsaWRhdG9yXG4gIGlmIChhdHRyLm5nTWF4bGVuZ3RoKSB7XG4gICAgdmFyIG1heGxlbmd0aCA9IGludChhdHRyLm5nTWF4bGVuZ3RoKTtcbiAgICB2YXIgbWF4TGVuZ3RoVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghY3RybC4kaXNFbXB0eSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID4gbWF4bGVuZ3RoKSB7XG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtYXhsZW5ndGgnLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWF4bGVuZ3RoJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKG1heExlbmd0aFZhbGlkYXRvcik7XG4gICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKG1heExlbmd0aFZhbGlkYXRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gbnVtYmVySW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcbiAgdGV4dElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKTtcblxuICBjdHJsLiRwYXJzZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgZW1wdHkgPSBjdHJsLiRpc0VtcHR5KHZhbHVlKTtcbiAgICBpZiAoZW1wdHkgfHwgTlVNQkVSX1JFR0VYUC50ZXN0KHZhbHVlKSkge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ251bWJlcicsIHRydWUpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiAoZW1wdHkgPyB2YWx1ZSA6IHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ251bWJlcicsIGZhbHNlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcblxuICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gY3RybC4kaXNFbXB0eSh2YWx1ZSkgPyAnJyA6ICcnICsgdmFsdWU7XG4gIH0pO1xuXG4gIGlmIChhdHRyLm1pbikge1xuICAgIHZhciBtaW5WYWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG1pbiA9IHBhcnNlRmxvYXQoYXR0ci5taW4pO1xuICAgICAgaWYgKCFjdHJsLiRpc0VtcHR5KHZhbHVlKSAmJiB2YWx1ZSA8IG1pbikge1xuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWluJywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ21pbicsIHRydWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGN0cmwuJHBhcnNlcnMucHVzaChtaW5WYWxpZGF0b3IpO1xuICAgIGN0cmwuJGZvcm1hdHRlcnMucHVzaChtaW5WYWxpZGF0b3IpO1xuICB9XG5cbiAgaWYgKGF0dHIubWF4KSB7XG4gICAgdmFyIG1heFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbWF4ID0gcGFyc2VGbG9hdChhdHRyLm1heCk7XG4gICAgICBpZiAoIWN0cmwuJGlzRW1wdHkodmFsdWUpICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdtYXgnLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnbWF4JywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY3RybC4kcGFyc2Vycy5wdXNoKG1heFZhbGlkYXRvcik7XG4gICAgY3RybC4kZm9ybWF0dGVycy5wdXNoKG1heFZhbGlkYXRvcik7XG4gIH1cblxuICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblxuICAgIGlmIChjdHJsLiRpc0VtcHR5KHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdudW1iZXInLCB0cnVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ251bWJlcicsIGZhbHNlKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXJsSW5wdXRUeXBlKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcbiAgdGV4dElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKTtcblxuICB2YXIgdXJsVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoY3RybC4kaXNFbXB0eSh2YWx1ZSkgfHwgVVJMX1JFR0VYUC50ZXN0KHZhbHVlKSkge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3VybCcsIHRydWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgndXJsJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKHVybFZhbGlkYXRvcik7XG4gIGN0cmwuJHBhcnNlcnMucHVzaCh1cmxWYWxpZGF0b3IpO1xufVxuXG5mdW5jdGlvbiBlbWFpbElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsICRicm93c2VyKSB7XG4gIHRleHRJbnB1dFR5cGUoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwsICRzbmlmZmVyLCAkYnJvd3Nlcik7XG5cbiAgdmFyIGVtYWlsVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoY3RybC4kaXNFbXB0eSh2YWx1ZSkgfHwgRU1BSUxfUkVHRVhQLnRlc3QodmFsdWUpKSB7XG4gICAgICBjdHJsLiRzZXRWYWxpZGl0eSgnZW1haWwnLCB0cnVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ2VtYWlsJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGVtYWlsVmFsaWRhdG9yKTtcbiAgY3RybC4kcGFyc2Vycy5wdXNoKGVtYWlsVmFsaWRhdG9yKTtcbn1cblxuZnVuY3Rpb24gcmFkaW9JbnB1dFR5cGUoc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcbiAgLy8gbWFrZSB0aGUgbmFtZSB1bmlxdWUsIGlmIG5vdCBkZWZpbmVkXG4gIGlmIChpc1VuZGVmaW5lZChhdHRyLm5hbWUpKSB7XG4gICAgZWxlbWVudC5hdHRyKCduYW1lJywgbmV4dFVpZCgpKTtcbiAgfVxuXG4gIGVsZW1lbnQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVsZW1lbnRbMF0uY2hlY2tlZCkge1xuICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICBjdHJsLiRzZXRWaWV3VmFsdWUoYXR0ci52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgZWxlbWVudFswXS5jaGVja2VkID0gKHZhbHVlID09IGN0cmwuJHZpZXdWYWx1ZSk7XG4gIH07XG5cbiAgYXR0ci4kb2JzZXJ2ZSgndmFsdWUnLCBjdHJsLiRyZW5kZXIpO1xufVxuXG5mdW5jdGlvbiBjaGVja2JveElucHV0VHlwZShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCkge1xuICB2YXIgdHJ1ZVZhbHVlID0gYXR0ci5uZ1RydWVWYWx1ZSxcbiAgICAgIGZhbHNlVmFsdWUgPSBhdHRyLm5nRmFsc2VWYWx1ZTtcblxuICBpZiAoIWlzU3RyaW5nKHRydWVWYWx1ZSkpIHRydWVWYWx1ZSA9IHRydWU7XG4gIGlmICghaXNTdHJpbmcoZmFsc2VWYWx1ZSkpIGZhbHNlVmFsdWUgPSBmYWxzZTtcblxuICBlbGVtZW50Lm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgIGN0cmwuJHNldFZpZXdWYWx1ZShlbGVtZW50WzBdLmNoZWNrZWQpO1xuICAgIH0pO1xuICB9KTtcblxuICBjdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50WzBdLmNoZWNrZWQgPSBjdHJsLiR2aWV3VmFsdWU7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIHN0YW5kYXJkIGAkaXNFbXB0eWAgYmVjYXVzZSBhIHZhbHVlIG9mIGBmYWxzZWAgbWVhbnMgZW1wdHkgaW4gYSBjaGVja2JveC5cbiAgY3RybC4kaXNFbXB0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB0cnVlVmFsdWU7XG4gIH07XG5cbiAgY3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlVmFsdWU7XG4gIH0pO1xuXG4gIGN0cmwuJHBhcnNlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IHRydWVWYWx1ZSA6IGZhbHNlVmFsdWU7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOnRleHRhcmVhXG4gKiBAcmVzdHJpY3QgRVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSFRNTCB0ZXh0YXJlYSBlbGVtZW50IGNvbnRyb2wgd2l0aCBhbmd1bGFyIGRhdGEtYmluZGluZy4gVGhlIGRhdGEtYmluZGluZyBhbmQgdmFsaWRhdGlvblxuICogcHJvcGVydGllcyBvZiB0aGlzIGVsZW1lbnQgYXJlIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgdGhlXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0IGlucHV0IGVsZW1lbnR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZ01vZGVsIEFzc2lnbmFibGUgYW5ndWxhciBleHByZXNzaW9uIHRvIGRhdGEtYmluZCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBmb3JtIHVuZGVyIHdoaWNoIHRoZSBjb250cm9sIGlzIHB1Ymxpc2hlZC5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gcmVxdWlyZWQgU2V0cyBgcmVxdWlyZWRgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBub3QgZW50ZXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xuICogICAgdGhlIGVsZW1lbnQgd2hlbiB0aGUgbmdSZXF1aXJlZCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLiBVc2UgYG5nUmVxdWlyZWRgIGluc3RlYWQgb2ZcbiAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBuZ01pbmxlbmd0aCBTZXRzIGBtaW5sZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBzaG9ydGVyIHRoYW5cbiAqICAgIG1pbmxlbmd0aC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbmdNYXhsZW5ndGggU2V0cyBgbWF4bGVuZ3RoYCB2YWxpZGF0aW9uIGVycm9yIGtleSBpZiB0aGUgdmFsdWUgaXMgbG9uZ2VyIHRoYW5cbiAqICAgIG1heGxlbmd0aC5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdQYXR0ZXJuIFNldHMgYHBhdHRlcm5gIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGVcbiAqICAgIFJlZ0V4cCBwYXR0ZXJuIGV4cHJlc3Npb24uIEV4cGVjdGVkIHZhbHVlIGlzIGAvcmVnZXhwL2AgZm9yIGlubGluZSBwYXR0ZXJucyBvciBgcmVnZXhwYCBmb3JcbiAqICAgIHBhdHRlcm5zIGRlZmluZWQgYXMgc2NvcGUgZXhwcmVzc2lvbnMuXG4gKiBAcGFyYW0ge3N0cmluZz19IG5nQ2hhbmdlIEFuZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSBleGVjdXRlZCB3aGVuIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXJcbiAqICAgIGludGVyYWN0aW9uIHdpdGggdGhlIGlucHV0IGVsZW1lbnQuXG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTppbnB1dFxuICogQHJlc3RyaWN0IEVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEhUTUwgaW5wdXQgZWxlbWVudCBjb250cm9sIHdpdGggYW5ndWxhciBkYXRhLWJpbmRpbmcuIElucHV0IGNvbnRyb2wgZm9sbG93cyBIVE1MNSBpbnB1dCB0eXBlc1xuICogYW5kIHBvbHlmaWxscyB0aGUgSFRNTDUgdmFsaWRhdGlvbiBiZWhhdmlvciBmb3Igb2xkZXIgYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxuICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIG5vdCBlbnRlcmVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gbmdSZXF1aXJlZCBTZXRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGlmIHNldCB0byB0cnVlXG4gKiBAcGFyYW0ge251bWJlcj19IG5nTWlubGVuZ3RoIFNldHMgYG1pbmxlbmd0aGAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGlzIHNob3J0ZXIgdGhhblxuICogICAgbWlubGVuZ3RoLlxuICogQHBhcmFtIHtudW1iZXI9fSBuZ01heGxlbmd0aCBTZXRzIGBtYXhsZW5ndGhgIHZhbGlkYXRpb24gZXJyb3Iga2V5IGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhblxuICogICAgbWF4bGVuZ3RoLlxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ1BhdHRlcm4gU2V0cyBgcGF0dGVybmAgdmFsaWRhdGlvbiBlcnJvciBrZXkgaWYgdGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZVxuICogICAgUmVnRXhwIHBhdHRlcm4gZXhwcmVzc2lvbi4gRXhwZWN0ZWQgdmFsdWUgaXMgYC9yZWdleHAvYCBmb3IgaW5saW5lIHBhdHRlcm5zIG9yIGByZWdleHBgIGZvclxuICogICAgcGF0dGVybnMgZGVmaW5lZCBhcyBzY29wZSBleHByZXNzaW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdDaGFuZ2UgQW5ndWxhciBleHByZXNzaW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaW5wdXQgY2hhbmdlcyBkdWUgdG8gdXNlclxuICogICAgaW50ZXJhY3Rpb24gd2l0aCB0aGUgaW5wdXQgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAgICAkc2NvcGUudXNlciA9IHtuYW1lOiAnZ3Vlc3QnLCBsYXN0OiAndmlzaXRvcid9O1xuICAgICAgICAgfVxuICAgICAgIDwvc2NyaXB0PlxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgIDxmb3JtIG5hbWU9XCJteUZvcm1cIj5cbiAgICAgICAgICAgVXNlciBuYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwidXNlck5hbWVcIiBuZy1tb2RlbD1cInVzZXIubmFtZVwiIHJlcXVpcmVkPlxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImVycm9yXCIgbmctc2hvdz1cIm15Rm9ybS51c2VyTmFtZS4kZXJyb3IucmVxdWlyZWRcIj5cbiAgICAgICAgICAgICBSZXF1aXJlZCE8L3NwYW4+PGJyPlxuICAgICAgICAgICBMYXN0IG5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIG5nLW1vZGVsPVwidXNlci5sYXN0XCJcbiAgICAgICAgICAgICBuZy1taW5sZW5ndGg9XCIzXCIgbmctbWF4bGVuZ3RoPVwiMTBcIj5cbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJlcnJvclwiIG5nLXNob3c9XCJteUZvcm0ubGFzdE5hbWUuJGVycm9yLm1pbmxlbmd0aFwiPlxuICAgICAgICAgICAgIFRvbyBzaG9ydCE8L3NwYW4+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLmxhc3ROYW1lLiRlcnJvci5tYXhsZW5ndGhcIj5cbiAgICAgICAgICAgICBUb28gbG9uZyE8L3NwYW4+PGJyPlxuICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgPGhyPlxuICAgICAgICAgPHR0PnVzZXIgPSB7e3VzZXJ9fTwvdHQ+PGJyLz5cbiAgICAgICAgIDx0dD5teUZvcm0udXNlck5hbWUuJHZhbGlkID0ge3tteUZvcm0udXNlck5hbWUuJHZhbGlkfX08L3R0Pjxicj5cbiAgICAgICAgIDx0dD5teUZvcm0udXNlck5hbWUuJGVycm9yID0ge3tteUZvcm0udXNlck5hbWUuJGVycm9yfX08L3R0Pjxicj5cbiAgICAgICAgIDx0dD5teUZvcm0ubGFzdE5hbWUuJHZhbGlkID0ge3tteUZvcm0ubGFzdE5hbWUuJHZhbGlkfX08L3R0Pjxicj5cbiAgICAgICAgIDx0dD5teUZvcm0ubGFzdE5hbWUuJGVycm9yID0ge3tteUZvcm0ubGFzdE5hbWUuJGVycm9yfX08L3R0Pjxicj5cbiAgICAgICAgIDx0dD5teUZvcm0uJHZhbGlkID0ge3tteUZvcm0uJHZhbGlkfX08L3R0Pjxicj5cbiAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLnJlcXVpcmVkID0ge3shIW15Rm9ybS4kZXJyb3IucmVxdWlyZWR9fTwvdHQ+PGJyPlxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IubWlubGVuZ3RoID0ge3shIW15Rm9ybS4kZXJyb3IubWlubGVuZ3RofX08L3R0Pjxicj5cbiAgICAgICAgIDx0dD5teUZvcm0uJGVycm9yLm1heGxlbmd0aCA9IHt7ISFteUZvcm0uJGVycm9yLm1heGxlbmd0aH19PC90dD48YnI+XG4gICAgICAgPC9kaXY+XG4gICAgICA8L2RvYzpzb3VyY2U+XG4gICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdG8gbW9kZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndXNlcicpKS50b0VxdWFsKCd7XCJuYW1lXCI6XCJndWVzdFwiLFwibGFzdFwiOlwidmlzaXRvclwifScpO1xuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0udXNlck5hbWUuJHZhbGlkJykpLnRvRXF1YWwoJ3RydWUnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBlbXB0eSB3aGVuIHJlcXVpcmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaW5wdXQoJ3VzZXIubmFtZScpLmVudGVyKCcnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndXNlcicpKS50b0VxdWFsKCd7XCJsYXN0XCI6XCJ2aXNpdG9yXCJ9Jyk7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS51c2VyTmFtZS4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGJlIHZhbGlkIGlmIGVtcHR5IHdoZW4gbWluIGxlbmd0aCBpcyBzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpbnB1dCgndXNlci5sYXN0JykuZW50ZXIoJycpO1xuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd1c2VyJykpLnRvRXF1YWwoJ3tcIm5hbWVcIjpcImd1ZXN0XCIsXCJsYXN0XCI6XCJcIn0nKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS4kdmFsaWQnKSkudG9FcXVhbCgndHJ1ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgbGVzcyB0aGFuIHJlcXVpcmVkIG1pbiBsZW5ndGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpbnB1dCgndXNlci5sYXN0JykuZW50ZXIoJ3h4Jyk7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ3VzZXInKSkudG9FcXVhbCgne1wibmFtZVwiOlwiZ3Vlc3RcIn0nKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0ubGFzdE5hbWUuJGVycm9yJykpLnRvTWF0Y2goL21pbmxlbmd0aC8pO1xuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0uJHZhbGlkJykpLnRvRXF1YWwoJ2ZhbHNlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgYmUgaW52YWxpZCBpZiBsb25nZXIgdGhhbiBtYXggbGVuZ3RoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaW5wdXQoJ3VzZXIubGFzdCcpLmVudGVyKCdzb21lIHJpZGljdWxvdXNseSBsb25nIG5hbWUnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndXNlcicpKVxuICAgICAgICAgICAgLnRvRXF1YWwoJ3tcIm5hbWVcIjpcImd1ZXN0XCJ9Jyk7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5sYXN0TmFtZS4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLmxhc3ROYW1lLiRlcnJvcicpKS50b01hdGNoKC9tYXhsZW5ndGgvKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbXlGb3JtLiR2YWxpZCcpKS50b0VxdWFsKCdmYWxzZScpO1xuICAgICAgICB9KTtcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cbnZhciBpbnB1dERpcmVjdGl2ZSA9IFsnJGJyb3dzZXInLCAnJHNuaWZmZXInLCBmdW5jdGlvbigkYnJvd3NlciwgJHNuaWZmZXIpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0UnLFxuICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwpIHtcbiAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgIChpbnB1dFR5cGVbbG93ZXJjYXNlKGF0dHIudHlwZSldIHx8IGlucHV0VHlwZS50ZXh0KShzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHNuaWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYnJvd3Nlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV07XG5cbnZhciBWQUxJRF9DTEFTUyA9ICduZy12YWxpZCcsXG4gICAgSU5WQUxJRF9DTEFTUyA9ICduZy1pbnZhbGlkJyxcbiAgICBQUklTVElORV9DTEFTUyA9ICduZy1wcmlzdGluZScsXG4gICAgRElSVFlfQ0xBU1MgPSAnbmctZGlydHknO1xuXG4vKipcbiAqIEBuZ2RvYyBvYmplY3RcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9ICR2aWV3VmFsdWUgQWN0dWFsIHN0cmluZyB2YWx1ZSBpbiB0aGUgdmlldy5cbiAqIEBwcm9wZXJ0eSB7Kn0gJG1vZGVsVmFsdWUgVGhlIHZhbHVlIGluIHRoZSBtb2RlbCwgdGhhdCB0aGUgY29udHJvbCBpcyBib3VuZCB0by5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEZ1bmN0aW9uPn0gJHBhcnNlcnMgQXJyYXkgb2YgZnVuY3Rpb25zIHRvIGV4ZWN1dGUsIGFzIGEgcGlwZWxpbmUsIHdoZW5ldmVyXG4gICAgICAgdGhlIGNvbnRyb2wgcmVhZHMgdmFsdWUgZnJvbSB0aGUgRE9NLiAgRWFjaCBmdW5jdGlvbiBpcyBjYWxsZWQsIGluIHR1cm4sIHBhc3NpbmcgdGhlIHZhbHVlXG4gICAgICAgdGhyb3VnaCB0byB0aGUgbmV4dC4gVXNlZCB0byBzYW5pdGl6ZSAvIGNvbnZlcnQgdGhlIHZhbHVlIGFzIHdlbGwgYXMgdmFsaWRhdGlvbi5cbiAgICAgICBGb3IgdmFsaWRhdGlvbiwgdGhlIHBhcnNlcnMgc2hvdWxkIHVwZGF0ZSB0aGUgdmFsaWRpdHkgc3RhdGUgdXNpbmdcbiAgICAgICB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXIjbWV0aG9kc18kc2V0VmFsaWRpdHkgJHNldFZhbGlkaXR5KCl9LFxuICAgICAgIGFuZCByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIGludmFsaWQgdmFsdWVzLlxuXG4gKlxuICogQHByb3BlcnR5IHtBcnJheS48RnVuY3Rpb24+fSAkZm9ybWF0dGVycyBBcnJheSBvZiBmdW5jdGlvbnMgdG8gZXhlY3V0ZSwgYXMgYSBwaXBlbGluZSwgd2hlbmV2ZXJcbiAgICAgICB0aGUgbW9kZWwgdmFsdWUgY2hhbmdlcy4gRWFjaCBmdW5jdGlvbiBpcyBjYWxsZWQsIGluIHR1cm4sIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggdG8gdGhlXG4gICAgICAgbmV4dC4gVXNlZCB0byBmb3JtYXQgLyBjb252ZXJ0IHZhbHVlcyBmb3IgZGlzcGxheSBpbiB0aGUgY29udHJvbCBhbmQgdmFsaWRhdGlvbi5cbiAqICAgICAgPHByZT5cbiAqICAgICAgZnVuY3Rpb24gZm9ybWF0dGVyKHZhbHVlKSB7XG4gKiAgICAgICAgaWYgKHZhbHVlKSB7XG4gKiAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgICAgbmdNb2RlbC4kZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gKiAgICAgIDwvcHJlPlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPEZ1bmN0aW9uPn0gJHZpZXdDaGFuZ2VMaXN0ZW5lcnMgQXJyYXkgb2YgZnVuY3Rpb25zIHRvIGV4ZWN1dGUgd2hlbmV2ZXIgdGhlXG4gKiAgICAgdmlldyB2YWx1ZSBoYXMgY2hhbmdlZC4gSXQgaXMgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICogICAgIFRoaXMgY2FuIGJlIHVzZWQgaW4gcGxhY2Ugb2YgYWRkaXRpb25hbCAkd2F0Y2hlcyBhZ2FpbnN0IHRoZSBtb2RlbCB2YWx1ZS5cbiAqXG4gKiBAcHJvcGVydHkge09iamVjdH0gJGVycm9yIEFuIG9iamVjdCBoYXNoIHdpdGggYWxsIGVycm9ycyBhcyBrZXlzLlxuICpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJHByaXN0aW5lIFRydWUgaWYgdXNlciBoYXMgbm90IGludGVyYWN0ZWQgd2l0aCB0aGUgY29udHJvbCB5ZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59ICRkaXJ0eSBUcnVlIGlmIHVzZXIgaGFzIGFscmVhZHkgaW50ZXJhY3RlZCB3aXRoIHRoZSBjb250cm9sLlxuICogQHByb3BlcnR5IHtib29sZWFufSAkdmFsaWQgVHJ1ZSBpZiB0aGVyZSBpcyBubyBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gJGludmFsaWQgVHJ1ZSBpZiBhdCBsZWFzdCBvbmUgZXJyb3Igb24gdGhlIGNvbnRyb2wuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogYE5nTW9kZWxDb250cm9sbGVyYCBwcm92aWRlcyBBUEkgZm9yIHRoZSBgbmctbW9kZWxgIGRpcmVjdGl2ZS4gVGhlIGNvbnRyb2xsZXIgY29udGFpbnNcbiAqIHNlcnZpY2VzIGZvciBkYXRhLWJpbmRpbmcsIHZhbGlkYXRpb24sIENTUyB1cGRhdGVzLCBhbmQgdmFsdWUgZm9ybWF0dGluZyBhbmQgcGFyc2luZy4gSXRcbiAqIHB1cnBvc2VmdWxseSBkb2VzIG5vdCBjb250YWluIGFueSBsb2dpYyB3aGljaCBkZWFscyB3aXRoIERPTSByZW5kZXJpbmcgb3IgbGlzdGVuaW5nIHRvXG4gKiBET00gZXZlbnRzLiBTdWNoIERPTSByZWxhdGVkIGxvZ2ljIHNob3VsZCBiZSBwcm92aWRlZCBieSBvdGhlciBkaXJlY3RpdmVzIHdoaWNoIG1ha2UgdXNlIG9mXG4gKiBgTmdNb2RlbENvbnRyb2xsZXJgIGZvciBkYXRhLWJpbmRpbmcuXG4gKlxuICogIyMgQ3VzdG9tIENvbnRyb2wgRXhhbXBsZVxuICogVGhpcyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYE5nTW9kZWxDb250cm9sbGVyYCB3aXRoIGEgY3VzdG9tIGNvbnRyb2wgdG8gYWNoaWV2ZVxuICogZGF0YS1iaW5kaW5nLiBOb3RpY2UgaG93IGRpZmZlcmVudCBkaXJlY3RpdmVzIChgY29udGVudGVkaXRhYmxlYCwgYG5nLW1vZGVsYCwgYW5kIGByZXF1aXJlZGApXG4gKiBjb2xsYWJvcmF0ZSB0b2dldGhlciB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIHJlc3VsdC5cbiAqXG4gKiBOb3RlIHRoYXQgYGNvbnRlbnRlZGl0YWJsZWAgaXMgYW4gSFRNTDUgYXR0cmlidXRlLCB3aGljaCB0ZWxscyB0aGUgYnJvd3NlciB0byBsZXQgdGhlIGVsZW1lbnRcbiAqIGNvbnRlbnRzIGJlIGVkaXRlZCBpbiBwbGFjZSBieSB0aGUgdXNlci4gIFRoaXMgd2lsbCBub3Qgd29yayBvbiBvbGRlciBicm93c2Vycy5cbiAqXG4gKiA8ZXhhbXBsZSBtb2R1bGU9XCJjdXN0b21Db250cm9sXCI+XG4gICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxuICAgICAgW2NvbnRlbnRlZGl0YWJsZV0ge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDIwcHg7XG4gICAgICB9XG5cbiAgICAgIC5uZy1pbnZhbGlkIHtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmVkO1xuICAgICAgfVxuXG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgIGFuZ3VsYXIubW9kdWxlKCdjdXN0b21Db250cm9sJywgW10pLlxuICAgICAgICBkaXJlY3RpdmUoJ2NvbnRlbnRlZGl0YWJsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0EnLCAvLyBvbmx5IGFjdGl2YXRlIG9uIGVsZW1lbnQgYXR0cmlidXRlXG4gICAgICAgICAgICByZXF1aXJlOiAnP25nTW9kZWwnLCAvLyBnZXQgYSBob2xkIG9mIE5nTW9kZWxDb250cm9sbGVyXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIG5nTW9kZWwpIHtcbiAgICAgICAgICAgICAgaWYoIW5nTW9kZWwpIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBubyBuZy1tb2RlbFxuXG4gICAgICAgICAgICAgIC8vIFNwZWNpZnkgaG93IFVJIHNob3VsZCBiZSB1cGRhdGVkXG4gICAgICAgICAgICAgIG5nTW9kZWwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaHRtbChuZ01vZGVsLiR2aWV3VmFsdWUgfHwgJycpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgY2hhbmdlIGV2ZW50cyB0byBlbmFibGUgYmluZGluZ1xuICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdibHVyIGtleXVwIGNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNjb3BlLiRhcHBseShyZWFkKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlYWQoKTsgLy8gaW5pdGlhbGl6ZVxuXG4gICAgICAgICAgICAgIC8vIFdyaXRlIGRhdGEgdG8gdGhlIG1vZGVsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBlbGVtZW50Lmh0bWwoKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGNsZWFyIHRoZSBjb250ZW50IGVkaXRhYmxlIHRoZSBicm93c2VyIGxlYXZlcyBhIDxicj4gYmVoaW5kXG4gICAgICAgICAgICAgICAgLy8gSWYgc3RyaXAtYnIgYXR0cmlidXRlIGlzIHByb3ZpZGVkIHRoZW4gd2Ugc3RyaXAgdGhpcyBvdXRcbiAgICAgICAgICAgICAgICBpZiggYXR0cnMuc3RyaXBCciAmJiBodG1sID09ICc8YnI+JyApIHtcbiAgICAgICAgICAgICAgICAgIGh0bWwgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmdNb2RlbC4kc2V0Vmlld1ZhbHVlKGh0bWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICA8Zm9ybSBuYW1lPVwibXlGb3JtXCI+XG4gICAgICAgPGRpdiBjb250ZW50ZWRpdGFibGVcbiAgICAgICAgICAgIG5hbWU9XCJteVdpZGdldFwiIG5nLW1vZGVsPVwidXNlckNvbnRlbnRcIlxuICAgICAgICAgICAgc3RyaXAtYnI9XCJ0cnVlXCJcbiAgICAgICAgICAgIHJlcXVpcmVkPkNoYW5nZSBtZSE8L2Rpdj5cbiAgICAgICAgPHNwYW4gbmctc2hvdz1cIm15Rm9ybS5teVdpZGdldC4kZXJyb3IucmVxdWlyZWRcIj5SZXF1aXJlZCE8L3NwYW4+XG4gICAgICAgPGhyPlxuICAgICAgIDx0ZXh0YXJlYSBuZy1tb2RlbD1cInVzZXJDb250ZW50XCI+PC90ZXh0YXJlYT5cbiAgICAgIDwvZm9ybT5cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gICAgICBpdCgnc2hvdWxkIGRhdGEtYmluZCBhbmQgYmVjb21lIGludmFsaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRFZGl0YWJsZSA9IGVsZW1lbnQoJ1tjb250ZW50ZWRpdGFibGVdJyk7XG5cbiAgICAgICAgZXhwZWN0KGNvbnRlbnRFZGl0YWJsZS50ZXh0KCkpLnRvRXF1YWwoJ0NoYW5nZSBtZSEnKTtcbiAgICAgICAgaW5wdXQoJ3VzZXJDb250ZW50JykuZW50ZXIoJycpO1xuICAgICAgICBleHBlY3QoY29udGVudEVkaXRhYmxlLnRleHQoKSkudG9FcXVhbCgnJyk7XG4gICAgICAgIGV4cGVjdChjb250ZW50RWRpdGFibGUucHJvcCgnY2xhc3NOYW1lJykpLnRvTWF0Y2goL25nLWludmFsaWQtcmVxdWlyZWQvKTtcbiAgICAgIH0pO1xuICAgIDwvZmlsZT5cbiAqIDwvZXhhbXBsZT5cbiAqXG4gKlxuICovXG52YXIgTmdNb2RlbENvbnRyb2xsZXIgPSBbJyRzY29wZScsICckZXhjZXB0aW9uSGFuZGxlcicsICckYXR0cnMnLCAnJGVsZW1lbnQnLCAnJHBhcnNlJyxcbiAgICBmdW5jdGlvbigkc2NvcGUsICRleGNlcHRpb25IYW5kbGVyLCAkYXR0ciwgJGVsZW1lbnQsICRwYXJzZSkge1xuICB0aGlzLiR2aWV3VmFsdWUgPSBOdW1iZXIuTmFOO1xuICB0aGlzLiRtb2RlbFZhbHVlID0gTnVtYmVyLk5hTjtcbiAgdGhpcy4kcGFyc2VycyA9IFtdO1xuICB0aGlzLiRmb3JtYXR0ZXJzID0gW107XG4gIHRoaXMuJHZpZXdDaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy4kcHJpc3RpbmUgPSB0cnVlO1xuICB0aGlzLiRkaXJ0eSA9IGZhbHNlO1xuICB0aGlzLiR2YWxpZCA9IHRydWU7XG4gIHRoaXMuJGludmFsaWQgPSBmYWxzZTtcbiAgdGhpcy4kbmFtZSA9ICRhdHRyLm5hbWU7XG5cbiAgdmFyIG5nTW9kZWxHZXQgPSAkcGFyc2UoJGF0dHIubmdNb2RlbCksXG4gICAgICBuZ01vZGVsU2V0ID0gbmdNb2RlbEdldC5hc3NpZ247XG5cbiAgaWYgKCFuZ01vZGVsU2V0KSB7XG4gICAgdGhyb3cgbWluRXJyKCduZ01vZGVsJykoJ25vbmFzc2lnbicsIFwiRXhwcmVzc2lvbiAnezB9JyBpcyBub24tYXNzaWduYWJsZS4gRWxlbWVudDogezF9XCIsXG4gICAgICAgICRhdHRyLm5nTW9kZWwsIHN0YXJ0aW5nVGFnKCRlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRyZW5kZXJcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdmlldyBuZWVkcyB0byBiZSB1cGRhdGVkLiBJdCBpcyBleHBlY3RlZCB0aGF0IHRoZSB1c2VyIG9mIHRoZSBuZy1tb2RlbFxuICAgKiBkaXJlY3RpdmUgd2lsbCBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAqL1xuICB0aGlzLiRyZW5kZXIgPSBub29wO1xuXG4gIC8qKlxuICAgKiBAbmdkb2MgZnVuY3Rpb25cbiAgICogQG5hbWUgeyBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlciMkaXNFbXB0eVxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gd2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpcyBlbXB0eS5cbiAgICpcbiAgICogRm9yIGluc3RhbmNlLCB0aGUgcmVxdWlyZWQgZGlyZWN0aXZlIGRvZXMgdGhpcyB0byB3b3JrIG91dCBpZiB0aGUgaW5wdXQgaGFzIGRhdGEgb3Igbm90LlxuICAgKiBUaGUgZGVmYXVsdCBgJGlzRW1wdHlgIGZ1bmN0aW9uIGNoZWNrcyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgYCcnYCwgYG51bGxgIG9yIGBOYU5gLlxuICAgKlxuICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgZm9yIGlucHV0IGRpcmVjdGl2ZXMgd2hvc2UgY29uY2VwdCBvZiBiZWluZyBlbXB0eSBpcyBkaWZmZXJlbnQgdG8gdGhlXG4gICAqIGRlZmF1bHQuIFRoZSBgY2hlY2tib3hJbnB1dFR5cGVgIGRpcmVjdGl2ZSBkb2VzIHRoaXMgYmVjYXVzZSBpbiBpdHMgY2FzZSBhIHZhbHVlIG9mIGBmYWxzZWBcbiAgICogaW1wbGllcyBlbXB0eS5cbiAgICovXG4gIHRoaXMuJGlzRW1wdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZTtcbiAgfTtcblxuICB2YXIgcGFyZW50Rm9ybSA9ICRlbGVtZW50LmluaGVyaXRlZERhdGEoJyRmb3JtQ29udHJvbGxlcicpIHx8IG51bGxGb3JtQ3RybCxcbiAgICAgIGludmFsaWRDb3VudCA9IDAsIC8vIHVzZWQgdG8gZWFzaWx5IGRldGVybWluZSBpZiB3ZSBhcmUgdmFsaWRcbiAgICAgICRlcnJvciA9IHRoaXMuJGVycm9yID0ge307IC8vIGtlZXAgaW52YWxpZCBrZXlzIGhlcmVcblxuXG4gIC8vIFNldHVwIGluaXRpYWwgc3RhdGUgb2YgdGhlIGNvbnRyb2xcbiAgJGVsZW1lbnQuYWRkQ2xhc3MoUFJJU1RJTkVfQ0xBU1MpO1xuICB0b2dnbGVWYWxpZENzcyh0cnVlKTtcblxuICAvLyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGVhc3kgdG9nZ2xpbmcgb2YgY2xhc3Nlc1xuICBmdW5jdGlvbiB0b2dnbGVWYWxpZENzcyhpc1ZhbGlkLCB2YWxpZGF0aW9uRXJyb3JLZXkpIHtcbiAgICB2YWxpZGF0aW9uRXJyb3JLZXkgPSB2YWxpZGF0aW9uRXJyb3JLZXkgPyAnLScgKyBzbmFrZV9jYXNlKHZhbGlkYXRpb25FcnJvcktleSwgJy0nKSA6ICcnO1xuICAgICRlbGVtZW50LlxuICAgICAgcmVtb3ZlQ2xhc3MoKGlzVmFsaWQgPyBJTlZBTElEX0NMQVNTIDogVkFMSURfQ0xBU1MpICsgdmFsaWRhdGlvbkVycm9yS2V5KS5cbiAgICAgIGFkZENsYXNzKChpc1ZhbGlkID8gVkFMSURfQ0xBU1MgOiBJTlZBTElEX0NMQVNTKSArIHZhbGlkYXRpb25FcnJvcktleSk7XG4gIH1cblxuICAvKipcbiAgICogQG5nZG9jIGZ1bmN0aW9uXG4gICAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyIyRzZXRWYWxpZGl0eVxuICAgKiBAbWV0aG9kT2YgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENoYW5nZSB0aGUgdmFsaWRpdHkgc3RhdGUsIGFuZCBub3RpZmllcyB0aGUgZm9ybSB3aGVuIHRoZSBjb250cm9sIGNoYW5nZXMgdmFsaWRpdHkuIChpLmUuIGl0XG4gICAqIGRvZXMgbm90IG5vdGlmeSBmb3JtIGlmIGdpdmVuIHZhbGlkYXRvciBpcyBhbHJlYWR5IG1hcmtlZCBhcyBpbnZhbGlkKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBieSB2YWxpZGF0b3JzIC0gaS5lLiB0aGUgcGFyc2VyIG9yIGZvcm1hdHRlciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0aW9uRXJyb3JLZXkgTmFtZSBvZiB0aGUgdmFsaWRhdG9yLiB0aGUgYHZhbGlkYXRpb25FcnJvcktleWAgd2lsbCBhc3NpZ25cbiAgICogICAgICAgIHRvIGAkZXJyb3JbdmFsaWRhdGlvbkVycm9yS2V5XT1pc1ZhbGlkYCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSBmb3IgZGF0YS1iaW5kaW5nLlxuICAgKiAgICAgICAgVGhlIGB2YWxpZGF0aW9uRXJyb3JLZXlgIHNob3VsZCBiZSBpbiBjYW1lbENhc2UgYW5kIHdpbGwgZ2V0IGNvbnZlcnRlZCBpbnRvIGRhc2gtY2FzZVxuICAgKiAgICAgICAgZm9yIGNsYXNzIG5hbWUuIEV4YW1wbGU6IGBteUVycm9yYCB3aWxsIHJlc3VsdCBpbiBgbmctdmFsaWQtbXktZXJyb3JgIGFuZCBgbmctaW52YWxpZC1teS1lcnJvcmBcbiAgICogICAgICAgIGNsYXNzIGFuZCBjYW4gYmUgYm91bmQgdG8gYXMgIGB7e3NvbWVGb3JtLnNvbWVDb250cm9sLiRlcnJvci5teUVycm9yfX1gIC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkIFdoZXRoZXIgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdmFsaWQgKHRydWUpIG9yIGludmFsaWQgKGZhbHNlKS5cbiAgICovXG4gIHRoaXMuJHNldFZhbGlkaXR5ID0gZnVuY3Rpb24odmFsaWRhdGlvbkVycm9yS2V5LCBpc1ZhbGlkKSB7XG4gICAgLy8gUHVycG9zZWZ1bCB1c2Ugb2YgISBoZXJlIHRvIGNhc3QgaXNWYWxpZCB0byBib29sZWFuIGluIGNhc2UgaXQgaXMgdW5kZWZpbmVkXG4gICAgLy8ganNoaW50IC1XMDE4XG4gICAgaWYgKCRlcnJvclt2YWxpZGF0aW9uRXJyb3JLZXldID09PSAhaXNWYWxpZCkgcmV0dXJuO1xuICAgIC8vIGpzaGludCArVzAxOFxuXG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIGlmICgkZXJyb3JbdmFsaWRhdGlvbkVycm9yS2V5XSkgaW52YWxpZENvdW50LS07XG4gICAgICBpZiAoIWludmFsaWRDb3VudCkge1xuICAgICAgICB0b2dnbGVWYWxpZENzcyh0cnVlKTtcbiAgICAgICAgdGhpcy4kdmFsaWQgPSB0cnVlO1xuICAgICAgICB0aGlzLiRpbnZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvZ2dsZVZhbGlkQ3NzKGZhbHNlKTtcbiAgICAgIHRoaXMuJGludmFsaWQgPSB0cnVlO1xuICAgICAgdGhpcy4kdmFsaWQgPSBmYWxzZTtcbiAgICAgIGludmFsaWRDb3VudCsrO1xuICAgIH1cblxuICAgICRlcnJvclt2YWxpZGF0aW9uRXJyb3JLZXldID0gIWlzVmFsaWQ7XG4gICAgdG9nZ2xlVmFsaWRDc3MoaXNWYWxpZCwgdmFsaWRhdGlvbkVycm9yS2V5KTtcblxuICAgIHBhcmVudEZvcm0uJHNldFZhbGlkaXR5KHZhbGlkYXRpb25FcnJvcktleSwgaXNWYWxpZCwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlciMkc2V0UHJpc3RpbmVcbiAgICogQG1ldGhvZE9mIG5nLmRpcmVjdGl2ZTpuZ01vZGVsLk5nTW9kZWxDb250cm9sbGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXRzIHRoZSBjb250cm9sIHRvIGl0cyBwcmlzdGluZSBzdGF0ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlICduZy1kaXJ0eScgY2xhc3MgYW5kIHNldCB0aGUgY29udHJvbCB0byBpdHMgcHJpc3RpbmVcbiAgICogc3RhdGUgKG5nLXByaXN0aW5lIGNsYXNzKS5cbiAgICovXG4gIHRoaXMuJHNldFByaXN0aW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy4kcHJpc3RpbmUgPSB0cnVlO1xuICAgICRlbGVtZW50LnJlbW92ZUNsYXNzKERJUlRZX0NMQVNTKS5hZGRDbGFzcyhQUklTVElORV9DTEFTUyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuZ2RvYyBmdW5jdGlvblxuICAgKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlciMkc2V0Vmlld1ZhbHVlXG4gICAqIEBtZXRob2RPZiBuZy5kaXJlY3RpdmU6bmdNb2RlbC5OZ01vZGVsQ29udHJvbGxlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVXBkYXRlIHRoZSB2aWV3IHZhbHVlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIHZpZXcgdmFsdWUgY2hhbmdlcywgdHlwaWNhbGx5IGZyb20gd2l0aGluIGEgRE9NIGV2ZW50IGhhbmRsZXIuXG4gICAqIEZvciBleGFtcGxlIHtAbGluayBuZy5kaXJlY3RpdmU6aW5wdXQgaW5wdXR9IGFuZFxuICAgKiB7QGxpbmsgbmcuZGlyZWN0aXZlOnNlbGVjdCBzZWxlY3R9IGRpcmVjdGl2ZXMgY2FsbCBpdC5cbiAgICpcbiAgICogSXQgd2lsbCB1cGRhdGUgdGhlICR2aWV3VmFsdWUsIHRoZW4gcGFzcyB0aGlzIHZhbHVlIHRocm91Z2ggZWFjaCBvZiB0aGUgZnVuY3Rpb25zIGluIGAkcGFyc2Vyc2AsXG4gICAqIHdoaWNoIGluY2x1ZGVzIGFueSB2YWxpZGF0b3JzLiBUaGUgdmFsdWUgdGhhdCBjb21lcyBvdXQgb2YgdGhpcyBgJHBhcnNlcnNgIHBpcGVsaW5lLCBiZSBhcHBsaWVkIHRvXG4gICAqIGAkbW9kZWxWYWx1ZWAgYW5kIHRoZSAqKmV4cHJlc3Npb24qKiBzcGVjaWZpZWQgaW4gdGhlIGBuZy1tb2RlbGAgYXR0cmlidXRlLlxuICAgKlxuICAgKiBMYXN0bHksIGFsbCB0aGUgcmVnaXN0ZXJlZCBjaGFuZ2UgbGlzdGVuZXJzLCBpbiB0aGUgYCR2aWV3Q2hhbmdlTGlzdGVuZXJzYCBsaXN0LCBhcmUgY2FsbGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyaWdnZXIgYSBgJGRpZ2VzdGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSBmcm9tIHRoZSB2aWV3LlxuICAgKi9cbiAgdGhpcy4kc2V0Vmlld1ZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLiR2aWV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIGNoYW5nZSB0byBkaXJ0eVxuICAgIGlmICh0aGlzLiRwcmlzdGluZSkge1xuICAgICAgdGhpcy4kZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy4kcHJpc3RpbmUgPSBmYWxzZTtcbiAgICAgICRlbGVtZW50LnJlbW92ZUNsYXNzKFBSSVNUSU5FX0NMQVNTKS5hZGRDbGFzcyhESVJUWV9DTEFTUyk7XG4gICAgICBwYXJlbnRGb3JtLiRzZXREaXJ0eSgpO1xuICAgIH1cblxuICAgIGZvckVhY2godGhpcy4kcGFyc2VycywgZnVuY3Rpb24oZm4pIHtcbiAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuJG1vZGVsVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLiRtb2RlbFZhbHVlID0gdmFsdWU7XG4gICAgICBuZ01vZGVsU2V0KCRzY29wZSwgdmFsdWUpO1xuICAgICAgZm9yRWFjaCh0aGlzLiR2aWV3Q2hhbmdlTGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICRleGNlcHRpb25IYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gbW9kZWwgLT4gdmFsdWVcbiAgdmFyIGN0cmwgPSB0aGlzO1xuXG4gICRzY29wZS4kd2F0Y2goZnVuY3Rpb24gbmdNb2RlbFdhdGNoKCkge1xuICAgIHZhciB2YWx1ZSA9IG5nTW9kZWxHZXQoJHNjb3BlKTtcblxuICAgIC8vIGlmIHNjb3BlIG1vZGVsIHZhbHVlIGFuZCBuZ01vZGVsIHZhbHVlIGFyZSBvdXQgb2Ygc3luY1xuICAgIGlmIChjdHJsLiRtb2RlbFZhbHVlICE9PSB2YWx1ZSkge1xuXG4gICAgICB2YXIgZm9ybWF0dGVycyA9IGN0cmwuJGZvcm1hdHRlcnMsXG4gICAgICAgICAgaWR4ID0gZm9ybWF0dGVycy5sZW5ndGg7XG5cbiAgICAgIGN0cmwuJG1vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHdoaWxlKGlkeC0tKSB7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0dGVyc1tpZHhdKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0cmwuJHZpZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY3RybC4kdmlld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGN0cmwuJHJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XTtcblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vZGVsXG4gKlxuICogQGVsZW1lbnQgaW5wdXRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgbmdNb2RlbGAgZGlyZWN0aXZlIGJpbmRzIGFuIGBpbnB1dGAsYHNlbGVjdGAsIGB0ZXh0YXJlYWAgKG9yIGN1c3RvbSBmb3JtIGNvbnRyb2wpIHRvIGFcbiAqIHByb3BlcnR5IG9uIHRoZSBzY29wZSB1c2luZyB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nTW9kZWwuTmdNb2RlbENvbnRyb2xsZXIgTmdNb2RlbENvbnRyb2xsZXJ9LFxuICogd2hpY2ggaXMgY3JlYXRlZCBhbmQgZXhwb3NlZCBieSB0aGlzIGRpcmVjdGl2ZS5cbiAqXG4gKiBgbmdNb2RlbGAgaXMgcmVzcG9uc2libGUgZm9yOlxuICpcbiAqIC0gQmluZGluZyB0aGUgdmlldyBpbnRvIHRoZSBtb2RlbCwgd2hpY2ggb3RoZXIgZGlyZWN0aXZlcyBzdWNoIGFzIGBpbnB1dGAsIGB0ZXh0YXJlYWAgb3IgYHNlbGVjdGBcbiAqICAgcmVxdWlyZS5cbiAqIC0gUHJvdmlkaW5nIHZhbGlkYXRpb24gYmVoYXZpb3IgKGkuZS4gcmVxdWlyZWQsIG51bWJlciwgZW1haWwsIHVybCkuXG4gKiAtIEtlZXBpbmcgdGhlIHN0YXRlIG9mIHRoZSBjb250cm9sICh2YWxpZC9pbnZhbGlkLCBkaXJ0eS9wcmlzdGluZSwgdmFsaWRhdGlvbiBlcnJvcnMpLlxuICogLSBTZXR0aW5nIHJlbGF0ZWQgY3NzIGNsYXNzZXMgb24gdGhlIGVsZW1lbnQgKGBuZy12YWxpZGAsIGBuZy1pbnZhbGlkYCwgYG5nLWRpcnR5YCwgYG5nLXByaXN0aW5lYCkuXG4gKiAtIFJlZ2lzdGVyaW5nIHRoZSBjb250cm9sIHdpdGggaXRzIHBhcmVudCB7QGxpbmsgbmcuZGlyZWN0aXZlOmZvcm0gZm9ybX0uXG4gKlxuICogTm90ZTogYG5nTW9kZWxgIHdpbGwgdHJ5IHRvIGJpbmQgdG8gdGhlIHByb3BlcnR5IGdpdmVuIGJ5IGV2YWx1YXRpbmcgdGhlIGV4cHJlc3Npb24gb24gdGhlXG4gKiBjdXJyZW50IHNjb3BlLiBJZiB0aGUgcHJvcGVydHkgZG9lc24ndCBhbHJlYWR5IGV4aXN0IG9uIHRoaXMgc2NvcGUsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICogaW1wbGljaXRseSBhbmQgYWRkZWQgdG8gdGhlIHNjb3BlLlxuICpcbiAqIEZvciBiZXN0IHByYWN0aWNlcyBvbiB1c2luZyBgbmdNb2RlbGAsIHNlZTpcbiAqXG4gKiAgLSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy93aWtpL1VuZGVyc3RhbmRpbmctU2NvcGVzfVxuICpcbiAqIEZvciBiYXNpYyBleGFtcGxlcywgaG93IHRvIHVzZSBgbmdNb2RlbGAsIHNlZTpcbiAqXG4gKiAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0IGlucHV0fVxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LnRleHQgdGV4dH1cbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC5jaGVja2JveCBjaGVja2JveH1cbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC5yYWRpbyByYWRpb31cbiAqICAgIC0ge0BsaW5rIG5nLmRpcmVjdGl2ZTppbnB1dC5udW1iZXIgbnVtYmVyfVxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LmVtYWlsIGVtYWlsfVxuICogICAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOmlucHV0LnVybCB1cmx9XG4gKiAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOnNlbGVjdCBzZWxlY3R9XG4gKiAgLSB7QGxpbmsgbmcuZGlyZWN0aXZlOnRleHRhcmVhIHRleHRhcmVhfVxuICpcbiAqL1xudmFyIG5nTW9kZWxEaXJlY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiBbJ25nTW9kZWwnLCAnXj9mb3JtJ10sXG4gICAgY29udHJvbGxlcjogTmdNb2RlbENvbnRyb2xsZXIsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmxzKSB7XG4gICAgICAvLyBub3RpZnkgb3RoZXJzLCBlc3BlY2lhbGx5IHBhcmVudCBmb3Jtc1xuXG4gICAgICB2YXIgbW9kZWxDdHJsID0gY3RybHNbMF0sXG4gICAgICAgICAgZm9ybUN0cmwgPSBjdHJsc1sxXSB8fCBudWxsRm9ybUN0cmw7XG5cbiAgICAgIGZvcm1DdHJsLiRhZGRDb250cm9sKG1vZGVsQ3RybCk7XG5cbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9ybUN0cmwuJHJlbW92ZUNvbnRyb2wobW9kZWxDdHJsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDaGFuZ2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEV2YWx1YXRlIGdpdmVuIGV4cHJlc3Npb24gd2hlbiB1c2VyIGNoYW5nZXMgdGhlIGlucHV0LlxuICogVGhlIGV4cHJlc3Npb24gaXMgbm90IGV2YWx1YXRlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2UgaXMgY29taW5nIGZyb20gdGhlIG1vZGVsLlxuICpcbiAqIE5vdGUsIHRoaXMgZGlyZWN0aXZlIHJlcXVpcmVzIGBuZ01vZGVsYCB0byBiZSBwcmVzZW50LlxuICpcbiAqIEBlbGVtZW50IGlucHV0XG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ2hhbmdlIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb24gY2hhbmdlXG4gKiBpbiBpbnB1dCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGRvYzpleGFtcGxlPlxuICogICA8ZG9jOnNvdXJjZT5cbiAqICAgICA8c2NyaXB0PlxuICogICAgICAgZnVuY3Rpb24gQ29udHJvbGxlcigkc2NvcGUpIHtcbiAqICAgICAgICAgJHNjb3BlLmNvdW50ZXIgPSAwO1xuICogICAgICAgICAkc2NvcGUuY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgJHNjb3BlLmNvdW50ZXIrKztcbiAqICAgICAgICAgfTtcbiAqICAgICAgIH1cbiAqICAgICA8L3NjcmlwdD5cbiAqICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDb250cm9sbGVyXCI+XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJjb25maXJtZWRcIiBuZy1jaGFuZ2U9XCJjaGFuZ2UoKVwiIGlkPVwibmctY2hhbmdlLWV4YW1wbGUxXCIgLz5cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNvbmZpcm1lZFwiIGlkPVwibmctY2hhbmdlLWV4YW1wbGUyXCIgLz5cbiAqICAgICAgIDxsYWJlbCBmb3I9XCJuZy1jaGFuZ2UtZXhhbXBsZTJcIj5Db25maXJtZWQ8L2xhYmVsPjxiciAvPlxuICogICAgICAgZGVidWcgPSB7e2NvbmZpcm1lZH19PGJyIC8+XG4gKiAgICAgICBjb3VudGVyID0ge3tjb3VudGVyfX1cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kb2M6c291cmNlPlxuICogICA8ZG9jOnNjZW5hcmlvPlxuICogICAgIGl0KCdzaG91bGQgZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gaWYgY2hhbmdpbmcgZnJvbSB2aWV3JywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICBleHBlY3QoYmluZGluZygnY291bnRlcicpKS50b0VxdWFsKCcwJyk7XG4gKiAgICAgICBlbGVtZW50KCcjbmctY2hhbmdlLWV4YW1wbGUxJykuY2xpY2soKTtcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudGVyJykpLnRvRXF1YWwoJzEnKTtcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb25maXJtZWQnKSkudG9FcXVhbCgndHJ1ZScpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBpdCgnc2hvdWxkIG5vdCBldmFsdWF0ZSB0aGUgZXhwcmVzc2lvbiBpZiBjaGFuZ2luZyBmcm9tIG1vZGVsJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICBlbGVtZW50KCcjbmctY2hhbmdlLWV4YW1wbGUyJykuY2xpY2soKTtcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudGVyJykpLnRvRXF1YWwoJzAnKTtcbiAqICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb25maXJtZWQnKSkudG9FcXVhbCgndHJ1ZScpO1xuICogICAgIH0pO1xuICogICA8L2RvYzpzY2VuYXJpbz5cbiAqIDwvZG9jOmV4YW1wbGU+XG4gKi9cbnZhciBuZ0NoYW5nZURpcmVjdGl2ZSA9IHZhbHVlRm4oe1xuICByZXF1aXJlOiAnbmdNb2RlbCcsXG4gIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyLCBjdHJsKSB7XG4gICAgY3RybC4kdmlld0NoYW5nZUxpc3RlbmVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgc2NvcGUuJGV2YWwoYXR0ci5uZ0NoYW5nZSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbnZhciByZXF1aXJlZERpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICc/bmdNb2RlbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0ciwgY3RybCkge1xuICAgICAgaWYgKCFjdHJsKSByZXR1cm47XG4gICAgICBhdHRyLnJlcXVpcmVkID0gdHJ1ZTsgLy8gZm9yY2UgdHJ1dGh5IGluIGNhc2Ugd2UgYXJlIG9uIG5vbiBpbnB1dCBlbGVtZW50XG5cbiAgICAgIHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoYXR0ci5yZXF1aXJlZCAmJiBjdHJsLiRpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgIGN0cmwuJHNldFZhbGlkaXR5KCdyZXF1aXJlZCcsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3RybC4kc2V0VmFsaWRpdHkoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2godmFsaWRhdG9yKTtcbiAgICAgIGN0cmwuJHBhcnNlcnMudW5zaGlmdCh2YWxpZGF0b3IpO1xuXG4gICAgICBhdHRyLiRvYnNlcnZlKCdyZXF1aXJlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YWxpZGF0b3IoY3RybC4kdmlld1ZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG5cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdMaXN0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUZXh0IGlucHV0IHRoYXQgY29udmVydHMgYmV0d2VlbiBhIGRlbGltaXRlZCBzdHJpbmcgYW5kIGFuIGFycmF5IG9mIHN0cmluZ3MuIFRoZSBkZWxpbWl0ZXJcbiAqIGNhbiBiZSBhIGZpeGVkIHN0cmluZyAoYnkgZGVmYXVsdCBhIGNvbW1hKSBvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZWxlbWVudCBpbnB1dFxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ0xpc3Qgb3B0aW9uYWwgZGVsaW1pdGVyIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gc3BsaXQgdGhlIHZhbHVlLiBJZlxuICogICBzcGVjaWZpZWQgaW4gZm9ybSBgL3NvbWV0aGluZy9gIHRoZW4gdGhlIHZhbHVlIHdpbGwgYmUgY29udmVydGVkIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQGV4YW1wbGVcbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICA8c2NyaXB0PlxuICAgICAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAgICAgJHNjb3BlLm5hbWVzID0gWydpZ29yJywgJ21pc2tvJywgJ3ZvanRhJ107XG4gICAgICAgICB9XG4gICAgICAgPC9zY3JpcHQ+XG4gICAgICAgPGZvcm0gbmFtZT1cIm15Rm9ybVwiIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgICAgICBMaXN0OiA8aW5wdXQgbmFtZT1cIm5hbWVzSW5wdXRcIiBuZy1tb2RlbD1cIm5hbWVzXCIgbmctbGlzdCByZXF1aXJlZD5cbiAgICAgICAgIDxzcGFuIGNsYXNzPVwiZXJyb3JcIiBuZy1zaG93PVwibXlGb3JtLm5hbWVzSW5wdXQuJGVycm9yLnJlcXVpcmVkXCI+XG4gICAgICAgICAgIFJlcXVpcmVkITwvc3Bhbj5cbiAgICAgICAgIDxicj5cbiAgICAgICAgIDx0dD5uYW1lcyA9IHt7bmFtZXN9fTwvdHQ+PGJyLz5cbiAgICAgICAgIDx0dD5teUZvcm0ubmFtZXNJbnB1dC4kdmFsaWQgPSB7e215Rm9ybS5uYW1lc0lucHV0LiR2YWxpZH19PC90dD48YnIvPlxuICAgICAgICAgPHR0Pm15Rm9ybS5uYW1lc0lucHV0LiRlcnJvciA9IHt7bXlGb3JtLm5hbWVzSW5wdXQuJGVycm9yfX08L3R0Pjxici8+XG4gICAgICAgICA8dHQ+bXlGb3JtLiR2YWxpZCA9IHt7bXlGb3JtLiR2YWxpZH19PC90dD48YnIvPlxuICAgICAgICAgPHR0Pm15Rm9ybS4kZXJyb3IucmVxdWlyZWQgPSB7eyEhbXlGb3JtLiRlcnJvci5yZXF1aXJlZH19PC90dD48YnIvPlxuICAgICAgICA8L2Zvcm0+XG4gICAgICA8L2RvYzpzb3VyY2U+XG4gICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgdG8gbW9kZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygnbmFtZXMnKSkudG9FcXVhbCgnW1wiaWdvclwiLFwibWlza29cIixcInZvanRhXCJdJyk7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215Rm9ybS5uYW1lc0lucHV0LiR2YWxpZCcpKS50b0VxdWFsKCd0cnVlJyk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJ3NwYW4uZXJyb3InKS5jc3MoJ2Rpc3BsYXknKSkudG9CZSgnbm9uZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGJlIGludmFsaWQgaWYgZW1wdHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpbnB1dCgnbmFtZXMnKS5lbnRlcignJyk7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ25hbWVzJykpLnRvRXF1YWwoJycpO1xuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteUZvcm0ubmFtZXNJbnB1dC4kdmFsaWQnKSkudG9FcXVhbCgnZmFsc2UnKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnc3Bhbi5lcnJvcicpLmNzcygnZGlzcGxheScpKS5ub3QoKS50b0JlKCdub25lJyk7XG4gICAgICAgIH0pO1xuICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xudmFyIG5nTGlzdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICduZ01vZGVsJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCkge1xuICAgICAgdmFyIG1hdGNoID0gL1xcLyguKilcXC8vLmV4ZWMoYXR0ci5uZ0xpc3QpLFxuICAgICAgICAgIHNlcGFyYXRvciA9IG1hdGNoICYmIG5ldyBSZWdFeHAobWF0Y2hbMV0pIHx8IGF0dHIubmdMaXN0IHx8ICcsJztcblxuICAgICAgdmFyIHBhcnNlID0gZnVuY3Rpb24odmlld1ZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2aWV3VmFsdWUgaXMgaW52YWxpZCAoc2F5IHJlcXVpcmVkIGJ1dCBlbXB0eSkgaXQgd2lsbCBiZSBgdW5kZWZpbmVkYFxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmlld1ZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgaWYgKHZpZXdWYWx1ZSkge1xuICAgICAgICAgIGZvckVhY2godmlld1ZhbHVlLnNwbGl0KHNlcGFyYXRvciksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIGxpc3QucHVzaCh0cmltKHZhbHVlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuJHBhcnNlcnMucHVzaChwYXJzZSk7XG4gICAgICBjdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLmpvaW4oJywgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE92ZXJyaWRlIHRoZSBzdGFuZGFyZCAkaXNFbXB0eSBiZWNhdXNlIGFuIGVtcHR5IGFycmF5IG1lYW5zIHRoZSBpbnB1dCBpcyBlbXB0eS5cbiAgICAgIGN0cmwuJGlzRW1wdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlIHx8ICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cblxudmFyIENPTlNUQU5UX1ZBTFVFX1JFR0VYUCA9IC9eKHRydWV8ZmFsc2V8XFxkKykkLztcbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nVmFsdWVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJpbmRzIHRoZSBnaXZlbiBleHByZXNzaW9uIHRvIHRoZSB2YWx1ZSBvZiBgaW5wdXRbc2VsZWN0XWAgb3IgYGlucHV0W3JhZGlvXWAsIHNvXG4gKiB0aGF0IHdoZW4gdGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQsIHRoZSBgbmdNb2RlbGAgb2YgdGhhdCBlbGVtZW50IGlzIHNldCB0byB0aGVcbiAqIGJvdW5kIHZhbHVlLlxuICpcbiAqIGBuZ1ZhbHVlYCBpcyB1c2VmdWwgd2hlbiBkeW5hbWljYWxseSBnZW5lcmF0aW5nIGxpc3RzIG9mIHJhZGlvIGJ1dHRvbnMgdXNpbmcgYG5nLXJlcGVhdGAsIGFzXG4gKiBzaG93biBiZWxvdy5cbiAqXG4gKiBAZWxlbWVudCBpbnB1dFxuICogQHBhcmFtIHtzdHJpbmc9fSBuZ1ZhbHVlIGFuZ3VsYXIgZXhwcmVzc2lvbiwgd2hvc2UgdmFsdWUgd2lsbCBiZSBib3VuZCB0byB0aGUgYHZhbHVlYCBhdHRyaWJ1dGVcbiAqICAgb2YgdGhlIGBpbnB1dGAgZWxlbWVudFxuICpcbiAqIEBleGFtcGxlXG4gICAgPGRvYzpleGFtcGxlPlxuICAgICAgPGRvYzpzb3VyY2U+XG4gICAgICAgPHNjcmlwdD5cbiAgICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAgICAgJHNjb3BlLm5hbWVzID0gWydwaXp6YScsICd1bmljb3JucycsICdyb2JvdHMnXTtcbiAgICAgICAgICAgICRzY29wZS5teSA9IHsgZmF2b3JpdGU6ICd1bmljb3JucycgfTtcbiAgICAgICAgICB9XG4gICAgICAgPC9zY3JpcHQ+XG4gICAgICAgIDxmb3JtIG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgICAgICAgPGgyPldoaWNoIGlzIHlvdXIgZmF2b3JpdGU/PC9oMj5cbiAgICAgICAgICAgIDxsYWJlbCBuZy1yZXBlYXQ9XCJuYW1lIGluIG5hbWVzXCIgZm9yPVwie3tuYW1lfX1cIj5cbiAgICAgICAgICAgICAge3tuYW1lfX1cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgICAgICBuZy1tb2RlbD1cIm15LmZhdm9yaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgIG5nLXZhbHVlPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICBpZD1cInt7bmFtZX19XCJcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJmYXZvcml0ZVwiPlxuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICA8ZGl2PllvdSBjaG9zZSB7e215LmZhdm9yaXRlfX08L2Rpdj5cbiAgICAgICAgPC9mb3JtPlxuICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHRvIG1vZGVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ215LmZhdm9yaXRlJykpLnRvRXF1YWwoJ3VuaWNvcm5zJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnc2hvdWxkIGJpbmQgdGhlIHZhbHVlcyB0byB0aGUgaW5wdXRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaW5wdXQoJ215LmZhdm9yaXRlJykuc2VsZWN0KCdwaXp6YScpO1xuICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdteS5mYXZvcml0ZScpKS50b0VxdWFsKCdwaXp6YScpO1xuICAgICAgICB9KTtcbiAgICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cbnZhciBuZ1ZhbHVlRGlyZWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEwMCxcbiAgICBjb21waWxlOiBmdW5jdGlvbih0cGwsIHRwbEF0dHIpIHtcbiAgICAgIGlmIChDT05TVEFOVF9WQUxVRV9SRUdFWFAudGVzdCh0cGxBdHRyLm5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZ1ZhbHVlQ29uc3RhbnRMaW5rKHNjb3BlLCBlbG0sIGF0dHIpIHtcbiAgICAgICAgICBhdHRyLiRzZXQoJ3ZhbHVlJywgc2NvcGUuJGV2YWwoYXR0ci5uZ1ZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmdWYWx1ZUxpbmsoc2NvcGUsIGVsbSwgYXR0cikge1xuICAgICAgICAgIHNjb3BlLiR3YXRjaChhdHRyLm5nVmFsdWUsIGZ1bmN0aW9uIHZhbHVlV2F0Y2hBY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGF0dHIuJHNldCgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdCaW5kXG4gKiBAcmVzdHJpY3QgQUNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgbmdCaW5kYCBhdHRyaWJ1dGUgdGVsbHMgQW5ndWxhciB0byByZXBsYWNlIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHNwZWNpZmllZCBIVE1MIGVsZW1lbnRcbiAqIHdpdGggdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gZXhwcmVzc2lvbiwgYW5kIHRvIHVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoYXRcbiAqIGV4cHJlc3Npb24gY2hhbmdlcy5cbiAqXG4gKiBUeXBpY2FsbHksIHlvdSBkb24ndCB1c2UgYG5nQmluZGAgZGlyZWN0bHksIGJ1dCBpbnN0ZWFkIHlvdSB1c2UgdGhlIGRvdWJsZSBjdXJseSBtYXJrdXAgbGlrZVxuICogYHt7IGV4cHJlc3Npb24gfX1gIHdoaWNoIGlzIHNpbWlsYXIgYnV0IGxlc3MgdmVyYm9zZS5cbiAqXG4gKiBJdCBpcyBwcmVmZXJyYWJsZSB0byB1c2UgYG5nQmluZGAgaW5zdGVhZCBvZiBge3sgZXhwcmVzc2lvbiB9fWAgd2hlbiBhIHRlbXBsYXRlIGlzIG1vbWVudGFyaWx5XG4gKiBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgaW4gaXRzIHJhdyBzdGF0ZSBiZWZvcmUgQW5ndWxhciBjb21waWxlcyBpdC4gU2luY2UgYG5nQmluZGAgaXMgYW5cbiAqIGVsZW1lbnQgYXR0cmlidXRlLCBpdCBtYWtlcyB0aGUgYmluZGluZ3MgaW52aXNpYmxlIHRvIHRoZSB1c2VyIHdoaWxlIHRoZSBwYWdlIGlzIGxvYWRpbmcuXG4gKlxuICogQW4gYWx0ZXJuYXRpdmUgc29sdXRpb24gdG8gdGhpcyBwcm9ibGVtIHdvdWxkIGJlIHVzaW5nIHRoZVxuICoge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0Nsb2FrIG5nQ2xvYWt9IGRpcmVjdGl2ZS5cbiAqXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQmluZCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogRW50ZXIgYSBuYW1lIGluIHRoZSBMaXZlIFByZXZpZXcgdGV4dCBib3g7IHRoZSBncmVldGluZyBiZWxvdyB0aGUgdGV4dCBib3ggY2hhbmdlcyBpbnN0YW50bHkuXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAgICAkc2NvcGUubmFtZSA9ICdXaGlybGVkJztcbiAgICAgICAgIH1cbiAgICAgICA8L3NjcmlwdD5cbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgICAgICBFbnRlciBuYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cIm5hbWVcIj48YnI+XG4gICAgICAgICBIZWxsbyA8c3BhbiBuZy1iaW5kPVwibmFtZVwiPjwvc3Bhbj4hXG4gICAgICAgPC9kaXY+XG4gICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWJpbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5iaW5kaW5nKCduYW1lJykpLnRvQmUoJ1doaXJsZWQnKTtcbiAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCduYW1lJykuZW50ZXIoJ3dvcmxkJyk7XG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnbmFtZScpKS50b0JlKCd3b3JsZCcpO1xuICAgICAgIH0pO1xuICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cbnZhciBuZ0JpbmREaXJlY3RpdmUgPSBuZ0RpcmVjdGl2ZShmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICBlbGVtZW50LmFkZENsYXNzKCduZy1iaW5kaW5nJykuZGF0YSgnJGJpbmRpbmcnLCBhdHRyLm5nQmluZCk7XG4gIHNjb3BlLiR3YXRjaChhdHRyLm5nQmluZCwgZnVuY3Rpb24gbmdCaW5kV2F0Y2hBY3Rpb24odmFsdWUpIHtcbiAgICAvLyBXZSBhcmUgcHVycG9zZWZ1bGx5IHVzaW5nID09IGhlcmUgcmF0aGVyIHRoYW4gPT09IGJlY2F1c2Ugd2Ugd2FudCB0b1xuICAgIC8vIGNhdGNoIHdoZW4gdmFsdWUgaXMgXCJudWxsIG9yIHVuZGVmaW5lZFwiXG4gICAgLy8ganNoaW50IC1XMDQxXG4gICAgZWxlbWVudC50ZXh0KHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWUpO1xuICB9KTtcbn0pO1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQmluZFRlbXBsYXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nQmluZFRlbXBsYXRlYCBkaXJlY3RpdmUgc3BlY2lmaWVzIHRoYXQgdGhlIGVsZW1lbnRcbiAqIHRleHQgY29udGVudCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW50ZXJwb2xhdGlvbiBvZiB0aGUgdGVtcGxhdGVcbiAqIGluIHRoZSBgbmdCaW5kVGVtcGxhdGVgIGF0dHJpYnV0ZS5cbiAqIFVubGlrZSBgbmdCaW5kYCwgdGhlIGBuZ0JpbmRUZW1wbGF0ZWAgY2FuIGNvbnRhaW4gbXVsdGlwbGUgYHt7YCBgfX1gXG4gKiBleHByZXNzaW9ucy4gVGhpcyBkaXJlY3RpdmUgaXMgbmVlZGVkIHNpbmNlIHNvbWUgSFRNTCBlbGVtZW50c1xuICogKHN1Y2ggYXMgVElUTEUgYW5kIE9QVElPTikgY2Fubm90IGNvbnRhaW4gU1BBTiBlbGVtZW50cy5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZ0JpbmRUZW1wbGF0ZSB0ZW1wbGF0ZSBvZiBmb3JtXG4gKiAgIDx0dD57ezwvdHQ+IDx0dD5leHByZXNzaW9uPC90dD4gPHR0Pn19PC90dD4gdG8gZXZhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogVHJ5IGl0IGhlcmU6IGVudGVyIHRleHQgaW4gdGV4dCBib3ggYW5kIHdhdGNoIHRoZSBncmVldGluZyBjaGFuZ2UuXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgIDxzY3JpcHQ+XG4gICAgICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAgICAkc2NvcGUuc2FsdXRhdGlvbiA9ICdIZWxsbyc7XG4gICAgICAgICAgICRzY29wZS5uYW1lID0gJ1dvcmxkJztcbiAgICAgICAgIH1cbiAgICAgICA8L3NjcmlwdD5cbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgICAgIFNhbHV0YXRpb246IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwic2FsdXRhdGlvblwiPjxicj5cbiAgICAgICAgTmFtZTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJuYW1lXCI+PGJyPlxuICAgICAgICA8cHJlIG5nLWJpbmQtdGVtcGxhdGU9XCJ7e3NhbHV0YXRpb259fSB7e25hbWV9fSFcIj48L3ByZT5cbiAgICAgICA8L2Rpdj5cbiAgICAgPC9kb2M6c291cmNlPlxuICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctYmluZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ3NhbHV0YXRpb24nKSkuXG4gICAgICAgICAgIHRvQmUoJ0hlbGxvJyk7XG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuYmluZGluZygnbmFtZScpKS5cbiAgICAgICAgICAgdG9CZSgnV29ybGQnKTtcbiAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdzYWx1dGF0aW9uJykuZW50ZXIoJ0dyZWV0aW5ncycpO1xuICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ25hbWUnKS5lbnRlcigndXNlcicpO1xuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ3NhbHV0YXRpb24nKSkuXG4gICAgICAgICAgIHRvQmUoJ0dyZWV0aW5ncycpO1xuICAgICAgICAgZXhwZWN0KHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmJpbmRpbmcoJ25hbWUnKSkuXG4gICAgICAgICAgIHRvQmUoJ3VzZXInKTtcbiAgICAgICB9KTtcbiAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG52YXIgbmdCaW5kVGVtcGxhdGVEaXJlY3RpdmUgPSBbJyRpbnRlcnBvbGF0ZScsIGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gc2NlbmFyaW8gcnVubmVyXG4gICAgdmFyIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUoZWxlbWVudC5hdHRyKGF0dHIuJGF0dHIubmdCaW5kVGVtcGxhdGUpKTtcbiAgICBlbGVtZW50LmFkZENsYXNzKCduZy1iaW5kaW5nJykuZGF0YSgnJGJpbmRpbmcnLCBpbnRlcnBvbGF0ZUZuKTtcbiAgICBhdHRyLiRvYnNlcnZlKCduZ0JpbmRUZW1wbGF0ZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xuICAgIH0pO1xuICB9O1xufV07XG5cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdCaW5kSHRtbFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIGJpbmRpbmcgdGhhdCB3aWxsIGlubmVySFRNTCB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIGBleHByZXNzaW9uYCBpbnRvIHRoZSBjdXJyZW50XG4gKiBlbGVtZW50IGluIGEgc2VjdXJlIHdheS4gIEJ5IGRlZmF1bHQsIHRoZSBpbm5lckhUTUwtZWQgY29udGVudCB3aWxsIGJlIHNhbml0aXplZCB1c2luZyB0aGUge0BsaW5rXG4gKiBuZ1Nhbml0aXplLiRzYW5pdGl6ZSAkc2FuaXRpemV9IHNlcnZpY2UuICBUbyB1dGlsaXplIHRoaXMgZnVuY3Rpb25hbGl0eSwgZW5zdXJlIHRoYXQgYCRzYW5pdGl6ZWBcbiAqIGlzIGF2YWlsYWJsZSwgZm9yIGV4YW1wbGUsIGJ5IGluY2x1ZGluZyB7QGxpbmsgbmdTYW5pdGl6ZX0gaW4geW91ciBtb2R1bGUncyBkZXBlbmRlbmNpZXMgKG5vdCBpblxuICogY29yZSBBbmd1bGFyLikgIFlvdSBtYXkgYWxzbyBieXBhc3Mgc2FuaXRpemF0aW9uIGZvciB2YWx1ZXMgeW91IGtub3cgYXJlIHNhZmUuIFRvIGRvIHNvLCBiaW5kIHRvXG4gKiBhbiBleHBsaWNpdGx5IHRydXN0ZWQgdmFsdWUgdmlhIHtAbGluayBuZy4kc2NlI21ldGhvZHNfdHJ1c3RBc0h0bWwgJHNjZS50cnVzdEFzSHRtbH0uICBTZWUgdGhlIGV4YW1wbGVcbiAqIHVuZGVyIHtAbGluayBuZy4kc2NlI0V4YW1wbGUgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmcgKFNDRSl9LlxuICpcbiAqIE5vdGU6IElmIGEgYCRzYW5pdGl6ZWAgc2VydmljZSBpcyB1bmF2YWlsYWJsZSBhbmQgdGhlIGJvdW5kIHZhbHVlIGlzbid0IGV4cGxpY2l0bHkgdHJ1c3RlZCwgeW91XG4gKiB3aWxsIGhhdmUgYW4gZXhjZXB0aW9uIChpbnN0ZWFkIG9mIGFuIGV4cGxvaXQuKVxuICpcbiAqIEBlbGVtZW50IEFOWVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0JpbmRIdG1sIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gICBUcnkgaXQgaGVyZTogZW50ZXIgdGV4dCBpbiB0ZXh0IGJveCBhbmQgd2F0Y2ggdGhlIGdyZWV0aW5nIGNoYW5nZS5cbiBcbiAgIDxleGFtcGxlIG1vZHVsZT1cIm5nQmluZEh0bWxFeGFtcGxlXCIgZGVwcz1cImFuZ3VsYXItc2FuaXRpemUuanNcIj5cbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJuZ0JpbmRIdG1sQ3RybFwiPlxuICAgICAgICA8cCBuZy1iaW5kLWh0bWw9XCJteUhUTUxcIj48L3A+XG4gICAgICAgPC9kaXY+XG4gICAgIDwvZmlsZT5cbiAgICAgXG4gICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgICBhbmd1bGFyLm1vZHVsZSgnbmdCaW5kSHRtbEV4YW1wbGUnLCBbJ25nU2FuaXRpemUnXSlcblxuICAgICAgIC5jb250cm9sbGVyKCduZ0JpbmRIdG1sQ3RybCcsIFsnJHNjb3BlJywgZnVuY3Rpb24gbmdCaW5kSHRtbEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAkc2NvcGUubXlIVE1MID1cbiAgICAgICAgICAgICdJIGFtIGFuIDxjb2RlPkhUTUw8L2NvZGU+c3RyaW5nIHdpdGggPGEgaHJlZj1cIiNcIj5saW5rcyE8L2E+IGFuZCBvdGhlciA8ZW0+c3R1ZmY8L2VtPic7XG4gICAgICAgfV0pO1xuICAgICA8L2ZpbGU+XG5cbiAgICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1iaW5kLWh0bWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5iaW5kaW5nKCdteUhUTUwnKSkuXG4gICAgICAgICAgIHRvQmUoXG4gICAgICAgICAgICdJIGFtIGFuIDxjb2RlPkhUTUw8L2NvZGU+c3RyaW5nIHdpdGggPGEgaHJlZj1cIiNcIj5saW5rcyE8L2E+IGFuZCBvdGhlciA8ZW0+c3R1ZmY8L2VtPidcbiAgICAgICAgICAgKTtcbiAgICAgICB9KTtcbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG52YXIgbmdCaW5kSHRtbERpcmVjdGl2ZSA9IFsnJHNjZScsICckcGFyc2UnLCBmdW5jdGlvbigkc2NlLCAkcGFyc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgZWxlbWVudC5hZGRDbGFzcygnbmctYmluZGluZycpLmRhdGEoJyRiaW5kaW5nJywgYXR0ci5uZ0JpbmRIdG1sKTtcblxuICAgIHZhciBwYXJzZWQgPSAkcGFyc2UoYXR0ci5uZ0JpbmRIdG1sKTtcbiAgICBmdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSgpIHsgcmV0dXJuIChwYXJzZWQoc2NvcGUpIHx8ICcnKS50b1N0cmluZygpOyB9XG5cbiAgICBzY29wZS4kd2F0Y2goZ2V0U3RyaW5nVmFsdWUsIGZ1bmN0aW9uIG5nQmluZEh0bWxXYXRjaEFjdGlvbih2YWx1ZSkge1xuICAgICAgZWxlbWVudC5odG1sKCRzY2UuZ2V0VHJ1c3RlZEh0bWwocGFyc2VkKHNjb3BlKSkgfHwgJycpO1xuICAgIH0pO1xuICB9O1xufV07XG5cbmZ1bmN0aW9uIGNsYXNzRGlyZWN0aXZlKG5hbWUsIHNlbGVjdG9yKSB7XG4gIG5hbWUgPSAnbmdDbGFzcycgKyBuYW1lO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQUMnLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgICAgdmFyIG9sZFZhbDtcblxuICAgICAgICBzY29wZS4kd2F0Y2goYXR0cltuYW1lXSwgbmdDbGFzc1dhdGNoQWN0aW9uLCB0cnVlKTtcblxuICAgICAgICBhdHRyLiRvYnNlcnZlKCdjbGFzcycsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgbmdDbGFzc1dhdGNoQWN0aW9uKHNjb3BlLiRldmFsKGF0dHJbbmFtZV0pKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBpZiAobmFtZSAhPT0gJ25nQ2xhc3MnKSB7XG4gICAgICAgICAgc2NvcGUuJHdhdGNoKCckaW5kZXgnLCBmdW5jdGlvbigkaW5kZXgsIG9sZCRpbmRleCkge1xuICAgICAgICAgICAgLy8ganNoaW50IGJpdHdpc2U6IGZhbHNlXG4gICAgICAgICAgICB2YXIgbW9kID0gJGluZGV4ICYgMTtcbiAgICAgICAgICAgIGlmIChtb2QgIT09IG9sZCRpbmRleCAmIDEpIHtcbiAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBmbGF0dGVuQ2xhc3NlcyhzY29wZS4kZXZhbChhdHRyW25hbWVdKSk7XG4gICAgICAgICAgICAgIG1vZCA9PT0gc2VsZWN0b3IgP1xuICAgICAgICAgICAgICAgIGF0dHIuJGFkZENsYXNzKGNsYXNzZXMpIDpcbiAgICAgICAgICAgICAgICBhdHRyLiRyZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZnVuY3Rpb24gbmdDbGFzc1dhdGNoQWN0aW9uKG5ld1ZhbCkge1xuICAgICAgICAgIGlmIChzZWxlY3RvciA9PT0gdHJ1ZSB8fCBzY29wZS4kaW5kZXggJSAyID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIG5ld0NsYXNzZXMgPSBmbGF0dGVuQ2xhc3NlcyhuZXdWYWwgfHwgJycpO1xuICAgICAgICAgICAgaWYoIW9sZFZhbCkge1xuICAgICAgICAgICAgICBhdHRyLiRhZGRDbGFzcyhuZXdDbGFzc2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZighZXF1YWxzKG5ld1ZhbCxvbGRWYWwpKSB7XG4gICAgICAgICAgICAgIGF0dHIuJHVwZGF0ZUNsYXNzKG5ld0NsYXNzZXMsIGZsYXR0ZW5DbGFzc2VzKG9sZFZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbGRWYWwgPSBjb3B5KG5ld1ZhbCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5DbGFzc2VzKGNsYXNzVmFsKSB7XG4gICAgICAgICAgaWYoaXNBcnJheShjbGFzc1ZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFzc1ZhbC5qb2luKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChjbGFzc1ZhbCkpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW10sIGkgPSAwO1xuICAgICAgICAgICAgZm9yRWFjaChjbGFzc1ZhbCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNsYXNzVmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDbGFzc1xuICogQHJlc3RyaWN0IEFDXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nQ2xhc3NgIGRpcmVjdGl2ZSBhbGxvd3MgeW91IHRvIGR5bmFtaWNhbGx5IHNldCBDU1MgY2xhc3NlcyBvbiBhbiBIVE1MIGVsZW1lbnQgYnkgZGF0YWJpbmRpbmdcbiAqIGFuIGV4cHJlc3Npb24gdGhhdCByZXByZXNlbnRzIGFsbCBjbGFzc2VzIHRvIGJlIGFkZGVkLlxuICpcbiAqIFRoZSBkaXJlY3RpdmUgd29uJ3QgYWRkIGR1cGxpY2F0ZSBjbGFzc2VzIGlmIGEgcGFydGljdWxhciBjbGFzcyB3YXMgYWxyZWFkeSBzZXQuXG4gKlxuICogV2hlbiB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzLCB0aGUgcHJldmlvdXNseSBhZGRlZCBjbGFzc2VzIGFyZSByZW1vdmVkIGFuZCBvbmx5IHRoZW4gdGhlXG4gKiBuZXcgY2xhc3NlcyBhcmUgYWRkZWQuXG4gKlxuICogQGFuaW1hdGlvbnNcbiAqIGFkZCAtIGhhcHBlbnMganVzdCBiZWZvcmUgdGhlIGNsYXNzIGlzIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqIHJlbW92ZSAtIGhhcHBlbnMganVzdCBiZWZvcmUgdGhlIGNsYXNzIGlzIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudFxuICpcbiAqIEBlbGVtZW50IEFOWVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0NsYXNzIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWwuIFRoZSByZXN1bHRcbiAqICAgb2YgdGhlIGV2YWx1YXRpb24gY2FuIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBzcGFjZSBkZWxpbWl0ZWQgY2xhc3NcbiAqICAgbmFtZXMsIGFuIGFycmF5LCBvciBhIG1hcCBvZiBjbGFzcyBuYW1lcyB0byBib29sZWFuIHZhbHVlcy4gSW4gdGhlIGNhc2Ugb2YgYSBtYXAsIHRoZVxuICogICBuYW1lcyBvZiB0aGUgcHJvcGVydGllcyB3aG9zZSB2YWx1ZXMgYXJlIHRydXRoeSB3aWxsIGJlIGFkZGVkIGFzIGNzcyBjbGFzc2VzIHRvIHRoZVxuICogICBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlIEV4YW1wbGUgdGhhdCBkZW1vbnN0cmF0ZXMgYmFzaWMgYmluZGluZ3MgdmlhIG5nQ2xhc3MgZGlyZWN0aXZlLlxuICAgPGV4YW1wbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgPHAgbmctY2xhc3M9XCJ7c3RyaWtlOiBkZWxldGVkLCBib2xkOiBpbXBvcnRhbnQsIHJlZDogZXJyb3J9XCI+TWFwIFN5bnRheCBFeGFtcGxlPC9wPlxuICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImRlbGV0ZWRcIj4gZGVsZXRlZCAoYXBwbHkgXCJzdHJpa2VcIiBjbGFzcyk8YnI+XG4gICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiaW1wb3J0YW50XCI+IGltcG9ydGFudCAoYXBwbHkgXCJib2xkXCIgY2xhc3MpPGJyPlxuICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImVycm9yXCI+IGVycm9yIChhcHBseSBcInJlZFwiIGNsYXNzKVxuICAgICAgIDxocj5cbiAgICAgICA8cCBuZy1jbGFzcz1cInN0eWxlXCI+VXNpbmcgU3RyaW5nIFN5bnRheDwvcD5cbiAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInN0eWxlXCIgcGxhY2Vob2xkZXI9XCJUeXBlOiBib2xkIHN0cmlrZSByZWRcIj5cbiAgICAgICA8aHI+XG4gICAgICAgPHAgbmctY2xhc3M9XCJbc3R5bGUxLCBzdHlsZTIsIHN0eWxlM11cIj5Vc2luZyBBcnJheSBTeW50YXg8L3A+XG4gICAgICAgPGlucHV0IG5nLW1vZGVsPVwic3R5bGUxXCIgcGxhY2Vob2xkZXI9XCJUeXBlOiBib2xkLCBzdHJpa2Ugb3IgcmVkXCI+PGJyPlxuICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInN0eWxlMlwiIHBsYWNlaG9sZGVyPVwiVHlwZTogYm9sZCwgc3RyaWtlIG9yIHJlZFwiPjxicj5cbiAgICAgICA8aW5wdXQgbmctbW9kZWw9XCJzdHlsZTNcIiBwbGFjZWhvbGRlcj1cIlR5cGU6IGJvbGQsIHN0cmlrZSBvciByZWRcIj48YnI+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxuICAgICAgIC5zdHJpa2Uge1xuICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XG4gICAgICAgfVxuICAgICAgIC5ib2xkIHtcbiAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgfVxuICAgICAgIC5yZWQge1xuICAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgIH1cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cbiAgICAgICBpdCgnc2hvdWxkIGxldCB5b3UgdG9nZ2xlIHRoZSBjbGFzcycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS5ub3QoKS50b01hdGNoKC9ib2xkLyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS5ub3QoKS50b01hdGNoKC9yZWQvKTtcblxuICAgICAgICAgaW5wdXQoJ2ltcG9ydGFudCcpLmNoZWNrKCk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS50b01hdGNoKC9ib2xkLyk7XG5cbiAgICAgICAgIGlucHV0KCdlcnJvcicpLmNoZWNrKCk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgcDpmaXJzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS50b01hdGNoKC9yZWQvKTtcbiAgICAgICB9KTtcblxuICAgICAgIGl0KCdzaG91bGQgbGV0IHlvdSB0b2dnbGUgc3RyaW5nIGV4YW1wbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOm50aC1vZi10eXBlKDIpJykucHJvcCgnY2xhc3NOYW1lJykpLnRvQmUoJycpO1xuICAgICAgICAgaW5wdXQoJ3N0eWxlJykuZW50ZXIoJ3JlZCcpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6bnRoLW9mLXR5cGUoMiknKS5wcm9wKCdjbGFzc05hbWUnKSkudG9CZSgncmVkJyk7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnYXJyYXkgZXhhbXBsZSBzaG91bGQgaGF2ZSAzIGNsYXNzZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBwOmxhc3QnKS5wcm9wKCdjbGFzc05hbWUnKSkudG9CZSgnJyk7XG4gICAgICAgICBpbnB1dCgnc3R5bGUxJykuZW50ZXIoJ2JvbGQnKTtcbiAgICAgICAgIGlucHV0KCdzdHlsZTInKS5lbnRlcignc3RyaWtlJyk7XG4gICAgICAgICBpbnB1dCgnc3R5bGUzJykuZW50ZXIoJ3JlZCcpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHA6bGFzdCcpLnByb3AoJ2NsYXNzTmFtZScpKS50b0JlKCdib2xkIHN0cmlrZSByZWQnKTtcbiAgICAgICB9KTtcbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuXG4gICAjIyBBbmltYXRpb25zXG5cbiAgIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBob3cgdG8gcGVyZm9ybSBhbmltYXRpb25zIHVzaW5nIG5nQ2xhc3MuXG5cbiAgIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwic2V0XCIgbmctY2xpY2s9XCJteVZhcj0nbXktY2xhc3MnXCI+XG4gICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwiY2xlYXJcIiBuZy1jbGljaz1cIm15VmFyPScnXCI+XG4gICAgICA8YnI+XG4gICAgICA8c3BhbiBjbGFzcz1cImJhc2UtY2xhc3NcIiBuZy1jbGFzcz1cIm15VmFyXCI+U2FtcGxlIFRleHQ8L3NwYW4+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxuICAgICAgIC5iYXNlLWNsYXNzIHtcbiAgICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xuICAgICAgICAgdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xuICAgICAgIH1cblxuICAgICAgIC5iYXNlLWNsYXNzLm15LWNsYXNzIHtcbiAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICBmb250LXNpemU6M2VtO1xuICAgICAgIH1cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLWNsYXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5ub3QoKS5cbiAgICAgICAgICAgdG9NYXRjaCgvbXktY2xhc3MvKTtcblxuICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuZWxlbWVudCgnOmJ1dHRvbjpmaXJzdCcpLmNsaWNrKCk7XG5cbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuJykucHJvcCgnY2xhc3NOYW1lJykpLlxuICAgICAgICAgICB0b01hdGNoKC9teS1jbGFzcy8pO1xuXG4gICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5lbGVtZW50KCc6YnV0dG9uOmxhc3QnKS5jbGljaygpO1xuXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5ub3QoKS5cbiAgICAgICAgICAgdG9NYXRjaCgvbXktY2xhc3MvKTtcbiAgICAgICB9KTtcbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuXG5cbiAgICMjIG5nQ2xhc3MgYW5kIHByZS1leGlzdGluZyBDU1MzIFRyYW5zaXRpb25zL0FuaW1hdGlvbnNcbiAgIFRoZSBuZ0NsYXNzIGRpcmVjdGl2ZSBzdGlsbCBzdXBwb3J0cyBDU1MzIFRyYW5zaXRpb25zL0FuaW1hdGlvbnMgZXZlbiBpZiB0aGV5IGRvIG5vdCBmb2xsb3cgdGhlIG5nQW5pbWF0ZSBDU1MgbmFtaW5nIHN0cnVjdHVyZS5cbiAgIFVwb24gYW5pbWF0aW9uIG5nQW5pbWF0ZSB3aWxsIGFwcGx5IHN1cHBsZW1lbnRhcnkgQ1NTIGNsYXNzZXMgdG8gdHJhY2sgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYW4gYW5pbWF0aW9uLCBidXQgdGhpcyB3aWxsIG5vdCBoaW5kZXJcbiAgIGFueSBwcmUtZXhpc3RpbmcgQ1NTIHRyYW5zaXRpb25zIGFscmVhZHkgb24gdGhlIGVsZW1lbnQuIFRvIGdldCBhbiBpZGVhIG9mIHdoYXQgaGFwcGVucyBkdXJpbmcgYSBjbGFzcy1iYXNlZCBhbmltYXRpb24sIGJlIHN1cmVcbiAgIHRvIHZpZXcgdGhlIHN0ZXAgYnkgc3RlcCBkZXRhaWxzIG9mIHtAbGluayBuZ0FuaW1hdGUuJGFuaW1hdGUjbWV0aG9kc19hZGRjbGFzcyAkYW5pbWF0ZS5hZGRDbGFzc30gYW5kXG4gICB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlI21ldGhvZHNfcmVtb3ZlY2xhc3MgJGFuaW1hdGUucmVtb3ZlQ2xhc3N9LlxuICovXG52YXIgbmdDbGFzc0RpcmVjdGl2ZSA9IGNsYXNzRGlyZWN0aXZlKCcnLCB0cnVlKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDbGFzc09kZFxuICogQHJlc3RyaWN0IEFDXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nQ2xhc3NPZGRgIGFuZCBgbmdDbGFzc0V2ZW5gIGRpcmVjdGl2ZXMgd29yayBleGFjdGx5IGFzXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ2xhc3MgbmdDbGFzc30sIGV4Y2VwdCB0aGV5IHdvcmsgaW5cbiAqIGNvbmp1bmN0aW9uIHdpdGggYG5nUmVwZWF0YCBhbmQgdGFrZSBlZmZlY3Qgb25seSBvbiBvZGQgKGV2ZW4pIHJvd3MuXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIGFwcGxpZWQgb25seSB3aXRoaW4gdGhlIHNjb3BlIG9mIGFuXG4gKiB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nUmVwZWF0IG5nUmVwZWF0fS5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDbGFzc09kZCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLiBUaGUgcmVzdWx0XG4gKiAgIG9mIHRoZSBldmFsdWF0aW9uIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIG9yIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZT5cbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgICAgPG9sIG5nLWluaXQ9XCJuYW1lcz1bJ0pvaG4nLCAnTWFyeScsICdDYXRlJywgJ1N1eiddXCI+XG4gICAgICAgICAgPGxpIG5nLXJlcGVhdD1cIm5hbWUgaW4gbmFtZXNcIj5cbiAgICAgICAgICAgPHNwYW4gbmctY2xhc3Mtb2RkPVwiJ29kZCdcIiBuZy1jbGFzcy1ldmVuPVwiJ2V2ZW4nXCI+XG4gICAgICAgICAgICAge3tuYW1lfX1cbiAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvb2w+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxuICAgICAgIC5vZGQge1xuICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICB9XG4gICAgICAgLmV2ZW4ge1xuICAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgICAgfVxuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctY2xhc3Mtb2RkIGFuZCBuZy1jbGFzcy1ldmVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbGk6Zmlyc3Qgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5cbiAgICAgICAgICAgdG9NYXRjaCgvb2RkLyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbGk6bGFzdCBzcGFuJykucHJvcCgnY2xhc3NOYW1lJykpLlxuICAgICAgICAgICB0b01hdGNoKC9ldmVuLyk7XG4gICAgICAgfSk7XG4gICAgIDwvZmlsZT5cbiAgIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nQ2xhc3NPZGREaXJlY3RpdmUgPSBjbGFzc0RpcmVjdGl2ZSgnT2RkJywgMCk7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ2xhc3NFdmVuXG4gKiBAcmVzdHJpY3QgQUNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgbmdDbGFzc09kZGAgYW5kIGBuZ0NsYXNzRXZlbmAgZGlyZWN0aXZlcyB3b3JrIGV4YWN0bHkgYXNcbiAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGFzcyBuZ0NsYXNzfSwgZXhjZXB0IHRoZXkgd29yayBpblxuICogY29uanVuY3Rpb24gd2l0aCBgbmdSZXBlYXRgIGFuZCB0YWtlIGVmZmVjdCBvbmx5IG9uIG9kZCAoZXZlbikgcm93cy5cbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgYXBwbGllZCBvbmx5IHdpdGhpbiB0aGUgc2NvcGUgb2YgYW5cbiAqIHtAbGluayBuZy5kaXJlY3RpdmU6bmdSZXBlYXQgbmdSZXBlYXR9LlxuICpcbiAqIEBlbGVtZW50IEFOWVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0NsYXNzRXZlbiB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLiBUaGVcbiAqICAgcmVzdWx0IG9mIHRoZSBldmFsdWF0aW9uIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIG9yIGFuIGFycmF5LlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZXhhbXBsZT5cbiAgICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgICAgPG9sIG5nLWluaXQ9XCJuYW1lcz1bJ0pvaG4nLCAnTWFyeScsICdDYXRlJywgJ1N1eiddXCI+XG4gICAgICAgICAgPGxpIG5nLXJlcGVhdD1cIm5hbWUgaW4gbmFtZXNcIj5cbiAgICAgICAgICAgPHNwYW4gbmctY2xhc3Mtb2RkPVwiJ29kZCdcIiBuZy1jbGFzcy1ldmVuPVwiJ2V2ZW4nXCI+XG4gICAgICAgICAgICAge3tuYW1lfX0gJm5ic3A7ICZuYnNwOyAmbmJzcDtcbiAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvb2w+XG4gICAgIDwvZmlsZT5cbiAgICAgPGZpbGUgbmFtZT1cInN0eWxlLmNzc1wiPlxuICAgICAgIC5vZGQge1xuICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICB9XG4gICAgICAgLmV2ZW4ge1xuICAgICAgICAgY29sb3I6IGJsdWU7XG4gICAgICAgfVxuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctY2xhc3Mtb2RkIGFuZCBuZy1jbGFzcy1ldmVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbGk6Zmlyc3Qgc3BhbicpLnByb3AoJ2NsYXNzTmFtZScpKS5cbiAgICAgICAgICAgdG9NYXRjaCgvb2RkLyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbGk6bGFzdCBzcGFuJykucHJvcCgnY2xhc3NOYW1lJykpLlxuICAgICAgICAgICB0b01hdGNoKC9ldmVuLyk7XG4gICAgICAgfSk7XG4gICAgIDwvZmlsZT5cbiAgIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nQ2xhc3NFdmVuRGlyZWN0aXZlID0gY2xhc3NEaXJlY3RpdmUoJ0V2ZW4nLCAxKTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdDbG9ha1xuICogQHJlc3RyaWN0IEFDXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nQ2xvYWtgIGRpcmVjdGl2ZSBpcyB1c2VkIHRvIHByZXZlbnQgdGhlIEFuZ3VsYXIgaHRtbCB0ZW1wbGF0ZSBmcm9tIGJlaW5nIGJyaWVmbHlcbiAqIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciBpbiBpdHMgcmF3ICh1bmNvbXBpbGVkKSBmb3JtIHdoaWxlIHlvdXIgYXBwbGljYXRpb24gaXMgbG9hZGluZy4gVXNlIHRoaXNcbiAqIGRpcmVjdGl2ZSB0byBhdm9pZCB0aGUgdW5kZXNpcmFibGUgZmxpY2tlciBlZmZlY3QgY2F1c2VkIGJ5IHRoZSBodG1sIHRlbXBsYXRlIGRpc3BsYXkuXG4gKlxuICogVGhlIGRpcmVjdGl2ZSBjYW4gYmUgYXBwbGllZCB0byB0aGUgYDxib2R5PmAgZWxlbWVudCwgYnV0IHRoZSBwcmVmZXJyZWQgdXNhZ2UgaXMgdG8gYXBwbHlcbiAqIG11bHRpcGxlIGBuZ0Nsb2FrYCBkaXJlY3RpdmVzIHRvIHNtYWxsIHBvcnRpb25zIG9mIHRoZSBwYWdlIHRvIHBlcm1pdCBwcm9ncmVzc2l2ZSByZW5kZXJpbmdcbiAqIG9mIHRoZSBicm93c2VyIHZpZXcuXG4gKlxuICogYG5nQ2xvYWtgIHdvcmtzIGluIGNvb3BlcmF0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBjc3MgcnVsZSBlbWJlZGRlZCB3aXRoaW4gYGFuZ3VsYXIuanNgIGFuZFxuICogYGFuZ3VsYXIubWluLmpzYC5cbiAqIEZvciBDU1AgbW9kZSBwbGVhc2UgYWRkIGBhbmd1bGFyLWNzcC5jc3NgIHRvIHlvdXIgaHRtbCBmaWxlIChzZWUge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0NzcCBuZ0NzcH0pLlxuICpcbiAqIDxwcmU+XG4gKiBbbmdcXDpjbG9ha10sIFtuZy1jbG9ha10sIFtkYXRhLW5nLWNsb2FrXSwgW3gtbmctY2xvYWtdLCAubmctY2xvYWssIC54LW5nLWNsb2FrIHtcbiAqICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICogfVxuICogPC9wcmU+XG4gKlxuICogV2hlbiB0aGlzIGNzcyBydWxlIGlzIGxvYWRlZCBieSB0aGUgYnJvd3NlciwgYWxsIGh0bWwgZWxlbWVudHMgKGluY2x1ZGluZyB0aGVpciBjaGlsZHJlbikgdGhhdFxuICogYXJlIHRhZ2dlZCB3aXRoIHRoZSBgbmdDbG9ha2AgZGlyZWN0aXZlIGFyZSBoaWRkZW4uIFdoZW4gQW5ndWxhciBlbmNvdW50ZXJzIHRoaXMgZGlyZWN0aXZlXG4gKiBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uIG9mIHRoZSB0ZW1wbGF0ZSBpdCBkZWxldGVzIHRoZSBgbmdDbG9ha2AgZWxlbWVudCBhdHRyaWJ1dGUsIG1ha2luZ1xuICogdGhlIGNvbXBpbGVkIGVsZW1lbnQgdmlzaWJsZS5cbiAqXG4gKiBGb3IgdGhlIGJlc3QgcmVzdWx0LCB0aGUgYGFuZ3VsYXIuanNgIHNjcmlwdCBtdXN0IGJlIGxvYWRlZCBpbiB0aGUgaGVhZCBzZWN0aW9uIG9mIHRoZSBodG1sXG4gKiBkb2N1bWVudDsgYWx0ZXJuYXRpdmVseSwgdGhlIGNzcyBydWxlIGFib3ZlIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIGV4dGVybmFsIHN0eWxlc2hlZXQgb2YgdGhlXG4gKiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBMZWdhY3kgYnJvd3NlcnMsIGxpa2UgSUU3LCBkbyBub3QgcHJvdmlkZSBhdHRyaWJ1dGUgc2VsZWN0b3Igc3VwcG9ydCAoYWRkZWQgaW4gQ1NTIDIuMSkgc28gdGhleVxuICogY2Fubm90IG1hdGNoIHRoZSBgW25nXFw6Y2xvYWtdYCBzZWxlY3Rvci4gVG8gd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLCB5b3UgbXVzdCBhZGQgdGhlIGNzc1xuICogY2xhc3MgYG5nLWNsb2FrYCBpbiBhZGRpdGlvbiB0byB0aGUgYG5nQ2xvYWtgIGRpcmVjdGl2ZSBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgPGRpdiBpZD1cInRlbXBsYXRlMVwiIG5nLWNsb2FrPnt7ICdoZWxsbycgfX08L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInRlbXBsYXRlMlwiIG5nLWNsb2FrIGNsYXNzPVwibmctY2xvYWtcIj57eyAnaGVsbG8gSUU3JyB9fTwvZGl2PlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCByZW1vdmUgdGhlIHRlbXBsYXRlIGRpcmVjdGl2ZSBhbmQgY3NzIGNsYXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI3RlbXBsYXRlMScpLmF0dHIoJ25nLWNsb2FrJykpLlxuICAgICAgICAgICBub3QoKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlICN0ZW1wbGF0ZTInKS5hdHRyKCduZy1jbG9haycpKS5cbiAgICAgICAgICAgbm90KCkudG9CZURlZmluZWQoKTtcbiAgICAgICB9KTtcbiAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICA8L2RvYzpleGFtcGxlPlxuICpcbiAqL1xudmFyIG5nQ2xvYWtEaXJlY3RpdmUgPSBuZ0RpcmVjdGl2ZSh7XG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICBhdHRyLiRzZXQoJ25nQ2xvYWsnLCB1bmRlZmluZWQpO1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ25nLWNsb2FrJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NvbnRyb2xsZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgbmdDb250cm9sbGVyYCBkaXJlY3RpdmUgYXR0YWNoZXMgYSBjb250cm9sbGVyIGNsYXNzIHRvIHRoZSB2aWV3LiBUaGlzIGlzIGEga2V5IGFzcGVjdCBvZiBob3cgYW5ndWxhclxuICogc3VwcG9ydHMgdGhlIHByaW5jaXBsZXMgYmVoaW5kIHRoZSBNb2RlbC1WaWV3LUNvbnRyb2xsZXIgZGVzaWduIHBhdHRlcm4uXG4gKlxuICogTVZDIGNvbXBvbmVudHMgaW4gYW5ndWxhcjpcbiAqXG4gKiAqIE1vZGVsIOKAlCBUaGUgTW9kZWwgaXMgc2NvcGUgcHJvcGVydGllczsgc2NvcGVzIGFyZSBhdHRhY2hlZCB0byB0aGUgRE9NIHdoZXJlIHNjb3BlIHByb3BlcnRpZXNcbiAqICAgYXJlIGFjY2Vzc2VkIHRocm91Z2ggYmluZGluZ3MuXG4gKiAqIFZpZXcg4oCUIFRoZSB0ZW1wbGF0ZSAoSFRNTCB3aXRoIGRhdGEgYmluZGluZ3MpIHRoYXQgaXMgcmVuZGVyZWQgaW50byB0aGUgVmlldy5cbiAqICogQ29udHJvbGxlciDigJQgVGhlIGBuZ0NvbnRyb2xsZXJgIGRpcmVjdGl2ZSBzcGVjaWZpZXMgYSBDb250cm9sbGVyIGNsYXNzOyB0aGUgY2xhc3MgY29udGFpbnMgYnVzaW5lc3NcbiAqICAgbG9naWMgYmVoaW5kIHRoZSBhcHBsaWNhdGlvbiB0byBkZWNvcmF0ZSB0aGUgc2NvcGUgd2l0aCBmdW5jdGlvbnMgYW5kIHZhbHVlc1xuICpcbiAqIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gYXR0YWNoIGNvbnRyb2xsZXJzIHRvIHRoZSBET00gYnkgZGVjbGFyaW5nIGl0IGluIGEgcm91dGUgZGVmaW5pdGlvblxuICogdmlhIHRoZSB7QGxpbmsgbmdSb3V0ZS4kcm91dGUgJHJvdXRlfSBzZXJ2aWNlLiBBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIGRlY2xhcmUgdGhlIGNvbnRyb2xsZXJcbiAqIGFnYWluIHVzaW5nIGBuZy1jb250cm9sbGVyYCBpbiB0aGUgdGVtcGxhdGUgaXRzZWxmLiAgVGhpcyB3aWxsIGNhdXNlIHRoZSBjb250cm9sbGVyIHRvIGJlIGF0dGFjaGVkXG4gKiBhbmQgZXhlY3V0ZWQgdHdpY2UuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAc2NvcGVcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDb250cm9sbGVyIE5hbWUgb2YgYSBnbG9iYWxseSBhY2Nlc3NpYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9yIGFuXG4gKiAgICAge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gZXhwcmVzc2lvbn0gdGhhdCBvbiB0aGUgY3VycmVudCBzY29wZSBldmFsdWF0ZXMgdG8gYVxuICogICAgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBUaGUgY29udHJvbGxlciBpbnN0YW5jZSBjYW4gYmUgcHVibGlzaGVkIGludG8gYSBzY29wZSBwcm9wZXJ0eVxuICogICAgIGJ5IHNwZWNpZnlpbmcgYGFzIHByb3BlcnR5TmFtZWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIEhlcmUgaXMgYSBzaW1wbGUgZm9ybSBmb3IgZWRpdGluZyB1c2VyIGNvbnRhY3QgaW5mb3JtYXRpb24uIEFkZGluZywgcmVtb3ZpbmcsIGNsZWFyaW5nLCBhbmRcbiAqIGdyZWV0aW5nIGFyZSBtZXRob2RzIGRlY2xhcmVkIG9uIHRoZSBjb250cm9sbGVyIChzZWUgc291cmNlIHRhYikuIFRoZXNlIG1ldGhvZHMgY2FuXG4gKiBlYXNpbHkgYmUgY2FsbGVkIGZyb20gdGhlIGFuZ3VsYXIgbWFya3VwLiBOb3RpY2UgdGhhdCB0aGUgc2NvcGUgYmVjb21lcyB0aGUgYHRoaXNgIGZvciB0aGVcbiAqIGNvbnRyb2xsZXIncyBpbnN0YW5jZS4gVGhpcyBhbGxvd3MgZm9yIGVhc3kgYWNjZXNzIHRvIHRoZSB2aWV3IGRhdGEgZnJvbSB0aGUgY29udHJvbGxlci4gQWxzb1xuICogbm90aWNlIHRoYXQgYW55IGNoYW5nZXMgdG8gdGhlIGRhdGEgYXJlIGF1dG9tYXRpY2FsbHkgcmVmbGVjdGVkIGluIHRoZSBWaWV3IHdpdGhvdXQgdGhlIG5lZWRcbiAqIGZvciBhIG1hbnVhbCB1cGRhdGUuIFRoZSBleGFtcGxlIGlzIHNob3duIGluIHR3byBkaWZmZXJlbnQgZGVjbGFyYXRpb24gc3R5bGVzIHlvdSBtYXkgdXNlXG4gKiBhY2NvcmRpbmcgdG8gcHJlZmVyZW5jZS5cbiAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICA8c2NyaXB0PlxuICAgICAgICBmdW5jdGlvbiBTZXR0aW5nc0NvbnRyb2xsZXIxKCkge1xuICAgICAgICAgIHRoaXMubmFtZSA9IFwiSm9obiBTbWl0aFwiO1xuICAgICAgICAgIHRoaXMuY29udGFjdHMgPSBbXG4gICAgICAgICAgICB7dHlwZTogJ3Bob25lJywgdmFsdWU6ICc0MDggNTU1IDEyMTInfSxcbiAgICAgICAgICAgIHt0eXBlOiAnZW1haWwnLCB2YWx1ZTogJ2pvaG4uc21pdGhAZXhhbXBsZS5vcmcnfSBdO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgU2V0dGluZ3NDb250cm9sbGVyMS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhbGVydCh0aGlzLm5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNldHRpbmdzQ29udHJvbGxlcjEucHJvdG90eXBlLmFkZENvbnRhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNvbnRhY3RzLnB1c2goe3R5cGU6ICdlbWFpbCcsIHZhbHVlOiAneW91cm5hbWVAZXhhbXBsZS5vcmcnfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgU2V0dGluZ3NDb250cm9sbGVyMS5wcm90b3R5cGUucmVtb3ZlQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3RUb1JlbW92ZSkge1xuICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250YWN0cy5pbmRleE9mKGNvbnRhY3RUb1JlbW92ZSk7XG4gICAgICAgICAgdGhpcy5jb250YWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFNldHRpbmdzQ29udHJvbGxlcjEucHJvdG90eXBlLmNsZWFyQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3QpIHtcbiAgICAgICAgICBjb250YWN0LnR5cGUgPSAncGhvbmUnO1xuICAgICAgICAgIGNvbnRhY3QudmFsdWUgPSAnJztcbiAgICAgICAgfTtcbiAgICAgIDwvc2NyaXB0PlxuICAgICAgPGRpdiBpZD1cImN0cmwtYXMtZXhtcGxcIiBuZy1jb250cm9sbGVyPVwiU2V0dGluZ3NDb250cm9sbGVyMSBhcyBzZXR0aW5nc1wiPlxuICAgICAgICBOYW1lOiA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInNldHRpbmdzLm5hbWVcIi8+XG4gICAgICAgIFsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwic2V0dGluZ3MuZ3JlZXQoKVwiPmdyZWV0PC9hPiBdPGJyLz5cbiAgICAgICAgQ29udGFjdDpcbiAgICAgICAgPHVsPlxuICAgICAgICAgIDxsaSBuZy1yZXBlYXQ9XCJjb250YWN0IGluIHNldHRpbmdzLmNvbnRhY3RzXCI+XG4gICAgICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVwiY29udGFjdC50eXBlXCI+XG4gICAgICAgICAgICAgICA8b3B0aW9uPnBob25lPC9vcHRpb24+XG4gICAgICAgICAgICAgICA8b3B0aW9uPmVtYWlsPC9vcHRpb24+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwiY29udGFjdC52YWx1ZVwiLz5cbiAgICAgICAgICAgIFsgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwic2V0dGluZ3MuY2xlYXJDb250YWN0KGNvbnRhY3QpXCI+Y2xlYXI8L2E+XG4gICAgICAgICAgICB8IDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cInNldHRpbmdzLnJlbW92ZUNvbnRhY3QoY29udGFjdClcIj5YPC9hPiBdXG4gICAgICAgICAgPC9saT5cbiAgICAgICAgICA8bGk+WyA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJzZXR0aW5ncy5hZGRDb250YWN0KClcIj5hZGQ8L2E+IF08L2xpPlxuICAgICAgIDwvdWw+XG4gICAgICA8L2Rpdj5cbiAgICAgPC9kb2M6c291cmNlPlxuICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgY29udHJvbGxlciBhcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWFzLWV4bXBsPjppbnB1dCcpLnZhbCgpKS50b0JlKCdKb2huIFNtaXRoJyk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6bnRoLWNoaWxkKDEpIGlucHV0JykudmFsKCkpXG4gICAgICAgICAgIC50b0JlKCc0MDggNTU1IDEyMTInKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpudGgtY2hpbGQoMikgaW5wdXQnKS52YWwoKSlcbiAgICAgICAgICAgLnRvQmUoJ2pvaG4uc21pdGhAZXhhbXBsZS5vcmcnKTtcblxuICAgICAgICAgZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6Zmlyc3QgYTpjb250YWlucyhcImNsZWFyXCIpJykuY2xpY2soKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpmaXJzdCBpbnB1dCcpLnZhbCgpKS50b0JlKCcnKTtcblxuICAgICAgICAgZWxlbWVudCgnI2N0cmwtYXMtZXhtcGwgbGk6bGFzdCBhOmNvbnRhaW5zKFwiYWRkXCIpJykuY2xpY2soKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1hcy1leG1wbCBsaTpudGgtY2hpbGQoMykgaW5wdXQnKS52YWwoKSlcbiAgICAgICAgICAgLnRvQmUoJ3lvdXJuYW1lQGV4YW1wbGUub3JnJyk7XG4gICAgICAgfSk7XG4gICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgPHNjcmlwdD5cbiAgICAgICAgZnVuY3Rpb24gU2V0dGluZ3NDb250cm9sbGVyMigkc2NvcGUpIHtcbiAgICAgICAgICAkc2NvcGUubmFtZSA9IFwiSm9obiBTbWl0aFwiO1xuICAgICAgICAgICRzY29wZS5jb250YWN0cyA9IFtcbiAgICAgICAgICAgIHt0eXBlOidwaG9uZScsIHZhbHVlOic0MDggNTU1IDEyMTInfSxcbiAgICAgICAgICAgIHt0eXBlOidlbWFpbCcsIHZhbHVlOidqb2huLnNtaXRoQGV4YW1wbGUub3JnJ30gXTtcblxuICAgICAgICAgICRzY29wZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBhbGVydCh0aGlzLm5hbWUpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUuYWRkQ29udGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLmNvbnRhY3RzLnB1c2goe3R5cGU6J2VtYWlsJywgdmFsdWU6J3lvdXJuYW1lQGV4YW1wbGUub3JnJ30pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUucmVtb3ZlQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3RUb1JlbW92ZSkge1xuICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRhY3RzLmluZGV4T2YoY29udGFjdFRvUmVtb3ZlKTtcbiAgICAgICAgICAgdGhpcy5jb250YWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUuY2xlYXJDb250YWN0ID0gZnVuY3Rpb24oY29udGFjdCkge1xuICAgICAgICAgICBjb250YWN0LnR5cGUgPSAncGhvbmUnO1xuICAgICAgICAgICBjb250YWN0LnZhbHVlID0gJyc7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgPC9zY3JpcHQ+XG4gICAgICA8ZGl2IGlkPVwiY3RybC1leG1wbFwiIG5nLWNvbnRyb2xsZXI9XCJTZXR0aW5nc0NvbnRyb2xsZXIyXCI+XG4gICAgICAgIE5hbWU6IDxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwibmFtZVwiLz5cbiAgICAgICAgWyA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJncmVldCgpXCI+Z3JlZXQ8L2E+IF08YnIvPlxuICAgICAgICBDb250YWN0OlxuICAgICAgICA8dWw+XG4gICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAgICAgICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJjb250YWN0LnR5cGVcIj5cbiAgICAgICAgICAgICAgIDxvcHRpb24+cGhvbmU8L29wdGlvbj5cbiAgICAgICAgICAgICAgIDxvcHRpb24+ZW1haWw8L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJjb250YWN0LnZhbHVlXCIvPlxuICAgICAgICAgICAgWyA8YSBocmVmPVwiXCIgbmctY2xpY2s9XCJjbGVhckNvbnRhY3QoY29udGFjdClcIj5jbGVhcjwvYT5cbiAgICAgICAgICAgIHwgPGEgaHJlZj1cIlwiIG5nLWNsaWNrPVwicmVtb3ZlQ29udGFjdChjb250YWN0KVwiPlg8L2E+IF1cbiAgICAgICAgICA8L2xpPlxuICAgICAgICAgIDxsaT5bIDxhIGhyZWY9XCJcIiBuZy1jbGljaz1cImFkZENvbnRhY3QoKVwiPmFkZDwvYT4gXTwvbGk+XG4gICAgICAgPC91bD5cbiAgICAgIDwvZGl2PlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBjb250cm9sbGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnI2N0cmwtZXhtcGw+OmlucHV0JykudmFsKCkpLnRvQmUoJ0pvaG4gU21pdGgnKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcjY3RybC1leG1wbCBsaTpudGgtY2hpbGQoMSkgaW5wdXQnKS52YWwoKSlcbiAgICAgICAgICAgLnRvQmUoJzQwOCA1NTUgMTIxMicpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOm50aC1jaGlsZCgyKSBpbnB1dCcpLnZhbCgpKVxuICAgICAgICAgICAudG9CZSgnam9obi5zbWl0aEBleGFtcGxlLm9yZycpO1xuXG4gICAgICAgICBlbGVtZW50KCcjY3RybC1leG1wbCBsaTpmaXJzdCBhOmNvbnRhaW5zKFwiY2xlYXJcIiknKS5jbGljaygpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOmZpcnN0IGlucHV0JykudmFsKCkpLnRvQmUoJycpO1xuXG4gICAgICAgICBlbGVtZW50KCcjY3RybC1leG1wbCBsaTpsYXN0IGE6Y29udGFpbnMoXCJhZGRcIiknKS5jbGljaygpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJyNjdHJsLWV4bXBsIGxpOm50aC1jaGlsZCgzKSBpbnB1dCcpLnZhbCgpKVxuICAgICAgICAgICAudG9CZSgneW91cm5hbWVAZXhhbXBsZS5vcmcnKTtcbiAgICAgICB9KTtcbiAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICA8L2RvYzpleGFtcGxlPlxuXG4gKi9cbnZhciBuZ0NvbnRyb2xsZXJEaXJlY3RpdmUgPSBbZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgc2NvcGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ0AnLFxuICAgIHByaW9yaXR5OiA1MDBcbiAgfTtcbn1dO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NzcFxuICpcbiAqIEBlbGVtZW50IGh0bWxcbiAqIEBkZXNjcmlwdGlvblxuICogRW5hYmxlcyBbQ1NQIChDb250ZW50IFNlY3VyaXR5IFBvbGljeSldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NlY3VyaXR5L0NTUCkgc3VwcG9ydC5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB3aGVuIGRldmVsb3BpbmcgdGhpbmdzIGxpa2UgR29vZ2xlIENocm9tZSBFeHRlbnNpb25zLlxuICpcbiAqIENTUCBmb3JiaWRzIGFwcHMgdG8gdXNlIGBldmFsYCBvciBgRnVuY3Rpb24oc3RyaW5nKWAgZ2VuZXJhdGVkIGZ1bmN0aW9ucyAoYW1vbmcgb3RoZXIgdGhpbmdzKS5cbiAqIEZvciB1cyB0byBiZSBjb21wYXRpYmxlLCB3ZSBqdXN0IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBcImdldHRlckZuXCIgaW4gJHBhcnNlIHdpdGhvdXQgdmlvbGF0aW5nXG4gKiBhbnkgb2YgdGhlc2UgcmVzdHJpY3Rpb25zLlxuICpcbiAqIEFuZ3VsYXJKUyB1c2VzIGBGdW5jdGlvbihzdHJpbmcpYCBnZW5lcmF0ZWQgZnVuY3Rpb25zIGFzIGEgc3BlZWQgb3B0aW1pemF0aW9uLiBBcHBseWluZyB0aGUgYG5nQ3NwYFxuICogZGlyZWN0aXZlIHdpbGwgY2F1c2UgQW5ndWxhciB0byB1c2UgQ1NQIGNvbXBhdGliaWxpdHkgbW9kZS4gV2hlbiB0aGlzIG1vZGUgaXMgb24gQW5ndWxhckpTIHdpbGxcbiAqIGV2YWx1YXRlIGFsbCBleHByZXNzaW9ucyB1cCB0byAzMCUgc2xvd2VyIHRoYW4gaW4gbm9uLUNTUCBtb2RlLCBidXQgbm8gc2VjdXJpdHkgdmlvbGF0aW9ucyB3aWxsXG4gKiBiZSByYWlzZWQuXG4gKlxuICogQ1NQIGZvcmJpZHMgSmF2YVNjcmlwdCB0byBpbmxpbmUgc3R5bGVzaGVldCBydWxlcy4gSW4gbm9uIENTUCBtb2RlIEFuZ3VsYXIgYXV0b21hdGljYWxseVxuICogaW5jbHVkZXMgc29tZSBDU1MgcnVsZXMgKGUuZy4ge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0Nsb2FrIG5nQ2xvYWt9KS5cbiAqIFRvIG1ha2UgdGhvc2UgZGlyZWN0aXZlcyB3b3JrIGluIENTUCBtb2RlLCBpbmNsdWRlIHRoZSBgYW5ndWxhci1jc3AuY3NzYCBtYW51YWxseS5cbiAqXG4gKiBJbiBvcmRlciB0byB1c2UgdGhpcyBmZWF0dXJlIHB1dCB0aGUgYG5nQ3NwYCBkaXJlY3RpdmUgb24gdGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogKk5vdGU6IFRoaXMgZGlyZWN0aXZlIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBgbmctY3NwYCBhbmQgYGRhdGEtbmctY3NwYCBhdHRyaWJ1dGUgZm9ybS4qXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoaXMgZXhhbXBsZSBzaG93cyBob3cgdG8gYXBwbHkgdGhlIGBuZ0NzcGAgZGlyZWN0aXZlIHRvIHRoZSBgaHRtbGAgdGFnLlxuICAgPHByZT5cbiAgICAgPCFkb2N0eXBlIGh0bWw+XG4gICAgIDxodG1sIG5nLWFwcCBuZy1jc3A+XG4gICAgIC4uLlxuICAgICAuLi5cbiAgICAgPC9odG1sPlxuICAgPC9wcmU+XG4gKi9cblxuLy8gbmdDc3AgaXMgbm90IGltcGxlbWVudGVkIGFzIGEgcHJvcGVyIGRpcmVjdGl2ZSBhbnkgbW9yZSwgYmVjYXVzZSB3ZSBuZWVkIGl0IGJlIHByb2Nlc3NlZCB3aGlsZSB3ZSBib290c3RyYXBcbi8vIHRoZSBzeXN0ZW0gKGJlZm9yZSAkcGFyc2UgaXMgaW5zdGFudGlhdGVkKSwgZm9yIHRoaXMgcmVhc29uIHdlIGp1c3QgaGF2ZSBhIGNzcCgpIGZuIHRoYXQgbG9va3MgZm9yIG5nLWNzcCBhdHRyaWJ1dGVcbi8vIGFueXdoZXJlIGluIHRoZSBjdXJyZW50IGRvY1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0NsaWNrXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgbmdDbGljayBkaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciB3aGVuXG4gKiBhbiBlbGVtZW50IGlzIGNsaWNrZWQuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ2xpY2sge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxuICogY2xpY2suIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgPGJ1dHRvbiBuZy1jbGljaz1cImNvdW50ID0gY291bnQgKyAxXCIgbmctaW5pdD1cImNvdW50PTBcIj5cbiAgICAgICAgSW5jcmVtZW50XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIGNvdW50OiB7e2NvdW50fX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgICA8ZG9jOnNjZW5hcmlvPlxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudCcpKS50b0JlKCcwJyk7XG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSA6YnV0dG9uJykuY2xpY2soKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdjb3VudCcpKS50b0JlKCcxJyk7XG4gICAgICAgfSk7XG4gICAgIDwvZG9jOnNjZW5hcmlvPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuLypcbiAqIEEgZGlyZWN0aXZlIHRoYXQgYWxsb3dzIGNyZWF0aW9uIG9mIGN1c3RvbSBvbmNsaWNrIGhhbmRsZXJzIHRoYXQgYXJlIGRlZmluZWQgYXMgYW5ndWxhclxuICogZXhwcmVzc2lvbnMgYW5kIGFyZSBjb21waWxlZCBhbmQgZXhlY3V0ZWQgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICpcbiAqIEV2ZW50cyB0aGF0IGFyZSBoYW5kbGVkIHZpYSB0aGVzZSBoYW5kbGVyIGFyZSBhbHdheXMgY29uZmlndXJlZCBub3QgdG8gcHJvcGFnYXRlIGZ1cnRoZXIuXG4gKi9cbnZhciBuZ0V2ZW50RGlyZWN0aXZlcyA9IHt9O1xuZm9yRWFjaChcbiAgJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgbW91c2VlbnRlciBtb3VzZWxlYXZlIGtleWRvd24ga2V5dXAga2V5cHJlc3Mgc3VibWl0IGZvY3VzIGJsdXIgY29weSBjdXQgcGFzdGUnLnNwbGl0KCcgJyksXG4gIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZU5vcm1hbGl6ZSgnbmctJyArIG5hbWUpO1xuICAgIG5nRXZlbnREaXJlY3RpdmVzW2RpcmVjdGl2ZU5hbWVdID0gWyckcGFyc2UnLCBmdW5jdGlvbigkcGFyc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKCRlbGVtZW50LCBhdHRyKSB7XG4gICAgICAgICAgdmFyIGZuID0gJHBhcnNlKGF0dHJbZGlyZWN0aXZlTmFtZV0pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICAgICAgICAgICAgZWxlbWVudC5vbihsb3dlcmNhc2UobmFtZSksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmbihzY29wZSwgeyRldmVudDpldmVudH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV07XG4gIH1cbik7XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nRGJsY2xpY2tcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgbmdEYmxjbGlja2AgZGlyZWN0aXZlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gYSBkYmxjbGljayBldmVudC5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdEYmxjbGljayB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXG4gKiBhIGRibGNsaWNrLiAoVGhlIEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXG4gKlxuICogQGV4YW1wbGVcbiAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICA8YnV0dG9uIG5nLWRibGNsaWNrPVwiY291bnQgPSBjb3VudCArIDFcIiBuZy1pbml0PVwiY291bnQ9MFwiPlxuICAgICAgICBJbmNyZW1lbnQgKG9uIGRvdWJsZSBjbGljaylcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgY291bnQ6IHt7Y291bnR9fVxuICAgICA8L2RvYzpzb3VyY2U+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb3VzZWRvd25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBuZ01vdXNlZG93biBkaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBtb3VzZWRvd24gZXZlbnQuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2Vkb3duIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIG1vdXNlZG93bi4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXG4gKlxuICogQGV4YW1wbGVcbiAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICA8YnV0dG9uIG5nLW1vdXNlZG93bj1cImNvdW50ID0gY291bnQgKyAxXCIgbmctaW5pdD1cImNvdW50PTBcIj5cbiAgICAgICAgSW5jcmVtZW50IChvbiBtb3VzZSBkb3duKVxuICAgICAgPC9idXR0b24+XG4gICAgICBjb3VudDoge3tjb3VudH19XG4gICAgIDwvZG9jOnNvdXJjZT5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vdXNldXBcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIG1vdXNldXAgZXZlbnQuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2V1cCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXG4gKiBtb3VzZXVwLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxidXR0b24gbmctbW91c2V1cD1cImNvdW50ID0gY291bnQgKyAxXCIgbmctaW5pdD1cImNvdW50PTBcIj5cbiAgICAgICAgSW5jcmVtZW50IChvbiBtb3VzZSB1cClcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgY291bnQ6IHt7Y291bnR9fVxuICAgICA8L2RvYzpzb3VyY2U+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2VvdmVyXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTcGVjaWZ5IGN1c3RvbSBiZWhhdmlvciBvbiBtb3VzZW92ZXIgZXZlbnQuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2VvdmVyIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIG1vdXNlb3Zlci4gKEV2ZW50IG9iamVjdCBpcyBhdmFpbGFibGUgYXMgYCRldmVudGApXG4gKlxuICogQGV4YW1wbGVcbiAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICA8YnV0dG9uIG5nLW1vdXNlb3Zlcj1cImNvdW50ID0gY291bnQgKyAxXCIgbmctaW5pdD1cImNvdW50PTBcIj5cbiAgICAgICAgSW5jcmVtZW50ICh3aGVuIG1vdXNlIGlzIG92ZXIpXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIGNvdW50OiB7e2NvdW50fX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nTW91c2VlbnRlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gbW91c2VlbnRlciBldmVudC5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNb3VzZWVudGVyIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIG1vdXNlZW50ZXIuIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgKVxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgPGJ1dHRvbiBuZy1tb3VzZWVudGVyPVwiY291bnQgPSBjb3VudCArIDFcIiBuZy1pbml0PVwiY291bnQ9MFwiPlxuICAgICAgICBJbmNyZW1lbnQgKHdoZW4gbW91c2UgZW50ZXJzKVxuICAgICAgPC9idXR0b24+XG4gICAgICBjb3VudDoge3tjb3VudH19XG4gICAgIDwvZG9jOnNvdXJjZT5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ01vdXNlbGVhdmVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIG1vdXNlbGVhdmUgZXZlbnQuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nTW91c2VsZWF2ZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXG4gKiBtb3VzZWxlYXZlLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxidXR0b24gbmctbW91c2VsZWF2ZT1cImNvdW50ID0gY291bnQgKyAxXCIgbmctaW5pdD1cImNvdW50PTBcIj5cbiAgICAgICAgSW5jcmVtZW50ICh3aGVuIG1vdXNlIGxlYXZlcylcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgY291bnQ6IHt7Y291bnR9fVxuICAgICA8L2RvYzpzb3VyY2U+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdNb3VzZW1vdmVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIG1vdXNlbW92ZSBldmVudC5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdNb3VzZW1vdmUge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxuICogbW91c2Vtb3ZlLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxidXR0b24gbmctbW91c2Vtb3ZlPVwiY291bnQgPSBjb3VudCArIDFcIiBuZy1pbml0PVwiY291bnQ9MFwiPlxuICAgICAgICBJbmNyZW1lbnQgKHdoZW4gbW91c2UgbW92ZXMpXG4gICAgICA8L2J1dHRvbj5cbiAgICAgIGNvdW50OiB7e2NvdW50fX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nS2V5ZG93blxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24ga2V5ZG93biBldmVudC5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdLZXlkb3duIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIGtleWRvd24uIChFdmVudCBvYmplY3QgaXMgYXZhaWxhYmxlIGFzIGAkZXZlbnRgIGFuZCBjYW4gYmUgaW50ZXJyb2dhdGVkIGZvciBrZXlDb2RlLCBhbHRLZXksIGV0Yy4pXG4gKlxuICogQGV4YW1wbGVcbiAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICA8aW5wdXQgbmcta2V5ZG93bj1cImNvdW50ID0gY291bnQgKyAxXCIgbmctaW5pdD1cImNvdW50PTBcIj5cbiAgICAgIGtleSBkb3duIGNvdW50OiB7e2NvdW50fX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nS2V5dXBcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIGtleXVwIGV2ZW50LlxuICpcbiAqIEBlbGVtZW50IEFOWVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0tleXVwIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIGtleXVwLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YCBhbmQgY2FuIGJlIGludGVycm9nYXRlZCBmb3Iga2V5Q29kZSwgYWx0S2V5LCBldGMuKVxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgPGlucHV0IG5nLWtleXVwPVwiY291bnQgPSBjb3VudCArIDFcIiBuZy1pbml0PVwiY291bnQ9MFwiPlxuICAgICAga2V5IHVwIGNvdW50OiB7e2NvdW50fX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nS2V5cHJlc3NcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFNwZWNpZnkgY3VzdG9tIGJlaGF2aW9yIG9uIGtleXByZXNzIGV2ZW50LlxuICpcbiAqIEBlbGVtZW50IEFOWVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0tleXByZXNzIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIGtleXByZXNzLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YCBhbmQgY2FuIGJlIGludGVycm9nYXRlZCBmb3Iga2V5Q29kZSwgYWx0S2V5LCBldGMuKVxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgICAgPGlucHV0IG5nLWtleXByZXNzPVwiY291bnQgPSBjb3VudCArIDFcIiBuZy1pbml0PVwiY291bnQ9MFwiPlxuICAgICAga2V5IHByZXNzIGNvdW50OiB7e2NvdW50fX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nU3VibWl0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBFbmFibGVzIGJpbmRpbmcgYW5ndWxhciBleHByZXNzaW9ucyB0byBvbnN1Ym1pdCBldmVudHMuXG4gKlxuICogQWRkaXRpb25hbGx5IGl0IHByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiAod2hpY2ggZm9yIGZvcm0gbWVhbnMgc2VuZGluZyB0aGUgcmVxdWVzdCB0byB0aGVcbiAqIHNlcnZlciBhbmQgcmVsb2FkaW5nIHRoZSBjdXJyZW50IHBhZ2UpICoqYnV0IG9ubHkgaWYgdGhlIGZvcm0gZG9lcyBub3QgY29udGFpbiBhbiBgYWN0aW9uYFxuICogYXR0cmlidXRlKiouXG4gKlxuICogQGVsZW1lbnQgZm9ybVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ1N1Ym1pdCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxzY3JpcHQ+XG4gICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAgJHNjb3BlLmxpc3QgPSBbXTtcbiAgICAgICAgICAkc2NvcGUudGV4dCA9ICdoZWxsbyc7XG4gICAgICAgICAgJHNjb3BlLnN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dCkge1xuICAgICAgICAgICAgICB0aGlzLmxpc3QucHVzaCh0aGlzLnRleHQpO1xuICAgICAgICAgICAgICB0aGlzLnRleHQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICA8L3NjcmlwdD5cbiAgICAgIDxmb3JtIG5nLXN1Ym1pdD1cInN1Ym1pdCgpXCIgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgRW50ZXIgdGV4dCBhbmQgaGl0IGVudGVyOlxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInRleHRcIiBuYW1lPVwidGV4dFwiIC8+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgaWQ9XCJzdWJtaXRcIiB2YWx1ZT1cIlN1Ym1pdFwiIC8+XG4gICAgICAgIDxwcmU+bGlzdD17e2xpc3R9fTwvcHJlPlxuICAgICAgPC9mb3JtPlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1zdWJtaXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdsaXN0JykpLnRvQmUoJ1tdJyk7XG4gICAgICAgICBlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAjc3VibWl0JykuY2xpY2soKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdsaXN0JykpLnRvQmUoJ1tcImhlbGxvXCJdJyk7XG4gICAgICAgICBleHBlY3QoaW5wdXQoJ3RleHQnKS52YWwoKSkudG9CZSgnJyk7XG4gICAgICAgfSk7XG4gICAgICAgaXQoJ3Nob3VsZCBpZ25vcmUgZW1wdHkgc3RyaW5ncycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgZXhwZWN0KGJpbmRpbmcoJ2xpc3QnKSkudG9CZSgnW10nKTtcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlICNzdWJtaXQnKS5jbGljaygpO1xuICAgICAgICAgZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgI3N1Ym1pdCcpLmNsaWNrKCk7XG4gICAgICAgICBleHBlY3QoYmluZGluZygnbGlzdCcpKS50b0JlKCdbXCJoZWxsb1wiXScpO1xuICAgICAgIH0pO1xuICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdGb2N1c1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gZm9jdXMgZXZlbnQuXG4gKlxuICogQGVsZW1lbnQgd2luZG93LCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0ZvY3VzIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIGZvY3VzLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxuICovXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQmx1clxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gYmx1ciBldmVudC5cbiAqXG4gKiBAZWxlbWVudCB3aW5kb3csIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBhXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQmx1ciB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXG4gKiBibHVyLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICogU2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGljayBuZ0NsaWNrfVxuICovXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nQ29weVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gY29weSBldmVudC5cbiAqXG4gKiBAZWxlbWVudCB3aW5kb3csIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBhXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nQ29weSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsdWF0ZSB1cG9uXG4gKiBjb3B5LiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxpbnB1dCBuZy1jb3B5PVwiY29waWVkPXRydWVcIiBuZy1pbml0PVwiY29waWVkPWZhbHNlOyB2YWx1ZT0nY29weSBtZSdcIiBuZy1tb2RlbD1cInZhbHVlXCI+XG4gICAgICBjb3BpZWQ6IHt7Y29waWVkfX1cbiAgICAgPC9kb2M6c291cmNlPlxuICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ0N1dFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gY3V0IGV2ZW50LlxuICpcbiAqIEBlbGVtZW50IHdpbmRvdywgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGFcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdDdXQge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gdG8gZXZhbHVhdGUgdXBvblxuICogY3V0LiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxpbnB1dCBuZy1jdXQ9XCJjdXQ9dHJ1ZVwiIG5nLWluaXQ9XCJjdXQ9ZmFsc2U7IHZhbHVlPSdjdXQgbWUnXCIgbmctbW9kZWw9XCJ2YWx1ZVwiPlxuICAgICAgY3V0OiB7e2N1dH19XG4gICAgIDwvZG9jOnNvdXJjZT5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdQYXN0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3BlY2lmeSBjdXN0b20gYmVoYXZpb3Igb24gcGFzdGUgZXZlbnQuXG4gKlxuICogQGVsZW1lbnQgd2luZG93LCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYVxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ1Bhc3RlIHtAbGluayBndWlkZS9leHByZXNzaW9uIEV4cHJlc3Npb259IHRvIGV2YWx1YXRlIHVwb25cbiAqIHBhc3RlLiAoRXZlbnQgb2JqZWN0IGlzIGF2YWlsYWJsZSBhcyBgJGV2ZW50YClcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlPlxuICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxpbnB1dCBuZy1wYXN0ZT1cInBhc3RlPXRydWVcIiBuZy1pbml0PVwicGFzdGU9ZmFsc2VcIiBwbGFjZWhvbGRlcj0ncGFzdGUgaGVyZSc+XG4gICAgICBwYXN0ZWQ6IHt7cGFzdGV9fVxuICAgICA8L2RvYzpzb3VyY2U+XG4gICA8L2RvYzpleGFtcGxlPlxuICovXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSWZcbiAqIEByZXN0cmljdCBBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nSWZgIGRpcmVjdGl2ZSByZW1vdmVzIG9yIHJlY3JlYXRlcyBhIHBvcnRpb24gb2YgdGhlIERPTSB0cmVlIGJhc2VkIG9uIGFuXG4gKiB7ZXhwcmVzc2lvbn0uIElmIHRoZSBleHByZXNzaW9uIGFzc2lnbmVkIHRvIGBuZ0lmYCBldmFsdWF0ZXMgdG8gYSBmYWxzZVxuICogdmFsdWUgdGhlbiB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgb3RoZXJ3aXNlIGEgY2xvbmUgb2YgdGhlXG4gKiBlbGVtZW50IGlzIHJlaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICpcbiAqIGBuZ0lmYCBkaWZmZXJzIGZyb20gYG5nU2hvd2AgYW5kIGBuZ0hpZGVgIGluIHRoYXQgYG5nSWZgIGNvbXBsZXRlbHkgcmVtb3ZlcyBhbmQgcmVjcmVhdGVzIHRoZVxuICogZWxlbWVudCBpbiB0aGUgRE9NIHJhdGhlciB0aGFuIGNoYW5naW5nIGl0cyB2aXNpYmlsaXR5IHZpYSB0aGUgYGRpc3BsYXlgIGNzcyBwcm9wZXJ0eS4gIEEgY29tbW9uXG4gKiBjYXNlIHdoZW4gdGhpcyBkaWZmZXJlbmNlIGlzIHNpZ25pZmljYW50IGlzIHdoZW4gdXNpbmcgY3NzIHNlbGVjdG9ycyB0aGF0IHJlbHkgb24gYW4gZWxlbWVudCdzXG4gKiBwb3NpdGlvbiB3aXRoaW4gdGhlIERPTSwgc3VjaCBhcyB0aGUgYDpmaXJzdC1jaGlsZGAgb3IgYDpsYXN0LWNoaWxkYCBwc2V1ZG8tY2xhc3Nlcy5cbiAqXG4gKiBOb3RlIHRoYXQgd2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgdXNpbmcgYG5nSWZgIGl0cyBzY29wZSBpcyBkZXN0cm95ZWQgYW5kIGEgbmV3IHNjb3BlXG4gKiBpcyBjcmVhdGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVzdG9yZWQuICBUaGUgc2NvcGUgY3JlYXRlZCB3aXRoaW4gYG5nSWZgIGluaGVyaXRzIGZyb21cbiAqIGl0cyBwYXJlbnQgc2NvcGUgdXNpbmdcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3dpa2kvVGhlLU51YW5jZXMtb2YtU2NvcGUtUHJvdG90eXBhbC1Jbmhlcml0YW5jZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlfS5cbiAqIEFuIGltcG9ydGFudCBpbXBsaWNhdGlvbiBvZiB0aGlzIGlzIGlmIGBuZ01vZGVsYCBpcyB1c2VkIHdpdGhpbiBgbmdJZmAgdG8gYmluZCB0b1xuICogYSBqYXZhc2NyaXB0IHByaW1pdGl2ZSBkZWZpbmVkIGluIHRoZSBwYXJlbnQgc2NvcGUuIEluIHRoaXMgY2FzZSBhbnkgbW9kaWZpY2F0aW9ucyBtYWRlIHRvIHRoZVxuICogdmFyaWFibGUgd2l0aGluIHRoZSBjaGlsZCBzY29wZSB3aWxsIG92ZXJyaWRlIChoaWRlKSB0aGUgdmFsdWUgaW4gdGhlIHBhcmVudCBzY29wZS5cbiAqXG4gKiBBbHNvLCBgbmdJZmAgcmVjcmVhdGVzIGVsZW1lbnRzIHVzaW5nIHRoZWlyIGNvbXBpbGVkIHN0YXRlLiBBbiBleGFtcGxlIG9mIHRoaXMgYmVoYXZpb3JcbiAqIGlzIGlmIGFuIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUgaXMgZGlyZWN0bHkgbW9kaWZpZWQgYWZ0ZXIgaXQncyBjb21waWxlZCwgdXNpbmcgc29tZXRoaW5nIGxpa2VcbiAqIGpRdWVyeSdzIGAuYWRkQ2xhc3MoKWAgbWV0aG9kLCBhbmQgdGhlIGVsZW1lbnQgaXMgbGF0ZXIgcmVtb3ZlZC4gV2hlbiBgbmdJZmAgcmVjcmVhdGVzIHRoZSBlbGVtZW50XG4gKiB0aGUgYWRkZWQgY2xhc3Mgd2lsbCBiZSBsb3N0IGJlY2F1c2UgdGhlIG9yaWdpbmFsIGNvbXBpbGVkIHN0YXRlIGlzIHVzZWQgdG8gcmVnZW5lcmF0ZSB0aGUgZWxlbWVudC5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gcHJvdmlkZSBhbmltYXRpb25zIHZpYSB0aGUgYG5nQW5pbWF0ZWAgbW9kdWxlIHRvIGFuaW1hdGUgdGhlIGBlbnRlcmBcbiAqIGFuZCBgbGVhdmVgIGVmZmVjdHMuXG4gKlxuICogQGFuaW1hdGlvbnNcbiAqIGVudGVyIC0gaGFwcGVucyBqdXN0IGFmdGVyIHRoZSBuZ0lmIGNvbnRlbnRzIGNoYW5nZSBhbmQgYSBuZXcgRE9NIGVsZW1lbnQgaXMgY3JlYXRlZCBhbmQgaW5qZWN0ZWQgaW50byB0aGUgbmdJZiBjb250YWluZXJcbiAqIGxlYXZlIC0gaGFwcGVucyBqdXN0IGJlZm9yZSB0aGUgbmdJZiBjb250ZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBzY29wZVxuICogQHByaW9yaXR5IDYwMFxuICogQHBhcmFtIHtleHByZXNzaW9ufSBuZ0lmIElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyBmYWxzeSB0aGVuXG4gKiAgICAgdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gdHJlZS4gSWYgaXQgaXMgdHJ1dGh5IGEgY29weSBvZiB0aGUgY29tcGlsZWRcbiAqICAgICBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET00gdHJlZS5cbiAqXG4gKiBAZXhhbXBsZVxuICA8ZXhhbXBsZSBhbmltYXRpb25zPVwidHJ1ZVwiPlxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICBDbGljayBtZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nLW1vZGVsPVwiY2hlY2tlZFwiIG5nLWluaXQ9XCJjaGVja2VkPXRydWVcIiAvPjxici8+XG4gICAgICBTaG93IHdoZW4gY2hlY2tlZDpcbiAgICAgIDxzcGFuIG5nLWlmPVwiY2hlY2tlZFwiIGNsYXNzPVwiYW5pbWF0ZS1pZlwiPlxuICAgICAgICBJJ20gcmVtb3ZlZCB3aGVuIHRoZSBjaGVja2JveCBpcyB1bmNoZWNrZWQuXG4gICAgICA8L3NwYW4+XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxuICAgICAgLmFuaW1hdGUtaWYge1xuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBwYWRkaW5nOjEwcHg7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLWlmLm5nLWVudGVyLCAuYW5pbWF0ZS1pZi5uZy1sZWF2ZSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xuICAgICAgICB0cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLWlmLm5nLWVudGVyLFxuICAgICAgLmFuaW1hdGUtaWYubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHtcbiAgICAgICAgb3BhY2l0eTowO1xuICAgICAgfVxuXG4gICAgICAuYW5pbWF0ZS1pZi5uZy1sZWF2ZSxcbiAgICAgIC5hbmltYXRlLWlmLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gICAgICAgIG9wYWNpdHk6MTtcbiAgICAgIH1cbiAgICA8L2ZpbGU+XG4gIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nSWZEaXJlY3RpdmUgPSBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgcHJpb3JpdHk6IDYwMCxcbiAgICB0ZXJtaW5hbDogdHJ1ZSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgICQkdGxiOiB0cnVlLFxuICAgIGxpbms6IGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50LCAkYXR0ciwgY3RybCwgJHRyYW5zY2x1ZGUpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBjaGlsZFNjb3BlO1xuICAgICAgICAkc2NvcGUuJHdhdGNoKCRhdHRyLm5nSWYsIGZ1bmN0aW9uIG5nSWZXYXRjaEFjdGlvbih2YWx1ZSkge1xuXG4gICAgICAgICAgaWYgKHRvQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghY2hpbGRTY29wZSkge1xuICAgICAgICAgICAgICBjaGlsZFNjb3BlID0gJHNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgICAgJHRyYW5zY2x1ZGUoY2hpbGRTY29wZSwgZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVbY2xvbmUubGVuZ3RoKytdID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIGVuZCBuZ0lmOiAnICsgJGF0dHIubmdJZiArICcgJyk7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2Ugb25seSBuZWVkIHRoZSBmaXJzdC9sYXN0IG5vZGUgb2YgdGhlIGNsb25lZCBub2Rlcy5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHJlZmVyZW5jZSB0byB0aGUganFsaXRlIHdyYXBwZXIgYXMgaXQgbWlnaHQgYmUgY2hhbmdlZCBsYXRlclxuICAgICAgICAgICAgICAgIC8vIGJ5IGEgZGlyZWN0aXZlIHdpdGggdGVtcGxhdGVVcmwgd2hlbiBpdCdzIHRlbXBsYXRlIGFycml2ZXMuXG4gICAgICAgICAgICAgICAgYmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgICBjbG9uZTogY2xvbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCAkZWxlbWVudC5wYXJlbnQoKSwgJGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRTY29wZSkge1xuICAgICAgICAgICAgICBjaGlsZFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgIGNoaWxkU2NvcGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZ2V0QmxvY2tFbGVtZW50cyhibG9jay5jbG9uZSkpO1xuICAgICAgICAgICAgICBibG9jayA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH07XG59XTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlXG4gKiBAcmVzdHJpY3QgRUNBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGZXRjaGVzLCBjb21waWxlcyBhbmQgaW5jbHVkZXMgYW4gZXh0ZXJuYWwgSFRNTCBmcmFnbWVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgVVJMIGlzIHJlc3RyaWN0ZWQgdG8gdGhlIHNhbWUgZG9tYWluIGFuZCBwcm90b2NvbCBhcyB0aGVcbiAqIGFwcGxpY2F0aW9uIGRvY3VtZW50LiBUaGlzIGlzIGRvbmUgYnkgY2FsbGluZyB7QGxpbmsgbmcuJHNjZSNtZXRob2RzX2dldFRydXN0ZWRSZXNvdXJjZVVybFxuICogJHNjZS5nZXRUcnVzdGVkUmVzb3VyY2VVcmx9IG9uIGl0LiBUbyBsb2FkIHRlbXBsYXRlcyBmcm9tIG90aGVyIGRvbWFpbnMgb3IgcHJvdG9jb2xzXG4gKiB5b3UgbWF5IGVpdGhlciB7QGxpbmsgbmcuJHNjZURlbGVnYXRlUHJvdmlkZXIjbWV0aG9kc19yZXNvdXJjZVVybFdoaXRlbGlzdCB3aGl0ZWxpc3QgdGhlbX0gb3JcbiAqIHtAbGluayBuZy4kc2NlI21ldGhvZHNfdHJ1c3RBc1Jlc291cmNlVXJsIHdyYXAgdGhlbX0gYXMgdHJ1c3RlZCB2YWx1ZXMuIFJlZmVyIHRvIEFuZ3VsYXIncyB7QGxpbmtcbiAqIG5nLiRzY2UgU3RyaWN0IENvbnRleHR1YWwgRXNjYXBpbmd9LlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgYnJvd3NlcidzXG4gKiB7QGxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9icm93c2Vyc2VjL3dpa2kvUGFydDIjU2FtZS1vcmlnaW5fcG9saWN5X2Zvcl9YTUxIdHRwUmVxdWVzdFxuICogU2FtZSBPcmlnaW4gUG9saWN5fSBhbmQge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL2NvcnMvIENyb3NzLU9yaWdpbiBSZXNvdXJjZSBTaGFyaW5nXG4gKiAoQ09SUyl9IHBvbGljeSBtYXkgZnVydGhlciByZXN0cmljdCB3aGV0aGVyIHRoZSB0ZW1wbGF0ZSBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICogRm9yIGV4YW1wbGUsIGBuZ0luY2x1ZGVgIHdvbid0IHdvcmsgZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cyBvbiBhbGwgYnJvd3NlcnMgYW5kIGZvciBgZmlsZTovL2BcbiAqIGFjY2VzcyBvbiBzb21lIGJyb3dzZXJzLlxuICpcbiAqIEBhbmltYXRpb25zXG4gKiBlbnRlciAtIGFuaW1hdGlvbiBpcyB1c2VkIHRvIGJyaW5nIG5ldyBjb250ZW50IGludG8gdGhlIGJyb3dzZXIuXG4gKiBsZWF2ZSAtIGFuaW1hdGlvbiBpcyB1c2VkIHRvIGFuaW1hdGUgZXhpc3RpbmcgY29udGVudCBhd2F5LlxuICpcbiAqIFRoZSBlbnRlciBhbmQgbGVhdmUgYW5pbWF0aW9uIG9jY3VyIGNvbmN1cnJlbnRseS5cbiAqXG4gKiBAc2NvcGVcbiAqIEBwcmlvcml0eSA0MDBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmdJbmNsdWRlfHNyYyBhbmd1bGFyIGV4cHJlc3Npb24gZXZhbHVhdGluZyB0byBVUkwuIElmIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmcgY29uc3RhbnQsXG4gKiAgICAgICAgICAgICAgICAgbWFrZSBzdXJlIHlvdSB3cmFwIGl0IGluIHF1b3RlcywgZS5nLiBgc3JjPVwiJ215UGFydGlhbFRlbXBsYXRlLmh0bWwnXCJgLlxuICogQHBhcmFtIHtzdHJpbmc9fSBvbmxvYWQgRXhwcmVzc2lvbiB0byBldmFsdWF0ZSB3aGVuIGEgbmV3IHBhcnRpYWwgaXMgbG9hZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXV0b3Njcm9sbCBXaGV0aGVyIGBuZ0luY2x1ZGVgIHNob3VsZCBjYWxsIHtAbGluayBuZy4kYW5jaG9yU2Nyb2xsXG4gKiAgICAgICAgICAgICAgICAgICRhbmNob3JTY3JvbGx9IHRvIHNjcm9sbCB0aGUgdmlld3BvcnQgYWZ0ZXIgdGhlIGNvbnRlbnQgaXMgbG9hZGVkLlxuICpcbiAqICAgICAgICAgICAgICAgICAgLSBJZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBzZXQsIGRpc2FibGUgc2Nyb2xsaW5nLlxuICogICAgICAgICAgICAgICAgICAtIElmIHRoZSBhdHRyaWJ1dGUgaXMgc2V0IHdpdGhvdXQgdmFsdWUsIGVuYWJsZSBzY3JvbGxpbmcuXG4gKiAgICAgICAgICAgICAgICAgIC0gT3RoZXJ3aXNlIGVuYWJsZSBzY3JvbGxpbmcgb25seSBpZiB0aGUgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1dGh5IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJ0ZW1wbGF0ZVwiIG5nLW9wdGlvbnM9XCJ0Lm5hbWUgZm9yIHQgaW4gdGVtcGxhdGVzXCI+XG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj4oYmxhbmspPC9vcHRpb24+XG4gICAgICAgPC9zZWxlY3Q+XG4gICAgICAgdXJsIG9mIHRoZSB0ZW1wbGF0ZTogPHR0Pnt7dGVtcGxhdGUudXJsfX08L3R0PlxuICAgICAgIDxoci8+XG4gICAgICAgPGRpdiBjbGFzcz1cInNsaWRlLWFuaW1hdGUtY29udGFpbmVyXCI+XG4gICAgICAgICA8ZGl2IGNsYXNzPVwic2xpZGUtYW5pbWF0ZVwiIG5nLWluY2x1ZGU9XCJ0ZW1wbGF0ZS51cmxcIj48L2Rpdj5cbiAgICAgICA8L2Rpdj5cbiAgICAgPC9kaXY+XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJzY3JpcHQuanNcIj5cbiAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICRzY29wZS50ZW1wbGF0ZXMgPVxuICAgICAgICAgIFsgeyBuYW1lOiAndGVtcGxhdGUxLmh0bWwnLCB1cmw6ICd0ZW1wbGF0ZTEuaHRtbCd9XG4gICAgICAgICAgLCB7IG5hbWU6ICd0ZW1wbGF0ZTIuaHRtbCcsIHVybDogJ3RlbXBsYXRlMi5odG1sJ30gXTtcbiAgICAgICAgJHNjb3BlLnRlbXBsYXRlID0gJHNjb3BlLnRlbXBsYXRlc1swXTtcbiAgICAgIH1cbiAgICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJ0ZW1wbGF0ZTEuaHRtbFwiPlxuICAgICAgQ29udGVudCBvZiB0ZW1wbGF0ZTEuaHRtbFxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwidGVtcGxhdGUyLmh0bWxcIj5cbiAgICAgIENvbnRlbnQgb2YgdGVtcGxhdGUyLmh0bWxcbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XG4gICAgICAuc2xpZGUtYW5pbWF0ZS1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgICAgYmFja2dyb3VuZDp3aGl0ZTtcbiAgICAgICAgYm9yZGVyOjFweCBzb2xpZCBibGFjaztcbiAgICAgICAgaGVpZ2h0OjQwcHg7XG4gICAgICAgIG92ZXJmbG93OmhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLnNsaWRlLWFuaW1hdGUge1xuICAgICAgICBwYWRkaW5nOjEwcHg7XG4gICAgICB9XG5cbiAgICAgIC5zbGlkZS1hbmltYXRlLm5nLWVudGVyLCAuc2xpZGUtYW5pbWF0ZS5uZy1sZWF2ZSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xuICAgICAgICB0cmFuc2l0aW9uOmFsbCBjdWJpYy1iZXppZXIoMC4yNTAsIDAuNDYwLCAwLjQ1MCwgMC45NDApIDAuNXM7XG5cbiAgICAgICAgcG9zaXRpb246YWJzb2x1dGU7XG4gICAgICAgIHRvcDowO1xuICAgICAgICBsZWZ0OjA7XG4gICAgICAgIHJpZ2h0OjA7XG4gICAgICAgIGJvdHRvbTowO1xuICAgICAgICBkaXNwbGF5OmJsb2NrO1xuICAgICAgICBwYWRkaW5nOjEwcHg7XG4gICAgICB9XG5cbiAgICAgIC5zbGlkZS1hbmltYXRlLm5nLWVudGVyIHtcbiAgICAgICAgdG9wOi01MHB4O1xuICAgICAgfVxuICAgICAgLnNsaWRlLWFuaW1hdGUubmctZW50ZXIubmctZW50ZXItYWN0aXZlIHtcbiAgICAgICAgdG9wOjA7XG4gICAgICB9XG5cbiAgICAgIC5zbGlkZS1hbmltYXRlLm5nLWxlYXZlIHtcbiAgICAgICAgdG9wOjA7XG4gICAgICB9XG4gICAgICAuc2xpZGUtYW5pbWF0ZS5uZy1sZWF2ZS5uZy1sZWF2ZS1hY3RpdmUge1xuICAgICAgICB0b3A6NTBweDtcbiAgICAgIH1cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gICAgICBpdCgnc2hvdWxkIGxvYWQgdGVtcGxhdGUxLmh0bWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgW25nLWluY2x1ZGVdJykudGV4dCgpKS5cbiAgICAgICAgIHRvTWF0Y2goL0NvbnRlbnQgb2YgdGVtcGxhdGUxLmh0bWwvKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3Nob3VsZCBsb2FkIHRlbXBsYXRlMi5odG1sJywgZnVuY3Rpb24oKSB7XG4gICAgICAgc2VsZWN0KCd0ZW1wbGF0ZScpLm9wdGlvbignMScpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctaW5jbHVkZV0nKS50ZXh0KCkpLlxuICAgICAgICAgdG9NYXRjaCgvQ29udGVudCBvZiB0ZW1wbGF0ZTIuaHRtbC8pO1xuICAgICAgfSk7XG4gICAgICBpdCgnc2hvdWxkIGNoYW5nZSB0byBibGFuaycsIGZ1bmN0aW9uKCkge1xuICAgICAgIHNlbGVjdCgndGVtcGxhdGUnKS5vcHRpb24oJycpO1xuICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctaW5jbHVkZV0nKSkudG9CZSh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgPC9maWxlPlxuICA8L2V4YW1wbGU+XG4gKi9cblxuXG4vKipcbiAqIEBuZ2RvYyBldmVudFxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSW5jbHVkZSMkaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWRcbiAqIEBldmVudE9mIG5nLmRpcmVjdGl2ZTpuZ0luY2x1ZGVcbiAqIEBldmVudFR5cGUgZW1pdCBvbiB0aGUgc2NvcGUgbmdJbmNsdWRlIHdhcyBkZWNsYXJlZCBpblxuICogQGRlc2NyaXB0aW9uXG4gKiBFbWl0dGVkIGV2ZXJ5IHRpbWUgdGhlIG5nSW5jbHVkZSBjb250ZW50IGlzIHJlcXVlc3RlZC5cbiAqL1xuXG5cbi8qKlxuICogQG5nZG9jIGV2ZW50XG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlIyRpbmNsdWRlQ29udGVudExvYWRlZFxuICogQGV2ZW50T2YgbmcuZGlyZWN0aXZlOm5nSW5jbHVkZVxuICogQGV2ZW50VHlwZSBlbWl0IG9uIHRoZSBjdXJyZW50IG5nSW5jbHVkZSBzY29wZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbWl0dGVkIGV2ZXJ5IHRpbWUgdGhlIG5nSW5jbHVkZSBjb250ZW50IGlzIHJlbG9hZGVkLlxuICovXG52YXIgbmdJbmNsdWRlRGlyZWN0aXZlID0gWyckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckYW5jaG9yU2Nyb2xsJywgJyRhbmltYXRlJywgJyRzY2UnLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oJGh0dHAsICAgJHRlbXBsYXRlQ2FjaGUsICAgJGFuY2hvclNjcm9sbCwgICAkYW5pbWF0ZSwgICAkc2NlKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgIHByaW9yaXR5OiA0MDAsXG4gICAgdGVybWluYWw6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxuICAgIGNvbnRyb2xsZXI6IGFuZ3VsYXIubm9vcCxcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgc3JjRXhwID0gYXR0ci5uZ0luY2x1ZGUgfHwgYXR0ci5zcmMsXG4gICAgICAgICAgb25sb2FkRXhwID0gYXR0ci5vbmxvYWQgfHwgJycsXG4gICAgICAgICAgYXV0b1Njcm9sbEV4cCA9IGF0dHIuYXV0b3Njcm9sbDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCAkZWxlbWVudCwgJGF0dHIsIGN0cmwsICR0cmFuc2NsdWRlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VDb3VudGVyID0gMCxcbiAgICAgICAgICAgIGN1cnJlbnRTY29wZSxcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50O1xuXG4gICAgICAgIHZhciBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS4kd2F0Y2goJHNjZS5wYXJzZUFzUmVzb3VyY2VVcmwoc3JjRXhwKSwgZnVuY3Rpb24gbmdJbmNsdWRlV2F0Y2hBY3Rpb24oc3JjKSB7XG4gICAgICAgICAgdmFyIGFmdGVyQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICghYXV0b1Njcm9sbEV4cCB8fCBzY29wZS4kZXZhbChhdXRvU2Nyb2xsRXhwKSkpIHtcbiAgICAgICAgICAgICAgJGFuY2hvclNjcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRoaXNDaGFuZ2VJZCA9ICsrY2hhbmdlQ291bnRlcjtcblxuICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICRodHRwLmdldChzcmMsIHtjYWNoZTogJHRlbXBsYXRlQ2FjaGV9KS5zdWNjZXNzKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgIT09IGNoYW5nZUNvdW50ZXIpIHJldHVybjtcbiAgICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICBjdHJsLnRlbXBsYXRlID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGFsc28gbGluayBhbGwgY2hpbGRyZW4gb2YgbmctaW5jbHVkZSB0aGF0IHdlcmUgY29udGFpbmVkIGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAvLyBodG1sLiBJZiB0aGF0IGNvbnRlbnQgY29udGFpbnMgY29udHJvbGxlcnMsIC4uLiB0aGV5IGNvdWxkIHBvbGx1dGUvY2hhbmdlIHRoZSBzY29wZS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgdXNpbmcgbmctaW5jbHVkZSBvbiBhbiBlbGVtZW50IHdpdGggYWRkaXRpb25hbCBjb250ZW50IGRvZXMgbm90IG1ha2Ugc2Vuc2UuLi5cbiAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2FuJ3QgcmVtb3ZlIHRoZW0gaW4gdGhlIGNsb25lQXR0Y2hGbiBvZiAkdHJhbnNjbHVkZSBhcyB0aGF0XG4gICAgICAgICAgICAgIC8vIGZ1bmN0aW9uIGlzIGNhbGxlZCBiZWZvcmUgbGlua2luZyB0aGUgY29udGVudCwgd2hpY2ggd291bGQgYXBwbHkgY2hpbGRcbiAgICAgICAgICAgICAgLy8gZGlyZWN0aXZlcyB0byBub24gZXhpc3RpbmcgZWxlbWVudHMuXG4gICAgICAgICAgICAgIHZhciBjbG9uZSA9ICR0cmFuc2NsdWRlKG5ld1Njb3BlLCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjbG9uZSwgbnVsbCwgJGVsZW1lbnQsIGFmdGVyQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XG4gICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY2xvbmU7XG5cbiAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRMb2FkZWQnKTtcbiAgICAgICAgICAgICAgc2NvcGUuJGV2YWwob25sb2FkRXhwKTtcbiAgICAgICAgICAgIH0pLmVycm9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkID09PSBjaGFuZ2VDb3VudGVyKSBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjb3BlLiRlbWl0KCckaW5jbHVkZUNvbnRlbnRSZXF1ZXN0ZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICAgICAgY3RybC50ZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xufV07XG5cbi8vIFRoaXMgZGlyZWN0aXZlIGlzIGNhbGxlZCBkdXJpbmcgdGhlICR0cmFuc2NsdWRlIGNhbGwgb2YgdGhlIGZpcnN0IGBuZ0luY2x1ZGVgIGRpcmVjdGl2ZS5cbi8vIEl0IHdpbGwgcmVwbGFjZSBhbmQgY29tcGlsZSB0aGUgY29udGVudCBvZiB0aGUgZWxlbWVudCB3aXRoIHRoZSBsb2FkZWQgdGVtcGxhdGUuXG4vLyBXZSBuZWVkIHRoaXMgZGlyZWN0aXZlIHNvIHRoYXQgdGhlIGVsZW1lbnQgY29udGVudCBpcyBhbHJlYWR5IGZpbGxlZCB3aGVuXG4vLyB0aGUgbGluayBmdW5jdGlvbiBvZiBhbm90aGVyIGRpcmVjdGl2ZSBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIG5nSW5jbHVkZVxuLy8gaXMgY2FsbGVkLlxudmFyIG5nSW5jbHVkZUZpbGxDb250ZW50RGlyZWN0aXZlID0gWyckY29tcGlsZScsXG4gIGZ1bmN0aW9uKCRjb21waWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnRUNBJyxcbiAgICAgIHByaW9yaXR5OiAtNDAwLFxuICAgICAgcmVxdWlyZTogJ25nSW5jbHVkZScsXG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgJGVsZW1lbnQsICRhdHRyLCBjdHJsKSB7XG4gICAgICAgICRlbGVtZW50Lmh0bWwoY3RybC50ZW1wbGF0ZSk7XG4gICAgICAgICRjb21waWxlKCRlbGVtZW50LmNvbnRlbnRzKCkpKHNjb3BlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdJbml0XG4gKiBAcmVzdHJpY3QgQUNcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgbmdJbml0YCBkaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBldmFsdWF0ZSBhbiBleHByZXNzaW9uIGluIHRoZVxuICogY3VycmVudCBzY29wZS5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgYWxlcnQtZXJyb3JcIj5cbiAqIFRoZSBvbmx5IGFwcHJvcHJpYXRlIHVzZSBvZiBgbmdJbml0YCBpcyBmb3IgYWxpYXNpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzIG9mXG4gKiB7QGxpbmsgYXBpL25nLmRpcmVjdGl2ZTpuZ1JlcGVhdCBgbmdSZXBlYXRgfSwgYXMgc2VlbiBpbiB0aGUgZGVtbyBiZWxvdy4gQmVzaWRlcyB0aGlzIGNhc2UsIHlvdVxuICogc2hvdWxkIHVzZSB7QGxpbmsgZ3VpZGUvY29udHJvbGxlciBjb250cm9sbGVyc30gcmF0aGVyIHRoYW4gYG5nSW5pdGBcbiAqIHRvIGluaXRpYWxpemUgdmFsdWVzIG9uIGEgc2NvcGUuXG4gKiA8L2Rpdj5cbiAqXG4gKiBAcHJpb3JpdHkgNDUwXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nSW5pdCB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBFeHByZXNzaW9ufSB0byBldmFsLlxuICpcbiAqIEBleGFtcGxlXG4gICA8ZG9jOmV4YW1wbGU+XG4gICAgIDxkb2M6c291cmNlPlxuICAgPHNjcmlwdD5cbiAgICAgZnVuY3Rpb24gQ3RybCgkc2NvcGUpIHtcbiAgICAgICAkc2NvcGUubGlzdCA9IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXTtcbiAgICAgfVxuICAgPC9zY3JpcHQ+XG4gICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJDdHJsXCI+XG4gICAgIDxkaXYgbmctcmVwZWF0PVwiaW5uZXJMaXN0IGluIGxpc3RcIiBuZy1pbml0PVwib3V0ZXJJbmRleCA9ICRpbmRleFwiPlxuICAgICAgIDxkaXYgbmctcmVwZWF0PVwidmFsdWUgaW4gaW5uZXJMaXN0XCIgbmctaW5pdD1cImlubmVySW5kZXggPSAkaW5kZXhcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImV4YW1wbGUtaW5pdFwiPmxpc3RbIHt7b3V0ZXJJbmRleH19IF1bIHt7aW5uZXJJbmRleH19IF0gPSB7e3ZhbHVlfX07PC9zcGFuPlxuICAgICAgIDwvZGl2PlxuICAgICA8L2Rpdj5cbiAgIDwvZGl2PlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBhbGlhcyBpbmRleCBwb3NpdGlvbnMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZXhhbXBsZS1pbml0JykudGV4dCgpKVxuICAgICAgICAgICAudG9CZSgnbGlzdFsgMCBdWyAwIF0gPSBhOycgK1xuICAgICAgICAgICAgICAgICAnbGlzdFsgMCBdWyAxIF0gPSBiOycgK1xuICAgICAgICAgICAgICAgICAnbGlzdFsgMSBdWyAwIF0gPSBjOycgK1xuICAgICAgICAgICAgICAgICAnbGlzdFsgMSBdWyAxIF0gPSBkOycpO1xuICAgICAgIH0pO1xuICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKi9cbnZhciBuZ0luaXREaXJlY3RpdmUgPSBuZ0RpcmVjdGl2ZSh7XG4gIHByaW9yaXR5OiA0NTAsXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwcmU6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBzY29wZS4kZXZhbChhdHRycy5uZ0luaXQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ05vbkJpbmRhYmxlXG4gKiBAcmVzdHJpY3QgQUNcbiAqIEBwcmlvcml0eSAxMDAwXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nTm9uQmluZGFibGVgIGRpcmVjdGl2ZSB0ZWxscyBBbmd1bGFyIG5vdCB0byBjb21waWxlIG9yIGJpbmQgdGhlIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50XG4gKiBET00gZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgd2hhdCBhcHBlYXJzIHRvIGJlIEFuZ3VsYXIgZGlyZWN0aXZlcyBhbmRcbiAqIGJpbmRpbmdzIGJ1dCB3aGljaCBzaG91bGQgYmUgaWdub3JlZCBieSBBbmd1bGFyLiBUaGlzIGNvdWxkIGJlIHRoZSBjYXNlIGlmIHlvdSBoYXZlIGEgc2l0ZSB0aGF0XG4gKiBkaXNwbGF5cyBzbmlwcGV0cyBvZiBjb2RlLCBmb3IgaW5zdGFuY2UuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKlxuICogQGV4YW1wbGVcbiAqIEluIHRoaXMgZXhhbXBsZSB0aGVyZSBhcmUgdHdvIGxvY2F0aW9ucyB3aGVyZSBhIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJpbmRpbmcgKGB7e319YCkgaXMgcHJlc2VudCxcbiAqIGJ1dCB0aGUgb25lIHdyYXBwZWQgaW4gYG5nTm9uQmluZGFibGVgIGlzIGxlZnQgYWxvbmUuXG4gKlxuICogQGV4YW1wbGVcbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgPGRpdj5Ob3JtYWw6IHt7MSArIDJ9fTwvZGl2PlxuICAgICAgICA8ZGl2IG5nLW5vbi1iaW5kYWJsZT5JZ25vcmVkOiB7ezEgKyAyfX08L2Rpdj5cbiAgICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgaXQoJ3Nob3VsZCBjaGVjayBuZy1ub24tYmluZGFibGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdCh1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5iaW5kaW5nKCcxICsgMicpKS50b0JlKCczJyk7XG4gICAgICAgICBleHBlY3QodXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuZWxlbWVudCgnZGl2Omxhc3QnKS50ZXh0KCkpLlxuICAgICAgICAgICB0b01hdGNoKC8xIFxcKyAyLyk7XG4gICAgICAgfSk7XG4gICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgICA8L2RvYzpleGFtcGxlPlxuICovXG52YXIgbmdOb25CaW5kYWJsZURpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKHsgdGVybWluYWw6IHRydWUsIHByaW9yaXR5OiAxMDAwIH0pO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1BsdXJhbGl6ZVxuICogQHJlc3RyaWN0IEVBXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAjIE92ZXJ2aWV3XG4gKiBgbmdQbHVyYWxpemVgIGlzIGEgZGlyZWN0aXZlIHRoYXQgZGlzcGxheXMgbWVzc2FnZXMgYWNjb3JkaW5nIHRvIGVuLVVTIGxvY2FsaXphdGlvbiBydWxlcy5cbiAqIFRoZXNlIHJ1bGVzIGFyZSBidW5kbGVkIHdpdGggYW5ndWxhci5qcywgYnV0IGNhbiBiZSBvdmVycmlkZGVuXG4gKiAoc2VlIHtAbGluayBndWlkZS9pMThuIEFuZ3VsYXIgaTE4bn0gZGV2IGd1aWRlKS4gWW91IGNvbmZpZ3VyZSBuZ1BsdXJhbGl6ZSBkaXJlY3RpdmVcbiAqIGJ5IHNwZWNpZnlpbmcgdGhlIG1hcHBpbmdzIGJldHdlZW5cbiAqIHtAbGluayBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3MvY2xkci10bXAvdHJ1bmsvZGlmZi9zdXBwbGVtZW50YWwvbGFuZ3VhZ2VfcGx1cmFsX3J1bGVzLmh0bWxcbiAqIHBsdXJhbCBjYXRlZ29yaWVzfSBhbmQgdGhlIHN0cmluZ3MgdG8gYmUgZGlzcGxheWVkLlxuICpcbiAqICMgUGx1cmFsIGNhdGVnb3JpZXMgYW5kIGV4cGxpY2l0IG51bWJlciBydWxlc1xuICogVGhlcmUgYXJlIHR3b1xuICoge0BsaW5rIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcy9jbGRyLXRtcC90cnVuay9kaWZmL3N1cHBsZW1lbnRhbC9sYW5ndWFnZV9wbHVyYWxfcnVsZXMuaHRtbFxuICogcGx1cmFsIGNhdGVnb3JpZXN9IGluIEFuZ3VsYXIncyBkZWZhdWx0IGVuLVVTIGxvY2FsZTogXCJvbmVcIiBhbmQgXCJvdGhlclwiLlxuICpcbiAqIFdoaWxlIGEgcGx1cmFsIGNhdGVnb3J5IG1heSBtYXRjaCBtYW55IG51bWJlcnMgKGZvciBleGFtcGxlLCBpbiBlbi1VUyBsb2NhbGUsIFwib3RoZXJcIiBjYW4gbWF0Y2hcbiAqIGFueSBudW1iZXIgdGhhdCBpcyBub3QgMSksIGFuIGV4cGxpY2l0IG51bWJlciBydWxlIGNhbiBvbmx5IG1hdGNoIG9uZSBudW1iZXIuIEZvciBleGFtcGxlLCB0aGVcbiAqIGV4cGxpY2l0IG51bWJlciBydWxlIGZvciBcIjNcIiBtYXRjaGVzIHRoZSBudW1iZXIgMy4gVGhlcmUgYXJlIGV4YW1wbGVzIG9mIHBsdXJhbCBjYXRlZ29yaWVzXG4gKiBhbmQgZXhwbGljaXQgbnVtYmVyIHJ1bGVzIHRocm91Z2hvdXQgdGhlIHJlc3Qgb2YgdGhpcyBkb2N1bWVudGF0aW9uLlxuICpcbiAqICMgQ29uZmlndXJpbmcgbmdQbHVyYWxpemVcbiAqIFlvdSBjb25maWd1cmUgbmdQbHVyYWxpemUgYnkgcHJvdmlkaW5nIDIgYXR0cmlidXRlczogYGNvdW50YCBhbmQgYHdoZW5gLlxuICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYW4gb3B0aW9uYWwgYXR0cmlidXRlLCBgb2Zmc2V0YC5cbiAqXG4gKiBUaGUgdmFsdWUgb2YgdGhlIGBjb3VudGAgYXR0cmlidXRlIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4ge0BsaW5rIGd1aWRlL2V4cHJlc3Npb25cbiAqIEFuZ3VsYXIgZXhwcmVzc2lvbn07IHRoZXNlIGFyZSBldmFsdWF0ZWQgb24gdGhlIGN1cnJlbnQgc2NvcGUgZm9yIGl0cyBib3VuZCB2YWx1ZS5cbiAqXG4gKiBUaGUgYHdoZW5gIGF0dHJpYnV0ZSBzcGVjaWZpZXMgdGhlIG1hcHBpbmdzIGJldHdlZW4gcGx1cmFsIGNhdGVnb3JpZXMgYW5kIHRoZSBhY3R1YWxcbiAqIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQuIFRoZSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gY29uZmlndXJlIG5nUGx1cmFsaXplOlxuICpcbiAqIDxwcmU+XG4gKiA8bmctcGx1cmFsaXplIGNvdW50PVwicGVyc29uQ291bnRcIlxuICAgICAgICAgICAgICAgICB3aGVuPVwieycwJzogJ05vYm9keSBpcyB2aWV3aW5nLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAnb25lJzogJzEgcGVyc29uIGlzIHZpZXdpbmcuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7fSBwZW9wbGUgYXJlIHZpZXdpbmcuJ31cIj5cbiAqIDwvbmctcGx1cmFsaXplPlxuICo8L3ByZT5cbiAqXG4gKiBJbiB0aGUgZXhhbXBsZSwgYFwiMDogTm9ib2R5IGlzIHZpZXdpbmcuXCJgIGlzIGFuIGV4cGxpY2l0IG51bWJlciBydWxlLiBJZiB5b3UgZGlkIG5vdFxuICogc3BlY2lmeSB0aGlzIHJ1bGUsIDAgd291bGQgYmUgbWF0Y2hlZCB0byB0aGUgXCJvdGhlclwiIGNhdGVnb3J5IGFuZCBcIjAgcGVvcGxlIGFyZSB2aWV3aW5nXCJcbiAqIHdvdWxkIGJlIHNob3duIGluc3RlYWQgb2YgXCJOb2JvZHkgaXMgdmlld2luZ1wiLiBZb3UgY2FuIHNwZWNpZnkgYW4gZXhwbGljaXQgbnVtYmVyIHJ1bGUgZm9yXG4gKiBvdGhlciBudW1iZXJzLCBmb3IgZXhhbXBsZSAxMiwgc28gdGhhdCBpbnN0ZWFkIG9mIHNob3dpbmcgXCIxMiBwZW9wbGUgYXJlIHZpZXdpbmdcIiwgeW91IGNhblxuICogc2hvdyBcImEgZG96ZW4gcGVvcGxlIGFyZSB2aWV3aW5nXCIuXG4gKlxuICogWW91IGNhbiB1c2UgYSBzZXQgb2YgY2xvc2VkIGJyYWNlcyAoYHt9YCkgYXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlIG51bWJlciB0aGF0IHlvdSB3YW50IHN1YnN0aXR1dGVkXG4gKiBpbnRvIHBsdXJhbGl6ZWQgc3RyaW5ncy4gSW4gdGhlIHByZXZpb3VzIGV4YW1wbGUsIEFuZ3VsYXIgd2lsbCByZXBsYWNlIGB7fWAgd2l0aFxuICogPHNwYW4gbmctbm9uLWJpbmRhYmxlPmB7e3BlcnNvbkNvdW50fX1gPC9zcGFuPi4gVGhlIGNsb3NlZCBicmFjZXMgYHt9YCBpcyBhIHBsYWNlaG9sZGVyXG4gKiBmb3IgPHNwYW4gbmctbm9uLWJpbmRhYmxlPnt7bnVtYmVyRXhwcmVzc2lvbn19PC9zcGFuPi5cbiAqXG4gKiAjIENvbmZpZ3VyaW5nIG5nUGx1cmFsaXplIHdpdGggb2Zmc2V0XG4gKiBUaGUgYG9mZnNldGAgYXR0cmlidXRlIGFsbG93cyBmdXJ0aGVyIGN1c3RvbWl6YXRpb24gb2YgcGx1cmFsaXplZCB0ZXh0LCB3aGljaCBjYW4gcmVzdWx0IGluXG4gKiBhIGJldHRlciB1c2VyIGV4cGVyaWVuY2UuIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mIHRoZSBtZXNzYWdlIFwiNCBwZW9wbGUgYXJlIHZpZXdpbmcgdGhpcyBkb2N1bWVudFwiLFxuICogeW91IG1pZ2h0IGRpc3BsYXkgXCJKb2huLCBLYXRlIGFuZCAyIG90aGVycyBhcmUgdmlld2luZyB0aGlzIGRvY3VtZW50XCIuXG4gKiBUaGUgb2Zmc2V0IGF0dHJpYnV0ZSBhbGxvd3MgeW91IHRvIG9mZnNldCBhIG51bWJlciBieSBhbnkgZGVzaXJlZCB2YWx1ZS5cbiAqIExldCdzIHRha2UgYSBsb29rIGF0IGFuIGV4YW1wbGU6XG4gKlxuICogPHByZT5cbiAqIDxuZy1wbHVyYWxpemUgY291bnQ9XCJwZXJzb25Db3VudFwiIG9mZnNldD0yXG4gKiAgICAgICAgICAgICAgIHdoZW49XCJ7JzAnOiAnTm9ib2R5IGlzIHZpZXdpbmcuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICcxJzogJ3t7cGVyc29uMX19IGlzIHZpZXdpbmcuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICcyJzogJ3t7cGVyc29uMX19IGFuZCB7e3BlcnNvbjJ9fSBhcmUgdmlld2luZy4nLFxuICogICAgICAgICAgICAgICAgICAgICAgJ29uZSc6ICd7e3BlcnNvbjF9fSwge3twZXJzb24yfX0gYW5kIG9uZSBvdGhlciBwZXJzb24gYXJlIHZpZXdpbmcuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7e3BlcnNvbjF9fSwge3twZXJzb24yfX0gYW5kIHt9IG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nfVwiPlxuICogPC9uZy1wbHVyYWxpemU+XG4gKiA8L3ByZT5cbiAqXG4gKiBOb3RpY2UgdGhhdCB3ZSBhcmUgc3RpbGwgdXNpbmcgdHdvIHBsdXJhbCBjYXRlZ29yaWVzKG9uZSwgb3RoZXIpLCBidXQgd2UgYWRkZWRcbiAqIHRocmVlIGV4cGxpY2l0IG51bWJlciBydWxlcyAwLCAxIGFuZCAyLlxuICogV2hlbiBvbmUgcGVyc29uLCBwZXJoYXBzIEpvaG4sIHZpZXdzIHRoZSBkb2N1bWVudCwgXCJKb2huIGlzIHZpZXdpbmdcIiB3aWxsIGJlIHNob3duLlxuICogV2hlbiB0aHJlZSBwZW9wbGUgdmlldyB0aGUgZG9jdW1lbnQsIG5vIGV4cGxpY2l0IG51bWJlciBydWxlIGlzIGZvdW5kLCBzb1xuICogYW4gb2Zmc2V0IG9mIDIgaXMgdGFrZW4gb2ZmIDMsIGFuZCBBbmd1bGFyIHVzZXMgMSB0byBkZWNpZGUgdGhlIHBsdXJhbCBjYXRlZ29yeS5cbiAqIEluIHRoaXMgY2FzZSwgcGx1cmFsIGNhdGVnb3J5ICdvbmUnIGlzIG1hdGNoZWQgYW5kIFwiSm9obiwgTWFycnkgYW5kIG9uZSBvdGhlciBwZXJzb24gYXJlIHZpZXdpbmdcIlxuICogaXMgc2hvd24uXG4gKlxuICogTm90ZSB0aGF0IHdoZW4geW91IHNwZWNpZnkgb2Zmc2V0cywgeW91IG11c3QgcHJvdmlkZSBleHBsaWNpdCBudW1iZXIgcnVsZXMgZm9yXG4gKiBudW1iZXJzIGZyb20gMCB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBvZmZzZXQuIElmIHlvdSB1c2UgYW4gb2Zmc2V0IG9mIDMsIGZvciBleGFtcGxlLFxuICogeW91IG11c3QgcHJvdmlkZSBleHBsaWNpdCBudW1iZXIgcnVsZXMgZm9yIDAsIDEsIDIgYW5kIDMuIFlvdSBtdXN0IGFsc28gcHJvdmlkZSBwbHVyYWwgc3RyaW5ncyBmb3JcbiAqIHBsdXJhbCBjYXRlZ29yaWVzIFwib25lXCIgYW5kIFwib3RoZXJcIi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xleHByZXNzaW9ufSBjb3VudCBUaGUgdmFyaWFibGUgdG8gYmUgYm91bmRlZCB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3aGVuIFRoZSBtYXBwaW5nIGJldHdlZW4gcGx1cmFsIGNhdGVnb3J5IHRvIGl0cyBjb3JyZXNwb25kaW5nIHN0cmluZ3MuXG4gKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gZGVkdWN0IGZyb20gdGhlIHRvdGFsIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICAgIDxkb2M6ZXhhbXBsZT5cbiAgICAgIDxkb2M6c291cmNlPlxuICAgICAgICA8c2NyaXB0PlxuICAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAgICAkc2NvcGUucGVyc29uMSA9ICdJZ29yJztcbiAgICAgICAgICAgICRzY29wZS5wZXJzb24yID0gJ01pc2tvJztcbiAgICAgICAgICAgICRzY29wZS5wZXJzb25Db3VudCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICA8L3NjcmlwdD5cbiAgICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiQ3RybFwiPlxuICAgICAgICAgIFBlcnNvbiAxOjxpbnB1dCB0eXBlPVwidGV4dFwiIG5nLW1vZGVsPVwicGVyc29uMVwiIHZhbHVlPVwiSWdvclwiIC8+PGJyLz5cbiAgICAgICAgICBQZXJzb24gMjo8aW5wdXQgdHlwZT1cInRleHRcIiBuZy1tb2RlbD1cInBlcnNvbjJcIiB2YWx1ZT1cIk1pc2tvXCIgLz48YnIvPlxuICAgICAgICAgIE51bWJlciBvZiBQZW9wbGU6PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmctbW9kZWw9XCJwZXJzb25Db3VudFwiIHZhbHVlPVwiMVwiIC8+PGJyLz5cblxuICAgICAgICAgIDwhLS0tIEV4YW1wbGUgd2l0aCBzaW1wbGUgcGx1cmFsaXphdGlvbiBydWxlcyBmb3IgZW4gbG9jYWxlIC0tLT5cbiAgICAgICAgICBXaXRob3V0IE9mZnNldDpcbiAgICAgICAgICA8bmctcGx1cmFsaXplIGNvdW50PVwicGVyc29uQ291bnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlbj1cInsnMCc6ICdOb2JvZHkgaXMgdmlld2luZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvbmUnOiAnMSBwZXJzb24gaXMgdmlld2luZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7fSBwZW9wbGUgYXJlIHZpZXdpbmcuJ31cIj5cbiAgICAgICAgICA8L25nLXBsdXJhbGl6ZT48YnI+XG5cbiAgICAgICAgICA8IS0tLSBFeGFtcGxlIHdpdGggb2Zmc2V0IC0tLT5cbiAgICAgICAgICBXaXRoIE9mZnNldCgyKTpcbiAgICAgICAgICA8bmctcGx1cmFsaXplIGNvdW50PVwicGVyc29uQ291bnRcIiBvZmZzZXQ9MlxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlbj1cInsnMCc6ICdOb2JvZHkgaXMgdmlld2luZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcxJzogJ3t7cGVyc29uMX19IGlzIHZpZXdpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMic6ICd7e3BlcnNvbjF9fSBhbmQge3twZXJzb24yfX0gYXJlIHZpZXdpbmcuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb25lJzogJ3t7cGVyc29uMX19LCB7e3BlcnNvbjJ9fSBhbmQgb25lIG90aGVyIHBlcnNvbiBhcmUgdmlld2luZy4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvdGhlcic6ICd7e3BlcnNvbjF9fSwge3twZXJzb24yfX0gYW5kIHt9IG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nfVwiPlxuICAgICAgICAgIDwvbmctcGx1cmFsaXplPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZG9jOnNvdXJjZT5cbiAgICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgIGl0KCdzaG91bGQgc2hvdyBjb3JyZWN0IHBsdXJhbGl6ZWQgc3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpmaXJzdCcpLnRleHQoKSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCcxIHBlcnNvbiBpcyB2aWV3aW5nLicpO1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6bGFzdCcpLnRleHQoKSkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdJZ29yIGlzIHZpZXdpbmcuJyk7XG5cbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uQ291bnQnKS5lbnRlcignMCcpO1xuICAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBuZy1wbHVyYWxpemU6Zmlyc3QnKS50ZXh0KCkpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0JlKCdOb2JvZHkgaXMgdmlld2luZy4nKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ05vYm9keSBpcyB2aWV3aW5nLicpO1xuXG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbkNvdW50JykuZW50ZXIoJzInKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnMiBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ0lnb3IgYW5kIE1pc2tvIGFyZSB2aWV3aW5nLicpO1xuXG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbkNvdW50JykuZW50ZXIoJzMnKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnMyBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ0lnb3IsIE1pc2tvIGFuZCBvbmUgb3RoZXIgcGVyc29uIGFyZSB2aWV3aW5nLicpO1xuXG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbkNvdW50JykuZW50ZXIoJzQnKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmZpcnN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9CZSgnNCBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvQmUoJ0lnb3IsIE1pc2tvIGFuZCAyIG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBzaG93IGRhdGEtYmluZGVkIG5hbWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdXNpbmcoJy5kb2MtZXhhbXBsZS1saXZlJykuaW5wdXQoJ3BlcnNvbkNvdW50JykuZW50ZXIoJzQnKTtcbiAgICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgbmctcGx1cmFsaXplOmxhc3QnKS50ZXh0KCkpLlxuICAgICAgICAgICAgICB0b0JlKCdJZ29yLCBNaXNrbyBhbmQgMiBvdGhlciBwZW9wbGUgYXJlIHZpZXdpbmcuJyk7XG5cbiAgICAgICAgICB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5pbnB1dCgncGVyc29uMScpLmVudGVyKCdEaScpO1xuICAgICAgICAgIHVzaW5nKCcuZG9jLWV4YW1wbGUtbGl2ZScpLmlucHV0KCdwZXJzb24yJykuZW50ZXIoJ1ZvanRhJyk7XG4gICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIG5nLXBsdXJhbGl6ZTpsYXN0JykudGV4dCgpKS5cbiAgICAgICAgICAgICAgdG9CZSgnRGksIFZvanRhIGFuZCAyIG90aGVyIHBlb3BsZSBhcmUgdmlld2luZy4nKTtcbiAgICAgICAgfSk7XG4gICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgICA8L2RvYzpleGFtcGxlPlxuICovXG52YXIgbmdQbHVyYWxpemVEaXJlY3RpdmUgPSBbJyRsb2NhbGUnLCAnJGludGVycG9sYXRlJywgZnVuY3Rpb24oJGxvY2FsZSwgJGludGVycG9sYXRlKSB7XG4gIHZhciBCUkFDRSA9IC97fS9nO1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRUEnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgbnVtYmVyRXhwID0gYXR0ci5jb3VudCxcbiAgICAgICAgICB3aGVuRXhwID0gYXR0ci4kYXR0ci53aGVuICYmIGVsZW1lbnQuYXR0cihhdHRyLiRhdHRyLndoZW4pLCAvLyB3ZSBoYXZlIHt7fX0gaW4gYXR0cnNcbiAgICAgICAgICBvZmZzZXQgPSBhdHRyLm9mZnNldCB8fCAwLFxuICAgICAgICAgIHdoZW5zID0gc2NvcGUuJGV2YWwod2hlbkV4cCkgfHwge30sXG4gICAgICAgICAgd2hlbnNFeHBGbnMgPSB7fSxcbiAgICAgICAgICBzdGFydFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpLFxuICAgICAgICAgIGVuZFN5bWJvbCA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKSxcbiAgICAgICAgICBpc1doZW4gPSAvXndoZW4oTWludXMpPyguKykkLztcblxuICAgICAgZm9yRWFjaChhdHRyLCBmdW5jdGlvbihleHByZXNzaW9uLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmIChpc1doZW4udGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIHdoZW5zW2xvd2VyY2FzZShhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoJ3doZW4nLCAnJykucmVwbGFjZSgnTWludXMnLCAnLScpKV0gPVxuICAgICAgICAgICAgZWxlbWVudC5hdHRyKGF0dHIuJGF0dHJbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvckVhY2god2hlbnMsIGZ1bmN0aW9uKGV4cHJlc3Npb24sIGtleSkge1xuICAgICAgICB3aGVuc0V4cEZuc1trZXldID1cbiAgICAgICAgICAkaW50ZXJwb2xhdGUoZXhwcmVzc2lvbi5yZXBsYWNlKEJSQUNFLCBzdGFydFN5bWJvbCArIG51bWJlckV4cCArICctJyArXG4gICAgICAgICAgICBvZmZzZXQgKyBlbmRTeW1ib2wpKTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gbmdQbHVyYWxpemVXYXRjaCgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChzY29wZS4kZXZhbChudW1iZXJFeHApKTtcblxuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgIC8vaWYgZXhwbGljaXQgbnVtYmVyIHJ1bGUgc3VjaCBhcyAxLCAyLCAzLi4uIGlzIGRlZmluZWQsIGp1c3QgdXNlIGl0LiBPdGhlcndpc2UsXG4gICAgICAgICAgLy9jaGVjayBpdCBhZ2FpbnN0IHBsdXJhbGl6YXRpb24gcnVsZXMgaW4gJGxvY2FsZSBzZXJ2aWNlXG4gICAgICAgICAgaWYgKCEodmFsdWUgaW4gd2hlbnMpKSB2YWx1ZSA9ICRsb2NhbGUucGx1cmFsQ2F0KHZhbHVlIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgcmV0dXJuIHdoZW5zRXhwRm5zW3ZhbHVlXShzY29wZSwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiBuZ1BsdXJhbGl6ZVdhdGNoQWN0aW9uKG5ld1ZhbCkge1xuICAgICAgICBlbGVtZW50LnRleHQobmV3VmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBuZ1JlcGVhdGAgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyBhIHRlbXBsYXRlIG9uY2UgcGVyIGl0ZW0gZnJvbSBhIGNvbGxlY3Rpb24uIEVhY2ggdGVtcGxhdGVcbiAqIGluc3RhbmNlIGdldHMgaXRzIG93biBzY29wZSwgd2hlcmUgdGhlIGdpdmVuIGxvb3AgdmFyaWFibGUgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaXRlbSxcbiAqIGFuZCBgJGluZGV4YCBpcyBzZXQgdG8gdGhlIGl0ZW0gaW5kZXggb3Iga2V5LlxuICpcbiAqIFNwZWNpYWwgcHJvcGVydGllcyBhcmUgZXhwb3NlZCBvbiB0aGUgbG9jYWwgc2NvcGUgb2YgZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZSwgaW5jbHVkaW5nOlxuICpcbiAqIHwgVmFyaWFibGUgIHwgVHlwZSAgICAgICAgICAgIHwgRGV0YWlscyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgYCRpbmRleGAgIHwge0B0eXBlIG51bWJlcn0gIHwgaXRlcmF0b3Igb2Zmc2V0IG9mIHRoZSByZXBlYXRlZCBlbGVtZW50ICgwLi5sZW5ndGgtMSkgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCRmaXJzdGAgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgcmVwZWF0ZWQgZWxlbWVudCBpcyBmaXJzdCBpbiB0aGUgaXRlcmF0b3IuICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCRtaWRkbGVgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgcmVwZWF0ZWQgZWxlbWVudCBpcyBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBpbiB0aGUgaXRlcmF0b3IuIHxcbiAqIHwgYCRsYXN0YCAgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgcmVwZWF0ZWQgZWxlbWVudCBpcyBsYXN0IGluIHRoZSBpdGVyYXRvci4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCRldmVuYCAgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgaXRlcmF0b3IgcG9zaXRpb24gYCRpbmRleGAgaXMgZXZlbiAob3RoZXJ3aXNlIGZhbHNlKS4gICAgICAgICAgIHxcbiAqIHwgYCRvZGRgICAgIHwge0B0eXBlIGJvb2xlYW59IHwgdHJ1ZSBpZiB0aGUgaXRlcmF0b3IgcG9zaXRpb24gYCRpbmRleGAgaXMgb2RkIChvdGhlcndpc2UgZmFsc2UpLiAgICAgICAgICAgIHxcbiAqXG4gKlxuICogIyBTcGVjaWFsIHJlcGVhdCBzdGFydCBhbmQgZW5kIHBvaW50c1xuICogVG8gcmVwZWF0IGEgc2VyaWVzIG9mIGVsZW1lbnRzIGluc3RlYWQgb2YganVzdCBvbmUgcGFyZW50IGVsZW1lbnQsIG5nUmVwZWF0IChhcyB3ZWxsIGFzIG90aGVyIG5nIGRpcmVjdGl2ZXMpIHN1cHBvcnRzIGV4dGVuZGluZ1xuICogdGhlIHJhbmdlIG9mIHRoZSByZXBlYXRlciBieSBkZWZpbmluZyBleHBsaWNpdCBzdGFydCBhbmQgZW5kIHBvaW50cyBieSB1c2luZyAqKm5nLXJlcGVhdC1zdGFydCoqIGFuZCAqKm5nLXJlcGVhdC1lbmQqKiByZXNwZWN0aXZlbHkuXG4gKiBUaGUgKipuZy1yZXBlYXQtc3RhcnQqKiBkaXJlY3RpdmUgd29ya3MgdGhlIHNhbWUgYXMgKipuZy1yZXBlYXQqKiwgYnV0IHdpbGwgcmVwZWF0IGFsbCB0aGUgSFRNTCBjb2RlIChpbmNsdWRpbmcgdGhlIHRhZyBpdCdzIGRlZmluZWQgb24pXG4gKiB1cCB0byBhbmQgaW5jbHVkaW5nIHRoZSBlbmRpbmcgSFRNTCB0YWcgd2hlcmUgKipuZy1yZXBlYXQtZW5kKiogaXMgcGxhY2VkLlxuICpcbiAqIFRoZSBleGFtcGxlIGJlbG93IG1ha2VzIHVzZSBvZiB0aGlzIGZlYXR1cmU6XG4gKiA8cHJlPlxuICogICA8aGVhZGVyIG5nLXJlcGVhdC1zdGFydD1cIml0ZW0gaW4gaXRlbXNcIj5cbiAqICAgICBIZWFkZXIge3sgaXRlbSB9fVxuICogICA8L2hlYWRlcj5cbiAqICAgPGRpdiBjbGFzcz1cImJvZHlcIj5cbiAqICAgICBCb2R5IHt7IGl0ZW0gfX1cbiAqICAgPC9kaXY+XG4gKiAgIDxmb290ZXIgbmctcmVwZWF0LWVuZD5cbiAqICAgICBGb290ZXIge3sgaXRlbSB9fVxuICogICA8L2Zvb3Rlcj5cbiAqIDwvcHJlPlxuICpcbiAqIEFuZCB3aXRoIGFuIGlucHV0IG9mIHtAdHlwZSBbJ0EnLCdCJ119IGZvciB0aGUgaXRlbXMgdmFyaWFibGUgaW4gdGhlIGV4YW1wbGUgYWJvdmUsIHRoZSBvdXRwdXQgd2lsbCBldmFsdWF0ZSB0bzpcbiAqIDxwcmU+XG4gKiAgIDxoZWFkZXI+XG4gKiAgICAgSGVhZGVyIEFcbiAqICAgPC9oZWFkZXI+XG4gKiAgIDxkaXYgY2xhc3M9XCJib2R5XCI+XG4gKiAgICAgQm9keSBBXG4gKiAgIDwvZGl2PlxuICogICA8Zm9vdGVyPlxuICogICAgIEZvb3RlciBBXG4gKiAgIDwvZm9vdGVyPlxuICogICA8aGVhZGVyPlxuICogICAgIEhlYWRlciBCXG4gKiAgIDwvaGVhZGVyPlxuICogICA8ZGl2IGNsYXNzPVwiYm9keVwiPlxuICogICAgIEJvZHkgQlxuICogICA8L2Rpdj5cbiAqICAgPGZvb3Rlcj5cbiAqICAgICBGb290ZXIgQlxuICogICA8L2Zvb3Rlcj5cbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBjdXN0b20gc3RhcnQgYW5kIGVuZCBwb2ludHMgZm9yIG5nUmVwZWF0IGFsc28gc3VwcG9ydCBhbGwgb3RoZXIgSFRNTCBkaXJlY3RpdmUgc3ludGF4IGZsYXZvcnMgcHJvdmlkZWQgaW4gQW5ndWxhckpTIChzdWNoXG4gKiBhcyAqKmRhdGEtbmctcmVwZWF0LXN0YXJ0KiosICoqeC1uZy1yZXBlYXQtc3RhcnQqKiBhbmQgKipuZzpyZXBlYXQtc3RhcnQqKikuXG4gKlxuICogQGFuaW1hdGlvbnNcbiAqIGVudGVyIC0gd2hlbiBhIG5ldyBpdGVtIGlzIGFkZGVkIHRvIHRoZSBsaXN0IG9yIHdoZW4gYW4gaXRlbSBpcyByZXZlYWxlZCBhZnRlciBhIGZpbHRlclxuICogbGVhdmUgLSB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0IG9yIHdoZW4gYW4gaXRlbSBpcyBmaWx0ZXJlZCBvdXRcbiAqIG1vdmUgLSB3aGVuIGFuIGFkamFjZW50IGl0ZW0gaXMgZmlsdGVyZWQgb3V0IGNhdXNpbmcgYSByZW9yZGVyIG9yIHdoZW4gdGhlIGl0ZW0gY29udGVudHMgYXJlIHJlb3JkZXJlZFxuICpcbiAqIEBlbGVtZW50IEFOWVxuICogQHNjb3BlXG4gKiBAcHJpb3JpdHkgMTAwMFxuICogQHBhcmFtIHtyZXBlYXRfZXhwcmVzc2lvbn0gbmdSZXBlYXQgVGhlIGV4cHJlc3Npb24gaW5kaWNhdGluZyBob3cgdG8gZW51bWVyYXRlIGEgY29sbGVjdGlvbi4gVGhlc2VcbiAqICAgZm9ybWF0cyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDpcbiAqXG4gKiAgICogYHZhcmlhYmxlIGluIGV4cHJlc3Npb25gIOKAkyB3aGVyZSB2YXJpYWJsZSBpcyB0aGUgdXNlciBkZWZpbmVkIGxvb3AgdmFyaWFibGUgYW5kIGBleHByZXNzaW9uYFxuICogICAgIGlzIGEgc2NvcGUgZXhwcmVzc2lvbiBnaXZpbmcgdGhlIGNvbGxlY3Rpb24gdG8gZW51bWVyYXRlLlxuICpcbiAqICAgICBGb3IgZXhhbXBsZTogYGFsYnVtIGluIGFydGlzdC5hbGJ1bXNgLlxuICpcbiAqICAgKiBgKGtleSwgdmFsdWUpIGluIGV4cHJlc3Npb25gIOKAkyB3aGVyZSBga2V5YCBhbmQgYHZhbHVlYCBjYW4gYmUgYW55IHVzZXIgZGVmaW5lZCBpZGVudGlmaWVycyxcbiAqICAgICBhbmQgYGV4cHJlc3Npb25gIGlzIHRoZSBzY29wZSBleHByZXNzaW9uIGdpdmluZyB0aGUgY29sbGVjdGlvbiB0byBlbnVtZXJhdGUuXG4gKlxuICogICAgIEZvciBleGFtcGxlOiBgKG5hbWUsIGFnZSkgaW4geydhZGFtJzoxMCwgJ2FtYWxpZSc6MTJ9YC5cbiAqXG4gKiAgICogYHZhcmlhYmxlIGluIGV4cHJlc3Npb24gdHJhY2sgYnkgdHJhY2tpbmdfZXhwcmVzc2lvbmAg4oCTIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIG9wdGlvbmFsIHRyYWNraW5nIGZ1bmN0aW9uXG4gKiAgICAgd2hpY2ggY2FuIGJlIHVzZWQgdG8gYXNzb2NpYXRlIHRoZSBvYmplY3RzIGluIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIERPTSBlbGVtZW50cy4gSWYgbm8gdHJhY2tpbmcgZnVuY3Rpb25cbiAqICAgICBpcyBzcGVjaWZpZWQgdGhlIG5nLXJlcGVhdCBhc3NvY2lhdGVzIGVsZW1lbnRzIGJ5IGlkZW50aXR5IGluIHRoZSBjb2xsZWN0aW9uLiBJdCBpcyBhbiBlcnJvciB0byBoYXZlXG4gKiAgICAgbW9yZSB0aGFuIG9uZSB0cmFja2luZyBmdW5jdGlvbiB0byByZXNvbHZlIHRvIHRoZSBzYW1lIGtleS4gKFRoaXMgd291bGQgbWVhbiB0aGF0IHR3byBkaXN0aW5jdCBvYmplY3RzIGFyZVxuICogICAgIG1hcHBlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudCwgd2hpY2ggaXMgbm90IHBvc3NpYmxlLikgIEZpbHRlcnMgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGV4cHJlc3Npb24sXG4gKiAgICAgYmVmb3JlIHNwZWNpZnlpbmcgYSB0cmFja2luZyBleHByZXNzaW9uLlxuICpcbiAqICAgICBGb3IgZXhhbXBsZTogYGl0ZW0gaW4gaXRlbXNgIGlzIGVxdWl2YWxlbnQgdG8gYGl0ZW0gaW4gaXRlbXMgdHJhY2sgYnkgJGlkKGl0ZW0pJy4gVGhpcyBpbXBsaWVzIHRoYXQgdGhlIERPTSBlbGVtZW50c1xuICogICAgIHdpbGwgYmUgYXNzb2NpYXRlZCBieSBpdGVtIGlkZW50aXR5IGluIHRoZSBhcnJheS5cbiAqXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBpdGVtIGluIGl0ZW1zIHRyYWNrIGJ5ICRpZChpdGVtKWAuIEEgYnVpbHQgaW4gYCRpZCgpYCBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBhc3NpZ24gYSB1bmlxdWVcbiAqICAgICBgJCRoYXNoS2V5YCBwcm9wZXJ0eSB0byBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LiBUaGlzIHByb3BlcnR5IGlzIHRoZW4gdXNlZCBhcyBhIGtleSB0byBhc3NvY2lhdGVkIERPTSBlbGVtZW50c1xuICogICAgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgaXRlbSBpbiB0aGUgYXJyYXkgYnkgaWRlbnRpdHkuIE1vdmluZyB0aGUgc2FtZSBvYmplY3QgaW4gYXJyYXkgd291bGQgbW92ZSB0aGUgRE9NXG4gKiAgICAgZWxlbWVudCBpbiB0aGUgc2FtZSB3YXkgaW4gdGhlIERPTS5cbiAqXG4gKiAgICAgRm9yIGV4YW1wbGU6IGBpdGVtIGluIGl0ZW1zIHRyYWNrIGJ5IGl0ZW0uaWRgIGlzIGEgdHlwaWNhbCBwYXR0ZXJuIHdoZW4gdGhlIGl0ZW1zIGNvbWUgZnJvbSB0aGUgZGF0YWJhc2UuIEluIHRoaXNcbiAqICAgICBjYXNlIHRoZSBvYmplY3QgaWRlbnRpdHkgZG9lcyBub3QgbWF0dGVyLiBUd28gb2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50IGFzIGxvbmcgYXMgdGhlaXIgYGlkYFxuICogICAgIHByb3BlcnR5IGlzIHNhbWUuXG4gKlxuICogICAgIEZvciBleGFtcGxlOiBgaXRlbSBpbiBpdGVtcyB8IGZpbHRlcjpzZWFyY2hUZXh0IHRyYWNrIGJ5IGl0ZW0uaWRgIGlzIGEgcGF0dGVybiB0aGF0IG1pZ2h0IGJlIHVzZWQgdG8gYXBwbHkgYSBmaWx0ZXJcbiAqICAgICB0byBpdGVtcyBpbiBjb25qdW5jdGlvbiB3aXRoIGEgdHJhY2tpbmcgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhpcyBleGFtcGxlIGluaXRpYWxpemVzIHRoZSBzY29wZSB0byBhIGxpc3Qgb2YgbmFtZXMgYW5kXG4gKiB0aGVuIHVzZXMgYG5nUmVwZWF0YCB0byBkaXNwbGF5IGV2ZXJ5IHBlcnNvbjpcbiAgPGV4YW1wbGUgYW5pbWF0aW9ucz1cInRydWVcIj5cbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgPGRpdiBuZy1pbml0PVwiZnJpZW5kcyA9IFtcbiAgICAgICAge25hbWU6J0pvaG4nLCBhZ2U6MjUsIGdlbmRlcjonYm95J30sXG4gICAgICAgIHtuYW1lOidKZXNzaWUnLCBhZ2U6MzAsIGdlbmRlcjonZ2lybCd9LFxuICAgICAgICB7bmFtZTonSm9oYW5uYScsIGFnZToyOCwgZ2VuZGVyOidnaXJsJ30sXG4gICAgICAgIHtuYW1lOidKb3knLCBhZ2U6MTUsIGdlbmRlcjonZ2lybCd9LFxuICAgICAgICB7bmFtZTonTWFyeScsIGFnZToyOCwgZ2VuZGVyOidnaXJsJ30sXG4gICAgICAgIHtuYW1lOidQZXRlcicsIGFnZTo5NSwgZ2VuZGVyOidib3knfSxcbiAgICAgICAge25hbWU6J1NlYmFzdGlhbicsIGFnZTo1MCwgZ2VuZGVyOidib3knfSxcbiAgICAgICAge25hbWU6J0VyaWthJywgYWdlOjI3LCBnZW5kZXI6J2dpcmwnfSxcbiAgICAgICAge25hbWU6J1BhdHJpY2snLCBhZ2U6NDAsIGdlbmRlcjonYm95J30sXG4gICAgICAgIHtuYW1lOidTYW1hbnRoYScsIGFnZTo2MCwgZ2VuZGVyOidnaXJsJ31cbiAgICAgIF1cIj5cbiAgICAgICAgSSBoYXZlIHt7ZnJpZW5kcy5sZW5ndGh9fSBmcmllbmRzLiBUaGV5IGFyZTpcbiAgICAgICAgPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBuZy1tb2RlbD1cInFcIiBwbGFjZWhvbGRlcj1cImZpbHRlciBmcmllbmRzLi4uXCIgLz5cbiAgICAgICAgPHVsIGNsYXNzPVwiZXhhbXBsZS1hbmltYXRlLWNvbnRhaW5lclwiPlxuICAgICAgICAgIDxsaSBjbGFzcz1cImFuaW1hdGUtcmVwZWF0XCIgbmctcmVwZWF0PVwiZnJpZW5kIGluIGZyaWVuZHMgfCBmaWx0ZXI6cVwiPlxuICAgICAgICAgICAgW3t7JGluZGV4ICsgMX19XSB7e2ZyaWVuZC5uYW1lfX0gd2hvIGlzIHt7ZnJpZW5kLmFnZX19IHllYXJzIG9sZC5cbiAgICAgICAgICA8L2xpPlxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxuICAgICAgLmV4YW1wbGUtYW5pbWF0ZS1jb250YWluZXIge1xuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBsaXN0LXN0eWxlOm5vbmU7XG4gICAgICAgIG1hcmdpbjowO1xuICAgICAgICBwYWRkaW5nOjAgMTBweDtcbiAgICAgIH1cblxuICAgICAgLmFuaW1hdGUtcmVwZWF0IHtcbiAgICAgICAgbGluZS1oZWlnaHQ6NDBweDtcbiAgICAgICAgbGlzdC1zdHlsZTpub25lO1xuICAgICAgICBib3gtc2l6aW5nOmJvcmRlci1ib3g7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1tb3ZlLFxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLWVudGVyLFxuICAgICAgLmFuaW1hdGUtcmVwZWF0Lm5nLWxlYXZlIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgbGluZWFyIDAuNXM7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1sZWF2ZS5uZy1sZWF2ZS1hY3RpdmUsXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctbW92ZSxcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1lbnRlciB7XG4gICAgICAgIG9wYWNpdHk6MDtcbiAgICAgICAgbWF4LWhlaWdodDowO1xuICAgICAgfVxuXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctbGVhdmUsXG4gICAgICAuYW5pbWF0ZS1yZXBlYXQubmctbW92ZS5uZy1tb3ZlLWFjdGl2ZSxcbiAgICAgIC5hbmltYXRlLXJlcGVhdC5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xuICAgICAgICBvcGFjaXR5OjE7XG4gICAgICAgIG1heC1oZWlnaHQ6NDBweDtcbiAgICAgIH1cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gICAgICAgaXQoJ3Nob3VsZCByZW5kZXIgaW5pdGlhbCBkYXRhIHNldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgdmFyIHIgPSB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5yZXBlYXRlcigndWwgbGknKTtcbiAgICAgICAgIGV4cGVjdChyLmNvdW50KCkpLnRvQmUoMTApO1xuICAgICAgICAgZXhwZWN0KHIucm93KDApKS50b0VxdWFsKFtcIjFcIixcIkpvaG5cIixcIjI1XCJdKTtcbiAgICAgICAgIGV4cGVjdChyLnJvdygxKSkudG9FcXVhbChbXCIyXCIsXCJKZXNzaWVcIixcIjMwXCJdKTtcbiAgICAgICAgIGV4cGVjdChyLnJvdyg5KSkudG9FcXVhbChbXCIxMFwiLFwiU2FtYW50aGFcIixcIjYwXCJdKTtcbiAgICAgICAgIGV4cGVjdChiaW5kaW5nKCdmcmllbmRzLmxlbmd0aCcpKS50b0JlKFwiMTBcIik7XG4gICAgICAgfSk7XG5cbiAgICAgICBpdCgnc2hvdWxkIHVwZGF0ZSByZXBlYXRlciB3aGVuIGZpbHRlciBwcmVkaWNhdGUgY2hhbmdlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgdmFyIHIgPSB1c2luZygnLmRvYy1leGFtcGxlLWxpdmUnKS5yZXBlYXRlcigndWwgbGknKTtcbiAgICAgICAgIGV4cGVjdChyLmNvdW50KCkpLnRvQmUoMTApO1xuXG4gICAgICAgICBpbnB1dCgncScpLmVudGVyKCdtYScpO1xuXG4gICAgICAgICBleHBlY3Qoci5jb3VudCgpKS50b0JlKDIpO1xuICAgICAgICAgZXhwZWN0KHIucm93KDApKS50b0VxdWFsKFtcIjFcIixcIk1hcnlcIixcIjI4XCJdKTtcbiAgICAgICAgIGV4cGVjdChyLnJvdygxKSkudG9FcXVhbChbXCIyXCIsXCJTYW1hbnRoYVwiLFwiNjBcIl0pO1xuICAgICAgIH0pO1xuICAgICAgPC9maWxlPlxuICAgIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nUmVwZWF0RGlyZWN0aXZlID0gWyckcGFyc2UnLCAnJGFuaW1hdGUnLCBmdW5jdGlvbigkcGFyc2UsICRhbmltYXRlKSB7XG4gIHZhciBOR19SRU1PVkVEID0gJyQkTkdfUkVNT1ZFRCc7XG4gIHZhciBuZ1JlcGVhdE1pbkVyciA9IG1pbkVycignbmdSZXBlYXQnKTtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gICAgcHJpb3JpdHk6IDEwMDAsXG4gICAgdGVybWluYWw6IHRydWUsXG4gICAgJCR0bGI6IHRydWUsXG4gICAgbGluazogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHIsIGN0cmwsICR0cmFuc2NsdWRlKXtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSAkYXR0ci5uZ1JlcGVhdDtcbiAgICAgICAgdmFyIG1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaCgvXlxccyooLispXFxzK2luXFxzKyhbXFxyXFxuXFxzXFxTXSo/KVxccyooXFxzK3RyYWNrXFxzK2J5XFxzKyguKylcXHMqKT8kLyksXG4gICAgICAgICAgdHJhY2tCeUV4cCwgdHJhY2tCeUV4cEdldHRlciwgdHJhY2tCeUlkRXhwRm4sIHRyYWNrQnlJZEFycmF5Rm4sIHRyYWNrQnlJZE9iakZuLFxuICAgICAgICAgIGxocywgcmhzLCB2YWx1ZUlkZW50aWZpZXIsIGtleUlkZW50aWZpZXIsXG4gICAgICAgICAgaGFzaEZuTG9jYWxzID0geyRpZDogaGFzaEtleX07XG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIHRocm93IG5nUmVwZWF0TWluRXJyKCdpZXhwJywgXCJFeHBlY3RlZCBleHByZXNzaW9uIGluIGZvcm0gb2YgJ19pdGVtXyBpbiBfY29sbGVjdGlvbl9bIHRyYWNrIGJ5IF9pZF9dJyBidXQgZ290ICd7MH0nLlwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsaHMgPSBtYXRjaFsxXTtcbiAgICAgICAgcmhzID0gbWF0Y2hbMl07XG4gICAgICAgIHRyYWNrQnlFeHAgPSBtYXRjaFs0XTtcblxuICAgICAgICBpZiAodHJhY2tCeUV4cCkge1xuICAgICAgICAgIHRyYWNrQnlFeHBHZXR0ZXIgPSAkcGFyc2UodHJhY2tCeUV4cCk7XG4gICAgICAgICAgdHJhY2tCeUlkRXhwRm4gPSBmdW5jdGlvbihrZXksIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gYXNzaWduIGtleSwgdmFsdWUsIGFuZCAkaW5kZXggdG8gdGhlIGxvY2FscyBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgaW4gaGFzaCBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmIChrZXlJZGVudGlmaWVyKSBoYXNoRm5Mb2NhbHNba2V5SWRlbnRpZmllcl0gPSBrZXk7XG4gICAgICAgICAgICBoYXNoRm5Mb2NhbHNbdmFsdWVJZGVudGlmaWVyXSA9IHZhbHVlO1xuICAgICAgICAgICAgaGFzaEZuTG9jYWxzLiRpbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrQnlFeHBHZXR0ZXIoJHNjb3BlLCBoYXNoRm5Mb2NhbHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhY2tCeUlkQXJyYXlGbiA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNoS2V5KHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYWNrQnlJZE9iakZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaCA9IGxocy5tYXRjaCgvXig/OihbXFwkXFx3XSspfFxcKChbXFwkXFx3XSspXFxzKixcXHMqKFtcXCRcXHddKylcXCkpJC8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgdGhyb3cgbmdSZXBlYXRNaW5FcnIoJ2lpZGV4cCcsIFwiJ19pdGVtXycgaW4gJ19pdGVtXyBpbiBfY29sbGVjdGlvbl8nIHNob3VsZCBiZSBhbiBpZGVudGlmaWVyIG9yICcoX2tleV8sIF92YWx1ZV8pJyBleHByZXNzaW9uLCBidXQgZ290ICd7MH0nLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlSWRlbnRpZmllciA9IG1hdGNoWzNdIHx8IG1hdGNoWzFdO1xuICAgICAgICBrZXlJZGVudGlmaWVyID0gbWF0Y2hbMl07XG5cbiAgICAgICAgLy8gU3RvcmUgYSBsaXN0IG9mIGVsZW1lbnRzIGZyb20gcHJldmlvdXMgcnVuLiBUaGlzIGlzIGEgaGFzaCB3aGVyZSBrZXkgaXMgdGhlIGl0ZW0gZnJvbSB0aGVcbiAgICAgICAgLy8gaXRlcmF0b3IsIGFuZCB0aGUgdmFsdWUgaXMgb2JqZWN0cyB3aXRoIGZvbGxvd2luZyBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyAgIC0gc2NvcGU6IGJvdW5kIHNjb3BlXG4gICAgICAgIC8vICAgLSBlbGVtZW50OiBwcmV2aW91cyBlbGVtZW50LlxuICAgICAgICAvLyAgIC0gaW5kZXg6IHBvc2l0aW9uXG4gICAgICAgIHZhciBsYXN0QmxvY2tNYXAgPSB7fTtcblxuICAgICAgICAvL3dhdGNoIHByb3BzXG4gICAgICAgICRzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKHJocywgZnVuY3Rpb24gbmdSZXBlYXRBY3Rpb24oY29sbGVjdGlvbil7XG4gICAgICAgICAgdmFyIGluZGV4LCBsZW5ndGgsXG4gICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9ICRlbGVtZW50WzBdLCAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgICBuZXh0Tm9kZSxcbiAgICAgICAgICAgICAgLy8gU2FtZSBhcyBsYXN0QmxvY2tNYXAgYnV0IGl0IGhhcyB0aGUgY3VycmVudCBzdGF0ZS4gSXQgd2lsbCBiZWNvbWUgdGhlXG4gICAgICAgICAgICAgIC8vIGxhc3RCbG9ja01hcCBvbiB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgIG5leHRCbG9ja01hcCA9IHt9LFxuICAgICAgICAgICAgICBhcnJheUxlbmd0aCxcbiAgICAgICAgICAgICAgY2hpbGRTY29wZSxcbiAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgLy8ga2V5L3ZhbHVlIG9mIGl0ZXJhdGlvblxuICAgICAgICAgICAgICB0cmFja0J5SWQsXG4gICAgICAgICAgICAgIHRyYWNrQnlJZEZuLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uS2V5cyxcbiAgICAgICAgICAgICAgYmxvY2ssICAgICAgIC8vIGxhc3Qgb2JqZWN0IGluZm9ybWF0aW9uIHtzY29wZSwgZWxlbWVudCwgaWR9XG4gICAgICAgICAgICAgIG5leHRCbG9ja09yZGVyID0gW10sXG4gICAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmU7XG5cblxuICAgICAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbktleXMgPSBjb2xsZWN0aW9uO1xuICAgICAgICAgICAgdHJhY2tCeUlkRm4gPSB0cmFja0J5SWRFeHBGbiB8fCB0cmFja0J5SWRBcnJheUZuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFja0J5SWRGbiA9IHRyYWNrQnlJZEV4cEZuIHx8IHRyYWNrQnlJZE9iakZuO1xuICAgICAgICAgICAgLy8gaWYgb2JqZWN0LCBleHRyYWN0IGtleXMsIHNvcnQgdGhlbSBhbmQgdXNlIHRvIGRldGVybWluZSBvcmRlciBvZiBpdGVyYXRpb24gb3ZlciBvYmogcHJvcHNcbiAgICAgICAgICAgIGNvbGxlY3Rpb25LZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9uLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5LmNoYXJBdCgwKSAhPSAnJCcpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbGxlY3Rpb25LZXlzLnNvcnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheUxlbmd0aCA9IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDtcblxuICAgICAgICAgIC8vIGxvY2F0ZSBleGlzdGluZyBpdGVtc1xuICAgICAgICAgIGxlbmd0aCA9IG5leHRCbG9ja09yZGVyLmxlbmd0aCA9IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDtcbiAgICAgICAgICBmb3IoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICBrZXkgPSAoY29sbGVjdGlvbiA9PT0gY29sbGVjdGlvbktleXMpID8gaW5kZXggOiBjb2xsZWN0aW9uS2V5c1tpbmRleF07XG4gICAgICAgICAgIHZhbHVlID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICAgICB0cmFja0J5SWQgPSB0cmFja0J5SWRGbihrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgIGFzc2VydE5vdEhhc093blByb3BlcnR5KHRyYWNrQnlJZCwgJ2B0cmFjayBieWAgaWQnKTtcbiAgICAgICAgICAgaWYobGFzdEJsb2NrTWFwLmhhc093blByb3BlcnR5KHRyYWNrQnlJZCkpIHtcbiAgICAgICAgICAgICBibG9jayA9IGxhc3RCbG9ja01hcFt0cmFja0J5SWRdO1xuICAgICAgICAgICAgIGRlbGV0ZSBsYXN0QmxvY2tNYXBbdHJhY2tCeUlkXTtcbiAgICAgICAgICAgICBuZXh0QmxvY2tNYXBbdHJhY2tCeUlkXSA9IGJsb2NrO1xuICAgICAgICAgICAgIG5leHRCbG9ja09yZGVyW2luZGV4XSA9IGJsb2NrO1xuICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRCbG9ja01hcC5oYXNPd25Qcm9wZXJ0eSh0cmFja0J5SWQpKSB7XG4gICAgICAgICAgICAgLy8gcmVzdG9yZSBsYXN0QmxvY2tNYXBcbiAgICAgICAgICAgICBmb3JFYWNoKG5leHRCbG9ja09yZGVyLCBmdW5jdGlvbihibG9jaykge1xuICAgICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLnNjb3BlKSBsYXN0QmxvY2tNYXBbYmxvY2suaWRdID0gYmxvY2s7XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGR1cGxpY2F0ZSBhbmQgd2UgbmVlZCB0byB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgIHRocm93IG5nUmVwZWF0TWluRXJyKCdkdXBlcycsIFwiRHVwbGljYXRlcyBpbiBhIHJlcGVhdGVyIGFyZSBub3QgYWxsb3dlZC4gVXNlICd0cmFjayBieScgZXhwcmVzc2lvbiB0byBzcGVjaWZ5IHVuaXF1ZSBrZXlzLiBSZXBlYXRlcjogezB9LCBEdXBsaWNhdGUga2V5OiB7MX1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLCAgICAgICB0cmFja0J5SWQpO1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgIC8vIG5ldyBuZXZlciBiZWZvcmUgc2VlbiBibG9ja1xuICAgICAgICAgICAgIG5leHRCbG9ja09yZGVyW2luZGV4XSA9IHsgaWQ6IHRyYWNrQnlJZCB9O1xuICAgICAgICAgICAgIG5leHRCbG9ja01hcFt0cmFja0J5SWRdID0gZmFsc2U7XG4gICAgICAgICAgIH1cbiAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyBpdGVtc1xuICAgICAgICAgIGZvciAoa2V5IGluIGxhc3RCbG9ja01hcCkge1xuICAgICAgICAgICAgLy8gbGFzdEJsb2NrTWFwIGlzIG91ciBvd24gb2JqZWN0IHNvIHdlIGRvbid0IG5lZWQgdG8gdXNlIHNwZWNpYWwgaGFzT3duUHJvcGVydHlGblxuICAgICAgICAgICAgaWYgKGxhc3RCbG9ja01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIGJsb2NrID0gbGFzdEJsb2NrTWFwW2tleV07XG4gICAgICAgICAgICAgIGVsZW1lbnRzVG9SZW1vdmUgPSBnZXRCbG9ja0VsZW1lbnRzKGJsb2NrLmNsb25lKTtcbiAgICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudHNUb1JlbW92ZSk7XG4gICAgICAgICAgICAgIGZvckVhY2goZWxlbWVudHNUb1JlbW92ZSwgZnVuY3Rpb24oZWxlbWVudCkgeyBlbGVtZW50W05HX1JFTU9WRURdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICAgIGJsb2NrLnNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBmb3JFYWNoIGZvciBwZXJmIHJlYXNvbnMgKHRyeWluZyB0byBhdm9pZCAjY2FsbClcbiAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gY29sbGVjdGlvbktleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAga2V5ID0gKGNvbGxlY3Rpb24gPT09IGNvbGxlY3Rpb25LZXlzKSA/IGluZGV4IDogY29sbGVjdGlvbktleXNbaW5kZXhdO1xuICAgICAgICAgICAgdmFsdWUgPSBjb2xsZWN0aW9uW2tleV07XG4gICAgICAgICAgICBibG9jayA9IG5leHRCbG9ja09yZGVyW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChuZXh0QmxvY2tPcmRlcltpbmRleCAtIDFdKSBwcmV2aW91c05vZGUgPSBnZXRCbG9ja0VuZChuZXh0QmxvY2tPcmRlcltpbmRleCAtIDFdKTtcblxuICAgICAgICAgICAgaWYgKGJsb2NrLnNjb3BlKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYWxyZWFkeSBzZWVuIHRoaXMgb2JqZWN0LCB0aGVuIHdlIG5lZWQgdG8gcmV1c2UgdGhlXG4gICAgICAgICAgICAgIC8vIGFzc29jaWF0ZWQgc2NvcGUvZWxlbWVudFxuICAgICAgICAgICAgICBjaGlsZFNjb3BlID0gYmxvY2suc2NvcGU7XG5cbiAgICAgICAgICAgICAgbmV4dE5vZGUgPSBwcmV2aW91c05vZGU7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICB9IHdoaWxlKG5leHROb2RlICYmIG5leHROb2RlW05HX1JFTU9WRURdKTtcblxuICAgICAgICAgICAgICBpZiAoZ2V0QmxvY2tTdGFydChibG9jaykgIT0gbmV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBpdGVtIHdoaWNoIGdvdCBtb3ZlZFxuICAgICAgICAgICAgICAgICRhbmltYXRlLm1vdmUoZ2V0QmxvY2tFbGVtZW50cyhibG9jay5jbG9uZSksIG51bGwsIGpxTGl0ZShwcmV2aW91c05vZGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSBnZXRCbG9ja0VuZChibG9jayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBuZXcgaXRlbSB3aGljaCB3ZSBkb24ndCBrbm93IGFib3V0XG4gICAgICAgICAgICAgIGNoaWxkU2NvcGUgPSAkc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZFNjb3BlW3ZhbHVlSWRlbnRpZmllcl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChrZXlJZGVudGlmaWVyKSBjaGlsZFNjb3BlW2tleUlkZW50aWZpZXJdID0ga2V5O1xuICAgICAgICAgICAgY2hpbGRTY29wZS4kaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJGZpcnN0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJGxhc3QgPSAoaW5kZXggPT09IChhcnJheUxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJG1pZGRsZSA9ICEoY2hpbGRTY29wZS4kZmlyc3QgfHwgY2hpbGRTY29wZS4kbGFzdCk7XG4gICAgICAgICAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2VcbiAgICAgICAgICAgIGNoaWxkU2NvcGUuJG9kZCA9ICEoY2hpbGRTY29wZS4kZXZlbiA9IChpbmRleCYxKSA9PT0gMCk7XG4gICAgICAgICAgICAvLyBqc2hpbnQgYml0d2lzZTogdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoIWJsb2NrLnNjb3BlKSB7XG4gICAgICAgICAgICAgICR0cmFuc2NsdWRlKGNoaWxkU2NvcGUsIGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVbY2xvbmUubGVuZ3RoKytdID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIGVuZCBuZ1JlcGVhdDogJyArIGV4cHJlc3Npb24gKyAnICcpO1xuICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGNsb25lLCBudWxsLCBqcUxpdGUocHJldmlvdXNOb2RlKSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gY2xvbmU7XG4gICAgICAgICAgICAgICAgYmxvY2suc2NvcGUgPSBjaGlsZFNjb3BlO1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9ubHkgbmVlZCB0aGUgZmlyc3QvbGFzdCBub2RlIG9mIHRoZSBjbG9uZWQgbm9kZXMuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgbmVlZCB0byBrZWVwIHRoZSByZWZlcmVuY2UgdG8gdGhlIGpxbGl0ZSB3cmFwcGVyIGFzIGl0IG1pZ2h0IGJlIGNoYW5nZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAvLyBieSBhIGRpcmVjdGl2ZSB3aXRoIHRlbXBsYXRlVXJsIHdoZW4gaXQncyB0ZW1wbGF0ZSBhcnJpdmVzLlxuICAgICAgICAgICAgICAgIGJsb2NrLmNsb25lID0gY2xvbmU7XG4gICAgICAgICAgICAgICAgbmV4dEJsb2NrTWFwW2Jsb2NrLmlkXSA9IGJsb2NrO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdEJsb2NrTWFwID0gbmV4dEJsb2NrTWFwO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QmxvY2tTdGFydChibG9jaykge1xuICAgIHJldHVybiBibG9jay5jbG9uZVswXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrRW5kKGJsb2NrKSB7XG4gICAgcmV0dXJuIGJsb2NrLmNsb25lW2Jsb2NrLmNsb25lLmxlbmd0aCAtIDFdO1xuICB9XG59XTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTaG93XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nU2hvd2AgZGlyZWN0aXZlIHNob3dzIG9yIGhpZGVzIHRoZSBnaXZlbiBIVE1MIGVsZW1lbnQgYmFzZWQgb24gdGhlIGV4cHJlc3Npb25cbiAqIHByb3ZpZGVkIHRvIHRoZSBuZ1Nob3cgYXR0cmlidXRlLiBUaGUgZWxlbWVudCBpcyBzaG93biBvciBoaWRkZW4gYnkgcmVtb3Zpbmcgb3IgYWRkaW5nXG4gKiB0aGUgYG5nLWhpZGVgIENTUyBjbGFzcyBvbnRvIHRoZSBlbGVtZW50LiBUaGUgYC5uZy1oaWRlYCBDU1MgY2xhc3MgaXMgcHJlZGVmaW5lZFxuICogaW4gQW5ndWxhckpTIGFuZCBzZXRzIHRoZSBkaXNwbGF5IHN0eWxlIHRvIG5vbmUgKHVzaW5nIGFuICFpbXBvcnRhbnQgZmxhZykuXG4gKiBGb3IgQ1NQIG1vZGUgcGxlYXNlIGFkZCBgYW5ndWxhci1jc3AuY3NzYCB0byB5b3VyIGh0bWwgZmlsZSAoc2VlIHtAbGluayBuZy5kaXJlY3RpdmU6bmdDc3AgbmdDc3B9KS5cbiAqXG4gKiA8cHJlPlxuICogPCEtLSB3aGVuICRzY29wZS5teVZhbHVlIGlzIHRydXRoeSAoZWxlbWVudCBpcyB2aXNpYmxlKSAtLT5cbiAqIDxkaXYgbmctc2hvdz1cIm15VmFsdWVcIj48L2Rpdj5cbiAqXG4gKiA8IS0tIHdoZW4gJHNjb3BlLm15VmFsdWUgaXMgZmFsc3kgKGVsZW1lbnQgaXMgaGlkZGVuKSAtLT5cbiAqIDxkaXYgbmctc2hvdz1cIm15VmFsdWVcIiBjbGFzcz1cIm5nLWhpZGVcIj48L2Rpdj5cbiAqIDwvcHJlPlxuICpcbiAqIFdoZW4gdGhlIG5nU2hvdyBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBmYWxzZSB0aGVuIHRoZSBuZy1oaWRlIENTUyBjbGFzcyBpcyBhZGRlZCB0byB0aGUgY2xhc3MgYXR0cmlidXRlXG4gKiBvbiB0aGUgZWxlbWVudCBjYXVzaW5nIGl0IHRvIGJlY29tZSBoaWRkZW4uIFdoZW4gdHJ1ZSwgdGhlIG5nLWhpZGUgQ1NTIGNsYXNzIGlzIHJlbW92ZWRcbiAqIGZyb20gdGhlIGVsZW1lbnQgY2F1c2luZyB0aGUgZWxlbWVudCBub3QgdG8gYXBwZWFyIGhpZGRlbi5cbiAqXG4gKiAjIyBXaHkgaXMgIWltcG9ydGFudCB1c2VkP1xuICpcbiAqIFlvdSBtYXkgYmUgd29uZGVyaW5nIHdoeSAhaW1wb3J0YW50IGlzIHVzZWQgZm9yIHRoZSAubmctaGlkZSBDU1MgY2xhc3MuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYC5uZy1oaWRlYCBzZWxlY3RvclxuICogY2FuIGJlIGVhc2lseSBvdmVycmlkZGVuIGJ5IGhlYXZpZXIgc2VsZWN0b3JzLiBGb3IgZXhhbXBsZSwgc29tZXRoaW5nIGFzIHNpbXBsZVxuICogYXMgY2hhbmdpbmcgdGhlIGRpc3BsYXkgc3R5bGUgb24gYSBIVE1MIGxpc3QgaXRlbSB3b3VsZCBtYWtlIGhpZGRlbiBlbGVtZW50cyBhcHBlYXIgdmlzaWJsZS5cbiAqIFRoaXMgYWxzbyBiZWNvbWVzIGEgYmlnZ2VyIGlzc3VlIHdoZW4gZGVhbGluZyB3aXRoIENTUyBmcmFtZXdvcmtzLlxuICpcbiAqIEJ5IHVzaW5nICFpbXBvcnRhbnQsIHRoZSBzaG93IGFuZCBoaWRlIGJlaGF2aW9yIHdpbGwgd29yayBhcyBleHBlY3RlZCBkZXNwaXRlIGFueSBjbGFzaCBiZXR3ZWVuIENTUyBzZWxlY3RvclxuICogc3BlY2lmaWNpdHkgKHdoZW4gIWltcG9ydGFudCBpc24ndCB1c2VkIHdpdGggYW55IGNvbmZsaWN0aW5nIHN0eWxlcykuIElmIGEgZGV2ZWxvcGVyIGNob29zZXMgdG8gb3ZlcnJpZGUgdGhlXG4gKiBzdHlsaW5nIHRvIGNoYW5nZSBob3cgdG8gaGlkZSBhbiBlbGVtZW50IHRoZW4gaXQgaXMganVzdCBhIG1hdHRlciBvZiB1c2luZyAhaW1wb3J0YW50IGluIHRoZWlyIG93biBDU1MgY29kZS5cbiAqXG4gKiAjIyMgT3ZlcnJpZGluZyAubmctaGlkZVxuICpcbiAqIElmIHlvdSB3aXNoIHRvIGNoYW5nZSB0aGUgaGlkZSBiZWhhdmlvciB3aXRoIG5nU2hvdy9uZ0hpZGUgdGhlbiB0aGlzIGNhbiBiZSBhY2hpZXZlZCBieVxuICogcmVzdGF0aW5nIHRoZSBzdHlsZXMgZm9yIHRoZSAubmctaGlkZSBjbGFzcyBpbiBDU1M6XG4gKiA8cHJlPlxuICogLm5nLWhpZGUge1xuICogICAvLyFhbm5vdGF0ZSBDU1MgU3BlY2lmaWNpdHl8Tm90IHRvIHdvcnJ5LCB0aGlzIHdpbGwgb3ZlcnJpZGUgdGhlIEFuZ3VsYXJKUyBkZWZhdWx0Li4uXG4gKiAgIGRpc3BsYXk6YmxvY2shaW1wb3J0YW50O1xuICpcbiAqICAgLy90aGlzIGlzIGp1c3QgYW5vdGhlciBmb3JtIG9mIGhpZGluZyBhbiBlbGVtZW50XG4gKiAgIHBvc2l0aW9uOmFic29sdXRlO1xuICogICB0b3A6LTk5OTlweDtcbiAqICAgbGVmdDotOTk5OXB4O1xuICogfVxuICogPC9wcmU+XG4gKlxuICogSnVzdCByZW1lbWJlciB0byBpbmNsdWRlIHRoZSBpbXBvcnRhbnQgZmxhZyBzbyB0aGUgQ1NTIG92ZXJyaWRlIHdpbGwgZnVuY3Rpb24uXG4gKlxuICogIyMgQSBub3RlIGFib3V0IGFuaW1hdGlvbnMgd2l0aCBuZ1Nob3dcbiAqXG4gKiBBbmltYXRpb25zIGluIG5nU2hvdy9uZ0hpZGUgd29yayB3aXRoIHRoZSBzaG93IGFuZCBoaWRlIGV2ZW50cyB0aGF0IGFyZSB0cmlnZ2VyZWQgd2hlbiB0aGUgZGlyZWN0aXZlIGV4cHJlc3Npb25cbiAqIGlzIHRydWUgYW5kIGZhbHNlLiBUaGlzIHN5c3RlbSB3b3JrcyBsaWtlIHRoZSBhbmltYXRpb24gc3lzdGVtIHByZXNlbnQgd2l0aCBuZ0NsYXNzIGV4Y2VwdCB0aGF0XG4gKiB5b3UgbXVzdCBhbHNvIGluY2x1ZGUgdGhlICFpbXBvcnRhbnQgZmxhZyB0byBvdmVycmlkZSB0aGUgZGlzcGxheSBwcm9wZXJ0eVxuICogc28gdGhhdCB5b3UgY2FuIHBlcmZvcm0gYW4gYW5pbWF0aW9uIHdoZW4gdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGR1cmluZyB0aGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uLlxuICpcbiAqIDxwcmU+XG4gKiAvL1xuICogLy9hIHdvcmtpbmcgZXhhbXBsZSBjYW4gYmUgZm91bmQgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIHBhZ2VcbiAqIC8vXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLWFkZCwgLm15LWVsZW1lbnQubmctaGlkZS1yZW1vdmUge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XG4gKiB9XG4gKlxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQgeyAuLi4gfVxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQubmctaGlkZS1hZGQtYWN0aXZlIHsgLi4uIH1cbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlIHsgLi4uIH1cbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlLm5nLWhpZGUtcmVtb3ZlLWFjdGl2ZSB7IC4uLiB9XG4gKiA8L3ByZT5cbiAqXG4gKiBAYW5pbWF0aW9uc1xuICogYWRkQ2xhc3M6IC5uZy1oaWRlIC0gaGFwcGVucyBhZnRlciB0aGUgbmdTaG93IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlIGFuZCB0aGUganVzdCBiZWZvcmUgY29udGVudHMgYXJlIHNldCB0byB2aXNpYmxlXG4gKiByZW1vdmVDbGFzczogLm5nLWhpZGUgLSBoYXBwZW5zIGFmdGVyIHRoZSBuZ1Nob3cgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYSBub24gdHJ1dGh5IHZhbHVlIGFuZCBqdXN0IGJlZm9yZSB0aGUgY29udGVudHMgYXJlIHNldCB0byBoaWRkZW5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdTaG93IElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHlcbiAqICAgICB0aGVuIHRoZSBlbGVtZW50IGlzIHNob3duIG9yIGhpZGRlbiByZXNwZWN0aXZlbHkuXG4gKlxuICogQGV4YW1wbGVcbiAgPGV4YW1wbGUgYW5pbWF0aW9ucz1cInRydWVcIj5cbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgQ2xpY2sgbWU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxuICAgICAgPGRpdj5cbiAgICAgICAgU2hvdzpcbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNrLWVsZW1lbnQgYW5pbWF0ZS1zaG93XCIgbmctc2hvdz1cImNoZWNrZWRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tdGh1bWJzLXVwXCI+PC9zcGFuPiBJIHNob3cgdXAgd2hlbiB5b3VyIGNoZWNrYm94IGlzIGNoZWNrZWQuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2PlxuICAgICAgICBIaWRlOlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlY2stZWxlbWVudCBhbmltYXRlLXNob3dcIiBuZy1oaWRlPVwiY2hlY2tlZFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10aHVtYnMtZG93blwiPjwvc3Bhbj4gSSBoaWRlIHdoZW4geW91ciBjaGVja2JveCBpcyBjaGVja2VkLlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cbiAgICAgIC5hbmltYXRlLXNob3cge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xuICAgICAgICB0cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcbiAgICAgICAgbGluZS1oZWlnaHQ6MjBweDtcbiAgICAgICAgb3BhY2l0eToxO1xuICAgICAgICBwYWRkaW5nOjEwcHg7XG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLXNob3cubmctaGlkZS1hZGQsXG4gICAgICAuYW5pbWF0ZS1zaG93Lm5nLWhpZGUtcmVtb3ZlIHtcbiAgICAgICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLXNob3cubmctaGlkZSB7XG4gICAgICAgIGxpbmUtaGVpZ2h0OjA7XG4gICAgICAgIG9wYWNpdHk6MDtcbiAgICAgICAgcGFkZGluZzowIDEwcHg7XG4gICAgICB9XG5cbiAgICAgIC5jaGVjay1lbGVtZW50IHtcbiAgICAgICAgcGFkZGluZzoxMHB4O1xuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xuICAgICAgfVxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLXNob3cgLyBuZy1oaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbjpmaXJzdDpoaWRkZW4nKS5jb3VudCgpKS50b0VxdWFsKDEpO1xuICAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIHNwYW46bGFzdDp2aXNpYmxlJykuY291bnQoKSkudG9FcXVhbCgxKTtcblxuICAgICAgICAgaW5wdXQoJ2NoZWNrZWQnKS5jaGVjaygpO1xuXG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbjpmaXJzdDp2aXNpYmxlJykuY291bnQoKSkudG9FcXVhbCgxKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuOmxhc3Q6aGlkZGVuJykuY291bnQoKSkudG9FcXVhbCgxKTtcbiAgICAgICB9KTtcbiAgICA8L2ZpbGU+XG4gIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nU2hvd0RpcmVjdGl2ZSA9IFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcbiAgICBzY29wZS4kd2F0Y2goYXR0ci5uZ1Nob3csIGZ1bmN0aW9uIG5nU2hvd1dhdGNoQWN0aW9uKHZhbHVlKXtcbiAgICAgICRhbmltYXRlW3RvQm9vbGVhbih2YWx1ZSkgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJ10oZWxlbWVudCwgJ25nLWhpZGUnKTtcbiAgICB9KTtcbiAgfTtcbn1dO1xuXG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmcuZGlyZWN0aXZlOm5nSGlkZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBuZ0hpZGVgIGRpcmVjdGl2ZSBzaG93cyBvciBoaWRlcyB0aGUgZ2l2ZW4gSFRNTCBlbGVtZW50IGJhc2VkIG9uIHRoZSBleHByZXNzaW9uXG4gKiBwcm92aWRlZCB0byB0aGUgbmdIaWRlIGF0dHJpYnV0ZS4gVGhlIGVsZW1lbnQgaXMgc2hvd24gb3IgaGlkZGVuIGJ5IHJlbW92aW5nIG9yIGFkZGluZ1xuICogdGhlIGBuZy1oaWRlYCBDU1MgY2xhc3Mgb250byB0aGUgZWxlbWVudC4gVGhlIGAubmctaGlkZWAgQ1NTIGNsYXNzIGlzIHByZWRlZmluZWRcbiAqIGluIEFuZ3VsYXJKUyBhbmQgc2V0cyB0aGUgZGlzcGxheSBzdHlsZSB0byBub25lICh1c2luZyBhbiAhaW1wb3J0YW50IGZsYWcpLlxuICogRm9yIENTUCBtb2RlIHBsZWFzZSBhZGQgYGFuZ3VsYXItY3NwLmNzc2AgdG8geW91ciBodG1sIGZpbGUgKHNlZSB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nQ3NwIG5nQ3NwfSkuXG4gKlxuICogPHByZT5cbiAqIDwhLS0gd2hlbiAkc2NvcGUubXlWYWx1ZSBpcyB0cnV0aHkgKGVsZW1lbnQgaXMgaGlkZGVuKSAtLT5cbiAqIDxkaXYgbmctaGlkZT1cIm15VmFsdWVcIj48L2Rpdj5cbiAqXG4gKiA8IS0tIHdoZW4gJHNjb3BlLm15VmFsdWUgaXMgZmFsc3kgKGVsZW1lbnQgaXMgdmlzaWJsZSkgLS0+XG4gKiA8ZGl2IG5nLWhpZGU9XCJteVZhbHVlXCIgY2xhc3M9XCJuZy1oaWRlXCI+PC9kaXY+XG4gKiA8L3ByZT5cbiAqXG4gKiBXaGVuIHRoZSBuZ0hpZGUgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZSB0aGVuIHRoZSAubmctaGlkZSBDU1MgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIGNsYXNzIGF0dHJpYnV0ZVxuICogb24gdGhlIGVsZW1lbnQgY2F1c2luZyBpdCB0byBiZWNvbWUgaGlkZGVuLiBXaGVuIGZhbHNlLCB0aGUgbmctaGlkZSBDU1MgY2xhc3MgaXMgcmVtb3ZlZFxuICogZnJvbSB0aGUgZWxlbWVudCBjYXVzaW5nIHRoZSBlbGVtZW50IG5vdCB0byBhcHBlYXIgaGlkZGVuLlxuICpcbiAqICMjIFdoeSBpcyAhaW1wb3J0YW50IHVzZWQ/XG4gKlxuICogWW91IG1heSBiZSB3b25kZXJpbmcgd2h5ICFpbXBvcnRhbnQgaXMgdXNlZCBmb3IgdGhlIC5uZy1oaWRlIENTUyBjbGFzcy4gVGhpcyBpcyBiZWNhdXNlIHRoZSBgLm5nLWhpZGVgIHNlbGVjdG9yXG4gKiBjYW4gYmUgZWFzaWx5IG92ZXJyaWRkZW4gYnkgaGVhdmllciBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCBzb21ldGhpbmcgYXMgc2ltcGxlXG4gKiBhcyBjaGFuZ2luZyB0aGUgZGlzcGxheSBzdHlsZSBvbiBhIEhUTUwgbGlzdCBpdGVtIHdvdWxkIG1ha2UgaGlkZGVuIGVsZW1lbnRzIGFwcGVhciB2aXNpYmxlLlxuICogVGhpcyBhbHNvIGJlY29tZXMgYSBiaWdnZXIgaXNzdWUgd2hlbiBkZWFsaW5nIHdpdGggQ1NTIGZyYW1ld29ya3MuXG4gKlxuICogQnkgdXNpbmcgIWltcG9ydGFudCwgdGhlIHNob3cgYW5kIGhpZGUgYmVoYXZpb3Igd2lsbCB3b3JrIGFzIGV4cGVjdGVkIGRlc3BpdGUgYW55IGNsYXNoIGJldHdlZW4gQ1NTIHNlbGVjdG9yXG4gKiBzcGVjaWZpY2l0eSAod2hlbiAhaW1wb3J0YW50IGlzbid0IHVzZWQgd2l0aCBhbnkgY29uZmxpY3Rpbmcgc3R5bGVzKS4gSWYgYSBkZXZlbG9wZXIgY2hvb3NlcyB0byBvdmVycmlkZSB0aGVcbiAqIHN0eWxpbmcgdG8gY2hhbmdlIGhvdyB0byBoaWRlIGFuIGVsZW1lbnQgdGhlbiBpdCBpcyBqdXN0IGEgbWF0dGVyIG9mIHVzaW5nICFpbXBvcnRhbnQgaW4gdGhlaXIgb3duIENTUyBjb2RlLlxuICpcbiAqICMjIyBPdmVycmlkaW5nIC5uZy1oaWRlXG4gKlxuICogSWYgeW91IHdpc2ggdG8gY2hhbmdlIHRoZSBoaWRlIGJlaGF2aW9yIHdpdGggbmdTaG93L25nSGlkZSB0aGVuIHRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5XG4gKiByZXN0YXRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIC5uZy1oaWRlIGNsYXNzIGluIENTUzpcbiAqIDxwcmU+XG4gKiAubmctaGlkZSB7XG4gKiAgIC8vIWFubm90YXRlIENTUyBTcGVjaWZpY2l0eXxOb3QgdG8gd29ycnksIHRoaXMgd2lsbCBvdmVycmlkZSB0aGUgQW5ndWxhckpTIGRlZmF1bHQuLi5cbiAqICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XG4gKlxuICogICAvL3RoaXMgaXMganVzdCBhbm90aGVyIGZvcm0gb2YgaGlkaW5nIGFuIGVsZW1lbnRcbiAqICAgcG9zaXRpb246YWJzb2x1dGU7XG4gKiAgIHRvcDotOTk5OXB4O1xuICogICBsZWZ0Oi05OTk5cHg7XG4gKiB9XG4gKiA8L3ByZT5cbiAqXG4gKiBKdXN0IHJlbWVtYmVyIHRvIGluY2x1ZGUgdGhlIGltcG9ydGFudCBmbGFnIHNvIHRoZSBDU1Mgb3ZlcnJpZGUgd2lsbCBmdW5jdGlvbi5cbiAqXG4gKiAjIyBBIG5vdGUgYWJvdXQgYW5pbWF0aW9ucyB3aXRoIG5nSGlkZVxuICpcbiAqIEFuaW1hdGlvbnMgaW4gbmdTaG93L25nSGlkZSB3b3JrIHdpdGggdGhlIHNob3cgYW5kIGhpZGUgZXZlbnRzIHRoYXQgYXJlIHRyaWdnZXJlZCB3aGVuIHRoZSBkaXJlY3RpdmUgZXhwcmVzc2lvblxuICogaXMgdHJ1ZSBhbmQgZmFsc2UuIFRoaXMgc3lzdGVtIHdvcmtzIGxpa2UgdGhlIGFuaW1hdGlvbiBzeXN0ZW0gcHJlc2VudCB3aXRoIG5nQ2xhc3MsIGV4Y2VwdCB0aGF0XG4gKiB5b3UgbXVzdCBhbHNvIGluY2x1ZGUgdGhlICFpbXBvcnRhbnQgZmxhZyB0byBvdmVycmlkZSB0aGUgZGlzcGxheSBwcm9wZXJ0eSBzb1xuICogdGhhdCB5b3UgY2FuIHBlcmZvcm0gYW4gYW5pbWF0aW9uIHdoZW4gdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGR1cmluZyB0aGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uLlxuICpcbiAqIDxwcmU+XG4gKiAvL1xuICogLy9hIHdvcmtpbmcgZXhhbXBsZSBjYW4gYmUgZm91bmQgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIHBhZ2VcbiAqIC8vXG4gKiAubXktZWxlbWVudC5uZy1oaWRlLWFkZCwgLm15LWVsZW1lbnQubmctaGlkZS1yZW1vdmUge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XG4gKiB9XG4gKlxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQgeyAuLi4gfVxuICogLm15LWVsZW1lbnQubmctaGlkZS1hZGQubmctaGlkZS1hZGQtYWN0aXZlIHsgLi4uIH1cbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlIHsgLi4uIH1cbiAqIC5teS1lbGVtZW50Lm5nLWhpZGUtcmVtb3ZlLm5nLWhpZGUtcmVtb3ZlLWFjdGl2ZSB7IC4uLiB9XG4gKiA8L3ByZT5cbiAqXG4gKiBAYW5pbWF0aW9uc1xuICogcmVtb3ZlQ2xhc3M6IC5uZy1oaWRlIC0gaGFwcGVucyBhZnRlciB0aGUgbmdIaWRlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGEgdHJ1dGh5IHZhbHVlIGFuZCBqdXN0IGJlZm9yZSB0aGUgY29udGVudHMgYXJlIHNldCB0byBoaWRkZW5cbiAqIGFkZENsYXNzOiAubmctaGlkZSAtIGhhcHBlbnMgYWZ0ZXIgdGhlIG5nSGlkZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIG5vbiB0cnV0aHkgdmFsdWUgYW5kIGp1c3QgYmVmb3JlIHRoZSBjb250ZW50cyBhcmUgc2V0IHRvIHZpc2libGVcbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqIEBwYXJhbSB7ZXhwcmVzc2lvbn0gbmdIaWRlIElmIHRoZSB7QGxpbmsgZ3VpZGUvZXhwcmVzc2lvbiBleHByZXNzaW9ufSBpcyB0cnV0aHkgdGhlblxuICogICAgIHRoZSBlbGVtZW50IGlzIHNob3duIG9yIGhpZGRlbiByZXNwZWN0aXZlbHkuXG4gKlxuICogQGV4YW1wbGVcbiAgPGV4YW1wbGUgYW5pbWF0aW9ucz1cInRydWVcIj5cbiAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgQ2xpY2sgbWU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuZy1tb2RlbD1cImNoZWNrZWRcIj48YnIvPlxuICAgICAgPGRpdj5cbiAgICAgICAgU2hvdzpcbiAgICAgICAgPGRpdiBjbGFzcz1cImNoZWNrLWVsZW1lbnQgYW5pbWF0ZS1oaWRlXCIgbmctc2hvdz1cImNoZWNrZWRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tdGh1bWJzLXVwXCI+PC9zcGFuPiBJIHNob3cgdXAgd2hlbiB5b3VyIGNoZWNrYm94IGlzIGNoZWNrZWQuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2PlxuICAgICAgICBIaWRlOlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2hlY2stZWxlbWVudCBhbmltYXRlLWhpZGVcIiBuZy1oaWRlPVwiY2hlY2tlZFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi10aHVtYnMtZG93blwiPjwvc3Bhbj4gSSBoaWRlIHdoZW4geW91ciBjaGVja2JveCBpcyBjaGVja2VkLlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cbiAgICAgIC5hbmltYXRlLWhpZGUge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGxpbmVhciAwLjVzO1xuICAgICAgICB0cmFuc2l0aW9uOmFsbCBsaW5lYXIgMC41cztcbiAgICAgICAgbGluZS1oZWlnaHQ6MjBweDtcbiAgICAgICAgb3BhY2l0eToxO1xuICAgICAgICBwYWRkaW5nOjEwcHg7XG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLWhpZGUubmctaGlkZS1hZGQsXG4gICAgICAuYW5pbWF0ZS1oaWRlLm5nLWhpZGUtcmVtb3ZlIHtcbiAgICAgICAgZGlzcGxheTpibG9jayFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLWhpZGUubmctaGlkZSB7XG4gICAgICAgIGxpbmUtaGVpZ2h0OjA7XG4gICAgICAgIG9wYWNpdHk6MDtcbiAgICAgICAgcGFkZGluZzowIDEwcHg7XG4gICAgICB9XG5cbiAgICAgIC5jaGVjay1lbGVtZW50IHtcbiAgICAgICAgcGFkZGluZzoxMHB4O1xuICAgICAgICBib3JkZXI6MXB4IHNvbGlkIGJsYWNrO1xuICAgICAgICBiYWNrZ3JvdW5kOndoaXRlO1xuICAgICAgfVxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwic2NlbmFyaW8uanNcIj5cbiAgICAgICBpdCgnc2hvdWxkIGNoZWNrIG5nLXNob3cgLyBuZy1oaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgLmNoZWNrLWVsZW1lbnQ6Zmlyc3Q6aGlkZGVuJykuY291bnQoKSkudG9FcXVhbCgxKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAuY2hlY2stZWxlbWVudDpsYXN0OnZpc2libGUnKS5jb3VudCgpKS50b0VxdWFsKDEpO1xuXG4gICAgICAgICBpbnB1dCgnY2hlY2tlZCcpLmNoZWNrKCk7XG5cbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAuY2hlY2stZWxlbWVudDpmaXJzdDp2aXNpYmxlJykuY291bnQoKSkudG9FcXVhbCgxKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSAuY2hlY2stZWxlbWVudDpsYXN0OmhpZGRlbicpLmNvdW50KCkpLnRvRXF1YWwoMSk7XG4gICAgICAgfSk7XG4gICAgPC9maWxlPlxuICA8L2V4YW1wbGU+XG4gKi9cbnZhciBuZ0hpZGVEaXJlY3RpdmUgPSBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gICAgc2NvcGUuJHdhdGNoKGF0dHIubmdIaWRlLCBmdW5jdGlvbiBuZ0hpZGVXYXRjaEFjdGlvbih2YWx1ZSl7XG4gICAgICAkYW5pbWF0ZVt0b0Jvb2xlYW4odmFsdWUpID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKGVsZW1lbnQsICduZy1oaWRlJyk7XG4gICAgfSk7XG4gIH07XG59XTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTdHlsZVxuICogQHJlc3RyaWN0IEFDXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYG5nU3R5bGVgIGRpcmVjdGl2ZSBhbGxvd3MgeW91IHRvIHNldCBDU1Mgc3R5bGUgb24gYW4gSFRNTCBlbGVtZW50IGNvbmRpdGlvbmFsbHkuXG4gKlxuICogQGVsZW1lbnQgQU5ZXG4gKiBAcGFyYW0ge2V4cHJlc3Npb259IG5nU3R5bGUge0BsaW5rIGd1aWRlL2V4cHJlc3Npb24gRXhwcmVzc2lvbn0gd2hpY2ggZXZhbHMgdG8gYW5cbiAqICAgICAgb2JqZWN0IHdob3NlIGtleXMgYXJlIENTUyBzdHlsZSBuYW1lcyBhbmQgdmFsdWVzIGFyZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBmb3IgdGhvc2UgQ1NTXG4gKiAgICAgIGtleXMuXG4gKlxuICogQGV4YW1wbGVcbiAgIDxleGFtcGxlPlxuICAgICA8ZmlsZSBuYW1lPVwiaW5kZXguaHRtbFwiPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwic2V0XCIgbmctY2xpY2s9XCJteVN0eWxlPXtjb2xvcjoncmVkJ31cIj5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cImNsZWFyXCIgbmctY2xpY2s9XCJteVN0eWxlPXt9XCI+XG4gICAgICAgIDxici8+XG4gICAgICAgIDxzcGFuIG5nLXN0eWxlPVwibXlTdHlsZVwiPlNhbXBsZSBUZXh0PC9zcGFuPlxuICAgICAgICA8cHJlPm15U3R5bGU9e3tteVN0eWxlfX08L3ByZT5cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwic3R5bGUuY3NzXCI+XG4gICAgICAgc3BhbiB7XG4gICAgICAgICBjb2xvcjogYmxhY2s7XG4gICAgICAgfVxuICAgICA8L2ZpbGU+XG4gICAgIDxmaWxlIG5hbWU9XCJzY2VuYXJpby5qc1wiPlxuICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctc3R5bGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuJykuY3NzKCdjb2xvcicpKS50b0JlKCdyZ2IoMCwgMCwgMCknKTtcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b25bdmFsdWU9c2V0XScpLmNsaWNrKCk7XG4gICAgICAgICBleHBlY3QoZWxlbWVudCgnLmRvYy1leGFtcGxlLWxpdmUgc3BhbicpLmNzcygnY29sb3InKSkudG9CZSgncmdiKDI1NSwgMCwgMCknKTtcbiAgICAgICAgIGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIDpidXR0b25bdmFsdWU9Y2xlYXJdJykuY2xpY2soKTtcbiAgICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBzcGFuJykuY3NzKCdjb2xvcicpKS50b0JlKCdyZ2IoMCwgMCwgMCknKTtcbiAgICAgICB9KTtcbiAgICAgPC9maWxlPlxuICAgPC9leGFtcGxlPlxuICovXG52YXIgbmdTdHlsZURpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRyKSB7XG4gIHNjb3BlLiR3YXRjaChhdHRyLm5nU3R5bGUsIGZ1bmN0aW9uIG5nU3R5bGVXYXRjaEFjdGlvbihuZXdTdHlsZXMsIG9sZFN0eWxlcykge1xuICAgIGlmIChvbGRTdHlsZXMgJiYgKG5ld1N0eWxlcyAhPT0gb2xkU3R5bGVzKSkge1xuICAgICAgZm9yRWFjaChvbGRTdHlsZXMsIGZ1bmN0aW9uKHZhbCwgc3R5bGUpIHsgZWxlbWVudC5jc3Moc3R5bGUsICcnKTt9KTtcbiAgICB9XG4gICAgaWYgKG5ld1N0eWxlcykgZWxlbWVudC5jc3MobmV3U3R5bGVzKTtcbiAgfSwgdHJ1ZSk7XG59KTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZy5kaXJlY3RpdmU6bmdTd2l0Y2hcbiAqIEByZXN0cmljdCBFQVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBuZ1N3aXRjaGAgZGlyZWN0aXZlIGlzIHVzZWQgdG8gY29uZGl0aW9uYWxseSBzd2FwIERPTSBzdHJ1Y3R1cmUgb24geW91ciB0ZW1wbGF0ZSBiYXNlZCBvbiBhIHNjb3BlIGV4cHJlc3Npb24uXG4gKiBFbGVtZW50cyB3aXRoaW4gYG5nU3dpdGNoYCBidXQgd2l0aG91dCBgbmdTd2l0Y2hXaGVuYCBvciBgbmdTd2l0Y2hEZWZhdWx0YCBkaXJlY3RpdmVzIHdpbGwgYmUgcHJlc2VydmVkIGF0IHRoZSBsb2NhdGlvblxuICogYXMgc3BlY2lmaWVkIGluIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGUgZGlyZWN0aXZlIGl0c2VsZiB3b3JrcyBzaW1pbGFyIHRvIG5nSW5jbHVkZSwgaG93ZXZlciwgaW5zdGVhZCBvZiBkb3dubG9hZGluZyB0ZW1wbGF0ZSBjb2RlIChvciBsb2FkaW5nIGl0XG4gKiBmcm9tIHRoZSB0ZW1wbGF0ZSBjYWNoZSksIGBuZ1N3aXRjaGAgc2ltcGx5IGNob3NlcyBvbmUgb2YgdGhlIG5lc3RlZCBlbGVtZW50cyBhbmQgbWFrZXMgaXQgdmlzaWJsZSBiYXNlZCBvbiB3aGljaCBlbGVtZW50XG4gKiBtYXRjaGVzIHRoZSB2YWx1ZSBvYnRhaW5lZCBmcm9tIHRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvbi4gSW4gb3RoZXIgd29yZHMsIHlvdSBkZWZpbmUgYSBjb250YWluZXIgZWxlbWVudFxuICogKHdoZXJlIHlvdSBwbGFjZSB0aGUgZGlyZWN0aXZlKSwgcGxhY2UgYW4gZXhwcmVzc2lvbiBvbiB0aGUgKipgb249XCIuLi5cImAgYXR0cmlidXRlKipcbiAqIChvciB0aGUgKipgbmctc3dpdGNoPVwiLi4uXCJgIGF0dHJpYnV0ZSoqKSwgZGVmaW5lIGFueSBpbm5lciBlbGVtZW50cyBpbnNpZGUgb2YgdGhlIGRpcmVjdGl2ZSBhbmQgcGxhY2VcbiAqIGEgd2hlbiBhdHRyaWJ1dGUgcGVyIGVsZW1lbnQuIFRoZSB3aGVuIGF0dHJpYnV0ZSBpcyB1c2VkIHRvIGluZm9ybSBuZ1N3aXRjaCB3aGljaCBlbGVtZW50IHRvIGRpc3BsYXkgd2hlbiB0aGUgb25cbiAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLiBJZiBhIG1hdGNoaW5nIGV4cHJlc3Npb24gaXMgbm90IGZvdW5kIHZpYSBhIHdoZW4gYXR0cmlidXRlIHRoZW4gYW4gZWxlbWVudCB3aXRoIHRoZSBkZWZhdWx0XG4gKiBhdHRyaWJ1dGUgaXMgZGlzcGxheWVkLlxuICpcbiAqIDxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1pbmZvXCI+XG4gKiBCZSBhd2FyZSB0aGF0IHRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRvIG1hdGNoIGFnYWluc3QgY2Fubm90IGJlIGV4cHJlc3Npb25zLiBUaGV5IGFyZSBpbnRlcnByZXRlZFxuICogYXMgbGl0ZXJhbCBzdHJpbmcgdmFsdWVzIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBGb3IgZXhhbXBsZSwgKipgbmctc3dpdGNoLXdoZW49XCJzb21lVmFsXCJgKiogd2lsbCBtYXRjaCBhZ2FpbnN0IHRoZSBzdHJpbmcgYFwic29tZVZhbFwiYCBub3QgYWdhaW5zdCB0aGVcbiAqIHZhbHVlIG9mIHRoZSBleHByZXNzaW9uIGAkc2NvcGUuc29tZVZhbGAuXG4gKiA8L2Rpdj5cblxuICogQGFuaW1hdGlvbnNcbiAqIGVudGVyIC0gaGFwcGVucyBhZnRlciB0aGUgbmdTd2l0Y2ggY29udGVudHMgY2hhbmdlIGFuZCB0aGUgbWF0Y2hlZCBjaGlsZCBlbGVtZW50IGlzIHBsYWNlZCBpbnNpZGUgdGhlIGNvbnRhaW5lclxuICogbGVhdmUgLSBoYXBwZW5zIGp1c3QgYWZ0ZXIgdGhlIG5nU3dpdGNoIGNvbnRlbnRzIGNoYW5nZSBhbmQganVzdCBiZWZvcmUgdGhlIGZvcm1lciBjb250ZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAqXG4gKiBAdXNhZ2VcbiAqIDxBTlkgbmctc3dpdGNoPVwiZXhwcmVzc2lvblwiPlxuICogICA8QU5ZIG5nLXN3aXRjaC13aGVuPVwibWF0Y2hWYWx1ZTFcIj4uLi48L0FOWT5cbiAqICAgPEFOWSBuZy1zd2l0Y2gtd2hlbj1cIm1hdGNoVmFsdWUyXCI+Li4uPC9BTlk+XG4gKiAgIDxBTlkgbmctc3dpdGNoLWRlZmF1bHQ+Li4uPC9BTlk+XG4gKiA8L0FOWT5cbiAqXG4gKlxuICogQHNjb3BlXG4gKiBAcHJpb3JpdHkgODAwXG4gKiBAcGFyYW0geyp9IG5nU3dpdGNofG9uIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdCA8dHQ+bmctc3dpdGNoLXdoZW48L3R0Pi5cbiAqIEBwYXJhbURlc2NyaXB0aW9uXG4gKiBPbiBjaGlsZCBlbGVtZW50cyBhZGQ6XG4gKlxuICogKiBgbmdTd2l0Y2hXaGVuYDogdGhlIGNhc2Ugc3RhdGVtZW50IHRvIG1hdGNoIGFnYWluc3QuIElmIG1hdGNoIHRoZW4gdGhpc1xuICogICBjYXNlIHdpbGwgYmUgZGlzcGxheWVkLiBJZiB0aGUgc2FtZSBtYXRjaCBhcHBlYXJzIG11bHRpcGxlIHRpbWVzLCBhbGwgdGhlXG4gKiAgIGVsZW1lbnRzIHdpbGwgYmUgZGlzcGxheWVkLlxuICogKiBgbmdTd2l0Y2hEZWZhdWx0YDogdGhlIGRlZmF1bHQgY2FzZSB3aGVuIG5vIG90aGVyIGNhc2UgbWF0Y2guIElmIHRoZXJlXG4gKiAgIGFyZSBtdWx0aXBsZSBkZWZhdWx0IGNhc2VzLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIG5vIG90aGVyXG4gKiAgIGNhc2UgbWF0Y2guXG4gKlxuICpcbiAqIEBleGFtcGxlXG4gIDxleGFtcGxlIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XG4gICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cInNlbGVjdGlvblwiIG5nLW9wdGlvbnM9XCJpdGVtIGZvciBpdGVtIGluIGl0ZW1zXCI+XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8dHQ+c2VsZWN0aW9uPXt7c2VsZWN0aW9ufX08L3R0PlxuICAgICAgICA8aHIvPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyXCJcbiAgICAgICAgICBuZy1zd2l0Y2ggb249XCJzZWxlY3Rpb25cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhbmltYXRlLXN3aXRjaFwiIG5nLXN3aXRjaC13aGVuPVwic2V0dGluZ3NcIj5TZXR0aW5ncyBEaXY8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhbmltYXRlLXN3aXRjaFwiIG5nLXN3aXRjaC13aGVuPVwiaG9tZVwiPkhvbWUgU3BhbjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFuaW1hdGUtc3dpdGNoXCIgbmctc3dpdGNoLWRlZmF1bHQ+ZGVmYXVsdDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICBmdW5jdGlvbiBDdHJsKCRzY29wZSkge1xuICAgICAgICAkc2NvcGUuaXRlbXMgPSBbJ3NldHRpbmdzJywgJ2hvbWUnLCAnb3RoZXInXTtcbiAgICAgICAgJHNjb3BlLnNlbGVjdGlvbiA9ICRzY29wZS5pdGVtc1swXTtcbiAgICAgIH1cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XG4gICAgICAuYW5pbWF0ZS1zd2l0Y2gtY29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246cmVsYXRpdmU7XG4gICAgICAgIGJhY2tncm91bmQ6d2hpdGU7XG4gICAgICAgIGJvcmRlcjoxcHggc29saWQgYmxhY2s7XG4gICAgICAgIGhlaWdodDo0MHB4O1xuICAgICAgICBvdmVyZmxvdzpoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC5hbmltYXRlLXN3aXRjaCB7XG4gICAgICAgIHBhZGRpbmc6MTBweDtcbiAgICAgIH1cblxuICAgICAgLmFuaW1hdGUtc3dpdGNoLm5nLWFuaW1hdGUge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCkgMC41cztcbiAgICAgICAgdHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKDAuMjUwLCAwLjQ2MCwgMC40NTAsIDAuOTQwKSAwLjVzO1xuXG4gICAgICAgIHBvc2l0aW9uOmFic29sdXRlO1xuICAgICAgICB0b3A6MDtcbiAgICAgICAgbGVmdDowO1xuICAgICAgICByaWdodDowO1xuICAgICAgICBib3R0b206MDtcbiAgICAgIH1cblxuICAgICAgLmFuaW1hdGUtc3dpdGNoLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSxcbiAgICAgIC5hbmltYXRlLXN3aXRjaC5uZy1lbnRlciB7XG4gICAgICAgIHRvcDotNTBweDtcbiAgICAgIH1cbiAgICAgIC5hbmltYXRlLXN3aXRjaC5uZy1sZWF2ZSxcbiAgICAgIC5hbmltYXRlLXN3aXRjaC5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xuICAgICAgICB0b3A6MDtcbiAgICAgIH1cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cInNjZW5hcmlvLmpzXCI+XG4gICAgICBpdCgnc2hvdWxkIHN0YXJ0IGluIHNldHRpbmdzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdChlbGVtZW50KCcuZG9jLWV4YW1wbGUtbGl2ZSBbbmctc3dpdGNoXScpLnRleHQoKSkudG9NYXRjaCgvU2V0dGluZ3MgRGl2Lyk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdzaG91bGQgY2hhbmdlIHRvIGhvbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZWN0KCdzZWxlY3Rpb24nKS5vcHRpb24oJ2hvbWUnKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIFtuZy1zd2l0Y2hdJykudGV4dCgpKS50b01hdGNoKC9Ib21lIFNwYW4vKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3Nob3VsZCBzZWxlY3QgZGVmYXVsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxlY3QoJ3NlbGVjdGlvbicpLm9wdGlvbignb3RoZXInKTtcbiAgICAgICAgZXhwZWN0KGVsZW1lbnQoJy5kb2MtZXhhbXBsZS1saXZlIFtuZy1zd2l0Y2hdJykudGV4dCgpKS50b01hdGNoKC9kZWZhdWx0Lyk7XG4gICAgICB9KTtcbiAgICA8L2ZpbGU+XG4gIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nU3dpdGNoRGlyZWN0aXZlID0gWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFQScsXG4gICAgcmVxdWlyZTogJ25nU3dpdGNoJyxcblxuICAgIC8vIGFza3MgZm9yICRzY29wZSB0byBmb29sIHRoZSBCQyBjb250cm9sbGVyIG1vZHVsZVxuICAgIGNvbnRyb2xsZXI6IFsnJHNjb3BlJywgZnVuY3Rpb24gbmdTd2l0Y2hDb250cm9sbGVyKCkge1xuICAgICB0aGlzLmNhc2VzID0ge307XG4gICAgfV0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIG5nU3dpdGNoQ29udHJvbGxlcikge1xuICAgICAgdmFyIHdhdGNoRXhwciA9IGF0dHIubmdTd2l0Y2ggfHwgYXR0ci5vbixcbiAgICAgICAgICBzZWxlY3RlZFRyYW5zY2x1ZGVzLFxuICAgICAgICAgIHNlbGVjdGVkRWxlbWVudHMsXG4gICAgICAgICAgc2VsZWN0ZWRTY29wZXMgPSBbXTtcblxuICAgICAgc2NvcGUuJHdhdGNoKHdhdGNoRXhwciwgZnVuY3Rpb24gbmdTd2l0Y2hXYXRjaEFjdGlvbih2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpPSAwLCBpaT1zZWxlY3RlZFNjb3Blcy5sZW5ndGg7IGk8aWk7IGkrKykge1xuICAgICAgICAgIHNlbGVjdGVkU2NvcGVzW2ldLiRkZXN0cm95KCk7XG4gICAgICAgICAgJGFuaW1hdGUubGVhdmUoc2VsZWN0ZWRFbGVtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZEVsZW1lbnRzID0gW107XG4gICAgICAgIHNlbGVjdGVkU2NvcGVzID0gW107XG5cbiAgICAgICAgaWYgKChzZWxlY3RlZFRyYW5zY2x1ZGVzID0gbmdTd2l0Y2hDb250cm9sbGVyLmNhc2VzWychJyArIHZhbHVlXSB8fCBuZ1N3aXRjaENvbnRyb2xsZXIuY2FzZXNbJz8nXSkpIHtcbiAgICAgICAgICBzY29wZS4kZXZhbChhdHRyLmNoYW5nZSk7XG4gICAgICAgICAgZm9yRWFjaChzZWxlY3RlZFRyYW5zY2x1ZGVzLCBmdW5jdGlvbihzZWxlY3RlZFRyYW5zY2x1ZGUpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFNjb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgc2VsZWN0ZWRTY29wZXMucHVzaChzZWxlY3RlZFNjb3BlKTtcbiAgICAgICAgICAgIHNlbGVjdGVkVHJhbnNjbHVkZS50cmFuc2NsdWRlKHNlbGVjdGVkU2NvcGUsIGZ1bmN0aW9uKGNhc2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBhbmNob3IgPSBzZWxlY3RlZFRyYW5zY2x1ZGUuZWxlbWVudDtcblxuICAgICAgICAgICAgICBzZWxlY3RlZEVsZW1lbnRzLnB1c2goY2FzZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjYXNlRWxlbWVudCwgYW5jaG9yLnBhcmVudCgpLCBhbmNob3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dO1xuXG52YXIgbmdTd2l0Y2hXaGVuRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xuICB0cmFuc2NsdWRlOiAnZWxlbWVudCcsXG4gIHByaW9yaXR5OiA4MDAsXG4gIHJlcXVpcmU6ICdebmdTd2l0Y2gnLFxuICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgIHJldHVybiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0ciwgY3RybCwgJHRyYW5zY2x1ZGUpIHtcbiAgICAgIGN0cmwuY2FzZXNbJyEnICsgYXR0cnMubmdTd2l0Y2hXaGVuXSA9IChjdHJsLmNhc2VzWychJyArIGF0dHJzLm5nU3dpdGNoV2hlbl0gfHwgW10pO1xuICAgICAgY3RybC5jYXNlc1snIScgKyBhdHRycy5uZ1N3aXRjaFdoZW5dLnB1c2goeyB0cmFuc2NsdWRlOiAkdHJhbnNjbHVkZSwgZWxlbWVudDogZWxlbWVudCB9KTtcbiAgICB9O1xuICB9XG59KTtcblxudmFyIG5nU3dpdGNoRGVmYXVsdERpcmVjdGl2ZSA9IG5nRGlyZWN0aXZlKHtcbiAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxuICBwcmlvcml0eTogODAwLFxuICByZXF1aXJlOiAnXm5nU3dpdGNoJyxcbiAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmwsICR0cmFuc2NsdWRlKSB7XG4gICAgY3RybC5jYXNlc1snPyddID0gKGN0cmwuY2FzZXNbJz8nXSB8fCBbXSk7XG4gICAgY3RybC5jYXNlc1snPyddLnB1c2goeyB0cmFuc2NsdWRlOiAkdHJhbnNjbHVkZSwgZWxlbWVudDogZWxlbWVudCB9KTtcbiAgIH1cbn0pO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpuZ1RyYW5zY2x1ZGVcbiAqIEByZXN0cmljdCBBQ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIHRoYXQgbWFya3MgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIHRyYW5zY2x1ZGVkIERPTSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgZGlyZWN0aXZlIHRoYXQgdXNlcyB0cmFuc2NsdXNpb24uXG4gKlxuICogQW55IGV4aXN0aW5nIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQgdGhhdCB0aGlzIGRpcmVjdGl2ZSBpcyBwbGFjZWQgb24gd2lsbCBiZSByZW1vdmVkIGJlZm9yZSB0aGUgdHJhbnNjbHVkZWQgY29udGVudCBpcyBpbnNlcnRlZC5cbiAqXG4gKiBAZWxlbWVudCBBTllcbiAqXG4gKiBAZXhhbXBsZVxuICAgPGRvYzpleGFtcGxlIG1vZHVsZT1cInRyYW5zY2x1ZGVcIj5cbiAgICAgPGRvYzpzb3VyY2U+XG4gICAgICAgPHNjcmlwdD5cbiAgICAgICAgIGZ1bmN0aW9uIEN0cmwoJHNjb3BlKSB7XG4gICAgICAgICAgICRzY29wZS50aXRsZSA9ICdMb3JlbSBJcHN1bSc7XG4gICAgICAgICAgICRzY29wZS50ZXh0ID0gJ05lcXVlIHBvcnJvIHF1aXNxdWFtIGVzdCBxdWkgZG9sb3JlbSBpcHN1bSBxdWlhIGRvbG9yLi4uJztcbiAgICAgICAgIH1cblxuICAgICAgICAgYW5ndWxhci5tb2R1bGUoJ3RyYW5zY2x1ZGUnLCBbXSlcbiAgICAgICAgICAuZGlyZWN0aXZlKCdwYW5lJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgICAgICAgICAgICBzY29wZTogeyB0aXRsZTonQCcgfSxcbiAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiBzdHlsZT1cImJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiBncmF5XCI+e3t0aXRsZX19PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgfTtcbiAgICAgICAgIH0pO1xuICAgICAgIDwvc2NyaXB0PlxuICAgICAgIDxkaXYgbmctY29udHJvbGxlcj1cIkN0cmxcIj5cbiAgICAgICAgIDxpbnB1dCBuZy1tb2RlbD1cInRpdGxlXCI+PGJyPlxuICAgICAgICAgPHRleHRhcmVhIG5nLW1vZGVsPVwidGV4dFwiPjwvdGV4dGFyZWE+IDxici8+XG4gICAgICAgICA8cGFuZSB0aXRsZT1cInt7dGl0bGV9fVwiPnt7dGV4dH19PC9wYW5lPlxuICAgICAgIDwvZGl2PlxuICAgICA8L2RvYzpzb3VyY2U+XG4gICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICAgIGl0KCdzaG91bGQgaGF2ZSB0cmFuc2NsdWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlucHV0KCd0aXRsZScpLmVudGVyKCdUSVRMRScpO1xuICAgICAgICAgIGlucHV0KCd0ZXh0JykuZW50ZXIoJ1RFWFQnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndGl0bGUnKSkudG9FcXVhbCgnVElUTEUnKTtcbiAgICAgICAgICBleHBlY3QoYmluZGluZygndGV4dCcpKS50b0VxdWFsKCdURVhUJyk7XG4gICAgICAgIH0pO1xuICAgICA8L2RvYzpzY2VuYXJpbz5cbiAgIDwvZG9jOmV4YW1wbGU+XG4gKlxuICovXG52YXIgbmdUcmFuc2NsdWRlRGlyZWN0aXZlID0gbmdEaXJlY3RpdmUoe1xuICBjb250cm9sbGVyOiBbJyRlbGVtZW50JywgJyR0cmFuc2NsdWRlJywgZnVuY3Rpb24oJGVsZW1lbnQsICR0cmFuc2NsdWRlKSB7XG4gICAgaWYgKCEkdHJhbnNjbHVkZSkge1xuICAgICAgdGhyb3cgbWluRXJyKCduZ1RyYW5zY2x1ZGUnKSgnb3JwaGFuJyxcbiAgICAgICAgICAnSWxsZWdhbCB1c2Ugb2YgbmdUcmFuc2NsdWRlIGRpcmVjdGl2ZSBpbiB0aGUgdGVtcGxhdGUhICcgK1xuICAgICAgICAgICdObyBwYXJlbnQgZGlyZWN0aXZlIHRoYXQgcmVxdWlyZXMgYSB0cmFuc2NsdXNpb24gZm91bmQuICcgK1xuICAgICAgICAgICdFbGVtZW50OiB7MH0nLFxuICAgICAgICAgIHN0YXJ0aW5nVGFnKCRlbGVtZW50KSk7XG4gICAgfVxuXG4gICAgLy8gcmVtZW1iZXIgdGhlIHRyYW5zY2x1c2lvbiBmbiBidXQgY2FsbCBpdCBkdXJpbmcgbGlua2luZyBzbyB0aGF0IHdlIGRvbid0IHByb2Nlc3MgdHJhbnNjbHVzaW9uIGJlZm9yZSBkaXJlY3RpdmVzIG9uXG4gICAgLy8gdGhlIHBhcmVudCBlbGVtZW50IGV2ZW4gd2hlbiB0aGUgdHJhbnNjbHVzaW9uIHJlcGxhY2VzIHRoZSBjdXJyZW50IGVsZW1lbnQuICh3ZSBjYW4ndCB1c2UgcHJpb3JpdHkgaGVyZSBiZWNhdXNlXG4gICAgLy8gdGhhdCBhcHBsaWVzIG9ubHkgdG8gY29tcGlsZSBmbnMgYW5kIG5vdCBjb250cm9sbGVyc1xuICAgIHRoaXMuJHRyYW5zY2x1ZGUgPSAkdHJhbnNjbHVkZTtcbiAgfV0sXG5cbiAgbGluazogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCBjb250cm9sbGVyKSB7XG4gICAgY29udHJvbGxlci4kdHJhbnNjbHVkZShmdW5jdGlvbihjbG9uZSkge1xuICAgICAgJGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICRlbGVtZW50LmFwcGVuZChjbG9uZSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpzY3JpcHRcbiAqIEByZXN0cmljdCBFXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBMb2FkIGNvbnRlbnQgb2YgYSBzY3JpcHQgdGFnLCB3aXRoIHR5cGUgYHRleHQvbmctdGVtcGxhdGVgLCBpbnRvIGAkdGVtcGxhdGVDYWNoZWAsIHNvIHRoYXQgdGhlXG4gKiB0ZW1wbGF0ZSBjYW4gYmUgdXNlZCBieSBgbmdJbmNsdWRlYCwgYG5nVmlld2Agb3IgZGlyZWN0aXZlIHRlbXBsYXRlcy5cbiAqXG4gKiBAcGFyYW0geyd0ZXh0L25nLXRlbXBsYXRlJ30gdHlwZSBtdXN0IGJlIHNldCB0byBgJ3RleHQvbmctdGVtcGxhdGUnYFxuICpcbiAqIEBleGFtcGxlXG4gIDxkb2M6ZXhhbXBsZT5cbiAgICA8ZG9jOnNvdXJjZT5cbiAgICAgIDxzY3JpcHQgdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIiBpZD1cIi90cGwuaHRtbFwiPlxuICAgICAgICBDb250ZW50IG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgIDwvc2NyaXB0PlxuXG4gICAgICA8YSBuZy1jbGljaz1cImN1cnJlbnRUcGw9Jy90cGwuaHRtbCdcIiBpZD1cInRwbC1saW5rXCI+TG9hZCBpbmxpbmVkIHRlbXBsYXRlPC9hPlxuICAgICAgPGRpdiBpZD1cInRwbC1jb250ZW50XCIgbmctaW5jbHVkZSBzcmM9XCJjdXJyZW50VHBsXCI+PC9kaXY+XG4gICAgPC9kb2M6c291cmNlPlxuICAgIDxkb2M6c2NlbmFyaW8+XG4gICAgICBpdCgnc2hvdWxkIGxvYWQgdGVtcGxhdGUgZGVmaW5lZCBpbnNpZGUgc2NyaXB0IHRhZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50KCcjdHBsLWxpbmsnKS5jbGljaygpO1xuICAgICAgICBleHBlY3QoZWxlbWVudCgnI3RwbC1jb250ZW50JykudGV4dCgpKS50b01hdGNoKC9Db250ZW50IG9mIHRoZSB0ZW1wbGF0ZS8pO1xuICAgICAgfSk7XG4gICAgPC9kb2M6c2NlbmFyaW8+XG4gIDwvZG9jOmV4YW1wbGU+XG4gKi9cbnZhciBzY3JpcHREaXJlY3RpdmUgPSBbJyR0ZW1wbGF0ZUNhY2hlJywgZnVuY3Rpb24oJHRlbXBsYXRlQ2FjaGUpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0UnLFxuICAgIHRlcm1pbmFsOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIGlmIChhdHRyLnR5cGUgPT0gJ3RleHQvbmctdGVtcGxhdGUnKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZVVybCA9IGF0dHIuaWQsXG4gICAgICAgICAgICAvLyBJRSBpcyBub3QgY29uc2lzdGVudCwgaW4gc2NyaXB0cyB3ZSBoYXZlIHRvIHJlYWQgLnRleHQgYnV0IGluIG90aGVyIG5vZGVzIHdlIGhhdmUgdG8gcmVhZCAudGV4dENvbnRlbnRcbiAgICAgICAgICAgIHRleHQgPSBlbGVtZW50WzBdLnRleHQ7XG5cbiAgICAgICAgJHRlbXBsYXRlQ2FjaGUucHV0KHRlbXBsYXRlVXJsLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XTtcblxudmFyIG5nT3B0aW9uc01pbkVyciA9IG1pbkVycignbmdPcHRpb25zJyk7XG4vKipcbiAqIEBuZ2RvYyBkaXJlY3RpdmVcbiAqIEBuYW1lIG5nLmRpcmVjdGl2ZTpzZWxlY3RcbiAqIEByZXN0cmljdCBFXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBIVE1MIGBTRUxFQ1RgIGVsZW1lbnQgd2l0aCBhbmd1bGFyIGRhdGEtYmluZGluZy5cbiAqXG4gKiAjIGBuZ09wdGlvbnNgXG4gKlxuICogVGhlIGBuZ09wdGlvbnNgIGF0dHJpYnV0ZSBjYW4gYmUgdXNlZCB0byBkeW5hbWljYWxseSBnZW5lcmF0ZSBhIGxpc3Qgb2YgYDxvcHRpb24+YFxuICogZWxlbWVudHMgZm9yIHRoZSBgPHNlbGVjdD5gIGVsZW1lbnQgdXNpbmcgdGhlIGFycmF5IG9yIG9iamVjdCBvYnRhaW5lZCBieSBldmFsdWF0aW5nIHRoZVxuICogYG5nT3B0aW9uc2AgY29tcHJlaGVuc2lvbl9leHByZXNzaW9uLlxuICpcbiAqIFdoZW4gYW4gaXRlbSBpbiB0aGUgYDxzZWxlY3Q+YCBtZW51IGlzIHNlbGVjdGVkLCB0aGUgYXJyYXkgZWxlbWVudCBvciBvYmplY3QgcHJvcGVydHlcbiAqIHJlcHJlc2VudGVkIGJ5IHRoZSBzZWxlY3RlZCBvcHRpb24gd2lsbCBiZSBib3VuZCB0byB0aGUgbW9kZWwgaWRlbnRpZmllZCBieSB0aGUgYG5nTW9kZWxgXG4gKiBkaXJlY3RpdmUuXG4gKlxuICogT3B0aW9uYWxseSwgYSBzaW5nbGUgaGFyZC1jb2RlZCBgPG9wdGlvbj5gIGVsZW1lbnQsIHdpdGggdGhlIHZhbHVlIHNldCB0byBhbiBlbXB0eSBzdHJpbmcsIGNhblxuICogYmUgbmVzdGVkIGludG8gdGhlIGA8c2VsZWN0PmAgZWxlbWVudC4gVGhpcyBlbGVtZW50IHdpbGwgdGhlbiByZXByZXNlbnQgdGhlIGBudWxsYCBvciBcIm5vdCBzZWxlY3RlZFwiXG4gKiBvcHRpb24uIFNlZSBleGFtcGxlIGJlbG93IGZvciBkZW1vbnN0cmF0aW9uLlxuICpcbiAqIE5vdGU6IGBuZ09wdGlvbnNgIHByb3ZpZGVzIGl0ZXJhdG9yIGZhY2lsaXR5IGZvciBgPG9wdGlvbj5gIGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZFxuICogb2Yge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCBuZ1JlcGVhdH0gd2hlbiB5b3Ugd2FudCB0aGVcbiAqIGBzZWxlY3RgIG1vZGVsIHRvIGJlIGJvdW5kIHRvIGEgbm9uLXN0cmluZyB2YWx1ZS4gVGhpcyBpcyBiZWNhdXNlIGFuIG9wdGlvbiBlbGVtZW50IGNhbiBvbmx5XG4gKiBiZSBib3VuZCB0byBzdHJpbmcgdmFsdWVzIGF0IHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5nTW9kZWwgQXNzaWduYWJsZSBhbmd1bGFyIGV4cHJlc3Npb24gdG8gZGF0YS1iaW5kIHRvLlxuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFByb3BlcnR5IG5hbWUgb2YgdGhlIGZvcm0gdW5kZXIgd2hpY2ggdGhlIGNvbnRyb2wgaXMgcHVibGlzaGVkLlxuICogQHBhcmFtIHtzdHJpbmc9fSByZXF1aXJlZCBUaGUgY29udHJvbCBpcyBjb25zaWRlcmVkIHZhbGlkIG9ubHkgaWYgdmFsdWUgaXMgZW50ZXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gbmdSZXF1aXJlZCBBZGRzIGByZXF1aXJlZGAgYXR0cmlidXRlIGFuZCBgcmVxdWlyZWRgIHZhbGlkYXRpb24gY29uc3RyYWludCB0b1xuICogICAgdGhlIGVsZW1lbnQgd2hlbiB0aGUgbmdSZXF1aXJlZCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlLiBVc2UgYG5nUmVxdWlyZWRgIGluc3RlYWQgb2ZcbiAqICAgIGByZXF1aXJlZGAgd2hlbiB5b3Ugd2FudCB0byBkYXRhLWJpbmQgdG8gdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLlxuICogQHBhcmFtIHtjb21wcmVoZW5zaW9uX2V4cHJlc3Npb249fSBuZ09wdGlvbnMgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKlxuICogICAqIGZvciBhcnJheSBkYXRhIHNvdXJjZXM6XG4gKiAgICAgKiBgbGFiZWxgICoqYGZvcmAqKiBgdmFsdWVgICoqYGluYCoqIGBhcnJheWBcbiAqICAgICAqIGBzZWxlY3RgICoqYGFzYCoqIGBsYWJlbGAgKipgZm9yYCoqIGB2YWx1ZWAgKipgaW5gKiogYGFycmF5YFxuICogICAgICogYGxhYmVsYCAgKipgZ3JvdXAgYnlgKiogYGdyb3VwYCAqKmBmb3JgKiogYHZhbHVlYCAqKmBpbmAqKiBgYXJyYXlgXG4gKiAgICAgKiBgc2VsZWN0YCAqKmBhc2AqKiBgbGFiZWxgICoqYGdyb3VwIGJ5YCoqIGBncm91cGAgKipgZm9yYCoqIGB2YWx1ZWAgKipgaW5gKiogYGFycmF5YCAqKmB0cmFjayBieWAqKiBgdHJhY2tleHByYFxuICogICAqIGZvciBvYmplY3QgZGF0YSBzb3VyY2VzOlxuICogICAgICogYGxhYmVsYCAqKmBmb3IgKGAqKmBrZXlgICoqYCxgKiogYHZhbHVlYCoqYCkgaW5gKiogYG9iamVjdGBcbiAqICAgICAqIGBzZWxlY3RgICoqYGFzYCoqIGBsYWJlbGAgKipgZm9yIChgKipga2V5YCAqKmAsYCoqIGB2YWx1ZWAqKmApIGluYCoqIGBvYmplY3RgXG4gKiAgICAgKiBgbGFiZWxgICoqYGdyb3VwIGJ5YCoqIGBncm91cGAgKipgZm9yIChgKipga2V5YCoqYCxgKiogYHZhbHVlYCoqYCkgaW5gKiogYG9iamVjdGBcbiAqICAgICAqIGBzZWxlY3RgICoqYGFzYCoqIGBsYWJlbGAgKipgZ3JvdXAgYnlgKiogYGdyb3VwYFxuICogICAgICAgICAqKmBmb3JgIGAoYCoqYGtleWAqKmAsYCoqIGB2YWx1ZWAqKmApIGluYCoqIGBvYmplY3RgXG4gKlxuICogV2hlcmU6XG4gKlxuICogICAqIGBhcnJheWAgLyBgb2JqZWN0YDogYW4gZXhwcmVzc2lvbiB3aGljaCBldmFsdWF0ZXMgdG8gYW4gYXJyYXkgLyBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogICAqIGB2YWx1ZWA6IGxvY2FsIHZhcmlhYmxlIHdoaWNoIHdpbGwgcmVmZXIgdG8gZWFjaCBpdGVtIGluIHRoZSBgYXJyYXlgIG9yIGVhY2ggcHJvcGVydHkgdmFsdWVcbiAqICAgICAgb2YgYG9iamVjdGAgZHVyaW5nIGl0ZXJhdGlvbi5cbiAqICAgKiBga2V5YDogbG9jYWwgdmFyaWFibGUgd2hpY2ggd2lsbCByZWZlciB0byBhIHByb3BlcnR5IG5hbWUgaW4gYG9iamVjdGAgZHVyaW5nIGl0ZXJhdGlvbi5cbiAqICAgKiBgbGFiZWxgOiBUaGUgcmVzdWx0IG9mIHRoaXMgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBsYWJlbCBmb3IgYDxvcHRpb24+YCBlbGVtZW50LiBUaGVcbiAqICAgICBgZXhwcmVzc2lvbmAgd2lsbCBtb3N0IGxpa2VseSByZWZlciB0byB0aGUgYHZhbHVlYCB2YXJpYWJsZSAoZS5nLiBgdmFsdWUucHJvcGVydHlOYW1lYCkuXG4gKiAgICogYHNlbGVjdGA6IFRoZSByZXN1bHQgb2YgdGhpcyBleHByZXNzaW9uIHdpbGwgYmUgYm91bmQgdG8gdGhlIG1vZGVsIG9mIHRoZSBwYXJlbnQgYDxzZWxlY3Q+YFxuICogICAgICBlbGVtZW50LiBJZiBub3Qgc3BlY2lmaWVkLCBgc2VsZWN0YCBleHByZXNzaW9uIHdpbGwgZGVmYXVsdCB0byBgdmFsdWVgLlxuICogICAqIGBncm91cGA6IFRoZSByZXN1bHQgb2YgdGhpcyBleHByZXNzaW9uIHdpbGwgYmUgdXNlZCB0byBncm91cCBvcHRpb25zIHVzaW5nIHRoZSBgPG9wdGdyb3VwPmBcbiAqICAgICAgRE9NIGVsZW1lbnQuXG4gKiAgICogYHRyYWNrZXhwcmA6IFVzZWQgd2hlbiB3b3JraW5nIHdpdGggYW4gYXJyYXkgb2Ygb2JqZWN0cy4gVGhlIHJlc3VsdCBvZiB0aGlzIGV4cHJlc3Npb24gd2lsbCBiZVxuICogICAgICB1c2VkIHRvIGlkZW50aWZ5IHRoZSBvYmplY3RzIGluIHRoZSBhcnJheS4gVGhlIGB0cmFja2V4cHJgIHdpbGwgbW9zdCBsaWtlbHkgcmVmZXIgdG8gdGhlXG4gKiAgICAgYHZhbHVlYCB2YXJpYWJsZSAoZS5nLiBgdmFsdWUucHJvcGVydHlOYW1lYCkuXG4gKlxuICogQGV4YW1wbGVcbiAgICA8ZG9jOmV4YW1wbGU+XG4gICAgICA8ZG9jOnNvdXJjZT5cbiAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgZnVuY3Rpb24gTXlDbnRybCgkc2NvcGUpIHtcbiAgICAgICAgICAkc2NvcGUuY29sb3JzID0gW1xuICAgICAgICAgICAge25hbWU6J2JsYWNrJywgc2hhZGU6J2RhcmsnfSxcbiAgICAgICAgICAgIHtuYW1lOid3aGl0ZScsIHNoYWRlOidsaWdodCd9LFxuICAgICAgICAgICAge25hbWU6J3JlZCcsIHNoYWRlOidkYXJrJ30sXG4gICAgICAgICAgICB7bmFtZTonYmx1ZScsIHNoYWRlOidkYXJrJ30sXG4gICAgICAgICAgICB7bmFtZToneWVsbG93Jywgc2hhZGU6J2xpZ2h0J31cbiAgICAgICAgICBdO1xuICAgICAgICAgICRzY29wZS5jb2xvciA9ICRzY29wZS5jb2xvcnNbMl07IC8vIHJlZFxuICAgICAgICB9XG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICA8ZGl2IG5nLWNvbnRyb2xsZXI9XCJNeUNudHJsXCI+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbG9yIGluIGNvbG9yc1wiPlxuICAgICAgICAgICAgICBOYW1lOiA8aW5wdXQgbmctbW9kZWw9XCJjb2xvci5uYW1lXCI+XG4gICAgICAgICAgICAgIFs8YSBocmVmIG5nLWNsaWNrPVwiY29sb3JzLnNwbGljZSgkaW5kZXgsIDEpXCI+WDwvYT5dXG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICBbPGEgaHJlZiBuZy1jbGljaz1cImNvbG9ycy5wdXNoKHt9KVwiPmFkZDwvYT5dXG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPGhyLz5cbiAgICAgICAgICBDb2xvciAobnVsbCBub3QgYWxsb3dlZCk6XG4gICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cImNvbG9yXCIgbmctb3B0aW9ucz1cImMubmFtZSBmb3IgYyBpbiBjb2xvcnNcIj48L3NlbGVjdD48YnI+XG5cbiAgICAgICAgICBDb2xvciAobnVsbCBhbGxvd2VkKTpcbiAgICAgICAgICA8c3BhbiAgY2xhc3M9XCJudWxsYWJsZVwiPlxuICAgICAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cImNvbG9yXCIgbmctb3B0aW9ucz1cImMubmFtZSBmb3IgYyBpbiBjb2xvcnNcIj5cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPi0tIGNob29zZSBjb2xvciAtLTwvb3B0aW9uPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgPC9zcGFuPjxici8+XG5cbiAgICAgICAgICBDb2xvciBncm91cGVkIGJ5IHNoYWRlOlxuICAgICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XCJjb2xvclwiIG5nLW9wdGlvbnM9XCJjLm5hbWUgZ3JvdXAgYnkgYy5zaGFkZSBmb3IgYyBpbiBjb2xvcnNcIj5cbiAgICAgICAgICA8L3NlbGVjdD48YnIvPlxuXG5cbiAgICAgICAgICBTZWxlY3QgPGEgaHJlZiBuZy1jbGljaz1cImNvbG9yPXtuYW1lOidub3QgaW4gbGlzdCd9XCI+Ym9ndXM8L2E+Ljxicj5cbiAgICAgICAgICA8aHIvPlxuICAgICAgICAgIEN1cnJlbnRseSBzZWxlY3RlZDoge3sge3NlbGVjdGVkX2NvbG9yOmNvbG9yfSAgfX1cbiAgICAgICAgICA8ZGl2IHN0eWxlPVwiYm9yZGVyOnNvbGlkIDFweCBibGFjazsgaGVpZ2h0OjIwcHhcIlxuICAgICAgICAgICAgICAgbmctc3R5bGU9XCJ7J2JhY2tncm91bmQtY29sb3InOmNvbG9yLm5hbWV9XCI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kb2M6c291cmNlPlxuICAgICAgPGRvYzpzY2VuYXJpbz5cbiAgICAgICAgIGl0KCdzaG91bGQgY2hlY2sgbmctb3B0aW9ucycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICBleHBlY3QoYmluZGluZygne3NlbGVjdGVkX2NvbG9yOmNvbG9yfScpKS50b01hdGNoKCdyZWQnKTtcbiAgICAgICAgICAgc2VsZWN0KCdjb2xvcicpLm9wdGlvbignMCcpO1xuICAgICAgICAgICBleHBlY3QoYmluZGluZygne3NlbGVjdGVkX2NvbG9yOmNvbG9yfScpKS50b01hdGNoKCdibGFjaycpO1xuICAgICAgICAgICB1c2luZygnLm51bGxhYmxlJykuc2VsZWN0KCdjb2xvcicpLm9wdGlvbignJyk7XG4gICAgICAgICAgIGV4cGVjdChiaW5kaW5nKCd7c2VsZWN0ZWRfY29sb3I6Y29sb3J9JykpLnRvTWF0Y2goJ251bGwnKTtcbiAgICAgICAgIH0pO1xuICAgICAgPC9kb2M6c2NlbmFyaW8+XG4gICAgPC9kb2M6ZXhhbXBsZT5cbiAqL1xuXG52YXIgbmdPcHRpb25zRGlyZWN0aXZlID0gdmFsdWVGbih7IHRlcm1pbmFsOiB0cnVlIH0pO1xuLy8ganNoaW50IG1heGxlbjogZmFsc2VcbnZhciBzZWxlY3REaXJlY3RpdmUgPSBbJyRjb21waWxlJywgJyRwYXJzZScsIGZ1bmN0aW9uKCRjb21waWxlLCAgICRwYXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vMDAwMDExMTExMDAwMDAwMDAwMDAyMjIyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDMzMzMwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDAwMDAwMDAwMDU1NTU1NTU1NTU1NTU1NTAwMDAwMDA2NjY2NjY2NjY2NjY2NjYwMDAwMDAwMDAwMDAwMDAwNzc3NzAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4OFxuICB2YXIgTkdfT1BUSU9OU19SRUdFWFAgPSAvXlxccyooLio/KSg/Olxccythc1xccysoLio/KSk/KD86XFxzK2dyb3VwXFxzK2J5XFxzKyguKikpP1xccytmb3JcXHMrKD86KFtcXCRcXHddW1xcJFxcd10qKXwoPzpcXChcXHMqKFtcXCRcXHddW1xcJFxcd10qKVxccyosXFxzKihbXFwkXFx3XVtcXCRcXHddKilcXHMqXFwpKSlcXHMraW5cXHMrKC4qPykoPzpcXHMrdHJhY2tcXHMrYnlcXHMrKC4qPykpPyQvLFxuICAgICAgbnVsbE1vZGVsQ3RybCA9IHskc2V0Vmlld1ZhbHVlOiBub29wfTtcbi8vIGpzaGludCBtYXhsZW46IDEwMFxuXG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdFJyxcbiAgICByZXF1aXJlOiBbJ3NlbGVjdCcsICc/bmdNb2RlbCddLFxuICAgIGNvbnRyb2xsZXI6IFsnJGVsZW1lbnQnLCAnJHNjb3BlJywgJyRhdHRycycsIGZ1bmN0aW9uKCRlbGVtZW50LCAkc2NvcGUsICRhdHRycykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIG9wdGlvbnNNYXAgPSB7fSxcbiAgICAgICAgICBuZ01vZGVsQ3RybCA9IG51bGxNb2RlbEN0cmwsXG4gICAgICAgICAgbnVsbE9wdGlvbixcbiAgICAgICAgICB1bmtub3duT3B0aW9uO1xuXG5cbiAgICAgIHNlbGYuZGF0YWJvdW5kID0gJGF0dHJzLm5nTW9kZWw7XG5cblxuICAgICAgc2VsZi5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfLCBudWxsT3B0aW9uXywgdW5rbm93bk9wdGlvbl8pIHtcbiAgICAgICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG4gICAgICAgIG51bGxPcHRpb24gPSBudWxsT3B0aW9uXztcbiAgICAgICAgdW5rbm93bk9wdGlvbiA9IHVua25vd25PcHRpb25fO1xuICAgICAgfTtcblxuXG4gICAgICBzZWxmLmFkZE9wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydE5vdEhhc093blByb3BlcnR5KHZhbHVlLCAnXCJvcHRpb24gdmFsdWVcIicpO1xuICAgICAgICBvcHRpb25zTWFwW3ZhbHVlXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPT0gdmFsdWUpIHtcbiAgICAgICAgICAkZWxlbWVudC52YWwodmFsdWUpO1xuICAgICAgICAgIGlmICh1bmtub3duT3B0aW9uLnBhcmVudCgpKSB1bmtub3duT3B0aW9uLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG5cbiAgICAgIHNlbGYucmVtb3ZlT3B0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3B0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zTWFwW3ZhbHVlXTtcbiAgICAgICAgICBpZiAobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJVbmtub3duT3B0aW9uKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cblxuICAgICAgc2VsZi5yZW5kZXJVbmtub3duT3B0aW9uID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciB1bmtub3duVmFsID0gJz8gJyArIGhhc2hLZXkodmFsKSArICcgPyc7XG4gICAgICAgIHVua25vd25PcHRpb24udmFsKHVua25vd25WYWwpO1xuICAgICAgICAkZWxlbWVudC5wcmVwZW5kKHVua25vd25PcHRpb24pO1xuICAgICAgICAkZWxlbWVudC52YWwodW5rbm93blZhbCk7XG4gICAgICAgIHVua25vd25PcHRpb24ucHJvcCgnc2VsZWN0ZWQnLCB0cnVlKTsgLy8gbmVlZGVkIGZvciBJRVxuICAgICAgfTtcblxuXG4gICAgICBzZWxmLmhhc09wdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zTWFwLmhhc093blByb3BlcnR5KHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGRpc2FibGUgdW5rbm93biBvcHRpb24gc28gdGhhdCB3ZSBkb24ndCBkbyB3b3JrIHdoZW4gdGhlIHdob2xlIHNlbGVjdCBpcyBiZWluZyBkZXN0cm95ZWRcbiAgICAgICAgc2VsZi5yZW5kZXJVbmtub3duT3B0aW9uID0gbm9vcDtcbiAgICAgIH0pO1xuICAgIH1dLFxuXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHIsIGN0cmxzKSB7XG4gICAgICAvLyBpZiBuZ01vZGVsIGlzIG5vdCBkZWZpbmVkLCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICBpZiAoIWN0cmxzWzFdKSByZXR1cm47XG5cbiAgICAgIHZhciBzZWxlY3RDdHJsID0gY3RybHNbMF0sXG4gICAgICAgICAgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXSxcbiAgICAgICAgICBtdWx0aXBsZSA9IGF0dHIubXVsdGlwbGUsXG4gICAgICAgICAgb3B0aW9uc0V4cCA9IGF0dHIubmdPcHRpb25zLFxuICAgICAgICAgIG51bGxPcHRpb24gPSBmYWxzZSwgLy8gaWYgZmFsc2UsIHVzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBzZWxlY3QgaXQgKHVzZWQgYnkgbmdPcHRpb25zKVxuICAgICAgICAgIGVtcHR5T3B0aW9uLFxuICAgICAgICAgIC8vIHdlIGNhbid0IGp1c3QganFMaXRlKCc8b3B0aW9uPicpIHNpbmNlIGpxTGl0ZSBpcyBub3Qgc21hcnQgZW5vdWdoXG4gICAgICAgICAgLy8gdG8gY3JlYXRlIGl0IGluIDxzZWxlY3Q+IGFuZCBJRSBiYXJmcyBvdGhlcndpc2UuXG4gICAgICAgICAgb3B0aW9uVGVtcGxhdGUgPSBqcUxpdGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJykpLFxuICAgICAgICAgIG9wdEdyb3VwVGVtcGxhdGUgPWpxTGl0ZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpKSxcbiAgICAgICAgICB1bmtub3duT3B0aW9uID0gb3B0aW9uVGVtcGxhdGUuY2xvbmUoKTtcblxuICAgICAgLy8gZmluZCBcIm51bGxcIiBvcHRpb25cbiAgICAgIGZvcih2YXIgaSA9IDAsIGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbigpLCBpaSA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnZhbHVlID09PSAnJykge1xuICAgICAgICAgIGVtcHR5T3B0aW9uID0gbnVsbE9wdGlvbiA9IGNoaWxkcmVuLmVxKGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdEN0cmwuaW5pdChuZ01vZGVsQ3RybCwgbnVsbE9wdGlvbiwgdW5rbm93bk9wdGlvbik7XG5cbiAgICAgIC8vIHJlcXVpcmVkIHZhbGlkYXRvclxuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIG5nTW9kZWxDdHJsLiRpc0VtcHR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnNFeHApIHNldHVwQXNPcHRpb25zKHNjb3BlLCBlbGVtZW50LCBuZ01vZGVsQ3RybCk7XG4gICAgICBlbHNlIGlmIChtdWx0aXBsZSkgc2V0dXBBc011bHRpcGxlKHNjb3BlLCBlbGVtZW50LCBuZ01vZGVsQ3RybCk7XG4gICAgICBlbHNlIHNldHVwQXNTaW5nbGUoc2NvcGUsIGVsZW1lbnQsIG5nTW9kZWxDdHJsLCBzZWxlY3RDdHJsKTtcblxuXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG4gICAgICBmdW5jdGlvbiBzZXR1cEFzU2luZ2xlKHNjb3BlLCBzZWxlY3RFbGVtZW50LCBuZ01vZGVsQ3RybCwgc2VsZWN0Q3RybCkge1xuICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZpZXdWYWx1ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0Q3RybC5oYXNPcHRpb24odmlld1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVua25vd25PcHRpb24ucGFyZW50KCkpIHVua25vd25PcHRpb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICBzZWxlY3RFbGVtZW50LnZhbCh2aWV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZpZXdWYWx1ZSA9PT0gJycpIGVtcHR5T3B0aW9uLnByb3AoJ3NlbGVjdGVkJywgdHJ1ZSk7IC8vIHRvIG1ha2UgSUU5IGhhcHB5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2aWV3VmFsdWUpICYmIGVtcHR5T3B0aW9uKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQudmFsKCcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEN0cmwucmVuZGVyVW5rbm93bk9wdGlvbih2aWV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxlY3RFbGVtZW50Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodW5rbm93bk9wdGlvbi5wYXJlbnQoKSkgdW5rbm93bk9wdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUoc2VsZWN0RWxlbWVudC52YWwoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXR1cEFzTXVsdGlwbGUoc2NvcGUsIHNlbGVjdEVsZW1lbnQsIGN0cmwpIHtcbiAgICAgICAgdmFyIGxhc3RWaWV3O1xuICAgICAgICBjdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSBuZXcgSGFzaE1hcChjdHJsLiR2aWV3VmFsdWUpO1xuICAgICAgICAgIGZvckVhY2goc2VsZWN0RWxlbWVudC5maW5kKCdvcHRpb24nKSwgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpc0RlZmluZWQoaXRlbXMuZ2V0KG9wdGlvbi52YWx1ZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZG8gaXQgb24gZWFjaCB3YXRjaCBzaW5jZSBuZ01vZGVsIHdhdGNoZXMgcmVmZXJlbmNlLCBidXRcbiAgICAgICAgLy8gd2UgbmVlZCB0byB3b3JrIG9mIGFuIGFycmF5LCBzbyB3ZSBuZWVkIHRvIHNlZSBpZiBhbnl0aGluZyB3YXMgaW5zZXJ0ZWQvcmVtb3ZlZFxuICAgICAgICBzY29wZS4kd2F0Y2goZnVuY3Rpb24gc2VsZWN0TXVsdGlwbGVXYXRjaCgpIHtcbiAgICAgICAgICBpZiAoIWVxdWFscyhsYXN0VmlldywgY3RybC4kdmlld1ZhbHVlKSkge1xuICAgICAgICAgICAgbGFzdFZpZXcgPSBjb3B5KGN0cmwuJHZpZXdWYWx1ZSk7XG4gICAgICAgICAgICBjdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbGVjdEVsZW1lbnQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yRWFjaChzZWxlY3RFbGVtZW50LmZpbmQoJ29wdGlvbicpLCBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2gob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdHJsLiRzZXRWaWV3VmFsdWUoYXJyYXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0dXBBc09wdGlvbnMoc2NvcGUsIHNlbGVjdEVsZW1lbnQsIGN0cmwpIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICAgIGlmICghIChtYXRjaCA9IG9wdGlvbnNFeHAubWF0Y2goTkdfT1BUSU9OU19SRUdFWFApKSkge1xuICAgICAgICAgIHRocm93IG5nT3B0aW9uc01pbkVycignaWV4cCcsXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGV4cHJlc3Npb24gaW4gZm9ybSBvZiBcIiArXG4gICAgICAgICAgICBcIidfc2VsZWN0XyAoYXMgX2xhYmVsXyk/IGZvciAoX2tleV8sKT9fdmFsdWVfIGluIF9jb2xsZWN0aW9uXydcIiArXG4gICAgICAgICAgICBcIiBidXQgZ290ICd7MH0nLiBFbGVtZW50OiB7MX1cIixcbiAgICAgICAgICAgIG9wdGlvbnNFeHAsIHN0YXJ0aW5nVGFnKHNlbGVjdEVsZW1lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXNwbGF5Rm4gPSAkcGFyc2UobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgdmFsdWVOYW1lID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNl0sXG4gICAgICAgICAgICBrZXlOYW1lID0gbWF0Y2hbNV0sXG4gICAgICAgICAgICBncm91cEJ5Rm4gPSAkcGFyc2UobWF0Y2hbM10gfHwgJycpLFxuICAgICAgICAgICAgdmFsdWVGbiA9ICRwYXJzZShtYXRjaFsyXSA/IG1hdGNoWzFdIDogdmFsdWVOYW1lKSxcbiAgICAgICAgICAgIHZhbHVlc0ZuID0gJHBhcnNlKG1hdGNoWzddKSxcbiAgICAgICAgICAgIHRyYWNrID0gbWF0Y2hbOF0sXG4gICAgICAgICAgICB0cmFja0ZuID0gdHJhY2sgPyAkcGFyc2UobWF0Y2hbOF0pIDogbnVsbCxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYXJyYXkgb2YgYXJyYXkgb2YgZXhpc3Rpbmcgb3B0aW9uIGdyb3VwcyBpbiBET00uXG4gICAgICAgICAgICAvLyBXZSB0cnkgdG8gcmV1c2UgdGhlc2UgaWYgcG9zc2libGVcbiAgICAgICAgICAgIC8vIC0gb3B0aW9uR3JvdXBzQ2FjaGVbMF0gaXMgdGhlIG9wdGlvbnMgd2l0aCBubyBvcHRpb24gZ3JvdXBcbiAgICAgICAgICAgIC8vIC0gb3B0aW9uR3JvdXBzQ2FjaGVbP11bMF0gaXMgdGhlIHBhcmVudDogZWl0aGVyIHRoZSBTRUxFQ1Qgb3IgT1BUR1JPVVAgZWxlbWVudFxuICAgICAgICAgICAgb3B0aW9uR3JvdXBzQ2FjaGUgPSBbW3tlbGVtZW50OiBzZWxlY3RFbGVtZW50LCBsYWJlbDonJ31dXTtcblxuICAgICAgICBpZiAobnVsbE9wdGlvbikge1xuICAgICAgICAgIC8vIGNvbXBpbGUgdGhlIGVsZW1lbnQgc2luY2UgdGhlcmUgbWlnaHQgYmUgYmluZGluZ3MgaW4gaXRcbiAgICAgICAgICAkY29tcGlsZShudWxsT3B0aW9uKShzY29wZSk7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGNsYXNzLCB3aGljaCBpcyBhZGRlZCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugd2UgcmVjb21waWxlIHRoZSBlbGVtZW50IGFuZCBpdFxuICAgICAgICAgIC8vIGJlY29tZXMgdGhlIGNvbXBpbGF0aW9uIHJvb3RcbiAgICAgICAgICBudWxsT3B0aW9uLnJlbW92ZUNsYXNzKCduZy1zY29wZScpO1xuXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byByZW1vdmUgaXQgYmVmb3JlIGNhbGxpbmcgc2VsZWN0RWxlbWVudC5lbXB0eSgpIGJlY2F1c2Ugb3RoZXJ3aXNlIElFIHdpbGxcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGxhYmVsIGZyb20gdGhlIGVsZW1lbnQuIHd0Zj9cbiAgICAgICAgICBudWxsT3B0aW9uLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgY29udGVudHMsIHdlJ2xsIGFkZCB3aGF0J3MgbmVlZGVkIGJhc2VkIG9uIHRoZSBtb2RlbFxuICAgICAgICBzZWxlY3RFbGVtZW50LmVtcHR5KCk7XG5cbiAgICAgICAgc2VsZWN0RWxlbWVudC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbkdyb3VwLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSB2YWx1ZXNGbihzY29wZSkgfHwgW10sXG4gICAgICAgICAgICAgICAgbG9jYWxzID0ge30sXG4gICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgb3B0aW9uRWxlbWVudCwgaW5kZXgsIGdyb3VwSW5kZXgsIGxlbmd0aCwgZ3JvdXBMZW5ndGgsIHRyYWNrSW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGdyb3VwSW5kZXggPSAwLCBncm91cExlbmd0aCA9IG9wdGlvbkdyb3Vwc0NhY2hlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICBncm91cEluZGV4IDwgZ3JvdXBMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBvcHRpb25zIGZvciB0aGF0IGdyb3VwLiAoZmlyc3QgaXRlbSBoYXMgdGhlIHBhcmVudClcbiAgICAgICAgICAgICAgICBvcHRpb25Hcm91cCA9IG9wdGlvbkdyb3Vwc0NhY2hlW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgZm9yKGluZGV4ID0gMSwgbGVuZ3RoID0gb3B0aW9uR3JvdXAubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKChvcHRpb25FbGVtZW50ID0gb3B0aW9uR3JvdXBbaW5kZXhdLmVsZW1lbnQpWzBdLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9wdGlvbkVsZW1lbnQudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lKSBsb2NhbHNba2V5TmFtZV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja0ZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh0cmFja0luZGV4ID0gMDsgdHJhY2tJbmRleCA8IGNvbGxlY3Rpb24ubGVuZ3RoOyB0cmFja0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2Fsc1t2YWx1ZU5hbWVdID0gY29sbGVjdGlvblt0cmFja0luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja0ZuKHNjb3BlLCBsb2NhbHMpID09IGtleSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGxvY2Fsc1t2YWx1ZU5hbWVdID0gY29sbGVjdGlvbltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2godmFsdWVGbihzY29wZSwgbG9jYWxzKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXkgPSBzZWxlY3RFbGVtZW50LnZhbCgpO1xuICAgICAgICAgICAgICBpZiAoa2V5ID09ICc/Jykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJycpe1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tGbikge1xuICAgICAgICAgICAgICAgICAgZm9yICh0cmFja0luZGV4ID0gMDsgdHJhY2tJbmRleCA8IGNvbGxlY3Rpb24ubGVuZ3RoOyB0cmFja0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxzW3ZhbHVlTmFtZV0gPSBjb2xsZWN0aW9uW3RyYWNrSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tGbihzY29wZSwgbG9jYWxzKSA9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlRm4oc2NvcGUsIGxvY2Fscyk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbG9jYWxzW3ZhbHVlTmFtZV0gPSBjb2xsZWN0aW9uW2tleV07XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5TmFtZSkgbG9jYWxzW2tleU5hbWVdID0ga2V5O1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZUZuKHNjb3BlLCBsb2NhbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3RybC4kc2V0Vmlld1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3RybC4kcmVuZGVyID0gcmVuZGVyO1xuXG4gICAgICAgIC8vIFRPRE8odm9qdGEpOiBjYW4ndCB3ZSBvcHRpbWl6ZSB0aGlzID9cbiAgICAgICAgc2NvcGUuJHdhdGNoKHJlbmRlcik7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgbG9jYXRpb24gZm9yIHRoZSBvcHRpb24gZ3JvdXBzIGJlZm9yZSB3ZSByZW5kZXIgdGhlbVxuICAgICAgICAgIHZhciBvcHRpb25Hcm91cHMgPSB7Jyc6W119LFxuICAgICAgICAgICAgICBvcHRpb25Hcm91cE5hbWVzID0gWycnXSxcbiAgICAgICAgICAgICAgb3B0aW9uR3JvdXBOYW1lLFxuICAgICAgICAgICAgICBvcHRpb25Hcm91cCxcbiAgICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgICBleGlzdGluZ1BhcmVudCwgZXhpc3RpbmdPcHRpb25zLCBleGlzdGluZ09wdGlvbixcbiAgICAgICAgICAgICAgbW9kZWxWYWx1ZSA9IGN0cmwuJG1vZGVsVmFsdWUsXG4gICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlc0ZuKHNjb3BlKSB8fCBbXSxcbiAgICAgICAgICAgICAga2V5cyA9IGtleU5hbWUgPyBzb3J0ZWRLZXlzKHZhbHVlcykgOiB2YWx1ZXMsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgZ3JvdXBMZW5ndGgsIGxlbmd0aCxcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleCwgaW5kZXgsXG4gICAgICAgICAgICAgIGxvY2FscyA9IHt9LFxuICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWRTZXQgPSBmYWxzZSwgLy8gbm90aGluZyBpcyBzZWxlY3RlZCB5ZXRcbiAgICAgICAgICAgICAgbGFzdEVsZW1lbnQsXG4gICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgIGxhYmVsO1xuXG4gICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tGbiAmJiBpc0FycmF5KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkU2V0ID0gbmV3IEhhc2hNYXAoW10pO1xuICAgICAgICAgICAgICBmb3IgKHZhciB0cmFja0luZGV4ID0gMDsgdHJhY2tJbmRleCA8IG1vZGVsVmFsdWUubGVuZ3RoOyB0cmFja0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICBsb2NhbHNbdmFsdWVOYW1lXSA9IG1vZGVsVmFsdWVbdHJhY2tJbmRleF07XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRTZXQucHV0KHRyYWNrRm4oc2NvcGUsIGxvY2FscyksIG1vZGVsVmFsdWVbdHJhY2tJbmRleF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RlZFNldCA9IG5ldyBIYXNoTWFwKG1vZGVsVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdlIG5vdyBidWlsZCB1cCB0aGUgbGlzdCBvZiBvcHRpb25zIHdlIG5lZWQgKHdlIG1lcmdlIGxhdGVyKVxuICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBsZW5ndGggPSBrZXlzLmxlbmd0aCwgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAga2V5ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKCBrZXkuY2hhckF0KDApID09PSAnJCcgKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgbG9jYWxzW2tleU5hbWVdID0ga2V5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2NhbHNbdmFsdWVOYW1lXSA9IHZhbHVlc1trZXldO1xuXG4gICAgICAgICAgICBvcHRpb25Hcm91cE5hbWUgPSBncm91cEJ5Rm4oc2NvcGUsIGxvY2FscykgfHwgJyc7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25Hcm91cCA9IG9wdGlvbkdyb3Vwc1tvcHRpb25Hcm91cE5hbWVdKSkge1xuICAgICAgICAgICAgICBvcHRpb25Hcm91cCA9IG9wdGlvbkdyb3Vwc1tvcHRpb25Hcm91cE5hbWVdID0gW107XG4gICAgICAgICAgICAgIG9wdGlvbkdyb3VwTmFtZXMucHVzaChvcHRpb25Hcm91cE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gaXNEZWZpbmVkKFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkU2V0LnJlbW92ZSh0cmFja0ZuID8gdHJhY2tGbihzY29wZSwgbG9jYWxzKSA6IHZhbHVlRm4oc2NvcGUsIGxvY2FscykpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodHJhY2tGbikge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlbENhc3QgPSB7fTtcbiAgICAgICAgICAgICAgICBtb2RlbENhc3RbdmFsdWVOYW1lXSA9IG1vZGVsVmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cmFja0ZuKHNjb3BlLCBtb2RlbENhc3QpID09PSB0cmFja0ZuKHNjb3BlLCBsb2NhbHMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gbW9kZWxWYWx1ZSA9PT0gdmFsdWVGbihzY29wZSwgbG9jYWxzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZWxlY3RlZFNldCA9IHNlbGVjdGVkU2V0IHx8IHNlbGVjdGVkOyAvLyBzZWUgaWYgYXQgbGVhc3Qgb25lIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhYmVsID0gZGlzcGxheUZuKHNjb3BlLCBsb2NhbHMpOyAvLyB3aGF0IHdpbGwgYmUgc2VlbiBieSB0aGUgdXNlclxuXG4gICAgICAgICAgICAvLyBkb2luZyBkaXNwbGF5Rm4oc2NvcGUsIGxvY2FscykgfHwgJycgb3ZlcndyaXRlcyB6ZXJvIHZhbHVlc1xuICAgICAgICAgICAgbGFiZWwgPSBpc0RlZmluZWQobGFiZWwpID8gbGFiZWwgOiAnJztcbiAgICAgICAgICAgIG9wdGlvbkdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAvLyBlaXRoZXIgdGhlIGluZGV4IGludG8gYXJyYXkgb3Iga2V5IGZyb20gb2JqZWN0XG4gICAgICAgICAgICAgIGlkOiB0cmFja0ZuID8gdHJhY2tGbihzY29wZSwgbG9jYWxzKSA6IChrZXlOYW1lID8ga2V5c1tpbmRleF0gOiBpbmRleCksXG4gICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAobnVsbE9wdGlvbiB8fCBtb2RlbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIGluc2VydCBudWxsIG9wdGlvbiBpZiB3ZSBoYXZlIGEgcGxhY2Vob2xkZXIsIG9yIHRoZSBtb2RlbCBpcyBudWxsXG4gICAgICAgICAgICAgIG9wdGlvbkdyb3Vwc1snJ10udW5zaGlmdCh7aWQ6JycsIGxhYmVsOicnLCBzZWxlY3RlZDohc2VsZWN0ZWRTZXR9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGVkU2V0KSB7XG4gICAgICAgICAgICAgIC8vIG9wdGlvbiBjb3VsZCBub3QgYmUgZm91bmQsIHdlIGhhdmUgdG8gaW5zZXJ0IHRoZSB1bmRlZmluZWQgaXRlbVxuICAgICAgICAgICAgICBvcHRpb25Hcm91cHNbJyddLnVuc2hpZnQoe2lkOic/JywgbGFiZWw6JycsIHNlbGVjdGVkOnRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb3cgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgRE9NIG5vZGVzIHRvIG1hdGNoIHRoZSBvcHRpb25Hcm91cHMgd2UgY29tcHV0ZWQgYWJvdmVcbiAgICAgICAgICBmb3IgKGdyb3VwSW5kZXggPSAwLCBncm91cExlbmd0aCA9IG9wdGlvbkdyb3VwTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgZ3JvdXBJbmRleCA8IGdyb3VwTGVuZ3RoO1xuICAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50IG9wdGlvbiBncm91cCBuYW1lIG9yICcnIGlmIG5vIGdyb3VwXG4gICAgICAgICAgICBvcHRpb25Hcm91cE5hbWUgPSBvcHRpb25Hcm91cE5hbWVzW2dyb3VwSW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBsaXN0IG9mIG9wdGlvbnMgZm9yIHRoYXQgZ3JvdXAuIChmaXJzdCBpdGVtIGhhcyB0aGUgcGFyZW50KVxuICAgICAgICAgICAgb3B0aW9uR3JvdXAgPSBvcHRpb25Hcm91cHNbb3B0aW9uR3JvdXBOYW1lXTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbkdyb3Vwc0NhY2hlLmxlbmd0aCA8PSBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZ3JvdyB0aGUgb3B0aW9uR3JvdXBzXG4gICAgICAgICAgICAgIGV4aXN0aW5nUGFyZW50ID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG9wdEdyb3VwVGVtcGxhdGUuY2xvbmUoKS5hdHRyKCdsYWJlbCcsIG9wdGlvbkdyb3VwTmFtZSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbkdyb3VwLmxhYmVsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucyA9IFtleGlzdGluZ1BhcmVudF07XG4gICAgICAgICAgICAgIG9wdGlvbkdyb3Vwc0NhY2hlLnB1c2goZXhpc3RpbmdPcHRpb25zKTtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQoZXhpc3RpbmdQYXJlbnQuZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleGlzdGluZ09wdGlvbnMgPSBvcHRpb25Hcm91cHNDYWNoZVtncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgZXhpc3RpbmdQYXJlbnQgPSBleGlzdGluZ09wdGlvbnNbMF07ICAvLyBlaXRoZXIgU0VMRUNUIChubyBncm91cCkgb3IgT1BUR1JPVVAgZWxlbWVudFxuXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgT1BUR1JPVVAgbGFiZWwgaWYgbm90IHRoZSBzYW1lLlxuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXJlbnQubGFiZWwgIT0gb3B0aW9uR3JvdXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdQYXJlbnQuZWxlbWVudC5hdHRyKCdsYWJlbCcsIGV4aXN0aW5nUGFyZW50LmxhYmVsID0gb3B0aW9uR3JvdXBOYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IG51bGw7ICAvLyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICBmb3IoaW5kZXggPSAwLCBsZW5ndGggPSBvcHRpb25Hcm91cC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbkdyb3VwW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKChleGlzdGluZ09wdGlvbiA9IGV4aXN0aW5nT3B0aW9uc1tpbmRleCsxXSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXVzZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZXhpc3RpbmdPcHRpb24uZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdPcHRpb24ubGFiZWwgIT09IG9wdGlvbi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQudGV4dChleGlzdGluZ09wdGlvbi5sYWJlbCA9IG9wdGlvbi5sYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ09wdGlvbi5pZCAhPT0gb3B0aW9uLmlkKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC52YWwoZXhpc3RpbmdPcHRpb24uaWQgPSBvcHRpb24uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBsYXN0RWxlbWVudC5wcm9wKCdzZWxlY3RlZCcpIHByb3ZpZGVkIGJ5IGpRdWVyeSBoYXMgc2lkZS1lZmZlY3RzXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RFbGVtZW50WzBdLnNlbGVjdGVkICE9PSBvcHRpb24uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGxhc3RFbGVtZW50LnByb3AoJ3NlbGVjdGVkJywgKGV4aXN0aW5nT3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnNlbGVjdGVkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyb3cgZWxlbWVudHNcblxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBudWxsIG9wdGlvblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24uaWQgPT09ICcnICYmIG51bGxPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIC8vIHB1dCBiYWNrIHRoZSBwcmUtY29tcGlsZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG51bGxPcHRpb247XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGpRdWVyeSh2MS40LjIpIEJ1ZzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gY2hhaW4gdGhlIG1ldGhvZCBjYWxscywgYnV0XG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5IG9uIHNvbWUgYnJvd3NlciB0aGUgLnRleHQoKSByZXR1cm5zIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAvLyByYXRoZXIgdGhlbiB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgIChlbGVtZW50ID0gb3B0aW9uVGVtcGxhdGUuY2xvbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAudmFsKG9wdGlvbi5pZClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc2VsZWN0ZWQnLCBvcHRpb24uc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgLnRleHQob3B0aW9uLmxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBleGlzdGluZ09wdGlvbnMucHVzaChleGlzdGluZ09wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbi5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG9wdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IG9wdGlvbi5zZWxlY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgbGFzdEVsZW1lbnQuYWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUGFyZW50LmVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXhjZXNzaXZlIE9QVElPTnMgaW4gYSBncm91cFxuICAgICAgICAgICAgaW5kZXgrKzsgLy8gaW5jcmVtZW50IHNpbmNlIHRoZSBleGlzdGluZ09wdGlvbnNbMF0gaXMgcGFyZW50IGVsZW1lbnQgbm90IE9QVElPTlxuICAgICAgICAgICAgd2hpbGUoZXhpc3RpbmdPcHRpb25zLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nT3B0aW9ucy5wb3AoKS5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZW1vdmUgYW55IGV4Y2Vzc2l2ZSBPUFRHUk9VUHMgZnJvbSBzZWxlY3RcbiAgICAgICAgICB3aGlsZShvcHRpb25Hcm91cHNDYWNoZS5sZW5ndGggPiBncm91cEluZGV4KSB7XG4gICAgICAgICAgICBvcHRpb25Hcm91cHNDYWNoZS5wb3AoKVswXS5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1dO1xuXG52YXIgb3B0aW9uRGlyZWN0aXZlID0gWyckaW50ZXJwb2xhdGUnLCBmdW5jdGlvbigkaW50ZXJwb2xhdGUpIHtcbiAgdmFyIG51bGxTZWxlY3RDdHJsID0ge1xuICAgIGFkZE9wdGlvbjogbm9vcCxcbiAgICByZW1vdmVPcHRpb246IG5vb3BcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnRScsXG4gICAgcHJpb3JpdHk6IDEwMCxcbiAgICBjb21waWxlOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQoYXR0ci52YWx1ZSkpIHtcbiAgICAgICAgdmFyIGludGVycG9sYXRlRm4gPSAkaW50ZXJwb2xhdGUoZWxlbWVudC50ZXh0KCksIHRydWUpO1xuICAgICAgICBpZiAoIWludGVycG9sYXRlRm4pIHtcbiAgICAgICAgICBhdHRyLiRzZXQoJ3ZhbHVlJywgZWxlbWVudC50ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgICAgdmFyIHNlbGVjdEN0cmxOYW1lID0gJyRzZWxlY3RDb250cm9sbGVyJyxcbiAgICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCksXG4gICAgICAgICAgICBzZWxlY3RDdHJsID0gcGFyZW50LmRhdGEoc2VsZWN0Q3RybE5hbWUpIHx8XG4gICAgICAgICAgICAgIHBhcmVudC5wYXJlbnQoKS5kYXRhKHNlbGVjdEN0cmxOYW1lKTsgLy8gaW4gY2FzZSB3ZSBhcmUgaW4gb3B0Z3JvdXBcblxuICAgICAgICBpZiAoc2VsZWN0Q3RybCAmJiBzZWxlY3RDdHJsLmRhdGFib3VuZCkge1xuICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBPcGVyYSBkZWZhdWx0cyB0byB0cnVlIGFuZCBpZiBub3Qgb3ZlcnJpZGRlbiB0aGlzIG1lc3NlcyB1cCB0aGUgcmVwZWF0ZXIuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgdmlldyB0byBkcml2ZSB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIG1vZGVsIGFueXdheS5cbiAgICAgICAgICBlbGVtZW50LnByb3AoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdEN0cmwgPSBudWxsU2VsZWN0Q3RybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZUZuKSB7XG4gICAgICAgICAgc2NvcGUuJHdhdGNoKGludGVycG9sYXRlRm4sIGZ1bmN0aW9uIGludGVycG9sYXRlV2F0Y2hBY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICAgIGF0dHIuJHNldCgndmFsdWUnLCBuZXdWYWwpO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gb2xkVmFsKSBzZWxlY3RDdHJsLnJlbW92ZU9wdGlvbihvbGRWYWwpO1xuICAgICAgICAgICAgc2VsZWN0Q3RybC5hZGRPcHRpb24obmV3VmFsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RDdHJsLmFkZE9wdGlvbihhdHRyLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQub24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZWN0Q3RybC5yZW1vdmVPcHRpb24oYXR0ci52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59XTtcblxudmFyIHN0eWxlRGlyZWN0aXZlID0gdmFsdWVGbih7XG4gIHJlc3RyaWN0OiAnRScsXG4gIHRlcm1pbmFsOiB0cnVlXG59KTtcblxuICAvL3RyeSB0byBiaW5kIHRvIGpxdWVyeSBub3cgc28gdGhhdCBvbmUgY2FuIHdyaXRlIGFuZ3VsYXIuZWxlbWVudCgpLnJlYWQoKVxuICAvL2J1dCB3ZSB3aWxsIHJlYmluZCBvbiBib290c3RyYXAgYWdhaW4uXG4gIGJpbmRKUXVlcnkoKTtcblxuICBwdWJsaXNoRXh0ZXJuYWxBUEkoYW5ndWxhcik7XG5cbiAganFMaXRlKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICBhbmd1bGFySW5pdChkb2N1bWVudCwgYm9vdHN0cmFwKTtcbiAgfSk7XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXG4hYW5ndWxhci4kJGNzcCgpICYmIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj5AY2hhcnNldCBcIlVURi04XCI7W25nXFxcXDpjbG9ha10sW25nLWNsb2FrXSxbZGF0YS1uZy1jbG9ha10sW3gtbmctY2xvYWtdLC5uZy1jbG9haywueC1uZy1jbG9haywubmctaGlkZXtkaXNwbGF5Om5vbmUgIWltcG9ydGFudDt9bmdcXFxcOmZvcm17ZGlzcGxheTpibG9jazt9PC9zdHlsZT4nKTtcbjsgYnJvd3NlcmlmeV9zaGltX19kZWZpbmVfX21vZHVsZV9fZXhwb3J0X18odHlwZW9mIGFuZ3VsYXIgIT0gXCJ1bmRlZmluZWRcIiA/IGFuZ3VsYXIgOiB3aW5kb3cuYW5ndWxhcik7XG5cbn0pLmNhbGwoZ2xvYmFsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBmdW5jdGlvbiBkZWZpbmVFeHBvcnQoZXgpIHsgbW9kdWxlLmV4cG9ydHMgPSBleDsgfSk7XG4iLCJ2YXIgZ2xvYmFsPXR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTsoZnVuY3Rpb24gYnJvd3NlcmlmeVNoaW0obW9kdWxlLCBleHBvcnRzLCBkZWZpbmUsIGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKSB7XG4vKipcbiAqIExpcXVpZE1ldGFsLCB2ZXJzaW9uOiAxLjIuMSAoMjAxMi0wNC0yMSlcbiAqXG4gKiBBIG1pbWV0aWMgcG9seS1hbGxveSBvZiBRdWlja3NpbHZlcidzIHNjb3JpbmcgYWxnb3JpdGhtLCBlc3NlbnRpYWxseVxuICogTGlxdWlkTWV0YWwuXG4gKlxuICogRm9yIHVzYWdlIGFuZCBleGFtcGxlcywgdmlzaXQ6XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9ybW01dC9saXF1aWRtZXRhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQ6XG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEyLCBSeWFuIE1jR2VhcnkgKHJ5YW4gLVthdF0tIG1jZ2VhcnkgWypkb3QqXSBvcmcpXG4gKi9cbnZhciBMaXF1aWRNZXRhbCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIFNDT1JFX05PX01BVENIID0gMC4wO1xuICB2YXIgU0NPUkVfTUFUQ0ggPSAxLjA7XG4gIHZhciBTQ09SRV9UUkFJTElORyA9IDAuODtcbiAgdmFyIFNDT1JFX1RSQUlMSU5HX0JVVF9TVEFSVEVEID0gMC45O1xuICB2YXIgU0NPUkVfQlVGRkVSID0gMC44NTtcbiAgdmFyIFdPUkRfU0VQQVJBVE9SUyA9IFwiIFxcdF8tXCI7XG5cbiAgcmV0dXJuIHtcbiAgICBsYXN0U2NvcmU6IG51bGwsXG4gICAgbGFzdFNjb3JlQXJyYXk6IG51bGwsXG5cbiAgICBzY29yZTogZnVuY3Rpb24oc3RyaW5nLCBhYmJyZXYpIHtcbiAgICAgIC8vIHNob3J0IGNpcmN1aXRzXG4gICAgICBpZiAoYWJicmV2Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIFNDT1JFX1RSQUlMSU5HO1xuICAgICAgaWYgKGFiYnJldi5sZW5ndGggPiBzdHJpbmcubGVuZ3RoKSByZXR1cm4gU0NPUkVfTk9fTUFUQ0g7XG5cbiAgICAgIC8vIG1hdGNoICYgc2NvcmUgYWxsXG4gICAgICB2YXIgYWxsU2NvcmVzID0gW107XG4gICAgICB2YXIgc2VhcmNoID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICBhYmJyZXYgPSBhYmJyZXYudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuX3Njb3JlQWxsKHN0cmluZywgc2VhcmNoLCBhYmJyZXYsIC0xLCAwLCBbXSwgYWxsU2NvcmVzKTtcblxuICAgICAgLy8gY29tcGxldGUgbWlzc1xuICAgICAgaWYgKGFsbFNjb3Jlcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgICAgIC8vIHN1bSBwZXItY2hhcmFjdGVyIHNjb3JlcyBpbnRvIG92ZXJhbGwgc2NvcmVzLFxuICAgICAgLy8gc2VsZWN0aW5nIHRoZSBtYXhpbXVtIHNjb3JlXG4gICAgICB2YXIgbWF4U2NvcmUgPSAwLjAsIG1heEFycmF5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFNjb3Jlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2NvcmVzID0gYWxsU2NvcmVzW2ldO1xuICAgICAgICB2YXIgc2NvcmVTdW0gPSAwLjA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaW5nLmxlbmd0aDsgaisrKSB7IHNjb3JlU3VtICs9IHNjb3Jlc1tqXTsgfVxuICAgICAgICBpZiAoc2NvcmVTdW0gPiBtYXhTY29yZSkge1xuICAgICAgICAgIG1heFNjb3JlID0gc2NvcmVTdW07XG4gICAgICAgICAgbWF4QXJyYXkgPSBzY29yZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsaXplIG1heCBzY29yZSBieSBzdHJpbmcgbGVuZ3RoXG4gICAgICAvLyBzLiB0LiB0aGUgcGVyZmVjdCBtYXRjaCBzY29yZSA9IDFcbiAgICAgIG1heFNjb3JlIC89IHN0cmluZy5sZW5ndGg7XG5cbiAgICAgIC8vIHJlY29yZCBtYXhpbXVtIHNjb3JlICYgc2NvcmUgYXJyYXksIHJldHVyblxuICAgICAgdGhpcy5sYXN0U2NvcmUgPSBtYXhTY29yZTtcbiAgICAgIHRoaXMubGFzdFNjb3JlQXJyYXkgPSBtYXhBcnJheTtcbiAgICAgIHJldHVybiBtYXhTY29yZTtcbiAgICB9LFxuXG4gICAgX3Njb3JlQWxsOiBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaCwgYWJicmV2LCBzZWFyY2hJbmRleCwgYWJickluZGV4LCBzY29yZXMsIGFsbFNjb3Jlcykge1xuICAgICAgLy8gc2F2ZSBjb21wbGV0ZWQgbWF0Y2ggc2NvcmVzIGF0IGVuZCBvZiBzZWFyY2hcbiAgICAgIGlmIChhYmJySW5kZXggPT0gYWJicmV2Lmxlbmd0aCkge1xuICAgICAgICAvLyBhZGQgdHJhaWxpbmcgc2NvcmUgZm9yIHRoZSByZW1haW5kZXIgb2YgdGhlIG1hdGNoXG4gICAgICAgIHZhciBzdGFydGVkID0gKHNlYXJjaC5jaGFyQXQoMCkgPT0gYWJicmV2LmNoYXJBdCgwKSk7XG4gICAgICAgIHZhciB0cmFpbFNjb3JlID0gc3RhcnRlZCA/IFNDT1JFX1RSQUlMSU5HX0JVVF9TVEFSVEVEIDogU0NPUkVfVFJBSUxJTkc7XG4gICAgICAgIGZpbGxBcnJheShzY29yZXMsIHRyYWlsU2NvcmUsIHNjb3Jlcy5sZW5ndGgsIHN0cmluZy5sZW5ndGgpO1xuICAgICAgICAvLyBzYXZlIHNjb3JlIGNsb25lIChzaW5jZSByZWZlcmVuY2UgaXMgcGVyc2lzdGVkIGluIHNjb3JlcylcbiAgICAgICAgYWxsU2NvcmVzLnB1c2goc2NvcmVzLnNsaWNlKDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zdW1lIGN1cnJlbnQgY2hhciB0byBtYXRjaFxuICAgICAgdmFyIGMgPSBhYmJyZXYuY2hhckF0KGFiYnJJbmRleCk7XG4gICAgICBhYmJySW5kZXgrKztcblxuICAgICAgLy8gY2FuY2VsIG1hdGNoIGlmIGEgY2hhcmFjdGVyIGlzIG1pc3NpbmdcbiAgICAgIHZhciBpbmRleCA9IHNlYXJjaC5pbmRleE9mKGMsIHNlYXJjaEluZGV4KTtcbiAgICAgIGlmIChpbmRleCA9PSAtMSkgcmV0dXJuO1xuXG4gICAgICAvLyBtYXRjaCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBhYmJyZXZpYXRvbiBjaGFyXG4gICAgICB2YXIgc2NvcmVJbmRleCA9IHNlYXJjaEluZGV4OyAvLyBzY29yZSBzZWN0aW9uIHRvIHVwZGF0ZVxuICAgICAgd2hpbGUgKChpbmRleCA9IHNlYXJjaC5pbmRleE9mKGMsIHNlYXJjaEluZGV4KzEpKSAhPSAtMSkge1xuICAgICAgICAvLyBzY29yZSB0aGlzIG1hdGNoIGFjY29yZGluZyB0byBjb250ZXh0XG4gICAgICAgIGlmIChpc05ld1dvcmQoc3RyaW5nLCBpbmRleCkpIHtcbiAgICAgICAgICBzY29yZXNbaW5kZXgtMV0gPSAxO1xuICAgICAgICAgIGZpbGxBcnJheShzY29yZXMsIFNDT1JFX0JVRkZFUiwgc2NvcmVJbmRleCsxLCBpbmRleC0xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1VwcGVyQ2FzZShzdHJpbmcsIGluZGV4KSkge1xuICAgICAgICAgIGZpbGxBcnJheShzY29yZXMsIFNDT1JFX0JVRkZFUiwgc2NvcmVJbmRleCsxLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmlsbEFycmF5KHNjb3JlcywgU0NPUkVfTk9fTUFUQ0gsIHNjb3JlSW5kZXgrMSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHNjb3Jlc1tpbmRleF0gPSBTQ09SRV9NQVRDSDtcblxuICAgICAgICAvLyBjb25zdW1lIG1hdGNoZWQgc3RyaW5nIGFuZCBjb250aW51ZSBzZWFyY2hcbiAgICAgICAgc2VhcmNoSW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fc2NvcmVBbGwoc3RyaW5nLCBzZWFyY2gsIGFiYnJldiwgc2VhcmNoSW5kZXgsIGFiYnJJbmRleCwgc2NvcmVzLCBhbGxTY29yZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1VwcGVyQ2FzZShzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gKFwiQVwiIDw9IGMgJiYgYyA8PSBcIlpcIik7XG4gIH1cblxuICAgZnVuY3Rpb24gaXNOZXdXb3JkKHN0cmluZywgaW5kZXgpIHtcbiAgICB2YXIgYyA9IHN0cmluZy5jaGFyQXQoaW5kZXgtMSk7XG4gICAgcmV0dXJuIChXT1JEX1NFUEFSQVRPUlMuaW5kZXhPZihjKSAhPSAtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsQXJyYXkoYXJyYXksIHZhbHVlLCBmcm9tLCB0bykge1xuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykgeyBhcnJheVtpXSA9IHZhbHVlOyB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59KSgpO1xuXG47IGJyb3dzZXJpZnlfc2hpbV9fZGVmaW5lX19tb2R1bGVfX2V4cG9ydF9fKHR5cGVvZiBMaXF1aWRNZXRhbCAhPSBcInVuZGVmaW5lZFwiID8gTGlxdWlkTWV0YWwgOiB3aW5kb3cuTGlxdWlkTWV0YWwpO1xuXG59KS5jYWxsKGdsb2JhbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZnVuY3Rpb24gZGVmaW5lRXhwb3J0KGV4KSB7IG1vZHVsZS5leHBvcnRzID0gZXg7IH0pO1xuIiwidmFyIGdsb2JhbD10eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge307KGZ1bmN0aW9uIGJyb3dzZXJpZnlTaGltKG1vZHVsZSwgZXhwb3J0cywgZGVmaW5lLCBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXykge1xuLyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjQuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1vIC4vZGlzdC9sb2Rhc2guanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIHRvIHBvb2wgYXJyYXlzIGFuZCBvYmplY3RzIHVzZWQgaW50ZXJuYWxseSAqL1xuICB2YXIgYXJyYXlQb29sID0gW10sXG4gICAgICBvYmplY3RQb29sID0gW107XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYW5kIHRlc3Qgd2hpdGVzcGFjZSAqL1xuICB2YXIgd2hpdGVzcGFjZSA9IChcbiAgICAvLyB3aGl0ZXNwYWNlXG4gICAgJyBcXHRcXHgwQlxcZlxceEEwXFx1ZmVmZicgK1xuXG4gICAgLy8gbGluZSB0ZXJtaW5hdG9yc1xuICAgICdcXG5cXHJcXHUyMDI4XFx1MjAyOScgK1xuXG4gICAgLy8gdW5pY29kZSBjYXRlZ29yeSBcIlpzXCIgc3BhY2Ugc2VwYXJhdG9yc1xuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UgKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1saXRlcmFscy1zdHJpbmctbGl0ZXJhbHNcbiAgICovXG4gIHZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcmVnZXhwIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBkZXRlY3RlZCBuYW1lZCBmdW5jdGlvbnMgKi9cbiAgdmFyIHJlRnVuY05hbWUgPSAvXlxccypmdW5jdGlvblsgXFxuXFxyXFx0XStcXHcvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFwiaW50ZXJwb2xhdGVcIiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCB6ZXJvcyB0byBiZSByZW1vdmVkICovXG4gIHZhciByZUxlYWRpbmdTcGFjZXNBbmRaZXJvcyA9IFJlZ0V4cCgnXlsnICsgd2hpdGVzcGFjZSArICddKjArKD89LiQpJyk7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gL1xcYnRoaXNcXGIvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHRcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdGdW5jdGlvbicsICdNYXRoJywgJ051bWJlcicsICdPYmplY3QnLFxuICAgICdSZWdFeHAnLCAnU3RyaW5nJywgJ18nLCAnYXR0YWNoRXZlbnQnLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ2lzTmFOJyxcbiAgICAncGFyc2VJbnQnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5ICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAwO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5Q2xhc3MgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgX19iaW5kRGF0YV9fYCAqL1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBudWxsLFxuICAgICd3cml0YWJsZSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHQnOiAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8uY29udGFpbnNgIGZvciBjYWNoZSBvYmplY3RzIHRoYXQgbWltaWNzIHRoZSByZXR1cm5cbiAgICogc2lnbmF0dXJlIG9mIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV0gPyAwIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gKGNhY2hlID0gY2FjaGVbdHlwZV0pICYmIGNhY2hlW2tleV07XG5cbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgPyAoY2FjaGUgJiYgYmFzZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGUgPyAwIDogLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnaXZlbiB2YWx1ZSB0byB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNhY2hlW3ZhbHVlXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlLFxuICAgICAgICAgIHR5cGVDYWNoZSA9IGNhY2hlW3R5cGVdIHx8IChjYWNoZVt0eXBlXSA9IHt9KTtcblxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayB3aGVuIGEgZ2l2ZW5cbiAgICogY29sbGVjdGlvbiBpcyBhIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBjaGFyYWN0ZXIgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29kZSB1bml0IG9mIGdpdmVuIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJBdENhbGxiYWNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGBjb2xsZWN0aW9uYCBlbGVtZW50cywgc3RhYmxlIHNvcnRpbmdcbiAgICogdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYWAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIG9mIGAxYCBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gICAgdmFyIGFjID0gYS5jcml0ZXJpYSxcbiAgICAgICAgYmMgPSBiLmNyaXRlcmlhLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhYy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYWNbaW5kZXhdLFxuICAgICAgICAgIG90aGVyID0gYmNbaW5kZXhdO1xuXG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+IG90aGVyIHx8IHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IG90aGVyIHx8IHR5cGVvZiBvdGhlciA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgIC8vIGBhYCBhbmQgYGJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgIC8vXG4gICAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgICAvLyBTZWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTBcbiAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IG9yIGBudWxsYCBpZiBjYWNoaW5nIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgZmlyc3QgPSBhcnJheVswXSxcbiAgICAgICAgbWlkID0gYXJyYXlbKGxlbmd0aCAvIDIpIHwgMF0sXG4gICAgICAgIGxhc3QgPSBhcnJheVtsZW5ndGggLSAxXTtcblxuICAgIGlmIChmaXJzdCAmJiB0eXBlb2YgZmlyc3QgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgbWlkICYmIHR5cGVvZiBtaWQgPT0gJ29iamVjdCcgJiYgbGFzdCAmJiB0eXBlb2YgbGFzdCA9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FjaGUgPSBnZXRPYmplY3QoKTtcbiAgICBjYWNoZVsnZmFsc2UnXSA9IGNhY2hlWydudWxsJ10gPSBjYWNoZVsndHJ1ZSddID0gY2FjaGVbJ3VuZGVmaW5lZCddID0gZmFsc2U7XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0T2JqZWN0KCk7XG4gICAgcmVzdWx0LmFycmF5ID0gYXJyYXk7XG4gICAgcmVzdWx0LmNhY2hlID0gY2FjaGU7XG4gICAgcmVzdWx0LnB1c2ggPSBjYWNoZVB1c2g7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZFxuICAgKiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhcnJheSBmcm9tIHRoZSBhcnJheSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXJyYXkoKSB7XG4gICAgcmV0dXJuIGFycmF5UG9vbC5wb3AoKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9iamVjdCBmcm9tIHRoZSBvYmplY3QgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBmcm9tIHRoZSBwb29sLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0KCkge1xuICAgIHJldHVybiBvYmplY3RQb29sLnBvcCgpIHx8IHtcbiAgICAgICdhcnJheSc6IG51bGwsXG4gICAgICAnY2FjaGUnOiBudWxsLFxuICAgICAgJ2NyaXRlcmlhJzogbnVsbCxcbiAgICAgICdmYWxzZSc6IGZhbHNlLFxuICAgICAgJ2luZGV4JzogMCxcbiAgICAgICdudWxsJzogZmFsc2UsXG4gICAgICAnbnVtYmVyJzogbnVsbCxcbiAgICAgICdvYmplY3QnOiBudWxsLFxuICAgICAgJ3B1c2gnOiBudWxsLFxuICAgICAgJ3N0cmluZyc6IG51bGwsXG4gICAgICAndHJ1ZSc6IGZhbHNlLFxuICAgICAgJ3VuZGVmaW5lZCc6IGZhbHNlLFxuICAgICAgJ3ZhbHVlJzogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIGFycmF5IGJhY2sgdG8gdGhlIGFycmF5IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlQXJyYXkoYXJyYXkpIHtcbiAgICBhcnJheS5sZW5ndGggPSAwO1xuICAgIGlmIChhcnJheVBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIGFycmF5UG9vbC5wdXNoKGFycmF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIG9iamVjdCBiYWNrIHRvIHRoZSBvYmplY3QgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VPYmplY3Qob2JqZWN0KSB7XG4gICAgdmFyIGNhY2hlID0gb2JqZWN0LmNhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgcmVsZWFzZU9iamVjdChjYWNoZSk7XG4gICAgfVxuICAgIG9iamVjdC5hcnJheSA9IG9iamVjdC5jYWNoZSA9IG9iamVjdC5jcml0ZXJpYSA9IG9iamVjdC5vYmplY3QgPSBvYmplY3QubnVtYmVyID0gb2JqZWN0LnN0cmluZyA9IG9iamVjdC52YWx1ZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFBvb2wubGVuZ3RoIDwgbWF4UG9vbFNpemUpIHtcbiAgICAgIG9iamVjdFBvb2wucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGBjb2xsZWN0aW9uYCBmcm9tIHRoZSBgc3RhcnRgIGluZGV4IHVwIHRvLCBidXQgbm90IGluY2x1ZGluZyxcbiAgICogdGhlIGBlbmRgIGluZGV4LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiBgQXJyYXkjc2xpY2VgIHRvIHN1cHBvcnQgbm9kZSBsaXN0c1xuICAgKiBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCB8fCAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gY29udGV4dCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9cm9vdF0gVGhlIGNvbnRleHQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICAvLyBBdm9pZCBpc3N1ZXMgd2l0aCBzb21lIEVTMyBlbnZpcm9ubWVudHMgdGhhdCBhdHRlbXB0IHRvIHVzZSB2YWx1ZXMsIG5hbWVkXG4gICAgLy8gYWZ0ZXIgYnVpbHQtaW4gY29uc3RydWN0b3JzIGxpa2UgYE9iamVjdGAsIGZvciB0aGUgY3JlYXRpb24gb2YgbGl0ZXJhbHMuXG4gICAgLy8gRVM1IGNsZWFycyB0aGlzIHVwIGJ5IHN0YXRpbmcgdGhhdCBsaXRlcmFscyBtdXN0IHVzZSBidWlsdC1pbiBjb25zdHJ1Y3RvcnMuXG4gICAgLy8gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTEuMS41LlxuICAgIGNvbnRleHQgPSBjb250ZXh0ID8gXy5kZWZhdWx0cyhyb290Lk9iamVjdCgpLCBjb250ZXh0LCBfLnBpY2socm9vdCwgY29udGV4dFByb3BzKSkgOiByb290O1xuXG4gICAgLyoqIE5hdGl2ZSBjb25zdHJ1Y3RvciByZWZlcmVuY2VzICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgQm9vbGVhbiA9IGNvbnRleHQuQm9vbGVhbixcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBOdW1iZXIgPSBjb250ZXh0Lk51bWJlcixcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dC5PYmplY3QsXG4gICAgICAgIFJlZ0V4cCA9IGNvbnRleHQuUmVnRXhwLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0LlN0cmluZyxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dC5UeXBlRXJyb3I7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBgQXJyYXlgIG1ldGhvZCByZWZlcmVuY2VzLlxuICAgICAqXG4gICAgICogTm9ybWFsbHkgYEFycmF5LnByb3RvdHlwZWAgd291bGQgc3VmZmljZSwgaG93ZXZlciwgdXNpbmcgYW4gYXJyYXkgbGl0ZXJhbFxuICAgICAqIGF2b2lkcyBpc3N1ZXMgaW4gTmFyd2hhbC5cbiAgICAgKi9cbiAgICB2YXIgYXJyYXlSZWYgPSBbXTtcblxuICAgIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgbm9Db25mbGljdGAgKi9cbiAgICB2YXIgb2xkRGFzaCA9IGNvbnRleHQuXztcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGludGVybmFsIFtbQ2xhc3NdXSBvZiB2YWx1ZXMgKi9cbiAgICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUgKi9cbiAgICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIFN0cmluZyh0b1N0cmluZylcbiAgICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAgICAgLnJlcGxhY2UoL3RvU3RyaW5nfCBmb3IgW15cXF1dKy9nLCAnLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzICovXG4gICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIGNsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0LFxuICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIGdldFByb3RvdHlwZU9mID0gaXNOYXRpdmUoZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YpICYmIGdldFByb3RvdHlwZU9mLFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgICAgICBwdXNoID0gYXJyYXlSZWYucHVzaCxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlSZWYuc3BsaWNlLFxuICAgICAgICB1bnNoaWZ0ID0gYXJyYXlSZWYudW5zaGlmdDtcblxuICAgIC8qKiBVc2VkIHRvIHNldCBtZXRhIGRhdGEgb24gZnVuY3Rpb25zICovXG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSUUgOCBvbmx5IGFjY2VwdHMgRE9NIGVsZW1lbnRzXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbyA9IHt9LFxuICAgICAgICAgICAgZnVuYyA9IGlzTmF0aXZlKGZ1bmMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIGZ1bmMsXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKG8sIG8sIG8pICYmIGZ1bmM7XG4gICAgICB9IGNhdGNoKGUpIHsgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KCkpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgICB2YXIgbmF0aXZlQ3JlYXRlID0gaXNOYXRpdmUobmF0aXZlQ3JlYXRlID0gT2JqZWN0LmNyZWF0ZSkgJiYgbmF0aXZlQ3JlYXRlLFxuICAgICAgICBuYXRpdmVJc0FycmF5ID0gaXNOYXRpdmUobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXksXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSXNOYU4gPSBjb250ZXh0LmlzTmFOLFxuICAgICAgICBuYXRpdmVLZXlzID0gaXNOYXRpdmUobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgYSBidWlsdC1pbiBjb25zdHJ1Y3RvciBieSBbW0NsYXNzXV0gKi9cbiAgICB2YXIgY3RvckJ5Q2xhc3MgPSB7fTtcbiAgICBjdG9yQnlDbGFzc1thcnJheUNsYXNzXSA9IEFycmF5O1xuICAgIGN0b3JCeUNsYXNzW2Jvb2xDbGFzc10gPSBCb29sZWFuO1xuICAgIGN0b3JCeUNsYXNzW2RhdGVDbGFzc10gPSBEYXRlO1xuICAgIGN0b3JCeUNsYXNzW2Z1bmNDbGFzc10gPSBGdW5jdGlvbjtcbiAgICBjdG9yQnlDbGFzc1tvYmplY3RDbGFzc10gPSBPYmplY3Q7XG4gICAgY3RvckJ5Q2xhc3NbbnVtYmVyQ2xhc3NdID0gTnVtYmVyO1xuICAgIGN0b3JCeUNsYXNzW3JlZ2V4cENsYXNzXSA9IFJlZ0V4cDtcbiAgICBjdG9yQnlDbGFzc1tzdHJpbmdDbGFzc10gPSBTdHJpbmc7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHRvIGVuYWJsZSBpbnR1aXRpdmVcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBMby1EYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICAgKiBgY29tcG9zZWAsIGBjb25jYXRgLCBgY291bnRCeWAsIGBjcmVhdGVgLCBgY3JlYXRlQ2FsbGJhY2tgLCBgY3VycnlgLFxuICAgICAqIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCxcbiAgICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG4gICAgICogYGludm9rZWAsIGBrZXlzYCwgYG1hcGAsIGBtYXhgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaW5gLCBgb2JqZWN0YCwgYG9taXRgLFxuICAgICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICAgKiBgcmFuZ2VgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc29ydEJ5YCwgYHNwbGljZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0cmFuc2Zvcm1gLFxuICAgICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAgICogYW5kIGB6aXBgXG4gICAgICpcbiAgICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGNsb25lYCwgYGNsb25lRGVlcGAsIGBjb250YWluc2AsIGBlc2NhcGVgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLFxuICAgICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgaGFzYCwgYGlkZW50aXR5YCxcbiAgICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCxcbiAgICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBqb2luYCxcbiAgICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAgICogYHJlZHVjZVJpZ2h0YCwgYHJlc3VsdGAsIGBzaGlmdGAsIGBzaXplYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgcnVuSW5Db250ZXh0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBhbmQgYHZhbHVlYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb25zIGBmaXJzdGAgYW5kIGBsYXN0YCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBgbmAgaXNcbiAgICAgKiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZXkgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbmluZyBjYW4gYmUgZW5hYmxlZCBieSB1c2luZyB0aGUgYF8uY2hhaW5gIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAqIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgLy8gZG9uJ3Qgd3JhcCBpZiBhbHJlYWR5IHdyYXBwZWQsIGV2ZW4gaWYgd3JhcHBlZCBieSBhIGRpZmZlcmVudCBgbG9kYXNoYCBjb25zdHJ1Y3RvclxuICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKVxuICAgICAgID8gdmFsdWVcbiAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhc3QgcGF0aCBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGFpbkFsbCBBIGZsYWcgdG8gZW5hYmxlIGNoYWluaW5nIGZvciBhbGwgbWV0aG9kc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICAgIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICogKGFsbCBidXQgUFMzIGFuZCBvbGRlciBPcGVyYSBtb2JpbGUgYnJvd3NlcnMgJiBhdm9pZGVkIGluIFdpbmRvd3MgOCBhcHBzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIWlzTmF0aXZlKGNvbnRleHQuV2luUlRFcnJvcikgJiYgcmVUaGlzLnRlc3QocnVuSW5Db250ZXh0KTtcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBgRnVuY3Rpb24jbmFtZWAgaXMgc3VwcG9ydGVkIChhbGwgYnV0IElFKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jTmFtZXMgPSB0eXBlb2YgRnVuY3Rpb24ubmFtZSA9PSAnc3RyaW5nJztcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgTG8tRGFzaCBhcmUgc2ltaWxhciB0byB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZVxuICAgICAqIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IC88JS0oW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYmluZGAgdGhhdCBjcmVhdGVzIHRoZSBib3VuZCBmdW5jdGlvbiBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUJpbmQoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgcGFydGlhbEFyZ3MgPSBiaW5kRGF0YVsyXSxcbiAgICAgICAgICB0aGlzQXJnID0gYmluZERhdGFbNF07XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjMuNC41XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAgIC8vIGF2b2lkIGBhcmd1bWVudHNgIG9iamVjdCBkZW9wdGltaXphdGlvbnMgYnkgdXNpbmcgYHNsaWNlYCBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgYEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsYCBhbmQgbm90IGFzc2lnbmluZyBgYXJndW1lbnRzYCB0byBhXG4gICAgICAgICAgLy8gdmFyaWFibGUgYXMgYSB0ZXJuYXJ5IGV4cHJlc3Npb25cbiAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKHBhcnRpYWxBcmdzKTtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3JcbiAgICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMy4yLjJcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIC8vIGVuc3VyZSBgbmV3IGJvdW5kYCBpcyBhbiBpbnN0YW5jZSBvZiBgZnVuY2BcbiAgICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyB8fCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgY2xvbmVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluc3BlY3QgW1tDbGFzc11dXG4gICAgICB2YXIgaXNPYmogPSBpc09iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICBpZiAoIWNsb25lYWJsZUNsYXNzZXNbY2xhc3NOYW1lXSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3RvciA9IGN0b3JCeUNsYXNzW2NsYXNzTmFtZV07XG4gICAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoK3ZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3Rvcih2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICAgICAgcmVzdWx0ID0gY3Rvcih2YWx1ZS5zb3VyY2UsIHJlRmxhZ3MuZXhlYyh2YWx1ZSkpO1xuICAgICAgICAgICAgcmVzdWx0Lmxhc3RJbmRleCA9IHZhbHVlLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGNvcnJlc3BvbmRpbmcgY2xvbmVcbiAgICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgICAgc3RhY2tCIHx8IChzdGFja0IgPSBnZXRBcnJheSgpKTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGlzQXJyID8gY3Rvcih2YWx1ZS5sZW5ndGgpIDoge307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBzbGljZSh2YWx1ZSkgOiBhc3NpZ24oe30sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2BcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2luZGV4JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5kZXggPSB2YWx1ZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2lucHV0JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBmb3Igc2hhbGxvdyBjbG9uZVxuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIGFkZCB0aGUgc291cmNlIHZhbHVlIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgLy8gYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZVxuICAgICAgc3RhY2tBLnB1c2godmFsdWUpO1xuICAgICAgc3RhY2tCLnB1c2gocmVzdWx0KTtcblxuICAgICAgLy8gcmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikodmFsdWUsIGZ1bmN0aW9uKG9ialZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlQ2xvbmUob2JqVmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvdHlwZSkgPyBuYXRpdmVDcmVhdGUocHJvdG90eXBlKSA6IHt9O1xuICAgIH1cbiAgICAvLyBmYWxsYmFjayBmb3IgYnJvd3NlcnMgd2l0aG91dCBgT2JqZWN0LmNyZWF0ZWBcbiAgICBpZiAoIW5hdGl2ZUNyZWF0ZSkge1xuICAgICAgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gT2JqZWN0KCkge31cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgICAgICAgIGlmIChpc09iamVjdChwcm90b3R5cGUpKSB7XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPYmplY3Q7XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBjb250ZXh0Lk9iamVjdCgpO1xuICAgICAgICB9O1xuICAgICAgfSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVDYWxsYmFja2Agd2l0aG91dCBzdXBwb3J0IGZvciBjcmVhdGluZ1xuICAgICAqIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBubyBgdGhpc0FyZ2Agb3IgYWxyZWFkeSBib3VuZCBieSBgRnVuY3Rpb24jYmluZGBcbiAgICAgIGlmICh0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyB8fCAhKCdwcm90b3R5cGUnIGluIGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgdmFyIGJpbmREYXRhID0gZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAodHlwZW9mIGJpbmREYXRhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgIGJpbmREYXRhID0gIWZ1bmMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBiaW5kRGF0YSA9IGJpbmREYXRhIHx8ICFzdXBwb3J0LmZ1bmNEZWNvbXA7XG4gICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gZm5Ub1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICAgIGlmICghc3VwcG9ydC5mdW5jTmFtZXMpIHtcbiAgICAgICAgICAgIGJpbmREYXRhID0gIXJlRnVuY05hbWUudGVzdChzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWJpbmREYXRhKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgaWYgYGZ1bmNgIHJlZmVyZW5jZXMgdGhlIGB0aGlzYCBrZXl3b3JkIGFuZCBzdG9yZXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgYmluZERhdGEgPSByZVRoaXMudGVzdChzb3VyY2UpO1xuICAgICAgICAgICAgc2V0QmluZERhdGEoZnVuYywgYmluZERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXhpdCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gYHRoaXNgIHJlZmVyZW5jZXMgb3IgYGZ1bmNgIGlzIGJvdW5kXG4gICAgICBpZiAoYmluZERhdGEgPT09IGZhbHNlIHx8IChiaW5kRGF0YSAhPT0gdHJ1ZSAmJiBiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhcmdDb3VudCkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhLCBiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiaW5kKGZ1bmMsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBjcmVhdGVXcmFwcGVyYCB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwZXIgYW5kXG4gICAgICogc2V0cyBpdHMgbWV0YSBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBiaW5kRGF0YSBUaGUgYmluZCBkYXRhIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGVXcmFwcGVyKGJpbmREYXRhKSB7XG4gICAgICB2YXIgZnVuYyA9IGJpbmREYXRhWzBdLFxuICAgICAgICAgIGJpdG1hc2sgPSBiaW5kRGF0YVsxXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHBhcnRpYWxSaWdodEFyZ3MgPSBiaW5kRGF0YVszXSxcbiAgICAgICAgICB0aGlzQXJnID0gYmluZERhdGFbNF0sXG4gICAgICAgICAgYXJpdHkgPSBiaW5kRGF0YVs1XTtcblxuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBrZXkgPSBmdW5jO1xuXG4gICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXM7XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncykge1xuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncyB8fCBpc0N1cnJ5KSB7XG4gICAgICAgICAgYXJncyB8fCAoYXJncyA9IHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzKSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDdXJyeSAmJiBhcmdzLmxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IDE2ICYgfjMyO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVXcmFwcGVyKFtmdW5jLCAoaXNDdXJyeUJvdW5kID8gYml0bWFzayA6IGJpdG1hc2sgJiB+MyksIGFyZ3MsIG51bGwsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNCaW5kS2V5KSB7XG4gICAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB0aGF0IGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgaXNMYXJnZSA9IGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlT2JqZWN0KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBpc1N0cmljdCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VGbGF0dGVuKHZhbHVlLCBpc1NoYWxsb3csIGlzU3RyaWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbEluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIHZhbExlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgcmVzSW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgLCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzQXJnYCBiaW5kaW5nLFxuICAgICAqIHRoYXQgYWxsb3dzIHBhcnRpYWwgXCJfLndoZXJlXCIgc3R5bGUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2lzV2hlcmU9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgYWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBiYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAvLyB1c2VkIHRvIGluZGljYXRlIHRoYXQgd2hlbiBjb21wYXJpbmcgb2JqZWN0cywgYGFgIGhhcyBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyBvZiBgYmBcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYSxcbiAgICAgICAgICBvdGhlclR5cGUgPSB0eXBlb2YgYjtcblxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBhICYmXG4gICAgICAgICAgIShhICYmIG9iamVjdFR5cGVzW3R5cGVdKSAmJlxuICAgICAgICAgICEoYiAmJiBvYmplY3RUeXBlc1tvdGhlclR5cGVdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGF2b2lkaW5nIEVTMydzIEZ1bmN0aW9uI2NhbGwgYmVoYXZpb3JcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjRcbiAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuICAgICAgLy8gY29tcGFyZSBbW0NsYXNzXV0gbmFtZXNcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpLFxuICAgICAgICAgIG90aGVyQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGIpO1xuXG4gICAgICBpZiAoY2xhc3NOYW1lID09IGFyZ3NDbGFzcykge1xuICAgICAgICBjbGFzc05hbWUgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlckNsYXNzID09IGFyZ3NDbGFzcykge1xuICAgICAgICBvdGhlckNsYXNzID0gb2JqZWN0Q2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAoY2xhc3NOYW1lICE9IG90aGVyQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiAoYSAhPSArYSlcbiAgICAgICAgICAgID8gYiAhPSArYlxuICAgICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgICA6IChhID09IDAgPyAoMSAvIGEgPT0gMSAvIGIpIDogYSA9PSArYik7XG5cbiAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNClcbiAgICAgICAgICAvLyB0cmVhdCBzdHJpbmcgcHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3QgaW5zdGFuY2VzIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gY2xhc3NOYW1lID09IGFycmF5Q2xhc3M7XG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIC8vIHVud3JhcCBhbnkgYGxvZGFzaGAgd3JhcHBlZCB2YWx1ZXNcbiAgICAgICAgdmFyIGFXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIGJXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChiLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAoYVdyYXBwZWQgfHwgYldyYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYVdyYXBwZWQgPyBhLl9fd3JhcHBlZF9fIDogYSwgYldyYXBwZWQgPyBiLl9fd3JhcHBlZF9fIDogYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleGl0IGZvciBmdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IG9iamVjdENsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhLCBgYXJndW1lbnRzYCBvYmplY3RzIGhhdmUgYEFycmF5YCBjb25zdHJ1Y3RvcnNcbiAgICAgICAgdmFyIGN0b3JBID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIGN0b3JCID0gYi5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBub24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbFxuICAgICAgICBpZiAoY3RvckEgIT0gY3RvckIgJiZcbiAgICAgICAgICAgICAgIShpc0Z1bmN0aW9uKGN0b3JBKSAmJiBjdG9yQSBpbnN0YW5jZW9mIGN0b3JBICYmIGlzRnVuY3Rpb24oY3RvckIpICYmIGN0b3JCIGluc3RhbmNlb2YgY3RvckIpICYmXG4gICAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgY3ljbGljIHN0cnVjdHVyZXMgYXJlIGVxdWFsXG4gICAgICAvLyB0aGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMVxuICAgICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMi4zKVxuICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gYSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAvLyBhZGQgYGFgIGFuZCBgYmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICBzdGFja0EucHVzaChhKTtcbiAgICAgIHN0YWNrQi5wdXNoKGIpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgLy8gY29tcGFyZSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnlcbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIHNpemUgPSBiLmxlbmd0aDtcbiAgICAgICAgcmVzdWx0ID0gc2l6ZSA9PSBsZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlc3VsdCB8fCBpc1doZXJlKSB7XG4gICAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJbc2l6ZV07XG5cbiAgICAgICAgICAgIGlmIChpc1doZXJlKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKChyZXN1bHQgPSBiYXNlSXNFcXVhbChhW2luZGV4XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShyZXN1bHQgPSBiYXNlSXNFcXVhbChhW3NpemVdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIG9iamVjdHMgdXNpbmcgYGZvckluYCwgaW5zdGVhZCBvZiBgZm9yT3duYCwgdG8gYXZvaWQgYE9iamVjdC5rZXlzYFxuICAgICAgICAvLyB3aGljaCwgaW4gdGhpcyBjYXNlLCBpcyBtb3JlIGNvc3RseVxuICAgICAgICBmb3JJbihiLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBiKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgLy8gZGVlcCBjb21wYXJlIGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSAmJiBiYXNlSXNFcXVhbChhW2tleV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgJiYgIWlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgYm90aCBvYmplY3RzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcbiAgICAgICAgICBmb3JJbihhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBhKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIGBzaXplYCB3aWxsIGJlIGAtMWAgaWYgYGFgIGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBgYmBcbiAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAtLXNpemUgPiAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrQS5wb3AoKTtcbiAgICAgIHN0YWNrQi5wb3AoKTtcblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgYXJndW1lbnQganVnZ2xpbmcgb3Igc3VwcG9ydFxuICAgICAqIGZvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgKGlzQXJyYXkoc291cmNlKSA/IGZvckVhY2ggOiBmb3JPd24pKHNvdXJjZSwgZnVuY3Rpb24oc291cmNlLCBrZXkpIHtcbiAgICAgICAgdmFyIGZvdW5kLFxuICAgICAgICAgICAgaXNBcnIsXG4gICAgICAgICAgICByZXN1bHQgPSBzb3VyY2UsXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmIChzb3VyY2UgJiYgKChpc0FyciA9IGlzQXJyYXkoc291cmNlKSkgfHwgaXNQbGFpbk9iamVjdChzb3VyY2UpKSkge1xuICAgICAgICAgIC8vIGF2b2lkIG1lcmdpbmcgcHJldmlvdXNseSBtZXJnZWQgY3ljbGljIHNvdXJjZXNcbiAgICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdGFja0xlbmd0aC0tKSB7XG4gICAgICAgICAgICBpZiAoKGZvdW5kID0gc3RhY2tBW3N0YWNrTGVuZ3RoXSA9PSBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3RhY2tCW3N0YWNrTGVuZ3RoXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIHZhciBpc1NoYWxsb3c7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICAgIGlmICgoaXNTaGFsbG93ID0gdHlwZW9mIHJlc3VsdCAhPSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBpc0FyclxuICAgICAgICAgICAgICAgID8gKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSlcbiAgICAgICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGBzb3VyY2VgIGFuZCBhc3NvY2lhdGVkIGB2YWx1ZWAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAgICAgICBzdGFja0EucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgc3RhY2tCLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgYmFzZU1lcmdlKHZhbHVlLCBzb3VyY2UsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIHJldHVybmluZyBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBvciBgdGhpc0FyZ2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB2YXIgaXNMYXJnZSA9ICFpc1NvcnRlZCAmJiBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzZUluZGV4T2YsXG4gICAgICAgICAgc2VlbiA9IChjYWxsYmFjayB8fCBpc0xhcmdlKSA/IGdldEFycmF5KCkgOiByZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNyZWF0ZUNhY2hlKHNlZW4pO1xuICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICBzZWVuID0gY2FjaGU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNTb3J0ZWRcbiAgICAgICAgICAgICAgPyAhaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSBjb21wdXRlZFxuICAgICAgICAgICAgICA6IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4uYXJyYXkpO1xuICAgICAgICByZWxlYXNlT2JqZWN0KHNlZW4pO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYSBjb2xsZWN0aW9uLCBjcmVhdGluZyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCBhIGNhbGxiYWNrLiBUaGUgZ2l2ZW4gYHNldHRlcmAgZnVuY3Rpb24gc2V0cyB0aGUga2V5cyBhbmQgdmFsdWVzXG4gICAgICogb2YgdGhlIGNvbXBvc2VkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBzZXR0ZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRlcihyZXN1bHQsIHZhbHVlLCBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYFxuICAgICAqIHdpdGggYW4gb3B0aW9uYWwgYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBtZXRob2QgZmxhZ3MgdG8gY29tcG9zZS5cbiAgICAgKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gICAgICogIDEgLSBgXy5iaW5kYFxuICAgICAqICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgNCAtIGBfLmN1cnJ5YFxuICAgICAqICA4IC0gYF8uY3VycnlgIChib3VuZClcbiAgICAgKiAgMTYgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAzMiAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxSaWdodEFyZ3NdIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihmdW5jLCBiaXRtYXNrLCBwYXJ0aWFsQXJncywgcGFydGlhbFJpZ2h0QXJncywgdGhpc0FyZywgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgMSxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgMixcbiAgICAgICAgICBpc0N1cnJ5ID0gYml0bWFzayAmIDQsXG4gICAgICAgICAgaXNDdXJyeUJvdW5kID0gYml0bWFzayAmIDgsXG4gICAgICAgICAgaXNQYXJ0aWFsID0gYml0bWFzayAmIDE2LFxuICAgICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gYml0bWFzayAmIDMyO1xuXG4gICAgICBpZiAoIWlzQmluZEtleSAmJiAhaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbCAmJiAhcGFydGlhbEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjE2O1xuICAgICAgICBpc1BhcnRpYWwgPSBwYXJ0aWFsQXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0ICYmICFwYXJ0aWFsUmlnaHRBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4zMjtcbiAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHRBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jICYmIGZ1bmMuX19iaW5kRGF0YV9fO1xuICAgICAgaWYgKGJpbmREYXRhICYmIGJpbmREYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIC8vIGNsb25lIGBiaW5kRGF0YWBcbiAgICAgICAgYmluZERhdGEgPSBzbGljZShiaW5kRGF0YSk7XG4gICAgICAgIGlmIChiaW5kRGF0YVsyXSkge1xuICAgICAgICAgIGJpbmREYXRhWzJdID0gc2xpY2UoYmluZERhdGFbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kRGF0YVszXSkge1xuICAgICAgICAgIGJpbmREYXRhWzNdID0gc2xpY2UoYmluZERhdGFbM10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBgdGhpc0JpbmRpbmdgIGlzIG5vdCBwcmV2aW91c2x5IGJvdW5kXG4gICAgICAgIGlmIChpc0JpbmQgJiYgIShiaW5kRGF0YVsxXSAmIDEpKSB7XG4gICAgICAgICAgYmluZERhdGFbNF0gPSB0aGlzQXJnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBpZiBwcmV2aW91c2x5IGJvdW5kIGJ1dCBub3QgY3VycmVudGx5IChzdWJzZXF1ZW50IGN1cnJpZWQgZnVuY3Rpb25zKVxuICAgICAgICBpZiAoIWlzQmluZCAmJiBiaW5kRGF0YVsxXSAmIDEpIHtcbiAgICAgICAgICBiaXRtYXNrIHw9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnJpZWQgYXJpdHkgaWYgbm90IHlldCBzZXRcbiAgICAgICAgaWYgKGlzQ3VycnkgJiYgIShiaW5kRGF0YVsxXSAmIDQpKSB7XG4gICAgICAgICAgYmluZERhdGFbNV0gPSBhcml0eTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCBsZWZ0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgcHVzaC5hcHBseShiaW5kRGF0YVsyXSB8fCAoYmluZERhdGFbMl0gPSBbXSksIHBhcnRpYWxBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBlbmQgcGFydGlhbCByaWdodCBhcmd1bWVudHNcbiAgICAgICAgaWYgKGlzUGFydGlhbFJpZ2h0KSB7XG4gICAgICAgICAgdW5zaGlmdC5hcHBseShiaW5kRGF0YVszXSB8fCAoYmluZERhdGFbM10gPSBbXSksIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGZsYWdzXG4gICAgICAgIGJpbmREYXRhWzFdIHw9IGJpdG1hc2s7XG4gICAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyLmFwcGx5KG51bGwsIGJpbmREYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYF8uYmluZGBcbiAgICAgIHZhciBjcmVhdGVyID0gKGJpdG1hc2sgPT0gMSB8fCBiaXRtYXNrID09PSAxNykgPyBiYXNlQmluZCA6IGJhc2VDcmVhdGVXcmFwcGVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZXIoW2Z1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYGVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbEVzY2FwZXNbbWF0Y2hdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLiBJZiB0aGUgYF8uaW5kZXhPZmAgbWV0aG9kIGlzXG4gICAgICogY3VzdG9taXplZCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgKiB0aGUgYGJhc2VJbmRleE9mYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBcImluZGV4T2ZcIiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IChyZXN1bHQgPSBsb2Rhc2guaW5kZXhPZikgPT09IGluZGV4T2YgPyBiYXNlSW5kZXhPZiA6IHJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgcmVOYXRpdmUudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgdGhpc2AgYmluZGluZyBkYXRhIG9uIGEgZ2l2ZW4gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNldCBkYXRhIG9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIFRoZSBkYXRhIGFycmF5IHRvIHNldC5cbiAgICAgKi9cbiAgICB2YXIgc2V0QmluZERhdGEgPSAhZGVmaW5lUHJvcGVydHkgPyBub29wIDogZnVuY3Rpb24oZnVuYywgdmFsdWUpIHtcbiAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGRlZmluZVByb3BlcnR5KGZ1bmMsICdfX2JpbmREYXRhX18nLCBkZXNjcmlwdG9yKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWVcbiAgICAgKiBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IsIGFzc3VtaW5nIG9iamVjdHMgY3JlYXRlZFxuICAgICAqIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciBoYXZlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIHRoYXRcbiAgICAgKiB0aGVyZSBhcmUgbm8gYE9iamVjdC5wcm90b3R5cGVgIGV4dGVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciBjdG9yLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgLy8gYXZvaWQgbm9uIE9iamVjdCBvYmplY3RzLCBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgRE9NIGVsZW1lbnRzXG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykgfHxcbiAgICAgICAgICAoY3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yLCBpc0Z1bmN0aW9uKGN0b3IpICYmICEoY3RvciBpbnN0YW5jZW9mIGN0b3IpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBJbiBtb3N0IGVudmlyb25tZW50cyBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYmVmb3JlXG4gICAgICAvLyBpdHMgaW5oZXJpdGVkIHByb3BlcnRpZXMuIElmIHRoZSBsYXN0IGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzXG4gICAgICAvLyBvd24gcHJvcGVydHkgdGhlbiB0aGVyZSBhcmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGZvckluKHZhbHVlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGB1bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZUh0bWxDaGFyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gaHRtbFVuZXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpOyB9KSgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FycmF5KGFyZ3VtZW50cyk7IH0pKCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzIHx8IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBPYmplY3Qua2V5c2Agd2hpY2ggcHJvZHVjZXMgYW4gYXJyYXkgb2YgdGhlXG4gICAgICogZ2l2ZW4gb2JqZWN0J3Mgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIHZhciBzaGltS2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCEob2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdF0pKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZXlzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsnb25lJywgJ3R3bycsICd0aHJlZSddIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXM6XG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIGA+YCBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZSBgPmAgYW5kIGAvYFxuICAgICAqIGRvbid0IHJlcXVpcmUgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmcgdW5sZXNzIHRoZXkncmUgcGFydFxuICAgICAqIG9mIGEgdGFnIG9yIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcyAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIilcbiAgICAgKi9cbiAgICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjMzk7J1xuICAgIH07XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycyAqL1xuICAgIHZhciBodG1sVW5lc2NhcGVzID0gaW52ZXJ0KGh0bWxFc2NhcGVzKTtcblxuICAgIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycyAqL1xuICAgIHZhciByZUVzY2FwZWRIdG1sID0gUmVnRXhwKCcoJyArIGtleXMoaHRtbFVuZXNjYXBlcykuam9pbignfCcpICsgJyknLCAnZycpLFxuICAgICAgICByZVVuZXNjYXBlZEh0bWwgPSBSZWdFeHAoJ1snICsga2V5cyhodG1sRXNjYXBlcykuam9pbignJykgKyAnXScsICdnJyk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAgICogc291cmNlcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlXG4gICAgICogYXNzaWduZWQgdmFsdWVzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICduYW1lJzogJ2ZyZWQnIH0sIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIGEgPT0gJ3VuZGVmaW5lZCcgPyBiIDogYTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBkZWZhdWx0cyhvYmplY3QsIHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICBpZiAoYXJnc0xlbmd0aCA+IDMgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1hcmdzTGVuZ3RoIC0gMV0sIGFyZ3NbYXJnc0xlbmd0aC0tXSwgMik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3NMZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2FyZ3NMZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWFyZ3NMZW5ndGhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2sgPyBjYWxsYmFjayhyZXN1bHRbaW5kZXhdLCBpdGVyYWJsZVtpbmRleF0pIDogaXRlcmFibGVbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBpc0RlZXBgIGlzIGB0cnVlYCBuZXN0ZWQgb2JqZWN0cyB3aWxsIGFsc29cbiAgICAgKiBiZSBjbG9uZWQsIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWVzLiBJZiB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNsb25pbmcgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXA9ZmFsc2VdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShjaGFyYWN0ZXJzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZShjaGFyYWN0ZXJzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSBjaGFyYWN0ZXJzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLm1peGluKHtcbiAgICAgKiAgICdjbG9uZSc6IF8ucGFydGlhbFJpZ2h0KF8uY2xvbmUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAqICAgfSlcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSk7XG4gICAgICogY2xvbmUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YFxuICAgICAgLy8gYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHMgZm9yIGBpc0RlZXBgIGFuZCBgY2FsbGJhY2tgXG4gICAgICBpZiAodHlwZW9mIGlzRGVlcCAhPSAnYm9vbGVhbicgJiYgaXNEZWVwICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGlzRGVlcDtcbiAgICAgICAgaXNEZWVwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIGB2YWx1ZWAuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZVxuICAgICAqIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZSBzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobS4gRnVuY3Rpb25zXG4gICAgICogYW5kIERPTSBub2RlcyBhcmUgKipub3QqKiBjbG9uZWQuIFRoZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhbmRcbiAgICAgKiBvYmplY3RzIGNyZWF0ZWQgYnkgY29uc3RydWN0b3JzIG90aGVyIHRoYW4gYE9iamVjdGAgYXJlIGNsb25lZCB0byBwbGFpbiBgT2JqZWN0YCBvYmplY3RzLlxuICAgICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI2ludGVybmFsLXN0cnVjdHVyZWQtY2xvbmluZy1hbGdvcml0aG0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKGNoYXJhY3RlcnMpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ25vZGUnOiBlbGVtZW50XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmVEZWVwKHZpZXcsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc0VsZW1lbnQodmFsdWUpID8gdmFsdWUuY2xvbmVOb2RlKHRydWUpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY2xvbmUubm9kZSA9PSB2aWV3Lm5vZGU7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgcHJvdmlkZWQgaXRzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkXG4gICAgICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHsgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPyBhc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIGRlZmF1bHRzIG9mIHRoZSBzYW1lIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIHdpdGhvdXQgdXNpbmcgaXRzXG4gICAgICogIGBrZXlgIGFuZCBgb2JqZWN0YCBhcmd1bWVudHMgYXMgc291cmNlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2Jhcm5leScgfTtcbiAgICAgKiBfLmRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBndWFyZCkge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IG9iamVjdCwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gdHlwZW9mIGd1YXJkID09ICdudW1iZXInID8gMiA6IGFyZ3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICBpdGVyYWJsZSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpbmRleF0gPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFtpbmRleF0gPSBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvXG4gICAgICogIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogeyAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kS2V5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiB7ICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyBgcGViYmxlc2AsIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgYGJhcm5leWBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93blJpZ2h0KG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCxcbiAgICAgKiBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JJbiA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9yIChpbmRleCBpbiBpdGVyYWJsZSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFNoYXBlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgdGhpcy54ICs9IHg7XG4gICAgICogICB0aGlzLnkgKz0geTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBTaGFwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdtb3ZlJywgJ3knLCBhbmQgJ3gnIGFzc3VtaW5nIGBfLmZvckluIGAgbG9ncyAneCcsICd5JywgYW5kICdtb3ZlJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHBhaXJzID0gW107XG5cbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBwYWlycy5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHBhaXJzW2xlbmd0aC0tXSwgcGFpcnNbbGVuZ3RoXSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JPd24oeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIHZhciBmb3JPd24gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHZhciBvd25JbmRleCA9IC0xLFxuICAgICAgICAgICAgb3duUHJvcHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdICYmIGtleXMoaXRlcmFibGUpLFxuICAgICAgICAgICAgbGVuZ3RoID0gb3duUHJvcHMgPyBvd25Qcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK293bkluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaW5kZXggPSBvd25Qcm9wc1tvd25JbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xlbmd0aCcsICcxJywgYW5kICcwJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNvcnRlZCBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvZiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLFxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkLCBvZiBgb2JqZWN0YCB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG1ldGhvZHNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICAgKiAvLyA9PiBbJ2FsbCcsICdhbnknLCAnYmluZCcsICdiaW5kQWxsJywgJ2Nsb25lJywgJ2NvbXBhY3QnLCAnY29tcG9zZScsIC4uLl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lIGV4aXN0cyBhcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCxcbiAgICAgKiBpbnN0ZWFkIG9mIGFuIGluaGVyaXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGtleSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ2ZyZWQnLCAnc2Vjb25kJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6ICdmaXJzdCcsICdiYXJuZXknOiAnc2Vjb25kJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbb2JqZWN0W2tleV1dID0ga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGJvb2xlYW4gdmFsdWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGRhdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZGF0ZUNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBlbXB0eS4gQXJyYXlzLCBzdHJpbmdzLCBvciBgYXJndW1lbnRzYCBvYmplY3RzIHdpdGggYVxuICAgICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAgICogXCJlbXB0eVwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoJycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgKSB8fFxuICAgICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogdG8gY29tcGFyZSB2YWx1ZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIGNvbXBhcmlzb25zIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKGEsIGIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IGEgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGNvcHkgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiBvYmplY3QgPT0gY29weTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgY29weSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHdvcmRzID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyV29yZHMgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbCh3b3Jkcywgb3RoZXJXb3JkcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgdmFyIHJlR3JlZXQgPSAvXig/OmhlbGxvfGhpKSQvaSxcbiAgICAgKiAgICAgICBhR3JlZXQgPSBfLmlzU3RyaW5nKGEpICYmIHJlR3JlZXQudGVzdChhKSxcbiAgICAgKiAgICAgICBiR3JlZXQgPSBfLmlzU3RyaW5nKGIpICYmIHJlR3JlZXQudGVzdChiKTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIChhR3JlZXQgfHwgYkdyZWV0KSA/IChhR3JlZXQgPT0gYkdyZWV0KSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKGEsIGIsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzLCBvciBjYW4gYmUgY29lcmNlZCB0bywgYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc0Zpbml0ZWAgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBmb3JcbiAgICAgKiBib29sZWFucyBhbmQgZW1wdHkgc3RyaW5ncy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBmaW5pdGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgtMTAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcxMCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlSXNGaW5pdGUodmFsdWUpICYmICFuYXRpdmVJc05hTihwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyB0aGUgRUNNQVNjcmlwdCBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdFxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3g4XG4gICAgICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNOYU5gIHdoaWNoIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWVyaWMgdmFsdWVzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gYE5hTmAgYXMgYSBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmXG4gICAgICAvLyAocGVyZm9ybSB0aGUgW1tDbGFzc11dIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWUgaG9zdCBvYmplY3RzIGluIElFKVxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IGBOYU5gIGlzIGNvbnNpZGVyZWQgYSBudW1iZXIuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDguNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoOC40ICogNSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBTaGFwZSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzUGxhaW5PYmplY3QgPSAhZ2V0UHJvdG90eXBlT2YgPyBzaGltSXNQbGFpbk9iamVjdCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoISh2YWx1ZSAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBvYmplY3RDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICAgIG9ialByb3RvID0gaXNOYXRpdmUodmFsdWVPZikgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgICAgcmV0dXJuIG9ialByb3RvXG4gICAgICAgID8gKHZhbHVlID09IG9ialByb3RvIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKSA9PSBvYmpQcm90bylcbiAgICAgICAgOiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvZnJlZC8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSByZWdleHBDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN0cmluZ0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWQgYnlcbiAgICAgKiBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhyb3VnaCB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHZhbHVlcyBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDN9ICwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwVmFsdWVzKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBtZXJnZXMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSwgdGhhdFxuICAgICAqIGRvbid0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXNcbiAgICAgKiB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGFuZCBzb3VyY2UgcHJvcGVydGllcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgbWVyZ2luZyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG5hbWVzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ25hbWUnOiAnYmFybmV5JyB9LFxuICAgICAqICAgICB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGFnZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnYWdlJzogMzYgfSxcbiAgICAgKiAgICAgeyAnYWdlJzogNDAgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG5hbWVzLCBhZ2VzKTtcbiAgICAgKiAvLyA9PiB7ICdjaGFyYWN0ZXJzJzogW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XSB9XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlckZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKGZvb2QsIG90aGVyRm9vZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdF0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tbGVuZ3RoIC0gMV0sIGFyZ3NbbGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlcyA9IHNsaWNlKGFyZ3VtZW50cywgMSwgbGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCksXG4gICAgICAgICAgc3RhY2tCID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlc1tpbmRleF0sIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBwcm9wZXJ0aWVzIHRvIG9taXQgb3IgdGhlXG4gICAgICogIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcyA9IGJhc2VEaWZmZXJlbmNlKHByb3BzLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBhbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgY29tcG9zZWQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgIT0gJ18nO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGlzT2JqZWN0KG9iamVjdCkgPyBwcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgIHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIHRocm91Z2ggYSBjYWxsYmFjaywgd2l0aCBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3F1YXJlcyA9IF8udHJhbnNmb3JtKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtKSB7XG4gICAgICogICBudW0gKj0gbnVtO1xuICAgICAqICAgaWYgKG51bSAlIDIpIHtcbiAgICAgKiAgICAgcmV0dXJuIHJlc3VsdC5wdXNoKG51bSkgPCAzO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCA5LCAyNV1cbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgcHJvdG8gPSBjdG9yICYmIGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBiYXNlQ3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgICAgKGlzQXJyID8gZm9yRWFjaCA6IGZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IG9iamVjdFtwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4ZXMsIG9yIGtleXMsIG9mIHRoZVxuICAgICAqIGBjb2xsZWN0aW9uYC4gSW5kZXhlcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXXxzdHJpbmd8c3RyaW5nW10pfSBbaW5kZXhdIFRoZSBpbmRleGVzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqICAgdG8gcmV0cmlldmUsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGluZGV4ZXMgb3IgYXJyYXlzIG9mIGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gICAgICogIHByb3ZpZGVkIGluZGV4ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgWzAsIDIsIDRdKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYycsICdlJ11cbiAgICAgKlxuICAgICAqIF8uYXQoWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0gYmFzZUZsYXR0ZW4oYXJncywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgIGxlbmd0aCA9IChhcmdzWzJdICYmIGFyZ3NbMl1bYXJnc1sxXV0gPT09IGNvbGxlY3Rpb24pID8gMSA6IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGdpdmVuIHZhbHVlIGlzIHByZXNlbnQgaW4gYSBjb2xsZWN0aW9uIHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBpbmNsdWRlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKCdwZWJibGVzJywgJ2ViJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXgpIHx8IDA7XG4gICAgICBpZiAoaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSA+IC0xO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IChpc1N0cmluZyhjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleCkgOiBpbmRleE9mKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNC4zLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldKysgOiByZXN1bHRba2V5XSA9IDEpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5zIHRydWV5IHZhbHVlIGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFsbFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmV2ZXJ5KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9ICEhY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gISFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHNlbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZXZlbnMgPSBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdFxuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkZXRlY3QsIGZpbmRXaGVyZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDQwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAxIH0pO1xuICAgICAqIC8vID0+ICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBmb3IgZWFjaFxuICAgICAqIGVsZW1lbnQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5XG4gICAgICogZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICogYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIGBfLmZvckluYCBvciBgXy5mb3JPd25gXG4gICAgICogbWF5IGJlIHVzZWQgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgJzEsMiwzJ1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zIHRoZSBvYmplY3QgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoUmlnaHQoZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGZyb20gcmlnaHQgdG8gbGVmdCBhbmQgcmV0dXJucyAnMywyLDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltsZW5ndGhdLCBsZW5ndGgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAga2V5ID0gcHJvcHMgPyBwcm9wc1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY29sbGVjdGlvbltrZXldLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgdGhlIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5mbG9vcihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiByZXN1bHRba2V5XSA9IFtdKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBnaXZlbiBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIga2V5cyA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4Qnkoa2V5cywgZnVuY3Rpb24oa2V5KSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGtleSkgeyB0aGlzLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0sIFN0cmluZyk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBpbmRleEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgbWV0aG9kTmFtZWAgaXMgYSBmdW5jdGlvbiBpdFxuICAgICAqIHdpbGwgYmUgaW52b2tlZCBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIG1ldGhvZE5hbWUgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSAoaXNGdW5jID8gbWV0aG9kTmFtZSA6IHZhbHVlW21ldGhvZE5hbWVdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGAtSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgSW5maW5pdHlgIGlzIHJldHVybmVkLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgY29sbGVjdGlvbiB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZVxuICAgICAqIGlzIHJhbmtlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4oY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYXJndW1lbnQgYXMgYSBjYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tjYWxsYmFja10gPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gKGNhbGxiYWNrID09IG51bGwgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA8IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYWxsIGVsZW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBsdWNrKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgdmFyIHBsdWNrID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBhIGNvbGxlY3Rpb24gdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBleGVjdXRpb24uIElmXG4gICAgICogYGFjY3VtdWxhdG9yYCBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIGluaXRpYWwgYGFjY3VtdWxhdG9yYCB2YWx1ZS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChub2FjY3VtKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjb2xsZWN0aW9uWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsaXN0ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqIHZhciBmbGF0ID0gXy5yZWR1Y2VSaWdodChsaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24gdGhhdCB0aGUgY2FsbGJhY2sgZG9lcyAqKm5vdCoqIHJldHVybiB0cnVleSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBmYWlsZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYFxuICAgICAqICB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGAgYXJndW1lbnRzIGFzIGBuYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgY29sbGVjdGlvbi5sZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gICAgICogc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDYsIDMsIDUsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgKytpbmRleCk7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3IgYXJyYXlzXG4gICAgICogYW5kIGFycmF5LWxpa2Ugb2JqZWN0cyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGBjb2xsZWN0aW9uLmxlbmd0aGAgb3IgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZXkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAgICogY29sbGVjdGlvbi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kXG4gICAgICogZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICgocmVzdWx0ID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBlcXVhbCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY29sbGVjdGlvblxuICAgICAqIHdpbGwgYmUgc29ydGVkIGJ5IGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMjYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiAzMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKF8uc29ydEJ5KGNoYXJhY3RlcnMsICdhZ2UnKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDI2XSwgWydmcmVkJywgMzBdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogLy8gc29ydGluZyBieSBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgWyduYW1lJywgJ2FnZSddKSwgXy52YWx1ZXMpO1xuICAgICAqIC8vID0gPiBbWydiYXJuZXknLCAyNl0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShjYWxsYmFjayksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbKytpbmRleF0gPSBnZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgb2JqZWN0LmNyaXRlcmlhID0gbWFwKGNhbGxiYWNrLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChvYmplY3QuY3JpdGVyaWEgPSBnZXRBcnJheSgpKVswXSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFtsZW5ndGhdO1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAgIHJlbGVhc2VBcnJheShvYmplY3QuY3JpdGVyaWEpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGBjb2xsZWN0aW9uYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzbGljZShjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gb2YgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gIHRvIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH1dXG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XVxuICAgICAqL1xuICAgIHZhciB3aGVyZSA9IGZpbHRlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCAyMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPiAzMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9yIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nXG4gICAgICogYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZCwgdGFrZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maXJzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICAgKiBmbGF0dGVuaW5nLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU2hhbGxvdyAhPSAnYm9vbGVhbicgJiYgaXNTaGFsbG93ICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICAgIGlzU2hhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXkgPSBtYXAoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYVxuICAgICAqIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tXG4gICAgICogdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmluaXRpYWwoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IGNhbGxiYWNrIHx8IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBwcmVzZW50IGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBzaGFyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IGdldEFycmF5KCksXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICB0cnVzdEluZGV4T2YgPSBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgY2FjaGVzLnB1c2godHJ1c3RJbmRleE9mICYmIHZhbHVlLmxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJlxuICAgICAgICAgICAgY3JlYXRlQ2FjaGUoYXJnc0luZGV4ID8gYXJnc1thcmdzSW5kZXhdIDogc2VlbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSBhcmdzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1swXTtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihzZWVuLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgIGFyZ3NJbmRleCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgICAgKGNhY2hlIHx8IHNlZW4pLnB1c2godmFsdWUpO1xuICAgICAgICAgIHdoaWxlICgtLWFyZ3NJbmRleCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPyBjYWNoZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA6IGluZGV4T2YoYXJnc1thcmdzSW5kZXhdLCB2YWx1ZSkpIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgIGNhY2hlID0gY2FjaGVzW2FyZ3NMZW5ndGhdO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVsZWFzZUFycmF5KGNhY2hlcyk7XG4gICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nIGFzIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5sYXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5sYXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ25hJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nIHN0cmljdFxuICAgICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICAgKiBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgcHJvdmlkZWQgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDEsIDIsIDNdO1xuICAgICAqIF8ucHVsbChhcnJheSwgMiwgMyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGwoYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgYGVuZGAuIElmIGBzdGFydGAgaXMgbGVzcyB0aGFuIGBzdG9wYCBhXG4gICAgICogemVyby1sZW5ndGggcmFuZ2UgaXMgY3JlYXRlZCB1bmxlc3MgYSBuZWdhdGl2ZSBgc3RlcGAgaXMgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgICAgIHN0ZXAgPSB0eXBlb2Ygc3RlcCA9PSAnbnVtYmVyJyA/IHN0ZXAgOiAoK3N0ZXAgfHwgMSk7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBlbmdpbmVzIGxpa2UgQ2hha3JhIGFuZCBWOCBhdm9pZCBzbG93ZXIgbW9kZXNcbiAgICAgIC8vIGh0dHA6Ly95b3V0dS5iZS9YQXFJcEdVOFpaayN0PTE3bTI1c1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KDAsIGNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IHRoYXQgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LS0sIDEpO1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5pbml0aWFsYCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb3JcbiAgICAgKiBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYW4gYXJyYXkuIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWQgZWxlbWVudHNcbiAgICAgKiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBkcm9wLCB0YWlsXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA8IDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogZmFsc2UsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8ucmVzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IG5hdGl2ZU1heCgwLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2ggYSB2YWx1ZVxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGEgZ2l2ZW4gc29ydGVkIGFycmF5IGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0XG4gICAgICogb3JkZXIgb2YgdGhlIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yXG4gICAgICogYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZVxuICAgICAqIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsyMCwgMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydGVkSW5kZXgoW3sgJ3gnOiAyMCB9LCB7ICd4JzogMzAgfSwgeyAneCc6IDUwIH1dLCB7ICd4JzogNDAgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgZGljdCA9IHtcbiAgICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiBkaWN0LndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0sIGRpY3QpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAgIC8vIGV4cGxpY2l0bHkgcmVmZXJlbmNlIGBpZGVudGl0eWAgZm9yIGJldHRlciBpbmxpbmluZyBpbiBGaXJlZm94XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSA6IGlkZW50aXR5O1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayh2YWx1ZSk7XG5cbiAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICAgIChjYWxsYmFjayhhcnJheVttaWRdKSA8IHZhbHVlKVxuICAgICAgICAgID8gbG93ID0gbWlkICsgMVxuICAgICAgICAgIDogaGlnaCA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb3c7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMiwgM10sIFs1LCAyLCAxLCA0XSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbigpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBhcnJheSBpcyBzb3J0ZWQsIHByb3ZpZGluZ1xuICAgICAqIGB0cnVlYCBmb3IgYGlzU29ydGVkYCB3aWxsIHVzZSBhIGZhc3RlciBhbGdvcml0aG0uIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWRcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgY2FsbGJhY2sgYmVmb3JlIHVuaXF1ZW5lc3NcbiAgICAgKiBpcyBjb21wdXRlZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bmlxdWVcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGBhcnJheWAgaXMgc29ydGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMiwgMSwgMywgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAxLCAyLCAyLCAzXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWydBJywgJ2InLCAnQycsICdhJywgJ0InLCAnYyddLCBmdW5jdGlvbihsZXR0ZXIpIHsgcmV0dXJuIGxldHRlci50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgICAgKiAvLyA9PiBbJ0EnLCAnYicsICdDJ11cbiAgICAgKlxuICAgICAqIF8udW5pcShbMSwgMi41LCAzLCAxLjUsIDIsIDMuNV0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMSwgMi41LCAzXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy51bmlxKFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Jvb2xlYW4nICYmIGlzU29ydGVkICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTb3J0ZWQgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTb3J0ZWRdID09PSBhcnJheSkgPyBudWxsIDogaXNTb3J0ZWQ7XG4gICAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIHByb3ZpZGVkIHZhbHVlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV0gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMSwgMiwgMSwgMCwgMywgMSwgNF0sIDAsIDEpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlRGlmZmVyZW5jZShhcnJheSwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzLlxuICAgICAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdKTtcbiAgICAgKiAvLyA9PiBbMywgNSwgNF1cbiAgICAgKlxuICAgICAqIF8ueG9yKFsxLCAyLCA1XSwgWzIsIDMsIDVdLCBbMywgNCwgNV0pO1xuICAgICAqIC8vID0+IFsxLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhvcigpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5KSB8fCBpc0FyZ3VtZW50cyhhcnJheSkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgICAgICA/IGJhc2VVbmlxKGJhc2VEaWZmZXJlbmNlKHJlc3VsdCwgYXJyYXkpLmNvbmNhdChiYXNlRGlmZmVyZW5jZShhcnJheSwgcmVzdWx0KSkpXG4gICAgICAgICAgICA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyB1bnppcFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydmcmVkJywgMzAsIHRydWVdLCBbJ2Jhcm5leScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKCkge1xuICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHMgOiBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IG1heChwbHVjayhhcnJheSwgJ2xlbmd0aCcpKSA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gcGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUHJvdmlkZVxuICAgICAqIGVpdGhlciBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYFxuICAgICAqIG9yIHR3byBhcnJheXMsIG9uZSBvZiBga2V5c2AgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIG9iamVjdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBhcnJheSBvZiBrZXlzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGdpdmVuIGtleXMgYW5kXG4gICAgICogIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2ZyZWQnLCAnYmFybmV5J10sIFszMCwgNDBdKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogMzAsICdiYXJuZXknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKCF2YWx1ZXMgJiYgbGVuZ3RoICYmICFpc0FycmF5KGtleXNbMF0pKSB7XG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYGZ1bmNgLCB3aXRoICB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kXG4gICAgICogYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCBvbmx5IGFmdGVyIGJlaW5nIGNhbGxlZCBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAgICogIGBmdW5jYCBpcyBleGVjdXRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnRG9uZSBzYXZpbmchJywgYWZ0ZXIgYWxsIHNhdmVzIGhhdmUgY29tcGxldGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZGAgYXJndW1lbnRzIHRvIHRob3NlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy5uYW1lO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jID0gXy5iaW5kKGZ1bmMsIHsgJ25hbWUnOiAnZnJlZCcgfSwgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihmdW5jLCAxNywgc2xpY2UoYXJndW1lbnRzLCAyKSwgbnVsbCwgdGhpc0FyZylcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDEsIG51bGwsIG51bGwsIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuIE1ldGhvZCBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5c1xuICAgICAqIG9mIG1ldGhvZCBuYW1lcy4gSWYgbm8gbWV0aG9kIG5hbWVzIGFyZSBwcm92aWRlZCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YCB3aWxsIGJlIGJvdW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IFttZXRob2ROYW1lXSBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0b1xuICAgICAqICBiaW5kLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBtZXRob2QgbmFtZXMgb3IgYXJyYXlzIG9mIG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTsgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldyk7XG4gICAgICogalF1ZXJ5KCcjZG9jcycpLm9uKCdjbGljaycsIHZpZXcub25DbGljayk7XG4gICAgICogLy8gPT4gbG9ncyAnY2xpY2tlZCBkb2NzJywgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSA6IGZ1bmN0aW9ucyhvYmplY3QpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICBvYmplY3Rba2V5XSA9IGNyZWF0ZVdyYXBwZXIob2JqZWN0W2tleV0sIDEsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWBcbiAgICAgKiBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRLZXlgIGFyZ3VtZW50cyB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYm91bmRcbiAgICAgKiBmdW5jdGlvbi4gVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0b1xuICAgICAqIHJlZmVyZW5jZSBtZXRob2RzIHRoYXQgd2lsbCBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgICAqIFNlZSBodHRwOi8vbWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdGhlIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ25hbWUnOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogZnVuYygpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy5uYW1lICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZEtleShvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyXG4gICAgICAgID8gY3JlYXRlV3JhcHBlcihrZXksIDE5LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCBvYmplY3QpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihrZXksIDMsIG51bGwsIG51bGwsIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gICAgICogd2hlcmUgZWFjaCBmdW5jdGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gICAgICogRm9yIGV4YW1wbGUsIGNvbXBvc2luZyB0aGUgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHByb2R1Y2VzIGBmKGcoaCgpKSlgLlxuICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IFtmdW5jXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYWxOYW1lTWFwID0ge1xuICAgICAqICAgJ3BlYmJsZXMnOiAncGVuZWxvcGUnXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBmb3JtYXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICBuYW1lID0gcmVhbE5hbWVNYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBuYW1lO1xuICAgICAqICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGZvcm1hdHRlZCkge1xuICAgICAqICAgcmV0dXJuICdIaXlhICcgKyBmb3JtYXR0ZWQgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciB3ZWxjb21lID0gXy5jb21wb3NlKGdyZWV0LCBmb3JtYXQpO1xuICAgICAqIHdlbGNvbWUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnSGl5YSBQZW5lbG9wZSEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuY3NbbGVuZ3RoXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIG9uZSBvciBtb3JlIGFyZ3VtZW50cyBvZiBgZnVuY2AgdGhhdCB3aGVuXG4gICAgICogaW52b2tlZCBlaXRoZXIgZXhlY3V0ZXMgYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhbGwgYGZ1bmNgIGFyZ3VtZW50c1xuICAgICAqIGhhdmUgYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgb3IgbW9yZSBvZiB0aGVcbiAgICAgKiByZW1haW5pbmcgYGZ1bmNgIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIGNhbiBiZSBzcGVjaWZpZWRcbiAgICAgKiBpZiBgZnVuYy5sZW5ndGhgIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGEgKyBiICsgYyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHkpIHtcbiAgICAgIGFyaXR5ID0gdHlwZW9mIGFyaXR5ID09ICdudW1iZXInID8gYXJpdHkgOiAoK2FyaXR5IHx8IGZ1bmMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKGZ1bmMsIDQsIG51bGwsIG51bGwsIG51bGwsIGFyaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGRlbGF5IHRoZSBleGVjdXRpb24gb2YgYGZ1bmNgIHVudGlsIGFmdGVyXG4gICAgICogYHdhaXRgIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC5cbiAgICAgKiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uXG4gICAgICogdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzXG4gICAgICogdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCBgZnVuY2Agd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIGlzXG4gICAgICogaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF0gVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGNhbGxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eFxuICAgICAqIHZhciBsYXp5TGF5b3V0ID0gXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgc2VuZE1haWxgIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiBqUXVlcnkoJyNwb3N0Ym94Jykub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZW5zdXJlIGBiYXRjaExvZ2AgaXMgZXhlY3V0ZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHNcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHtcbiAgICAgKiAgICdtYXhXYWl0JzogMTAwMFxuICAgICAqIH0sIGZhbHNlKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBuYXRpdmVNYXgoMCwgd2FpdCkgfHwgMDtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9IG9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChuYXRpdmVNYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1heERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSBub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBleGVjdXRpbmcgdGhlIGBmdW5jYCBmdW5jdGlvbiB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLlxuICAgICAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gbG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBvciBtb3JlIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGBmdW5jYCBmdW5jdGlvbiBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQgaXMgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBleGVjdXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHsgY29uc29sZS5sb2codGV4dCk7IH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IGxvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogVGhlIGBmdW5jYCBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogVGhlIHJlc3VsdCBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDIgPyBuIDogZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmaWJvbmFjY2koOSlcbiAgICAgKiAvLyA9PiAzNFxuICAgICAqXG4gICAgICogdmFyIGRhdGEgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdmFyIGdldCA9IF8ubWVtb2l6ZShmdW5jdGlvbihuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9LCBfLmlkZW50aXR5KTtcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICpcbiAgICAgKiBnZXQuY2FjaGUucGViYmxlcy5uYW1lID0gJ3BlbmVsb3BlJztcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlbmVsb3BlJywgJ2FnZSc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5UHJlZml4ICsgYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgICAgOiAoY2FjaGVba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBleGVjdXRlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHZhciByYW4sXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJhbikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7IH07XG4gICAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICAgKiBoaSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMTYsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0c0RlZXAgPSBfLnBhcnRpYWxSaWdodChfLm1lcmdlLCBfLmRlZmF1bHRzKTtcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgJ3ZhcmlhYmxlJzogJ2RhdGEnLFxuICAgICAqICAgJ2ltcG9ydHMnOiB7ICdqcSc6ICQgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkZWZhdWx0c0RlZXAob3B0aW9ucywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcbiAgICAgKlxuICAgICAqIG9wdGlvbnMudmFyaWFibGVcbiAgICAgKiAvLyA9PiAnZGF0YSdcbiAgICAgKlxuICAgICAqIG9wdGlvbnMuaW1wb3J0c1xuICAgICAqIC8vID0+IHsgJ18nOiBfLCAnanEnOiAkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMzIsIG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAgICogaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2VcbiAgICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBnZXR0ZXIgPSBfLmNvbnN0YW50KG9iamVjdCk7XG4gICAgICogZ2V0dGVyKCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIGNhbGxiYWNrIGJvdW5kIHRvIGFuIG9wdGlvbmFsIGB0aGlzQXJnYC4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHlcbiAgICAgKiBuYW1lIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIGBmdW5jYCBpcyBhbiBvYmplY3QgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50c1xuICAgICAqIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudCBvYmplY3QgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdDb3VudF0gVGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhlIGNhbGxiYWNrIGFjY2VwdHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd3JhcCB0byBjcmVhdGUgY3VzdG9tIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgKiBfLmNyZWF0ZUNhbGxiYWNrID0gXy53cmFwKF8uY3JlYXRlQ2FsbGJhY2ssIGZ1bmN0aW9uKGZ1bmMsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICogICB2YXIgbWF0Y2ggPSAvXiguKz8pX18oW2dsXXQpKC4rKSQvLmV4ZWMoY2FsbGJhY2spO1xuICAgICAqICAgcmV0dXJuICFtYXRjaCA/IGZ1bmMoY2FsbGJhY2ssIHRoaXNBcmcpIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICogICAgIHJldHVybiBtYXRjaFsyXSA9PSAnZ3QnID8gb2JqZWN0W21hdGNoWzFdXSA+IG1hdGNoWzNdIDogb2JqZWN0W21hdGNoWzFdXSA8IG1hdGNoWzNdO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdhZ2VfX2d0MzgnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGZ1bmM7XG4gICAgICBpZiAoZnVuYyA9PSBudWxsIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSBcIl8ucGx1Y2tcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAodHlwZSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkoZnVuYyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgIGEgPSBmdW5jW2tleV07XG5cbiAgICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIHRoZSBjb21tb24gY2FzZSBvZiBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgYCZgLCBgPGAsIGA+YCwgYFwiYCwgYW5kIGAnYCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiBtZXRob2RzIHdpbGwgYmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fSBbb2JqZWN0PWxvZGFzaF0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBhZGRlZCBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSk7XG4gICAgICogXy5jYXBpdGFsaXplKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ2NhcGl0YWxpemUnOiBjYXBpdGFsaXplIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLmNhcGl0YWxpemUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNoYWluID0gdHJ1ZSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IHNvdXJjZSAmJiBmdW5jdGlvbnMoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2UgfHwgKCFvcHRpb25zICYmICFtZXRob2ROYW1lcy5sZW5ndGgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBsb2Rhc2hXcmFwcGVyO1xuICAgICAgICBzb3VyY2UgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IGxvZGFzaDtcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBmdW5jdGlvbnMoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBjaGFpbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgY2hhaW4gPSBvcHRpb25zLmNoYWluO1xuICAgICAgfVxuICAgICAgdmFyIGN0b3IgPSBvYmplY3QsXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihjdG9yKTtcblxuICAgICAgZm9yRWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgICAgYXJncyA9IFt2YWx1ZV07XG5cbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoY2hhaW4gfHwgY2hhaW5BbGwpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQgJiYgaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBjdG9yKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSBjaGFpbkFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIFVuaXggZXBvY2hcbiAgICAgKiAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0YW1wID0gXy5ub3coKTtcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApOyB9KTtcbiAgICAgKiAvLyA9PiBsb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICB2YXIgbm93ID0gaXNOYXRpdmUobm93ID0gRGF0ZS5ub3cpICYmIG5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgICAqIElmIGByYWRpeGAgaXMgYHVuZGVmaW5lZGAgb3IgYDBgIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIHRoZVxuICAgICAqIGB2YWx1ZWAgaXMgYSBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgYXZvaWRzIGRpZmZlcmVuY2VzIGluIG5hdGl2ZSBFUzMgYW5kIEVTNSBgcGFyc2VJbnRgXG4gICAgICogaW1wbGVtZW50YXRpb25zLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI0UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4XSBUaGUgcmFkaXggdXNlZCB0byBpbnRlcnByZXQgdGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG5ldyBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKi9cbiAgICB2YXIgcGFyc2VJbnQgPSBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlICsgJzA4JykgPT0gOCA/IG5hdGl2ZVBhcnNlSW50IDogZnVuY3Rpb24odmFsdWUsIHJhZGl4KSB7XG4gICAgICAvLyBGaXJlZm94IDwgMjEgYW5kIE9wZXJhIDwgMTUgZm9sbG93IHRoZSBFUzMgc3BlY2lmaWVkIGltcGxlbWVudGF0aW9uIG9mIGBwYXJzZUludGBcbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludChpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zLCAnJykgOiB2YWx1ZSwgcmFkaXggfHwgMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBcIl8ucGx1Y2tcIiBzdHlsZSBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyB0aGUgYGtleWAgdmFsdWUgb2YgYVxuICAgICAqIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgZ2V0TmFtZSA9IF8ucHJvcGVydHkoJ25hbWUnKTtcbiAgICAgKlxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsIGdldE5hbWUpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkoa2V5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIChpbmNsdXNpdmUpLiBJZiBvbmx5IG9uZVxuICAgICAqIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyB0cnVleSBvciBlaXRoZXIgYG1pbmAgb3IgYG1heGAgYXJlIGZsb2F0cyBhXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nPWZhbHNlXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIGZsb2F0aW5nKSB7XG4gICAgICB2YXIgbm9NaW4gPSBtaW4gPT0gbnVsbCxcbiAgICAgICAgICBub01heCA9IG1heCA9PSBudWxsO1xuXG4gICAgICBpZiAoZmxvYXRpbmcgPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSAnYm9vbGVhbicgJiYgbm9NYXgpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IG1pbjtcbiAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFub01heCAmJiB0eXBlb2YgbWF4ID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWF4O1xuICAgICAgICAgIG5vTWF4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vTWluICYmIG5vTWF4KSB7XG4gICAgICAgIG1heCA9IDE7XG4gICAgICB9XG4gICAgICBtaW4gPSArbWluIHx8IDA7XG4gICAgICBpZiAobm9NYXgpIHtcbiAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4ID0gK21heCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IG1pbiAlIDEgfHwgbWF4ICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKG1pbiArIChyYW5kICogKG1heCAtIG1pbiArIHBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKycnKS5sZW5ndGggLSAxKSkpKSwgbWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKG1pbiwgbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYGtleWAgb24gYG9iamVjdGAuIElmIGBrZXlgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsXG4gICAgICogZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gJ25vbnNlbnNlJztcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3Rba2V5XSgpIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtaWNyby10ZW1wbGF0aW5nIG1ldGhvZCB0aGF0IGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlc1xuICAgICAqIHdoaXRlc3BhY2UsIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAgICAqXG4gICAgICogTm90ZTogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkLCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXMgc291cmNlVVJMcyBmb3IgZWFzaWVyXG4gICAgICogZGVidWdnaW5nLiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWU6XG4gICAgICogaHR0cDovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkc1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlOlxuICAgICAqIGh0dHA6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9zdGFibGUvZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbC5odG1sXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZV0gVGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZV0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHNdIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgbG9jYWwgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZV0gVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VVUkxdIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFyaWFibGVdIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxzdHJpbmd9IFJldHVybnMgYSBjb21waWxlZCBmdW5jdGlvbiB3aGVuIG5vIGBkYXRhYCBvYmplY3RcbiAgICAgKiAgaXMgZ2l2ZW4sIGVsc2UgaXQgcmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICduYW1lJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBIVE1MIGluIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicsIHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZ2VuZXJhdGUgSFRNTFxuICAgICAqIHZhciBsaXN0ID0gJzwlIF8uZm9yRWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgRVM2IGRlbGltaXRlciBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgZGVmYXVsdCBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8gJHsgbmFtZSB9JywgeyAnbmFtZSc6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIG5hbWUpOyAlPiEnLCB7ICduYW1lJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBhIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgICAqICAgJ2ludGVycG9sYXRlJzogL3t7KFtcXHNcXFNdKz8pfX0vZ1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyB7eyBuYW1lIH19IScsIHsgJ25hbWUnOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgalF1ZXJ5XG4gICAgICogdmFyIGxpc3QgPSAnPCUganEuZWFjaChwZW9wbGUsIGZ1bmN0aW9uKG5hbWUpIHsgJT48bGk+PCUtIG5hbWUgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicsIG51bGwsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS5uYW1lICU+IScsIG51bGwsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogICB2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGU7XG4gICAgICogICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS5uYW1lICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogICByZXR1cm4gX19wO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIC8vIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCB8fCAnJyk7XG5cbiAgICAgIC8vIGF2b2lkIG1pc3NpbmcgZGVwZW5kZW5jaWVzIHdoZW4gYGl0ZXJhdG9yVGVtcGxhdGVgIGlzIG5vdCBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IHZhbHVlcyhpbXBvcnRzKTtcblxuICAgICAgdmFyIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlclxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgdGV4dC5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gcmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHNcbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWVcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIGlmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCwgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGUsXG4gICAgICAgICAgaGFzVmFyaWFibGUgPSB2YXJpYWJsZTtcblxuICAgICAgaWYgKCFoYXNWYXJpYWJsZSkge1xuICAgICAgICB2YXJpYWJsZSA9ICdvYmonO1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAoJyArIHZhcmlhYmxlICsgJykge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3NcbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gZnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICtcbiAgICAgICAgKGhhc1ZhcmlhYmxlID8gJycgOiB2YXJpYWJsZSArICcgfHwgKCcgKyB2YXJpYWJsZSArICcgPSB7fSk7XFxuJykgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZVwiICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnXFxuLypcXG4vLyMgc291cmNlVVJMPScgKyAob3B0aW9ucy5zb3VyY2VVUkwgfHwgJy9sb2Rhc2gvdGVtcGxhdGUvc291cmNlWycgKyAodGVtcGxhdGVDb3VudGVyKyspICsgJ10nKSArICdcXG4qLyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbihpbXBvcnRzS2V5cywgJ3JldHVybiAnICsgc291cmNlICsgc291cmNlVVJMKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCwgaW5cbiAgICAgIC8vIHN1cHBvcnRlZCBlbnZpcm9ubWVudHMsIG9yIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgICAgLy8gaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBjYWxsYmFjayBleGVjdXRpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgICAqIC8vID0+IGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMsIHBhc3NpbmcgYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIG4gPSAobiA9ICtuKSA+IC0xID8gbiA6IDA7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWAgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdGcmVkLCBCYXJuZXkgJmFtcDsgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBCYXJuZXkgJiBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIHdpbGwgYmUgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gU3RyaW5nKHByZWZpeCA9PSBudWxsID8gJycgOiBwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHdpdGggZXhwbGljaXRcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihjaGFyYWN0ZXJzKVxuICAgICAqICAgICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgICAubWFwKGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLm5hbWUgKyAnIGlzICcgKyBjaHIuYWdlOyB9KVxuICAgICAqICAgICAuZmlyc3QoKVxuICAgICAqICAgICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGB2YWx1ZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVuXG4gICAgICogcmV0dXJucyBgdmFsdWVgLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2RcbiAgICAgKiBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluXG4gICAgICogdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgMywgNF0pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHsgYXJyYXkucG9wKCk7IH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ2FnZScpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICdhZ2UnOiAzNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIGB0b1N0cmluZ2AgcmVzdWx0IG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXN1bHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMuX193cmFwcGVkX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVPZlxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHZhbHVlXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZU9mKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlT2YoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3dyYXBwZWRfXztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb21wb3NlID0gY29tcG9zZTtcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3JlYXRlQ2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjaztcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluZGV4QnkgPSBpbmRleEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guZHJvcCA9IHJlc3Q7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbjtcbiAgICBsb2Rhc2gubWV0aG9kcyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2gub2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC5zZWxlY3QgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLnRhaWwgPSByZXN0O1xuICAgIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuICAgIGxvZGFzaC51bnppcCA9IHppcDtcblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgXG4gICAgbWl4aW4obG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmFsbCA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5hbnkgPSBzb21lO1xuICAgIGxvZGFzaC5kZXRlY3QgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kV2hlcmUgPSBmaW5kO1xuICAgIGxvZGFzaC5mb2xkbCA9IHJlZHVjZTtcbiAgICBsb2Rhc2guZm9sZHIgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2guaW5jbHVkZSA9IGNvbnRhaW5zO1xuICAgIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG5cbiAgICBtaXhpbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fVxuICAgICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpLCBmYWxzZSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgY2FwYWJsZSBvZiByZXR1cm5pbmcgd3JhcHBlZCBhbmQgdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmZpcnN0ID0gZmlyc3Q7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC50YWtlID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcblxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjYWxsYmFja2FibGUgPSBtZXRob2ROYW1lICE9PSAnc2FtcGxlJztcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdPSBmdW5jdGlvbihuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jKHRoaXMuX193cmFwcGVkX18sIG4sIGd1YXJkKTtcblxuICAgICAgICAgIHJldHVybiAhY2hhaW5BbGwgJiYgKG4gPT0gbnVsbCB8fCAoZ3VhcmQgJiYgIShjYWxsYmFja2FibGUgJiYgdHlwZW9mIG4gPT0gJ2Z1bmN0aW9uJykpKVxuICAgICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gJzIuNC4xJztcblxuICAgIC8vIGFkZCBcIkNoYWluaW5nXCIgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyXG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvU3RyaW5nID0gd3JhcHBlclRvU3RyaW5nO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWVPZjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSB3cmFwcGVyVmFsdWVPZjtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzXG4gICAgZm9yRWFjaChbJ2pvaW4nLCAncG9wJywgJ3NoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiBjaGFpbkFsbFxuICAgICAgICAgID8gbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbClcbiAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdGhlIGV4aXN0aW5nIHdyYXBwZWQgdmFsdWVcbiAgICBmb3JFYWNoKFsncHVzaCcsICdyZXZlcnNlJywgJ3NvcnQnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBuZXcgd3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnY29uY2F0JywgJ3NsaWNlJywgJ3NwbGljZSddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGxvZGFzaFdyYXBwZXIoZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGV4cG9zZSBMby1EYXNoXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gc29tZSBBTUQgYnVpbGQgb3B0aW1pemVycyBsaWtlIHIuanMgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMby1EYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGV2ZW4gd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgaW5cbiAgICAvLyBjYXNlIExvLURhc2ggaXMgbG9hZGVkIHdpdGggYSBSZXF1aXJlSlMgc2hpbSBjb25maWcuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWwjY29uZmlnLXNoaW1cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlNcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIH1cbiAgICAvLyBpbiBOYXJ3aGFsIG9yIFJoaW5vIC1yZXF1aXJlXG4gICAgZWxzZSB7XG4gICAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcblxuOyBicm93c2VyaWZ5X3NoaW1fX2RlZmluZV9fbW9kdWxlX19leHBvcnRfXyh0eXBlb2YgXyAhPSBcInVuZGVmaW5lZFwiID8gXyA6IHdpbmRvdy5fKTtcblxufSkuY2FsbChnbG9iYWwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIGRlZmluZUV4cG9ydChleCkgeyBtb2R1bGUuZXhwb3J0cyA9IGV4OyB9KTtcbiIsInZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpO1xuXG5yZXF1aXJlKCdzcmMvdHVuZS1saXN0cy9tb2R1bGUnKTtcbnJlcXVpcmUoJ3NyYy9zZXQtbGlzdHMvbW9kdWxlJyk7XG5yZXF1aXJlKCdhbmd1bGFyLWJvb3RzdHJhcCcpO1xucmVxdWlyZSgnYW5ndWxhci1yZXNvdXJjZScpO1xucmVxdWlyZSgnYW5ndWxhci1jb29raWVzJyk7XG5yZXF1aXJlKCdhbmd1bGFyLXJvdXRlJyk7XG5yZXF1aXJlKCdhbmd1bGFyLWFuaW1hdGUnKTtcblxudmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdqbnInLCBbXG4gICAgJ25nUmVzb3VyY2UnLFxuICAgICduZ0Nvb2tpZXMnLFxuICAgICduZ1JvdXRlJyxcbiAgICAnbmdBbmltYXRlJyxcbiAgICAndWkuYm9vdHN0cmFwJyxcbiAgICAnam5yLnR1bmUtbGlzdHMnLFxuICAgICdqbnIuc2V0LWxpc3RzJ1xuXSk7XG5cbmFwcC52YWx1ZSgnak5vdycsIG5ldyBEYXRlKCkpXG4gICAgLmNvbmZpZyhmdW5jdGlvbiAoJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpLmhhc2hQcmVmaXgoJyEnKTsgICBcbiAgICB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHBcbiAuY29uZmlnKGZ1bmN0aW9uICgkcm91dGVQcm92aWRlcikge1xuICAgIFxuICAgICAgICAkcm91dGVQcm92aWRlci5vdGhlcndpc2Uoe1xuICAgICAgICAgICAgcmVkaXJlY3RUbzogJy9zZXRzL2xpc3QvbWFuZG9saW4nXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXG4gICAgJHNjb3BlLCBcbiAgICAkcm9vdFNjb3BlLCBcbiAgICAkbG9jYXRpb24sIFxuICAgIGpQYWdlU3RhdGUsXG4gICAgak1vZGFsc1xuKSB7XG4gICAgJHNjb3BlLmN1cnJlbnRVcmwgPSAkbG9jYXRpb24ucGF0aCgpO1xuICAgICRzY29wZS5wYWdlU3RhdGUgPSBqUGFnZVN0YXRlLmdldCgpO1xuICAgICRzY29wZS5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgXG4gICAgJHJvb3RTY29wZS4kb24oJ2xvY2F0aW9uQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRzY29wZS5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAkc2NvcGUudG9nZ2xlTmV3VHVuZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRyb290U2NvcGUuc2hvd05ld1R1bmVzID0gISRyb290U2NvcGUuc2hvd05ld1R1bmVzO1xuICAgIH07XG5cbiAgICAkc2NvcGUuYWRkVHVuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgak1vZGFscy5vcGVuKCdhZGRUdW5lJyk7XG4gICAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCRyb290U2NvcGUsICRyZXNvdXJjZSwgJGh0dHApIHtcbiAgICB2YXIgdGFibGVzID0ge30sXG4gICAgICAgIHJlc291cmNlcyA9IHt9LFxuICAgICAgICB1cGRhdGVGcm9tVGhlU2Vzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJGh0dHAoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgdXJsOiAnL3Jlc3Qvc2NyYXBlcidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnN1Y2Nlc3MoZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCBoZWFkZXJzLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVzLnR1bmVzLnB1c2gobmV3IHJlc291cmNlcy50dW5lcyhpdGVtKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnbmV3VHVuZXNGZXRjaGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0UmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZU5hbWUsIGFzVGFibGUpIHtcbiAgICAgICAgICAgIHJlc291cmNlc1tyZXNvdXJjZU5hbWVdID0gJHJlc291cmNlKCcvcmVzdC8nICsgcmVzb3VyY2VOYW1lICsgJy86aWQnLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdAX2lkJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICdnZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndXBkYXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICdxdWVyeScgOiB7IG1ldGhvZDonR0VUJywgY2FjaGU6IHRydWUsIGlzQXJyYXk6IHRydWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXNUYWJsZSkge1xuICAgICAgICAgICAgICAgIHRhYmxlc1tyZXNvdXJjZU5hbWVdID0gcmVzb3VyY2VzW3Jlc291cmNlTmFtZV0ucXVlcnkoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnakRhdGFMb2FkZWQnLCByZXNvdXJjZU5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc291cmNlTmFtZSA9PT0gJ3R1bmVzJykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGcm9tVGhlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVzW3Jlc291cmNlTmFtZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXNbcmVzb3VyY2VOYW1lXTtcbiAgICAgICAgICAgIC8vIH0sXG5cbiAgICAgICAgICAgIC8vIGluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAgICAgdmFyIHJlc291cmNlTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gICAgIGZvciAodmFyIGkgPSByZXNvdXJjZU5hbWVzLmxlbmd0aDsgLS1pOyBpPi0xKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIGlmICghcmVzb3VyY2VzW3Jlc291cmNlTmFtZXNbaV1dKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBpbml0UmVzb3VyY2UocmVzb3VyY2VOYW1lc1tpXSk7XG4gICAgICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRUYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlc1tuYW1lXSB8fCBpbml0UmVzb3VyY2UobmFtZSwgJ3RhYmxlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlc291cmNlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VzW25hbWVdIHx8IGluaXRSZXNvdXJjZShuYW1lKTtcbiAgICAgICAgfSAvLyxcbiAgICAgICAgLy8gaW5pdDogaW5pdFxuXG4gICAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigkcm9vdFNjb3BlKSB7XG4gICAgdmFyIGRyb3Bkb3ducyA9IHtcbiAgICAgICAgcGxheWJhY2s6IFt7XG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnTm92aWNlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgICAgIGxhYmVsOiAnSGFuZC1ob2xkaW5nJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogMixcbiAgICAgICAgICAgIGxhYmVsOiAnU2xvcHB5L1Nsb3cnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgICAgbGFiZWw6ICdQbGF5YWxvbmcnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiA0LFxuICAgICAgICAgICAgbGFiZWw6ICdTdGFydGVyJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogNSxcbiAgICAgICAgICAgIGxhYmVsOiAnU29sbydcbiAgICAgICAgfV0sXG4gICAgICAgIHBvcHVsYXJpdHk6IFt7XG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnVW5rbm93bidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgICAgICBsYWJlbDogJ1JhcmUnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAyLFxuICAgICAgICAgICAgbGFiZWw6ICdDb21tb24nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgICAgbGFiZWw6ICdTdGFuZGFyZCdcbiAgICAgICAgfV0sXG4gICAgICAgIHJhdGluZzogW3tcbiAgICAgICAgICAgIHZhbHVlOiAxLFxuICAgICAgICAgICAgbGFiZWw6ICdNZWRpb2NyZSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdmFsdWU6IDIsXG4gICAgICAgICAgICBsYWJlbDogJ1J1biBvZiB0aGUgbWlsbCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdmFsdWU6IDMsXG4gICAgICAgICAgICBsYWJlbDogJ1ByZXR0eSBnb29kJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogNCxcbiAgICAgICAgICAgIGxhYmVsOiAnUmVhbGx5IG5pY2UnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiA1LFxuICAgICAgICAgICAgbGFiZWw6ICdTcGVjaWFsJ1xuICAgICAgICB9XSxcbiAgICAgICAgZGlmZmljdWx0eTogW3tcbiAgICAgICAgICAgIHZhbHVlOiAxLFxuICAgICAgICAgICAgbGFiZWw6ICdFYXN5LXBlYXN5J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogMixcbiAgICAgICAgICAgIGxhYmVsOiAnU3RyYWlnaHRmb3J3YXJkJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgICAgIGxhYmVsOiAnVHJpY2t5IEJpdHMnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZhbHVlOiA0LFxuICAgICAgICAgICAgbGFiZWw6ICdSZWFsbHkgaGFyZCdcbiAgICAgICAgfV0sXG4gICAgICAgIHJoeXRobTogW1xuICAgICAgICAgICAgJ2ppZycsXG4gICAgICAgICAgICAncmVlbCcsXG4gICAgICAgICAgICAnc2xpcCBqaWcnLFxuICAgICAgICAgICAgJ2hvcm5waXBlJyxcbiAgICAgICAgICAgICdwb2xrYScsXG4gICAgICAgICAgICAnc2xpZGUnLFxuICAgICAgICAgICAgJ3dhbHR6JyxcbiAgICAgICAgICAgICdiYXJuZGFuY2UnLFxuICAgICAgICAgICAgJ3N0cmF0aHNwZXknLFxuICAgICAgICAgICAgJ3RocmVlLXR3bycsXG4gICAgICAgICAgICAnbWF6dXJrYSdcbiAgICAgICAgXSxcbiAgICAgICAgcm9vdDogW1xuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0UnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ0cnLFxuICAgICAgICAgICAgJ0JiJyxcbiAgICAgICAgICAgICdFYicsXG4gICAgICAgICAgICAnQWInLFxuICAgICAgICAgICAgJ0RiJyxcbiAgICAgICAgICAgICdGIycsXG4gICAgICAgICAgICAnQyMnLFxuICAgICAgICAgICAgJ0cjJ1xuICAgICAgICBdLFxuICAgICAgICBtb2RlOiBbXG4gICAgICAgICAgICAnbWFqJyxcbiAgICAgICAgICAgICdtaW4nLFxuICAgICAgICAgICAgJ21peCcsXG4gICAgICAgICAgICAnZG9yJyxcbiAgICAgICAgICAgICdhZW8nXG4gICAgICAgIF1cbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5kcm9wZG93bnMgPSBkcm9wZG93bnM7XG5cbiAgICByZXR1cm4gZHJvcGRvd25zO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKTtcbnJlcXVpcmUoJ2FuZ3VsYXItcmVzb3VyY2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbmd1bGFyLm1vZHVsZSgnam5yLmNvbW1vbicsIFsnbmdSZXNvdXJjZSddKVxuICAgIFxuICAgIC5kaXJlY3RpdmUoJ2pTZWxlY3RPbkNsaWNrJywgcmVxdWlyZSgnLi91aS9zZWxlY3Qtb24tY2xpY2snKSlcbiAgICAuZmlsdGVyKCdjYXBpdGFsaXNlJywgcmVxdWlyZSgnLi91aS9jYXBpdGFsaXNlJykpXG4gICAgLnNlcnZpY2UoJ2pNb2RhbHMnLCByZXF1aXJlKCcuL3VpL21vZGFscycpKVxuICAgIC5zZXJ2aWNlKCdyZWFkQ29va2llJywgcmVxdWlyZSgnLi9zZXJ2aWNlcy9yZWFkLWNvb2tpZScpKVxuICAgIC5zZXJ2aWNlKCdqUGFnZVN0YXRlJywgcmVxdWlyZSgnLi9zZXJ2aWNlcy9wYWdlLXN0YXRlJykpXG4gICAgLnNlcnZpY2UoJ2pEYXRhYmFzZScsIHJlcXVpcmUoJy4vZGF0YS9kYXRhYmFzZScpKVxuICAgIC5zZXJ2aWNlKCdqRHJvcGRvd25zJywgcmVxdWlyZSgnLi9kYXRhL2Ryb3Bkb3ducycpKVxuICAgIC5jb250cm9sbGVyKCd0b3BOYXYnLCByZXF1aXJlKCcuL2NvbnRyb2xsZXJzL3RvcC1uYXYnKSlcbjsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkY29va2llcykge1xuICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAkcm9vdFNjb3BlLnBhZ2VTdGF0ZSA9IHBhcmFtcztcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBwYXJhbXMgPSBkYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnaW5zdHJ1bWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGNvb2tpZXMuaW5zdHJ1bWVudCA9IGRhdGEuaW5zdHJ1bWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wID8gcGFyYW1zW3Byb3BdIDogcGFyYW1zO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBjb3BpZWQgKi8gXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlYWRDb29raWUgKG5hbWUpIHtcbiAgICB2YXIgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICB2YXIgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICBmb3IodmFyIGk9MDtpIDwgY2EubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgYyA9IGNhW2ldO1xuICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGNvcGllZCAqLyBcbiAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLGMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IGNvcGllZCAqLyBcbiAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCxjLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59OyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaW5wdXQuc3Vic3RyKDEpO1xuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkbW9kYWwpIHtcbiAgICBcbiAgICB2YXIgY29uZmlncyA9IHtcbiAgICAgICAgdHVuZVZpZXdlcjoge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3R1bmUvdHBsL3R1bmUtdmlld2VyLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ3R1bmVWaWV3ZXInLFxuICAgICAgICAgICAgd2luZG93Q2xhc3M6ICAndHVuZS12aWV3ZXIgZmFkZSdcbiAgICAgICAgfSxcbiAgICAgICAgYWRkVHVuZToge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3R1bmUvdHBsL2FkZC10dW5lLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ2FkZFR1bmUnLFxuICAgICAgICAgICAgd2luZG93Q2xhc3M6ICAnYWRkLXR1bmUgZmFkZSdcbiAgICAgICAgfSxcbiAgICAgICAgcGVyZm9ybWFuY2VFZGl0b3I6IHtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnL3NyYy90dW5lL3RwbC9wZXJmb3JtYW5jZS1lZGl0b3IuaHRtbCcsXG4gICAgICAgICAgICB3aW5kb3dDbGFzczogICdmYWRlJ1xuICAgICAgICB9LFxuICAgICAgICBhcnJhbmdlbWVudENvbmZpcm06IHtcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnL3NyYy90dW5lL3RwbC9hcnJhbmdlbWVudC1jb25maXJtLmh0bWwnLFxuICAgICAgICAgICAgd2luZG93Q2xhc3M6ICAnZmFkZSdcbiAgICAgICAgfSxcbiAgICAgICAgYWJjQ29uZmlybToge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3R1bmUvdHBsL2FiYy1jb25maXJtLmh0bWwnLFxuICAgICAgICAgICAgd2luZG93Q2xhc3M6ICAnZmFkZSdcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBvcGVuOiBmdW5jdGlvbiAodHlwZSwgc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBjb25mID0gY29uZmlnc1t0eXBlXSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogcGFyYW5vaWQgZmFsbGJhY2sgKi8ge307XG4gICAgICAgICAgICBzY29wZSAmJiAoY29uZi5zY29wZSA9IHNjb3BlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuICRtb2RhbC5vcGVuKGNvbmYpO1xuXG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuYmluZCgnY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbGVtZW50WzBdLnNlbGVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsIi8vIHZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpLFxuLy8gICAgIGxpc3RUdW5lcyA9IHJlcXVpcmUoJ3NyYy90dW5lLWxpc3RzL2NvbnRyb2xsZXJzL2xpc3QtdHVuZXMnKSxcbi8vICAgICAvLyB2aWV3VHVuZSA9IHJlcXVpcmUoJ3NyYy9jb250cm9sbGVycy92aWV3LXR1bmUnKSxcbi8vICAgICAvLyBzZXRCdWlsZGVyID0gcmVxdWlyZSgnc3JjL2NvbnRyb2xsZXJzL3NldC1idWlsZGVyJyksXG4vLyAgICAgLy8gbGlzdFNldHMgPSByZXF1aXJlKCdzcmMvY29udHJvbGxlcnMvbGlzdC1zZXRzJyksXG4vLyAgICAgbmV3VHVuZXMgPSByZXF1aXJlKCdzcmMvdHVuZS1saXN0cy9jb250cm9sbGVycy9uZXctdHVuZXMnKSxcbi8vICAgICB0dW5lVmlld2VyID0gcmVxdWlyZSgnc3JjL2NvbnRyb2xsZXJzL21vZGFscy90dW5lLXZpZXdlcicpLFxuLy8gICAgIGFkZFR1bmUgPSByZXF1aXJlKCdzcmMvY29udHJvbGxlcnMvbW9kYWxzL2FkZC10dW5lJyksXG4vLyAgICAgdG9wTmF2ID0gcmVxdWlyZSgnc3JjL2NvbnRyb2xsZXJzL2luY2x1ZGUvdG9wLW5hdicpO1xuXG5cbi8vIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgYW5ndWxhci5tb2R1bGUoJ2pucicpXG4vLyAgICAgICAgIC5jb250cm9sbGVyKCdsaXN0VHVuZXMnLCBsaXN0VHVuZXMpXG4vLyAgICAgICAgIC8vLmNvbnRyb2xsZXIoJ3ZpZXdUdW5lJywgdmlld1R1bmUpXG4vLyAgICAgICAgIC8vLmNvbnRyb2xsZXIoJ3NldEJ1aWxkZXInLCBzZXRCdWlsZGVyKVxuLy8gICAgICAgICAvLy5jb250cm9sbGVyKCdsaXN0U2V0cycsIGxpc3RTZXRzKVxuLy8gICAgICAgICAuY29udHJvbGxlcignbmV3VHVuZXMnLCBuZXdUdW5lcylcbi8vICAgICAgICAgLmNvbnRyb2xsZXIoJ3R1bmVWaWV3ZXInLCB0dW5lVmlld2VyKVxuLy8gICAgICAgICAuY29udHJvbGxlcignYWRkVHVuZScsIGFkZFR1bmUpXG4vLyAgICAgICAgIC5jb250cm9sbGVyKCd0b3BOYXYnLCB0b3BOYXYpO1xuXG4vLyB9O1xuIiwidmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XG5yZXF1aXJlKCdzcmMvYXBwJyk7XG5cbmFuZ3VsYXIuYm9vdHN0cmFwKGRvY3VtZW50LCBbJ2puciddKTsiLCIvLyAndXNlIHN0cmljdCc7XG5cbi8vIHZhciByZWFkQ29va2llID0gcmVxdWlyZSgnc3JjL2NvbW1vbi9yZWFkLWNvb2tpZScpO1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuLy8gICAgIHJlcXVpcmUoJ2FuZ3VsYXInKS5tb2R1bGUoJ2pucicpLmNvbmZpZyhbJyRyb3V0ZVByb3ZpZGVyJywgJyRsb2NhdGlvblByb3ZpZGVyJywgZnVuY3Rpb24gKCRyb3V0ZVByb3ZpZGVyLCAkbG9jYXRpb25Qcm92aWRlcikge1xuICAgICAgICBcbi8vICAgICAgICAgJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKHRydWUpLmhhc2hQcmVmaXgoJyEnKTsgICBcblxuLy8gICAgICAgICAkcm91dGVQcm92aWRlci53aGVuKCcvdHVuZXMnLCB7XG4vLyAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogJy92aWV3cy9saXN0LXR1bmVzLmh0bWwnXG4vLyAgICAgICAgIH0pLndoZW4oJy90dW5lcy86aW5zdHJ1bWVudCcsIHtcbi8vICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnL3ZpZXdzL2xpc3QtdHVuZXMuaHRtbCdcbi8vICAgICAgICAgLy8gfSkud2hlbignL3R1bmUvOmlkJywge1xuLy8gICAgICAgICAvLyAgICAgdGVtcGxhdGVVcmw6ICcvdmlld3MvdHVuZS5odG1sJ1xuLy8gICAgICAgICAvLyB9KS53aGVuKCcvdHVuZS86aWQvOmluc3RydW1lbnQnLCB7XG4vLyAgICAgICAgIC8vICAgICB0ZW1wbGF0ZVVybDogJy92aWV3cy90dW5lLmh0bWwnXG4vLyAgICAgICAgIC8vIH0pLndoZW4oJy9zZXRzL25ldy8nLCB7XG4vLyAgICAgICAgIC8vICAgICB0ZW1wbGF0ZVVybDogJy92aWV3cy9zZXQtYnVpbGRlci5odG1sJ1xuLy8gICAgICAgICAvLyB9KS53aGVuKCcvc2V0cy9saXN0LycsIHtcbi8vICAgICAgICAgLy8gICAgIHRlbXBsYXRlVXJsOiAnL3ZpZXdzL3NldC1saXN0Lmh0bWwnXG4vLyAgICAgICAgIC8vIH0pLndoZW4oJy9zZXRzL25ldy86aW5zdHJ1bWVudCcsIHtcbi8vICAgICAgICAgLy8gICAgIHRlbXBsYXRlVXJsOiAnL3ZpZXdzL3NldC1idWlsZGVyLmh0bWwnXG4vLyAgICAgICAgIC8vIH0pLndoZW4oJy9zZXRzL2xpc3QvOmluc3RydW1lbnQnLCB7XG4vLyAgICAgICAgIC8vICAgICB0ZW1wbGF0ZVVybDogJy92aWV3cy9zZXQtbGlzdC5odG1sJ1xuLy8gICAgICAgICB9KS5vdGhlcndpc2Uoe1xuLy8gICAgICAgICAgICAgcmVkaXJlY3RUbzogJy90dW5lcy8nICsgKCByZWFkQ29va2llKCdpbnN0cnVtZW50JykgfHwgJ21hbmRvbGluJylcbi8vICAgICAgICAgfSk7XG4vLyAgICAgfV0pO1xuLy8gfTtcblxuICAgIFxuIiwiLy8gJ3VzZSBzdHJpY3QnO1xuXG4vLyByZXF1aXJlKCdzcmMvc2VydmljZXMvcGFnZS1zdGF0ZScpO1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChcbi8vICAgICAkc2NvcGUsICAgICBcbi8vICAgICAkcm91dGVQYXJhbXMsIFxuLy8gICAgIGpQYWdlU3RhdGVcbi8vICkge1xuLy8gICAgIGpQYWdlU3RhdGUuc2V0KHtcbi8vICAgICAgICAgc2VjdGlvbjogJ3NldHMnLFxuLy8gICAgICAgICBpbnN0cnVtZW50OiAkcm91dGVQYXJhbXMuaW5zdHJ1bWVudCxcbi8vICAgICAgICAgc3Vic2VjdGlvbjogJ25ldycsIFxuLy8gICAgICAgICBwYXRoOiAnL3NldHMvbmV3J1xuLy8gICAgIH0pO1xuLy8gfTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnc3JjL3NldC9zZXJ2aWNlcy9zZXQtbW9kZWwnKTtcbnJlcXVpcmUoJ3NyYy9jb21tb24vc2VydmljZXMvcGFnZS1zdGF0ZScpO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChcbiAgICAkcm91dGVQYXJhbXMsIFxuICAgICRzY29wZSwgXG4gICAgJHJvb3RTY29wZSxcbiAgICBqTW9kYWxzLFxuICAgIGpTZXQsXG4gICAgJHRpbWVvdXQsXG4gICAgalBhZ2VTdGF0ZSxcbiAgICBqRGF0YWJhc2Vcbikge1xuXG4gICAgLy8gY29uc29sZS5sb2coakRhdGFiYXNlLmdldFRhYmxlKCd0dW5lcycpLCAncmVkJyk7XG4gICAgalBhZ2VTdGF0ZS5zZXQoe1xuICAgICAgICBzZWN0aW9uOiAnc2V0cycsXG4gICAgICAgIGluc3RydW1lbnQ6ICRyb3V0ZVBhcmFtcy5pbnN0cnVtZW50LFxuICAgICAgICBzdWJzZWN0aW9uOiAnbGlzdCcsIFxuICAgICAgICBwYXRoOiAnL3NldHMvbGlzdCdcbiAgICB9KTtcbiAgICBcbiAgICAkc2NvcGUuc2VsZWN0ZWRUdW5lcyA9IFtdO1xuXG4gICAgJHNjb3BlLmFycmFuZ2VtZW50cyA9IFtdO1xuICAgIGpEYXRhYmFzZS5nZXRUYWJsZSgndHVuZXMnKS4kcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkYXRhKXtcbiAgICAgICAgJHNjb3BlLmFycmFuZ2VtZW50cyA9IF8uc29ydEJ5KGRhdGEubWFwKGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICB2YXIgcGVyZiA9IF8uZmluZFdoZXJlKHR1bmUucGVyZm9ybWFuY2VzLCB7aW5zdHJ1bWVudDogJHJvdXRlUGFyYW1zLmluc3RydW1lbnR9KTtcbiAgICAgICAgICAgIGlmIChwZXJmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IF8uZmluZFdoZXJlKHR1bmUuYXJyYW5nZW1lbnRzLCB7X2lkOiBwZXJmLmFycmFuZ2VtZW50fSk7XG4gICAgICAgICAgICAgICAgYXJyLm5hbWUgPSB0dW5lLm5hbWUgKyAnICcgKyBhcnIucm9vdCArIHR1bmUubW9kZSArICcgJyArIHR1bmUucmh5dGhtO1xuICAgICAgICAgICAgICAgIGFyci5zYW5pdGlzZWROYW1lID0gYXJyLm5hbWUucmVwbGFjZSgvXihUaGV8QSkgLywgJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pLCAnc2FuaXRpc2VkTmFtZScpOyAgXG4gICAgfSk7XG5cbiAgICAkc2NvcGUuc2V0cyA9IFtdO1xuICAgIGpEYXRhYmFzZS5nZXRUYWJsZSgndHVuZXMnKS4kcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgakRhdGFiYXNlLmdldFRhYmxlKCdzZXRzJykuJHByb21pc2UudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgJHNjb3BlLnNldHMgPSBkYXRhLm1hcChmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBqU2V0KHNldCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5zZXRzID0gXy5zb3J0QnkoJHNjb3BlLnNldHMsIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldC5wZXJmb3JtYW5jZS5sYXN0UHJhY3RpY2VkIC0gKHNldC5wZXJmb3JtYW5jZS5zdGFuZGFyZCAqIDEyICogNjAgKjI0MDAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIFxuICAgICAgICAvLyAkc2NvcGUuc2V0cyA9ICRzY29wZS5zZXRzLnNvcnQoZnVuY3Rpb24gKHNldDEsIHNldDIpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiBzZXQyLnBlcmZvcm1hbmNlLmxhc3RQcmFjdGljZWQgLSBzZXQxLnBlcmZvcm1hbmNlLmxhc3RQcmFjdGljZWQ7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICBcbiAgICB9KTtcbiAgICAgICAgXG5cbiAgICAkc2NvcGUudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHNjb3BlLnNlbGVjdGVkVHVuZXMucG9wKCk7XG4gICAgfTtcblxuICAgICRzY29wZS5zZWxlY3RUdW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkc2NvcGUuc2VsZWN0ZWRUdW5lcy5wdXNoKHRoaXMuc2VsZWN0ZWRUdW5lKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFR1bmUgPSBudWxsO1xuICAgIH07XG5cbiAgICAkc2NvcGUuc2VsZWN0ZWRJbmRleCA9IC0xO1xuXG4gICAgJHNjb3BlLmV4cGFuZFJvdyA9IGZ1bmN0aW9uICgkaW5kZXgpIHtcbiAgICAgICAgJHNjb3BlLnNlbGVjdGVkSW5kZXggPSAkaW5kZXg7XG4gICAgfTtcblxuXG4gICAgJHNjb3BlLnNhdmVTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0dW5lcyA9ICRzY29wZS5zZWxlY3RlZFR1bmVzO1xuICAgICAgICBpZiAodHVuZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBqRGF0YWJhc2UuZ2V0UmVzb3VyY2UoJ3NldHMnKS5zYXZlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnZnV6enknICsgTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICAgICAgICB0dW5lczogdHVuZXNcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgICAgICAgICBqRGF0YWJhc2UuZ2V0VGFibGUoJ3NldHMnKS5zaGlmdChzZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUuc2VsZWN0ZWRUdW5lcyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS5wcmFjdGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50dW5lLnVwZGF0ZSgpO1xuICAgICAgICB2YXIgc2V0ID0gdGhpcy4kcGFyZW50LiRwYXJlbnQuc2V0O1xuICAgICAgICB2YXIgdHVuZXNMZWZ0VG9QcmFjdGljZSA9IHNldC50dW5lcy5maWx0ZXIoZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IERhdGUoKSkgLSAobmV3IERhdGUodHVuZS5wZXJmb3JtYW5jZS5sYXN0UHJhY3RpY2VkKSkgPiAxMjAwMDA7XG4gICAgICAgIH0pLmxlbmd0aDtcblxuICAgICAgICBpZiAoIXR1bmVzTGVmdFRvUHJhY3RpY2UpIHtcbiAgICAgICAgICAgICRzY29wZS5zZXRzLnNwbGljZSgkc2NvcGUuc2V0cy5pbmRleE9mKHNldCksIDEpO1xuICAgICAgICAgICAgJHNjb3BlLnNldHMucHVzaChzZXQpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgJHNjb3BlLmV4cGFuZFR1bmUgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgJHJvb3RTY29wZS5hY3RpdmVUdW5lID0gdGhpcy50dW5lO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNDb2xsYXBzZWQgPSAhb3B0cy5lZGl0O1xuICAgICAgICB0aGlzLnNob3dQZXJmb3JtYW5jZSA9ICFvcHRzLm5vUGVyZm9ybWFuY2U7XG4gICAgICAgIGpNb2RhbHMub3BlbigndHVuZVZpZXdlcicsIHRoaXMpO1xuICAgIH07XG5cbiAgICAkc2NvcGUucHJhY3RpY2VBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZXQgPSB0aGlzLnJhdGVlO1xuICAgICAgICBzZXQudHVuZXMuZm9yRWFjaChmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgdHVuZS5kdW1teVN0YW5kYXJkID0gc2V0LmR1bW15U3RhbmRhcmQ7XG4gICAgICAgICAgICB0dW5lLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0LnVwZGF0ZVBlcmZvcm1hbmNlKHRydWUpO1xuXG4gICAgICAgICRzY29wZS5zZXRzLnNwbGljZSgkc2NvcGUuc2V0cy5pbmRleE9mKHNldCksIDEpO1xuICAgICAgICAkc2NvcGUuc2V0cy5wdXNoKHNldCk7XG4gICAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdzcmMvY29tbW9uL21vZHVsZScpO1xucmVxdWlyZSgnc3JjL3NldC9tb2R1bGUnKTtcblxudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyksXG4gICAgcmVhZENvb2tpZSA9IHJlcXVpcmUoJ3NyYy9jb21tb24vc2VydmljZXMvcmVhZC1jb29raWUnKSxcbiAgICBzZXRNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnam5yLnNldC1saXN0cycsIFsnam5yLmNvbW1vbicsICdqbnIuc2V0J10pLFxuICAgIGxpc3RTZXRzID0gcmVxdWlyZSgnc3JjL3NldC1saXN0cy9jb250cm9sbGVycy9saXN0LXNldHMnKTtcbiAgICAvLyBhZGRUdW5lID0gcmVxdWlyZSgnc3JjL3NldC9jb250cm9sbGVycy9hZGQtc2V0Jyk7XG4gICAgICAgIFxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldE1vZHVsZVxuICAgIC5jb250cm9sbGVyKCdsaXN0U2V0cycsIGxpc3RTZXRzKVxuICAgIC5jb25maWcoZnVuY3Rpb24gKCRyb3V0ZVByb3ZpZGVyKSB7XG4gICAgXG4gICAgICAgICRyb3V0ZVByb3ZpZGVyLndoZW4oJy9zZXRzL2xpc3QvJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3NldC1saXN0cy90cGwvbGlzdC1zZXRzLmh0bWwnXG4gICAgICAgIH0pLndoZW4oJy9zZXRzL2xpc3QvOmluc3RydW1lbnQnLCB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJy9zcmMvc2V0LWxpc3RzL3RwbC9saXN0LXNldHMuaHRtbCdcbiAgICAgICAgfSk7XG4gICAgfSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdzcmMvY29tbW9uL21vZHVsZScpO1xucmVxdWlyZSgnc3JjL3R1bmUvbW9kdWxlJyk7XG5cbnZhciBhbmd1bGFyID0gcmVxdWlyZSgnYW5ndWxhcicpLFxuICAgIHNldE1vZHVsZSA9IGFuZ3VsYXIubW9kdWxlKCdqbnIuc2V0JywgWydqbnIuY29tbW9uJywgJ2puci50dW5lJ10pO1xuICAgIC8vIHNldFZpZXdlciA9IHJlcXVpcmUoJ3NyYy9zZXQvY29udHJvbGxlcnMvc2V0LXZpZXdlcicpLFxuICAgIC8vIGFkZFR1bmUgPSByZXF1aXJlKCdzcmMvc2V0L2NvbnRyb2xsZXJzL2FkZC1zZXQnKTtcbiAgICAgICAgXG5cbm1vZHVsZS5leHBvcnRzID0gc2V0TW9kdWxlO1xuICAgIC8vIC5jb250cm9sbGVyKCdzZXRWaWV3ZXInLCBzZXRWaWV3ZXIpXG4gICAgLy8gLmNvbnRyb2xsZXIoJ2FkZFR1bmUnLCBhZGRUdW5lKTsiLCJ2YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbi8vIHJlcXVpcmUoJ3NyYy90dW5lL3NlcnZpY2VzL2FiYy1wYXJzZXInKTtcblxucmVxdWlyZSgnYW5ndWxhcicpLm1vZHVsZSgnam5yLnNldCcpLmZhY3RvcnkoJ2pTZXQnLCBmdW5jdGlvbiAoXG4gICAgJHJvdXRlUGFyYW1zLFxuICAgICRyb290U2NvcGUsXG4gICAgakRhdGFiYXNlLFxuICAgIGpUdW5lXG4pIHtcblxuICAgIHZhciB0dW5lc0ZldGNoZWQgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgdmFyIFNldCA9IGZ1bmN0aW9uIChzZXQsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm92ZXJmbG93ID0gNiAtIHRoaXMuc2V0LnR1bmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghdHVuZXNGZXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgakRhdGFiYXNlLmdldFRhYmxlKCd0dW5lcycpLiRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lc0ZldGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFR1bmVzKCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGJlc3Q6IC0xLFxuICAgICAgICAgICAgICAgICAgICBsYXN0UHJhY3RpY2VkOiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUdW5lcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRUdW5lczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0LnR1bmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50dW5lcyA9IHRoaXMuc2V0LnR1bmVzLm1hcChmdW5jdGlvbiAoYXJyYW5nZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpUdW5lLmdldEZvckFycmFuZ2VtZW50KGFycmFuZ2VtZW50LCAkcm9vdFNjb3BlLnBhZ2VTdGF0ZS5pbnN0cnVtZW50KTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSk7ICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQZXJmb3JtYW5jZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR1bmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlUGVyZm9ybWFuY2U6IGZ1bmN0aW9uIChwcmFjdGljZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5kdW1teVN0YW5kYXJkID0gLTE7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlID0ge1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkOiB0aGlzLnR1bmVzLnJlZHVjZShmdW5jdGlvbiAocHJldlZhbCwgdHVuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldlZhbCwgdHVuZS5wZXJmb3JtYW5jZS5zdGFuZGFyZCk7XG4gICAgICAgICAgICAgICAgfSwgNSksXG4gICAgICAgICAgICAgICAgYmVzdDogdGhpcy50dW5lcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZWYWwsIHR1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXZWYWwsIHR1bmUucGVyZm9ybWFuY2UuYmVzdCk7XG4gICAgICAgICAgICAgICAgfSwgNSksXG4gICAgICAgICAgICAgICAgbGFzdFByYWN0aWNlZDogLy9wcmFjdGljZWQgPyBEYXRlLm5vdygpIDogXG4gICAgICAgICAgICAgICAgdGhpcy50dW5lcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZWYWwsIHR1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2VmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSh0dW5lLnBlcmZvcm1hbmNlLmxhc3RQcmFjdGljZWQpLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXZWYWwsIChuZXcgRGF0ZSh0dW5lLnBlcmZvcm1hbmNlLmxhc3RQcmFjdGljZWQpKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZClcbiAgICAgICAgICAgIH07IFxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgICAgICBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGlxdWlkTWV0YWwgPSByZXF1aXJlKCdsaXF1aWRtZXRhbCcpLFxuICAgIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxucmVxdWlyZSgnc3JjL3R1bmUtbGlzdHMvc2VydmljZXMvdHVuZS1saXN0Jyk7XG5yZXF1aXJlKCdzcmMvdHVuZS91aS90dW5lLWhlYWRpbmcnKTtcbnJlcXVpcmUoJ3NyYy90dW5lL3VpL3BlcmZvcm1hbmNlLXJhdGVyJyk7XG5yZXF1aXJlKCdzcmMvY29tbW9uL3VpL3NlbGVjdC1vbi1jbGljaycpO1xucmVxdWlyZSgnc3JjL2NvbW1vbi9zZXJ2aWNlcy9wYWdlLXN0YXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFxuICAgICRzY29wZSwgXG4gICAgJHJvb3RTY29wZSwgXG4gICAgJHJvdXRlUGFyYW1zLCBcbiAgICBqUGFnZVN0YXRlLCBcbiAgICBqVHVuZUxpc3Rcbikge1xuICAgIHZhciBmaWx0ZXJzID0ge1xuICAgICAgICAgICAgcHJhY3RpY2U6IGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmUudHVuZS5wZXJmb3JtYW5jZXMubGVuZ3RoICYmICghJHJvdXRlUGFyYW1zLmluc3RydW1lbnQgfHwgXy5maWx0ZXIodHVuZS50dW5lLnBlcmZvcm1hbmNlcywgZnVuY3Rpb24gKHBlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5pbnN0cnVtZW50ID09PSAkcm91dGVQYXJhbXMuaW5zdHJ1bWVudCAmJiAocGVyZm9ybWFuY2UuYmVzdCA+IDIgfHwgcGVyZm9ybWFuY2Uuc3BlY2lhbCk7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICAgICAgdHVuZS5zZWFyY2hTY29yZSA9IGxpcXVpZE1ldGFsLnNjb3JlKHR1bmUudHVuZS5uYW1lLCAkc2NvcGUuc2VhcmNoVGVybS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuZS5zZWFyY2hTY29yZSA+IDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc29ydGVycyA9IHtcbiAgICAgICAgICAgIHByYWN0aWNlOiBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgIHZhciBwZXJmb3JtYW5jZSA9IHR1bmUucGVyZm9ybWFuY2UgfHwgdHVuZS5fY3JlYXRlUGVyZm9ybWFuY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2FwID0gcGVyZm9ybWFuY2UuYmVzdCAtIHBlcmZvcm1hbmNlLnN0YW5kYXJkLFxuICAgICAgICAgICAgICAgICAgICBkaWZmaWN1bHR5ID0gcGVyZm9ybWFuY2UuZGlmZmljdWx0eSA9PT0gLTEgPyAwIDogcGVyZm9ybWFuY2UuZGlmZmljdWx0eSxcbiAgICAgICAgICAgICAgICAgICAgcmF0aW5nID0gdHVuZS50dW5lLnJhdGluZyA9PT0gLTEgPyAwIDogdHVuZS50dW5lLnJhdGluZyxcbiAgICAgICAgICAgICAgICAgICAgcG9wdWxhcml0eSA9IHR1bmUudHVuZS5wb3B1bGFyaXR5ID09PSAtMSA/IDAgOiB0dW5lLnR1bmUucG9wdWxhcml0eSxcbiAgICAgICAgICAgICAgICAgICAgcHJhY3RpY2VVcmdlbmN5ID0gMCxcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlVmVyc2lvbiA9IHR1bmUudHVuZS5wZXJmb3JtYW5jZXMubGVuZ3RoIDwgMixcbiAgICAgICAgICAgICAgICAgICAgdHVuZVJhbmsgPSAocGVyZm9ybWFuY2Uuc3BlY2lhbCAqIDUpICsgKDEuNSAqIHJhdGluZykgKyBwb3B1bGFyaXR5ICsgdW5pcXVlVmVyc2lvbjtcblxuICAgICAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5iZXN0ID4gMiB8fCBwZXJmb3JtYW5jZS5zcGVjaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByYWN0aWNlVXJnZW5jeSA9IChnYXAgKyAoZGlmZmljdWx0eSAvIDIpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZS5zdGFuZGFyZCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByYWN0aWNlVXJnZW5jeSArPSBnYXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmZvcm1hbmNlLnNwZWNpYWwgJiYgcGVyZm9ybWFuY2UuYmVzdCA8IDMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmFjdGljZVVyZ2VuY3kgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByYWN0aWNlVXJnZW5jeSA9IChnYXAgLSAoZGlmZmljdWx0eSAvIDIpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR1bmUucHJhY3RpY2VSYW5rID0gdHVuZVJhbmsgKiBwcmFjdGljZVVyZ2VuY3kgKiAodHVuZS5kYXlzU2luY2VMYXN0UHJhY3RpY2UgKyAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gLXR1bmUucHJhY3RpY2VSYW5rO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLXR1bmUuc2VhcmNoU2NvcmU7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyVGVybSkge1xuICAgICAgICAgICAgdmFyIG1vZGVUZXJtID0gJHNjb3BlLmZpbHRlck1vZGUudHJpbSgpLFxuICAgICAgICAgICAgICAgIHJoeXRobVRlcm0gPSAkc2NvcGUuZmlsdGVyUmh5dGhtLnRyaW0oKTtcblxuICAgICAgICAgICAgdmFyIGFsbFR1bmVSaHl0aG1zID0gJHJvb3RTY29wZS5kcm9wZG93bnMucmh5dGhtLFxuICAgICAgICAgICAgICAgIHJoeXRobXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVkOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHJoeXRobVRlcm0pIHtcbiAgICAgICAgICAgICAgICByaHl0aG1UZXJtID0gcmh5dGhtVGVybS5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhbGxUdW5lUmh5dGhtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmh5dGhtVGVybS5pbmRleE9mKGFsbFR1bmVSaHl0aG1zW2tleV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoeXRobXMuaW5jbHVkZWQucHVzaChhbGxUdW5lUmh5dGhtc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmh5dGhtVGVybS5pbmRleE9mKCchJyArIGFsbFR1bmVSaHl0aG1zW2tleV0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoeXRobXMuZXhjbHVkZWQucHVzaChhbGxUdW5lUmh5dGhtc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGVUZXJtICYmIC9eKFxcIT8oW0FCQ0RFRkddKCN8Yik/KT8oW2Etel17M30pPyhcXHwpPykrJC8udGVzdChtb2RlVGVybSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZXMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZU1hdGNoZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5kOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIG1vZGVUZXJtID0gbW9kZVRlcm0ucmVwbGFjZSgvXFwoW14oXStcXCkvZywgZnVuY3Rpb24gKCQxKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIG1vZGVzLnB1c2goJDEuc3Vic3RyKDEsICQxLmxlbmd0aCAtIDIpKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIC8vIH0pO1xuXG4gICAgICAgICAgICAgICAgbW9kZXMgPSBtb2Rlcy5jb25jYXQobW9kZVRlcm0pO1xuXG4gICAgICAgICAgICAgICAgZm9yIChtb2RlIGluIG1vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFNpbmdsZU1vZGVGaWx0ZXIobW9kZXNbbW9kZV0sIG1vZGVNYXRjaGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBieSBlLmcgR3xhZW8gRG1haiwgbWl4fG1hai4gY2FzZSBzZW5zaXRpdmUsICFHIChub3QgYXV0b21hdGljYWxseSBiZWNvbWVzIGFuIGFuZClcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmh5dGhtVGVybSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJoeXRobXMuaW5jbHVkZWQubGVuZ3RoICYmIHJoeXRobXMuaW5jbHVkZWQuaW5kZXhPZih0dW5lLnR1bmUucmh5dGhtKSA9PT0gLTEpIHx8IChyaHl0aG1zLmV4Y2x1ZGVkLmxlbmd0aCAmJiByaHl0aG1zLmV4Y2x1ZGVkLmluZGV4T2YodHVuZS50dW5lLnJoeXRobSkgPiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVNYXRjaGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuTWF0Y2hlcnModHVuZSwgbW9kZU1hdGNoZXJzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTaW5nbGVNb2RlRmlsdGVyID0gZnVuY3Rpb24gKG1vZGUsIG1hdGNoZXJzKSB7XG4gICAgICAgICAgICAvLyBpZiAoIW1vZGUpIHtcbiAgICAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50cztcbiAgICAgICAgICAgIC8vIGlmIChtb2RlLmluZGV4T2YoJ3whJykgPiAtMSkge1xuICAgICAgICAgICAgLy8gICAgIHN0YXRlbWVudHMgPSBtb2RlLnNwbGl0KCd8IScpO1xuICAgICAgICAgICAgLy8gICAgIHN0YXRlbWVudHMubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gICAgICAgICBnZXRTaW5nbGVNb2RlRmlsdGVyKGluZGV4ICE9PSAwID8gJyEnIDogJycgKyBpdGVtLCBtYXRjaGVycyk7XG4gICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKC9bYS16XVxcfFtBLVpdLy50ZXN0KG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBtb2RlLnNwbGl0KCd8JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWwgPSBzdGF0ZW1lbnRzLmxlbmd0aDsgaTxpbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvdGhlciBjb2RlIHByZXZlbnRzIGl0IGV2ZXIgcnVubmluZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvW2Etel0vLnRlc3Qoc3RhdGVtZW50LmNoYXJBdChzdGF0ZW1lbnQubGVuZ3RoIC0gMSkpICYmIC9bQS1aXS8udGVzdChzdGF0ZW1lbnRzW2ldLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2luZ2xlTW9kZUZpbHRlcihzdGF0ZW1lbnQsIG1hdGNoZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgICAgICBnZXRTaW5nbGVNb2RlRmlsdGVyKHN0YXRlbWVudCwgbWF0Y2hlcnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvb3RzID0gbW9kZS5tYXRjaCgvW0EtWl0vZyksXG4gICAgICAgICAgICAgICAgbW9kZXMgPSBtb2RlLm1hdGNoKC9bYS16XXszfS9nKSxcbiAgICAgICAgICAgICAgICBuZWdhdGVkID0gbW9kZS5pbmRleE9mKCchJykgPT09IDA7XG5cbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzICYmIHJvb3RzLmluZGV4T2YodHVuZS5hcnJhbmdlbWVudC5yb290KSA+IC0xO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYgKG1vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzICYmIG1vZGVzLmluZGV4T2YodHVuZS50dW5lLm1vZGUpID4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBuZWdhdGVkID8gIW1hdGNoZXMgOiBtYXRjaGVzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbWF0Y2hlcnNbbmVnYXRlZCA/ICdhbmQnIDogJ29yJ10ucHVzaChtYXRjaGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBydW5NYXRjaGVycyA9IGZ1bmN0aW9uICh0dW5lLCBtYXRjaGVycykge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXIsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcnMub3IubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChtYXRjaGVyIGluIG1hdGNoZXJzLm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVycy5vclttYXRjaGVyXSh0dW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcnMuYW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobWF0Y2hlciBpbiBtYXRjaGVycy5hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVycy5hbmRbbWF0Y2hlcl0odHVuZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvdW50cyAoKSB7XG4gICAgICAgIGlmICgkc2NvcGUuc2VhcmNoVGVybSkge3JldHVybjt9XG4gICAgICAgIHZhciBhbGxUdW5lcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkodHVuZUxpc3Quc2VsZWN0ZWRUdW5lcywgdHVuZUxpc3Qub3RoZXJUdW5lcyk7XG4gICAgICAgICRzY29wZS5jb3VudHMgPSBbXG4gICAgICAgICAgICBhbGxUdW5lcy5sZW5ndGgsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm93OiBfLmZpbHRlcihhbGxUdW5lcywgZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR1bmUucGVyZm9ybWFuY2Uuc3RhbmRhcmQgPT09IDE7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhc3Q6IF8uZmlsdGVyKGFsbFR1bmVzLCBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVuZS5wZXJmb3JtYW5jZS5iZXN0ID09PSAxO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub3c6IF8uZmlsdGVyKGFsbFR1bmVzLCBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVuZS5wZXJmb3JtYW5jZS5zdGFuZGFyZCA9PT0gMjtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcGFzdDogXy5maWx0ZXIoYWxsVHVuZXMsIGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dW5lLnBlcmZvcm1hbmNlLmJlc3QgPT09IDI7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vdzogXy5maWx0ZXIoYWxsVHVuZXMsIGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dW5lLnBlcmZvcm1hbmNlLnN0YW5kYXJkID09PSAzO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwYXN0OiBfLmZpbHRlcihhbGxUdW5lcywgZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR1bmUucGVyZm9ybWFuY2UuYmVzdCA9PT0gMztcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm93OiBfLmZpbHRlcihhbGxUdW5lcywgZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR1bmUucGVyZm9ybWFuY2Uuc3RhbmRhcmQgPT09IDQ7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHBhc3Q6IF8uZmlsdGVyKGFsbFR1bmVzLCBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVuZS5wZXJmb3JtYW5jZS5iZXN0ID09PSA0O1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub3c6IF8uZmlsdGVyKGFsbFR1bmVzLCBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVuZS5wZXJmb3JtYW5jZS5zdGFuZGFyZCA9PT0gNTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcGFzdDogXy5maWx0ZXIoYWxsVHVuZXMsIGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dW5lLnBlcmZvcm1hbmNlLmJlc3QgPT09IDU7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG5cbiAgICAgICAgJHNjb3BlLmNvdW50cy50b1NjcmF0Y2ggPSB7XG4gICAgICAgICAgICBub3c6IF8uZmlsdGVyKGFsbFR1bmVzLCBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5lLnBlcmZvcm1hbmNlLnN0YW5kYXJkID4gMjtcbiAgICAgICAgICAgIH0pLmxlbmd0aCxcbiAgICAgICAgICAgIHBhc3Q6IF8uZmlsdGVyKGFsbFR1bmVzLCBmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5lLnBlcmZvcm1hbmNlLmJlc3QgPiAyO1xuICAgICAgICAgICAgfSkubGVuZ3RoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgJHNjb3BlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWYgKHRoaXMudHVuZS5kdW1teVN0YW5kYXJkID4gLTEpIHtcbiAgICAgICAgLy8gICAgIHR1bmVMaXN0Lm1vdmVUb0JvdHRvbSh0aGlzLnR1bmUpOyAgICBcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHRoaXMudHVuZS51cGRhdGUoe1xuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IHRoaXMudHVuZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAgIHNldFB1YmxpY1BlcmZvcm1hbmNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy91cGRhdGVDb3VudHMoKTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnNlYXJjaFRlcm0gPSAnJztcbiAgICAkc2NvcGUuZmlsdGVyTW9kZSA9ICcnO1xuICAgICRzY29wZS5maWx0ZXJSaHl0aG0gPSAnJztcbiAgICAkc2NvcGUuc3VtbWFyeUNvbGxhcHNlZCA9IHRydWU7XG4gICAgJHJvb3RTY29wZS4kb24oJ3R1bmVQcmFjdGljZWQnLCBmdW5jdGlvbiAoZXZlbnQsIHR1bmUpIHtcbiAgICAgICAgdHVuZUxpc3QubW92ZVRvQm90dG9tKHR1bmUpO1xuICAgICAgICB1cGRhdGVDb3VudHMoKTtcblxuICAgIH0pO1xuXG4gICAgJHNjb3BlLnNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRzY29wZS5zZWFyY2hUZXJtLnRyaW0oKS5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAkc2NvcGUuZmlsdGVyTW9kZSA9ICcnO1xuICAgICAgICAgICAgJHNjb3BlLmZpbHRlclJoeXRobSA9ICcnO1xuICAgICAgICAgICAgdHVuZUxpc3QucmVsaXN0KHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcnMuc2VhcmNoLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnRlcnMuc2VhcmNoLFxuICAgICAgICAgICAgICAgIGZvcmNlUmVsaXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpbWl0OiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1bmVMaXN0LnJlbGlzdCh7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJzLnByYWN0aWNlLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnRlcnMucHJhY3RpY2UsXG4gICAgICAgICAgICAgICAgbGltaXQ6IDE1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkc2NvcGUuZmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBcbiAgICAgICAgaWYgKCRzY29wZS5maWx0ZXJNb2RlLnRyaW0oKSB8fCAkc2NvcGUuZmlsdGVyUmh5dGhtLnRyaW0oKSkge1xuICAgICAgICAgICAgJHNjb3BlLnNlYXJjaFRlcm0gPSAnJztcbiAgICAgICAgICAgIHR1bmVMaXN0LnJlbGlzdCh7XG4gICAgICAgICAgICAgICAgZmlsdGVyOiBnZXRGaWx0ZXIoKSxcbiAgICAgICAgICAgICAgICBzb3J0OiBzb3J0ZXJzLnByYWN0aWNlLFxuICAgICAgICAgICAgICAgIGZvcmNlUmVsaXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpbWl0OiAoJHNjb3BlLmZpbHRlclJoeXRobS50cmltKCkgJiYgJHNjb3BlLmZpbHRlck1vZGUudHJpbSgpKSA/IDAgOiAyMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dW5lTGlzdC5yZWxpc3Qoe1xuICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVycy5wcmFjdGljZSxcbiAgICAgICAgICAgICAgICBzb3J0OiBzb3J0ZXJzLnByYWN0aWNlLFxuICAgICAgICAgICAgICAgIGxpbWl0OiAxNVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJHNjb3BlLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICRzY29wZS5zb3J0ZXJzID0gc29ydGVycztcblxuICAgIGpQYWdlU3RhdGUuc2V0KHtcbiAgICAgICAgc2VjdGlvbjogJ3R1bmVzJyxcbiAgICAgICAgaW5zdHJ1bWVudDogJHJvdXRlUGFyYW1zLmluc3RydW1lbnQsXG4gICAgICAgIHBhdGg6ICcvdHVuZXMnXG4gICAgfSk7XG5cbiAgICB2YXIgdHVuZUxpc3QgPSBqVHVuZUxpc3Qoe1xuICAgICAgICAkc2NvcGU6ICRzY29wZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXJzLnByYWN0aWNlLFxuICAgICAgICBzb3J0OiBzb3J0ZXJzLnByYWN0aWNlLFxuICAgICAgICB0dW5lTW9kaWZpZXI6IGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICB0dW5lLmR1bW15U3RhbmRhcmQgPSAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdXBkYXRlQ291bnRzKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAkc2NvcGUuJG9uKCd0dW5lc0xpc3RlZCcsIGZ1bmN0aW9uIChldmVudCwgbGlzdCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBpZiAobGlzdCA9PT0gdHVuZUxpc3QpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50cygpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9KTtcbiAgICB9ICAgIFxufTsiLCJ2YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5yZXF1aXJlKCdzcmMvY29tbW9uL3VpL21vZGFscycpO1xucmVxdWlyZSgnc3JjL3R1bmUvdWkvdHVuZS1oZWFkaW5nJyk7XG5yZXF1aXJlKCdzcmMvdHVuZS91aS9wZXJmb3JtYW5jZS1yYXRlcicpO1xucmVxdWlyZSgnc3JjL3R1bmUtbGlzdHMvc2VydmljZXMvdHVuZS1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFxuICAgICRzY29wZSxcbiAgICAkcm9vdFNjb3BlLFxuICAgIGpUdW5lTGlzdCxcbiAgICBqTW9kYWxzXG4pIHtcblxuICAgICRyb290U2NvcGUuc2hvd05ld1R1bmVzID0gZmFsc2U7XG5cbiAgICB2YXIgZ2V0UGVyZm9ybWFuY2VGb3JJbnN0cnVtZW50ID0gZnVuY3Rpb24gKHR1bmUsIGluc3RydW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXy5maW5kV2hlcmUodHVuZS50dW5lLnBlcmZvcm1hbmNlcywge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50OiBpbnN0cnVtZW50XG4gICAgICAgICAgICAgICAgfSkgfHwge1xuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50OiBpbnN0cnVtZW50LFxuICAgICAgICAgICAgICAgICAgICBkdW1teTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpc05ldyA9IGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVuZS5pc05ldygpO1xuICAgICAgICB9O1xuXG4gICAgJHNjb3BlLmxhc3RUdW5lUmVtb3ZlZDtcblxuICAgICRzY29wZS5maW5pc2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHVuZUxpc3QucmVtb3ZlKHRoaXMudHVuZSk7XG4gICAgICAgIGlmICghJHNjb3BlLm5ld1R1bmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TmV3VHVuZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAkc2NvcGUudW5kbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHVuZUxpc3QudW5kb1JlbW92ZSgpO1xuICAgIH07XG5cbiAgICAkc2NvcGUudXBkYXRlID0gZnVuY3Rpb24gKG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudHVuZS51cGRhdGUoe1xuICAgICAgICAgICAgb2xkUHJvcHM6IG9sZFZhbHVlLFxuICAgICAgICAgICAgc2V0UHVibGljUGVyZm9ybWFuY2U6IHRydWVcbiAgICAgICAgfSk7ICAgICAgIFxuICAgIH07IFxuXG4gICAgdmFyIHBlcmZvcm1hbmNlRWRpdG9yO1xuXG4gICAgJHNjb3BlLmVkaXRQZXJmb3JtYW5jZUZvckluc3RydW1lbnQgPSBmdW5jdGlvbiAoaW5zdHJ1bWVudCkge1xuICAgICAgICB0aGlzLnR1bmUucGVyZm9ybWFuY2UgPSBnZXRQZXJmb3JtYW5jZUZvckluc3RydW1lbnQodGhpcy50dW5lLCBpbnN0cnVtZW50KTtcbiAgICAgICAgdGhpcy5pbnN0cnVtZW50ID0gaW5zdHJ1bWVudDtcbiAgICAgICAgcGVyZm9ybWFuY2VFZGl0b3IgPSBqTW9kYWxzLm9wZW4oJ3BlcmZvcm1hbmNlRWRpdG9yJywgdGhpcyk7XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdHJpY2t5IHRvIHRlc3QgKi9cbiAgICAkc2NvcGUuZmluaXNoUGVyZm9ybWFuY2VFZGl0ID0gZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgdHVuZS5wZXJmb3JtYW5jZSA9IHtcbiAgICAgICAgICAgIGR1bW15OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHBlcmZvcm1hbmNlRWRpdG9yLmRpc21pc3MoKTtcbiAgICB9O1xuXG4gICAgdmFyIHR1bmVMaXN0ID0galR1bmVMaXN0KHtcbiAgICAgICAgJHNjb3BlOiAkc2NvcGUsXG4gICAgICAgIGxpc3ROYW1lOiAnbmV3VHVuZXMnLFxuICAgICAgICBmaWx0ZXI6IGlzTmV3LFxuICAgICAgICBsaW1pdDogNFxuICAgIH0pO1xuXG4gICAgJHJvb3RTY29wZS5uZXdUdW5lQ291bnQgPSB0dW5lTGlzdC50dW5lQ291bnQ7XG4gICAgJHNjb3BlLiRvbigndHVuZXNMaXN0ZWQnLCBmdW5jdGlvbiAoZXZlbnQsIHR1bmVMaXN0KSB7XG4gICAgICAgICRyb290U2NvcGUubmV3VHVuZUNvdW50ID0gdHVuZUxpc3QudHVuZUNvdW50O1xuICAgIH0pO1xuXG4gICAgJHJvb3RTY29wZS4kb24oJ25ld1R1bmVzRmV0Y2hlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0dW5lTGlzdC5yZWxpc3Qoe1xuICAgICAgICAgICAgZm9yY2VSZWxpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnc3JjL2NvbW1vbi9tb2R1bGUnKTtcbnJlcXVpcmUoJ3NyYy90dW5lL21vZHVsZScpO1xuXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKSxcbiAgICB0dW5lTGlzdHNNb2R1bGUgPSBhbmd1bGFyLm1vZHVsZSgnam5yLnR1bmUtbGlzdHMnLCBbJ2puci5jb21tb24nLCAnam5yLnR1bmUnXSksXG4gICAgcmVhZENvb2tpZSA9IHJlcXVpcmUoJ3NyYy9jb21tb24vc2VydmljZXMvcmVhZC1jb29raWUnKSxcbiAgICBsaXN0VHVuZXMgPSByZXF1aXJlKCdzcmMvdHVuZS1saXN0cy9jb250cm9sbGVycy9saXN0LXR1bmVzJyksXG4gICAgbmV3VHVuZXMgPSByZXF1aXJlKCdzcmMvdHVuZS1saXN0cy9jb250cm9sbGVycy9uZXctdHVuZXMnKTtcbiAgICAgICAgXG5tb2R1bGUuZXhwb3J0cyA9IHR1bmVMaXN0c01vZHVsZVxuICAgIC5jb250cm9sbGVyKCdsaXN0VHVuZXMnLCBsaXN0VHVuZXMpXG4gICAgLmNvbnRyb2xsZXIoJ25ld1R1bmVzJywgbmV3VHVuZXMpXG4gICAgLmNvbmZpZyhmdW5jdGlvbiAoJHJvdXRlUHJvdmlkZXIpIHtcbiAgICBcbiAgICAgICAgJHJvdXRlUHJvdmlkZXIud2hlbignL3R1bmVzJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3R1bmUtbGlzdHMvdHBsL2xpc3QtdHVuZXMuaHRtbCdcbiAgICAgICAgfSkud2hlbignL3R1bmVzLzppbnN0cnVtZW50Jywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3R1bmUtbGlzdHMvdHBsL2xpc3QtdHVuZXMuaHRtbCdcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiIsInJlcXVpcmUoJ3NyYy9jb21tb24vZGF0YS9kYXRhYmFzZScpO1xucmVxdWlyZSgnc3JjL2NvbW1vbi91aS9tb2RhbHMnKTtcbnJlcXVpcmUoJ3NyYy90dW5lL3NlcnZpY2VzL3R1bmUtbW9kZWwnKTtcbnJlcXVpcmUoJ3NyYy9jb21tb24vc2VydmljZXMvcGFnZS1zdGF0ZScpO1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5yZXF1aXJlKCdhbmd1bGFyJykubW9kdWxlKCdqbnIudHVuZS1saXN0cycpLmZhY3RvcnkoJ2pUdW5lTGlzdCcsIGZ1bmN0aW9uIChcbiAgICAkcm9vdFNjb3BlLCBcbiAgICBqRGF0YWJhc2UsIFxuICAgIGpNb2RhbHMsXG4gICAgalBhZ2VTdGF0ZSxcbiAgICBqVHVuZVxuKSB7XG5cbiAgICB2YXIgYWxsVHVuZXMgPSBqRGF0YWJhc2UuZ2V0VGFibGUoJ3R1bmVzJyksXG5cbiAgICAgICAgZXhwYW5kVHVuZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgICRyb290U2NvcGUuYWN0aXZlVHVuZSA9IHRoaXMudHVuZTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllc0NvbGxhcHNlZCA9ICFvcHRzLmVkaXQ7XG4gICAgICAgICAgICB0aGlzLnNob3dQZXJmb3JtYW5jZSA9ICFvcHRzLm5vUGVyZm9ybWFuY2U7XG4gICAgICAgICAgICBqTW9kYWxzLm9wZW4oJ3R1bmVWaWV3ZXInLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnR1bmUudXBkYXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHVuZUxpc3RGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVuZUxpc3QoY29uZik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVHVuZUxpc3QgPSBmdW5jdGlvbiAoY29uZikge1xuICAgICAgICAgICAgdGhpcy5jb25mID0gY29uZjtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9O1xuXG4gICAgVHVuZUxpc3QucHJvdG90eXBlID0ge1xuICAgICAgICBcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUgPSB0aGlzLmNvbmYuJHNjb3BlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnR1bmVNb2RpZmllciA9IHRoaXMuY29uZi50dW5lTW9kaWZpZXIgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB0aGlzLmxpc3ROYW1lID0gdGhpcy5jb25mLmxpc3ROYW1lIHx8ICd0dW5lcyc7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyh0aGlzLmNvbmYpO1xuICAgICAgICAgICAgdGhpcy50dW5lQ291bnQgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIWFsbFR1bmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHNjb3BlLiRvbignakRhdGFMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucG9wdWxhdGVMaXN0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGVMaXN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJHNjb3BlLmV4cGFuZFR1bmUgPSB0aGlzLiRzY29wZS5leHBhbmRUdW5lIHx8IGV4cGFuZFR1bmU7XG4gICAgICAgICAgICB0aGlzLiRzY29wZS51cGRhdGUgPSB0aGlzLiRzY29wZS51cGRhdGUgfHwgdXBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQYXJhbXM6IGZ1bmN0aW9uIChjb25mKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnQgPSBjb25mLnNvcnQgIT09IHVuZGVmaW5lZCA/IGNvbmYuc29ydCA6IHRoaXMuc29ydDtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gY29uZi5maWx0ZXIgIT09IHVuZGVmaW5lZCA/IGNvbmYuZmlsdGVyIDogdGhpcy5maWx0ZXI7XG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gY29uZi5saW1pdCAhPT0gdW5kZWZpbmVkID8gY29uZi5saW1pdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0ID09PSB1bmRlZmluZWQgPyAxNSA6IHRoaXMubGltaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvcHVsYXRlTGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHR1bmVzID0gW107XG5cbiAgICAgICAgICAgIGFsbFR1bmVzLm1hcChmdW5jdGlvbiAodHVuZSkge1xuICAgICAgICAgICAgICAgIHZhciBhZ2dyZWdhdGVzID0galR1bmUuZXh0cmFjdCh0dW5lLCB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlRmlsdGVyOiBmdW5jdGlvbiAocGVyZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcmYuaW5zdHJ1bWVudCA9PT0gJHJvb3RTY29wZS5wYWdlU3RhdGUuaW5zdHJ1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbGlzdDogdHVuZXNcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBzZWxmLnR1bmVNb2RpZmllclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0dW5lcyA9IF8uZmlsdGVyKHR1bmVzLCB0aGlzLmZpbHRlcik7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50dW5lQ291bnQgPSB0dW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0KSB7XG4gICAgICAgICAgICAgICAgdHVuZXMgPSBfLnNvcnRCeSh0dW5lcywgdGhpcy5zb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFR1bmVzID0gXy5maXJzdCh0dW5lcywgdGhpcy5saW1pdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdGhlclR1bmVzID0gXy5yZXN0KHR1bmVzLCB0aGlzLmxpbWl0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFR1bmVzID0gdHVuZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5vdGhlclR1bmVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRzY29wZVt0aGlzLmxpc3ROYW1lXSA9IHRoaXMuc2VsZWN0ZWRUdW5lcztcbiAgICAgICAgICAgIHRoaXMuJHNjb3BlLiRlbWl0KCd0dW5lc0xpc3RlZCcsIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICByZWxpc3Q6IGZ1bmN0aW9uIChjb25mKSB7XG4gICAgICAgICAgICB2YXIgb2xkTGltaXQgPSB0aGlzLmxpbWl0O1xuICAgICAgICAgICAgaWYgKCFjb25mLmZvcmNlUmVsaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYuc29ydCAmJiBjb25mLnNvcnQgPT09IHRoaXMuc29ydCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29uZi5zb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZi5maWx0ZXIgJiYgY29uZi5maWx0ZXIgPT09IHRoaXMuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb25mLmZpbHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25mLmZpbHRlciAmJiAhY29uZi5zb3J0ICYmIGNvbmYubGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoY29uZik7XG5cbiAgICAgICAgICAgIGlmIChjb25mLnNvcnQgfHwgY29uZi5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlTGlzdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZi5saW1pdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAvL2NoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbWl0ID09PSAwICYmIG9sZExpbWl0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2VsZWN0ZWRUdW5lcywgdGhpcy5vdGhlclR1bmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlclR1bmVzID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRMaW1pdCA+IHRoaXMubGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkodGhpcy5vdGhlclR1bmVzLCB0aGlzLnNlbGVjdGVkVHVuZXMuc3BsaWNlKHRoaXMubGltaXQsIG9sZExpbWl0IC0gdGhpcy5saW1pdCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2xkTGltaXQgPCB0aGlzLmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2VsZWN0ZWRUdW5lcywgdGhpcy5vdGhlclR1bmVzLnNwbGljZSgwLCB0aGlzLmxpbWl0IC0gb2xkTGltaXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGVMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmVUb0JvdHRvbTogZnVuY3Rpb24gKHR1bmUpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUdW5lcy5zcGxpY2UodGhpcy5zZWxlY3RlZFR1bmVzLmluZGV4T2YodHVuZSksIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3RoZXJUdW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm90aGVyVHVuZXMucHVzaCh0dW5lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVHVuZXMucHVzaCh0aGlzLm90aGVyVHVuZXMuc2hpZnQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRpbWVvdXQgcHJldmVudHMgYSBtb3ZlIGV2ZW50IHRyaWdnZXJpbmcgaW5zdGVhZCBvZiBhIGxlYXZlIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIGhlbmNlIG1ha2VzIHN1cmUgdGhlIGFuaW1hdGlvbiBoYXBwZW5zXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRUdW5lcy5wdXNoKHR1bmUpO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh0dW5lKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnNlbGVjdGVkVHVuZXMuaW5kZXhPZih0dW5lKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUdW5lcy5zcGxpY2UoaW5kZXgsIDEgKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbW92ZWQgPSBbaW5kZXgsIHR1bmVdO1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUubGFzdFJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMub3RoZXJUdW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVHVuZXMucHVzaCh0aGlzLm90aGVyVHVuZXMuc2hpZnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG9SZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMub3RoZXJUdW5lcy51bnNoaWZ0KHRoaXMuc2VsZWN0ZWRUdW5lcy5wb3AoKSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkVHVuZXMuc3BsaWNlKHRoaXMubGFzdFJlbW92ZWRbMF0sIDAsIHRoaXMubGFzdFJlbW92ZWRbMV0pO1xuICAgICAgICAgICAgdGhpcy4kc2NvcGUubGFzdFJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbW92ZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0dW5lTGlzdEZhY3Rvcnk7XG59KTsgIiwicmVxdWlyZSgnc3JjL3R1bmUvdWkvZHJhdy1zY29yZScpO1xucmVxdWlyZSgnc3JjL2NvbW1vbi9kYXRhL2RhdGFiYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFxuICAgICRzY29wZSxcbiAgICBqVHVuZVxuKSB7XG5cbiAgICAkc2NvcGUubmV3VHVuZSA9IHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHt9XG4gICAgfTtcblxuICAgICRzY29wZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoalR1bmUuY3JlYXRlKCRzY29wZS5uZXdUdW5lKSkge1xuICAgICAgICAgICAgJHNjb3BlLiRkaXNtaXNzKCk7XG4gICAgICAgIH0gXG4gICAgfTtcbiAgICBcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuZ3VsYXIgPSByZXF1aXJlKCdhbmd1bGFyJyk7XG5yZXF1aXJlKCdzcmMvdHVuZS91aS9kcmF3LXNjb3JlJyk7XG5yZXF1aXJlKCdzcmMvdHVuZS91aS9wZXJmb3JtYW5jZS1yYXRlcicpO1xucmVxdWlyZSgnc3JjL2NvbW1vbi91aS9tb2RhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoXG4gICAgJHNjb3BlLCBcbiAgICBqTW9kYWxzXG4pIHtcblxuICAgICRzY29wZS50dW5lID0gJHNjb3BlLmFjdGl2ZVR1bmU7XG4gICAgJHNjb3BlLnR1bmUuZHVtbXlTdGFuZGFyZCA9IC0xO1xuICAgICRzY29wZS5lZGl0aW5nQWJjID0gZmFsc2U7XG4gICAgJHNjb3BlLmlzTmV3QWJjID0gZmFsc2U7XG5cbiAgICB2YXIgb2xkQXJyYW5nZW1lbnRWYWx1ZSxcbiAgICAgICAgYXJyYW5nZW1lbnRDb25maXJtO1xuXG4gICAgJHNjb3BlLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZWRyYXdTY29yZSkge1xuXG4gICAgICAgIGlmKCRzY29wZS50dW5lLnVwZGF0ZSh7XG4gICAgICAgICAgICBwZXJmb3JtYW5jZTogJHNjb3BlLnR1bmUucGVyZm9ybWFuY2UsXG4gICAgICAgICAgICBzZXRQdWJsaWNQZXJmb3JtYW5jZTogdHJ1ZSxcbiAgICAgICAgICAgIHVwZGF0ZVNjb3JlOiByZWRyYXdTY29yZVxuICAgICAgICB9KS5wcmFjdGljZWQpIHtcbiAgICAgICAgICAgICRzY29wZS4kZGlzbWlzcygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS5lZGl0QWJjID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkc2NvcGUuZWRpdGFibGVTY29yZUdlbmVyYXRvciA9IGFuZ3VsYXIuY29weSgkc2NvcGUudHVuZS5zY29yZUdlbmVyYXRvcik7ICBcbiAgICAgICAgJHNjb3BlLmVkaXRpbmdBYmMgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuaXNOZXdBYmMgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLm5ld0FiYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHNjb3BlLmVkaXRhYmxlU2NvcmVHZW5lcmF0b3IgPSBhbmd1bGFyLmNvcHkoJHNjb3BlLnR1bmUuc2NvcmVHZW5lcmF0b3IpOyAgXG4gICAgICAgICRzY29wZS5lZGl0YWJsZVNjb3JlR2VuZXJhdG9yLmFycmFuZ2VtZW50LmFiYyA9ICcnOyBcbiAgICAgICAgJHNjb3BlLmVkaXRpbmdBYmMgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuaXNOZXdBYmMgPSB0cnVlO1xuICAgIH07XG5cbiAgICAkc2NvcGUudXBkYXRlQXJyYW5nZW1lbnQgPSBmdW5jdGlvbiAob2xkVmFsdWUpIHtcbiAgICAgICAgb2xkQXJyYW5nZW1lbnRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgICAgICBhcnJhbmdlbWVudENvbmZpcm0gPSBqTW9kYWxzLm9wZW4oJ2FycmFuZ2VtZW50Q29uZmlybScsICRzY29wZSk7XG4gICAgfTtcblxuICAgICRzY29wZS5zYXZlVGhpc0FiYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHNjb3BlLnR1bmUuYXJyYW5nZW1lbnQuYWJjID0gZWRpdGVkQWJjO1xuICAgICAgICBlZGl0ZWRBYmMgPSBudWxsO1xuICAgICAgICAkc2NvcGUudHVuZS51cGRhdGUoe1xuICAgICAgICAgICAgdXBkYXRlU2NvcmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGFiY0NvbmZpcm0uZGlzbWlzcygpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuc2F2ZU5ld0FiYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0FycmFuZ2VtZW50ID0gYW5ndWxhci5leHRlbmQoe30sICRzY29wZS50dW5lLmFycmFuZ2VtZW50KTtcbiAgICAgICAgbmV3QXJyYW5nZW1lbnQuYWJjID0gZWRpdGVkQWJjO1xuICAgICAgICBlZGl0ZWRBYmMgPSBudWxsO1xuICAgICAgICAkc2NvcGUudHVuZS51cGRhdGUoe1xuICAgICAgICAgICAgYXJyYW5nZW1lbnQ6IG5ld0FycmFuZ2VtZW50LFxuICAgICAgICAgICAgdXNlQXJyYW5nZW1lbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGFiY0NvbmZpcm0gJiYgYWJjQ29uZmlybS5kaXNtaXNzKCk7XG4gICAgfTtcblxuICAgIHZhciBlZGl0ZWRBYmMsXG4gICAgICAgIGFiY0NvbmZpcm07XG5cbiAgICAkc2NvcGUuc2F2ZUFiY0RpYWxvZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBcbiAgICAgICAgZWRpdGVkQWJjID0gJHNjb3BlLmVkaXRhYmxlU2NvcmVHZW5lcmF0b3IuYXJyYW5nZW1lbnQuYWJjO1xuICAgICAgICBcbiAgICAgICAgJHNjb3BlLmVkaXRpbmdBYmMgPSBmYWxzZTtcbiAgICAgICAgaWYgKCRzY29wZS5pc05ld0FiYykge1xuICAgICAgICAgICAgJHNjb3BlLnNhdmVOZXdBYmMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFiY0NvbmZpcm0gPSBqTW9kYWxzLm9wZW4oJ2FiY0NvbmZpcm0nLCAkc2NvcGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICRzY29wZS5jYW5jZWxBYmNFZGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAkc2NvcGUuZWRpdGluZ0FiYyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAkc2NvcGUuYWx0ZXJBcnJhbmdlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHNjb3BlLnR1bmUudXBkYXRlKHtcbiAgICAgICAgICAgIHVwZGF0ZVNjb3JlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBhcnJhbmdlbWVudENvbmZpcm0uZGlzbWlzcygpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuY2FuY2VsQXJyYW5nZW1lbnRFZGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhbmd1bGFyLmV4dGVuZCgkc2NvcGUudHVuZS5hcnJhbmdlbWVudCwgb2xkQXJyYW5nZW1lbnRWYWx1ZSk7XG4gICAgICAgIG9sZEFycmFuZ2VtZW50VmFsdWUgPSBudWxsO1xuICAgICAgICBhcnJhbmdlbWVudENvbmZpcm0uZGlzbWlzcygpO1xuICAgIH07XG5cbiAgICAkc2NvcGUuc2F2ZU5ld0FycmFuZ2VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3QXJyYW5nZW1lbnQgPSBhbmd1bGFyLmV4dGVuZCh7fSwgJHNjb3BlLnR1bmUuYXJyYW5nZW1lbnQpO1xuICAgICAgICBhbmd1bGFyLmV4dGVuZCgkc2NvcGUudHVuZS5hcnJhbmdlbWVudCwgb2xkQXJyYW5nZW1lbnRWYWx1ZSk7XG4gICAgICAgIG9sZEFycmFuZ2VtZW50VmFsdWUgPSBudWxsO1xuICAgICAgICAkc2NvcGUudHVuZS51cGRhdGUoe1xuICAgICAgICAgICAgYXJyYW5nZW1lbnQ6IG5ld0FycmFuZ2VtZW50LFxuICAgICAgICAgICAgdXNlQXJyYW5nZW1lbnQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGFycmFuZ2VtZW50Q29uZmlybS5kaXNtaXNzKCk7XG4gICAgfTtcblxuXG4gICAgJHNjb3BlLnNhdmVBYmNUb1BlcmZvcm1hbmNlID0gZnVuY3Rpb24gKG5ld1BlcmZvcm1hbmNlKSB7XG4gICAgICAgIGlmIChuZXdQZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgJHNjb3BlLnR1bmUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgICAgICAgICAgICBkdW1teTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXJyYW5nZW1lbnQ6ICRzY29wZS50dW5lLmFycmFuZ2VtZW50Ll9pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdHJ1bWVudDogJHNjb3BlLnR1bmUucGVyZm9ybWFuY2UuaW5zdHJ1bWVudFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0UHVibGljUGVyZm9ybWFuY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnR1bmUucGVyZm9ybWFuY2UuYXJyYW5nZW1lbnQgPSAkc2NvcGUudHVuZS5hcnJhbmdlbWVudC5faWQ7XG4gICAgICAgICAgICAkc2NvcGUudHVuZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgJHNjb3BlLmFiY1NhdmVQZW5kaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgICRzY29wZS5yZXZlcnRBYmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRzY29wZS50dW5lLnJlc2V0QXJyYW5nZW1lbnQoKTtcbiAgICAgICAgJHNjb3BlLmFiY1NhdmVQZW5kaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgICRzY29wZS5hYmNTYXZlUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgJHNjb3BlLm5leHRBYmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJhbmdlbWVudHMgPSAkc2NvcGUudHVuZS50dW5lLmFycmFuZ2VtZW50cztcbiAgICAgICAgJHNjb3BlLnR1bmUubmV4dEFycmFuZ2VtZW50KCk7XG4gICAgICAgIC8vICRzY29wZS50dW5lLmFycmFuZ2VtZW50ID0gYXJyYW5nZW1lbnRzWyhhcnJhbmdlbWVudHMuaW5kZXhPZigkc2NvcGUudHVuZS5hcnJhbmdlbWVudCkgKyAxKSAlIGFycmFuZ2VtZW50cy5sZW5ndGhdO1xuICAgICAgICAkc2NvcGUuYWJjU2F2ZVBlbmRpbmcgPSAoJHNjb3BlLnR1bmUuYXJyYW5nZW1lbnQuX2lkICE9PSAkc2NvcGUudHVuZS5wZXJmb3JtYW5jZS5hcnJhbmdlbWVudCk7XG4gICAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdzcmMvY29tbW9uL21vZHVsZScpO1xuXG52YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKSxcbiAgICB0dW5lTW9kdWxlID0gYW5ndWxhci5tb2R1bGUoJ2puci50dW5lJywgWydqbnIuY29tbW9uJ10pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR1bmVNb2R1bGVcbiAgICAuY29udHJvbGxlcigndHVuZVZpZXdlcicsIHJlcXVpcmUoJ3NyYy90dW5lL2NvbnRyb2xsZXJzL3R1bmUtdmlld2VyJykpXG4gICAgLmNvbnRyb2xsZXIoJ2FkZFR1bmUnLCByZXF1aXJlKCdzcmMvdHVuZS9jb250cm9sbGVycy9hZGQtdHVuZScpKVxuICAgIC5maWx0ZXIoJ3R1bmVTdGF0U3VtbWFyeScsIHJlcXVpcmUoJ3NyYy90dW5lL3VpL3R1bmUtc3RhdC1zdW1tYXJ5JykpOyIsInZhciBzY2FsZSA9ICdjZGVmZ2FiJyxcbiAgICByb290cyA9IFtcbiAgICAgICAgJ0MnLCAnRGInLCAnRCcsICdFYicsICdFJywgJ0YnLCAnR2InLCAnRycsICdBYicsICdBJywgJ0JiJywgJ0InLCBcbiAgICAgICAgJ0MnLCAnQyMnLCAnRCcsICdEIycsICdFJywgJ0YnLCAnRiMnLCAnRycsICdHIycsICdBJywgJ0EjJywgJ0InXG4gICAgXSwgXG4gICAgZXF1aXZhbGVudFJvb3RzID0ge1xuICAgICAgICAnQSMnOiAnQmInLFxuICAgICAgICAnRyMnOiAnQWInLFxuICAgICAgICAnQyMnOiAnRGInLFxuICAgICAgICAnRCMnOiAnRWInLFxuICAgICAgICAnR2InOiAnRiMnLFxuICAgICAgICAnRmInOiAnRScsXG4gICAgICAgICdDYic6ICdCJyxcbiAgICAgICAgJ0IjJzogJ0MnLFxuICAgICAgICAnRSMnOiAnRidcbiAgICB9LFxuICAgIG1vZGVzID0gW1xuICAgICAgICAnbWFqJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAnZG9yJyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAncGhyJyxcbiAgICAgICAgJ2x5ZCcsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgJ21peCcsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgJ21pbicsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgJ2xvYydcbiAgICBdLFxuICAgIG1ham9yS2V5U2lnbmF0dXJlcyA9IHtcbiAgICAgICAgRGI6IC01LFxuICAgICAgICBBYjogLTQsXG4gICAgICAgIEViOiAtMyxcbiAgICAgICAgQmI6IC0yLFxuICAgICAgICBGOiAtMSxcbiAgICAgICAgQzogMCxcbiAgICAgICAgRzogMSxcbiAgICAgICAgRDogMixcbiAgICAgICAgQTogMyxcbiAgICAgICAgRTogNCxcbiAgICAgICAgQjogNSxcbiAgICAgICAgJ0YjJzogNlxuICAgIH0sXG5cbiAgICBmdWxsTm90ZVJYID0gLyg/OlxcPXxffFxcXik/W2EtZ10oPzosfFxcJykqL2dpLFxuICAgIGFjY2lkZW50YWxzUlggPSAvXFw9fF98XFxeLyxcbiAgICBsb3dOb3RlUlggPSAvW0EtR10vLFxuICAgIFxuICAgIGV4dHJhY3RlZE5vdGVzQ2FjaGUgPSB7fSxcblxuICAgIF9nZXRIaWdoZXN0T3JMb3dlc3RPZlBhaXIgPSBmdW5jdGlvbiAobm90ZTEsIG5vdGUyLCBoaWdoZXN0KSB7XG4gICAgICAgIFxuICAgICAgICAvL1N0YXJ0IGJ5IGlkZW50aWZ5aW5nIHRoZSBsb3dlc3Qgbm90ZVxuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGFyZSBvY3RhdmVzXG4gICAgICAgIHZhciByZXN1bHQgPSBub3RlMVsxXSA8IG5vdGUyWzFdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5vdGUxIDpcbiAgICAgICAgICAgICAgICAgICAgbm90ZTFbMV0gPiBub3RlMlsxXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbm90ZTIgOlxuICAgICAgICAgICAgICAgICAgICAvL2NvbXBhcmUgcG9zaXRpb24gaW4gc2NhbGVcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUuaW5kZXhPZihub3RlMVswXSkgPCBzY2FsZS5pbmRleE9mKG5vdGUyWzBdKSAgID8gbm90ZTEgOlxuICAgICAgICAgICAgICAgICAgICBzY2FsZS5pbmRleE9mKG5vdGUxWzBdKSA+IHNjYWxlLmluZGV4T2Yobm90ZTJbMF0pICAgPyBub3RlMiA6XG4gICAgICAgICAgICAgICAgICAgIC8vY29tcGFyZSBmbGF0bmVzc1xuICAgICAgICAgICAgICAgICAgICBub3RlMVsyXSA9PT0gJ18nID8gbm90ZTEgOiBcbiAgICAgICAgICAgICAgICAgICAgbm90ZTJbMl0gPT09ICdfJyA/IG5vdGUyIDpcbiAgICAgICAgICAgICAgICAgICAgLy9jb21wYXJlIG5hdHVyYWxuZXNzXG4gICAgICAgICAgICAgICAgICAgIG5vdGUxWzJdID09PSAnPScgPyBub3RlMSA6XG4gICAgICAgICAgICAgICAgICAgIG5vdGUyWzJdID09PSAnPScgPyBub3RlMiA6XG4gICAgICAgICAgICAgICAgICAgIC8vY29tcGFyZSBub3QgYmVpbmcgc2hhcnBcbiAgICAgICAgICAgICAgICAgICAgIW5vdGUxWzJdICAgICAgICA/IG5vdGUxIDpcbiAgICAgICAgICAgICAgICAgICAgIW5vdGUyWzJdICAgICAgICA/IG5vdGUyIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZ2V0IGhlcmUgYm90aCBub3RlcyBhcmUgdGhlIHNhbWUgbm90ZSBzaGFycGVuZWQgaW4gdGhlIHNhbWUgb2N0dmUgc28gZG9lc24ndCBtYXR0ZXIgd2hpY2ggd2UgcmV0dXJuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGUxO1xuICAgICAgICBcbiAgICAgICAgLy8gaWYgbG9va2luZyBmb3IgaGlnaGVzdCByZXR1cm4gdGhlIG9uZSB3ZSBkaWRuJ3QgaWRlbnRpZnkgYWJvdmUgICAgXG4gICAgICAgIGlmIChoaWdoZXN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IG5vdGUxID8gbm90ZTIgOiBub3RlMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfZXh0cmFjdE5vdGVzID0gZnVuY3Rpb24gKGFiYykge1xuXG4gICAgICAgIGlmIChleHRyYWN0ZWROb3Rlc0NhY2hlW2FiY10pIHtcbiAgICAgICAgICAgIHJldHVybiBleHRyYWN0ZWROb3Rlc0NhY2hlW2FiY107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm90ZXMgPSBbXTtcblxuICAgICAgICBhYmMucmVwbGFjZShmdWxsTm90ZVJYLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgICAgICAgIG5vdGVzLnB1c2goX2dldE5vdGVDb29yZHMoJDApKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBleHRyYWN0ZWROb3Rlc0NhY2hlW2FiY10gPSBub3RlcztcbiAgICB9LFxuXG4gICAgX2dldEhpZ2hlc3RPckxvd2VzdEluQWJjID0gZnVuY3Rpb24gKGFiYywgaGlnaGVzdCkge1xuICAgICAgICB2YXIgbm90ZXMgPSBfZXh0cmFjdE5vdGVzKGFiYyksXG4gICAgICAgICAgICBjdXJyZW50RXh0cmVtZSA9IG5vdGVzWzBdO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSAxLCBubCA9IG5vdGVzLmxlbmd0aDsgbjxubDsgbisrKSB7XG4gICAgICAgICAgICBjdXJyZW50RXh0cmVtZSA9IF9nZXRIaWdoZXN0T3JMb3dlc3RPZlBhaXIoY3VycmVudEV4dHJlbWUsIG5vdGVzW25dLCBoaWdoZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfZ2V0Tm90ZUZyb21Db29yZHMoY3VycmVudEV4dHJlbWUpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gX2dldER1cmF0aW9uID0gZnVuY3Rpb24gKGFiY0ZyYWdtZW50KSB7XG4gICAgICAgIFxuICAgIC8vICAgICB2YXIgZHVyYXRpb24gPSAwO1xuICAgIC8vIH0sXG5cbiAgICBfZ2V0RGlyZWN0aW9uT2ZUcmFuc3Bvc2l0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgaW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA+IDAgPyAxIDogLTE7ICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsIDwgNSA/IDE6IC0xO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXROb3RlQ29vcmRzID0gZnVuY3Rpb24gKG5vdGUpIHtcbiAgICAgICAgdmFyIGFjY2lkZW50YWw7XG4gICAgICAgIGlmIChhY2NpZGVudGFsc1JYLnRlc3Qobm90ZS5jaGFyQXQoMCkpKSB7XG4gICAgICAgICAgICBhY2NpZGVudGFsID0gbm90ZS5jaGFyQXQoMCk7XG4gICAgICAgICAgICBub3RlID0gbm90ZS5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd05vdGVSWC50ZXN0KG5vdGUuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtub3RlLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpLCAxIC0gbm90ZS5sZW5ndGgsIGFjY2lkZW50YWxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtub3RlLmNoYXJBdCgwKSwgbm90ZS5sZW5ndGgsIGFjY2lkZW50YWxdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXROb3RlRnJvbUNvb3JkcyA9IGZ1bmN0aW9uIChub3RlKSB7XG4gICAgICAgIHZhciBub3RlU3RyaW5nO1xuXG4gICAgICAgIGlmIChub3RlWzFdIDwgMSkge1xuICAgICAgICAgICAgbm90ZVN0cmluZyA9ICBub3RlWzBdLnRvVXBwZXJDYXNlKCkgKyBBcnJheSgxIC0gbm90ZVsxXSkuam9pbignLCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm90ZVN0cmluZyA9ICBub3RlWzBdICsgQXJyYXkobm90ZVsxXSkuam9pbignXFwnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm90ZVsyXSkge1xuICAgICAgICAgICAgbm90ZVN0cmluZyA9IG5vdGVbMl0gKyBub3RlU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RlU3RyaW5nO1xuICAgIH0sXG5cbiAgICBfa2VlcEluTGltaXRzID0gZnVuY3Rpb24gKG5vdGUsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgICAgICAgXG4gICAgICAgIGlmIChsb3dlckJvdW5kKSB7XG4gICAgICAgICAgICBsb3dlckJvdW5kID0gX2dldE5vdGVDb29yZHMobG93ZXJCb3VuZCk7XG4gICAgICAgICAgICBpZiAobG93ZXJCb3VuZFsxXSA+PSBub3RlWzFdKSB7XG4gICAgICAgICAgICAgICAgbm90ZVsxXSA9IGxvd2VyQm91bmRbMV07XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlLmluZGV4T2Yobm90ZVswXSkgPCBzY2FsZS5pbmRleE9mKGxvd2VyQm91bmRbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVbMV0rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdXBwZXJCb3VuZCA9IF9nZXROb3RlQ29vcmRzKHVwcGVyQm91bmQpO1xuICAgICAgICAgICAgaWYgKHVwcGVyQm91bmRbMV0gPD0gbm90ZVsxXSkge1xuICAgICAgICAgICAgICAgIG5vdGVbMV0gPSB1cHBlckJvdW5kWzFdO1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZS5pbmRleE9mKG5vdGVbMF0pID4gc2NhbGUuaW5kZXhPZih1cHBlckJvdW5kWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBub3RlWzFdLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vdGU7XG4gICAgfSxcblxuICAgIHRyYW5zcG9zZSA9IGZ1bmN0aW9uIChhYmNEZWYsIG9wdHMpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gc2NhbGUuaW5kZXhPZihvcHRzLm5ld1Jvb3Quc3Vic3RyKDAsIDEpLnRvTG93ZXJDYXNlKCkpIC0gc2NhbGUuaW5kZXhPZihhYmNEZWYucm9vdC5zdWJzdHIoMCwgMSkudG9Mb3dlckNhc2UoKSksXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBfZ2V0RGlyZWN0aW9uT2ZUcmFuc3Bvc2l0aW9uKG9wdHMuZGlyZWN0aW9uLCBpbnRlcnZhbCksXG4gICAgICAgICAgICBleHRyYU9jdGF2ZXMgPSBvcHRzLmRpcmVjdGlvbiA/ICgob3B0cy5kaXJlY3Rpb24gLyBkaXJlY3Rpb24pIC0gMSkgOiAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgICAgIGludGVydmFsID0gLWludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoaW50ZXJ2YWwgPD0gMCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgKz0gNzsgIFxuICAgICAgICB9XG4gICAgICAgICBcbiAgICAgICAgaW50ZXJ2YWwgKz0gZXh0cmFPY3RhdmVzICogNztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhYmNEZWYuYWJjLnJlcGxhY2UoZnVsbE5vdGVSWCwgZnVuY3Rpb24gKG5vdGUpIHtcbiAgICAgICAgICAgIG5vdGUgPSBfZ2V0Tm90ZUNvb3Jkcyhub3RlKTtcblxuICAgICAgICAgICAgdmFyIGludGVydmFsV2l0aGluT2N0YXZlID0gKGludGVydmFsICogZGlyZWN0aW9uKSAlIDcsXG4gICAgICAgICAgICAgICAgbmV3Tm90ZUluZGV4ID0gc2NhbGUuaW5kZXhPZihub3RlWzBdKSArIGludGVydmFsV2l0aGluT2N0YXZlO1xuXG4gICAgICAgICAgICBub3RlWzBdID0gc2NhbGVbKG5ld05vdGVJbmRleCArIDcpICUgN107XG5cbiAgICAgICAgICAgIG5vdGVbMV0gKz0gZGlyZWN0aW9uICogTWF0aC5mbG9vcihpbnRlcnZhbCAvIDcpO1xuXG4gICAgICAgICAgICBpZiAobmV3Tm90ZUluZGV4IDwgMCB8fCBuZXdOb3RlSW5kZXggPiA2KSB7XG4gICAgICAgICAgICAgICAgbm90ZVsxXSArPSBkaXJlY3Rpb247ICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm90ZSA9IF9rZWVwSW5MaW1pdHMobm90ZSwgb3B0cy5sb3dlckxpbWl0LCBvcHRzLnVwcGVyTGltaXQpO1xuICAgICAgICAgICAgcmV0dXJuIF9nZXROb3RlRnJvbUNvb3Jkcyhub3RlKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvLyBnZXRQcm9wcyA9IGZ1bmN0aW9uIChhYmNEZWYpIHtcblxuICAgIC8vICAgICByZXR1cm4ge1xuICAgIC8vICAgICAgICAgbG93ZXN0OiBnZXRMb3dlc3ROb3RlKGFiY0RlZi5hYmMsIGdldFNoYXJwc0FuZEZsYXRzKGFiY0RlZi5yb290LCBhYmNEZWYubW9kZSkpLFxuICAgIC8vICAgICAgICAgaGlnaGVzdDogZ2V0SGlnaGVzdE5vdGUoYWJjRGVmLmFiYywgZ2V0U2hhcnBzQW5kRmxhdHMoYWJjRGVmLnJvb3QsIGFiY0RlZi5tb2RlKSksXG4gICAgLy8gICAgICAgICAvLyBmaXJzdFxuICAgIC8vICAgICAgICAgLy8gbGFzdFxuICAgIC8vICAgICAgICAgLy8gbGVhZEluTGVuZ3RoXG4gICAgLy8gICAgICAgICAvLyBsZWFkSW5cbiAgICAvLyAgICAgICAgIGtleVNpZ25hdHVyZTogZ2V0U2hhcnBzQW5kRmxhdHMoYWJjRGVmLnJvb3QsIGFiY0RlZi5tb2RlKVxuICAgIC8vICAgICB9O1xuICAgIC8vIH0sXG5cbiAgICBnZXRTaGFycHNBbmRGbGF0cyA9IGZ1bmN0aW9uIChyb290LCBtb2RlKSB7XG5cbiAgICAgICAgdmFyIGVxdWl2YWxlbnRNYWpvckluZGV4ID0gKHJvb3RzLmxlbmd0aCArIHJvb3RzLmluZGV4T2Yocm9vdCkgLSBtb2Rlcy5pbmRleE9mKG1vZGUpKSAlIHJvb3RzLmxlbmd0aCxcbiAgICAgICAgICAgIGVxdWl2YWxlbnRNYWpvciA9IHJvb3RzW2VxdWl2YWxlbnRNYWpvckluZGV4XTtcblxuICAgICAgICBlcXVpdmFsZW50TWFqb3IgPSBlcXVpdmFsZW50Um9vdHNbZXF1aXZhbGVudE1ham9yXSB8fCBlcXVpdmFsZW50TWFqb3I7XG5cbiAgICAgICAgcmV0dXJuIG1ham9yS2V5U2lnbmF0dXJlc1tlcXVpdmFsZW50TWFqb3JdO1xuICAgIH0sXG5cbiAgICBnZXRMb3dlc3ROb3RlID0gZnVuY3Rpb24gKGFiYykge1xuICAgICAgICByZXR1cm4gX2dldEhpZ2hlc3RPckxvd2VzdEluQWJjKGFiYywgZmFsc2UpO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0SGlnaGVzdE5vdGUgPSBmdW5jdGlvbiAoYWJjKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SGlnaGVzdE9yTG93ZXN0SW5BYmMoYWJjLCB0cnVlKTtcbiAgICB9LFxuICAgIGNsZWFyRXh0cmFjdGVkTm90ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGV4dHJhY3RlZE5vdGVzQ2FjaGUgPSB7fTtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0cmFuc3Bvc2U6IHRyYW5zcG9zZSxcbiAgICBleHRyYWN0Tm90ZXM6IF9leHRyYWN0Tm90ZXMsXG4gICAgLy8gZ2V0UHJvcHM6IGdldFByb3BzLFxuICAgIGdldFNoYXJwc0FuZEZsYXRzOiBnZXRTaGFycHNBbmRGbGF0cyxcbiAgICBnZXRMb3dlc3ROb3RlOiBnZXRMb3dlc3ROb3RlLFxuICAgIGdldEhpZ2hlc3ROb3RlOiBnZXRIaWdoZXN0Tm90ZSxcbiAgICBjbGVhckV4dHJhY3RlZE5vdGVzOiBjbGVhckV4dHJhY3RlZE5vdGVzXG59O1xuIiwicmVxdWlyZSgnYW5ndWxhcicpLm1vZHVsZSgnam5yLnR1bmUnKS5zZXJ2aWNlKCdqU2NvcmVTbmlwcGV0cycsIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBpbmRleGVkREIgPSB3aW5kb3cuaW5kZXhlZERCIHx8IG51bGwsXG4gICAgICAgIHNuaXBwZXRzREIgPSB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbiA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBpbmRleGVkREIub3Blbignc2NvcmUtc25pcHBldHMnLCB2ZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBzbmlwcGV0c0RCLmRiID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBzb21lIG1vcmUgc3R1ZmYgaW4gYSBtaW51dGVcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIG9ubHkgY3JlYXRlIE9iamVjdCBzdG9yZXMgaW4gYSB2ZXJzaW9uY2hhbmdlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQSB2ZXJzaW9uY2hhbmdlIHRyYW5zYWN0aW9uIGlzIHN0YXJ0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQudHJhbnNhY3Rpb24ub25lcnJvciA9IHNuaXBwZXRzREIub25lcnJvcjtcblxuICAgICAgICAgICAgICAgICAgICBpZihkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdzbmlwcGV0cycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSgnc25pcHBldHMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdzbmlwcGV0cycsIHtrZXlQYXRoOiAnYXJyYW5nZW1lbnRJZCd9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gc25pcHBldHNEQi5vbmVycm9yO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbihhcnJhbmdlbWVudCwgc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNuaXBwZXRzREIuaW5Qcm9ncmVzc1thcnJhbmdlbWVudC5faWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHNuaXBwZXRzREIuZGI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFucyA9IGRiLnRyYW5zYWN0aW9uKFsnc25pcHBldHMnXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSgnc25pcHBldHMnKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXRzREIuaW5Qcm9ncmVzc1thcnJhbmdlbWVudC5faWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBzdG9yZS5wdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZW1lbnRJZDogYXJyYW5nZW1lbnQuX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHNjb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXJlbmRlciBhbGwgdGhlIHRvZG8nc1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNuaXBwZXRzREIuaW5Qcm9ncmVzc1thcnJhbmdlbWVudC5faWRdO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEJ5SWQ6IGZ1bmN0aW9uKGlkLCBzdWNjZXNzLCBmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRiID0gc25pcHBldHNEQi5kYjtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnMgPSBkYi50cmFuc2FjdGlvbihbJ3NuaXBwZXRzJ10sICdyZWFkd3JpdGUnKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZSgnc25pcHBldHMnKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gc3RvcmUuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmYWlsdXJlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluUHJvZ3Jlc3M6IHt9XG4gICAgICAgIH07XG5cbiAgICBpZiAoaW5kZXhlZERCKSB7XG4gICAgICAgIHNuaXBwZXRzREIub3BlbigpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNhY2hlU2NvcmU6IGZ1bmN0aW9uIChhcnJhbmdlbWVudCwgc2NvcmUpIHtcbiAgICAgICAgICAgIHNuaXBwZXRzREIuaW5zZXJ0KGFycmFuZ2VtZW50LCBzY29yZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENhY2hlZFNjb3JlOiBmdW5jdGlvbiAoYXJyYW5nZW1lbnQsIGV4aXN0c0NhbGxiYWNrLCBub3RFeGlzdHNDYWxsYmFjaykge1xuICAgICAgICAgICAgc25pcHBldHNEQi5nZXRCeUlkKGFycmFuZ2VtZW50Ll9pZCwgZXhpc3RzQ2FsbGJhY2ssIG5vdEV4aXN0c0NhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG59KTsiLCJ2YXIgYW5ndWxhciA9IHJlcXVpcmUoJ2FuZ3VsYXInKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbi8vIHJlcXVpcmUoJ3NyYy90dW5lL3NlcnZpY2VzL2FiYy1wYXJzZXInKTtcblxucmVxdWlyZSgnYW5ndWxhcicpLm1vZHVsZSgnam5yLnR1bmUnKS5mYWN0b3J5KCdqVHVuZScsIGZ1bmN0aW9uKFxuICAgICRyb3V0ZVBhcmFtcyxcbiAgICAkcm9vdFNjb3BlLFxuICAgIGpEYXRhYmFzZVxuKSB7XG5cbiAgICB2YXIgZGF5TGVuZ3RoID0gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xuXG4gICAgdmFyIFR1bmUgPSBmdW5jdGlvbih0dW5lLCBvcHRzKSB7XG4gICAgICAgIHRoaXMudHVuZSA9IHR1bmU7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH07XG5cbiAgICBUdW5lLmV4dHJhY3QgPSBmdW5jdGlvbih0dW5lLCBvcHRzLCBpbnN0YW5jZU9wdHMpIHtcbiAgICAgICAgdmFyIGpUdW5lcyA9IFtdLFxuICAgICAgICAgICAgZmlsdGVyO1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBpbnN0YW5jZU9wdHMgPSBpbnN0YW5jZU9wdHMgfHwge307XG5cbiAgICAgICAgaWYgKG9wdHMucGVyZm9ybWFuY2VGaWx0ZXIpIHtcbiAgICAgICAgICAgIGpUdW5lcyA9IF8uZmlsdGVyKHR1bmUucGVyZm9ybWFuY2VzLCBvcHRzLnBlcmZvcm1hbmNlRmlsdGVyKS5tYXAoZnVuY3Rpb24ocGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1bmUodHVuZSwgYW5ndWxhci5leHRlbmQoe30sIGluc3RhbmNlT3B0cywge1xuICAgICAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZTogcGVyZm9ybWFuY2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghalR1bmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgalR1bmVzID0gW25ldyBUdW5lKHR1bmUsIGFuZ3VsYXIuZXh0ZW5kKHt9LCBpbnN0YW5jZU9wdHMpKV07XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChvcHRzLmxpc3QpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG9wdHMubGlzdCwgalR1bmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqVHVuZXM7XG5cbiAgICB9O1xuXG4gICAgVHVuZS5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgaWYgKCEoXG4gICAgICAgICAgICBkYXRhLm5hbWUgJiZcbiAgICAgICAgICAgIGRhdGEuYWJjICYmXG4gICAgICAgICAgICBkYXRhLnJvb3QgJiZcbiAgICAgICAgICAgIGRhdGEubWV0ZXIgJiZcbiAgICAgICAgICAgIGRhdGEubW9kZSAmJlxuICAgICAgICAgICAgZGF0YS5yaHl0aG1cbiAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBlcmZvcm1hbmNlLFxuICAgICAgICAgICAgbmV3VHVuZSA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IDAsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIGFycmFuZ2VtZW50czogW3tcbiAgICAgICAgICAgICAgICAgICAgYWJjOiBkYXRhLmFiYyxcbiAgICAgICAgICAgICAgICAgICAgaGlnaGVzdE5vdGU6ICcnLFxuICAgICAgICAgICAgICAgICAgICBsb3dlc3ROb3RlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudHM6ICcnLFxuICAgICAgICAgICAgICAgICAgICByb290OiBkYXRhLnJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcjogZGF0YS5hdXRob3IgfHwgJ3doZXJlc3JoeXMnLFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlTmFtZXM6IFtdLFxuICAgICAgICAgICAgICAgIG1ldGVyOiBkYXRhLm1ldGVyLFxuICAgICAgICAgICAgICAgIG1vZGU6IGRhdGEubW9kZSxcbiAgICAgICAgICAgICAgICByaHl0aG06IGRhdGEucmh5dGhtLFxuICAgICAgICAgICAgICAgIHJhdGluZzogZGF0YS5yYXRpbmcgfHwgLTEsXG4gICAgICAgICAgICAgICAgcG9wdWxhcml0eTogZGF0YS5wb3B1bGFyaXR5IHx8IC0xLFxuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlczogW10sXG4gICAgICAgICAgICAgICAgbm90ZXM6IGRhdGEubm90ZXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRhdGEucGVyZm9ybWFuY2UuaW5zdHJ1bWVudCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmQ6IGRhdGEucGVyZm9ybWFuY2Uuc3RhbmRhcmQgfHwgMCxcbiAgICAgICAgICAgICAgICBub3RlczogJycsXG4gICAgICAgICAgICAgICAgYmVzdDogZGF0YS5wZXJmb3JtYW5jZS5zdGFuZGFyZCB8fCAwLFxuICAgICAgICAgICAgICAgIGRpZmZpY3VsdHk6IGRhdGEucGVyZm9ybWFuY2UuZGlmZmljdWx0eSB8fCAoLTEpLFxuICAgICAgICAgICAgICAgIGxhc3RQcmFjdGljZWQ6IGRhdGEucGVyZm9ybWFuY2Uuc3RhbmRhcmQgPyBuZXcgRGF0ZSgpIDogbmV3IERhdGUoMCksXG4gICAgICAgICAgICAgICAgc3BlY2lhbDogISEgZGF0YS5wZXJmb3JtYW5jZS5zcGVjaWFsLFxuICAgICAgICAgICAgICAgIGluc3RydW1lbnQ6IGRhdGEucGVyZm9ybWFuY2UuaW5zdHJ1bWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpEYXRhYmFzZS5nZXRSZXNvdXJjZSgndHVuZXMnKS5zYXZlKG5ld1R1bmUsIGZ1bmN0aW9uKHR1bmUpIHtcbiAgICAgICAgICAgIGlmIChwZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLmFycmFuZ2VtZW50ID0gdHVuZS5hcnJhbmdlbWVudHNbMF0uX2lkO1xuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLnR1bmUgPSB0dW5lLl9pZDtcbiAgICAgICAgICAgICAgICB0dW5lLnBlcmZvcm1hbmNlcy5wdXNoKHBlcmZvcm1hbmNlKTtcbiAgICAgICAgICAgICAgICB0dW5lLiR1cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpEYXRhYmFzZS5nZXRUYWJsZSgndHVuZXMnKS5wdXNoKHR1bmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgVHVuZS5nZXRGb3JBcnJhbmdlbWVudCA9IGZ1bmN0aW9uKGFycmFuZ2VtZW50LCBpbnN0cnVtZW50KSB7XG4gICAgICAgIHZhciB0dW5lc1RhYmxlID0gakRhdGFiYXNlLmdldFRhYmxlKCd0dW5lcycpO1xuICAgICAgICB2YXIgdHVuZSA9IF8uZmluZFdoZXJlKHR1bmVzVGFibGUsIHtcbiAgICAgICAgICAgIF9pZDogYXJyYW5nZW1lbnQudHVuZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1bmUodHVuZSwge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IF8uZmluZFdoZXJlKHR1bmUucGVyZm9ybWFuY2VzLCB7XG4gICAgICAgICAgICAgICAgYXJyYW5nZW1lbnQ6IGFycmFuZ2VtZW50Ll9pZCxcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50OiBpbnN0cnVtZW50XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHVuZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMub3B0cy5zY29wZSkge1xuICAgICAgICAgICAgLy8gICAgIC8vIGlmICh0eXBlb2YgdGhpcy5vcHRzLnNjb3BlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIC8vICAgICAvLyAgICAgJHNjb3BlLnR1bmUgPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAgIC8vICAgICB0aGlzLiRzY29wZSA9ICRzY29wZTtcbiAgICAgICAgICAgIC8vICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMuc2NvcGUgPSB0aGlzLm9wdHMuc2NvcGU7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5zY29wZS50dW5lID0gdGhpcztcbiAgICAgICAgICAgIC8vICAgICAvLyB9ICBcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgdGhpcy5fYXNzaWduQXJyQW5kUGVyZigpO1xuICAgICAgICAgICAgdGhpcy5fc2V0TGFzdFByYWN0aWNlZERheXMoKTtcbiAgICAgICAgICAgIHRoaXMub3B0cy5tb2RpZmllciAmJiB0aGlzLm9wdHMubW9kaWZpZXIodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9hc3NpZ25BcnJBbmRQZXJmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0QXJyYW5nZW1lbnQgPSB0aGlzLnR1bmUuYXJyYW5nZW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5wZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybWFuY2UgPSB0aGlzLm9wdHMucGVyZm9ybWFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IF8uZmluZCh0aGlzLnR1bmUuYXJyYW5nZW1lbnRzLCBmdW5jdGlvbihhcnJhbmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYW5nZW1lbnQuX2lkID09PSB0aGF0LnBlcmZvcm1hbmNlLmFycmFuZ2VtZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICBkdW1teTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IGRlZmF1bHRBcnJhbmdlbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY29yZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVNjb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcmVHZW5lcmF0b3IgPSB7XG4gICAgICAgICAgICAgICAgYXJyYW5nZW1lbnQ6IHRoaXMuYXJyYW5nZW1lbnQsXG4gICAgICAgICAgICAgICAgbWV0ZXI6IHRoaXMudHVuZS5tZXRlcixcbiAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLnR1bmUubW9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0TGFzdFByYWN0aWNlZERheXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9ICgobmV3IERhdGUoKSkgLSAobmV3IERhdGUodGhpcy5wZXJmb3JtYW5jZS5sYXN0UHJhY3RpY2VkIHx8IDApKSk7XG4gICAgICAgICAgICB0aGlzLmRheXNTaW5jZUxhc3RQcmFjdGljZSA9ICtNYXRoLnJvdW5kKChtaWxsaXNlY29uZHMgLyBkYXlMZW5ndGgpLCAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGVyZm9ybWFuY2VOZWVkc1NhdmluZzogZnVuY3Rpb24ocGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15U3RhbmRhcmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKFsnaW5zdHJ1bWVudCcsICdkdW1teSddLmluZGV4T2Yoa2V5KSA9PT0gLTEgJiYgcGVyZm9ybWFuY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIF9wZXJmb3JtYW5jZUlzUmVhbDogZnVuY3Rpb24ocGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiAhcGVyZm9ybWFuY2UuZHVtbXk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZVBlcmZvcm1hbmNlOiBmdW5jdGlvbihwZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZSB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHVuZTogdGhpcy50dW5lLl9pZCxcbiAgICAgICAgICAgICAgICBpbnN0cnVtZW50OiAocGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2UuaW5zdHJ1bWVudCkgfHwgJHJvb3RTY29wZS5wYWdlU3RhdGUuaW5zdHJ1bWVudCxcbiAgICAgICAgICAgICAgICBzcGVjaWFsOiBwZXJmb3JtYW5jZS5zcGVjaWFsIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhc3RQcmFjdGljZWQ6IG5ldyBEYXRlKDApLFxuICAgICAgICAgICAgICAgIGRpZmZpY3VsdHk6IHBlcmZvcm1hbmNlLmRpZmZpY3VsdHkgfHwgLTEsXG4gICAgICAgICAgICAgICAgYmVzdDogMCxcbiAgICAgICAgICAgICAgICBub3RlczogJycsXG4gICAgICAgICAgICAgICAgc3RhbmRhcmQ6IDAsXG4gICAgICAgICAgICAgICAgYXJyYW5nZW1lbnQ6IHRoaXMuYXJyYW5nZW1lbnQuX2lkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVQZXJmb3JtYW5jZTogZnVuY3Rpb24ob3B0cykge1xuXG4gICAgICAgICAgICB2YXIgcHJhY3RpY2VkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UgPSBvcHRzLnBlcmZvcm1hbmNlIHx8IHRoaXMucGVyZm9ybWFuY2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVyZm9ybWFuY2VOZWVkc1NhdmluZyhwZXJmb3JtYW5jZSkpIHtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcGVyZm9ybWFuY2VJc1JlYWwocGVyZm9ybWFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlID0gdGhpcy5fY3JlYXRlUGVyZm9ybWFuY2UocGVyZm9ybWFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR1bmUucGVyZm9ybWFuY2VzLnB1c2gocGVyZm9ybWFuY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmR1bW15U3RhbmRhcmQgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kdW1teVN0YW5kYXJkID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2Uuc3BlY2lhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLnN0YW5kYXJkID0gdGhpcy5kdW1teVN0YW5kYXJkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmR1bW15U3RhbmRhcmQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubGFzdFByYWN0aWNlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldExhc3RQcmFjdGljZWREYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgndHVuZVByYWN0aWNlZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwcmFjdGljZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLmJlc3QgPSBNYXRoLm1heChwZXJmb3JtYW5jZS5iZXN0LCBwZXJmb3JtYW5jZS5zdGFuZGFyZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zZXRQdWJsaWNQZXJmb3JtYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJhY3RpY2VkO1xuICAgICAgICB9LFxuICAgICAgICBpc05ldzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50dW5lLnJhdGluZyA8IDA7IC8vIHx8IHR1bmUucG9wdWxhcml0eSA8IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0QXJyYW5nZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRlc3RJZCA9IHRoaXMucGVyZm9ybWFuY2UuYXJyYW5nZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFycmFuZ2VtZW50ID0gXy5maW5kKHRoaXMudHVuZS5hcnJhbmdlbWVudHMsIGZ1bmN0aW9uKGFycmFuZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmFuZ2VtZW50Ll9pZCA9PT0gdGVzdElkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFycmFuZ2VtZW50Q2hhbmdlUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY29yZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRBcnJhbmdlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmFycmFuZ2VtZW50ID0gdGhpcy50dW5lLmFycmFuZ2VtZW50c1sodGhpcy50dW5lLmFycmFuZ2VtZW50cy5pbmRleE9mKHRoaXMuYXJyYW5nZW1lbnQpICsgMSkgJSB0aGlzLnR1bmUuYXJyYW5nZW1lbnRzLmxlbmd0aF07XG4gICAgICAgICAgICB0aGlzLmFycmFuZ2VtZW50Q2hhbmdlUGVuZGluZyA9ICh0aGlzLmFycmFuZ2VtZW50Ll9pZCAhPT0gdGhpcy5wZXJmb3JtYW5jZS5hcnJhbmdlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjb3JlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG9sZFByb3BzID0gb3B0cy5vbGRQcm9wcyB8fCB7fSxcbiAgICAgICAgICAgICAgICBwcmFjdGljZWQgPSB0aGlzLl91cGRhdGVQZXJmb3JtYW5jZShvcHRzKTtcblxuICAgICAgICAgICAgaWYgKG9sZFByb3BzICYmIG9sZFByb3BzLnJhdGluZyA9PT0gLTEgJiYgIXRoaXMuaXNOZXcoKSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubmV3VHVuZUNvdW50LS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmFycmFuZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50dW5lLmFycmFuZ2VtZW50cy5wdXNoKG9wdHMuYXJyYW5nZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLmFycmFuZ2VtZW50Ll9pZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0cy5hcnJhbmdlbWVudC5faWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMuYXJyYW5nZW1lbnQudHVuZSA9IHRoaXMudHVuZS5faWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3luYyhmdW5jdGlvbihzYXZlZFR1bmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMudXNlQXJyYW5nZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU2NvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXJyYW5nZW1lbnQgPSBzYXZlZFR1bmUuYXJyYW5nZW1lbnRzW3NhdmVkVHVuZS5hcnJhbmdlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBlcmZvcm1hbmNlLmFycmFuZ2VtZW50ID0gdGhhdC5hcnJhbmdlbWVudC5faWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmFuZ2VtZW50Q2hhbmdlUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMuYXJyYW5nZW1lbnQgfHwgb3B0cy51cGRhdGVTY29yZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2NvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcmFjdGljZWQ6IHByYWN0aWNlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuICAgICAgICBfc3luYzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZUluZGV4ID0gdGhpcy50dW5lLnBlcmZvcm1hbmNlcy5pbmRleE9mKHRoaXMucGVyZm9ybWFuY2UpLFxuICAgICAgICAgICAgICAgIGFycmFuZ2VtZW50SW5kZXggPSB0aGlzLnR1bmUuYXJyYW5nZW1lbnRzLmluZGV4T2YodGhpcy5hcnJhbmdlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMudHVuZS4kdXBkYXRlKGZ1bmN0aW9uKHNhdmVkVHVuZSkge1xuICAgICAgICAgICAgICAgIHRoYXQucGVyZm9ybWFuY2UgPSB0aGF0LnR1bmUucGVyZm9ybWFuY2VzW3BlcmZvcm1hbmNlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoYXQuYXJyYW5nZW1lbnQgPSB0aGF0LnR1bmUuYXJyYW5nZW1lbnRzW2FycmFuZ2VtZW50SW5kZXhdO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHNhdmVkVHVuZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHJldHVybiBUdW5lO1xuXG59KTsiLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJ3NyYy90dW5lL3NlcnZpY2VzL3Njb3JlLXNuaXBwZXRzJyk7XG5cbnZhciBBQkNKUyA9IHJlcXVpcmUoJ2FiY2pzJyksXG4gICAgc25pcHBldHNTdG9yZTtcblxudmFyIFNjb3JlRHJhd2VyID0gZnVuY3Rpb24gKHNjb3JlR2VuZXJhdG9yLCBzbmlwcGV0T25seSwgZWwpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5zY29yZUdlbmVyYXRvciA9IHNjb3JlR2VuZXJhdG9yO1xuICAgIHRoaXMuc25pcHBldE9ubHkgPSBzbmlwcGV0T25seTtcbiAgICB0aGlzLmV4ZWMoKTtcbn07XG5cblNjb3JlRHJhd2VyLnByb3RvdHlwZSA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsLmh0bWwoJycpO1xuXG5cbiAgICAgICAgdGhpcy5hcnJhbmdlbWVudCA9IHRoaXMuc2NvcmVHZW5lcmF0b3IuYXJyYW5nZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFycmFuZ2VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFiYyA9IHRoaXMuYXJyYW5nZW1lbnQuYWJjO1xuICAgICAgICB0aGlzLmNvbmYgPSB7XG4gICAgICAgICAgICBzY2FsZTogMC42LFxuICAgICAgICAgICAgcGFkZGluZ3RvcDogMCxcbiAgICAgICAgICAgIHBhZGRpbmdib3R0b206IDAsXG4gICAgICAgICAgICBwYWRkaW5ncmlnaHQ6IDAsXG4gICAgICAgICAgICBwYWRkaW5nbGVmdDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIFxuXG4gICAgICAgIGlmICh0aGlzLnNuaXBwZXRPbmx5KSB7XG4gICAgICAgICAgICB0aGlzLmdldFNuaXBwZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2NvcmUoKTtcbiAgICAgICAgfSBcbiAgICB9LFxuXG4gICAgZ2V0U25pcHBldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnc2NvcmUtc25pcHBldCcpO1xuXG4gICAgICAgIHNuaXBwZXRzU3RvcmUuZ2V0Q2FjaGVkU2NvcmUodGhpcy5hcnJhbmdlbWVudCwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgc2VsZi5lbC5odG1sKG9iai5zY29yZSk7XG4gICAgICAgICAgICBzZWxmLmVsWzBdLnN0eWxlLndpZHRoID0gc2VsZi5lbC5maW5kKCdzdmcnKVswXS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgKyAncHgnO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmFiYyA9IHNlbGYuYWJjLnJlcGxhY2UoL15cXHwqOj8vLCAnJyk7XG4gICAgICAgICAgICBzZWxmLmFiYyA9IHNlbGYuYWJjLnNwbGl0KCd8Jyk7XG4gICAgICAgICAgICBzZWxmLmFiYyA9IHNlbGYuYWJjLnNsaWNlKDAsIChzZWxmLmFiY1swXS5sZW5ndGggPCA0ID8gNCA6IDMpKS5qb2luKCd8Jyk7XG4gICAgICAgICAgICBzZWxmLmNvbmYuc2NhbGUgPSAwLjU7XG4gICAgICAgICAgICBzZWxmLmNvbmYuc3RhZmZ3aWR0aCA9IDQ1MDtcbiAgICAgICAgICAgIHNlbGYucmVuZGVyU2NvcmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbmRlclNjb3JlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5hYmMgPSAnWDoxJyArXG4gICAgICAgIC8vJ1xcblQ6JyArIHNjb3JlR2VuZXJhdG9yLm5hbWUgKyBcbiAgICAgICAgJ1xcbk06JyArIHRoaXMuc2NvcmVHZW5lcmF0b3IubWV0ZXIgKyBcbiAgICAgICAgJ1xcbkw6MS84JyArIFxuICAgICAgICAvLydcXG5SOicgKyBzY29yZUdlbmVyYXRvci5yaHl0aG0gKyBcbiAgICAgICAgJ1xcbks6JyArIHRoaXMuYXJyYW5nZW1lbnQucm9vdCArIHRoaXMuc2NvcmVHZW5lcmF0b3IubW9kZSArIFxuICAgICAgICAnXFxuJyArIHRoaXMuYWJjO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgQUJDSlMucmVuZGVyQWJjKHNlbGYuZWxbMF0sIHNlbGYuYWJjLCB7fSwgc2VsZi5jb25mLCB7fSk7ICBcblxuICAgICAgICAgICAgaWYgKHNlbGYuc25pcHBldE9ubHkpIHtcbiAgICAgICAgICAgICAgICBzbmlwcGV0c1N0b3JlLmNhY2hlU2NvcmUoc2VsZi5hcnJhbmdlbWVudCwgc2VsZi5lbFswXS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgfSAgXG4gICAgICAgIH0sIDEwMCk7ICAgICAgICBcbiAgICB9XG5cbn07XG5cbnJlcXVpcmUoJ2FuZ3VsYXInKS5tb2R1bGUoJ2puci50dW5lJykuZGlyZWN0aXZlKCdqRHJhd1Njb3JlJywgZnVuY3Rpb24gKGpTY29yZVNuaXBwZXRzKSB7XG4gICAgc25pcHBldHNTdG9yZSA9IGpTY29yZVNuaXBwZXRzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsLCBhdHRycykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc25pcHBldE9ubHkgPSAhIWF0dHJzLnNuaXBwZXQ7XG5cbiAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCd0dW5lJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFNjb3JlRHJhd2VyKEpTT04ucGFyc2UodmFsdWUpLCBzbmlwcGV0T25seSwgZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnYW5ndWxhcicpLm1vZHVsZSgnam5yLnR1bmUnKS5kaXJlY3RpdmUoJ2pQZXJmb3JtYW5jZVJhdGVyJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb2xvdXJpbmdzID0gJ2RlZmF1bHQsZGFuZ2VyLHdhcm5pbmcsc3VjY2VzcyxpbmZvLHByaW1hcnknLnNwbGl0KCcsJyk7XG4gICAgcmV0dXJuIHtcbiAgICAvLyB0cmFuc2NsdWRlOiB0cnVlLFxuICAgICAgICBzY29wZTogdHJ1ZSxcbiAgICAgICAgdGVtcGxhdGVVcmw6ICcvc3JjL3R1bmUvdHBsL3BlcmZvcm1hbmNlLXJhdGVyLmh0bWwnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgcmF0ZWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJhdGVlID0gSlNPTi5wYXJzZShhdHRycy5yYXRlZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmF0ZWUgPSBzY29wZVthdHRycy5yYXRlZSB8fCAndHVuZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzY29wZS5yYXRlZSA9IHJhdGVlO1xuICAgICAgICAgICAgc2NvcGUuY29sb3VyaW5ncyA9IGNvbG91cmluZ3M7XG4gICAgICAgICAgICBzY29wZS51cGRhdGVQZXJmb3JtYW5jZSA9IGZ1bmN0aW9uIChyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICByYXRlZS5kdW1teVN0YW5kYXJkID0gcmF0aW5nO1xuICAgICAgICAgICAgICAgIGF0dHJzLmNhbGxiYWNrID8gc2NvcGVbYXR0cnMuY2FsbGJhY2tdKCkgOiByYXRlZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BlcmZvcm1hbmNlLXJhdGVyJyk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4iLCJyZXF1aXJlKCdzcmMvdHVuZS91aS90dW5lLXN0YXQtc3VtbWFyeScpO1xuXG5yZXF1aXJlKCdhbmd1bGFyJykubW9kdWxlKCdqbnIudHVuZScpLmRpcmVjdGl2ZSgnalR1bmVIZWFkaW5nJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgLy8gdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgIHRlbXBsYXRlVXJsOiAnL3NyYy90dW5lL3RwbC90dW5lLWhlYWRpbmcuaHRtbCcsXG4gICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgIHZhciB0dW5lID0gc2NvcGVbYXR0cnMudHVuZSB8fCAndHVuZSddO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNjb3BlLnR1bmUgPSB0dW5lLnR1bmU7XG4gICAgICAgICAgICAgICAgc2NvcGUuYXJyYW5nZW1lbnQgPSB0dW5lLmFycmFuZ2VtZW50O1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5zdGF0cykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5zdGF0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3R1bmUtaGVhZGluZycpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnc3JjL2NvbW1vbi9kYXRhL2Ryb3Bkb3ducycpO1xuXG4gXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGpEcm9wZG93bnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnJztcblxuICAgICAgICBpZiAoaW5wdXQucmF0aW5nICE9PSAtMSB8fCBpbnB1dC5wb3B1bGFyaXR5ICE9PSAtMSkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSAnQSAnO1xuICAgICAgICAgICAgaWYgKGlucHV0LnJhdGluZyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGpEcm9wZG93bnMucmF0aW5nW2lucHV0LnJhdGluZyAtIDFdLmxhYmVsLnRvTG93ZXJDYXNlKCkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXQucG9wdWxhcml0eSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGpEcm9wZG93bnMucG9wdWxhcml0eVtpbnB1dC5wb3B1bGFyaXR5XS5sYWJlbC50b0xvd2VyQ2FzZSgpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSArPSAndHVuZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbn07XG4iXX0=
